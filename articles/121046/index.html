<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basics of LibCanvas - Theory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. One of the most common questions about LibCanvas now is ‚ÄúWhere to start?‚Äù. I agree that the threshold for entering this library is slightly ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basics of LibCanvas - Theory</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/fe2/876/c13/fe2876c137ad5e0e0bdd56850ce79972.png"><br><br>  Good day.  One of the most common questions about LibCanvas now is ‚ÄúWhere to start?‚Äù.  I agree that the threshold for entering this library is slightly higher than in simpler canvas libraries, so in this topic I will cover the basics of LibCanvas - basic concepts and principles, drawing primitive figures, mouse events, keyboards, animation, advanced context, behaviors.  I will try to describe all this with a lot of examples and the most accessible language. <br><br>  I hope the article will provide answers to the questions: What is LibCanvas?  Why is it needed and what are its advantages?  Where to begin? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article there will be only a theory, and how to apply this knowledge in practice is <a href="http://habrahabr.ru/blogs/canvas/121047/">revealed in the next article.</a> <br><a name="habracut"></a><br><h2>  General information </h2><br>  LibCanvas is a framework for working with Canvas and related technologies that can be used to develop games and other interactive applications. <br><br>  It is built on the basis of <a href="https://github.com/theshock/atomjs">AtomJS</a> - a lightweight JavaScript framework, something similar to MooTools and jQuery.  There is quite good <a href="https://github.com/theshock/atomjs/tree/master/Docs">English documentation AtomJS</a> and, if you have used MooTools before, then you will just have to master AtomJS. <br><br>  The latest version of LibCanvas can be obtained <a href="https://github.com/theshock/libcanvas">in the repository</a> , on GitHub there are also a <a href="http://libcanvas.github.com/">number of relevant examples</a> from very simple to fairly complex.  Many principles can be understood by studying these examples.  There is <a href="https://github.com/theshock/libcanvas/tree/master/Docs/Ru">Russian documentation</a> , but many parts of LibCanvas are not covered in it yet.  Over time, it will be filled and expanded.  I hope someone will help me with the translation into English) <br><br><h2>  Core </h2><br>  All code is stored in the LibCanvas namespace.  This is good because the library does not litter the global namespace.  However, there is a drawback - a rather verbose syntax in the end: <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> circle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LibCanvas.Shapes.Circle( <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> circle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LibCanvas.Shapes.Circle( <span class="hljs-number"><span class="hljs-number">222</span></span>, <span class="hljs-number"><span class="hljs-number">222</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span> );</code> </pre> <br><br>  This can be fixed using the static method LibCanvas.extract ().  It globalizes LibCanvas itself so that you can use short class names in your application: <br><pre> <code class="javascript hljs">LibCanvas.extract(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> circle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Circle( <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> circle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Circle( <span class="hljs-number"><span class="hljs-number">222</span></span>, <span class="hljs-number"><span class="hljs-number">222</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span> );</code> </pre><br><br>  Another alternative is to use aliases: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Circle = LibCanvas.Shapes.Circle; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> circle1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Circle( <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> circle2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Circle( <span class="hljs-number"><span class="hljs-number">222</span></span>, <span class="hljs-number"><span class="hljs-number">222</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span> );</code> </pre><br><br><h2>  LibCanvas.Context2D </h2><br>  There is an embedded LibCanvas context.  It is very easy to call: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].getContext(<span class="hljs-string"><span class="hljs-string">'2d-libcanvas'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// or: var context = atom.dom('canvas').first.getContext('2d-libcanvas');</span></span></code> </pre><br><br>  Please note that the original "2d" context is still available and not touched, so it can be safely used in your applications: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = atom.dom(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>).first.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>);</code> </pre><br><br>  The '2d-libcanvas' context is backward compatible with the original context (all code written for the '2d' context will work in the context of '2d-libcanvas'), but it has the following advantages: <br>  1. <b>Chainable</b> - all methods can be called as a chain.  This method has become particularly popular with the advent of jQuery: <br><pre> <code class="javascript hljs">context .set({ <span class="hljs-attr"><span class="hljs-attr">fillStyle</span></span>: <span class="hljs-string"><span class="hljs-string">'black'</span></span>, <span class="hljs-attr"><span class="hljs-attr">strokeStyle</span></span>: <span class="hljs-string"><span class="hljs-string">'red'</span></span> }) . fillRect(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>) .strokeRect(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br><br>  2. <b>Named arguments</b> - now you can pass not just a set of characters, but a hash: <br><pre> <code class="javascript hljs">context.drawImage(img, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>); <span class="hljs-comment"><span class="hljs-comment">// vs context.drawImage({ image: img, crop : [10, 15, 40, 45], draw : [20, 25, 50, 50] });</span></span></code> </pre><br><br>  3. <b>Figures</b> - you can transfer figures, not numbers.  This is especially convenient when you have a large application with objects created: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  : context.drawImage( image, rect.from.x, rect.from.y, rect.width, rect.height ); // vs context.drawImage( image, rect ); //      : context.save(); context.fillStyle = 'red'; context.fillRect( rect.from.x, rect.from.y, rect.width, rect.height ) context.restore(); // vs: context.fill( rect, 'red' );</span></span></code> </pre><br><br>  4. <b>Expansion API</b> - there is a whole series of amenities.  First, more convenient work with paths, text, pictures, transformations, etc: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      ,   : // original ctx: context.save(); context.translate(this.position.x, this.position.y); context.rotate(this.angle); context.translate(-this.image.width/2, -this.image.height/2); context.drawImage(this.image, 0, 0); context.restore(); // vs context.drawImage({ image : this.image, center: this.position, angle : this.angle }); // : context.text({ text: 'Test string \n with line breaks \n is here' padding: [ 30, 50 ], size: 20, align: 'center' }) //    : context.translate( point.x, point.y); context.rotate(angle); context.translate(-point.x, -point.y); // vs: context.rotate( angle, point ); //   context.beginPath( ); context.moveTo( mt.x, mt.y ); context.lineTo( lt.x, lt.y ); context.bezierCurveTo( bc1.x, bc1.y, bc2.x, bc2.y, bc.x, bc.y ); context.quadraticCurveTo( qc1.x, qc1.y, qc.x, qc.y ); context.closePath(); // vs context .beginPath( mt ) .lineTo( lt ); .curveTo( bc, bc1, bc2 ) .curveTo( qc, qc1 ) .closePath(); //  : var circle = new Circle( 130, 120, 50 ); context.beginPath(); context.arc( circle.center.x, circle.center.y, circle.radius, 0, Math.PI * 2 ); context.closePath(); context.clip(); // vs: context.clip( circle ); //   : context.clear( 0, 0, canvas.width, canvas.height ); // vs context.clearAll();</span></span></code> </pre><br><br>  And so on.  I think you yourself can see the convenience of the inline context. <br><br><h2>  LibCanvas object </h2><br>  When constructing LibCanvas, a LibCanvas.Canvas2D object is created.  The first argument is to pass a reference to the desired canvas element (css-selector, dom-object, etc).  The second one can transfer additional settings - limit fps, cleaning before redrawing, preloading of pictures <a href="">and others</a> . <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> libcanvas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LibCanvas(<span class="hljs-string"><span class="hljs-string">'#my-canvas'</span></span>); libcanvas <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> LibCanvas; <span class="hljs-comment"><span class="hljs-comment">// true libcanvas instanceof LibCanvas.Canvas2D; // true //      : libcanvas.ctx instanceof LibCanvas.Context2D; // true</span></span></code> </pre><br><br>  Each frame consists of two stages.  The first is data miscalculation.  It is executed every time and is solely responsible for mathematical operations - the movement of objects, collisions, etc.  There should be no redraw in this layer.  The second stage is the render.  It contains the part that is responsible for redrawing the contents of the screen and it will be executed only in case of any changes on the screen.  This can be reported at the miscalculation stage by calling the <code>libcanvas.update()</code> method. <br><br>  You can add a function to the rendering stage using the <code>libcanvas.addRender()</code> method, you can add a function to the render phase using the <code>libcanvas.addRender()</code> method.  Also, at the render stage, the draw methods of the transferred objects are invoked.  Approximately the code looks like this: <br><br><pre> <code class="javascript hljs">libcanvas .addFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ scene.recount(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scene.somethingChanged()) { libcanvas.update(); } }) .addRender(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      libcanvas.update(); scene.drawAll(); });</span></span></code> </pre><br><br>  A lot of applications are static most of the time with redrawing only at the moments of user action.  This will help to significantly reduce the unnecessary load on the processor. <br><br>  In practice, <code>addRender</code> is rarely used, since  It is very convenient to draw objects using the <code>draw()</code> method (see below). <br><br>  Always redraw something on the screen only when changes are present.  In many applications, such a basic mechanism will not be enough, but it is better than nothing. <br><br><h2>  Point </h2><br>  <a href=""><code>LibCanvas.Point</code></a> is one of the basic objects.  It is used very often, is a component of all the figures and is <a href="http://libcanvas.github.com/shapes/point.html">very convenient to use outside of them</a> .  It has methods for determining the distance between two points, the angle, the point multiplication, and also getting all the neighbors. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   A  60    B: var A = new Point(10, 10), B = new Point(20, 20); A.rotate( (60).degree(), B ); //        : var sum = 0 + matrix[py-1][px-1] + matrix[py-1][px] + matrix[py-1][p.x+1] + matrix[py ][px-1] + matrix[py ][p.x+1] + matrix[p.y+1][px-1] + matrix[p.y+1][px] + matrix[p.y+1][p.x+1] ; // vs var sum = point.neighbours.reduce(function(value, p) { return value + matrix[py][px]; }, 0);</span></span></code> </pre><br><br><h2>  Figures </h2><br>  The figures are contained in the namespace <code>LibCanvas.Shapes.*</code> And globalize to short aliases.  The most famous shapes are <code>Rectangle</code> , <code>Circle</code> , <code>Line</code> .  When using LibCanvas, you must realize that the figures themselves do not have an appearance, they cannot have an appearance ‚Äî color or shadow.  An object that uses a shape, such as LibCanvas.Ui.Shaper, is responsible for the appearance, while the figures themselves contain only mathematical operations - how to pass the path, intersections, whether the point is inside the shape, etc.  They are the astral, but not the physical body. <br><br>  This allows you to separate the behavior from the appearance.  For example, we have a board in Arkanoid.  In fact, this is a picture, but we can perform all the actions as with a simple figure: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Unit = atom.Class({ <span class="hljs-attr"><span class="hljs-attr">initialize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rectangle, image</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shape = rectangle; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.image = image; }, <span class="hljs-attr"><span class="hljs-attr">collision</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">anotherUnit</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shape.intersect( anotherUnit.shape ); }, <span class="hljs-attr"><span class="hljs-attr">draw</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.libcanvas.ctx.drawImage( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.image, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shape ); } });</code> </pre><br><br>  <a href=""><code>Rectangle</code></a> is the most important shape.  It is used not only during drawing rectangles and basic mathematical operations, but also in many methods of LibCanvas.  This could be, for example, the context.drawImage method, which takes arguments to cut and draw a rectangle or a tile engine, in which each element is a small Rectangle. <br><br>  When a method needs a Rectangle-like argument, it can take any argument that looks like a rectangle.  For example: <br><pre> <code class="javascript hljs">context.drawImage({ <span class="hljs-attr"><span class="hljs-attr">image</span></span>: image, <span class="hljs-attr"><span class="hljs-attr">crop</span></span>: { <span class="hljs-attr"><span class="hljs-attr">from</span></span>: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> }, <span class="hljs-attr"><span class="hljs-attr">size</span></span>: { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">draw</span></span>: [<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">200</span></span>] });</code> </pre><br><br>  In this case, crop and draw will be brought inside to the Rectangle (or to another required shape), but from the point of view of performance (when repeatedly redrawing the canvas), as well as from the point of view of the application architecture, the most profitable method is to create all the objects during initialization applications.  This decision was made specifically to promote good architecture. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Item = atom.Class({ <span class="hljs-attr"><span class="hljs-attr">initialize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.image = image; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cropRect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.drawRect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">draw</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ context.drawImage({ <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.image, <span class="hljs-attr"><span class="hljs-attr">crop</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cropRect, <span class="hljs-attr"><span class="hljs-attr">draw</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.drawRect }); } });</code> </pre><br><br>  Other figures are similarly used: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// : context.arc({ circle: new Circle( 100, 100, 50 ), angle : [ (45).degree(), (135).degree() ] }); //  : context.stroke( new Line([13, 13], [42, 42]), 'red' );</span></span></code> </pre><br><br><h2>  Behavior </h2><br>  The next part is <a href="https://github.com/theshock/libcanvas/tree/master/Docs/Ru/Classes/Behaviors"><code>LibCanvas.Behaviors.*</code></a> .  Each of them is just <a href="http://ru.wikipedia.org/wiki/Mixin">an admixture</a> that adds to your class a certain functionality or behavior.  For example, <code>Animatable</code> adds the <code>animate</code> method which allows you to change the properties of an object smoothly, and <code>Drawable</code> allows objects of your class to be added to the LibCanvas object for drawing. <br><br>  By the way, Drawable is the basis for drawing in LibCanvas.  A blend of Drawable and Shapes. * Allows you to draw any shape onto a canvas, and adding other behaviors will give this shape additional functionality. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Item = atom.Class({ <span class="hljs-attr"><span class="hljs-attr">Implements</span></span>: [ Drawable, Draggable ], <span class="hljs-attr"><span class="hljs-attr">initialize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">shape</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shape = shape; }, <span class="hljs-attr"><span class="hljs-attr">draw</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.libcanvas.ctx.stroke( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shape, <span class="hljs-string"><span class="hljs-string">'red'</span></span> ); } }); libcanvas.addElement( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Item( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>) ).draggable() );</code> </pre><br><br>  In fact, a similar pattern for drawing figures had to be created quite often, because <code>Ui.Shaper</code> already implemented: <br><br><pre> <code class="javascript hljs">libcanvas.createShaper({ <span class="hljs-attr"><span class="hljs-attr">shape</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-attr"><span class="hljs-attr">stroke</span></span>: <span class="hljs-string"><span class="hljs-string">'red'</span></span> }).draggable();</code> </pre><br><br><h2>  Klava and mouse </h2><br>  Working with the keyboard is quite simple.  When initializing an application, it is enough to call the <code>libcanvas.listenKeyboard()</code> method and you can use the <code>libcanvas.getKey( keyName )</code> method, if necessary, to find out the state of the key: <br><br><pre> <code class="javascript hljs">update: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.libcanvas.getKey(<span class="hljs-string"><span class="hljs-string">'aup'</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.move(); } }</code> </pre><br><br>  Working with the mouse is worth parsing.  Firstly, if you want to use the mouse in your application, be sure to call the <code>libcanvas.listenMouse()</code> method.  In order to optimize, mouse events are not analyzed before it is called, because there are applications that do not need a mouse.  After that, you can easily subscribe to mouse events by adding an element to the Mouse object: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.libcanvas.mouse.subscribe( element );</code> </pre><br><br>  It is important that the value of the element's shape property is one of the shapes ( <code>LibCanvas.Shapes.*</code> ), The zIndex property is and it has implemented the class <code>atom.Class.Events</code> .  In practice, all this is hidden behind the behaviors and when you call, for example, the <code>draggable()</code> method of the <code>Draggable</code> behavior, the object automatically subscribes to mouse events.  If you only need to listen to mouse events, then it is sufficient to implement the <code>MouseListener</code> behavior and call the <code>listenMouse</code> method.  However, the most important thing is still the element - the element must have the <code>Shape</code> property with some figure inside.  When mouse events on your object are being listened to, you can subscribe to any of the following events: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* - click - mouseover - mousemove - mouseout - mouseup - mousedown - away:mouseover - away:mousemove - away:mouseout - away:mouseup - away:mousedown */</span></span> <span class="hljs-comment"><span class="hljs-comment">// : element .listenMouse() .addEvent('click', function () { alert('element clicked'); });</span></span></code> </pre><br><br><h2>  Conclusion </h2><br>  I described here the basics of the theoretical part of the development on LibCanvas.  It does not reveal many interesting features and principles, but its goal is to explain the ideology and show the reader where to start. <br><br>  The topic of the next article is a <a href="http://habrahabr.ru/blogs/canvas/121047/">practical part of the development on LibCanvas</a> . </div><p>Source: <a href="https://habr.com/ru/post/121046/">https://habr.com/ru/post/121046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../121036/index.html">ZTE Skate comes out - brother of Orange San Francisco</a></li>
<li><a href="../121037/index.html">Mobile guide to Moscow shopping centers for iOS and Android</a></li>
<li><a href="../121038/index.html">How to choose a co-founder</a></li>
<li><a href="../121041/index.html">Fake URL shortening services - an innovation of the Runet</a></li>
<li><a href="../121045/index.html">We are finalizing the video card. By file</a></li>
<li><a href="../121047/index.html">LibCanvas basics - practice</a></li>
<li><a href="../121048/index.html">Startup Jobs by PRUFFI (June 6-10)</a></li>
<li><a href="../121052/index.html">Spam karma wrap offer</a></li>
<li><a href="../121053/index.html">Typical errors on web-studio own sites</a></li>
<li><a href="../121054/index.html">$ 4.7 billion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>