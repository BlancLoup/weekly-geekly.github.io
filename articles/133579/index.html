<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hasof endofunctors and their monoidal structure</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In the previous article, I talked about the concepts of a category and a functor in the context of the Hask category, which consists of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hasof endofunctors and their monoidal structure</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  In the <a href="http://habrahabr.ru/blogs/Haskell/133277/">previous article,</a> I talked about the concepts of a category and a functor in the context of the <b>Hask</b> category, which consists of data types and functions of the Haskell language.  Now I want to talk about another example of a category, built from concepts already known to us, as well as a very important concept of a monoid. <br><br><h2>  Designations </h2><br>  Last time I wanted to denote a morphism / function with the letter <code>f</code> , but it was used to designate a functor / variable of type <code>f</code> - there is no problem from the point of view of Haskell, but with inattentive reading this can be confusing, and I used the letter for morphism <code>g</code> .  A trifle, but still, I believe that it is useful to visually separate entities that have different nature.  I will call ordinary types by their usual names, but I will call variable types of small Greek letters, simple ( <code>‚àó</code> ) - letters from the beginning of the alphabet, and parametric ( <code>‚àó ‚Üí ‚àó</code> ) - letters from the end of the alphabet ( <code>Œ∏</code> not from the end, but it looks better than <code>œá</code> , which is too similar to <code>X</code> ).  So, in the terminology category <b>Hask</b> : <br><ul><li>  Objects: <code>Œ±, Œ≤, Œ≥, Œ¥ ‚à∑ ‚àó</code> </li><li>  Functors: <code>Œ∏, œÜ, œà, œâ ‚à∑ ‚àó ‚Üí ‚àó</code> </li><li>  Morphisms: <code>f, g, h ‚à∑ Œ± ‚Üí Œ≤</code> </li></ul>  Due to the fact that GHC supports unicode for a long time, these designations do not change anything in terms of syntax and are purely cosmetic. <br><br>  One more remark about the terminology: as you have already noted, what I called the word ‚Äúkind‚Äù last time, I now call it the word ‚Äúvariety‚Äù - this is considered a generally accepted translation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Hask category </h2><br>  Let's consider a category in which there will be only one object ‚Äî the <b>Hask</b> category <b>itself</b> .  What will be the morphisms in this category?  There must be some <b>Hask</b> ‚Üí <b>Hask maps</b> , and we already know this type of maps ‚Äî these are endofunctors of the <b>Hask</b> category, that is, the types <code>‚àó ‚Üí ‚àó</code> class <code>Functor</code> .  Now you need to think about how a single morphism and composition are arranged in this category, so that they satisfy the axioms. <a name="habracut"></a><br><br><h3>  Identical functor </h3><br>  As an identity morphism, it is natural to choose an identical functor, that is, a functor that does not change anything.  Haskell has no special designation for it - since it doesn‚Äôt do anything, why designate it somehow?  I will introduce a ‚Äúdummy‚Äù type constructor with which it will be possible to ‚Äúvisualize‚Äù the action of this functor on objects of the <b>Hask</b> category: <br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Œ±</span></span></span><span class="hljs-class"> </span></span>= Œ±</code> </pre><br>  In Haskell, you cannot declare incarnations for type synonyms; therefore, <code>Id</code> cannot be entered completely like other functors, but if we could, we would write this: <br><pre> <code class="hljs mel">-- <span class="hljs-keyword"><span class="hljs-keyword">warning</span></span>: - <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> Functor Id where fmap ‚à∑ (Œ± ‚Üí Œ≤) ‚Üí (Id Œ± ‚Üí Id Œ≤) fmap f = f</code> </pre>  That is, the behavior of this functor on morphisms is determined trivially: <code>fmap ‚â° id ‚à∑ (Œ± ‚Üí Œ≤) ‚Üí (Œ± ‚Üí Œ≤)</code> - there is no <code>Id</code> constructor here, but this is the same signature.  So, two mappings of the functor look like this: <br><pre> <code class="hljs objectivec">Œ± ‚à∑ ‚àó ‚Ü¶ Id Œ± = Œ± ‚à∑ ‚àó f ‚à∑ Œ± ‚Üí Œ≤ ‚Ü¶ <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> f = f ‚à∑ Œ± ‚Üí Œ≤</code> </pre><br>  Although this functor seems useless, we need it to complete the definition of a category.  In addition, it makes it possible to perceive any type <code>Œ± ‚à∑ ‚àó</code> as <code>Id Œ± ‚à∑ ‚àó</code> , that is, under the action of an identical functor ‚Äî this is also useful when we meet with monads. <br><br><h3>  Composition of functors </h3><br>  In the category we are considering, now the composition of morphisms (endofunctors) is lacking.  Since we consider morphisms on the same object, they all have the same region and co-region, so we know a priori that the composition applies to any two morphisms. <br><br>  Let's start with an example.  Consider two known functors: <code>Maybe</code> and <code>[]</code> .  Here is how they act on objects: <br><pre> <code class="hljs css">Œ± ‚à∑ ‚àó ‚Ü¶ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Maybe</span></span> Œ± ‚à∑ ‚àó Œ≤ ‚à∑ ‚àó ‚Ü¶ <span class="hljs-selector-attr"><span class="hljs-selector-attr">[Œ≤]</span></span> ‚à∑ ‚àó</code> </pre><br>  Composition means that we first apply one mapping, and the second is what came out: <br><pre> <code class="hljs css">Œ± ‚Ü¶ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Maybe</span></span> Œ± ‚Ü¶ <span class="hljs-selector-attr"><span class="hljs-selector-attr">[Maybe Œ±]</span></span></code> </pre>  Or in a different order: <br><pre> <code class="hljs css">Œ± ‚Ü¶ <span class="hljs-selector-attr"><span class="hljs-selector-attr">[Œ±]</span></span> ‚Ü¶ <span class="hljs-selector-tag"><span class="hljs-selector-tag">Maybe</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[Œ±]</span></span></code> </pre>  In order to apply the composition to type constructors, nothing special is needed - just write first one, then the other.  For this operation, we introduce a notation similar to the usual composition (the type constructor in the form of an operator must begin with a colon, and I put the second just for symmetry): <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> (œÜ :.: œà) Œ± = œÜ (œà Œ±)</span></span></code> </pre><br>  Now let's see what with the display of morphisms.  Since for any functor this map has the name <code>fmap</code> , we can say in general that we need to apply one <code>fmap</code> to the morphism first, and then the second, that is, the display of the composition of functors will be: <code>Œªf ‚Üí fmap (fmap f)</code> or simply <code>fmap . fmap</code>  <code>fmap . fmap</code> .  It should be understood that these two <code>fmap</code> are different manifestations of the same polymorphic function - each has its own type and corresponding definition.  Let's demonstrate this clearly: <br><pre> <code class="hljs kotlin">instance Functor Maybe <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> -- fmap ‚à∑ (Œ± ‚Üí Œ≤) ‚Üí (Maybe Œ± ‚Üí Maybe Œ≤) fmap f = f<span class="hljs-string"><span class="hljs-string">' where f'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span> f<span class="hljs-string"><span class="hljs-string">' (Just x) = Just (fx) instance Functor [] where -- fmap ‚à∑ (Œ± ‚Üí Œ≤) ‚Üí ([Œ±] ‚Üí [Œ≤]) fmap g = g'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> g<span class="hljs-string"><span class="hljs-string">' [] = [] g'</span></span> (x:xs) = (gx) : (g<span class="hljs-string"><span class="hljs-string">' xs)</span></span></code> </pre><br>  Now consider the composition of the example: <code>[] :.: Maybe</code> <br><pre> <code class="hljs pgsql">(fmap . fmap) ‚à∑ (Œ± ‚Üí Œ≤) ‚Üí ([Maybe Œ±] ‚Üí [Maybe Œ≤]) (fmap . fmap) even [Just <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span>, Just <span class="hljs-number"><span class="hljs-number">3</span></span>] ‚â° [Just <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span>, Just <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>]</code> </pre><br>  And in a different order: <code>Maybe :.: []</code> <br><pre> <code class="hljs pgsql">(fmap . fmap) ‚à∑ (Œ± ‚Üí Œ≤) ‚Üí (Maybe [Œ±] ‚Üí Maybe [Œ≤]) (fmap . fmap) even Just [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] ‚â° Just [<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>] (fmap . fmap) even <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span> ‚â° <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre><br>  If we wanted to make the composition of functors the embodiment of the class <code>Functor</code> , we would do it approximately as the authors of the <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TypeCompose">TypeCompose</a> package <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TypeCompose">do</a> .  I, however, do not see much point in this, since I have to wrap the values ‚Äã‚Äãin an additional data constructor.  So, if we talk about functors as pairs of maps (on objects and morphisms), then for two functors <code>(œÜ, fmap</code> <sub><code>œÜ</code></sub> <code>)</code> and <code>(œà, fmap</code> <sub><code>œà</code></sub> <code>)</code> , their composition will be such a pair of maps: <code>(œÜ :.: œà, fmap</code> <sub><code>œÜ</code></sub> <code>. fmap</code> <code>)</code> , i.e. <br><br> <code>Œ± ‚à∑ ‚àó ‚Ü¶ (œÜ :.: œà) Œ± ‚à∑ ‚àó</code> <br>  <code>f ‚à∑ Œ± ‚Üí Œ≤ ‚Ü¶ (fmap</code> <sub><code>œÜ</code></sub> <code>. fmap</code> <sub><code>œà</code></sub> <code>) f ‚à∑ (œÜ :.: œà) Œ± ‚Üí (œÜ :.: œà) Œ≤</code> <br><br>  Formally, it is necessary to check that this pair of mappings is itself an endofunctor of the <b>Hask</b> category, that is, it keeps a single morphism and a composition of morphisms in it, but since one <code>fmap</code> saves, then two successively applied <code>fmap</code> will save: <br><pre> <code class="hljs objectivec">(fmap . fmap) <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ‚â° fmap (fmap <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ‚â° fmap <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ‚â° <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> (fmap . fmap) (f . g) ‚â° ‚â° fmap (fmap (f . g)) ‚â° ‚â° fmap ((fmap f) . (fmap g)) ‚â° ‚â° (fmap (fmap f)) . (fmap (fmap g)) ‚â° ‚â° ((fmap . fmap) f) . ((fmap . fmap) g)</code> </pre>  Q.E.D.  The composition of functors, as well as the identical functor, is a natural and simple construction, but nevertheless useful, and we will need it again when we get to the monads. <br><br>  So, to build a category with the <b>Hask</b> object and endofunctors as morphisms, it remains to check two axioms: <br><ul><li>  Associativity of composition <br><pre> <code class="hljs css"> ((œÜ <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:.</span></span>: œà) <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:.</span></span>: œâ) Œ± ‚â° (œÜ <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:.</span></span>: œà) (œâ Œ±) ‚â° ‚â° œÜ (œà (œâ Œ±)) ‚â° ‚â° œÜ ((œà <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:.</span></span>: œâ) Œ±) ‚â° (œÜ <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:.</span></span>: (œà <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:.</span></span>: œâ)) Œ±</code> </pre>  The action on morphisms <code>(fmap</code> <sub><code>œÜ</code></sub> <code>. fmap</code> <sub><code>œà</code></sub> <code>)</code> is a common composition, we have already tested its associativity last time. </li><li>  Neutrality of a single morphism <br><pre> <code class="hljs objectivec"> (œÜ :.: Id) Œ± ‚â° œÜ (Id Œ±) ‚â° œÜ Œ± ‚â° Id (œÜ Œ±) ‚â° (Id :.: œÜ) Œ± fmap . <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ‚â° <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ‚â° <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> . fmap</code> </pre></li></ul>  Everything is good! <br><br><h2>  Monoid structure </h2><br>  In fact, our acquaintance with monoids has already taken place, since the category described above is a monoid.  Let's filter out redundant information about it and leave only the definition: <br><blockquote>  <i>A monoid is a category with one object.</i> <br></blockquote><br>  Just like that.  From this formulation it becomes immediately clear why he has such a name: ‚Äúmono‚Äù means ‚Äúone‚Äù. <br><br>  I will give one more example of a category monoid.  Consider a subcategory of the <b>Hask</b> category, with one <code>Int</code> .  As morphisms, we take the following functions: <code>Œªn ‚Üí n + k</code> or shortly <code>(+k)</code> for each <code>k ‚à∑ Int</code> , that is <code>(+(-1))</code> , <code>(+7)</code> , <code>(+100500)</code> , etc.  Together with the usual composition and <code>(+0) ‚â° id</code> , the category is obtained.  One can imagine all <code>Int</code> type values ‚Äã‚Äãon the number line and the action of these morphisms on them as follows: <br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">Int</span></span>: ‚Ä¶ <span class="hljs-number"><span class="hljs-number">-5</span></span> <span class="hljs-number"><span class="hljs-number">-4</span></span> <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">-2</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Ä¶ (+(<span class="hljs-number"><span class="hljs-number">-2</span></span>)) ‚à∑ ‚Üë ‚Üë ‚Üë ‚Üë ‚Üë ‚Üë ‚Üë ‚Üë <span class="hljs-type"><span class="hljs-type">Int</span></span>: ‚Ä¶ <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">-2</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ‚Ä¶ (+<span class="hljs-number"><span class="hljs-number">3</span></span>) ‚à∑ ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì ‚Üì <span class="hljs-type"><span class="hljs-type">Int</span></span>: ‚Ä¶ <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> ‚Ä¶</code> </pre>  That is, visually, these are shifts of the origin ( <code>0</code> ) by a specified number of positions, although in general the numerical line remains the same.  What the category structure gives us: firstly, there is a single morphism that leaves everything in place, secondly, there is a composition of morphisms, it is associative and <code>id</code> neutral with respect to it.  If <code>m</code> and <code>n</code> are two integers, then the composition is as follows: <br><pre> <code class="hljs">(+m) . (+n) ‚â° (+(m+n))</code> </pre>  That is, in fact, it acts as a sum.  You can think of each morphism <code>(+m)</code> as simply the number <code>m</code> (where we moved the origin: <code>(+m) 0 ‚â° m</code> ), then the ‚Äúcomposition‚Äù <code>m</code> and <code>n</code> is really their sum: <code>(m+n)</code> , and a single morphism is simply zero. <br><br>  This view corresponds to the set-theoretic definition of a monoid: <br><blockquote>  <i>A monoid is a triple consisting of a set, an associative binary operation on this set and an element neutral with respect to this operation.</i> <br></blockquote><br>  In this example, this is such a triple: <code>(Int, (+), 0)</code> . <br><pre> <code class="hljs">(l + m) + n ‚â° l + (m + n) m + 0 ‚â° m ‚â° 0 + m</code> </pre><br>  In this definition, the axioms of the category are simply reformulated: a set is a set of morphisms, an associative binary operation is a composition of morphisms, and a neutral element is a single morphism.  It is important to understand that from whatever side we look at the structure of the monoid, the main thing is the <b>associativity of the binary operation</b> and the <b>presence of a neutral element</b> . <br><br>  Now let's look at the <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html"><code>Monoid</code></a> class in Haskell: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> Œº </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> mappend ‚à∑ Œº ‚Üí Œº ‚Üí Œº mempty ‚à∑ Œº</code> </pre>  where <code>Œº</code> is the considered set, <code>mappend</code> is an operation that must be associative, <code>mempty</code> is an element that must be neutral with respect to <code>mappend</code> .  For a triple <code>(Int, (+), 0)</code> embodiment of this class will be immediate: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> mappend = (+) mempty = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Similarly for any other triple, for example <code>(Float, (*), 1)</code> or <code>([Œ±], (++), [])</code> or <code>(Bool, (||), False)</code> , where <code>||</code>  - logical ‚Äúor‚Äù.  But we can also implement a categorical definition, once again demonstrating their connection: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mor</span></span></span><span class="hljs-class"> Œ± = Œ± ‚Üí Œ± instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mor</span></span></span><span class="hljs-class"> Œ±) where mappend = (.) mempty = id</span></span></code> </pre>  In this case, the type <code>Œ± ‚à∑ ‚àó</code> is an object of category <b>Hask</b> , functions of type <code>Mor Œ±</code> are morphisms on this object.  Together with the usual composition and single morphism <code>id</code> they form a category with one object, that is, a monoid. <br><br>  The <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html"><code>Data.Monoid</code></a> module has a similar incarnation for the <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html"><code>Endo</code></a> type.  By the way, almost all incarnations in this module are made for types ‚Äúin wrappers‚Äù.  This is done because on the same set a monoidal structure can be introduced in different ways.  For example, for the type <code>Int</code> , besides the considered structure <code>(Int, (+), 0)</code> (cf. <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html"><code>Sum</code></a> ), one can also consider <code>(Int, (*), 1)</code> (cf. <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html"><code>Product</code></a> ), and for the type <code>Bool</code> besides the one mentioned <code>(Bool, (||), False)</code> (see <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html"><code>Any</code></a> ) is <code>(Bool, (&amp;&amp;), True)</code> (see <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html"><code>All</code></a> ). <br><br>  A lot of examples of such triples-monoids can be found in the habr-article <a href="http://habrahabr.ru/blogs/algorithm/112394/">"Monoids and their applications: monoidal calculations in trees</a> . <a href="http://habrahabr.ru/blogs/algorithm/112394/">"</a>  In addition, on the use of monoids in Haskell, you can read the <a href="http://fprog.ru/2009/issue1/dan-piponi-haskell-monoids-and-their-uses/">article-translation</a> in the journal <a href="http://fprog.ru/">Practice of Functional Programming</a> .  Well, if it's completely sad without pictures, there is a <a href="http://arsanukaev.blogspot.com/2011/09/monoid.html">translation of the chapter on monoids</a> from the textbook <a href="http://nostarch.com/lyah.htm">Learn You a Haskell for Great Good!</a> <br><br><h2>  Conclusion </h2><br>  It may seem to the reader that I have turned everything upside down with these different definitions of a monoid, but I just wanted to show that the structure itself is important, and not what it is built on: on the elements of a set, morphisms of a category or on something else . <br><br>  In fact, in this whole theory we are talking about different types of arrows (mappings, transformations).  You can identify objects with single morphisms and not talk more about objects in further constructions (only indexing of single morphisms is needed as a designation, and the area and range of morphisms are needed only for the correct construction of the composition). <br><br>  We already know about morphisms, as about arrows between objects, we know about functors, as about arrows between categories.  <i>And what is the nature of arrows between functors?</i>  Such arrows are called natural transformations (natural transformations) and I will tell about them next time. <br><br>  Summing up this article, I want to repeat the main concepts reviewed and link them together: <br><blockquote>  <b>The endofunctors of the Hask category <b>,</b> along with the composition of functors and the identical functor, have a monoid structure</b> <br></blockquote><br>  This key phrase will be extremely useful to us when it comes to the (strictly) monoidal category, which we construct from functors and natural transformations. </div><p>Source: <a href="https://habr.com/ru/post/133579/">https://habr.com/ru/post/133579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133569/index.html">ListView in Android: Simple to use</a></li>
<li><a href="../133575/index.html">ListView in Android: Customizing Lists</a></li>
<li><a href="../133576/index.html">Do you use other markets to publish your apps besides Android Market?</a></li>
<li><a href="../133577/index.html">Micromouse - competition for small robots</a></li>
<li><a href="../133578/index.html">We use "Yandex Music" outside the browser</a></li>
<li><a href="../133582/index.html">Who is a "good programmer"?</a></li>
<li><a href="../133583/index.html">St. Petersburg habravstrecha: Floors</a></li>
<li><a href="../133586/index.html">Qt Quick and Box2d: Simulate Physics</a></li>
<li><a href="../133587/index.html">Preorder for ¬µTorrent Plus open</a></li>
<li><a href="../133588/index.html">Moscow Rescue Service will not reach the age of majority?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>