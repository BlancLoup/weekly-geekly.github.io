<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does a computer play chess?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hikaru Nakamura, who recently challenged a computer 

 The computer has long won a man of chess, now the strongest chess players are not able to win e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does a computer play chess?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/85e/fcf/1ca/85efcf1cae994ade85219b1e4915d0a7.jpg"><br>  <i>Hikaru Nakamura, who recently challenged a computer</i> <br><br>  The computer has long won a man of chess, now the strongest chess players are not able to win even an old laptop.  Now, chess engines are used to analyze the games, search for new variants and play correspondence. <br><br>  If it is interesting to you how chess engines are arranged - welcome under kat. <br><a name="habracut"></a><br><h1>  Introduction </h1><br>  Once I was sure that chess programs (they are the engines, however, about this a bit later) simply hold in mind a huge number of games played and find their current position in them and make the right move.  In my opinion, I read about it in some book. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is undoubtedly a very naive opinion.  A new position in chess can be obtained by the tenth move.  Although there are fewer positions in chess than in <a href="https://geektimes.ru/post/270248/">go</a> , nevertheless, already after 3 moves (a move is one move of white and black, a half-move is a move of only one side) the move tree consists of almost 120 million knots.  Moreover, the size of the tree after 14 half-moves from the initial position has been <a href="http://www.talkchess.com/forum/viewtopic.php%3Fp%3D654046">considered by</a> enthusiasts for more than a year, having advanced by about a third. <br><br>  I also thought that chess programs, despite the long-standing <a href="https://geektimes.ru/post/246086/">victory</a> over the world champion, are still within the reach of the best people.  This is also not true. <br><br>  In a <a href="https://www.chess.com/news/view/komodo-beats-nakamura-in-final-battle-1331">recent</a> man-machine <a href="https://www.chess.com/news/view/komodo-beats-nakamura-in-final-battle-1331">mini-match</a> , <a href="http://hikarunakamura.com/">Hikaru Nakamura</a> , one of the <a href="http://www.2700chess.com/">strongest chess players</a> in the world, played with <a href="https://komodochess.com/">Komodo</a> , one of the (two) <a href="http://www.computerchess.org.uk/ccrl/4040/index.html">strongest chess programs</a> in the world.  The program was launched on 24-core Xeon.  Since people can no longer compete with the computer on equal terms, the grandmaster got a head start in each of the 4 games: <br><ul><li>  In the first game - a pawn and a move: the computer was playing black and without the f7 pawn </li><li>  In the second - only a pawn: the computer played white without the f2 pawn </li><li>  In the third, the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2587%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE_%2528%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B%2529">quality</a> (the difference between the rook and the light piece, is estimated at about 2 pawns): the computer is white without the rook a1, the man without the b8 knight and with the rook a8 in his place. </li><li>  In the fourth, there are four moves: the person plays white and instead of the first move he makes 4 any moves, without crossing the middle of the board. </li></ul><br>  There were some disputes about the odds - for example, the absence of the f pawn weakens the king somewhat, but after castling gives an open line to the rook.  The absence of a central pawn, perhaps, gives a greater advantage.  4 moves give a good positional advantage, but if you play a closed debut like the King's Indian defense, then this advantage is not so difficult to negate. <br><br>  In addition, the games were played with a control of 45 +15 ', that is, 45 minutes per game and 15 seconds of <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B0%25D1%2581%25D1%258B_%25D0%25A4%25D0%25B8%25D1%2588%25D0%25B5%25D1%2580%25D0%25B0">addition</a> each turn. Usually, shorter controls give an additional advantage to the computer, while longer ones - somewhat increase the person‚Äôs chances. The computer even in a fraction of a second will have time to brush off the frankly losing moves, while due to the exponential growth of the options tree, each subsequent improvement of the analysis takes more and more time. <br><br>  Nevertheless, the head start was and the person lost in the match 2.5‚Äì1.5, having tied the first 3 games and lost the fourth.  At the same time, a <a href="https://ratings.fide.com/card.phtml%3Fevent%3D305243">weak grandmaster</a> quite confidently <a href="http://komodochess.com/games/Neuman.html">won</a> with a handicap of 2 pawns.  Therefore, the advantage of the best programs over the best people at the moment is somewhere between 1 and 2 pawns of the handicap.  Of course, this assessment is very rough, but for an accurate assessment we need to play several thousand games between people and programs, and this is unlikely that anyone will be involved.  Please note that the ELO rating, which is often indicated for programs, has nothing to do with people rating. <br><br><h1>  What is a chess engine? </h1><br>  In order for a person to play chess with a computer, besides actually searching for a better move, you need a GUI.  Fortunately, a universal interface was invented (even two, <a href="https://en.wikipedia.org/wiki/Chess_Engine_Communication_Protocol">Winboard</a> and <a href="https://ru.wikipedia.org/wiki/UCI_%2528%25D0%25BF%25D1%2580%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25BB%2529">UCI</a> , but most engines use UCI) for communication between the GUI and the actual chess program (engine).  Thus, programmers can concentrate on the very algorithm of the game of chess, without thinking about the interface.  The reverse side of the coin - since the creation of a GUI is much more boring than writing the engine, the free GUIs noticeably lose out to the paid ones.  Unlike engines, where free <a href="https://stockfishchess.org/">Stockfish</a> confidently fights for the first line of the rating with paid Komodo. <br><br><h1>  How do they still play? </h1><br>  So, how does the modern chess engine work? <br><br><h2>  Board presentation </h2><br>  The basis of any engine is a representation of a chessboard.  First of all, it is necessary to ‚Äúexplain‚Äù to the computer all the rules of chess and enable it to keep a chess position.  Without this, it is impossible to evaluate the position and make moves. <br><br>  There are two basic ways to store a board view ‚Äî <b>by shape</b> or <b>by cell</b> .  In the first case, we store for each piece its place on the board, in the second - on the contrary, for each cell we store what is there.  Each method has its advantages and disadvantages, but at the moment all top engines use the same board representation - bitboards. <br><br><h3>  Bitboards </h3><br>  By happy coincidence, there are 64 squares on a chessboard.  So, if for each cell to use one bit, we can store the entire board in a 64-bit integer. <br>  In one variable we will store all white pieces, in the other - all black, and in another 6 - each type of figures separately (another option - 12 bitboards for each color and type of figures separately). <br><br>  What is the advantage of this option? <br>  First, the memory.  As we will learn later, when analyzing the presentation of the board is copied many times, and, accordingly, eats off the RAM.  Bitboards are one of the most compact representations of a chessboard. <br>  Secondly, speed.  Many calculations, for example, the calculation of possible moves, are reduced to several bit operations.  Due to this, for example, using the POPCNT instruction gives ~ 15% acceleration to modern engines.  In addition, during the existence of bitboards, many algorithms and optimizations have been invented, such as, for example, <a href="http://chessprogramming.wikispaces.com/Magic%2BBitboards">‚Äúmagic‚Äù beatboards</a> . <br><br><h2>  Search </h2><br><h3>  Minimax </h3><br>  Most of the chess engines are based on the minimax search algorithm or its modification negamex.  In short, we go down the tree, evaluate the leaves, and then go up, each time choosing the optimal move for the current player, minimizing the estimate for one (black) and maximizing for the second (white).  Hence the name.  Once at the root, we get a sequence of moves that is optimal for both players.  The difference between minimax and non-maxama is that in the first case we choose turns with maximal and minimal marks, and in the second we change the sign for all marks instead and always choose maximal (we understood the name from where).  Read more <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25BA%25D1%2581">here</a> and <a href="https://chessprogramming.wikispaces.com/Minimax">here</a> . <br><br><h3>  Alpha beta </h3><br><img src="https://habrastorage.org/files/b45/c98/3b3/b45c983b325e40a68c4f5b79b0a0c2dd.png" align="left">  The first optimization is <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D1%258C%25D1%2584%25D0%25B0-%25D0%25B1%25D0%25B5%25D1%2582%25D0%25B0-%25D0%25BE%25D1%2582%25D1%2581%25D0%25B5%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">alpha beta</a> .  The idea of ‚Äã‚Äãalpha-beta is simple - if I already have a good move, then I can cut off moves that are obviously worse.  Consider the example on the creepy picture on the left.  Suppose player A has 2 possible moves - a3 and b3.  After analyzing move a3, the program received a score of +1.75.  Starting to evaluate the move b3, the program saw that player B has two moves - a6 and a5.  Assessment of a6 +0.5.  Since player B chooses a move with a minimum mark, he will not choose a move with a mark higher than 0.5, which means the mark of move b3 is less than 0.5, and it makes no sense to consider it.  Thus, all remaining subtree b3 is cut off. <br><br>  For clipping, we store the upper and lower bounds - alpha and beta.  If, when analyzing a move, it receives an estimate higher than beta, then the current node is cut off.  If the score is higher than the alpha, then the alpha is updated. <br><br>  The nodes in alpha-beta are divided into 3 categories: <br><ol><li>  <b>PV-Nodes</b> are nodes whose score fell into the window (between alpha and beta).  The root and the leftmost node are always nodes of this type. </li><li>  <b>Cut-Nodes</b> (or <b>fail-high nodes</b> ) - the nodes in which cut-off has occurred. </li><li>  <b>All-Nodes</b> (or <b>fail-low nodes</b> ) are nodes in which no move exceeded alpha by evaluation. </li></ol><br><br><h3>  Sort moves </h3><br>  When using alpha-beta, the order of moves becomes important.  If we can put the best move first, then the remaining moves will be analyzed much faster due to the cutoffs on the beta. <br><br>  In addition to using the hash and the best move from the previous iteration, there are several techniques for sorting moves. <br><br>  For taking, for example, a simple heuristic of <b>MVV-LVA</b> (Most Valuable Victim - Least Valuable Aggressor) can be used.  We sort all the takeovers by descending value of the ‚Äúvictim‚Äù, and inside we revisit the ascending value of the ‚Äúaggressor‚Äù.  Obviously, it is usually more profitable to take a queen pawn than vice versa. <br><br>  For "quiet" moves, the "killer" method is used - the moves that caused clipping on the beta.  These moves are usually checked immediately after hashes and takes. <br><br><h3>  Hash table or permutation table </h3><br>  Despite the huge size of the tree, many nodes in it are identical.  In order not to analyze the same position twice, the computer stores the analysis results in a table and each time checks whether there is already a ready analysis of this position.  Usually, such a table stores the actual hash of the position, score, best move, and age of the score.  Age is required to replace old positions when filling out the table. <br><br><h3>  Iterative search </h3><br>  As you know, if we cannot analyze the entire tree completely, the minimax needs an evaluation function.  Then, having reached a certain depth, we stop the search, evaluate the position and begin climbing the tree.  But such a method requires a predetermined depth and does not provide qualitative intermediate results. <br><br>  These problems are solved by iterative search.  To begin with, we carry out the analysis to a depth of 1, then to a depth of 2, etc.  Thus, each time we descend a little deeper than the last time, until the analysis is stopped.  To reduce the size of the search tree, the results of the previous iteration are usually used to cut off obviously bad moves on the current one.  This method is called aspiration window (aspiration window) and is used everywhere. <br><br><h3>  Quiet Search (Quiescence Search) </h3><br>  This method is designed to combat the ‚Äúhorizon effect‚Äù.  Simply stopping the search at the right depth can be very dangerous.  Imagine that we stopped in the midst of the exchange of queens - the white took the black queen, and the next move Black should pick up the white.  But at the moment on the board - White has an extra queen and the static estimate will be fundamentally wrong. <br><br>  To do this, before doing a static assessment, we check all captures (sometimes even shahs) and descend the tree to a position in which there are no possible captures and checks.  Naturally, if all takes worsen the assessment, then we return the assessment of the current position. <br><br><h3>  Selective search </h3><br>  The idea of ‚Äã‚Äãa selective search is to consider ‚Äúinteresting‚Äù moves longer and less - uninteresting.  To do this, use extensions that increase the depth of search in certain positions, and abbreviations that reduce the depth of search. <br><br>  The depth is increased in the case of captures, shahs, if the only move is much better than alternatives or if there is a passed pawn. <br><br><h4>  Clipping and shortening </h4><br>  With clippings and contractions, everything is much more interesting.  They can significantly reduce the size of the tree. <br><br>  Briefly about clipping: <br><ul><li>  <b>Delta cutoff</b> - check if taking can improve the current alpha.  To do this, add the value of the taken shape to the node's estimate and a little more and see if the resulting value is greater than the alpha.  For example, if White lacks a rook, then taking a pawn is unlikely to help them, on the other hand, taking an bishop can help. </li><li>  <b>Cutting off uselessness</b> is the same, only for non-taking.  If the current estimate is so much lower than the alpha that no positional advantage can compensate for this, then such nodes are cut off.  Usually applied at low depths (1-2). </li><li>  <b>Historical clipping</b> - for each move we store the number of times this move provoked the clipping, regardless of position.  Movements with a high value of this heuristics are cut off.  It is usually applied starting from a certain depth and will not be applied on PV nodes.  Sometimes combined with the previous method. </li><li>  <b>Multi-Cut</b> - if from the first M (for example, 6) nodes at least C (for example, 3) are Cut-node, then we cut all the nodes. </li><li>  <b>Clipping on a null-move</b> - if after a null-move (a simple transfer of the queue to an opponent), the score is still higher than beta, then we cut the node.  Simply put, if the position is so bad that even after making two moves in a row, the player still cannot improve it, then there is no point in considering this position. </li></ul><br><br>  Abbreviations are used when we are not so sure that the move is bad, and therefore we do not cut it, but simply reduce the depth.  For example, <b>razoring</b> is an abbreviation, provided that the static estimate of the current position is less than alpha. <br><br>  Due to the high-quality sorting of moves and clipping, modern engines manage to achieve <a href="http://www.talkchess.com/forum/viewtopic.php%3Ft%3D48281%26postorder%3Dasc%26topic_view%3Dflat">a branching factor below 2</a> .  Due to this, unfortunately, they sometimes overlook non-standard sacrifices and combinations. <br><br><h3>  NegaScout and PVS </h3><br>  Two very similar techniques that use the fact that after we found the PV-node (provided that our moves are well sorted), it most likely will not change, that is, all the remaining nodes will return a lower grade than alpha.  Therefore, instead of searching with a window from alpha to beta, we are looking for a window from alpha to alpha + 1, which allows us to speed up the search.  Of course, if in some node we get clipping by beta, then it should be re-evaluated, already by normal search. <br><br>  The difference between the two methods is only in the formulation - they were developed at about the same time, but independently, and therefore are known by different names. <br><br><h3>  Parallel Search </h3><br>  Alpha-beta paralleling is a separate big topic.  I will briefly go through it, and who is interested - read <a href="http://www.top-5000.nl/ps/Parallel%2520Alpha-Beta%2520Search%2520on%2520Shared%2520Memory%2520Multiprocessors.pdf">Parallel Alpha-Beta Search on Shared Memory Multiprocessors</a> .  The difficulty is that with parallel search, many Cut-nodes are analyzed before another thread finds a refutation (sets beta), while in a sequential search, with good sorting, many of these nodes would be cut off. <br><br><h3>  Lazy smp </h3><br>  Very simple algorithm.  We just run all the threads at the same time with the same search.  Communication flows at the expense of the hash table.  Lazy SMP was surprisingly effective, so much so that the top Stockfish switched to it from YBW.  However, some <a href="http://www.talkchess.com/forum/viewtopic.php%3Ft%3D58031">believe</a> that the improvement was due to poor implementation of YBWC and too aggressive cuts, and not because of the advantage of Lazy SMP. <br><br><h3>  Young Brothers Wait Concept (YBWC) </h3><br>  The first node (older brother) should be fully analyzed, after which a parallel analysis of the remaining nodes (younger brothers) is launched.  The idea is the same, the first move will either noticeably improve the alpha, or even allow you to cut off all the other nodes. <br><br><h3>  Dynamic Tree Splitting (DTS) </h3><br>  Fast and complicated algorithm.  About speed: the search speed is measured in ttd (time to depth), that is, the time it takes for the search to reach a certain depth.  This indicator can usually be used to compare the work of different versions of the engine or engine running on different number of cores (although Komodo, for example, increases the width of the tree with more available cores).  In addition, during operation, the engine displays the search speed in nps (nodes per second).  This metric is much more popular, but it does not allow comparing even the engine with itself.  Lazy SMP, in which there is no synchronization, increases nps almost linearly, but due to the large amount of unnecessary work, its ttd is not so impressive.  While for DTS, nps and ttd vary <a href="http://www.talkchess.com/forum/viewtopic.php%3Ft%3D56019">almost equally</a> . <br><br>  To be honest, I could not fully understand this algorithm, which, despite its high efficiency, is used literally in a pair of engines.  Who is very interesting, follow the link above. <br><br><h2>  Evaluation </h2><br>  So, we have reached the necessary depth, made a search for peace, and finally we need to evaluate the static position. <br><br>  The computer evaluates the position in pawns: +1.0 means that White has an advantage equivalent to 1 pawn, -0.5 means that Black has half a pawn advantage.  A mate is estimated at 300 pawns, and the position in which the number of moves to mate x is known is at (300-0.01x) pawns.  +299.85 means that whites checkmate in 15 moves.  At the same time, the program itself usually operates with whole evaluations in centi-peshes (1/100 of a pawn). <br><br>  What parameters does the computer take into account when evaluating the position? <br><br><h3>  Material and Mobility </h3><br>  The easiest.  Queen 9-12 pawns, rook 5-6, knight and bishop 2.5-4 and pawn, respectively, one pawn.  In general, the material is a worthy heuristic for evaluating a position, and any positional advantage is usually transformed eventually into a material one. <br><br>  Mobility is considered simple - the number of possible moves in the current position.  The more of them, the more mobile the player's army. <br><br><h3>  Figure Position Tables </h3><br>  The knight in the corner of the board is usually bad, pawns closer to the enemy rear are becoming more valuable, and so on.  For each piece, a table of bonuses and penalties is compiled depending on its position on the board. <br><br><h3>  Pawn structure </h3><br><ul><li>  <b>Double pawns</b> - two pawns on the same vertical.  Often they are difficult to defend with other pawns, considered weakness. </li><li>  <b>Lagging pawns</b> are pawns whose neighbors are in front of them.  Such pawns cannot be defended by other pawns, and therefore they are considered weakness. </li><li>  <b>Passing pawns</b> are pawns that can reach the last rank without interference from enemy pawns.  Strong threat to the opponent, especially in the endgame </li><li>  <b>Isolated pawns</b> are pawns that have no neighbors.  Such pawns in general cannot be defended by other pawns, and therefore they are considered a serious weakness. </li></ul><br><br><h3>  Stages of the game </h3><br>  All of the above parameters affect the assessment of the game in different ways, depending on the stage of the game.  In the opening there is no sense in passing a pawn, but in the endgame you need to bring the king to the center of the board, and not hide behind the pawns. <br><br>  Therefore, many engines have a separate estimate for the endgame and for the debut.  They evaluate the stage of the game depending on the material remaining on the board and, in accordance with this, consider the assessment - the closer to the end of the game, the less impact the opening assessment and the more - the endgame. <br><br><h3>  Other </h3><br>  In addition to these main factors, the engines can add some other factors to the assessment - for example, the king‚Äôs security, locked pieces, pawn islands, center control, etc. <br><br><h3>  Accurate assessment or quick search? </h3><br>  Traditional dispute: what is more effective, accurately assess the position or achieve greater depth of search.  Experience shows that too ‚Äúheavy‚Äù evaluation functions are ineffective.  On the other hand, a more detailed assessment that takes into account more factors usually leads to a more ‚Äúbeautiful‚Äù and ‚Äúaggressive‚Äù game. <br><br><h2>  Debut books and endgame tables </h2><br><h3>  Debut books </h3><br>  At the dawn of computer chess, the program played a very weak debut.  Debut often requires strategic decisions that will affect the whole game.  On the other hand, people had a well developed theory of debut, debuts were repeatedly analyzed and played from memory.  So for computers such a ‚Äúmemory‚Äù was created.  Starting from the initial position, a tree of moves was built and each move was evaluated.  During the game, the engine simply chose one of the ‚Äúgood‚Äù moves with a certain probability. <br><br>  Since then, debut books have grown, many debuts have been analyzed with the help of computers up to the endgame.  There is no need for them, the strong engines have learned to play the debut, but they leave the main lines rather quickly. <br><br><h3>  Endgame tables </h3><br>  Let's return to the introduction.  Remember the idea of ‚Äã‚Äãstoring many positions in memory and choosing the right one.  Here she is.  For a small (up to 7) number of figures, all existing positions have been calculated.  That is, in these positions, the computer starts to play perfectly, winning in the minimum number of moves.  Minus - the size and time of generation.  The creation of these tables helped in the study of endgroups. <br><br><h4>  Table generation </h4><br>  We will generate all possible (with symmetry) positions with a certain set of shapes.  Among them we will find and designate all positions where there is a mat.  By the next pass we will designate all positions in which you can get into positions with a mat - in these positions a checkmate is put in 1 move.  Thus, we find all positions with a checkmate of 2,3,4, <a href="http://tb7.chessok.com/articles/Top8DTM_eng">549</a> moves.  In all unmarked positions - a draw. <br><br><h4>  Nalimov tables </h4><br>  The first endgame tables published back in 1998.  For each position is stored the result of the game and the number of moves to the mat in the ideal game.  The size of all six-figure terminations is 1.2 terabytes. <br><br><h4>  Lomonosov tables </h4><br>  In 2012, all <a href="http://chessok.com/%3Fpage_id%3D27966">seven-figure endings</a> were counted on the Lomonosov supercomputer at Moscow State University (except 6 vs. 1).  These bases are available only for money and these are the only existing complete seven-figure endgame tables. <br><br><h4>  Syzygy </h4><br>  Standard de facto.  These bases are much more compact than the bases of Nalimov.  They consist of two parts - WDL (Win Draw Lose) and DTZ (Distance to zeroing).  WDL databases are designed for use during a search.  Once the tree node is found in the table, we have the exact result of the game in this position.  DTZ are intended for use in the root - they store the number of moves until the move moves to zero, a move (a pawn or a take).  thus, WDL bases are enough for analysis, and DTZ bases can be useful when analyzing endgames.  Syzygy size is much smaller - 68 gigabytes for six-figured WDL and 83 for DTZ.  Seven-figure bases do not exist, since their generation requires approximately a terabyte of RAM. <br><br><h4>  Using </h4><br>  Endgame tables are used mainly for analysis, the increase in the strength of the game engines is small - 20-30 points of <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B9%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B3_%25D0%25AD%25D0%25BB%25D0%25BE">ELO</a> .  However, since the depth of search for modern engines can be very large, requests for endgame bases from the search tree occur even in the opening. <br><br><h2>  Other interesting things </h2><br><h3>  Giraffe or neural networks play chess </h3><br>  Some of you may have heard about the chess engine on neural networks that have <a href="https://www.technologyreview.com/s/541276/deep-learning-machine-teaches-itself-chess-in-72-hours-plays-at-international-master/">reached the IM level</a> (which, as we understood in the introduction, is not so cool for the engine).  He wrote and posted on <a href="https://bitbucket.org/waterreaction/giraffe">Bitbucket</a> Matthew Lai, who unfortunately stopped working on him because he <a href="http://www.talkchess.com/forum/viewtopic.php%3Ft%3D59003">started working in Google DeepMind</a> . <br><br><h3>  Tuning parameters </h3><br>  It is easy to add a new function to the engine, but how to check that it gave the gain?  The simplest option is to play several games between the old and the new version and see who wins.  But if the improvement is small, and it usually happens after all the main features are added, there should be several thousand games, otherwise there will be no certainty. <br><br><h3>  Stockfish </h3><br>  There are a lot of people working on this engine, and their every idea needs to be checked.  With the current strength of the engine, each improvement gives an increase in a couple of points in the rating, but the result is a steady increase of several dozen points annually. <br><br>  Their solution is typical for open source - volunteers <a href="http://tests.stockfishchess.org/tests">provide</a> their power to drive hundreds of thousands of games to them. <br><br><h3>  CLOP </h3><br>  <a href="http://www.remi-coulom.fr/CLOP/">A program</a> that optimizes parameters through linear regression, using the results of the engine games with itself with different parameters.  Of the minuses, the size of the task is very limited: it cannot optimize a hundred parameters (quite an adequate number for the engine), at least in an adequate time. <br><br><h3>  Texel's tuning </h3><br>  Solves the problem of the previous method.  We take a large number of positions (the author offered 9 million positions from 64,000 games, I took 8 million from almost 200,000), for each we save the result of the game (White‚Äôs victory 1, draw 0.5, loss 0).  Now we minimize the error, which is the sum of the squares of the difference between the result and the sigmoid estimate.  The method is effective and popular, but does not work on all engines. <br><br><h3>  Stockfish tuning </h3><br>  Another technique from the leader.  We take the parameter equal to x, and compare (in several tens of thousands of batches) the engine with the parameter equal to x-sigma and x + sigma.  If the engine won with a large parameter, move it up a little, otherwise, move it down a little and repeat. <br><br><h3>  Engine contests </h3><br>  Of all the competitions being held, I would like to separately highlight <a href="http://tcec.chessdom.com/live.php">TCEC</a> .  It differs from all the others with a powerful iron, careful selection of debuts and long control.  In the last final, 100 games were played for 2 x Intel Xeon E5-2690v3 with 256 gigabytes of RAM with 180 '+ 30 "control. In such conditions, the number is huge, and only 11 games were productive. <br><br><h1>  Conclusion </h1><br>  So in brief in this long article I talked about the structure of chess engines.  Many details were not disclosed, I simply did not know about something or forgot to say.  If you have any questions, write them in the comments.  In addition, I would advise you two resources that you probably noticed if you carefully opened all the links scattered on the article: <br><ul><li>  <a href="http://chessprogramming.wikispaces.com/">Chess programming wiki</a> </li><li>  <a href="http://talkchess.com/forum/index.php">Talkchess Forum</a> </li><li>  And one more, not mentioned earlier - <a href="http://www.top-5000.nl/authors/rebel/chess840.htm">programmer corner</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/390821/">https://habr.com/ru/post/390821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../390807/index.html">How to travel using virtual reality technology</a></li>
<li><a href="../390811/index.html">How to read 40 books per year</a></li>
<li><a href="../390813/index.html">Budgetary people in the Ulyanovsk region have banned Google, Skype and WhatsApp in the workplace</a></li>
<li><a href="../390815/index.html">Getting Started with TI CC13xx-CC26xx and Contiki under Code Composer Studio</a></li>
<li><a href="../390817/index.html">Exciting sounds of "Star Wars"</a></li>
<li><a href="../390823/index.html">Revived SpaceShipTwo</a></li>
<li><a href="../390825/index.html">How to choose a communication standard for IoT network</a></li>
<li><a href="../390827/index.html">"Warned - armed" or what you need to know about a stroke, even if you are young</a></li>
<li><a href="../390829/index.html">Tim Cook once again confirms the hardness of their positions, 51% of Americans surveyed support the FBI</a></li>
<li><a href="../390831/index.html">Oil magnates create a group to attack electric vehicles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>