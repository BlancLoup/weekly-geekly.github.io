<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Transition from AngularJS to Angular: goals, plans and rules for transferring elements (1/3)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In January, we completed the translation of our Vimbox platform from AngularJS to Angular 4 in Skyeng. During the preparation and transition, we accum...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Transition from AngularJS to Angular: goals, plans and rules for transferring elements (1/3)</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ee/2_/pt/ee2_pt2t73-_r1g4-nic6mpaudo.jpeg"></p><br><p>  In January, we completed the translation of our Vimbox platform from AngularJS to Angular 4 in Skyeng. During the preparation and transition, we accumulated a lot of entries on planning, problem solving and new work conventions, and we decided to share them in three articles on Habr√©.  We hope that our notes will be useful structurally similar to our Vimbox projects that have just started to move or are going to do it. </p><a name="habracut"></a><br><h2 id="zachem-nam-eto-nuzhno">  Why do we need it? </h2><br><p>  First, Angular is better at all than AngularJS - it is faster, easier, more convenient, it has fewer bugs (for example, typing templates helps to combat them).  This is a lot said and written, it makes no sense to repeat.  It was clear from Angular 2, but a year ago it was scary to start a transition: what if Google again decides to turn everything upside down with the next version, without backward compatibility?  We have a big project, the transition to an essentially new framework requires serious resources, and we don‚Äôt want to do it once every two years.  Angular 4 lets hope that there will be no more revolutions, which means that it is time to migrate. </p><br><p>  Secondly, we wanted to update the technologies used in our platform.  If this is not done according to the principle ‚Äúif something doesn‚Äôt break, you don‚Äôt need to repair it‚Äù, at some point we will pass the line beyond which further progress will be possible only if the platform is rewritten from scratch.  Sooner or later, switching over to Angular will be all the same, but the sooner this is done, the cheaper the transition will be (the amount of code increases all the time, and we will get benefits from the new technology earlier). </p><br><p>  Finally, a third important reason: developers.  AngularJS - passed stage, it performs its tasks, but does not develop and will never develop;  our platform is constantly growing.  We do not have a very large team consisting of strong developers, and strong developers are always interested in new technologies, they are just not interested in dealing with an outdated framework.  The transition to Angular makes our jobs more interesting for strong candidates;  in the next two or three years they will be quite relevant. </p><br><h2 id="kak-perehodit">  How to move? </h2><br><p>  You can perform the transition in parallel mode - the platform works on AngularJS, we write from scratch and test the new version, and at some point simply switch the toggle switch.  The second option is a hybrid mode, where changes occur directly on the production, where both AngularJS and Angular work simultaneously.  Fortunately, this mode is well thought out and <a href="https://angular.io/guide/upgrade">documented</a> . </p><br><p>  The choice between hybrid and parallel transition modes depends on how actively the product is developing.  Our developer, who prepared the event plan, had experience of a parallel approach in another company - but in the event there were fewer dependencies (although the code was about the same), and most importantly, it was possible for a month to stop all development and deal only with the transition.  The choice of mode depends on whether you can afford this luxury. </p><br><p>  For us, in a parallel transition, there was a risk: at the time of the preparation of the new version, the entire development stops, and no matter how competently we calculate the move date, there is a chance that the process will be delayed, we will rest on something and will not understand what to do next.  In the hybrid mode in this situation, we can just stop and calmly look for a solution, since we still have the current working version on production;  it may not work as effectively and a bit harder, but no processes are stopped.  In parallel, we would have rolled back with the corresponding losses.  It is worth noting that our transition process really took a long time - it was planned for 412 hours, in fact it turned out twice as long (830).  But at the same time, nothing stopped, the new functionality was constantly rolling out, everything worked as it should. </p><br><p>  In general, it should be borne in mind that the hybrid transition is not force majeure, it is a completely normal, default procedure, according to the developers of Angular himself;  it is not necessary to be afraid of him. </p><br><h2 id="plan">  Plan </h2><br><p>  The sequence of actions looked like this: </p><br><ol><li> Hybrid application initialization: bootstrap angular, which bootstrap angularis.  Everything remains as it was, only now we are going slower and run longer (while the hybrid mode is working).  It is no longer possible to throw the controller on the <code>head</code> , all work with the title / favicon / meta tags is placed in the services that directly interact with the necessary elements in the header. </li><li>  Transfer services to Angulyar: the easiest.  Rewritten services are quickly made available from AngularJS, on which components are still running.  Starting from the most simple, not having dependencies, to more complex ones. </li><li>  We draw the rest of the owl: we transfer the basic components (the GUI and everything else that does not use other components / directives).  We transfer components from the bottom up, as far as possible by unit. </li><li>  We brush feathers: we transfer components of pages, we saw out AngularJS. </li></ol><br><h2 id="pravila-perenosa">  Transfer rules </h2><br><p>  Well, now let's move on to the promised technical details.  We cleaned these records a bit, removing unnecessary details relating only to our platform.  These are not at all universal solutions, but maybe they will help someone to solve problems that arise. </p><br><p>  In order not to fence the wall of the text, we hide everything under the spoilers. </p><br><h3 id="kak-perenosit-otdelnye-elementy">  How to move individual items </h3><br><div class="spoiler">  <b class="spoiler_title">Module</b> <div class="spoiler_text"><p>  If in the module in which we start to upgrade something, there is no an angular module, then we create it and attach it to the main application module: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {NgModule} from <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NgModule({ // })</span></span>; export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmthModule</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@NgModule({ imports: [ ... SmthModule, ], })</span></span>; export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  If the angularization module is still alive, then the new module is called with the postfix <code>.new</code> .  We cut out postfix along with the old angular module. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Service</b> <div class="spoiler_text"><p>  In a good case, we add a decorator, remove the <code>default</code> from export, manage imports (because the default has been removed), import into the anguly module, downgrade to the anguard module: </p><br><pre> <code class="hljs perl">import <span class="hljs-string"><span class="hljs-string">{Injectable}</span></span> from <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; @Injectable() export class SmthService { ... } // angular module @NgModule({ providers: [ ... SmthService, ], }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> angularjs module import <span class="hljs-string"><span class="hljs-string">{downgradeInjectable}</span></span> from <span class="hljs-string"><span class="hljs-string">"@angular/upgrade/static"</span></span>; ... .factory(<span class="hljs-string"><span class="hljs-string">"vim.smth"</span></span>, downgradeInjectable(SmthService))</code> </pre> <br><p>  The service remains available under the old name in Angurarzhs and does not require additional configuration. </p><br><p>  A good option implies: all injecting services have already moved to Angulyar, no specific items like <code>templateCache</code> or <code>compiler</code> . </p><br><p>  In the remaining 95% of cases, we suffer, first upgrading what is injected, getting rid of all sorts of weird angularies, etc. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Component</b> <div class="spoiler_text"><p>  We drop the decorator with the metadata to the controller, put the decorators into inputs / outputs and transfer them to the beginning of the class: </p><br><pre> <code class="hljs ruby">import {Component, Input, Output, EventEmitter} from <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; @Component({ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">`-`</span></span>     ,   camelCase <span class="hljs-symbol"><span class="hljs-symbol">selector:</span></span> <span class="hljs-string"><span class="hljs-string">"vim-smth"</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./smth.html"</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">templateUrl:</span></span> <span class="hljs-string"><span class="hljs-string">"smth.html"</span></span>, }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmthComponent</span></span></span><span class="hljs-class"> { @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">smth1</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">;</span></span> @Output() smthAction = new EventEmitter&lt;void&gt;(); ... } /<span class="hljs-regexp"><span class="hljs-regexp">/ angular module @NgModule({ declarations: [ ... SmthComponent, ], /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         ,         exports: [ ... SmthComponent, ], }); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ angularjs module import {downgradeInjectable} from "@angular/upgrade</span></span><span class="hljs-regexp"><span class="hljs-regexp">/static"; ... .directive("vimSmth", downgradeComponent({ component: SmthComponent }) as ng.IDirectiveFactory)</span></span></code> </pre> <br><p>  All injected services, all require components (how to cling them - below to <em>Any</em> ) and all components / directives / filters used inside the template should be on an angular basis. </p><br><p>  All component variables used in the template must be declared as <code>public</code> , otherwise it will fall on the AoT assembly. </p><br><p>  If the component receives all the data for output from the component above (via input), then feel free to write to it in the meta-data <code>changeDetection: ChangeDetectionStrategy.OnPush</code> .  This tells the angular that it will only sync the data template (let change detection for this component) if any of the components of the component change.  Ideally, most of the components should be in this mode (but we are unlikely, because very large components that receive data for output via services). </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Directive</b> <div class="spoiler_text"><p>  Same as the component, only there is no template and the <code>@Directive</code> decorator.  It is thrown into the module there, it is necessary to export it for use in the components of other modules as well. </p><br><p>  The selector in camelCase is also used in component templates. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Filter</b> <div class="spoiler_text"><p>  Now it is <code>@Pipe</code> and must implement the <code>PipeTransform</code> interface.  The module is thrown in the same place as the components / directives, and also must be exported if used in other modules. </p><br><p>  The selector in camelCase is also used in component templates. </p><br><p>  Angular's directives and filters cannot be used in patterns of angular components and vice versa.  Between the frameworks, only services and components are forwarded. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Exports / Imports and Interfaces</b> <div class="spoiler_text"><p>  First, we get rid of export default, because  AoT compiler cannot. </p><br><p>  Secondly, because of the current structure of the modules (very large) and the use of interfaces (we put in a heap in the same file where the classes are) we caught a funny bug with importing such interfaces and using them with decorators: if the interface is imported from a file containing exports not only interfaces, but also, for example, classes / constants, and such an interface is used for typing next to the decorator (for example, <code>@Input() smth: ISmth</code> ), the compiler will <code>export 'ISmth' was not found</code> import error <code>export 'ISmth' was not found</code> .  This can be fixed either by moving all interfaces to a separate file (which is bad due to large modules, such a file will be in a dozen screens), or by replacing interfaces with classes.  Replacement for classes is not a ride, because  can not inherit from multiple parents. </p><br><p>  Selected solution: create an <code>interface</code> directory in each module in which files with the name of the entity will be located, containing the corresponding interfaces (for example, room, step, content, workbook, homework).  Accordingly, all interfaces that are not used locally are put there and imported from such file directories. </p><br><p>  A more detailed description of the problem: <br>  <a href="https://github.com/angular/angular-cli/issues/2034">https://github.com/angular/angular/angular-cli/issues/2034#issuecomment-302666897</a> <br>  <a href="https://github.com/webpack/webpack/issues/2977">https://github.com/webpack/webpack/issues/2977#issuecomment-245898520</a> </p></div></div><br><h3 id="osobennosti-transklud-peredacha-parametrov-import-svg">  Features (transklud, transfer parameters, import svg) </h3><br><div class="spoiler">  <b class="spoiler_title">Features transkluda</b> <div class="spoiler_text"><p>  If transglud ( <code>ng-content</code> ) is used in the upgraded component, then when using the component from the angular templates: </p><br><ul><li>  multi-slot transkluds do not work, only the ability to forward everything in one piece through one <code>ng-content</code> ; </li><li>  in the transcloud of such a component, it is impossible to pass ui-view,  it will not work (broken off when attempting to upgrade the viewport component); </li><li>  if the component is used in a similar way, either we postpone its upgrade to an upgrade of all the places where it is used, or make a copy of it for parallel work in already upgraded components. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Features of the transfer of parameters</b> <div class="spoiler_text"><p>  When using an angular component in an angular component, the inputs are written as for a regular component angular (using <code>[]</code> and <code>()</code> ), but in <code>kebab-case</code> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vim-angular-component</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">some-input</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">some-output</span></span></span><span class="hljs-tag">)=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vim-angular-component</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  When rewriting such a template on an angular, we kebab-case on camelCase. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">require in templates for pictures / svg</b> <div class="spoiler_text"><p>  Do not ride, because  on it the AoT compiler will swear.  Therefore, import the same files into the ts file and forward it through the component. </p><br><p>  It was: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> ${require('!html-loader!image-webpack-loader?{}!./images/icon.svg')} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  has become: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageIcon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>&lt;string&gt;(<span class="hljs-string"><span class="hljs-string">"!html-loader!image-webpack-loader?{}!./images/icon.svg"</span></span>); public imageIcon = imageIcon; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> [</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">innerHTML</span></span></span></span><span class="xml"><span class="hljs-tag">]=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"imageIcon | vimBaseSafeHtml"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  Or for use via img </p><br><p>  It was: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${require('./images/icon.svg')}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  has become: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageIcon = require&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"./images/icon.svg"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> imageIcon = imageIcon; &lt;img [src]=<span class="hljs-string"><span class="hljs-string">"imageIcon | vimBaseSafeUrl"</span></span> /&gt;</code> </pre> </div></div><br><h3 id="dinamicheskie-komponenty-i-shablony">  Dynamic components and patterns </h3><br><div class="spoiler">  <b class="spoiler_title">Life without $ compile</b> <div class="spoiler_text"><p>  <code>$compile</code> is no more, and there is no compilation from the string (in fact, there is a small hack, but here it‚Äôs about how to live in 95% of cases without <code>$compile</code> ). </p><br><p>  Dynamically inserted components are forwarded as follows: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({...})</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicComponent</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@NgModule({ declarations: [ ... DynamicComponent, ], entryComponents: [ DynamicComponent, ], })</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeModule</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">//  @Component({ ... template: ` &lt;vim-base-dynamic-component [component]="dynamicComponent"&gt;&lt;/vim-base-dynamic-component&gt; ` }) class SomeComponent { public dynamicComponent = DynamicComponent; }</span></span></code> </pre> <br><p>  The class of the inserted component can be prokidyvatsya through the service, input or else how else. </p><br><p>  <code>vim-base-dynamic-component</code> is an already-written component for dynamically inserting other components with input / output support (in the future, if needed). </p></div></div><br><div class="spoiler">  <b class="spoiler_title">No dynamic templateUrl</b> <div class="spoiler_text"><p>  If you need to display different templates according to the condition, and the dynamic <code>templateUrl</code> used for this, replace it with a structural directive and divide the component into three.  An example for separating mobile / non mobile: </p><br><p>  request / data processing <br>  display for mobile <br>  display for desktops </p><br><p>  The first component has a minimal template and is engaged in working with data, processing user actions, and the like (such a template, because of its brevity, it makes sense to put the component component in the template via `` instead of a separate html file and <code>templateUrl</code> ).  For example: </p><br><pre> <code class="hljs pgsql">@Component({ selector: "...", <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>: ` &lt;<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-component-mobile *vimBaseIfMobile="true" [data]="data" (changeSmth)="onChangeSmth($event)"&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-component-mobile&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-component-desktop *vimBaseIfMobile="false" [data]="data" (changeSmth)="onChangeSmth($event)"&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-component-desktop&gt; `, })</code> </pre> <br><p>  <code>vimBaseIfMobile</code> is a structural directive (in this case, a direct analogue of <code>ngIf</code> ), displaying the corresponding component by the internal condition and the parameter passed. </p><br><p>  Components for mobile and desktop get data via input, send some events through output and deal only with the output of the necessary.  All complex logic, processing, changing data - in the main component that displays them.  In such components (desktop / mobile), you can safely write <code>changeDetection: ChangeDetectionStrategy.OnPush</code> . </p></div></div><br><h3 id="ispolzovanie-angulyarzhs-servisovkomponentov-v-angulyar-servisahkomponentah">  Using Angular Services / Components in Angular Services / Components </h3><br><div class="spoiler">  <b class="spoiler_title">Service / factoring / provider</b> <div class="spoiler_text"><p>  Open <code>app/entries/angularjs-services-upgrade.ts</code> and follow the example of an existing copy-paste (all within this file): </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> EXAMPLE: copy-paste, fix naming<span class="hljs-regexp"><span class="hljs-regexp">/params, add to module providers at the bottom, use /</span></span>/ ----- <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LoaderService <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../service/loader"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> NOTE: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> function MUST be provided <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> exported <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> AoT compilation <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> function loaderServiceFactory(i: any) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i.get(LoaderService.ID); } const loaderServiceProvider = { provide: LoaderService, useFactory: loaderServiceFactory, deps: [ <span class="hljs-string"><span class="hljs-string">"$injector"</span></span> ] }; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ----- @NgModule({ providers: [ loaderServiceProvider, ] }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AngularJSServicesUpgrade</span></span></span><span class="hljs-class"> {}</span></span></code> </pre> <br><p>  Those.  we copy the existing block, import the necessary service, rule the names of the constants / functions under it, rule the service used in them and its name (most often, instead of <code>SmthService.ID</code> you will need to insert just the name of the service under which the service is available (injected) in Angular); new <code>smthServiceProvider</code> constant to the list of providers at the end of the file. </p><br><p>  This service is used as native Angulyarovsky: just inject in the constructor by class. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Component</b> <div class="spoiler_text"><p>  We put in the file with the original component (at the beginning) the following stub, which will allow the component to be thrown into the angular environment: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {<span class="hljs-type"><span class="hljs-type">Directive</span></span>, <span class="hljs-type"><span class="hljs-type">ElementRef</span></span>, <span class="hljs-type"><span class="hljs-type">Injector</span></span>, <span class="hljs-type"><span class="hljs-type">Input</span></span>, <span class="hljs-type"><span class="hljs-type">Output</span></span>, <span class="hljs-type"><span class="hljs-type">EventEmitter</span></span>} from <span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {<span class="hljs-type"><span class="hljs-type">UpgradeComponent</span></span>} from <span class="hljs-string"><span class="hljs-string">"@angular/upgrade/static"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Directive</span></span>({ <span class="hljs-comment"><span class="hljs-comment">/* tslint:disable:directive-selector */</span></span> selector: <span class="hljs-string"><span class="hljs-string">"vim-smth"</span></span> }) <span class="hljs-comment"><span class="hljs-comment">/* tslint:disable:directive-class-suffix */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmthComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UpgradeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input</span></span>() smth: boolean; <span class="hljs-meta"><span class="hljs-meta">@Output</span></span>() someAction: <span class="hljs-type"><span class="hljs-type">EventEmitter</span></span>&lt;string&gt;; constructor(elementRef: <span class="hljs-type"><span class="hljs-type">ElementRef</span></span>, injector: <span class="hljs-type"><span class="hljs-type">Injector</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">"vimSmth"</span></span>, elementRef, injector); } } <span class="hljs-meta"><span class="hljs-meta">@NgModule</span></span>({ declarations: [ ... <span class="hljs-type"><span class="hljs-type">SmthComponent</span></span>, ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmthModule</span></span></span><span class="hljs-class"> </span></span>{</code> </pre> <br><p>  Please note that in this case the <code>Directive</code> decorator is used instead of the <code>Component</code> , this is a feature of how the angular will process it. </p><br><p>  We do not forget to register all Input / Output (binding from an original component) and to register a component in <code>declarations</code> corresponding module. </p><br><p>  Further, when upgrading this component, such a cap will become a real component of the angular. </p><br><p>  If a component (or rather, the old component directive) injects <code>$attrs</code> into the controller / link function, then such a component cannot be thrown into an angular from angularis, and it needs to be upgraded or put next to an upgraded copy for the angular. </p><br><p>  Disabling tslint errors is necessary so that it does not swear at the discrepancy between the selector name and class to the decorator directive.  These lines (comments) should be removed after the upgrade component. </p></div></div><br><h3 id="vsyakoe">  Any </h3><br><div class="spoiler">  <b class="spoiler_title">Any</b> <div class="spoiler_text"><ul><li>  using the service with promises <code>$q</code> is replaced with native <code>Promise</code> .  They do not have <code>finally</code> , but this is fixed by the <code>core.js/es7.promise.finally</code> and now it is.  It also has no deferred, added ts-deferred, not to write a bike every time; </li><li>  instead of <code>$timeout</code> and <code>$interval</code> use native <code>window.setTimeout</code> and <code>window.setInterval</code> ; </li><li>  instead of <code>ng-show="visible"</code> let us go to the attribute <code>[hidden]="!visible"</code> ; </li><li>  <code>track by</code> now should always be a method, indicated as (do not forget about the Post's postfix method): </li></ul><br><pre> <code class="hljs cs">*ngFor=<span class="hljs-string"><span class="hljs-string">"let item of items; trackBy: itemTrack"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">itemTrack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_index: number, item: IItem</span></span></span><span class="hljs-function">): number</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item.id; }</code> </pre> <br><ul><li>  in 99% of cases, <code>$digest</code> , <code>$apply</code> , <code>$evalAsync</code> and the like are cut without replacement; </li><li>  for an injecting service, we simply write it in the constructor <code>constructor(private someService: SomeService)</code> , the angular itself will understand where to get it; </li><li>  inside the derivative, the element on which it hangs is accessible via the <code>constructor(private element: ElementRef)</code> injectable <code>constructor(private element: ElementRef)</code> and initialized in the <code>AfterViewInit</code> hook ( <code>ElementRef</code> is not a DOM object itself, it is accessible by <code>this.element.nativeElement</code> ); </li><li>  <code>ng-include</code> not without replacement, we use dynamic component creation; </li><li>  <code>angular.extend</code> , <code>angular.merge</code> , <code>angular.forEach</code> and the like is absent, use native js and lodash; </li><li>  <code>angular.element</code> and all its methods are missing.  We use <code>@ViewChild/@ContentChild</code> and work through the native js; </li><li>  if you need to pull the change in the component with <code>OnPush</code> - inject <code>private changeDetectorRef: ChangeDetectorRef</code> and pull <code>this.changeDetectorRef.markForCheck()</code> ; </li><li>  we cut out from templates <code>$ctrl.</code>  - access to Saint-you and methods directly by name; </li><li>  <code>ng-bind-html="smth"</code> -&gt; <code>[innerHTML]="smth"</code> </li><li>  <code>$sce</code> -&gt; <code>import {DomSanitizer} from "@angular/platform-browser";</code> </li><li>  <code>ng-pural</code> -&gt; <code>[ngPlural]</code> <a href="https://angular.io/api/common/NgPlural">https://angular.io/api/common/NgPlural</a> </li><li>  <code>ngClass</code> cannot </li></ul><br><pre> <code class="html hljs xml">[ngClass]="{ [ styles.active ]: visible, [ styles.smth ]: smth }"</code> </pre> <br><p>  so replace with array </p><br><pre> <code class="html hljs xml">[ngClass]="[ visible ? styles.active : '', smth ? styles.smth : '' ]"</code> </pre> <br><ul><li>  classes for <code>ui-router</code> services are imported from <code>@uirouter/core</code> and injected without the old <code>$</code> prefix </li></ul><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {StateService, TransitionService} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@uirouter/core"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(stateService: StateService, transitionService: TransitionService) {</code> </pre> <br><ul><li>  data attributes on components are <code>attr.data-smth=""</code> as <code>attr.data-smth=""</code> or <code>[attr.data-smth]=""</code> ; </li><li>  <code>require</code> in components / directives is replaced by the component class injection directly in the constructor of the current component <code>contructor(private parentComponent: ParentComponent)</code> .  Angulyar himself will see that this is a component, and hook him.  For fine tuning there are decorators <code>@Host</code> (searches among parents), <code>@Self</code> (searches directly on the component), <code>@Optional</code> (may or may not, if not, the variable will be undefined).  You can throw several <code>@Host() @Optional() parentComponent: ParentComponent</code> .  It is possible to requisition components / directives in components / directives; </li><li>  two-way binding in its components has become more explicit and requires the indication of <code>Output</code> with the same name and the postfix <code>Change</code> . </li></ul><br><pre> <code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmthComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> variable: string; <span class="hljs-meta"><span class="hljs-meta">@Output()</span></span> variableChange = new EventEmitter&lt;string&gt;(); &lt;vim-smth [(variable)]=<span class="hljs-string"><span class="hljs-string">"localVar"</span></span>&gt;&lt;/vim-smth&gt;</code> </pre> <br><ul><li>  possible transludal angularis components in the angular component.  The named transcloud must be checked: it works or not (in the angular it is made through selectors) </li></ul><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- angular --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-content</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-content</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- angularjs --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vim-angular-component</span></span></span><span class="hljs-tag">&gt;</span></span> transcluded data <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vim-angular-component</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p>  In the following parts, we talk about the <a href="https://habrahabr.ru/company/skyeng/blog/348512/">features of work in a hybrid mode</a> , as well as about <a href="https://habrahabr.ru/company/skyeng/blog/348606/">new conventions to which we have to get used to Angular</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348356/">https://habr.com/ru/post/348356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348346/index.html">New industry requirements: Certification Centers stop issuing 3-year SSL certificates from March 1, 2018</a></li>
<li><a href="../348348/index.html">It is dangerous to use EDS in Kazakhstan</a></li>
<li><a href="../348350/index.html">Updating strings on the fly in mobile apps: part 2</a></li>
<li><a href="../348352/index.html">How to work with Jira plugin from ScriptRunner or how to avoid code duplication</a></li>
<li><a href="../348354/index.html">How ZFS Stores Data</a></li>
<li><a href="../348358/index.html">10 Gigabit Ethernet: Newbie Tips</a></li>
<li><a href="../348360/index.html">OpenVPN OSPF between two servers, multiple tunnels</a></li>
<li><a href="../348362/index.html">Where in Siberia to talk about IT</a></li>
<li><a href="../348364/index.html">BitPaymer (FriedEx) coder created by Dridex banker trojan authors</a></li>
<li><a href="../348366/index.html">Personal experience with Firebase Cloud Firestore</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>