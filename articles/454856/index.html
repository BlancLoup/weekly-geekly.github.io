<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parse SSL / TLS certificate verification vulnerabilities in non-browser software</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Originally designed for browsers, the SSL / TLS protocol later became the de facto standard for all secure Internet communications. It is now used to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parse SSL / TLS certificate verification vulnerabilities in non-browser software</h1><div class="post__text post__text-html js-mediator-article"><p>  Originally designed for browsers, the SSL / TLS protocol later became the de facto standard for all secure Internet communications.  It is now used to remotely administer a virtual infrastructure deployed in the cloud to transfer customer‚Äôs payment details from e-commerce servers to payment processors such as PayPal and Amazon to send local data to the cloud storage, store messages in instant messengers, and authenticate servers in mobile applications iOS and Android. </p><br><p>  The list of situations where the exchange of highly sensitive information requires maximum security is quite impressive.  In this article we will look at how the security of these communications is ensured in practice. </p><br><p><img src="https://habrastorage.org/webt/qz/-m/fl/qz-mflldhumqjvdsr5kmhxhwh_e.jpeg"></p><a name="habracut"></a><br><h1 id="ssltls-protokol-hoteli-kak-luchshe">  SSL / TLS protocol: we wanted it better ... </h1><br><p>  In theory, the SSL / TLS-protected connection should ensure the confidentiality, authenticity and integrity of client and server software communications - even in the presence of an active advanced attacker from the network: when the network is completely captured by the enemy, the DNS is poisoned, and access points and routers, switches and WiFi is controlled by the attacker;  an attacker who among other things controls the SSL / TLS backend.  In addition, when client software tries to connect to a legitimate server, an attacker can replace the network address of the server (for example, through DNS poisoning), and instead of the legitimate server, redirect the client to its malicious server. </p><br><p>  The security of communications in such harsh conditions, as is well known, depends entirely on the adequacy of the verification of the cryptographic certificate provided by the server during connection establishment.  Including the adequacy of the implementation of a cipher suite (ciphersuite) that the client and server use during data exchange.  In order for the SSL / TLS connection to be completely secure, the client software, among other things, must carefully ensure that: </p><br><ul><li>  certificate issued by the current certification body; </li><li>  its validity period has not expired (or the certificate has not been revoked); </li><li>  in the list of names listed in the certificate there is the domain to which the connection is made. </li></ul><br><h1 id="a-poluchilos-kak-vsegda-primery-provalnoy-proverki-ssltls-sertifikata">  ... but it turned out as always: examples of failing SSL / TLS certificate verification </h1><br><p>  However, in many applications and libraries for which the security of communications is very critical, the procedure for verifying an SSL / TLS certificate, and even EV-SSL, a certificate with extended verification [4], is completely failing.  In all popular operating systems: Linux, Windows, Android and iOS.  Among the vulnerable software, libraries and middleware-services are the following [1]: </p><br><ul><li>  Amazon Java EC2 Library and all cloud front-end clients built on it. </li><li>  Amazon's and PayPal's shopping SDK, responsible for delivering payment details from sites (which have an online commerce infrastructure) to payment gateways. </li><li>  Integrated baskets, such as osCommerce, ZenCart, Ubercart and PrestaShop, which do not check certificates at all. </li><li>  AdMob-code used by mobile software for displaying contextual advertising. </li><li>  Interface frontend components ElephantDrive and FilesAnywhere responsible for interacting with the cloud storage. </li><li>  Android's Pusher library and all software that uses the Pusher API for managing instant messaging (for example, GitHub's Gaug.es). </li><li>  Apache HttpClient (version 3.x);  Apache Libcloud;  and all client connections to Apache ActiveMQ servers, etc. </li><li>  SOAP middleware Java services, including Apache Axis, Axis 2, Codehaus XFire;  as well as all the software that is built on the basis of these middleware-services. </li><li>  API Tools Elastic Load Balancing. </li><li>  Weberknecht implementation of WebSockets. </li><li>  As well as all mobile software built on the basis of the above libraries and middleware-services (to understand what middleware-services are, see Fig. 1);  including the iOS client hosting provider Rackspace. </li></ul><br><p><img src="https://habrastorage.org/webt/h6/9q/u6/h69qu6qopmj-_h8pcexpzcuzth0.png">  <em><strong>Figure 1.</strong> What are middleware-services</em> </p><br><p>  In addition, in [2] even more hundreds of vulnerable mobile applications are listed (see Fig. 2).  Including: Android's Google Cloud Messaging, Angie's List of Business Center Passwords, AT &amp; T Global Network Client, CapitalOne Spark Pay, Cisco OnPlus (remote access), Cisco Technical Support, Cisco Webex, Cisco WebEx Passwords, Dominos Pizza, E-Trade, Freelancer , Google Earth, Huntington Mobile (Bank), Intuit Tax Online Accountant, iTunes Connect, Microsoft Skype, Oracle Now, Pinterest, SafeNet (VPN client), SouthWest Airlines, Uber, US Bank - Access Online, WesternUnion, WordPress, Yahoo!  Finance, Yahoo!  Mail. </p><br><p><img src="https://habrastorage.org/webt/u4/qz/rd/u4qzrdgik4ygb_j1jalyckamwmo.png">  <em><strong>Figure 2.</strong> A small sample from the list of vulnerable mobile applications</em> </p><br><h1 id="logicheskie-uyazvimosti-ssltls-protokola">  Logical SSL / TLS Protocol Vulnerabilities </h1><br><p>  SSL / TLS connections of all this and many other software are vulnerable to a wide range of MiTM attacks.  At the same time, MiTM-attack can be carried out, often, even without forging certificates and without stealing private keys with which the servers sign their certificates.  A MiTM attack can be performed by simply exploiting the logical vulnerabilities that are present in the SSL / TLS certificate verification procedure on the client software side.  As a result, the MiTM attacker may, for example, collect authorization tokens, credit card numbers, names, addresses, etc.  - any merchant who uses vulnerable payment processing web applications. </p><br><p>  Mobile software providers who take the AdMob sample code to link their applications to an AdMob account are also vulnerable - they allow an attacker to capture account data and access all of his Google services.  For example, due to incorrect verification of certificates in instant messengers such as Trillian and AIM, a MiTM attacker could steal login credentials to all Google services (including Gmail), Yahoo !;  and also to Windows Live services (including SkyDrive).  Among other vulnerabilities that modern non-browser web-software suffers are: the use of incorrect regular expressions when comparing the host name;  ignoring the results of certificate validation;  accidental or intentional disabling of the scan.  [one] </p><br><h1 id="drugie-rasprostranyonnye-uyazvimosti-realizacii-ssltls-protokola">  Other common SSL / TLS implementation vulnerabilities </h1><br><p>  And of course, one should not forget that even if there are no logical errors in the implementation of the SSL / TLS protocol (if of course someone still believes in it), then protection can be circumvented by stealing the private key [12], by using 0day- exploits for such things as keyboards, browsers, operating systems, utilities and firmware [3];  by compromising BGP routing [10];  or attack SSL / TLS through hardware (see Fig. 3) [8] and / or software [9] bypass channels. </p><br><p><img src="https://habrastorage.org/webt/ia/ft/cx/iaftcxtvwltpvjrjsrl1kveoeoe.png">  <em><strong>Figure 3.</strong> SSL attack on hardware bypass channels</em> </p><br><p>  In addition, attackers can perform virtually invisible MiTM-attacks, abusing the caching mechanism of SSL / TLS-sessions, implemented in the class SSLSessionCache.  This mechanism verifies the validity of certificates only during the initial connection;  nor is it able to properly cancel a communication session after deleting certificates from the device.  In addition, after restarting the Android device (via the ‚ÄúRestart‚Äù or ‚ÄúPower Off‚Äù options), you can continue to see encrypted traffic from some applications that did not start after the restart, but worked before the restart.  So for example with Google Maps going on.  In [2], it is described how, thanks to these caching flaws, an attacker can completely transparently allow the user to install and remove ‚Äúinvisible certificates‚Äù, and then establish a network connection with any application. </p><br><p><img src="https://habrastorage.org/webt/ug/jc/nl/ugjcnltgragwjfsa3uqtswrwkoe.png">  <em><strong>Figure 4.</strong> Retrospective Vulnerable Encryption</em> </p><br><p>  Other common SSL / TLS protocol implementation vulnerabilities include vulnerable encryption (see Figure 4) [5], GCM reuse (Galois / Counter Mode; counter with Galois authentication) [6], CNG trickery (CryptoAPI-NG ) in Schannel (see Fig. 5) [7], incorrect verification of the trust chain [2], incorrect verification of the host name [11]. </p><br><p><img src="https://habrastorage.org/webt/er/yb/sn/erybsnnakygfotqkha9beavus-g.png">  <em><strong>Figure 5.</strong> CNG trick: pulling secrets out of Schannel</em> </p><br><p> An incorrect trust chain check is a situation where a web application accepts absolutely any certificate that indicates the correct host name without checking which certificate authority it was signed with.  This allows you to intercept and decrypt passwords and / or credit card numbers.  And in some cases, even make an injection of malicious code.  This vulnerability penetrates into Android software, for example, when a customized X509TrustManger interface is created that ignores CertificateException exceptions.  Or when a software developer inserts a call to the SslErrorHandler.proceed () method in the code of the WebViews component.  [2] </p><br><p>  Incorrect verification of the host name is a situation where the web application accepts a certificate without making sure that the host from which this certificate came is in the list of trusted hosts.  This vulnerability penetrates to Android software, for example, when a HostnameVerifier interface is created, which returns TRUE under any conditions.  Or when a software developer inserts a call to the SslErrorHandler.proceed () method in the WebViews component code.  [2] </p><br><h1 id="korennaya-prichina-suschestvovaniya-uyazvimostey-v-ssltls-protokole">  The root cause of the existence of vulnerabilities in the SSL / TLS-protocol </h1><br><p>  The root cause of the overwhelming majority of the listed vulnerabilities is the terrible API design of the SSL / TLS libraries (including JSSE, OpenSSL, and GnuTLS).  As well as the equally awful design of data transfer libraries (such as cURL, Apache HttpClient and urllib), each of which is a high-level wrapper for SSL / TLS libraries.  Not to mention middleware services (such as Apache Axis, Axis 2, or Codehaus XFire), which are even more high-level wrappers, and which increase the snowball of a terrible design even more.  Instead of communicating with an application developer (often far from system programming) in a language he understands (in terms of confidentiality and authentication), abstracting from the low-level details of the SSL / TLS protocol implementation, these APIs dump a bunch of low-level SSL / TLS parameters on the poor guy , incomprehensible to him.  They require high-level software to correctly set low-level options;  implemented the functions of checking the host name and took care of interpreting the values ‚Äã‚Äãreturned by low-level operations. </p><br><p>  As a result, application developers use the SSL / TLS API incorrectly: they misinterpret the variety of their parameters, options, side effects, and return values.  For example [1]: </p><br><ul><li>  Amazon's PHP Library Flexible Payments Service is trying to turn on host name verification by setting the CURLOPT_SSL_VERIFYHOST parameter to TRUE (in the cURL library).  However, the correct default value for this parameter is 2;  if, however, you assign it a value of TRUE, then this parameter, imperceptibly for the developer, is assigned the value 1, and so  certificate verification is disabled. </li><li>  PHP-library PayPal Payments Standard - acquired the same error;  and at that moment, when the previous, vulnerable, implementation was updated (i.e., one error was removed, another was added). </li><li>  Another example is Lynx, a text-oriented browser.  It checks self-signed certificates, but only if the GnuTLS certificate verification function returns a negative value.  However, this very function for some errors returns 0;  including in cases where certificates are signed by an untrusted authority.  Because of this, the trust chain in Lynx is broken. </li></ul><br><p>  In addition, application developers often misunderstand what kind of security guarantees a particular SSL / TLS library provides.  Therefore, in the wild, you can find clinical cases where applications that are fundamentally in need of secure communications (for example, interacting with a payment processor) use an SSL / TLS library that does not check SSL / TLS certificates at all.  More prosaic, but even more deadly, is when a developer of any of the intermediate layers of software silently disables the SSL / TLS certificate verification procedure (he can do this, for example, to test the system, and after testing, forget to re-enable it).  At the same time, high-level program code using this intermediate layer is sure that certificates are checked.  So  SSL / TLS errors are often hidden in the depth of one or several intermediate library layers at once ‚Äî which makes it almost impossible to detect this problem. </p><br><p>  For example, in JSSE (Java Secure Socket Extension), the advanced interface SSLSocketFactory API silently skips checking the host name if the "algorithm" field in the SSL client is set to NULL or to an empty string, but not to HTTPS.  Although this is mentioned in the JSSE Reference Manual, many Java implementations of the SSL protocols use SSLSocketFactory without performing a host name check ... </p><br><h1 id="lozhka-myoda-v-bochku-dyogtya">  A spoon of honey in a tar barrel </h1><br><p>  Thus, in fact, it turns out that in most modern non-browser web software, SSL / TLS certificate checking is either disabled completely or not implemented correctly.  Figure 7 presents the classification of the current SSL / TLS protocol vulnerabilities.  Some of these vulnerabilities, but not all, have been described and / or mentioned above.  You can familiarize yourself with the mentioned but undescribed vulnerabilities by reading the materials listed in the bibliography. </p><br><p><img src="https://habrastorage.org/webt/qc/zm/pr/qczmpr2oacz3cprgolpbb4ryhxm.png">  <em><strong>Figure 6.</strong> Classification of SSL / TLS vulnerabilities relevant</em> </p><br><p>  Well, to add a spoonful of honey to the tar barrel, it is worth noting that [1] describes in detail / clearly / popularly / correctly how SSL should be implemented, with reference to the RFC.  We did not find a better description that would be technically accurate and at the same time understandable.  Also in [1], the most common SSL libraries are sorted, with classification by level of abstraction (low-level / high-level).  All with diagrams and laconic algorithms in pseudocode.  Details of the specific product vulnerabilities are described, with an incorrect code, and an indication of errors.  So if suddenly someone once again has a desire to create such an implementation of the SSL / TLS framework, which will be an exception to the saying ‚Äúthey wanted it better, but it turned out as always,‚Äù then [1] is an ideal beginning. </p><br><div class="spoiler">  <b class="spoiler_title">Bibliography</b> <div class="spoiler_text"><p>  <strong>1.</strong> <em>Martin Georgiev, Rishita Anubhai, Subodh Iyengar.</em>  The Most Dangerous Code in the World: Validating SSL Certificates in Non-Browser Software // Proceedings of the 2012 ACM conference on computer and communications security.  2012. pp.  38-49. <br>  <strong>2.</strong> <em>Tony Trummer.</em>  Mobile SSL Failures // Proceedings of the HITB Security Conference.  2015 <br>  <strong>3.</strong> <em>Kellen Evan Person.</em>  <a href="https://fly.io/articles/how-ciphersuites-work/">How Ciphersuites Work: TLS in Pieces</a> // 2017. <br>  <strong>4.</strong> <em>Catalin Cimpanu.</em>  <a href="https://www.bleepingcomputer.com/news/security/extended-validation-ev-certificates-abused-to-create-insanely-believable-phishing-sites/">Extended Validation (EV) Certificates Abused to Create Insanely Believable Phishing Sites</a> // Bleeping Computer.  2017 <br>  <strong>5.</strong> <em>David Adrian.</em>  A Retrospective on the Use of Export Cryptography // Black Hat.  2016 <br>  <strong>6.</strong> <em>Sean Devlin.</em>  Nonce-Disrespecting Adversaries: Practical Forces Attacks on GCM in TLS // Black Hat.  2016 <br>  <strong>7.</strong> <em>Jake Kambic.</em>  Cunning with CNG: Soliciting Secrets from Schannel // Black Hat.  2016 <br>  <strong>8.</strong> <em>Valeria Bertacco.</em>  Torturing OpenSSL // Black Hat.  2012 <br>  <strong>9.</strong> <em>Tom van Goethem.</em>  HEIST: HTTP Encrypted Information Can Be Stolen Through TCP-Windows // Black Hat.  2016 <br>  <strong>10.</strong> <em>Artyom Gavrichenkov.</em>  Breaking Https With BGP Hijacking // Black Hat.  2016 <br>  <strong>11.</strong> <em>Chris Stone, Tom Chothia.</em>  Spinner: Semi-Automatic Detection of Pinning without Hostname Verification // Proceedings of the Annual Computer Security Applications Conference (ACSAC) 2017. <br>  <strong>12.</strong> <em>Marco Ortisi.</em>  Recover a Session with Perfect Forward Secrecy // Black Hat.  2016 </p><br><p>  <strong>Ps.</strong>  The article was originally published on <a href="https://xakep.ru/2018/03/08/ssl-tls-fuckup/">Hacker</a> . </p></div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/454856/">https://habr.com/ru/post/454856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454832/index.html">Why a four-day work week is a bad fairy tale.</a></li>
<li><a href="../454834/index.html">Real terms of studying blind typing with low motivation</a></li>
<li><a href="../454840/index.html">Careful transfer to the Netherlands with his wife and mortgage. Part 2: document preparation and relocation</a></li>
<li><a href="../454844/index.html">Odaydzhest: interesting for designers for the week</a></li>
<li><a href="../454850/index.html">Evolution of a single algorithm</a></li>
<li><a href="../45486/index.html">Street Performer Protocol Model - Possible Solution to Piracy Issues</a></li>
<li><a href="../454866/index.html">Siemplify, a Tel Aviv-based cyber security systems management company, raised $ 30 million in Round C</a></li>
<li><a href="../454868/index.html">Compiling C to WebAssembly without Emscripten</a></li>
<li><a href="../45487/index.html">How much is a hundred credit cards?</a></li>
<li><a href="../454872/index.html">Space Invaders: now in 512 bytes (Assembler x86)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>