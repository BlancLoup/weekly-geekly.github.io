<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Notes on SQL and relational algebra</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√© and beyond, they often discuss relational algebra and SQL, but far less often focus on the connections between these formalisms. In this arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Notes on SQL and relational algebra</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/0db/fb4/d0d/0dbfb4d0d4dd40fa9d12e9287e2cdc9a.png"><br><br>  On Habr√© and beyond, they often <a href="http://habrahabr.ru/post/145381/">discuss</a> relational algebra and SQL, but far less often focus on the connections between these formalisms.  In this article, we will go to the very roots of query theory: relational calculus, relational algebra, and the SQL language.  We will analyze them with simple examples, and also see that it can be useful to switch between formalisms for analyzing and writing queries. <br><br>  Why might it be needed today?  Not only data analysts and database administrators have to work with data, in fact very few people don‚Äôt have to extract something from (semi-) structured data or transform existing ones.  In order to have a good idea why query languages ‚Äã‚Äãare arranged in a certain way and consciously use them, you need to deal with the underlying core.  We will talk about this today. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Most of the articles are examples interspersed with theory.  At the end of the sections are links to additional materials, and for those interested, and a small selection of literature and courses at the end. <br><br><p>  Content </p><br><br><ul><li>  <a href="http://habrahabr.ru/post/275251/">Relational algebra</a> </li><li>  <a href="http://habrahabr.ru/post/275251/">SQL</a> </li><li>  <a href="http://habrahabr.ru/post/275251/">Relational calculus</a> </li><li>  <a href="http://habrahabr.ru/post/275251/">Equality of Formalisms (Codd's Theorem)</a> </li><li>  <a href="http://habrahabr.ru/post/275251/">Conjunctive Queries (CQ)</a> </li><li>  <a href="http://habrahabr.ru/post/275251/">Computational complexity</a> </li><li>  <a href="http://habrahabr.ru/post/275251/">Query properties and analysis</a> </li><li>  <a href="http://habrahabr.ru/post/275251/">An example of using RA to optimize queries</a> </li><li>  <a href="http://habrahabr.ru/post/275251/">Literature, materials and slides</a> </li></ul><a name="habracut"></a><br><a name="relational_algebra"></a><h1>  Relational algebra </h1><br><h2>  Main operators </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4fb/daf/570/4fbdaf5703c6923711d9baa20c7dc262.svg" alt="A">  - the relation A itself (the relation here is synonymous with a table and a predicate) is an expression of relational algebra, moreover, since it is an algebra, any expression of a relational algebra returns a relation (the closure property of operators) </p><br><br><h3>  Selection (selection; restriction) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e93/fbe/61d/e93fbe61d3439d36cf9184558cc99264.svg" alt="\ sigma_ \ phi (A)">  - selection (selection; restriction), A - relation (predicate, table), <img src="https://habrastorage.org/getpro/habr/post_images/871/f41/a31/871f41a3149b588318eb29f5385446f8.svg" alt="\ phi">  - Boolean formula by which the selection of lines (tuples, records, etc) </p><br><br><p>  Selection is essentially a horizontal line filter, i.e., you can imagine that we go along each line and leave only those that satisfy the condition <img src="https://habrastorage.org/getpro/habr/post_images/871/f41/a31/871f41a3149b588318eb29f5385446f8.svg" alt="\ phi">  .  A simple example for clarity: </p><br><img src="https://habrastorage.org/files/4f9/9e8/018/4f99e8018c184cafb171935cf48b4e54.png"><br><h3>  Projection </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/118/20a/1ae/11820a1ae460257509b5a6b27db11d5e.svg" alt="\ Large \ pi_ {a, b, \ dots} (A)">  - projection on the attributes A, B, ....  Returns a table in which only columns (attributes) A, B, ... remain.  A simple example is below.  In essence, it is a filter by attributes i.  it is in a sense a vertical filter. </p><br><img src="https://habrastorage.org/files/d91/6ba/35c/d916ba35c8d9431d9fb727f3a9d8a4fb.png"><br><h3>  Rename </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/59d/ce7/cf4/59dce7cf471b41648db732eddef462ba.svg" alt="\ rho_ {a, b} (A)">  - renames the column a to b in relation to A (attribute, predicate argument, etc);  two teas to the gentleman who will show that algebra is strictly more expressible with the renaming operator (we need to give an example of a query that we cannot express without this operator, but we will express it with <img src="https://habrastorage.org/getpro/habr/post_images/624/ede/4ec/624ede4ec661d07a134064b30b06cfce.svg" alt="\ rho">  ) </p><br><br><h3>  Cartesian product </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/71d/54e/b89/71d54eb897176921ad6f90921b256cbd.svg" alt="A \ times B">  - Cartesian product of two relations, a large ratio of all possible combinations of strings in A and B. </p><br><img src="https://habrastorage.org/files/9a6/78d/1c8/9a678d1c87c7494682ce243cdd4708c1.png"><br><h2>  Set operations </h2><br><p>  Relational algebra is an extension of the classical set of operators over sets (a relation is a set of ordered tuples; note that this is not at all equal to the ordered set of tuples).  Suppose we have a table StudentMark (Name, Mark, Subject, Date) - then the tuple (Vasya, 5, Informatics, 10/05/2010) is ordered - first the string Name on the first (ok, or zero) position, an integer on the second, line on the third and date on the fourth.  At the same time, the ordered tuples themselves (Name, Mark, Subject, Date) are not ordered ‚Äúwithin‚Äù the relationship. </p><br><br><h3>  Union </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/913/287/31b/91328731bfb3d3db36b54a8648aebebc.svg" alt="A \ cup B">  - union of all strings in A and B, restriction - identical attributes </p><br><img src="https://habrastorage.org/files/34a/254/9c8/34a2549c89254575944aaa05eb9c030a.png"><br><h3>  Intersection </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c9c/574/8f8/c9c5748f820c3c8b08da2be16862cfc4.svg" alt="A \ cap B">  - the intersection of lines, the same restriction </p><br><img src="https://habrastorage.org/files/6ef/d4b/c8d/6efd4bc8d842455ab0ca7cebe8fd3449.png"><br><h3>  Set difference </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/566/24f/92a/56624f92a0fa8e3bb0416ee2505a6d35.svg" alt="B \ backslash A">  - B minus A, all strings that are present in B, but not in A, the same restriction </p><br><img src="https://habrastorage.org/files/dd3/e1b/310/dd3e1b3106be4e3194474712022b1056.png"><br><p>  (B \ A; A - on the left, B - on the right) </p><br><br><h3>  Auxiliary operators </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ed7/d9c/ea0/ed7d9cea038893987e71d83f1854ae08.svg" alt="A \ bowtie _ {\ phi} B \ equiv \ sigma _ {\ phi} (A \ times B)">  - join (connection);  join joins two records of tables A and B, provided that the condition œÜ is met for these two records. </p><br><img src="https://habrastorage.org/files/777/5aa/87a/7775aa87a0ac42b8ad31bfaf72ac8649.png"><br><h2>  Tasks for warming up </h2><br><p>  We will work with the following scheme. <br><img src="https://habrastorage.org/files/55c/0e6/6f2/55c0e66f22a245ddba7357c52147f28d.png"><br>  (The diagram is taken from the book: Elmasri, Navathe - Fundamentals of Database systems; for everyone: I highly recommend NOT the book; see the selection at the end) </p><br><br><p>  Next, we consider several simple problems on relational algebra. </p><br><br><p>  <strong>Task one.</strong>  <em>Print the names of all 5th Department employees who work more than 10 hours a week on Project X.</em> </p><br><br><p>  (Intermediate results can be ‚Äúpreserved‚Äù in new relationships, but this is not necessary.) </p><br><div class="spoiler">  <b class="spoiler_title">The solution to the first problem.</b>  <b class="spoiler_title">Relational algebra</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/567/8bb/0a8/5678bb0a811b432db8311811a5cb9295.png"><br></div></div><br><p>  <strong>Task two.</strong>  <em>Print the names of all employees directly supervised by Franklin Wong</em> (and find a small mistake in the decision below) <br></p><div class="spoiler">  <b class="spoiler_title">The solution of the second problem.</b>  <b class="spoiler_title">Relational algebra</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/c80/811/fd5/c80811fd576b43ef92f9c4607051c0c7.png"></div></div><br><br><p>  <strong>The third task</strong> will require the use of a new operator - ‚Äúaggregation‚Äù.  Consider it by example: </p><br><br><p>  For each project, print the name and total number of hours per week that all employees spend on this project. </p><br><div class="spoiler">  <b class="spoiler_title">The solution of the third problem.</b>  <b class="spoiler_title">Relational algebra</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/1d9/9b5/f6b/1d99b5f6b2c342b594f777f6c8ac3c84.png"><br></div></div><br><p>  Note that the query has the form a F b (A), where a, b are columns, A is a relation, and a is an aggregation function (for example, SUM, MIN, MAX, COUNT, etc).  It reads as follows: for each value in column a, count b.  That is, one value in column a can correspond to several lines, put the values ‚Äã‚Äãof column b from this set of lines in the function and create a new attribute fun_b with the appropriate value. <br><br></p><p>  This query cannot be expressed in a ‚Äúclassical‚Äù relational algebra (without the aggregation operator F).  That is, you cannot write a single query that, for any database that satisfies the schema, gives the correct answer. </p><br><br><p>  From where exactly the given result follows, we will analyze later; now we can only note that requests with aggregation belong to a higher class of computational complexity. </p><br><br><p>  We will consider and analyze more interesting examples of problems later in the article.  There's also a small selection of problems on relational algebra with solutions available <a href="https://github.com/SergeyParamonov/HabraData/tree/master/Slides%2520queries">here.</a> </p><br><br><a name="SQL"></a><h1>  SQL </h1><br><p>  In this part we will talk about SQL (Structured Query Language) and show how SQL corresponds to relational algebra with simple examples. </p><br><br><p>  Consider the very first task again: </p><br><br><p>  <strong>Task one.</strong>  <em>Print the names of all 5th Department employees who work more than 10 hours a week on Project X.</em> </p><br><br><p>  The classic solution is as follows: <br></p><div class="spoiler">  <b class="spoiler_title">The classic solution.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a04/f33/a76/a04f33a761294505afe22a05e99107cf.png"><br></div></div><br><br><p>  Alternatively, you can write this: <br></p><div class="spoiler">  <b class="spoiler_title">A bit alternative.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/934/32c/dbd/93432cdbd80c45dc95dc0d61912807bf.png"><br></div></div><br><br><br><p>  Or quite alternatively: <br></p><div class="spoiler">  <b class="spoiler_title">With subquery</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/40c/982/7ed/40c9827ed8ff415fa111f7f3aba9c5df.png"></div></div><br><br><br>  (further solutions are not removed under spoilers) <br><br><h3>  Draw an analogy between SQL and relational algebra </h3><br><br><p>  In the second solution, we see a distinct analogy with relational algebra: </p><br><img src="https://habrastorage.org/files/003/4e6/a03/0034e6a034714952bf4b24b53edb9b09.png"><br><p>  Now use equality for join and see the analogy between SQL and relational algebra in the first solution </p><br><img src="https://habrastorage.org/files/d3c/4e6/d23/d3c4e6d23bae4618afd19a5000b5caa3.png"><br><p>  No matter how ironic it is, but SELECT in SQL is the project (œÄ; projection) in relational algebra. </p><br><br><p>  Now consider the problem with aggregation and compare it with the solution on relational algebra: </p><br><img src="https://habrastorage.org/files/c13/71b/f86/c1371bf86c494faf80d0cca61fe5c88c.png"><br><p>  We will look at more interesting problems later in the article (also a small selection <a href="https://dl.dropboxusercontent.com/u/12373089/Paramonov_SQL.pdf">here</a> ), and now we will consider another query formalism. </p><br><br><a name="relational_calculus"></a><h1>  Relational calculus </h1><br>  Attentive reader now could exclaim: why goat bayan?  What we lack here is two formalisms for writing queries, what is the third one for? <br><br>  Relational calculus is an adaptation of first order logic (FOL: first order logic) for writing queries.  FOL is one of the most well-studied formalisms of mathematics and makes it possible to use the already created theoretical apparatus and classical results for analyzing and writing queries. <br><br>  Many results in complexity, (not) expressibility and formation of queries came to the database from logic, precisely because of relational calculus, therefore it is worth getting acquainted with this formalism. <br><br><p>  To parse and talk about relational calculus, we need first-order logic, which can be refreshed <a href="https://ddll.inf.tu-dresden.de/w/images/d/d3/Fol2015.pdf">here</a> . </p><br><br><p>  Let œÜ (X) be a first-order formula, and X are free variables, that is, they are not quantified (‚àÄ is a universal quantifier, is an existence quantifier), then the query in relational calculus defines a set: </p><br><br><p>  {X |  œÜ (X)} </p><br><br><p>  Consider simple examples on which we analyze the formalism: </p><br><br><p>  Let R be a relation with three attributes a, b, c;  then rewrite the following query of relational algebra: </p><br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e12/ec6/636/e12ec6636c160dbef3e336edcd3699f5.svg" alt="\ sigma_ {a = b} (R (a, b, c))">  in relational terms like: </p><br><br><p>  {ra, rb, rc |  R¬Æ and ra = rc} </p><br><br><p>  Translating into simple language r is a tuple in R (that is, a string with attributes whose values ‚Äã‚Äãcan be obtained through a point by name, ie, ra is an attribute of a tuple r (strings) with respect to R (table)).  As we see, there are no quantifiers here, since r is at the output of the query and should be a free tuple. </p><br><br><p>  Consider another simple example: R (a, b, c) ‚àó S (c, d, e), where * is a natural join, i.e.  join by name - as the join condition, take attributes with the same name. </p><br><br><p>  {rA, rB, rC, sD, sE |  R¬Æ and S (s) and rC = sC} </p><br><br><p>  If sD and Se were not among the output parameters, the request would have the following form: </p><br><br><p>  {rA, rB, rC |  R¬Æ and ‚àÉs: S (s) and rC = sC} </p><br><br><p>  We would be obliged to put a quantifier of existence, since S is contained only in the "body" of the request. </p><br><br><p>  When making such queries, you should always be careful with the quantifier of universality if we write the following expression (for illustration purposes only): </p><br><br><p>  {rA |  R¬Æ and ‚àÄs: S (s) and rC = sC and sE = ‚Äúbanana‚Äù} </p><br><br><p>  That, this query will always return an empty set, since in order for the query conditions to be fulfilled it is necessary that every tuple in the world of length three belongs to S and has the value of the last attribute ‚Äúbanana‚Äù. </p><br><br><p>  Usually, together with the universal quantifier, the implication ‚Äú=&gt;‚Äù is used, we can rewrite the query as follows: </p><br><br><p>  {rA |  R¬Æ and ‚àÄs: (S (s) and rC = sC) =&gt; sE = "banana"} </p><br><br><p>  If s belongs to S and the value of C is the same as C in R, then the last attribute should have the value banana. </p><br><br>  <a href="https://dl.dropboxusercontent.com/u/12373089/Paramonov_Relational_Calculus.pdf">Here</a> you can find a short selection of problems on relational calculus with solutions. <br><br><a name="codd_theorem"></a><h1>  Equality of Formalisms (Codd's Theorem) </h1><br><p>  In simple terms, Codd's theorem sounds like this: all three SQL formalisms, relational algebra, and relational calculus are equal.  Here is <a href="http://www.dbai.tuwien.ac.at/staff/pichler/dbt/slides/dbt03.pdf">a</a> lot of theory for those interested. </p><br><br><p>  That is, any query expressed in one language can be reformulated in another.  This result is primarily convenient in that it allows the use of the most convenient formalism for analyzing a query, and secondly it connects declarative SQL languages ‚Äã‚Äãand relational calculus with imperative relational algebra.  That is, by translating a query from SQL to relational algebra, we already get a way to execute the query (and optimize it). </p><br><br><a name="conjunctive_queries"></a><h1>  Conjunctive Queries (CQ) </h1><br><p>  Requests that consist of a select (œÉ) -project (œÄ) -join (‚ãà) segment of relational algebra are called conjunctive queries (ok, I omitted renaming, we consider it implicitly present). </p><br><br><p>  If you have read this line, try to solve the following problem using only these three operators (and of course the relationship): </p><br><br><p>  <strong>Task.</strong>  <em>Print the names of all the workers who work on each project.</em> </p><br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text">  It's impossible.  Why read on. <br></div></div><br><p>  Consider which segment of SQL and relational calculus this class of relational algebra belongs to. </p><br><br><a name="complexity"></a><h1>  Computational complexity </h1><br><p>  There are several different ways to measure the computational complexity of the query, between them are often confused therefore write out the definitions and their names: </p><br><br><p>  Let Q is a query, D is a database, and you need to calculate Q (D) </p><br><ul><li>  If Q is fixed, then the complexity of the calculation of f (D) is called data complexity (data complexity) </li><li>  If D is fixed, then the complexity of the calculation of f (Q) is called the complexity of the query (query complexity) </li><li>  If nothing is fixed, then the complexity f (Q, D) is called the combined complexity (combined complexity) </li></ul><br><p>  Important facts: SQL complexity <em>by data</em> (and all the others) belongs to the class AC0 - this is a very good complexity class, i.e., queries can be calculated very effectively. </p><br><br><p>  From a theoretical point of view, you can look at this picture here: <br><img src="https://habrastorage.org/getpro/habr/post_images/47a/3ee/c9e/47a3eec9e0d5ee675f6f63dbc991ae76.png"></p><br><br><p>  AC0 lies within NL (more precisely, even within one of the NC layers within NL). </p><br><br><p>  Consider the following interesting question related to computational complexity: let f be a function of the satisfiability of a formula, that is, for each query, it says whether a database exists such that Q (D) is true.  From the Codd theorem, we know that relational algebra and SQL are equivalent to relational calculus.  So, the calculation of f is equivalent to the stopping problem (the SAT for the first order logic is not computable).  From here: there are no algorithms that, for an arbitrary SQL query, could determine its consistency. </p><br><br><p>  For those interested, I also recommend: <a href="https://en.wikipedia.org/wiki/Trakhtenbrot%2527s_theorem">Trakhtenbrot theorem</a> </p><br><br><h3>  Difficulty Conjunctive Queries </h3><br><p>  CQs are one of the most studied classes of queries as they make up the bulk of database queries (I saw a figure of 90% on one presentation, but I can‚Äôt find the source now).  Therefore, we consider in more detail their complexity and prove that in reality their combined complexity is equal to NP, i.e.  The task is NP complete.  (You can read about full NP <a href="http://habrahabr.ru/post/207112/">here</a> and <a href="http://habrahabr.ru/post/208774/">here</a> .) </p><br><br><p>  To do this, we write an arbitrary CQ query in relational calculus in the form: </p><br><br><p>  {X |  [‚àÉX0:] p0 (X0) and [‚àÉX1:] p1 (X1) and [‚àÉX1:] p (X2) ...} </p><br><br><p>  Where [.] Is an optional quantifier.  Why is such a representation always permissible?  Because the project here can always be expressed in X i. <img src="https://habrastorage.org/getpro/habr/post_images/820/3b6/2ea/8203b62eab63b766844430da7c2a71ff.svg" alt="X \ subseteq \ cup_i X_i">  , join is expressed in terms of equality of variables in <img src="https://habrastorage.org/getpro/habr/post_images/c23/d0b/351/c23d0b3511a20d44f1c87b4b4771bf6a.svg" alt="X_i">  , and select through conditions on <img src="https://habrastorage.org/getpro/habr/post_images/c23/d0b/351/c23d0b3511a20d44f1c87b4b4771bf6a.svg" alt="X_i">  in the request body. </p><br><br><p>  To show that the task belongs to the class NP-complete, you need to do two things. </p><br><ul><li>  Show that task inside NP class </li><li>  Show that NP is a complete task comes down to this </li></ul><br><p>  The first condition is trivial: since the values ‚Äã‚Äãof relations are finite (that is, the set of all possible values), we can ‚Äúguess‚Äù the function nondeterministic <img src="https://habrastorage.org/getpro/habr/post_images/79e/354/574/79e354574a2c34442463ebb72a2cead0.svg" alt="\ alpha">  such that makes each relationship true under the quantifiers of existence. </p><br><br><p>  We show that the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D0%25BA%25D1%2580%25D0%25B0%25D1%2581%25D0%25BA%25D0%25B0_%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25BE%25D0%25B2">graph coloring</a> problem is reduced to the problem of the feasibility of a CQ query. </p><br><br><p>  Let D consist of one relation edge = {(red, green), (green, red), (blue, red), (green, blue) ...} - all possible correct colorings of the graph, such that no two vertices have the same color . </p><br><br><p>  Let the original graph be given as a set of edges <img src="https://habrastorage.org/getpro/habr/post_images/a84/0cf/e79/a840cfe795033e2ac60c266b6142f7fa.svg" alt="\ textit {edge} = \ {(v_i, v_j) \}"></p><br><br><p>  Then, we write the following query </p><br><br><p>  {() |  ‚àÉX0 ... ‚àÉXN: edge (V1, V2) and ... edge (V_i, V_j) ...} </p><br><br><p>  That is, each arc in the source graph in the query will correspond to an edge relation with the corresponding arguments.  If the request returned an empty tuple, it means that there is such a function. <img src="https://habrastorage.org/getpro/habr/post_images/79e/354/574/79e354574a2c34442463ebb72a2cead0.svg" alt="\ alpha">  that displays <img src="https://habrastorage.org/getpro/habr/post_images/dc4/218/7ab/dc42187aba7c1e4cce811949271f621b.svg" alt="V_i \ mapsto \ {red, green, blue \}">  , and no two vertices will have the same color (follows from the definition of D).  C.T.D. </p><br><br>  Question with an asterisk: from the select-project-join segment we throw out the project, how will the computational complexity change? <br><br><h3>  Transitive closure </h3><br>  Determining the complexity of the data and on request also shed light on one known result - in classical SQL (without with) the <a href="https://en.wikipedia.org/wiki/Transitive_closure">transitive closure is</a> inexpressible with a fixed query ie.  you cannot write a single query such that for any database it would calculate the predicate closure.  That is, if we have a graph saved as an edge relationship, then we cannot write one fixed query that would calculate the reachability relation for an arbitrary graph.  Although intuitively it seems that such a query should clearly lie in the class CQ. <br><br>  This can be seen either from computational complexity ‚Äúby data‚Äù, or it is much more constructive and interesting that follows from <a href="https://en.wikipedia.org/wiki/Compactness_theorem">the compactness</a> theorem and Codd's theorem (SQL = First Order Logic). <br><br>  The proof is non-trivial and can be skipped without losing the understanding of further material. <br><div class="spoiler">  <b class="spoiler_title">Sketch of evidence</b> <div class="spoiler_text">  <b>The compactness theorem: an</b> infinite set of formulas is feasible (it has a model ‚Äî an interpretation in which all formulas are correct), if and only if any finite subset of this set is feasible. <br><br>  <b>G√∂del:</b> first-order logic is compact. <br>  <b>Codd:</b> SQL - first order logic <br><br>  Proof by contradiction, let T (a, b) be the path from a to b.  P_n (a, b) is the path from a to b of length n.  Then ~ P_n (a, b) - from a there is no path to b of length n. <br><br>  Take the following finite set {T (a, b), ~ P_1 (a, b), ~ P_2 (a, b) ... ~ P_k (a, b)} - it is feasible, since we take a path of length k + 1 and T (a, b) is fulfilled and all ~ P_1 ... ~ P_k are also satisfied.  Moreover, any finite set of this type is feasible, and therefore, by the compactness theorem, their infinite union must be feasible. <br><br>  However, ~ P_k - must be true for ANY k, that is, there must not be a path of any length from a to b, and to run T (a, b) such a path must exist.  Contradiction.  QED <br><br></div></div><br><br>  If the query is not fixed, then the problem becomes trivially solvable.  Let me have only k edges in the database, it means the largest path is no more than k, it means that you can write the query in an explicit form, as a union of paths of length 1, 2, ... k and thus get a query that computes reachability in the graph. <br><br><a name="query_analysis"></a><h1>  Query properties and analysis </h1><br><p>  Now back to the task proposed earlier: </p><br><br><p>  <em>Print the names of all the workers who work on each project.</em> </p><br><br><p>  Why this problem has no solution in the CQ class we can understand by defining the key properties of the query itself and the CQ class. </p><br><br><p>  The definition, the query Q is called monotonous, if and only if, for any two databases <img src="https://habrastorage.org/getpro/habr/post_images/26d/ac9/9b4/26dac99b497d1b8c3778990e06f15468.svg" alt="D_1 \ subseteq D_2">  right that <img src="https://habrastorage.org/getpro/habr/post_images/536/8c9/45a/5368c945aaeb1b8c1a7e733c67a5a022.svg" alt="Q (D_1) \ subseteq Q (D_2)">  .  That is, an increase in the database can only increase the number of tuples in the output or remain the same. </p><br><br><p>  Observation: CQ is a class of monotonically increasing queries.  Imagine an arbitrary CQ request Q - it consists of select-project-join.  Let us show that each of them is a monotone operator: </p><br><br><p>  Suppose we have added another entry in D </p><br><ul><li><p>  select - filters records vertically, if a new record satisfies the query, then the set of answers increases, if not, it remains the same. </p><br></li><li><p>  project - does not affect the additional tuple </p><br></li><li><p>  join - if the corresponding record is also in the second set, then the response set will expand, otherwise it will remain the same. </p><br></li></ul><br><p>  Superposition of monotone operators monotone =&gt; CQ is a class of monotonous queries. </p><br><br><p>  Question: Is the original task monotonous?  Not really.  Suppose we have only one employee Petya, who is working on two projects A and B, and we have 2 projects A and B in total, which means Petya must be in issuing a request.  Suppose we added the third project C =&gt; now Petit is not in the answer and the response set is empty, which means the request is not monotone. </p><br><br><p>  The following question logically follows from this: what do you need to add to the select-project-join so that the problem is solved?  This is something that should be non-monotonic! </p><br><br><p>  As of course, the reader guessed - the difference of sets.  His asymmetry seemed to tell us and set it apart from the very beginning. </p><br><br><p>  However, before writing a solution, we make one more observation: if there are no counter-examples to the statement, this statement is always true.  Formally: </p><br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b6/e36/274/5b6e3627460c58df26e63998a9f572e6.svg" alt="\ forall x: p (x) \ equiv \ lnot \ exists x: \ lnot p (x)">  - there is no x such that p (x) is incorrect. </p><br><br><p>  In the task, we see an explicit ‚Äúfor all‚Äù quantifier and we can emulate it using double negative, that is, we rephrase the query as follows: <em>output the names of all employees for whom there is no project on which they would not work</em> </p><br><img src="https://habrastorage.org/files/183/2ac/59d/1832ac59db03420d91ca1358e3d9d276.png"><br><p>  This same query looks incredibly simple if we had <img src="https://habrastorage.org/getpro/habr/post_images/3f8/119/749/3f81197494f6d9ac087457235fbef2a2.svg" alt="\ forall">  (and it is in relational calculus): </p><br><br><p>  {e.fname, e.lname |  EMP (e) and <img src="https://habrastorage.org/getpro/habr/post_images/525/4f8/462/5254f8462183182bfda48f5b5da07f4a.svg" alt="\ forall p:">  PRJ (p) <img src="https://habrastorage.org/getpro/habr/post_images/348/b51/281/348b512813b34cc871b63f35d9e04f0a.svg" alt="\ implies \ exists w:">  WORKS_ON (w) and w.Pno = p.Pnumber and e.Ssn = w.Essn} </p><br><br><a name="query_optimization"></a><h1>  An example of using RA to optimize queries </h1><br><p>  Transforming SQL into relational algebra also optimizes query execution.  Consider a simple example: </p><br><br><p>  <strong>Task</strong> <br>  <em>Print all the numbers of projects in which the employee with the surname Schmidt worked as the manager of the department managing this project.</em> </p><br><div class="spoiler">  <b class="spoiler_title">original wording</b> <div class="spoiler_text">  <em>This is a list of</em> </div></div><br><br><p>  A simple solution is as follows: <br><img src="https://habrastorage.org/files/469/eb6/f1a/469eb6f1a586490599b7397a8e895e72.png"></p><br><br><p>  Which can be rewritten into relational algebra as follows: </p><br><img src="https://habrastorage.org/files/e4d/351/0a7/e4d3510a7da547468456df516b006e65.png"><br><p>  The first optimization is to use select as early as possible, then the Cartesian product will receive smaller relations as input: <br><img src="https://habrastorage.org/files/0aa/a44/f6f/0aaa44f6f28c4ec69eedabd3b1fa1e87.png"></p><br><br><p>  Select c equality constant strong constraint, so it must be calculated and connected as soon as possible: <br><img src="https://habrastorage.org/files/0cc/f9e/a9e/0ccf9ea9e8424d0d9aa38b0cb5c28694.png"></p><br><br><p>  We collapse the Cartesian product and select into a join (which is implemented effectively with indices and specialized data structures) <br><img src="https://habrastorage.org/files/07f/e76/a04/07fe76a0456d4972856e2dafc385e62b.png"></p><br><br><p>  Drop the project as low as possible so that only the necessary information is passed up the tree. <br><img src="https://habrastorage.org/files/d94/2fb/efc/d942fbefcbe740c1943027a9fe172f2f.png"></p><br><br><div class="spoiler">  <b class="spoiler_title">Minute self-promotion</b> <div class="spoiler_text">  There are interesting tasks on data science, big data, machine learning, data mining - <a href="http://www.sergey-paramonov.com/cv.pdf">write</a> . </div></div><br><br><a name="literature"></a><h1>  Literature, materials and slides </h1><br><p>  <a href="https://lagunita.stanford.edu/courses/Home/Databases/Engineering/about">Stanford online course - Jennifer Widom</a> - excellent course, I recommend </p><br><br><p>  <a href="http://webdam.inria.fr/Alice/">Alice's book - Serge Abiteboul</a> - classics of the genre </p><br><br><p>  <a href="http://rutracker.org/forum/viewtopic.php%3Ft%3D3296600">Martin Graber - SQL</a> - fairly simple and detailed explanations of the work of algorithms and SQL syntax </p><br><br><p>  Habra articles about P-NP - introductory material part <a href="http://habrahabr.ru/post/207112/">one</a> and <a href="http://habrahabr.ru/post/208774/">two</a> </p><br><br><p>  <a href="https://github.com/SergeyParamonov/HabraData/tree/master/Slides%2520queries">My slides on the topic</a> (extremely useful because of the examples of problem solutions in different formalisms - in some places a mixture of Dutch and English) </p><br><br><p>  <a href="http://www.inf.unibz.it/~nutt/Teaching/FDBs1516/">Good slides on the theory</a> (non-trivial theoretical material) </p></div><p>Source: <a href="https://habr.com/ru/post/275251/">https://habr.com/ru/post/275251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275235/index.html">Add multiplayer to the game using Node.JS and Frida. Part 1</a></li>
<li><a href="../275239/index.html">System plug-ins and modules in Unreal Engine 4</a></li>
<li><a href="../275245/index.html">The best gift book for well-read fans of JavaScript</a></li>
<li><a href="../275247/index.html">Almost perfect computer security may be closer than you think.</a></li>
<li><a href="../275249/index.html">The problem of duplication and obsolescence of knowledge in mock objects or Integration tests is good</a></li>
<li><a href="../275255/index.html">We write MVP application on Kotlin for Android</a></li>
<li><a href="../275259/index.html">Bareos: tapes, Hyper-V and more</a></li>
<li><a href="../275265/index.html">The digest of interesting materials for the mobile # 136 developer (on January 11-17)</a></li>
<li><a href="../275267/index.html">Personal account for dealers in 5 minutes</a></li>
<li><a href="../275269/index.html">Parallel Sequential Scan Commited</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>