<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimize SQL insertion speed on Android devices</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. 

 During the development of my project for Android, I encountered the task of updating a large number of rows in an SQLite database directl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimize SQL insertion speed on Android devices</h1><div class="post__text post__text-html js-mediator-article">  Good day. <br><br>  During the development of my project for Android, I encountered the task of updating a large number of rows in an SQLite database directly on the device. <br><br>  The initial solution in the forehead gave terribly slow results, because  update had more than 40,000 lines.  About how I improved the performance of these updates rows in the database, and the story goes. <br><a name="habracut"></a><br><h5>  More detailed description of the task: </h5><br>  The application for Android was distributed with a SQLite base inside (inside the APK, in assets).  The database was information on the cities.  But the information is basic, language-independent, and language-dependent fields were only in English. <br>  To distribute the program with all languages ‚Äã‚Äãwould be unrealistic, since  each language in the database would add the original APK file to the installer from 1-2 MB.  And languages ‚Äã‚Äãsupported 11. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, language patches were invented to the database, which would be downloaded from the Internet (from the server), and rolled onto the base on the device. <br>  The patch was a text file clamped by gzip, each line of which contained values ‚Äã‚Äãseparated by a tab (\ t). <br><br>  There were no problems with downloading.  It is fast.  But the bottleneck of this scheme is the insertion into the base on the device. <br>  I wrote the first version in Java using the well-known SQLite capabilities for working with SQLite. <br>  It was necessary to update 3 fields in the line (add values ‚Äã‚Äãfrom the patch).  Here are just such lines were from 20,000 to 60,000, depending on the language. <br><br><h5>  The first version of Java code </h5><br>  The first version looked something like this (I don‚Äôt pretend to the accuracy of the code, there is nothing left from the first versions, since they were all rewritten and were not saved anywhere. I cite the code to display ideas and bottlenecks so that people do not repeat the mistakes I made ). <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { buffRead = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(fileIn, (<span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 1000 KB String line; int lineNum = 0; while ((line = buffRead.readLine()) != null) { try { String[] values = line.split("\t"); if (values.length &lt; 2) // cause 3rd value van be empty { // some error, try next line continue; } int idInt = Integer.valueOf(values[0]); String name = values[1]; getDb().execSql("update " + getTableNabe() + " set " + lang.getColumnName() + " = ? where " + COLUMN_ID + " = ? ", new String[] { name, String.valueOf(idInt) }); getDb().execSql("update " + getTableNabe() + " set " + lang.getColumnSort() + " = ? where " + COLUMN_ID + " = ? ", new String[] { String.valueOf(lineNum++), String.valueOf(idInt) }); if (values.lengh == 3 &amp;&amp; values[2].length != 0) { String data = values[2]; getDb().execSql("update "+ getTableNabe() + " set " + lang.getColumnData() + " = ? where " + COLUMN_ID + " = ? ", new String[] { data, String.valueOf(idInt) }); } } catch (NumberFormatException e) { e.printStackTrace(); return false; } catch (SQLException e) { e.printStackTrace(); return false; } createIndexOnLang(lang); }// end of while } catch (IOException e) { e.printStackTrace(); return false; } finally { if (buffRead != null) { try { buffRead.close(); } catch (IOException e) { e.printStackTrace(); } } } return true;</span></span></code> </pre> <br><br>  Well, naturally, such a solution worked super slowly.  More precisely, to say that slowly is to say nothing.  The code added lines to the database in tens of minutes. <br>  The first thing that asked for was to add a transaction. <br><br>  Added before cycle <br><pre> <code class="java hljs"> getDb().beginTransaction();</code> </pre><br>  After cycle added <br><pre> <code class="java hljs"> getDb().setTransactionSuccessful();</code> </pre><br>  And in block finaly <br><pre> <code class="java hljs"> getDb().endTransaction();</code> </pre><br><br>  This gain is not great.  Then I remembered that in Eclipse, after installing Android Developer Tools ( <a href="http://developer.android.com/tools/sdk/eclipse-adt.html">ADT</a> ) there, there is a great prospect of <a href="http://developer.android.com/tools/debugging/ddms.html">DDMS</a> , in which there is an excellent function of function profiling. <br><br>  How to use it, you can read <a href="http://developer.android.com/tools/debugging/debugging-tracing.html">here</a> .  On the habr, by the way, did not find the articles describing this ADT functional (I could not search well, but I found only about <a href="http://habrahabr.ru/post/116163/">memory analysis</a> .) <br><br><h5>  Drawdown performance </h5><br>  With the help of this profiling mechanism, it became immediately apparent that the drawdown in performance was in my following places. <br>  1. Spit terribly slow method.  It may not be a revelation to anyone, but I was surprised. <br>  2. Work with strings, in terms of pasting strings for queries.  Inside execSql, as you can see, a bunch of new StringBuilders were made in the loop each time, which were then discarded as unnecessary.  As written <a href="http://habrahabr.ru/post/132241/">here</a> , never in cycles, do not glue the lines by means of a plus (+).  Use one prearranged StringBuilder.  And even better, in general, prepare the lines in advance, before the cycle.  What, in my case, is the most obvious improvement. <br>  3. The work of the SQL itself within the android libraries.  A lot of locks and unlocks were made there.  <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html">After reading the</a> documentation, I found a method for the <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html">setLockingEnabled</a> database, setting it to false, we get a good speed increase. <br>  4. Prepare a SQLiteStatement for each execSql call.  This is also an expensive operation.  A little nagging, I found that it was possible to prepare in advance, as well as the lines, in advance, and in the loop just by loading parameters into them, and then right there. <br><br><h5>  Second version of java code </h5><br>  Having solved all these problems, getting rid of split, removing SQLiteStatement training from a cycle, removing all work with strings from a cycle, adding getDb (). SetLockingEnabled (false) before a cycle, I got this option <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { buffRead = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(fileIn, (<span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 1000 KB String line; int lineNum = 0; checkDbErrors(); getDb().beginTransaction(); getDb().setLockingEnabled(false); // Prepare SQL queries String updateStatment = "update " + getTableName() + " set "; String whereStatment = " where " + COLUMN_ID + " = ?"; String updateNameSQL = updateStatment + lang.getColumns().getColumnName() + " = ? " + whereStatment; String updatqDataSQL = updateStatment + lang.getColumns().getColumnData() + " = ? " + whereStatment; String updatqSortSQL = updateStatment + lang.getColumns().getColumnSort() + " = ? " + whereStatment; SQLiteStatement updateName = getDb().compileStatement(updateNameSQL); SQLiteStatement updateData = getDb().compileStatement(updatqDataSQL); SQLiteStatement updateSort = getDb().compileStatement(updatqSortSQL); while ((line = buffRead.readLine()) != null) { try { int idInt = parseIdFromString(line); String name = parseNameFromString(line, line.indexOf('\t') + 1); String data= parseDataFromString(line, name.length() + 1); updateName.bindString(1, name); updateName.bindLong(2, idInt); updateName.execute(); if (data.length() != 0) { updateWiki.bindString(1, data); updateWiki.bindLong(2, idInt); updateWiki.execute(); } updateSort.bindLong(1, lineNum++); updateSort.bindLong(2, idInt); updateSort.execute(); } catch (NumberFormatException e) { e.printStackTrace(); return false; } catch (SQLException e) { e.printStackTrace(); return false; } } getDb().setTransactionSuccessful(); } catch (IOException e) { e.printStackTrace(); return false; } finally { getDb().endTransaction(); if (buffRead != null) { try { buffRead.close(); } catch (IOException e) { e.printStackTrace(); } } } return true;</span></span></code> </pre><br><br>  Methods <br>  parseIdFromString (String line), <br>  parseNameFromString (String line, int from) and <br>  parseDataFromString (String line, int from) is extremely clumsy, but works faster than the split version <br><br>  Here they are, who are interested: <br><div class="spoiler">  <b class="spoiler_title">Helper code</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseIdFromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String line)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ind = line.indexOf(<span class="hljs-string"><span class="hljs-string">'\t'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ind == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } String idStr = line.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, ind); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = idStr.length(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zero = <span class="hljs-string"><span class="hljs-string">'0'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; ++i) { result += (idStr.charAt(i) - zero) * Math.pow(<span class="hljs-number"><span class="hljs-number">10</span></span>, length - i - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseNameFromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String line, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ind = line.indexOf(<span class="hljs-string"><span class="hljs-string">'\t'</span></span>, from); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ind == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> line.substring(from, ind); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseDataFromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String line, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> from)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ind = line.indexOf(<span class="hljs-string"><span class="hljs-string">'\t'</span></span>, from); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ind == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> line.substring(from, ind); }</code> </pre><br><br>  As you can see in parseNameFromString there is even a frontal translation of the String to an int, but this clumsy version works faster than Integer.valueOf (verified through the profiler) <br></div></div><br><br>  As a result, this update option in the database worked ten times faster than the initial one.  Those.  43,000 lines update this algorithm did in about 1.5-2 minutes on <a href="http://en.wikipedia.org/wiki/HTC_Desire">HTC Desire</a> <br><br>  But, this result could not satisfy me.  It‚Äôs not very cool for a program user to wait 2 minutes while we insert the necessary language into the database. <br><br>  With Java, one could still poshamanit, but the speed could not be increased by orders of magnitude, because the results of the profiler run on the latest version of the code clearly showed that now the longest is done inside the native_execute () method from the source file Android SDK \ sources \ android- 14 \ android \ database \ sqlite \ SQLiteStatement.java.  This is a native c ++ method. <br>  But along with it, we lost a lot of time in some kind of magical method logTimeStat, the need for which I did not understand, and how to disable it, too.  In addition, bindings in the workflow also did not work very fast, and indeed, this is Java ... what kind of performance it can be (sarcasm, I don‚Äôt have anything bad to Java) <br><br><h5>  We write everything in C ++ </h5><br>  In the end, I decided not to bother with Java anymore and write my insert in C ++ (as they say with blackjack and ...).  To collect by means of <a href="http://en.wikipedia.org/wiki/Android_NDK">NDK</a> and to call it from Java through <a href="http://en.wikipedia.org/wiki/JNI">JNI</a> . <br><br>  There is one problem with this idea: where can I get sqlite for NDK?  Well, actually - elementary.  Take the source file sqlite c <a href="http://www.sqlite.org/download.html">of.</a>  <a href="http://www.sqlite.org/download.html">site</a> and just add it entirely to your libina under the NDK. <br><br>  I will not write how to collect code under NDK, because there is a lot of <a href="http://habrahabr.ru/search/%3Fq%3Dandroid%2Bndk">information</a> on Habr√©, and not only on it <a href="http://habrahabr.ru/search/%3Fq%3Dandroid%2Bndk">.</a> <br><br>  A small remark about the inclusion of SQLite sources in your library.  While googling this topic, I found the official Google group of android developers (unfortunately the links were not preserved), on which they discussed options for working with the database through their native libs, in which some of their own SQLite versions were included (the versions are different).  So there the official people from Android were not very approving of this practice, they said that in theory this could spoil the database, because on the device itself there could be some other version of SQLite, and that working from its own, and then from Java already standard means, with the same base, you can break it.  But in my practice, the breaking of the base happened only when the program was forcibly terminated, at the time when my lib was updating the contents of the base.  This case is rare, because it does not make the program for long.  But for me this is not a critical case, because  the base always lies in my asset and I can restore it at any fault, and ask the user to download the languages ‚Äã‚Äãagain and roll them again. <br>  So, in the case when you need to work with SQLite databases from native code, people from Android advise you to work only from it, without touching these Java bases with Android tools.  In this case, everything is guaranteed to be well with the databases, since you will work with them only with the version of SQLite that you have. <br><br>  Let's go back to the story. <br>  I decided to write my update.  SQLite dragged.  The C ++ code itself repeats all the ideas that have already been improved in Java code. <br>  Also, this <a href="http://stackoverflow.com/questions/1711631/how-do-i-improve-the-performance-of-sqlite">article</a> helped me a lot.  It describes in great detail how to increase the speed of insertion. <br><br>  Coda got a lot, who are interested, can see <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">std::vector&lt;std::string&gt;&amp; split(const std::string &amp;s, <span class="hljs-type"><span class="hljs-type">char</span></span> delim, std::vector&lt;std::string&gt; &amp;elems) { elems.clear(); std::stringstream ss(s); std::string item; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (std::getline(ss, item, delim)) { elems.push_back(item); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elems; } std::string prepareUpdateStatment(std::string columnName, std::string columnValue, std::string id) { std::ostringstream constructor; constructor &lt;&lt; "update cities set " &lt;&lt; columnName &lt;&lt; " = \"" &lt;&lt; columnValue &lt;&lt; "\" where _id = " &lt;&lt; id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> constructor.str(); } std::string prepareUpdateStatmentForBind(std::string columnName) { std::ostringstream constructor; constructor &lt;&lt; "update cities set " &lt;&lt; columnName &lt;&lt; " = ? where _id = ? "; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> constructor.str(); } std::string getColumnName(std::string <span class="hljs-keyword"><span class="hljs-keyword">column</span></span>, std::string lang) { std::ostringstream constructor; constructor &lt;&lt; lang &lt;&lt; "_" &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">column</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> constructor.str(); } std::string parseInt(<span class="hljs-type"><span class="hljs-type">int</span></span> i) { std::ostringstream ss; ss &lt;&lt; i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ss.str(); } <span class="hljs-type"><span class="hljs-type">bool</span></span> pushToDBWithPreparedStatments(std::string <span class="hljs-type"><span class="hljs-type">line</span></span>, sqlite3* db, std::string lang, <span class="hljs-type"><span class="hljs-type">int</span></span> lineNum, sqlite3_stmt* stmtnUpdateName, sqlite3_stmt* stmtnUpdateSort, sqlite3_stmt* stmtnUpdateData) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">line</span></span>.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> file } <span class="hljs-type"><span class="hljs-type">int</span></span> error = SQLITE_OK; std::vector&lt;std::string&gt; elems; elems = split(<span class="hljs-type"><span class="hljs-type">line</span></span>, <span class="hljs-string"><span class="hljs-string">'\t'</span></span>, elems); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elems.size() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { log("line parse error"); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } std::string&amp; idStr = elems[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-type"><span class="hljs-type">int</span></span> idInt = atoi(idStr.c_str()); std::string&amp; nameStr = elems[<span class="hljs-number"><span class="hljs-number">1</span></span>]; sqlite3_bind_text(stmtnUpdateName, <span class="hljs-number"><span class="hljs-number">1</span></span> , nameStr.c_str(), <span class="hljs-number"><span class="hljs-number">-1</span></span>, SQLITE_STATIC); sqlite3_bind_int(stmtnUpdateName, <span class="hljs-number"><span class="hljs-number">2</span></span> , idInt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((error = sqlite3_step(stmtnUpdateName)) != SQLITE_DONE) { logError(error, sqlite3_errmsg(db)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } sqlite3_clear_bindings(stmtnUpdateName); sqlite3_reset(stmtnUpdateName); sqlite3_bind_int(stmtnUpdateSort, <span class="hljs-number"><span class="hljs-number">1</span></span> , lineNum); sqlite3_bind_int(stmtnUpdateSort, <span class="hljs-number"><span class="hljs-number">2</span></span> , idInt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((error = sqlite3_step(stmtnUpdateSort)) != SQLITE_DONE) { logError(error, sqlite3_errmsg(db)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } sqlite3_clear_bindings(stmtnUpdateSort); sqlite3_reset(stmtnUpdateSort); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elems.size() == <span class="hljs-number"><span class="hljs-number">3</span></span>) { std::string&amp; DataStr = elems[<span class="hljs-number"><span class="hljs-number">2</span></span>]; sqlite3_bind_text(stmtnUpdateData, <span class="hljs-number"><span class="hljs-number">1</span></span> , DataStr.c_str(), <span class="hljs-number"><span class="hljs-number">-1</span></span>, SQLITE_STATIC); sqlite3_bind_int(stmtnUpdateData, <span class="hljs-number"><span class="hljs-number">2</span></span> , idInt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((error = sqlite3_step(stmtnUpdateData)) != SQLITE_DONE) { logError(error, sqlite3_errmsg(db)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } sqlite3_clear_bindings(stmtnUpdateData); sqlite3_reset(stmtnUpdateData); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> parseAndUpdateDB(std::string databasePath, std::string patchPath, std::string lang) { time_t beforeStartTime = <span class="hljs-type"><span class="hljs-type">time</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); sqlite3* db; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sqlite3_open_v2(databasePath.c_str(), &amp;db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_NOMUTEX | SQLITE_OPEN_PRIVATECACHE, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>) != SQLITE_OK) { logError("Error wile opening db", sqlite3_errmsg(db)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } std::string <span class="hljs-type"><span class="hljs-type">line</span></span>; std::ifstream myfile(patchPath.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!myfile.is_open()) { log("Error wile opening patch file"); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-type"><span class="hljs-type">int</span></span> lineNum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> error = SQLITE_OK; // <span class="hljs-keyword"><span class="hljs-keyword">Begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (error = sqlite3_exec(db, "begin", <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>)) != SQLITE_OK) { logError(error, sqlite3_errmsg(db)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } sqlite3_stmt* stmtnUpdateName; std::string updateName = prepareUpdateStatmentForBind(getColumnName("name", lang)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (error = sqlite3_prepare(db, updateName.c_str(), updateName.length(), &amp;stmtnUpdateName, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>)) != SQLITE_OK) { logError(error, sqlite3_errmsg(db)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } sqlite3_stmt * stmtnUpdateSort; std::string updateSort = prepareUpdateStatmentForBind(getColumnName("sort", lang)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (error = sqlite3_prepare(db, updateSort.c_str(), updateSort.length(), &amp;stmtnUpdateSort, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>)) != SQLITE_OK) { logError(error, sqlite3_errmsg(db)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } sqlite3_stmt * stmtnUpdateData; std::string updateData = prepareUpdateStatmentForBind(getColumnName("data", lang)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (error = sqlite3_prepare(db, updateData.c_str(), updateData.length(), &amp;stmtnUpdateData, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>)) != SQLITE_OK) { logError(error, sqlite3_errmsg(db)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } // <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> fast <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> sqlite3_exec(db, "PRAGMA synchronous = OFF", <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); sqlite3_exec(db, "PRAGMA journal_mode = MEMORY", <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( myfile.good() ) { std::getline(myfile, <span class="hljs-type"><span class="hljs-type">line</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pushToDBWithPreparedStatments(<span class="hljs-type"><span class="hljs-type">line</span></span>, db, lang, lineNum++, stmtnUpdateName, stmtnUpdateSort, stmtnUpdateData)) { break; } } sqlite3_finalize(stmtnUpdateName); sqlite3_finalize(stmtnUpdateSort); sqlite3_finalize(stmtnUpdateData); // <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (error = sqlite3_exec(db, "end", <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>)) != SQLITE_OK) { logError(error, sqlite3_errmsg(db)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } sqlite3_close(db); myfile.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(); time_t afterFinishTime = <span class="hljs-type"><span class="hljs-type">time</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-type"><span class="hljs-type">int</span></span> result = afterFinishTime- beforeStartTime; log("result of run is %d secs" , result); }</code> </pre><br></div></div><br><br>  By the way, I wrote and debugged this code under Windows in Visual Studio, and then, I collected it under NDK, and it all worked in a magical way under Android. <br>  The version of the code is not final, so you should not find fault with some not the best solutions.  The essence of the code is to show how to do the same in Java as in C ++, but only in C ++ it will work many times faster. <br><br><h5>  So about the speed. </h5><br>  The same insertion of 43,000 lines, on the same HTC Desire under debugging (with Eclipse connected), worked about 43 seconds.  Those.  where is one line in 1 ms.  If you cut off Eclipse and debug, you get a truly quick result in the region of 20-25 seconds.  On more powerful devices like the HTC One S, the insertion process generally took about 10-15 seconds.  What, in comparison with the original minutes, shows that all efforts to improve performance were not made in vain. <br><br><h5>  Morality </h5><br>  Using the example of my task, I showed how to speed up work with SQLite when developing for Android (up to the transition to the native level).  I do not argue that there are plenty of options to do the same thing, but I think this information will help someone to make their applications even more responsive and quick. <br><br>  <b>UPD:</b> <br>  Thanks <a href="http://habrahabr.ru/users/to_climb/" class="user_link">to_climb</a> , mentioned another obvious improvement.  To stick together 3 requests for updates in 1N request. <br>  Those.  not 3, but one long look <br>  update table set var1 =?, var2 =?  where _id =? </div><p>Source: <a href="https://habr.com/ru/post/190876/">https://habr.com/ru/post/190876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190866/index.html">Determination of the percentage of similarity drawn 2d-polygon with a given pattern</a></li>
<li><a href="../190868/index.html">PhpBB integration in the Yii framework</a></li>
<li><a href="../190870/index.html">Script for checking the availability of free dates at the embassy</a></li>
<li><a href="../190872/index.html">Pseudolemmatization, composites and other strange words</a></li>
<li><a href="../190874/index.html">As I continued to make my amusement park</a></li>
<li><a href="../190880/index.html">Import KeePass Password Database into KWallet</a></li>
<li><a href="../190882/index.html">Caution, radiation!</a></li>
<li><a href="../190884/index.html">The first site is blocked by the "anti-piracy" law UPD + a full list of sites to block</a></li>
<li><a href="../190888/index.html">PVS-Studio finally got to Boost</a></li>
<li><a href="../190892/index.html">Scientists have created a graphene transistor with a frequency of 427 GHz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>