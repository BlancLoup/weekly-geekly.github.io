<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Full automation of the ‚Äúdevelopment‚Äù environment using docker-compose</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will share the experience of automating the launch, testing and configuration of large projects using docker-compose. A few simple ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Full automation of the ‚Äúdevelopment‚Äù environment using docker-compose</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article we will share the experience of automating the launch, testing and configuration of large projects using docker-compose.  A few simple changes can help your team be more efficient and spend time on important, rather than routine tasks. </p><br><h4 id="docker-v-2017">  Docker in 2017 </h4><br><p>  At the <a href="http://2016.dockercon.com/">Dockercon 2016</a> conference, <a href="http://2016.dockercon.com/">Docker's</a> CEO said that the number of applications that are launched in Docker has grown by 3100% over the past two years.  More than 460,000 applications worldwide are launched in Docker.  This is incredible! </p><br><p>  If you are still not using Docker, I would advise you to read a <a href="https://www.datadoghq.com/docker-adoption/">great article</a> about using Docker around the world.  Docker completely changed the way we write applications and became an integral part for developers and DevOps teams.  In this article, we assume that you are already familiar with Docker and want to give you one more good reason to continue using it. <a name="habracut"></a></p><br><h4 id="chto-ne-tak">  What's wrong? </h4><br><p>  From the beginning of my career, when I was developing web applications, launching an application in a work environment has always been a challenge.  We had to do a lot of extra work from installing the database to configuring the application in order to simply run it.  Developers <del>  love </del>  do not like to write documentation, and the steps to start a project are usually hidden in the heads of team members.  As a result, the launch of the project becomes a painful task, especially for new guys. </p><br><p>  Many projects are simple at the beginning, but become larger with time.  This leads to an increase in external dependencies, such as databases, queues.  Due to the growing popularity of microservices, many projects cease to be monolithic and are divided into several small parts.  Any such change requires the attention of the whole team, since after such changes, the project needs to be launched differently.  Usually, developers involved in root changes write a letter, or they create a wiki page with a description of the steps that need to be taken in order for the project to start again on the working environments.  It usually works, but not always :) Once our team got into a situation where a developer from another continent made many changes to the project, wrote a long letter and went to bed.  I suppose you know what happened next.  That's right, he forgot to mention a few important points.  As a result, the next day, part of the team simply could not start the project and the day was lost. </p><br><p>  As an engineer, I like to automate everything around.  I believe that startup, testing and deployment should <strong>always</strong> be one-step.  In this case, the team will be able to focus on the important tasks: the development and improvement of the product.  It was harder to do 10 years ago, but now it has become much easier to automate and, as it seems to me, every team should devote time to it.  The earlier the better. </p><br><h4 id="bystryy-start-s-docker-compose">  Quick start with docker-compose </h4><br><p>  <a href="https://docs.docker.com/compose/">Docker-compose</a> is a simple tool that allows you to configure and launch multiple containers with one command.  Before we dive deeper into docker-compose, we need to dwell a bit on the structure of the project.  We use <a href="http://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext">"monorepo"</a> .  The code of each service (frontend, api, worker, etc) is in its directory and has a Dockerfile.  An example of the project structure can be found <a href="https://github.com/maqpie/docker-compose-starter">here</a> . </p><br><p> The entire configuration for docker-compose is described in the <code>docker-compose.yml</code> , which usually lies at the root of the project.  Let's start with the automation of a simple Node.JS application that works with a MongoDB database.  This is what the configuration file will look like: </p><br><pre> <code class="hljs vhdl">version: '<span class="hljs-number"><span class="hljs-number">2</span></span>' services: web: build: <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: ./web dockerfile: Dockerfile.dev volumes: - <span class="hljs-string"><span class="hljs-string">"./web/src:/web/src"</span></span> ports: - <span class="hljs-string"><span class="hljs-string">"8080:8080"</span></span> mongo: command: mongod image: mongo:<span class="hljs-number"><span class="hljs-number">3.2</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> ports: - <span class="hljs-string"><span class="hljs-string">"27100:27017"</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> <span class="hljs-keyword"><span class="hljs-keyword">port</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> none standard <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> avoid conflicts <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> locally installed mongodb. volumes: - /var/run/docker.sock:/var/run/docker.sock</code> </pre> <br><p>  To run the project, we need one command: </p><br><pre> <code class="hljs ruby">$ docker-compose up</code> </pre> <br><p>  At the first start, all containers will be built or downloaded.  If you worked with Docker, the configuration file for docker-compose should be more or less clear, but you should pay attention to a few details: </p><br><ol><li>  <code>context: ./web</code> - this indicates the path to the docker of the service inside our repository. </li><li>  <code>dockerfile: Dockerfile.dev</code> - we use a separate Dockerfile.dev for working environments.  For the "production" environments, we copy the code into the Docker image, and on the work environments we add the code as "volume".  When using "volume", you do not have to restart docker-compose every time after changes in the code. </li><li>  <code>volumes: - "./web/src:/web/src"</code> - this is how the code is added as "volume" to the Docker. </li><li>  Docker-compose automatically binds containers.  Thanks to this, it is possible to contact the service by name.  For example, from the <code>web</code> service you can connect to the MongoDB database: <code>mongodb://mongo:27017</code> </li></ol><br><h4 id="vsegda-ispolzuyte---build">  Always use <code>--build</code> </h4><br><p>  By default, <code>docker-compose up</code> will not rebuild containers if they are already on the host.  To get the docker to do this, you need to use the <code>--build</code> argument.  This is usually needed when third-party dependencies of a project change or the pre-file changes.  We always use <code>docker-compose up --build</code> in our team.  Docker can cache layers and will not rebuild the container if nothing has changed.  When using - <code>--build</code> everywhere, you may lose a few seconds when you start the application.  But at the same time, you will never encounter the magical problems of launching a new version of the application with old dependencies. </p><br><p>  <em>Tip:</em> You can wrap the startup command in a simple bash script: </p><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#!/bin/sh docker-compose up --build </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$@"</span></span></span></span></code> </pre> <br><p>  This will give you the opportunity to change the arguments or approach to run the application as a whole.  For a team, it will always be just like: <code>./bin/start.sh</code> . </p><br><h4 id="chastichnyy-zapusk">  Partial start </h4><br><p>  In this <a href="">example, docker-compose.yml</a> some services depend on each other: </p><br><pre> <code class="hljs vhdl"> api: build: <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: ./api dockerfile: Dockerfile.dev volumes: - <span class="hljs-string"><span class="hljs-string">"./api/src:/app/src"</span></span> ports: - <span class="hljs-string"><span class="hljs-string">"8081:8081"</span></span> depends_on: - mongo</code> </pre> <br><p>  In this case, the <code>api</code> service needs a database to work with.  When running docker-compose, you can pass the name of the service in order to start only it and all its dependencies: <code>docker-compose up api</code> .  This command will start MongoDB and only after that will it start <code>api</code> . </p><br><p>  In large projects there are always parts that are needed only from time to time.  Different team members can work on different parts of the application.  The frontend developer who works on the landing site, there is no need to launch the project entirely.  He can just run the parts he really needs. </p><br><h4 id="devnull-nazoylivye-logi">  &gt; / dev / null annoying logs </h4><br><p>  Often we use tools that generate a lot of logs, thereby distracting us from the useful logs of our application.  To disable logs for a particular service, you just need to set the logging driver to none. </p><br><pre> <code class="hljs swift"> mongo: command: mongod image: mongo:<span class="hljs-number"><span class="hljs-number">3.2</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> ports: - <span class="hljs-string"><span class="hljs-string">"27100:27017"</span></span> volumes: - /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock logging: driver: <span class="hljs-keyword"><span class="hljs-keyword">none</span></span></code> </pre> <br><h4 id="neskolko-faylov-docker-compose">  Multiple docker-compose files </h4><br><p>  By default, when you run <code>docker-compose up</code> , docker-compose looks for the <code>docker-compose.yml</code> configuration file in the current directory.  In some cases (let's talk about this in a minute), you will have to create several such configuration files.  To do this, you just need to use the argument - <code>--file</code> : </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-compose</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--file</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-compose</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.local-tests</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.yml</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">up</span></span></code> </pre> <br><p>  So why you may need several configuration files?  The first use case is to split a large project into several smaller ones.  Interestingly, even if you run several separate docker-compose, services will still be able to communicate with each other by the name of docker-compose.  For example, you can split infrastructure containers (databases, queues, etc.) and application containers into separate docker-compose files. </p><br><h4 id="zapusk-testov">  Running tests </h4><br><p>  Our tests include various types: unit, integration, UI testing, code syntax checking.  Each service has its own set of tests.  Integration and UI tests require <code>api</code> and <code>web frontend</code> for their work. </p><br><p>  At the very beginning, it seemed to us that we should run tests every time we start docker-compose.  But very soon we realized that this is not always convenient and takes too much time.  In some cases, we also wanted to have a little more control over which tests to run.  For this, we use a separate docker-compose configuration file: </p><br><pre> <code class="hljs bash">version: <span class="hljs-string"><span class="hljs-string">'2'</span></span> services: api-tests: image: app_api <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: npm run <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> volumes: - <span class="hljs-string"><span class="hljs-string">"./api/src:/app/src"</span></span> web-tests: image: app_web <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: npm run <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> volumes: - <span class="hljs-string"><span class="hljs-string">"./web/src:/app/src"</span></span></code> </pre> <br><p>  To run the tests, you need to run the main <a href="https://github.com/maqpie/docker-compose-starter">docker-compose</a> .  Integration tests use the working version of the <code>api</code> service, and UI tests use the <code>web frontend</code> service.  In essence, tests simply use images that are mostly compiled in docker-compose.  It is also possible to run tests only for a specific service, for example: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-compose</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--file</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-compose</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.local-tests</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.yml</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">up</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">api-tests</span></span></code> </pre> <br><p>  This command will only run tests for the <code>api</code> service. </p><br><h4 id="prefiks-dlya-konteynerov">  Container Prefix </h4><br><p>  By default, all containers that are launched using docker-compose use the name of the current directory as a prefix.  The name of this directory may differ in the working environments of different developers.  This prefix ( <code>app_</code> ) is used when we want to refer to the container from the main docker-compose file.  To fix this prefix, you need to create a <code>.env</code> file <code>.env</code> <del>  next to docker-compose configuration files </del>  in the directory from which docker-compose is launched: </p><br><pre> <code class="hljs">COMPOSE_PROJECT_NAME=app</code> </pre> <br><p>  Thus, the prefix will be the same in all work environments. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Docker-compose is a very useful and flexible way to automate the launch of projects. </p><br><p>  When new developers are added to our team, we give them a small task, which they must complete by the end of the first working day.  Everyone who joined our team coped with this and was the happiest man on earth.  From the very first minutes, new developers can focus on important tasks and not waste time on launching a project.  Our documentation for the start of the project consists of three points: </p><br><ol><li>  Install <a href="https://docs.docker.com/engine/installation/">Docker</a> and <a href="https://docs.docker.com/compose/install/">Docker-compose</a> </li><li>  Clone repository </li><li>  Run in terminal <code>./bin/start.sh</code> </li></ol><br><p>  To make it easier for you to understand this article, we have <a href="https://github.com/maqpie/docker-compose-starter">an example of a project</a> on Github.  Share your experience and <a href="https://github.com/maqpie/docker-compose-starter/issues/new">ask questions</a> . </p><br><p>  We hope that the article was useful and will help make your project better :) </p><br><p>  English version, you can read <a href="https://blog.maqpie.com/2017/02/22/fully-automated-development-environment-with-docker-compose/">here</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322440/">https://habr.com/ru/post/322440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322428/index.html">Functional security, part 5 of 7. The life cycle of information and functional security</a></li>
<li><a href="../322430/index.html">BBR system: congestion control directly by congestion</a></li>
<li><a href="../322432/index.html">Welcome to Lua in Moscow 2017 March 5</a></li>
<li><a href="../322434/index.html">IOS Localization Guide</a></li>
<li><a href="../322438/index.html">Neural networks in pictures: from one neuron to deep architectures</a></li>
<li><a href="../322442/index.html">MIPSfpga and in-circuit debugging</a></li>
<li><a href="../322444/index.html">Tete-a-tete: ask the right questions</a></li>
<li><a href="../322446/index.html">Emoji.prototype.length - a story about emotional characters in Unicode</a></li>
<li><a href="../322448/index.html">About spaghetti, or how to explore the business processes of an organization</a></li>
<li><a href="../322450/index.html">Immunitable data in C ++. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>