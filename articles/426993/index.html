<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Do I need to learn C to understand how a computer works?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I often heard that in order to understand how a computer works, people suggest studying C. Is this a good idea? Are you sure? Immediately present the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Do I need to learn C to understand how a computer works?</h1><div class="post__text post__text-html js-mediator-article">  I often heard that in order to understand how a computer works, people suggest studying C. Is this a good idea?  Are you sure?  Immediately present the conclusions of the article, just for absolute clarity: <br><br><ul><li>  C is not "how a computer works." </li><li>  I do not think that most people speak literally, so it does not matter. </li><li>  Understanding the context means that learning C for this reason can still make sense, depending on your goals. </li></ul><br>  I plan to write two more articles with a more detailed explanation of the conclusions, but this is already enough.  I will add links here when articles come out. <br><a name="habracut"></a><br>  I often heard from people like this: <br><br><blockquote>  By studying C, you can understand how computers work. </blockquote><br>  I do not think that the idea is initially wrong, but it has some reservations.  If you keep them in mind, it may well be a viable strategy for learning new and important things.  However, I rarely see people discussing these reservations in detail, so I am writing this article to provide, in my opinion, a very necessary context ... If you are thinking about learning C to understand computer work, then the article is for you.  I hope it helps to figure it out. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  Before we really start, I would like to say one more thing: if you want to study C, then study!  Learning is great.  Studying C has become very important for my understanding of computing and my career.  Studying this language and its place in the history of a programming language will make you a better programmer.  You need no excuse.  Learn things just for the sake of learning.  This article is intended to be a guide to understand the truth, it does not discuss whether or not to study C. </blockquote><br>  First of all, to whom this idea is generally recommended.  If you are trying to ‚Äúlearn how computers work,‚Äù then it goes without saying that you currently do not understand this.  What programmers do not understand how computers work?  I basically saw this feeling come from people who mostly program in dynamically typed ‚Äúscripting‚Äù languages, such as Ruby, Python, or JavaScript.  They allegedly ‚Äúdo not know how computers work‚Äù, because these languages ‚Äã‚Äãwork inside a virtual machine, where only the semantics of the virtual machine is important.  In the end, the whole idea of ‚Äã‚Äãa virtual machine is to provide portability.  The goal is not to depend on the hardware on which the VM runs. <br><br>  There is only one problem: C <i>also</i> works inside the virtual machine. <br><br><h3>  Abstract machine C </h3><br>  From <a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf">the C99 specification</a> , section 5.1.2.3, ‚ÄúProgram execution‚Äù: <br><br><blockquote>  Semantic descriptions in this International Standard describe the behavior of an abstract machine, in which optimization questions have no meaning. </blockquote><br>  In my opinion, this is most important to understand when studying C. Language does not "describe how a computer works," but describes how "abstract machine C" works.  All the rest is important from this concept. <br><br><blockquote> Another note: here I chose C99, which is not the latest C standard. Why?  Well, <a href="https://stackoverflow.com/questions/146381/visual-studio-support-for-new-c-c-standards">MSVC has ... interesting support for the C language</a> , and today I am a Windows user.  Yes, you can run <code>clang</code> and <code>gcc</code> under Windows.  There is not much difference between C89, C99 and C11 in terms of what we are talking about.  At some point you have to choose.  The version I mentioned here includes some edits to the original specification. </blockquote><br>  Perhaps, in conversations about C, you heard another phrase: "C is a portable assembler."  If you think about this phrase, then you will understand that if this is true, then C cannot correspond to the operation of a computer: there are many different computers with different architecture.  If C is like an assembler that runs on different computers with different architectures, then it cannot simultaneously function exactly as each of these computers.  It <i>must</i> hide the details, otherwise it will not be portable! <br><br>  Nevertheless, I think that this fact does not matter, because it is unlikely that people literally mean "C is how a computer works."  Before returning to this, let's talk about the abstract machine C, and why many people do not seem to understand this aspect of C. <br><br><h3>  Retreat: why are people mistaken? </h3><br>  I can only talk about my experience, although for sure it is not unique. <br><br>  I learned GW-BASIC, then C, then C ++, then Java.  I heard about Java before I started writing about it in 1999, four years after it appeared.  Marketing was at that time actively opposing Java and C ++, it focused on the JVM as a platform, and on the fact that the machine model distinguishes it from C ++, and therefore C. Sun Microsystems no longer exists, but the <a href="https://tech-insider.org/java/research/1996/0123.html">mirror of the press release</a> reminds us: <br><br><blockquote>  Java applications are platform independent;  you just need to port a Java virtual machine to each platform.  It acts as an interpreter between the user's computer and the Java application.  An application written in the Java environment can run anywhere, eliminating the need to migrate applications to multiple platforms. </blockquote><br>  The main motto was "Write once, run everywhere."  These two sentences became how I (and many others) came to understand Java, and how it differs from C ++.  Java has an interpreter, a Java virtual machine.  In C ++, there is no virtual machine. <br><br>  With such powerful marketing, a ‚Äúvirtual machine‚Äù in the minds of many people has become synonymous with ‚Äúa large runtime environment and / or interpreter.‚Äù  Languages ‚Äã‚Äãwithout this feature were too tied to a specific computer and required porting, since they are not truly platform independent.  The main reason for the existence of Java was the modification of this C ++ flaw. <br><br><blockquote>  "Runtime", "virtual machine" and "abstract machine" are different words for the same fundamental concept.  But since then they have received different connotations due to the insignificant dispersion in the implementations of these ideas. </blockquote><br>  I personally believe that this 1995 marketing is the reason why programmers still misunderstand the nature of C. <br><br>  So this statement is false?  Why does Sun Microsystems spend millions and millions of dollars to promote lies?  If C is also based on an abstract machine that offers inter-platform portability, why use Java?  I think this is the key to understanding what people really mean when they say ‚ÄúC is how a computer works.‚Äù <br><br><h3>  What do people really mean? </h3><br>  Although C works in the context of a virtual machine, it still differs significantly from Java-like languages.  Sun did not lie.  To understand, you need to know the history of S. <br><br>  In 1969, a computer operating system in assembly language was written at Bell Labs.  In 1970, it was christened UNIX.  Over time, Bell Labs bought more and more new computers, including the PDP-11. <br><br>  When it came time to port Unix to the PDP-11, they decided to use a higher level language, which was quite a radical idea at the time.  Imagine that today I‚Äôll tell you: ‚ÄúI‚Äôm going to write an OS in Java‚Äù - you will probably laugh, although the <a href="https://en.wikipedia.org/wiki/JavaOS">idea is realizable</a> .  The situation (in my understanding, I did not live then) was about the same.  A language called B was considered, but it did not support some of the functions that the PDP-11 had, and so they created a successor, calling it "C", since this was the next letter in the alphabet. <br><br><blockquote>  The language "A" was not;  B succeeded BCPL (Basic Combined Programming Language). </blockquote><br>  In 1972, the first C compiler was written on the PDP-11 and simultaneously UNIX was rewritten to C. Initially, portability was not thought of, but C became famous, so the C compilers ported to other systems. <br><br>  In 1978, the first edition of the book "C programming language".  Affectionately called ‚ÄúK &amp; R‚Äù, by the names of its authors, the book was not at all like the specification, but it described the language in some detail, as a result of which others also tried to write compilers C. Later, this ‚Äúversion‚Äù will be called ‚ÄúK &amp; R C‚Äù. <br><br>  As UNIX and C spread, they both ported to many computers.  In the 70s and 80s, their hardware base grew steadily.  Just as C was created, because B did not support all the functions of the PDP-11, many compilers used language extensions.  Since there was only K &amp; R, and not a specification, it was considered acceptable as long as the extensions were close enough.  By 1983, the lack of any standardization was causing problems, so ANSI created a group to prepare the specification.  In 1989, the standard came out C89, which is sometimes called "ANSI C". <br><br>  Specification C attempted to unify these diverse implementations on different hardware.  Thus, the abstract machine C is a kind of minimally possible specification that would allow the same code to work the same on all platforms.  C implementations were compiled, not interpreted, so there was no interpreter, so there was no "VM" in the 1995 sense.  However, C programs are written on this abstract non-existent computer, and then the code is converted to an assembler specific to the specific computer on which the program is running.  You could not rely on some specific details to write portable code in C. This makes writing portable C very difficult, since you may have made a platform-specific assumption when writing the initial version of your code. <br><br>  This is best illustrated by example.  One of the main data types in C is <code>char</code> , from the word "character."  However, the abstract C machine does not determine how many bits should be in <code>char</code> .  Well, it does, but not by number;  it determines the size of the <code>CHAR_BIT</code> , which is a constant.  Section 5.2.4.2.1 of the specification: <br><br><blockquote>  The values ‚Äã‚Äãgiven below should be replaced by constant expressions that are suitable or used in preprocessing directives <code>#if</code> . ... Values ‚Äã‚Äãin specific implementations must be equal to or greater in magnitude (absolute value) of those given here with the same sign. <br><br> <code>CHAR_BIT: 8</code> </blockquote> <br>  In other words, you know that <code>char</code> is at least 8 bits, but there may be more implementations.  In order to correctly encode an ‚Äúabstract C machine‚Äù, you need to use <code>CHAR_BIT</code> instead of <code>8</code> as the size when processing <code>char</code> .  But this is not some kind of interpreter function, as we think of virtual machines;  this is a property of how the compiler translates the source code into machine code. <br><br><blockquote>  Yes, <a href="https://stackoverflow.com/questions/2098149/what-platforms-have-something-other-than-8-bit-char">there are systems</a> where <code>CHAR_BIT</code> not <code>8</code> . </blockquote><br>  Thus, this ‚Äúabstract machine‚Äù, although technically the same idea as the Java virtual machine, is rather a compilation construct for managing compilers when creating assembler code, rather than some kind of test in runtime or property.  The equivalent type in Java is <code>byte</code> , which is always 8 bits, and the JVM implementation is tasked with what to do on platforms with more bytes.  (Not sure if the JVM works on any of these platforms, but this is how it should work).  Abstract machine C is created as a minimal wrapper for various ‚Äúhardware‚Äù, and not as some kind of solid-tissue platform, written in software for your code. <br><br>  So, although Sun was not technically right, in practice they mean not so much what they literally say, and what they <i>mean</i> is true.  The same with the phrase "Learn C to understand how computers work." <br><br><h3>  Learn C to BETTER understand how computers work </h3><br>  What <i>do</i> people <i>really</i> mean?  In the context of ‚Äúshould a ruberist study C, in order to understand how computers work‚Äù is the advice to decline ‚Äúto the level of iron‚Äù.  That is, not only to understand how its program works inside the virtual machine, but also how the combination of the program and the VM work in the context of the machine itself. <br><br>  Studying C <i>will provide</i> you with more such details, because the abstract machine is much closer to the hardware, as well as the abstractions of the operating systems.  The C language is very different from high-level languages, so learning it can teach a lot. <br><br>  But it is important to remember that C is essentially an <i>abstraction of</i> hardware, and abstractions are imperfect.  Be careful with what C does or how it works with the machine itself.  If you go too deeply, then you will definitely encounter these differences, which can cause problems.  Most training resources for C, especially today, when equipment is becoming more homogeneous, will promote the idea that <i>this is how</i> a computer works.  Therefore, it may be difficult for a student to understand what is going on under the hood and what is the abstraction provided by C. <br><br>  In this discussion, we have not even raised other issues.  For example, that because of the enormous popularity of C, the hardware has become more homogeneous, because it tends to move towards the semantics of the abstract machine C. If your architecture is too different from the semantics of C, C programs can run much slower than others, and the speed of the hardware is often measured by tests in the C language. This article is rather long ... <br><br>  For this reason, I think that a more accurate version of this statement will be ‚ÄúBy studying C, you <i>will</i> learn <i>more</i> about how computers work.‚Äù  I really think that a rough acquaintance with C is useful to many programmers, even if they do not write C. Getting to know C will also give you an idea of ‚Äã‚Äãthe history of our industry. <br><br>  There are other ways to explore this topic;  C <i>is inherently</i> not intended for studying computer, but it is a good option. <br><br>  There is so much to learn in programming.  I wish you success on this path. </div><p>Source: <a href="https://habr.com/ru/post/426993/">https://habr.com/ru/post/426993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426981/index.html">10 tricks for advanced dashboarding in Splunk. Part 1</a></li>
<li><a href="../426983/index.html">New in SObjectizer 5.5.23: wish fulfillment or Pandora's box?</a></li>
<li><a href="../426985/index.html">kubebox and other console shells for Kubernetes</a></li>
<li><a href="../426987/index.html">Learn OpenGL. Lesson 6.3 - Image Based Lighting. Diffuse irradiation</a></li>
<li><a href="../426991/index.html">Startup Digest: 10 nearest IT events in Moscow</a></li>
<li><a href="../426995/index.html">Recycling harms both products and employees</a></li>
<li><a href="../426997/index.html">How to create custom shapes with MaterialShapeDrawable</a></li>
<li><a href="../426999/index.html">In the wake of trends, or moving towards RxJava and LiveData</a></li>
<li><a href="../427001/index.html">"Yandex" can go under the state administration</a></li>
<li><a href="../427003/index.html">Unity Hexagon Maps: Fog of War, Map Exploration, Procedural Generation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>