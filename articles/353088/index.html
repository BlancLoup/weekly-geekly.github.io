<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write the plugin for Unity correctly. Part 1: iOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When you make games on Unity for mobile platforms, sooner or later you will have to write some of the functionality in the native language of the plat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write the plugin for Unity correctly. Part 1: iOS</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/73/si/gj/73sigjfacz6jqtfcysilmxjrado.png"><br><br>  When you make games on Unity for mobile platforms, sooner or later you will have to write some of the functionality in the native language of the platform, be it iOS (Objective C or Swift) or Android (Java, Kotlin).  This may be your own code or integration of a third-party library, the installation itself may consist in copying files or decompressing the unitypackage, not the essence.  The result of this integration is always the same: add libraries with native code (.jar, .aar, .framework, .a, .mm), scripts in C # (for the facade to the native code) and Game Object with a specific MonoBehavior to catch engine events and interactions with a scene.  And it is often required to include libraries of dependencies that are needed for the native part to work. <br><br>  This whole integration mechanism usually does not cause problems on a pure project, in which there is no (or little) integration of such third-party libraries.  But when the project grows, many problems arise that complicate this process, and often give the need for additional modifications and adaptations to the plug-in project, which then results in an increase in the complexity of subsequent support and updating. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here are the main ones: <br><br><ol><li>  The Game Object should normally be loaded with the first scene, and be DontDestroyOnLoad.  We have to create a special scene with a bunch of such non-paged objects, and then also see them in the editor during the testing process. </li><li>  All of these files are often added to Assets / Plugins / iOS and Assets / Plugins / Android, with all dependencies.  Then it is difficult to figure out where and for what is the library file, and dependencies often conflict with those already installed for other plugins. </li><li>  If the libraries are in special subfolders, there is no conflict during the import, but during the assembly there may be an error of duplicate classes, if in the end there are still somewhere the same dependencies of different versions. </li><li>  Sometimes it is too late to initialize the native part in Awake, and the MonoBehavior event may not be enough. </li><li>  Unity Send Message for interaction between native and C # code is inconvenient, since it is asynchronous and with one string argument, without variants. </li><li>  I want to use C # delegates as callbacks. </li><li>  Some plug-ins require on iOS to launch the implementation of their UIApplicationDelegate, the successor of UnityAppController, and on Android their Activity, the successor of UnityPlayerActivity, or their Application class.  Since there can be only one UIApplicationDelegate on iOS, and on Android one main Activity (for games) and one Application, several plug-ins become difficult to get along in one project. </li></ol><br>  But these problems can be avoided if you are guided by certain recipes when writing plugins.  In this article we will look at tips for iOS, in the second part - for Android. <br><br>  The main principle when writing plugins is: do not use the Game Object unless you need to draw something on the stage (use graphics api).  Unity and Cocoa Touch already have all the major events required by an ordinary plugin: start, resume, pause, notification event.  And the interaction between C # and ObjectiveC (Swift) can be accomplished via <b>AOT.MonoPInvokeCallback</b> .  The essence of this method is that we register a static C # function of some class as a C function, and store a reference to it in C (ObjectiveC) code. <br><br>  I will give an example of my class that implements a functional similar to UnitySendMessage: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* MessageHandler.cs */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MessageHandler</span></span> { <span class="hljs-comment"><span class="hljs-comment">//        private delegate void MonoPMessageDelegate(string message, string data); //        , //      [AOT.MonoPInvokeCallback(typeof(MonoPMessageDelegate))] private static void OnMessage(string message, string data) { //      MessageRouter.RouteMessage(message, data); } //        Unity Engine   [RuntimeInitializeOnLoadMethod] private static void Initialize() { //          RegisterMessageHandler(OnMessage); } //  ,        [DllImport("__Internal")] private static extern void RegisterMessageHandler(MonoPMessageDelegate messageDelegate); }</span></span></code> </pre> <br>  In this class, there is both a declaration of the signature of the exported method via the delegate, and its implementation OnMessage, and automatic transmission of the reference to this implementation when the game starts. <br><br>  Consider the implementation of this mechanism in the native code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* MessageHandler.mm */</span></span> <span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt; //     ,    Unity typedef void (*MonoPMessageDelegate)(const char* message, const char* data); //     . //         -  static MonoPMessageDelegate _messageDelegate = NULL; //   ,    Unity FOUNDATION_EXPORT void RegisterMessageHandler(MonoPMessageDelegate delegate) { _messageDelegate = delegate; } //  - ,      Unity, //    void SendMessageToUnity(const char* message, const char* data) { dispatch_async(dispatch_get_main_queue(), ^{ if(_messageDelegate != NULL) { _messageDelegate(message, data); } }); }</span></span></span></span></code> </pre> <br>  As an example, I wrote a native implementation in the form of a global static variable and function.  If you wish, you can wrap all this in some class.  It is important to make a call to MonoPMessageDelegate in the main thread, because on iOS this is the Unity stream, and on the C # side you cannot transfer to the right stream without having a Game Object on the stage. <br><br>  We implemented the interaction between Unity and native code without using a Game Object!  Of course, we just repeated the functionality of UnitySendMessage, but here we control the signature, and we can create as many such methods with the necessary arguments.  And if you want to call something before Unity is initialized, you can create a message queue if MonoPMessageDelegate is still null. <br><br>  But transferring primitive types is not enough.  Often you need to transfer a calback to the native C # function, which will then need to pass the result.  Of course, you can save a colbek in any Dictionary, and transfer the unique key to it to the native function.  But in C # there is a ready solution, using the capabilities of the GC, to fix the object in memory and get a pointer to it.  This pointer is passed to the native function, it, after performing the operation and generating the result, passes the pointer along with this result back to Unity, where we receive a callback object (for example, Action). <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* MonoPCallback.cs */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MonoPCallback</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,     Action //     private delegate void MonoPCallbackDelegate(IntPtr actionPtr, string data); [AOT.MonoPInvokeCallback(typeof(MonoPCallbackDelegate))] private static void MonoPCallbackInvoke(IntPtr actionPtr, string data) { if(IntPtr.Zero.Equals(actionPtr)) { return; } //      Action var action = IntPtrToObject(actionPtr, true); if(action == null) { Debug.LogError("Callaback not found"); return; } try { // ,       Action var paramTypes = action.GetType().GetGenericArguments(); //        var arg = paramTypes.Length == 0 ? null : ConvertObject(data, paramTypes[0]); //  Action     , //     var invokeMethod = action.GetType().GetMethod("Invoke", paramTypes.Length == 0 ? new Type[0] : new []{ paramTypes[0] }); if(invokeMethod != null) { invokeMethod.Invoke(action, paramTypes.Length == 0 ? new object[] { } : new[] { arg }); } else { Debug.LogError("Failed to invoke callback " + action + " with arg " + arg + ": invoke method not found"); } } catch(Exception e) { Debug.LogError("Failed to invoke callback " + action + " with arg " + data + ": " + e.Message); } } //       public static object IntPtrToObject(IntPtr handle, bool unpinHandle) { if(IntPtr.Zero.Equals(handle)) { return null; } var gcHandle = GCHandle.FromIntPtr(handle); var result = gcHandle.Target; if(unpinHandle) { gcHandle.Free(); } return result; } //       public static IntPtr ObjectToIntPtr(object obj) { if(obj == null) { return IntPtr.Zero; } var handle = GCHandle.Alloc(obj); return GCHandle.ToIntPtr(handle); } //  ,    public static IntPtr ActionToIntPtr&lt;T&gt;(Action&lt;T&gt; action) { return ObjectToIntPtr(action); } private static object ConvertObject(string value, Type objectType) { if(value == null || objectType == typeof(string)) { return value; } return Newtonsoft.Json.JsonConvert.DeserializeObject(value, objectType); } //    [RuntimeInitializeOnLoadMethod] private static void Initialize() { RegisterCallbackDelegate(MonoPCallbackInvoke); } [DllImport("__Internal")] private static extern void RegisterCallbackDelegate(MonoPCallbackDelegate callbackDelegate); }</span></span></code> </pre> <br>  And on the side of the native code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* MonoPCallback.h */</span></span> <span class="hljs-comment"><span class="hljs-comment">//       Unity  typedef const void* UnityAction; //     ,     void SendCallbackDataToUnity(UnityAction callback, NSDictionary* data); /* MonoPCallback.mm */ #import &lt;Foundation/Foundation.h&gt; #import "MonoPCallback.h" //     Objective C typedef void (*MonoPCallbackDelegate)(UnityAction action, const char* data); //    , //          static MonoPCallbackDelegate _monoPCallbackDelegate = NULL; FOUNDATION_EXPORT void RegisterCallbackDelegate(MonoPCallbackDelegate callbackDelegate) { _monoPCallbackDelegate = callbackDelegate; } //      -  void SendCallbackDataToUnity(UnityAction callback, NSDictionary* data) { if(callback == NULL) return; NSString* dataStr = nil; if(data != nil) { //    json NSError* parsingError = nil; NSData* dataJson = [NSJSONSerialization dataWithJSONObject:data options:0 error:&amp;parsingError]; if (parsingError == nil) { dataStr = [[NSString alloc] initWithData:dataJson encoding:NSUTF8StringEncoding]; } else { NSLog(@"SendCallbackDataToUnity json parsing error: %@", parsingError); } } //    Unity ()  dispatch_async(dispatch_get_main_queue(), ^{ if(_monoPCallbackDelegate != NULL) _monoPCallbackDelegate(callback, [dataStr cStringUsingEncoding:NSUTF8StringEncoding]); }); }</span></span></code> </pre> <br>  In this example, a fairly universal approach was used to transfer the result as a json string.  By passing the pointer, the Action is retrieved with unlocking in the GC (that is, the callback is called once, then the pointer becomes invalid, and the Action can be deleted by the GC), the type of the required argument is checked (one!), And through Json.Net the data is de-serialized this type.  All these actions are optional, you can create a signature MonoPCallbackDelegate another, specific to your particular case.  But this approach allows us not to produce many methods of the same type, but to reduce the use itself to the definition of the simplest class specifying the data format and setting this format through generic arguments: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Example.cs */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Example</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ResultData</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Success; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ValueStr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ValueInt; } [DllImport(<span class="hljs-string"><span class="hljs-string">"__Internal"</span></span>, CharSet = CharSet.Ansi)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeDataWithCallback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, IntPtr callback</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, Action&lt;ResultData&gt; completionHandler</span></span></span><span class="hljs-function">)</span></span> { GetSomeDataWithCallback(key, MonoPCallback.ActionToIntPtr&lt;ResultData&gt;(completionHandler); } }</code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Example.mm */</span></span> <span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt; #import "MonoPCallback.h" FOUNDATION_EXPORT void GetSomeDataWithCallback(const char* key, UnityAction callback) { DoSomeStuffWithKey(key); SendCallbackDataToUnity(callback, @{ @"Success" : @YES, @"ValueStr" : someResult, @"ValueInt" : @42 }); }</span></span></span></span></code> </pre><br>  With the interaction between Unity and native code sorted out.  It is worth adding that the native code in the form of .mm files, or compiled .a or .framework is not necessary to put in Assets / Plugins / iOS.  If you are writing not for yourself, but any package for export to other projects, put everything in a subfolder inside your specific folder with the code - then it will be easier to connect the ends with the ends and remove unwanted packages.  If the plugin requires you to add some standard iOS dependencies (frameworks) to the project, use the import settings in the Unity editor for .mm, .a and .framework files.  Only use the PostProcessBuild function as a last resort.  By the way, if the required framework is not in the inspector list, you can write it directly in the meta file through a text editor, following the general syntax. <br><br><img src="https://habrastorage.org/webt/s8/1u/g9/s81ug916usqcwhfbaryu5whfkc0.png"><br><br>  Now we will consider how to catch the events of UIApplicationDelegate and the application life cycle in particular.  Here we are already assisted by messages already transmitted to Unity via NotificationCenter.  Consider a way to execute the native plugin script even before Unity is loaded and subscribe to these events. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* ApplicationStateListener.mm */</span></span> <span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt; #import &lt;UIKit/UIKit.h&gt; #import "AppDelegateListener.h" @interface ApplicationStateListener : NSObject &lt;AppDelegateListener&gt; + (instancetype)sharedInstance; @end @implementation ApplicationStateListener //      , //    Unity Player static ApplicationStateListener* _applicationStateListenerInstance = [[ApplicationStateListener alloc] init]; + (instancetype)sharedInstance { return _applicationStateListenerInstance; } - (instancetype)init { self = [super init]; if (self) { //    -    //   Notification Center    UIApplicationDelegate, //    Unity    UnityRegisterAppDelegateListener(self); } return self; } - (void)dealloc { //    . -,     [[NSNotificationCenter defaultCenter] removeObserver:self]; } #pragma mark AppDelegateListener - (void)applicationDidFinishLaunching:(NSNotification *)notification { NSDictionary *launchOptions = notification.userInfo; //    -   launchOptions, //    sdk } - (void)applicationDidEnterBackground:(NSNotification *)notification { //    } - (void)applicationDidBecomeActive:(NSNotification *)notification { //     } - (void)onOpenURL:(NSNotification*)notification { NSDictionary* openUrlData = notification.userInfo; //     } @end</span></span></span></span></code> </pre> <br>  So you can catch most of the events of the application life cycle.  Not all methods, of course, are available.  For example, from the latter, there is no <i>application: performActionForShortcutItem: completionHandler</i> : to respond to the launch by a shortcut from the 3d touch context menu.  But since this method does not exist in the basic UnityAppController, it can be expanded using the category in any plug-in file and, for example, throw a new event in the Notification Center: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* ApplicationExtension.m */</span></span> <span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityAppController.h"</span></span></span><span class="hljs-meta"> @implementation UnityAppController (ShortcutItems) - (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem*)shortcutItem completionHandler:(void (^)(BOOL succeeded))completionHandler { [[NSNotificationCenter defaultCenter] postNotificationName:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UIApplicationPerformActionForShortcutItem"</span></span></span><span class="hljs-meta"> object:nil userInfo:@{ UIApplicationLaunchOptionsShortcutItemKey : shortcutItem }]; completionHandler(YES); } @end</span></span></code> </pre> <br>  On iOS, there is another problem when you need to add third-party libraries from CocoaPods, the package manager for Xcode.  This is rare, there is often an alternative to introducing the library directly.  But in this case, too, there is a <a href="https://github.com/googlesamples/unity-jar-resolver">solution</a> .  Its essence is that instead of the Podfile (file - dependency manifest), dependencies are published in the xml file, and when exporting the XCode project, support for CocoaPods is automatically added and xcworkspace is created with the dependencies already included.  There may be several Xml files, they may be located in Assets in a sub-folder with a specific plugin, Unity Jar Resolver will scan all these files and find dependencies.  The tool got its name, because initially it was created to do the same with Android dependencies, and there the problem of including third-party native libraries is more acute, so you can‚Äôt do without such a tool.  But about this - in the next part of the article. </div><p>Source: <a href="https://habr.com/ru/post/353088/">https://habr.com/ru/post/353088/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353074/index.html">About the main reason for the existence of modern JS frameworks</a></li>
<li><a href="../353076/index.html">React-testing-library library overview</a></li>
<li><a href="../353080/index.html">Misconceptions about automated testing</a></li>
<li><a href="../353082/index.html">Desperate quad circle search</a></li>
<li><a href="../353084/index.html">Digital Signature Cloud Services</a></li>
<li><a href="../353090/index.html">IT asset management: how myths affect projects (Part 2)</a></li>
<li><a href="../353092/index.html">Digital events in Moscow from April 9 to 15</a></li>
<li><a href="../353094/index.html">ECO Flow in Vivado or working in netlist editing mode</a></li>
<li><a href="../353100/index.html">Explicit Proxy with authorization by AD Group + Interception Proxy with authorization by MAC</a></li>
<li><a href="../353102/index.html">Effective use of AWS spot instances</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>