<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization killers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post contains tips on how not to write code whose performance will be much lower than expected. This is especially true when the V8 engine (used ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization killers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/5f7/05b/5cc/5f705b5cc0678527b0d9a8e1b5151b5b.jpg" alt="image"><br><br>  This post contains tips on how not to write code whose performance will be much lower than expected.  This is especially true when the V8 engine (used in Node.js, Opera, Chromium, etc.) refuses to optimize some functions. <br><a name="habracut"></a><br><h1>  V8 Features </h1><br>  There is no interpreter in this engine, but there are two different compilers: regular and optimizing.  This means that your JS code is always compiled and executed directly as native.  Think it means fast?  You are mistaken.  Compiling into native code doesn't improve performance too much.  We only get rid of the use of the interpreter, but the non-optimized code will work so slowly. <br><br>  For example, in a normal compiler, the expression a + b would look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="xml hljs">mov eax, a mov ebx, b call RuntimeAdd</code> </pre> <br>  This is just a call to the corresponding function.  If a and b are integer, then the code will look like this: <br><br><pre> <code class="html hljs xml">mov eax, a mov ebx, b add eax, ebx</code> </pre><br>  And this option will work much faster than the call, which at run time handles complex additional JS semantics.  In other words, a regular compiler generates a non-optimized, "raw" code, and an optimizing compiler brings it to mind, leading to the final form.  At the same time, the performance of the optimized code can be 100 times higher than the performance of the ‚Äúnormal‚Äù one.  But the fact is that you can't just write any JS code and optimize it.  There are many programming patterns (some of them even idiomatic) that the optimizing compiler refuses to process. <br><br>  Note that if a template is not optimized, then it affects the entire function that contains it.  After all, the code is optimized one function at a time, and the system does not know what the rest of the code does (unless it is built into a function that is being optimized at the moment). <br><br>  Below, we will look at most of the templates whose functions fall into the ‚Äúhell of de-optimization‚Äù.  Most often it makes sense to change them, and the proposed solutions may become unnecessary when the compiler learns to recognize all new and new patterns. <br><br><h1>  1. Using the built-in toolkit </h1><br>  To determine how patterns affect optimization, you should be able to use Node.js with some V8 flags.  Create a function with a pattern, call it with all sorts of data types, and then call the internal V8 function to test and optimize: <br><br>  test.js: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Function that contains the pattern to be inspected (using with statement) function containsWith() { return 3; with({}) {} } function printStatus(fn) { switch(%GetOptimizationStatus(fn)) { case 1: console.log("Function is optimized"); break; case 2: console.log("Function is not optimized"); break; case 3: console.log("Function is always optimized"); break; case 4: console.log("Function is never optimized"); break; case 6: console.log("Function is maybe deoptimized"); break; case 7: console.log("Function is optimized by TurboFan"); break; default: console.log("Unknown optimization status"); break; } } // Fill type-info containsWith(); // 2 calls are needed to go from uninitialized -&gt; pre-monomorphic -&gt; monomorphic containsWith(); %OptimizeFunctionOnNextCall(containsWith); // The next call containsWith(); // Check printStatus(containsWith);</span></span></code> </pre><br>  Run: <br><br><pre> <code class="bash hljs">$ node --trace_opt --trace_deopt --allow-natives-syntax test.js Function is not optimized</code> </pre><br>  To test the functionality, comment out the with statement and restart: <br><br><pre> <code class="bash hljs">$ node --trace_opt --trace_deopt --allow-natives-syntax test.js [optimizing 000003FFCBF74231 &lt;JS Function containsWith (SharedFunctionInfo 00000000FE1389E1)&gt; - took 0.345, 0.042, 0.010 ms] Function is optimized</code> </pre><br>  It is important to use the built-in toolkit to check if the selected solutions work. <br><br><h1>  2. Unsupported syntax </h1><br>  Some constructs are not explicitly supported by the optimizing compiler because they use a non-optimizable syntax. <br><br>  <b>Important:</b> even if the structure is unavailable or not executed, it still does not allow optimizing the function containing it. <br><br>  For example, it is useless to do so: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEVELOPMENT) { <span class="hljs-keyword"><span class="hljs-keyword">debugger</span></span>; }</code> </pre><br>  This code will affect the entire function, even if the debugger expression will not be executed. <br><br>  Currently not optimized: <br><br><ul><li>  function generators; </li><li>  functions containing a for-of expression; </li><li>  functions containing a try-catch expression; </li><li>  functions containing a try-finally statement; </li><li>  functions containing a compound let assignment statement; </li><li>  functions containing the const compound assignment operator; </li><li>  functions that contain object literals, which in turn contain __proto__, get, or set declarations. </li></ul><br>  Most likely, not optimized: <br><br><ul><li>  functions containing a debugger expression; </li><li>  functions that call eval (); </li><li>  functions containing a with expression. </li></ul><br>  To avoid misunderstandings: if a function contains any of the following, it will not be fully optimized: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsObjectLiteralWithProto</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">__proto__</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsObjectLiteralWithGetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { get prop() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; } }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsObjectLiteralWithSetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { set prop(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val = val; } }; }</code> </pre><br>  Direct calls to eval and with deserved special mention, because everything they work with is in the dynamic scope, which means that these expressions can have a negative impact on many other functions if it becomes impossible to analyze what is happening there. <br><br>  <b>Workaround</b> : some of these expressions cannot be discarded in the finished product code.  For example, from try-finally or try-catch.  To minimize the detrimental effects, they should be isolated within small functions: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> errorObject = {<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryCatch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, ctx, args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn.apply(ctx, args); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { errorObject.value = e; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorObject; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = tryCatch(mightThrow, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// Unambiguously tells whether the call threw if(result === errorObject) { var error = errorObject.value; } else { // Result is the returned value }</span></span></code> </pre><br><h1>  3. Using arguments </h1><br>  There are many ways to use arguments so that it will not be possible to optimize a function.  So when working with arguments you should be especially careful. <br><br><h3>  <i>3.1.</i>  <i>Reassignment of a given parameter under the condition that the arguments are used in the function body (only in the unstable mode (sloppy mode))</i> </h3><br>  Typical example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultArgsReassign</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) b = <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre><br>  In this case, you can save the parameter to a new variable: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reAssignParam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b_</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = b_; <span class="hljs-comment"><span class="hljs-comment">// Unlike b_, b can safely be reassigned if (arguments.length &lt; 2) b = 5; }</span></span></code> </pre><br>  If this were the only way to use arguments in a function, then it could be replaced by checking for undefined: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reAssignParam</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b === <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) b = <span class="hljs-number"><span class="hljs-number">5</span></span>; }</code> </pre><br>  If there is a possibility that the arguments will be used later in the function, then you should not worry about reassignment. <br><br>  Another way to solve the problem is to enable strict mode ('use strict') for a file or function. <br><br><h3>  <i>3.2.</i>  <i>Flowing arguments</i> </h3><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leaksArguments1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leaksArguments2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> args = [].slice.call(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leaksArguments3</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }; }</code> </pre><br>  The arguments object should not be passed anywhere. <br><br>  Proxy can be done by creating an internal array: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doesntLeakArguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// .length is just an integer, this doesn't leak // the arguments object itself var args = new Array(arguments.length); for(var i = 0; i &lt; args.length; ++i) { // i is always valid index in the arguments object args[i] = arguments[i]; } return args; }</span></span></code> </pre><br>  In this case, you have to write a lot of code, so it makes sense to first decide whether the game is worth it.  Again, optimization implies a large amount of code, with more pronounced semantics. <br><br>  However, if your project is at the assembly stage, this can be achieved using a macro that does not require the use of source maps and allows you to save the source code as normal JavaScript. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doesntLeakArguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ INLINE_SLICE(args, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args; }</code> </pre><br>  This technique is used in bluebird, and at the assembly stage, the code turns into this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doesntLeakArguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $_len = <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length;<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> args = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>($_len); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $_i &lt; $_len; ++$_i) {args[$_i] = <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[$_i];} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args; }</code> </pre><br><h3>  <i>3.3.</i>  <i>Assignment to arguments</i> </h3><br>  This can only be done in unstable mode: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assignToArguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>; }</code> </pre><br>  <b>Solution</b> : just do not write such an idiotic code.  In strict mode, such creativity will lead to exclusion. <br><br><h3>  How can you safely use arguments? </h3><br><ul><li>  Use arguments.length. </li><li>  Use arguments [i], where i is always the correct integer index in arguments and cannot be outside its bounds. </li><li>  Never use arguments directly without .length or [i]. </li><li>  You can use fn.apply (y, arguments) in strict mode.  And nothing else, especially .slice.  Function # apply. </li><li>  Remember that adding properties to functions (for example, fn. $ Inject = ...) and restricted functions (for example, the result of Function # bind) results in the creation of hidden classes, therefore it is not safe when using #apply. </li></ul><br>  If you comply with all of the above, using arguments will not result in memory allocation for this object. <br><br><h1>  4. Switch-case </h1><br>  The switch-case expression today can have up to 128 case points, and if this number is exceeded, the function containing this expression cannot be optimized. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">over128Cases</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(c) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ... case <span class="hljs-number"><span class="hljs-number">128</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">129</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Keep the amount of case within 128 pieces using an array of functions or if-else. <br><br><h1>  5. For-in </h1><br>  A For-in expression can interfere with function optimization in several ways. <br><br><h3>  <i>5.1.</i>  <i>The key is not a local variable.</i> </h3><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonLocalKey1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key; }; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonLocalKey2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj); }</code> </pre><br>  The key can not be from the upper scope, as well as can not refer to the bottom.  It must be exclusively local variable. <br><br><h3>  <i>5.2.</i>  <i>The object being iterated is not ‚Äúsimple enumerable‚Äù.</i> </h3><br>  <b>5.2.1.</b>  <b>Objects in the ‚Äúhash table‚Äù mode (‚Äúnormalized objects‚Äù, ‚Äúdictionaries‚Äù - objects whose auxiliary data structure is a hash table) are not simple enumerated</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashTableIteration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hashTable = {<span class="hljs-string"><span class="hljs-string">"-"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hashTable); }</code> </pre><br>  An object can go into hash table mode, for example, when you dynamically add too many properties (outside the constructor), delete properties, use properties that are not valid identifiers, etc. In other words, if you use an object like this, as if it is a hash table, then it turns into a hash table.  In no case can you pass such objects in for-in.  To find out if the object is in hash table mode, you can call console.log (% HasFastProperties (obj)) with the --allow-natives-syntax flag activated in Node.js. <br><br>  <b>5.2.2.</b>  <b>There are fields with enumerated values ‚Äã‚Äãin the object prototype chain.</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{};</code> </pre> <br>  This line gives the property the enumerated chain of prototypes of all objects (with the exception of Object.create (null)).  Thus, any function containing a for-in expression becomes non-optimizable (as long as they do not iterate over Object.create (null) objects). <br><br>  With Object.defineProperty, you can assign non-enumerable properties.  It is not recommended to do this at run time.  But for the effective determination of static things like properties of the prototype - the most it. <br><br>  <b>5.2.3.</b>  <b>The object contains enumerated array indices.</b> <br><br>  It must be said that the properties of the array index are defined in <a href="http://www.ecma-international.org/ecma-262/5.1/">the ECMAScript specification</a> : <br><br>  <i>A property name P (as a string) is an array index if and only if ToString (ToUint32 (P)) is P, and ToUint32 (P) is not 2 <sup>32</sup> - 1. The property whose name is the array index is also called the element .</i> <br><br>  As a rule, this refers to arrays, but ordinary objects may also have array indices: <br><br><pre> <code class="javascript hljs">normalObj[<span class="hljs-number"><span class="hljs-number">0</span></span>] = value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iteratesOverArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arr) { } }</code> </pre><br>  Bounding an array using for-in is slower than using for, and the function containing for-in is not optimized. <br><br>  If you pass an object that is not a simple enumeration to a for-in, this will have a negative effect on the function. <br><br>  <b>Solution</b> : always use Object.keys and iterate over the array using a for loop.  If you really need all the properties from a chain of prototypes, then create an isolated helper function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inheritedKeys</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj) { ret.push(key); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br><h1>  6. Infinite loops with complex logic of exit conditions or with unclear exit conditions. </h1><br>  Sometimes when writing code, you realize that you need to make a cycle, but you have no idea what to put in it.  Then you enter while (true) {or for (;;) {, and then insert into the break loop, which you soon forget.  It is time to refactor, when it turns out that the function is executed slowly or de-optimization is generally observed.  The reason may be in the forgotten condition of interruption. <br><br>  Refactoring the cycle for the sake of placing the condition of output in the conditional part of the expression of the cycle may be nontrivial.  If the condition is part of an if statement at the end of the loop and the code must be executed at least once, then refactor the loop to do {} while () ;.  If the exit condition is located at the beginning, then place it in the conditional part of the loop body.  If the exit condition is located in the middle, then you can play around with the code: each time you move part of the code from the top line to the bottom line, leave a copy of the line above the loop.  After the exit condition can be tested using a conditional or at least a simple logical test, the cycle should no longer fall under deoptimization. </div><p>Source: <a href="https://habr.com/ru/post/273839/">https://habr.com/ru/post/273839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273823/index.html">New 3CX Phone v14 client details</a></li>
<li><a href="../273825/index.html">Hub AI & BigData meetup # 1</a></li>
<li><a href="../273827/index.html">Let's Encrypt in a Plesk Panel</a></li>
<li><a href="../273835/index.html">IBM Watson will help treat children with rare diseases</a></li>
<li><a href="../273837/index.html">Development on the Yii2 framework on the IBM Bluemix platform</a></li>
<li><a href="../273841/index.html">Thread support in Mail.Ru Mail Android application: we are achieving complete sync</a></li>
<li><a href="../273843/index.html">From STUPID code to SOLID code</a></li>
<li><a href="../273845/index.html">Welcome to Tarantool meetup January 28</a></li>
<li><a href="../273847/index.html">The digest of news from the world of development on Unity</a></li>
<li><a href="../273849/index.html">Static time analysis demystified</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>