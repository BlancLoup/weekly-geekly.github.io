<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to offline navigation for augmented reality</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Computer systems with control without the help of controllers - a new stage in the interaction of man and computer. This area includes technologies th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to offline navigation for augmented reality</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/3b1/a1b/e39/3b1a1be39d2d4d9f836ec1669c67b034.gif"></div><br>  Computer systems with control without the help of controllers - a new stage in the interaction of man and computer.  This area includes technologies that perceive the physical environment, including gesture recognition, voice recognition, face recognition, motion tracking, environment reconstruction.  <a href="https://software.intel.com/en-us/realsense/devkit">The Intel RealSense F200 and R200 cameras provide a</a> number of features from this area.  Due to the ability to shoot with the definition of the depth of the camera F200 and R200 allow you to build a three-dimensional environment and track the movement of the device in relation to the environment.  Reconstruction of the environment along with motion tracking allows you to realize the possibilities of virtual reality, in which virtual objects fit into the real world. <br><br>  The purpose of this article is to introduce autonomous navigation and describe its use in augmented reality applications.  The developed example uses the Intel RealSense R200 camera and the <a href="http://unity3d.com/">Unity 3D</a> game engine.  It is recommended that you familiarize yourself with the capabilities of the <a href="https://software.intel.com/en-us/intel-realsense-sdk">Intel RealSense SDK</a> and Unity.  For information on integrating the Intel RealSense SDK with Unity, see the articles <a href="https://software.intel.com/ru-ru/articles/game-development-with-unity-and-intel-realsense-3d-camera">Developing Games with Unity and the Intel RealSense 3D Camera</a> and <a href="https://blogs.intel.com/evangelists/2015/06/08/first-look-ar-unity-intel-realsense-r200/">First Look: Augmented Reality in Unity with the Intel RealSense R200</a> . <br><a name="habracut"></a><br>  Intel RealSense cameras can provide data to augmented reality applications, but creating a truly interesting virtual world is up to developers.  One way to create a live environment is to use autonomous agents.  Autonomous agents are objects that operate independently using artificial intelligence.  Artificial intelligence determines the operational parameters and rules that the agent must obey.  The agent dynamically reacts to the conditions of the environment in which it is located, in real time, so even with the simplicity of the principles of action it can have a complex pattern of behavior. <br><br>  Autonomous agents can exist in many types, but in this discussion we will focus on agents that can move and navigate.  These agents include game characters not controlled by the player (NPC), and birds gathering in flocks in educational animation programs.  The objectives of the agents will vary depending on the application, but the principles of movement and navigation are the same in all cases. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#0071c5">Autonomous navigation</font> </h2><br>  Agents can be navigated in different ways: both simple and complex, both in terms of implementation and in terms of resource intensity.  The simplest approach is to determine the path that the agent will take.  The waypoint is selected, then the agent moves towards it in a straight line.  This approach is simple to implement, but its application involves several problems.  The most obvious of them is: what happens if there is no direct path between the agent and the waypoint (Fig. 1)? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/12f/6e6/2aa/12f6e62aaac14bb1b1bb12fda944b73c.gif"></div><br>  <i><font color="#999999">Figure 1. The agent moves to the target along a straight path, but the path is blocked by an obstacle.</font></i>  <i><font color="#999999">Note.</font></i>  <i><font color="#999999">The described issues are applicable to navigation in both two-dimensional and three-dimensional space.</font></i>  <i><font color="#999999">This uses 2D space for illustration.</font></i> <br><br>  To pave the route around obstacles, you need to add additional waypoints (Fig. 2). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8ec/840/95b/8ec84095b5a148d290d5577c4694c96a.gif"></div><br>  <i><font color="#999999">Figure 2. Additional waypoints are added so that the agent can bypass obstacles.</font></i> <br><br>  On large maps with a large number of obstacles there will be much more waypoints and routes.  In addition, increasing the density of waypoints (Fig. 3) will help to build more efficient routes (the agent‚Äôs path to the destination point will be shorter). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/171/86a/5f2/17186a5f215c40418a24179c0da82406.gif"></div><br>  <i><font color="#999999">Figure 3. As the map size increases, the number of waypoints and possible routes increases.</font></i> <br><br>  With a large number of waypoints, a way to construct a route between two waypoints located not in the neighborhood of one another is required.  This problem is called "finding the way."  Pathfinding is closely related to graph theory and is used in many areas, not only in navigation.  Naturally, quite a lot of research is being done in this area; many algorithms have been created to solve various problems of finding a path.  One of the most well-known path finding algorithms is A *.  This algorithm provides for movement between adjacent waypoints towards the destination and a map of all visited waypoints and all waypoints connected to them.  After reaching the destination, the algorithm calculates the path using the created map.  After that, the agent can move along this path.  Algorithm A * does not provide for a search in all available space, therefore the constructed path is not always optimal.  The effectiveness of this algorithm in terms of the load on computing resources is quite high. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/94a/1cc/238/94a1cc2381c740bc95827d1ad1db00fc.gif"></div><br>  <i><font color="#999999">Figure 4. Algorithm A * bypasses the map, trying to find a route to the target. Animation: Subh83 / <a href="">CC BY 3.0</a></font></i> <br><br>  Algorithm A * by its nature cannot adapt to environmental changes, such as adding or removing obstacles, moving boundaries.  The augmented reality environment is inherently dynamic, since such an environment is created and modified in accordance with the movement of the user and the physical space. <br><br>  In a dynamic environment, it is desirable that agents make a decision in real time;  such a decision should be made on the basis of the total amount of the agent‚Äôs current knowledge of the environment.  Thus, it is necessary to define the structure so that the agent can make decisions and act in real time.  With regard to navigation, a convenient and common approach is that the structure of behavior is divided into three levels. <br><br><ol><li>  <b>The choice of action</b> consists of setting goals and determining how to achieve these goals.  For example, a rabbit will move around the field in search of food, but when a predator appears near it, the rabbit will flee.  Finite automata (end-state machines) are conveniently used to implement this behavior, since they determine the agent states and the conditions under which the states change. <br><br></li><li>  <b>Guidance</b> is the calculation of movement based on the current state of the agent.  For example, if a predator is chasing a rabbit, the rabbit must run away from the predator.  Guidance calculates both magnitude and direction of motion. <br><br></li><li>  <b>Movement</b> is the mechanic through which the agent moves.  A rabbit, a man, a car, and a spaceship move in different ways.  Movement also determines the method of movement (for example, using legs, wheels, rocket engines), and the parameters of this movement (for example, mass, maximum speed, maximum force, etc.). </li></ol><br>  Together, these levels form the artificial intelligence agent.  In the next section, we will show an example of a Unity application that demonstrates the implementation of these three levels.  Next, we embed autonomous navigation in an augmented reality application using the R200 camera. <br><br><h2>  <font color="#0071c5">Implementing autonomous navigation</font> </h2><br>  This section describes the platform behavior in the Unity scene for autonomous navigation, starting with movement. <br><br><h3>  <font color="#0071c5">‚ñçMoving</font> </h3><br>  The movement of the agent is based on the <a href="https://en.wikipedia.org/wiki/Newton%2527s_laws_of_motion">laws of Newton's dynamics</a> : when force is applied to the mass, acceleration occurs.  We use a simplified model with a uniformly distributed body mass, to which force from any direction can be applied.  To limit the movement sets the maximum force and maximum speed (code fragment 1). <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mass = <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Mass (kg) public float maxSpeed = 0.5f; // Maximum speed (m/s) public float maxForce = 1f; // "Maximum force (N)</span></span></code> </pre> <br>  <i><font color="#999999">Code snippet 1. Agent movement pattern</font></i> <br><br>  The agent must have the components rigidbody and collider, which are initialized at startup (see code snippet 2).  For simplicity, gravity is excluded, but it can be turned on. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Initialize the rigidbody this.rb = GetComponent&lt;rigidbody&gt; (); this.rb.mass = this.mass; this.rb.useGravity = false; // Initialize the collider this.col = GetComponent&lt;collider&gt; (); }</span></span></code> </pre> <br>  <i><font color="#999999">Code snippet 2. The rigidbody and collider components are initialized with Start ()</font></i> <br><br>  The agent moves by applying force to a rigidbody in the <i>FixedUpdate ()</i> step (see code snippet 3).  <i>FixedUpdate ()</i> works like <i>Update ()</i> , but is guaranteed to run at the same interval as <i>Update ()</i> .  The Unity engine performs physics calculations (operations with solids) after completing the <i>FixedUpdate ()</i> step. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Vector3 force = Vector3.forward; <span class="hljs-comment"><span class="hljs-comment">// Upper bound on force if (force.magnitude &gt; this.maxForce) { force = force.normalized * this.maxForce; } // Apply the force rb.AddForce (force, ForceMode.Force); // Upper bound on speed if (rb.velocity.magnitude &gt; this.maxSpeed) { rb.velocity = rb.velocity.normalized * this.maxSpeed; } }</span></span></code> </pre> <br>  <i><font color="#999999">Code 3 snippet. Strength applied to a rigidbody in the FixedUpdate () step.</font></i>  <i><font color="#999999">In this example, the agent moves along the z axis.</font></i> <br><br>  If the magnitude of the force exceeds the maximum force of the agent, it is adjusted so that the force of the magnitude is equal to the maximum force (the direction is preserved).  The <i>AddForce ()</i> function applies force through <a href="https://en.wikipedia.org/wiki/Numerical_integration">numerical integration</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/183/8a2/7d1/1838a27d19734000a1d82e9e11c28f9a.PNG"></div><br>  <i><font color="#999999">Equation 1. Numerical integration of speed.</font></i>  <i><font color="#999999">The AddForce () function performs this calculation.</font></i> <br><br>  Where <i>ŒΩ <sub>1</sub></i> is the new speed, <i>ŒΩ <sub>0</sub></i> is the old speed, <i>f</i> is the force, <i>m</i> is the mass, and <i>Œît</i> is the time interval between updates (by default, the fixed time step in Unity is 0.02 s).  If the magnitude of the speed exceeds the maximum speed of the agent, it is adjusted to match the maximum speed. <br><br><h3>  <font color="#0071c5">‚ñç Hope</font> </h3><br>  Guidance computes the force that will be given to the movement pattern.  Three hover behavior algorithms will be applied: search, arrival, and avoidance of obstacles. <br><br><h4>  Search </h4><br>  Behavior ‚ÄúSearch‚Äù tries to move the object to the target as quickly as possible  The desired speed of this behavior - the movement directly to the target with maximum speed.  The pointing force is calculated as the difference between the desired and the current speeds of the agent (Fig. 5). <br><br><img src="https://habrastorage.org/files/35e/0de/2ae/35e0de2aeb9548e08f05a78da41caada.png"><br>  <i><font color="#999999">Figure 5. Search Behavior applies pointing power to change the current speed to the desired</font></i> <br><br>  The implementation (code snippet 4) first calculates the desired vector by normalizing the offset between the agent and the target and multiplying it by the maximum speed.  The return power of the guidance is the desired speed minus the current speed of the rigidbody. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Seek</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Vector3 desiredVelocity = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.seekTarget.position - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position).normalized * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxSpeed; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> desiredVelocity - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rb.velocity; }</code> </pre> <br>  <i><font color="#999999">Code snippet 4. Search behavior</font></i> <br><br>  The agent uses the ‚ÄúSearch‚Äù algorithm, calling <i>Seek ()</i> when calculating the force in <i>FixedUpdate ()</i> (code snippet 5). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Vector3 force = Seek (); ...</code> </pre> <br>  <i><font color="#999999">Snippet 5. Calling Seek () in FixedUpdate ()</font></i> <br><br>  An example of the ‚ÄúSearch‚Äù algorithm in action is shown in video 1. The agent is provided with a blue arrow indicating the current speed of the rigidbody and a red arrow indicating that guidance is applied at this time interval. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/HMjut52zxgI%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiJHJgGeF_qZRJSuJE6yCBg7ysBcQ" frameborder="0" allowfullscreen=""></iframe><br>  <i><font color="#999999">Video 1. Initially, the speed of the agent is perpendicular to the direction to the target, so the agent moves along the curve</font></i> <br><br><h4>  Arrival </h4><br>  With the ‚ÄúSearch‚Äù algorithm, the agent misses the target and moves around it, as it moved with the greatest possible speed.  The ‚ÄúArrival‚Äù algorithm is similar to the ‚ÄúSearch‚Äù algorithm, and the difference is that it tries to completely stop at the target.  The ‚ÄúDeceleration Radius‚Äù parameter determines the distance to the target, after reaching which the agent will begin to slow down.  When the agent is inside the deceleration radius, the value of the desired speed will be inversely proportional to the distance between the agent and the target.  Depending on the values ‚Äã‚Äãof the maximum force, the maximum speed and the deceleration radius, this behavior may not lead to a complete stop. <br><br>  The Arrival behavior (snippet 6) first calculates the distance between the agent and the target.  The reduced speed is calculated as the maximum speed reduced to distance divided by the deceleration radius.  The desired speed is the lowest between the superficial speed and the maximum speed.  Thus, if the distance to the target is less than the deceleration radius, then the desired speed is the superficial velocity.  Otherwise, the desired speed is the maximum speed.  The remainder of this function works exactly like ‚ÄúSearch‚Äù at the desired speed. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Arrive deceleration radius (m) public float decelerationRadius = 1f; private Vector3 Arrive () { // Calculate the desired speed Vector3 targetOffset = this.seekTarget.position - this.transform.position; float distance = targetOffset.magnitude; float scaledSpeed = (distance / this.decelerationRadius) * this.maxSpeed; float desiredSpeed = Mathf.Min (scaledSpeed, this.maxSpeed); // Compute the steering force Vector3 desiredVelocity = targetOffset.normalized * desiredSpeed; return desiredVelocity - this.rb.velocity; }</span></span></code> </pre> <br>  <i><font color="#999999">Code snippet 6. Arrival behavior</font></i> <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/p_3-zU5GBEI%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhh__P4BQCXqvp8GqSiBuktZnaZxIg" frameborder="0" allowfullscreen=""></iframe><br>  <i><font color="#999999">Video 2. The Arrival algorithm reduces speed when the target is reached.</font></i> <br><br><h4>  Obstacle avoidance </h4><br>  The ‚ÄúArrival‚Äù and ‚ÄúSearch‚Äù algorithms are great for arriving at your destination, but they do not cope with obstacles.  In a dynamic environment, an agent should be able to evade new obstacles that appear.  The Obstacle Avoidance algorithm analyzes the path ahead of the agent along the intended route and determines if there are any obstacles along the way that should be avoided.  If obstacles are detected, the algorithm calculates the force that changes the path of the agent in such a way that the agent does not encounter an obstacle (Fig. 6). <br><br>  Figure 6. If an obstacle is detected on the current path, a force is returned to prevent a collision. <br>  The implementation of the Obstacle Avoidance algorithm (snippet 7) uses spherecast to detect collisions.  At the same time, a sphere is produced along the current velocity's rigidbody body, and RaycastHit is returned for each collision.  The sphere moves from the center of the agent, its radius is equal to the sum of the radius of the collision of the object with the value of the parameter ‚Äúradius of evasion‚Äù.  Using the dodge radius, the user can define empty space around the agent.  The range of motion of the sphere is limited by the parameter "Front detection". <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Avoidance radius (m). The desired amount of space between the agent and obstacles. public float avoidanceRadius = 0.03f; // Forward detection radius (m). The distance in front of the agent that is checked for obstacles. public float forwardDetection = 0.5f; private Vector3 ObstacleAvoidance () { Vector3 steeringForce = Vector3.zero; // Cast a sphere, that bounds the avoidance zone of the agent, to detect obstacles RaycastHit[] hits = Physics.SphereCastAll(this.transform.position, this.col.bounds.extents.x + this.avoidanceRadius, this.rb.velocity, this.forwardDetection); // Compute and sum the forces across all hits for(int i = 0; i &lt; hits.Length; i++) { // Ensure that the collidier is on a different object if (hits[i].collider.gameObject.GetInstanceID () != this.gameObject.GetInstanceID ()) { if (hits[i].distance &gt; 0) { // Scale the force inversely proportional to the distance to the target float scaledForce = ((this.forwardDetection - hits[i].distance) / this.forwardDetection) * this.maxForce; float desiredForce = Mathf.Min (scaledForce, this.maxForce); // Compute the steering force steeringForce += hits[i].normal * desiredForce; } } } return steeringForce; }</span></span></code> </pre> <br>  <i><font color="#999999">Code snippet 7. Behavior "Obstacle Avoidance"</font></i> <br><br>  When spherecast is used, an array of <i>RaycastHit</i> objects is <i>returned</i> .  The <i>RaycastHit</i> object contains information about the collision, including the distance to the collision and the normal to the plane of the surface with which the collision occurred.  A normal is a vector perpendicular to the plane.  It can be used to direct the agent away from the collision point.  The magnitude of the force is determined by maximizing the force inversely proportional to the distance to the collision.  The forces of each collision are added, and the result is the total force of evasion in one time interval. <br><br>  To obtain a more complex behavior, you can use several algorithms at once simultaneously (code snippet 8).  The Obstacle Avoidance algorithm is only useful when used in conjunction with other algorithms.  In this example (video 3), Obstacle Avoidance is used together with the Arrival algorithm.  Algorithms of behavior are combined simply by combining their forces.  More complex schemes are also possible, where heuristic mechanisms are used to determine the weights of the priority of forces. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Calculate the total steering force by summing the active steering behaviors Vector3 force = Arrive () + ObstacleAvoidance(); ...</span></span></code> </pre><br>  <i><font color="#999999">Code snippet 8. The ‚ÄúArrival‚Äù and ‚ÄúObstacle Avoidance‚Äù algorithms are used simultaneously by adding their strengths.</font></i> <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/LsUDMG8KLn8%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiWfY_Z6kYPug5CKLeHc8YiUNioJw" frameborder="0" allowfullscreen=""></iframe><br>  <i><font color="#999999">Video 3. The agent uses two types of behavior at once: ‚ÄúArrival‚Äù and ‚ÄúAvoidance from obstacles‚Äù</font></i> <br><br><h3>  <font color="#0071c5">‚ñçSelection of action</font> </h3><br>  The choice of action is setting common goals and making decisions by the agent.  Our agent implementation already includes a simple model for choosing actions in the form of a combination of the Arrival and Evasion of Obstacles algorithms.  The agent tries to arrive at the target, but if it detects obstacles, its trajectory will be changed.  The Evasion Radius and Discovery Ahead parameters of the Obstacle Avoidance algorithm determine the action to be performed. <br><br><h2>  <font color="#0071c5">R200 camera integration</font> </h2><br>  Now the agent is able to move independently, it can be included in the application of augmented reality. <br>  The following example is based on the Scene Perception example included in the Intel RealSense SDK.  This application creates a three-dimensional model using Scene Perception, and the user can set and move the target in three-dimensional space.  After that, the agent will be able to navigate through the created three-dimensional model to achieve the goal. <br><br><h3>  <font color="#0071c5">‚ñçScene Manager</font> </h3><br>  The Scene Manager script initializes the scene and handles user control.  The only type of control is touch (or mouse click, if the device does not support touch).  The ray tracing from the point of tangency determines whether the created three-dimensional model is touching.  The first touch creates a target on a three-dimensional model, the second creates an agent, and each subsequent touch moves the position of the target.  The control logic is processed by the state machine (snippet 9). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// State machine that controls the scene: // Start =&gt; SceneInitialized -&gt; TargetInitialized -&gt; AgentInitialized private enum SceneState {SceneInitialized, TargetInitialized, AgentInitialized}; private SceneState state = SceneState.SceneInitialized; // Initial scene state. private void Update () { // Trigger when the user "clicks" with either the mouse or a touch up gesture. if(Input.GetMouseButtonUp (0)) { TouchHandler (); } } private void TouchHandler () { RaycastHit hit; // Raycast from the point touched on the screen if (Physics.Raycast (Camera.main.ScreenPointToRay (Input.mousePosition), out hit)) { // Only register if the touch was on the generated mesh if (hit.collider.gameObject.name == "meshPrefab(Clone)") { switch (this.state) { case SceneState.SceneInitialized: SpawnTarget (hit); this.state = SceneState.TargetInitialized; break; case SceneState.TargetInitialized: SpawnAgent (hit); this.state = SceneState.AgentInitialized; break; case SceneState.AgentInitialized: MoveTarget (hit); break; default: Debug.LogError("Invalid scene state."); break; } } } }</span></span></code> </pre> <br>  <i><font color="#999999">Code snippet 9. Touch handler and state machine for sample application</font></i> <br><br>  The Scene Perception component forms many small three-dimensional models.  Such models usually have no more than 30 vertices.  The location of the peaks may vary, with the result that some models are slightly inclined with respect to the surface on which they are located.  If the object is on top of the model (for example, a goal or an object), then the object will be incorrectly oriented.  To work around this problem, the average normal of the three-dimensional model is used (code snippet 10). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AverageMeshNormal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mesh mesh)</span></span></span><span class="hljs-function"> </span></span>{ Vector3 sum = Vector3.zero; <span class="hljs-comment"><span class="hljs-comment">// Sum all the normals in the mesh for (int i = 0; i &lt; mesh.normals.Length; i++){ sum += mesh.normals[i]; } // Return the average return sum / mesh.normals.Length; }</span></span></code> </pre> <br>  <i><font color="#999999">Fragment of code 10. Calculation of the average normal of the three-dimensional model</font></i> <br><br><h3>  <font color="#0071c5">‚ñç Assembly application</font> </h3><br>  All code developed for this example is available <a href="https://github.com/FantasmoStudios/AutoNavAR">on Github</a> . <br>  The following instructions build the Scene Manager and agent implementation into the Intel RealSense application. <br><br><ol><li>  Open the RF_ScenePerception example in the Intel RealSense SDK folder RSSDK \ framework \ Unity. </li><li>  <a href="https://github.com/FantasmoStudios/AutoNavAR/releases/download/1.0/AutoNavAR.unitypackage">Download</a> and import the AutoNavAR Unity package. </li><li>  Open RealSenseExampleScene in the Assets / AutoNavAR / Scenes / folder. </li><li>  Build and run the application on any compatible device with the Intel RealSense R200 Camera. </li></ol><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/k-WwQwPgSIo%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiqO_Z2YUk9SZwFuYrLRcmGzIEiOA" frameborder="0" allowfullscreen=""></iframe><br>  <i><font color="#999999">Video 4. Completed Integration with the Intel RealSense R200 Camera</font></i> <br><br><h2>  <font color="#0071c5">Further development of autonomous navigation</font> </h2><br>  We have developed an example that demonstrates an autonomous agent in an augmented reality application with a R200 camera.  There are several ways to develop this work, to increase the "rationality" and realism of the agent. <br><br>  As an agent, a simplified mechanical model was used with a uniform distribution of mass and without restriction of movement in directions.  A more sophisticated model can be developed in which the mass will be distributed unevenly, and the forces applied to the body will be limited (for example, a car with different acceleration and deceleration forces, a spacecraft with the main engine and lateral shunting engines).  The more precisely the mechanical models are made, the more realistic the movement will be. <br><br>  Craig Reynolds (Craig Reynolds) first described in detail the behavioral guidance algorithms in the context of animation and games.  The algorithms "Search", "Arrival" and "Evasion from obstacles", demonstrated in our example, are based on <a href="http://www.red3d.com/cwr/papers/1999/gdc99steer.pdf">his work</a> .  Reynolds described other behavioral algorithms, including ‚ÄúEscape‚Äù, ‚ÄúHarassment‚Äù, ‚ÄúWandering‚Äù, ‚ÄúResearch‚Äù, ‚ÄúObstacle Avoidance‚Äù and ‚ÄúFollowing the Route‚Äù.  Considered group behavior algorithms include ‚ÄúSplitting‚Äù, ‚ÄúMerging‚Äù and ‚ÄúBuilding‚Äù.  Another useful resource is Mat Buckland's ‚ÄúProgramming the Artificial Intelligence of Games with Examples‚Äù.  It describes the implementation of behavioral algorithms and a number of other issues, including finite automata and the search for paths. <br><br>  In this example, the arrival and the obstacle avoidance guidance algorithms are applied to the agent simultaneously.  So you can combine any number of behavior algorithms to obtain more complex models.  For example, the Unite into a Behavioral Algorithm is created on the basis of division, merger and construction.  A combination of different behavioral algorithms can sometimes give an unnatural result.  It is recommended to experiment with different types of such algorithms to identify new features. <br><br>  In addition, some search path techniques are intended for use in dynamic environments.  <a href="https://en.wikipedia.org/wiki/D*">Algorithm D *</a> is close to A *, but can update the path based on new observations (i.e., added and removed obstacles).  Algorithm <a href="http://idm-lab.org/bib/abstracts/papers/aaai02b.pdf">D * Lite</a> works the same as D *, and is simpler to implement.  Path finding can be used with hover: you can set waypoints and then use hover to bypass them. <br><br>  The choice of actions is not discussed in this article, but is widely studied in game theory.  Game theory explores the mathematical basis of strategy and decision making.  Game theory is applied in many areas, including economics, political science and psychology.  For autonomous agents, game theory can control how and when decisions are made.  Game Theory 101: A Complete Reference Book by William Spaniel is a great starting resource with a <a href="https://www.youtube.com/watch%3Fv%3DNSVmOC_5zrE">series of videos on YouTube</a> . <br><br><h2>  <font color="#0071c5">Conclusion</font> </h2><br>  There is a whole arsenal of tools for setting up the movement, behavior and actions of agents.  Autonomous navigation is best suited for dynamic environments like the one created by the Intel RealSense camera in augmented reality applications.  Even simple patterns of movement and guidance can form complex behaviors without prior knowledge of the environment.  The abundance of available models and algorithms provides the flexibility to implement stand-alone solutions for any application. </div><p>Source: <a href="https://habr.com/ru/post/282141/">https://habr.com/ru/post/282141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282127/index.html">Striving for nil: how the prices for mobile communications have changed in a quarter of a century</a></li>
<li><a href="../282129/index.html">Work with geofences (geofences) in Android. Update</a></li>
<li><a href="../282131/index.html">Introduction to Shader Programming: Part 3</a></li>
<li><a href="../282133/index.html">SpyEye authors were given 24 years for two</a></li>
<li><a href="../282139/index.html">IT Center at the DUMP-2016 Conference</a></li>
<li><a href="../282143/index.html">How Google in London trained on Android N</a></li>
<li><a href="../282145/index.html">How to hope for the Ministry of Emergency Situations and disappear in the forests of Karelia - bad advice from an experienced tourist</a></li>
<li><a href="../282149/index.html">Proper error handling in javascript</a></li>
<li><a href="../282151/index.html">DevConf-2016: waiting for applications for reports</a></li>
<li><a href="../282153/index.html">INTEL represents the release of the source code for the Arduino 101 firmware</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>