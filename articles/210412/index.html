<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The legacy of Konrad Zuse: Architecture Z1 and Z3 [Translation]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Original: Ra√∫l Rojas - ‚ÄúKonrad Zuse's Legacy: The Architecture of the Z1 and Z3‚Äù, IEEE Annals of the History of Computing, Vol. 19, No. 2, 1997 

 Thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The legacy of Konrad Zuse: Architecture Z1 and Z3 [Translation]</h1><div class="post__text post__text-html js-mediator-article">  Original: Ra√∫l Rojas - ‚ÄúKonrad Zuse's Legacy: The Architecture of the Z1 and Z3‚Äù, IEEE Annals of the History of Computing, Vol.  19, No.  2, 1997 <br><br>  <i>This article presents a detailed description of the architecture of computers Z1 and Z3, developed by Konrad Zuse in Berlin from 1936 to 1941.</i>  <i>The information was mainly obtained from a detailed study of the patent filed by Zuse in 1941. A deeper assessment was obtained from a software simulation of computer logic.</i>  <i>Z1 was based solely on mechanical components, while Z3 used electromechanical relays, but both machines had a common logical structure and software model.</i>  <i>Z1 and Z3 possessed such properties of modern computers as: separation of memory and processor, the ability to operate with floating-point numbers, calculate 4 basic arithmetic operations and a square root.</i>  <i>Programs were stored on punched tape and read sequentially.</i>  <i>In the next article I will look at the architecture of the Z1 and Z3 in a historical perspective, and make a comparison with computers built in other countries.</i> <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  <a href="http://ru.wikipedia.org/wiki/%25D6%25F3%25E7%25E5,_%25CA%25EE%25ED%25F0%25E0%25E4">Konrad Zuse is</a> recognized in Germany as the father of a computer, and his <a href="http://ru.wikipedia.org/wiki/Z1_%2528%25D0%25B2%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25B0%25D1%2588%25D0%25B8%25D0%25BD%25D0%25B0%2529">Z1</a> , a programmable machine built from 1936 to 1938, is considered the first computer in the world.  In other countries, this value is attached to other scientists, and there are long and sharp disputes over the question of who is the true inventor of the computer.  Sometimes disputes turned into a deep and detailed description of the technological features of specific machines.  For example, ENIAC (Electronic Numerical Integrator and Computer) is considered to be the ‚ÄúFirst large-scale, fully electronic computing machine in the world.‚Äù  <a href="http://ru.wikipedia.org/wiki/%25DD%25CD%25C8%25C0%25CA">ENIAC</a> was built at <a href="http://en.wikipedia.org/wiki/Moore_School_of_Electrical_Engineering">the</a> Moore School of Electrical Engineering at the University of Pennsylvania (Moore School of Electrical Engineering of the University of Pennsylvania) from 1943 to 1945.  He solved the first task in December 1945 and was introduced in February 1946. <a href="http://en.wikipedia.org/wiki/Harvard_Mark_I">Mark I</a> , built by <a href="http://ru.wikipedia.org/wiki/%25DD%25E9%25EA%25E5%25ED,_%25C3%25EE%25E2%25E0%25F0%25E4">Howard Aiken</a> at Harvard University from 1939 to 1944, is considered another candidate for the title of the first computer.  Mark I was an electromechanical machine, i.e.  built not on purely mechanical elements, as in earlier computing devices, and not on electronics already available at that time.  John Atanasov‚Äôs car (later called <a href="http://ru.wikipedia.org/wiki/%25CA%25EE%25EC%25EF%25FC%25FE%25F2%25E5%25F0_%25C0%25F2%25E0%25ED%25E0%25F1%25EE%25E2%25E0_%2597_%25C1%25E5%25F0%25F0%25E8">ABC</a> ) from <a href="http://en.wikipedia.org/wiki/Iowa_State_University">Iowa State College</a> , under construction from 1939 to 1944, used vacuum tubes, but the machine had limitations on vector addition and subtraction, and the current structure was not suitable for universal computing.  Z1 is the exact opposite of these machines, more flexible, built to execute long and modifiable sequences of instructions read from punched tape.  Machines Z3 and Z4 were not electronic and had smaller dimensions.  The Z3 was built and successfully tested earlier than the Mark I, and therefore was named the first programmable computing machine in the world.  Of course, long-standing discussions will not be completed on this article, but I want to show how advanced Zuse's machines were in terms of modern computer architecture and in comparison with the architecture of that time. <br><br>  Zuse, a student at the Berlin Polytechnic, began working on a computer in the 1930s.  He realized that he could build an automaton capable of performing a sequence of mathematical operations that are required for constructing mathematical tables.  Coming from civil engineering, he had experience in the field of electronics, but was not familiar with the technologies used in conventional mechanical calculators.  However, this lack of knowledge gave him an advantage, because  He was able to rethink all the problems of machine arithmetic and find new original solutions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Zuse decided to build his first experimental computing machine based on two main ideas: <br><ul><li>  The machine must operate in binary notation. </li><li>  Computed and Control Data must be shared in memory. </li></ul><br><br>  A year earlier, <a href="http://ru.wikipedia.org/wiki/%25CD%25E5%25E9%25EC%25E0%25ED,_%25C4%25E6%25EE%25ED_%25F4%25EE%25ED">John von Neumann</a> explained the advantage of computer architecture with a processor sharing memory.  Zuse came to the same conclusion.  It should be noted that <a href="http://ru.wikipedia.org/wiki/%25C1%25FD%25E1%25E1%25E8%25E4%25E6,_%25D7%25E0%25F0%25EB%25FC%25E7">Charles Babbage</a> came to the same conclusions when designing his Analytical engine in the last century.  In 1936, Zuse completed work on the memory for his car, and called it Speicherwerk (it is Memory Storage) - the term Speicher was used in Germany instead of the anthropomorphic term Memory (eng. Memory), which was introduced by von Neumann, while Babbage used term Store (eng. - Storage).  Memory was a mechanical device, but not the usual type.  Instead of using gears (Babbage used them in the last century), Zuse implemented logical and arithmetic operations on sliding metal slats.  Reiki could move in one of two directions (direct and reverse) and therefore were a binary mechanism.  The Z1 processor was built 5 months after memory construction.  When working with memory, he was extremely unreliable.  The main problem was the accuracy of synchronization, which is required to prevent excessive mechanical stress on moving parts.  It is interesting to note that in the same year, when Zuse finished working on memory, <a href="http://ru.wikipedia.org/wiki/%25D2%25FC%25FE%25F0%25E8%25ED%25E3,_%25C0%25EB%25E0%25ED">Alan Turing</a> wrote his pioneering work On computable numbers (English - On computable numbers), in which he formalized intuitive calculations. <br><br>  The Z1 machine, despite its unreliability, showed that Architectural design was expedient and prompted Zuse to explore other types of technology.  Following the advice of his friend Helmut Schreyer, he considered electromechanical relays.  Zuse built an ‚Äúintermediate‚Äù model (Z2) on a mixed technology (the processor was built on a relay, but the memory remained mechanical).  In 1938, Zuse began developing the Z3, a machine entirely built on a relay, but with a logical structure from Z1.  It was ready for operation in 1941, 4 years before ENIAC. <br><br>  This work involves a detailed review of the architecture of machines Z1 and Z3.  Zuse reconstructed his Z1 car in Berlin in the 80s, and now it is on display at the <a href="http://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25BC%25D0%25B5%25D1%2586%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2582%25D0%25B5%25D1%2585%25D0%25BD%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BC%25D1%2583%25D0%25B7%25D0%25B5%25D0%25B9">Berlin Museum of Transport and Technology</a> .  However, the available information describes the mechanical memory device [12].  Zuse documented Z3 in patent application Z-391 1941, but its analysis is difficult due to non-standard notation and terminology [14].  The book [4] about Z3 is a good source for understanding the historical environment surrounding Zuse's research, but does not describe the Z3 in detail.  Since  Z1 and Z3 are equivalent from a logical and functional point of view, in the future, I will only refer to Z3.  The main architectural difference is that Z1 does not support the square root operation.  The remaining minimal differences are reduced to the difference in the number of bits in the arithmetic operators of the processor (Z1 uses a lower bit of the mantissa in floating-point numbers) and in the number of cycles required for each instruction.  With minimal caveat, taking into account only the architecture, it is possible to consider Z1 and Z3 equivalent machines.  There have been controversies whether the reconstructed Z1 corresponds to the original Z1 destroyed during the Second World War.  Zuse reconstructed the Z1 car based solely on his memories, and it is possible that the reconstructed car has more in common with the Z3 than with the original Z1.  Also, Zuse points out in his memoirs the basic similarities of Z1 and Z3 [15], and confirms this aspect of his work in a private interview. <br><br><h4>  Z1 and Z3 architecture overview </h4><br>  In this section, most of the architectural features are given for Z3.  First, I will provide an overview of the architecture, then move on to the details. <br><h5>  Structural scheme </h5><br>  Z3 worked with floating-point numbers, unlike other early computing machines, such as Mark I, ABC or ENIAC, working with fixed-point numbers.  Zuse developed what he later called a ‚Äúsemi-logarithmic record‚Äù, which corresponds to the modern representation of floating-point numbers. <br><br>  In fig.  Figure 1 shows the main composite blocks of the Z3.  The first feature of the architecture is the separation of the processor and memory.  Z3 includes a binary memory (capable of storing 64 floating point numbers), a binary processor for floating point numbers, a control device, and input / output devices.  The memory and the arithmetic unit are connected by a data bus transferring the exponent and the mantissa of the floating point number.  The control unit contains firmware for each instruction.  Control signals go to the processor, memory, and I / O device to synchronize all blocks.  The punched tape reader provides an operation code for each instruction, as well as an address for accessing the memory.  An I / O device is connected to the processor by a data bus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/521/344/7b8/5213447b8bcdaac46a9dae5cf0760d7b.png" width="400" alt="image"><br><br><h5>  Floating point representation </h5><br>  In fig.  2 shows the representation used in Z3.  The first digit is used to store the mark, the next 7 digits store the exponent, and the last 14 digits store the mantissa.  The digits of the exponent are called Part A and are denoted as a <sub>6</sub> , ..., a <sub>0</sub> .  The bits of the mantissa are called Part B and are denoted as b <sub>0</sub> , b <sub>-1</sub> , ..., b <sub>-14</sub> .  The exponent is encoded in an additional code and may contain values ‚Äã‚Äãin the range from -64 to 64. The mantissa is stored in a normalized form, in which the first decimal place (b <sub>0</sub> ) must always be set to one [5].  This bit is not stored in memory (therefore, it is not shown in Figure 2), so the effective range of mantissa values ‚Äã‚Äãin memory is 15 bits.  However, there is a problem with the number 0, since  normalized mantissa can not express it.  In Z3, there is an agreement according to which, any mantissa with the exponent -64 is considered to be 0. Any number with an exponent of 63 is considered to be infinitely large.  Operations on 0 or infinitely large cause exceptions, and special hardware controllers set exceptions flags in the processor (discussed below). <br>  Given this convention, the minimum number in memory Z3 is 2 <sup>-63</sup> = 1.08x10 <sup>-19</sup> , and the maximum 1.999x2 <sup>62</sup> = 9.2x10 <sup>18</sup> .  Arguments for calculation can be entered as decimal numbers from the keyboard (four-digit).  The exponent of the decimal representation is entered by pressing the corresponding button in the row of buttons marked -8, -7, ..., 7.8.  The original Z3 allowed you to enter only numbers in the range from 1x10 <sup>-8</sup> to 9,999x10 <sup>8</sup> .  The reconstructed Z3 from the German Museum in Munich has additional buttons for large exhibitors.  With this improvement, it became possible to enter the full numerical range of the machine from the keyboard.  Let's say a little about the conclusion.  Z3 did not print the results of the software procedures.  A single number was displayed on the array of lamps representing numbers from 0 to 9. The maximum number that Z3 was capable of displaying was 19,999, and the minimum number was 00001. The maximum displayed exponent was +8, and the minimum was -8. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d94/b61/150/d94b6115045879b17a4201421db5380a.png" width="400"><br><br><h5>  Instruction set </h5><br>  Z3 program is stored on punched tape.  One instruction uses 8 bits from each row on the tape.  The Z3 instruction set consists of 9 instructions presented in Table 1. They are divided into 3 groups: input / output, memory, and arithmetic operators.  The operation code has a variable length from 2 to 4 bits.  Memory operators encode the address of the word in the lower 6 bits, which are capable of addressing 64 words, as mentioned earlier. <br><br>  Punched tape instructions can be placed in any order.  The Lu and Ld instructions (Reading from the keyboard and Displaying on the display) stop the machine so that the operator has enough time to enter the number and record the result. <br><br>  Z3 has no conditional jump instructions.  The cycles are implemented by simply fastening the two ends of the punched tape, but this does not allow for the realization of conditional sequences of instructions.  Consequently, Z3 is not a universal computer in Turing's description. <br><br>  Table 1. Many instructions and their Z3 machine codes <br><table><tbody><tr><td>  <b>Type of</b> </td><td>  <b>Instruction</b> </td><td>  <b>Description</b> </td><td>  <b>KOP</b> </td></tr><tr><td rowspan="2">  In / in </td><td>  Lu </td><td>  Keyboard input </td><td>  01 110000 </td></tr><tr><td>  Ld </td><td>  Output result </td><td>  01 111000 </td></tr><tr><td rowspan="2">  Memory </td><td>  Pr z </td><td>  Download from z </td><td>  11 z <sub>6</sub> z <sub>5</sub> z <sub>4</sub> z <sub>3</sub> z <sub>2</sub> z <sub>1</sub> </td></tr><tr><td>  Ps z </td><td>  Write to z </td><td>  10 z <sub>6</sub> z <sub>5</sub> z <sub>4</sub> z <sub>3</sub> z <sub>2</sub> z <sub>1</sub> </td></tr><tr><td rowspan="5">  Arithmetic </td><td>  Lm </td><td>  Multiplication </td><td>  01 001000 </td></tr><tr><td>  Li </td><td>  Division </td><td>  01 010000 </td></tr><tr><td>  Lw </td><td>  Square root </td><td>  01 011000 </td></tr><tr><td>  Ls <sub>1</sub> </td><td>  Addition </td><td>  01 100,000 </td></tr><tr><td>  Ls <sub>2</sub> </td><td>  Subtraction </td><td>  01 101000 </td></tr></tbody></table><br><br><h5>  Number of cycles </h5><br>  Z3 is a synchronous machine.  Each cycle is divided into 5 stages, called I, II, III, IV, and V. At stage I, the instruction is decoded from a punched tape.  The main arithmetic operations are the addition and subtraction of exponents and mantissas.  Operations can be performed in the first three stages of each cycle.  Stages IV and V are used to prepare arguments for the following operations or output the result. <br><br>  Table 2. The number of cycles required to execute instructions. <br><table><tbody><tr><td>  <b>Operation</b> </td><td>  <b>Number of cycles</b> </td></tr><tr><td>  Multiplication </td><td>  sixteen </td></tr><tr><td>  Division </td><td>  18 </td></tr><tr><td>  Square root </td><td>  20 </td></tr><tr><td>  Addition </td><td>  3 </td></tr><tr><td>  Subtraction </td><td>  4 or 5, depending on the result </td></tr><tr><td>  Keyboard input </td><td>  from 9 to 41, depends on the exponent </td></tr><tr><td>  Output </td><td>  from 9 to 41, depends on the exponent </td></tr><tr><td>  Load from memory </td><td>  one </td></tr><tr><td>  Memory entry </td><td>  0 or 1 </td></tr></tbody></table><br><br>  According to Zuse, multiplication is done in 3 seconds.  Given that the multiplication operation requires 16 cycles, it can be estimated that the operating frequency of Z3 is 3/16 = 5.33 Hz.  Curiously, the coincidence that the Z3 simulator, which my students implemented on a personal computer, also requires about 3 seconds to multiply. <br><br>  The number of cycles required for the Keyboard and Display instructions is variable, because it depends on the exponent of the arguments.  Since  the input must convert the decimal representation to binary, the number of multiplications by 10 or 0.1 is determined by the value of the decimal exponent (consider below). <br><br>  Addition and subtraction require more than one cycle because in the case of floating-point numbers, we need to bring the exponents of both arguments to the same value.  This requires additional comparisons and shifts. <br><br>  A number can be written to the memory in 0 cycles in the case when the result of the last arithmetic operation can be redirected to the desired memory address.  In this case, the cycle required for the write instruction coincides with the last cycle of the arithmetic operation. <br><br><h5>  Software model </h5><br>  It is very important to describe the machine Z3 from the point of view of the programmer.  From a software point of view, Z3 consists of 64 words in memory, capable of being loaded into 2 floating point registers, which I will call R1 and R2 for simplicity.  Two registers hold arguments for an arithmetic operation.  The programmer can write any sequence of instructions, but must remember about the state of the registers. <br><br>  It is important to remember the sequence: The first load operation in the program (Pr z) loads the contents of the address z into R1.  All subsequent load operations load the word from memory into R2.  The Keyboard Input instruction loads a number into R1 and CLEARS R2, which is used as a temporary value when converting a decimal input to a binary representation. <br><br>  Arithmetic operations do not contain arguments in the opcode.  The following arguments are always used: <br><table><tbody><tr><td>  Multiplication </td><td>  R1: = R1 * R2 </td></tr><tr><td>  Division </td><td>  R1: = R1 / R2 </td></tr><tr><td>  Addition </td><td>  R1: = R1 + R2 </td></tr><tr><td>  Subtraction </td><td>  R1: = R1 - R2 </td></tr><tr><td>  Square root </td><td>  R1: = sqrt (R1) </td></tr></tbody></table><br><br>  R2 is reset to 0 after arithmetic instructions that write the result to R1.  Subsequent load operations from memory send the value to R2.  The instructions for writing to memory and displaying always take the value from R1, which contains the result of the last arithmetic operation.  After the save operation or output, R1 is reset to 0 (when the relay is turned off, which will then be ready to accept the new value).  The next load from memory occurs in R1. <br><br>  We give an example for a better understanding of the software model Z3.  Suppose we need to calculate a polynomial <a href="http://ru.wikipedia.org/wiki/%25D1%25F5%25E5%25EC%25E0_%25C3%25EE%25F0%25ED%25E5%25F0%25E0">by the Horner method</a> . <br><br>  x (a <sub>2</sub> + x (a <sub>3</sub> + xa <sub>4</sub> )) + x <sub>5</sub> <br><br>  Further, we assume that the arguments a <sub>4</sub> , a <sub>3</sub> , a <sub>2</sub> and a <sub>1</sub> are stored in the fourth, third, second and first memory cells, respectively.  The value of z is stored in the fifth.  The program is shown below: <br><br><pre> Pr 4 download a4 to R1 
 Pr 5 download x to R2 
 Lm multiply R1 and R2, the result is in R1 
 Pr 3 load a3 into R2 
 Lsl add R1 and R2, result in R1 
 Pr 5 download x to R2 
 Lm multiply R1 and R2, the result is in R1 
 Pr 2 load a2 into R2 
 Lsl add R1 and R2, result in R1 
 Pr 5 download x to R2 
 Lm multiply R1 and R2, the result is in R1 
 Pr 1 download a1 to R2 
 Ls1 add R1 and R2, result in R1 
 Ld display the result
</pre><br><br>  After the last instruction is executed, the processor is reset to its original state. <br>  state. <br><br><h4>  Z3 block diagram </h4><br>  In this section, I will look at the structure of the Z3 and describe the main building blocks in <br>  details.  It is important to show how synchronization between <br>  components. <br><h5>  CPU </h5><br>  In fig.  3 shows a simplified diagram of an arithmetic unit.  It consists of two parts: the left handles operations on the exponent of a floating point number, and the right handles operations on the mantissa.  The registers Af and Bf store the exponent and the mantissa of what is programmatically called R1.  I will represent R1 as a pair of registers &lt;Af, Bf&gt;.  A pair of registers &lt;Ab, Bb&gt; stores the exponent and the mantissa R2.  The pair &lt;Aa, Ba&gt; stores the exponent and mantissa of the third temporary floating point register, invisible to the programmer.  Two Arithmetic Logic Devices (ALU) A and B are used to add and subtract exponents and mantis, respectively.  The exponent and the mantissa of the result are placed in Ae and Be respectively.  The pair &lt;Ae, Be&gt; is treated as an internal register, inaccessible to the programmer.  In Part B, the multiplexer allows you to select the result of the operation between Ba and the output of the ALU.  The multiplexer is controlled by the switch Bt (if Bt = 0, then Be gets the value of Ba). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c53/401/32b/c5340132b4f1eab694e2561cd2bcb4b0.png" width="400"><br><br>  The small blocks designated Ea, Eb, Ec, Ed, Ef, Fa, Fb, Fc, Fd, and Ff are relay blocks (hereinafter RB), opening and closing tires.  For example, to transfer the value of the contents of register Af to register Aa, you need to set RB Ea to one.  As we can see from fig.  3, the contents of Af can be transferred to Aa or Ab, and the contents of Ae can be transferred to Aa, Ab or Af, depending on the state of the RB.  Part B of the arithmetic unit is arranged similarly, but with the addition of a multiplexer controlled by a switch Bt and shifters between Ba and Ba, and between Bf and Bb.  The first shifter can shift the mantissa within 2 digits to the left or 1 digit to the right.  It divides Bf by 4 or multiplying by 2. The second shifter can shift Af by one of 16 positions to the left or one of 15 positions to the right.  These shifting devices are required to add and subtract floating point numbers.  Multiplication and division by powers of two can be performed with the subsequent arithmetic operation without the cost of additional time. <br><br>  Table 3. Digit registers <br><table><tbody><tr><td>  Af </td><td>  7 digits </td><td>  Bf </td><td>  17 ranks </td></tr><tr><td>  Aa </td><td>  eight </td><td>  Ba </td><td>  nineteen </td></tr><tr><td>  Ab </td><td>  eight </td><td>  Bb </td><td>  18 </td></tr><tr><td>  Ae </td><td>  eight </td><td>  Be </td><td>  18 </td></tr></tbody></table><br><br>  As we can see from the list, Ae has an extra bit to save the result of the addition of exponential arguments.  Part B has 2 additional digits (b <sub>-15</sub> and b <sub>-16</sub> ) and explicit b <sub>0</sub> , not stored in memory.  -15 and -16 digits are entered to increase the accuracy of calculations.  Consequently, the total bit needed to store the result of arithmetic operations in Bf is 17 bits.  The Ba and Bb registers require additional bits (ba2, ba1 and bb1) to store intermediate results of some calculations.  For example, the square root algorithm may require 3 digits to the left of the decimal point. <br><br>  The simplest operation on a data channel is the addition and subtraction of the mantissa and the exponent.  When the As or Bs switches are set to 1, the ALU translates the second argument to an additional code, i.e.  changes its sign (Ab or Bb).  Therefore, if the As switch is set to 1, then the AUL of Part A subtracts, otherwise the addition.  Part B and switch Bs work in a similar way. <br><br>  Suppose there are two numbers with equal exponents that need to be added.  The first exhibitor is stored in Af, and the second in Ab.  Since they are equal, this part of the machine should not perform any operations.  In part B, the mantissa of the first number is stored in Bf, and the mantissa of the second in Bb.  The first stage consists in transferring the number from Bf to Bf, for which it is necessary to set the relay block Fa to 1. Next, the addition occurs.  In order for the result of Ba + Bb to be registered in Be, you must set the Bt switch to 1. RB Ff is currently set to 1, and the result is placed in Bf.  The architecture must provide the correct sequence of actions on the switches to perform the desired operation.  The Z3 does this thanks to a technique that is very similar to firmware. <br><br><h4>  Control device </h4><br>  In fig.  4 shows a detailed diagram of the control device and I / O panels.  The circuit Pa decodes the opcode read from punched tape.  If this is a memory instruction, the Pb circuit sends the lower 6 bits of the opcode to the address bus.  The control device determines the microsequence instructions.  For each operator from the instruction set, there are special schemes. <br><br>  Diagram Z represents the keyboard used to enter decimal numbers.  Only one button in each of the four columns can be pressed.  The exponent is set by pressing one of the buttons marked from -8 to 8 in the K diagram. The display is very similar to the input panel, its lamps illuminate the decimal number received, and its exponent (Q scheme).  Please note that the display shows the fifth digit (it can take values ‚Äã‚Äãonly 0 or 1). <br><br>  After entering a decimal number, it is transmitted via the data bus to the Ba register, and a special sequence of operations begins.  The decimal number entered from the keyboard must be converted to binary representation.  This requires several multiplications, the number of which is determined by the value of the exponent.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For the exponent equal to zero, 9 cycles are spent for the complete conversion, and for the exponent equal to -8, 9 + 4 * 8 = 41 cycles are spent. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e21/0db/922/e210db92258aac301ade3c6eacc92853.png" width="400"><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Z3 micromanagement </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the heart of the Control Device is the microsequence controller. </font><font style="vertical-align: inherit;">Before considering the principle of its operation, we need to consider in detail the algorithms of arithmetic instructions Z3.</font></font> In fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 shows the main idea. Each cycle consists of 5 stages. At stages IV and V, information is entered into the machine. In stages I, II and III, addition / subtraction occurs, in parts A and B. I called this phase of the instruction - ‚Äúexecution‚Äù. A typical instruction selects arguments, executes and records the result. Tsuze was able to reduce the execution time by overlapping the stages of selecting the arguments for the next instruction and recording the result of the current one. As a result, we can assume that the executive cycle consists of two stages (in Fig. 5, the first two cycles are indicated).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The microsequence controller is implemented using a special control wheel. Implemented separate wheels for the multiplication algorithm, division and taking the square root. The movable lever shown in Fig. 6, begins to rotate clockwise as soon as the control device decodes the corresponding instruction. For each cycle, the lever moves one position. The lever conducts electricity and activates the circuitry with which it comes in contact. In the example shown in fig. 6, the movable lever sets the switch Ea to 1 on the first cycle. This leads to the transfer of numbers from the register Af to Aa. On the next cycle, switches Ec and Fc are activated. In this case, the results of the operation in parts A and B are recorded in the registers Aa and Ba, respectively. As we can seeThe use of such control wheels provides a platform for easy modification of microsequences of certain operators. Microprocessor controllers in modern microprocessors are similarly arranged. I did not call this method microprogramming, because in our case the microsequence controller is hardware, but it is obvious that microsequences and microprograms are closely related.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/222/d34/1ff/222d341ffcc5a87637eba813caf40519.png" width="400"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcc/a2c/4cb/dcca2c4cb8d3af3ae137f09f73150b18.png" width="400"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of microsequence controllers allowed Zuse to greatly simplify the machine. </font><font style="vertical-align: inherit;">After the basic schemes were prepared on their basis, the control device was improved until it was possible to achieve an optimal sequence of micro-instructions. </font><font style="vertical-align: inherit;">The engineer, when designing the ‚Äúfirmware‚Äù, must take into account many details, otherwise a short circuit could destroy the machine. </font><font style="vertical-align: inherit;">Mechanical Z1 was more sensitive in this respect than Z3. </font><font style="vertical-align: inherit;">At the end of this stage there was a list of sequences that the programmer should avoid in order to prevent damage to the equipment. </font><font style="vertical-align: inherit;">One of these sequences was negligently launched at the Berlin Museum of Technology and Transport, and resulted in minor damage to the Z1 reconstruction in 1994.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adders </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An important feature of the adder Z3, is the calculation of the sum and difference method, called the </font></font><a href="http://ru.wikipedia.org/wiki/%25D1%25F5%25E5%25EC%25E0_%25F3%25F1%25EA%25EE%25F0%25E5%25ED%25ED%25EE%25E3%25EE_%25EF%25E5%25F0%25E5%25ED%25EE%25F1%25E0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scheme of accelerated transfer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If binary addition is performed directly, the transfer is transferred from each digit one bit further. In the case of a mantissa, 16 cycles are required to transfer the transfer of one bit. Adding to the implementation of Zuse is much faster, where addition and subtraction are carried out during phases I, II and III of one cycle. For subtraction, the second argument is translated into reverse code with the addition of one to the least significant bit (additional code).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the addition of the registers Ba and Bb. I will denote the i-th digit of the register Bb as bbi or Bb [i]. In this notation, all registers will be denoted. The first intermediate result is obtained bitwise Exclusive OR between two registers, i.e. bc </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = ba </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XOR bb </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The second intermediate result is obtained by a bitwise conjunction between two registers, i.e. ba </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AND bb </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The next operation finds digits for which transfer is required. Intermediate result bd </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculated by the scheme shown in Fig. </font><font style="vertical-align: inherit;">7. Please note that if the discharge is set to one, then a current flows through the corresponding transfer line, otherwise the power supply is disconnected (so that a short circuit does not occur). </font><font style="vertical-align: inherit;">The wiring diagram of the switches bc </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., bc </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-16 is</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shown in fig. </font><font style="vertical-align: inherit;">7. If the digit bc </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i is</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> set to one, the corresponding switch is open. </font><font style="vertical-align: inherit;">The final result is be </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = bd </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XOR bc </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This scheme allows you to move the transfer to the last digit much faster. </font><font style="vertical-align: inherit;">In case all switches are active, the transfer moves from the first digit to the last without wasting time.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/22f/9d1/9a4/22f9d19a40eadc8f9df872232ae42bf7.png" width="400"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Numerical Algorithms </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section, I will describe the algorithms above floating-point numbers used in Z3. </font><font style="vertical-align: inherit;">All of them, without exception, are used in ordinary small sequential floating point processors.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Floating point exceptions </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main problem with a floating-point entry is the convention regarding the representation of the number 0. Z3 solves this problem with exceptions (overflow and loss of digits) for tracking the exponent value after arithmetic or load from memory. Special schemes monitor the state of the Ae bus and catch exceptions. Any number with an exponent of -64 is 0: A switch denoted by Nn1 is set to 1 if such a number is stored in a pair of registers &lt;Af, Bf&gt;. If such a number is stored in a pair of registers &lt;Ab, Bb&gt;, the switch Nn2 is set to 1. Therefore, we always know whether one of the arguments of the arithmetic operation is zero. Something similar happens for any number with exponent 63 (infinitely large). In this case, the switches Ni </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or Ni </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are reset to 0 if the corresponding register pairs store such numbers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operations involving ‚Äúexceptional‚Äù numbers (zero and infinity) are performed as usual, but the result is replaced with a special scheme. Consider, for example, multiplication with the first argument equal to zero (Nn </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set to 1). Calculation takes place as usual, but in each cycle a special scheme gives the result -64 from the adder of Part A. It does not matter at all what operations were performed with the mantissa, since the exponent is -64, and therefore the final result is zero. The division by zero is similar. Z3 can detect uncertainties such as 0/0, ‚àû-‚àû, ‚àû / ‚àû, and 0 * ‚àû. In all these cases, the corresponding exception indicator on the output panel lights up and the machine stops. Z3 always calculates the correct result when one of the arguments is zero or infinity, and the second is a finite non-zero number. But this does not apply to Z1. Zuse was thinking about exception handling in Z1, but it remained unrealized. The machine produces an incorrect result in some calculations with zero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The additional circuit looks at the exponent of the result, at the output of the adder of Part A. If the exponent is greater than or equal to 63, an overflow has occurred and the result must be set to infinity. </font><font style="vertical-align: inherit;">If the exponent fell to -64, then a loss of digits occurred and the result should be set to zero. </font><font style="vertical-align: inherit;">To do this, the corresponding switches (Nn </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or Ni </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) are set to 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuse implemented exception handling using a total of 5 relays. </font><font style="vertical-align: inherit;">This feature of the Z3 is one of the most elegant in the whole design. </font><font style="vertical-align: inherit;">Most early microprocessors in the 1970s did not have exception handling and implemented them programmatically. </font><font style="vertical-align: inherit;">Zuse's approach is more advanced, since it frees programmers from having to constantly check the boundaries of numbers before each operation.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Addition and Subtraction </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To add or subtract two floating-point numbers x and y, they must be represented with the same exponent. After that, addition and subtraction is carried out only over the mantissa. If the exponentials are different, the mantissa of a smaller number is shifted to the right by the required number of digits (and the exponent is correspondingly incremented so that the operand retains its value) so that the exponents become equal. Of course, it may happen that a smaller number becomes zero after 17 shifts to the right. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The characters of the operands are compared before deciding on the type of operation being performed. If addition is requested, the addition is performed in the case of the same characters and subtraction in the case of different characters. If subtraction is requested and the characters are the same, then subtraction is performed, and if different, addition is performed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A special scheme establishes the sign of the result based on the signs of the operands and the sign of the intermediate result.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition and subtraction are controlled by a switch chain (and not by the Micro Sequence Control Wheel), since while the maximum number of required steps is not large. Table 4 shows the signals needed to add two numbers. Initially, the arguments of the addition operation are stored in pairs of registers &lt;Af, Bf&gt; and &lt;Ab, Bb&gt;. In the first cycle, the exponents are compared. In the second cycle, the mantissa of the number with the larger exponent is loaded into the Ba register, and the mantissa of the number with the smaller exponent is loaded into the Bb register. The mantissa in register Bb is shifted to the right by a number equal to the absolute value of the exponent difference (the exception handling system takes care of the case when a smaller number becomes zero after the shift). At stages I, II and III of the second cycle, the mantissas are added up and at the end the processor will check whether the result is greater than two. If isthe mantissa is shifted one position to the right, and the exhibitor is incremented. It is important to note that the ‚Äúif (Be&gt; 0)‚Äù check is performed in Part A of the arithmetic unit after Be is calculated in Part B in stages I, II and III of cycle 2.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Table 4. Addition Cycles </font></font><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycle </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stage </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exhibitor </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mantissa </font></font></td></tr><tr><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td></td><td></td></tr><tr><td rowspan="2">  one </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aa: = Af </font></font><br></td><td></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ae: = Aa - Ab </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Be: = 0 + Bb </font></font><br></td></tr><tr><td rowspan="2">  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Ae&gt; = 0) then Ab: = 0, Aa: = Af </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Aa: = 0</font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Ae&gt; = 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Ba: = Bf, Bb: = Be (shifted) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Ba: = Be, Bb: = Bf (shifted)</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Be&gt; = 2) then Ae: = Aa + Ab + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Ae: = Aa + Ab</font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Be: = Ba + Bb </font></font><br></td></tr><tr><td>  3 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Af: = Ae </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (Be&gt; = 2) then Bf: = Be / 2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Bf: = Be</font></font><br></td></tr></tbody></table><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of subtraction, 4 or 5 cycles are required. </font><font style="vertical-align: inherit;">Table 5 presents the signals required for the subtraction operation. </font><font style="vertical-align: inherit;">The first two cycles are completely identical to the first two cycles of the addition algorithm, except that the mantissas are subtracted. </font><font style="vertical-align: inherit;">Cycle 3 is performed only if the mantissa of the result is positive. </font><font style="vertical-align: inherit;">Cycle 4 is very important: the difference between the normalized mantissas can have many zeros in the first bits to the left. </font><font style="vertical-align: inherit;">The result is normalized by shifting Be to the left by the required number of digits (this is done by a shifter between the switch Fd and the register Bb). </font><font style="vertical-align: inherit;">The number of shifts is subtracted from the exponent in Part A of the processor. </font><font style="vertical-align: inherit;">In loop 5, the result is written into a pair of registers &lt;Af, Bf&gt;. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table 5. Cycles subtraction algorithm</font></font><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycle </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stage </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exhibitor </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mantissa </font></font></td></tr><tr><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td></td><td></td></tr><tr><td rowspan="2">  one </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aa: = Af </font></font><br></td><td></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ae: = Aa - Ab </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Be: = 0 + Bb </font></font><br></td></tr><tr><td rowspan="2">  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td> If( Ae &gt;= 0 ) then Ab:=0, Aa:=Af <br> else Aa:=0 <br></td><td> If( Ae &gt;= 0 ) <br> then Ba:=Bf, Bb:=Be(shifted) <br> else Ba:=Be, Bb:=Bf(shifted) <br></td></tr><tr><td> I, II, III </td><td> Ae:=Aa+Ab <br></td><td> Be:=Ba-Bb <br></td></tr><tr><td rowspan="2">  3 </td><td> IV, V </td><td> Af:=Ae, Ab:=0 <br></td><td> Ba:=0, Bb:=Be <br></td></tr><tr><td> I, II, III </td><td> Ae:=Aa+Ab <br></td><td> Be:=Ba-Bb <br></td></tr><tr><td rowspan="2">  four </td><td> IV, V </td><td> Aa:=Ae <br> Ab:=   <br></td><td> Bb:=Be(shifted) <br> (Be   ) <br></td></tr><tr><td> I, II, III </td><td> Ae:=Aa-Ab <br></td><td> Be:=0+Bb <br></td></tr><tr><td>  five </td><td> IV, V </td><td> Af:=Ae <br></td><td> Bf:=Be <br></td></tr></tbody></table><br><br><h5>  Multiplication </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The multiplication algorithm Z3 is similar to one of the methods of decimal multiplication on the fingers. The method is based on repeated additions of a multiplier with individual digits of a multiplicand. At the beginning of the algorithm, the first operand is stored in a pair of registers &lt;Af, Bf&gt;, and the second operand is stored in a pair of registers &lt;Ab, Bb&gt;. The intermediate pair of registers &lt;Aa, Ba&gt; is reset to 0. Table 6 shows the micro-sequence executed by the Micro-Sequence Control Wheel to perform multiplication. The algorithm requires 16 cycles. Only bits from -14 to 0 are involved in multiplication. Exponents are added in the first cycle, and the result of the addition is cyclically stored in Part A of the Arithmetic unit. Mantissas are processed in Part B. The Ba register stores the intermediate result of the calculations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main multiplication cycle is as follows: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ba:= Be / 2</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Be: = Ba + Bb * (i-th bit of Bf) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For i = -14, .., 0. </font><font style="vertical-align: inherit;">The intermediate result in Be shifts one digit to the right to execute the expression Ba: = Be / 2. This operation is performed on a shifter connected to the Fc switch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of the mantissa multiplication is the number 1 &lt;= r &lt;4 (for operands within the specified limits). </font><font style="vertical-align: inherit;">On the last cycle, the result is checked for the condition r&gt; = 2. If the condition is satisfied, the result is shifted by one digit to the right, and the exponent is incriminated. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table 6. Multiplication Algorithm Cycles</font></font><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycle </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stage </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exhibitor </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mantissa </font></font></td></tr><tr><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td></td><td></td></tr><tr><td rowspan="2">  one </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aa: = Af </font></font><br></td><td></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ae: = Aa + Ab </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Bf [-14] = 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Be: = Ba + Bb </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Be: = Ba</font></font><br></td></tr><tr><td rowspan="2">  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aa: = Ae, Af: = 0, Ab: = 0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ba: = Be / 2 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ae: = Aa + Ab </font></font><br></td><td> If( Bf[-13]=1 ) <br> then Be:=Ba+Bb <br> else Be:=Ba <br></td></tr><tr><td rowspan="2">  3 </td><td> IV, V </td><td> Aa:=Ae <br></td><td> Ba:=Be/2 <br></td></tr><tr><td> I, II, III </td><td> Ae:=Aa+Ab <br></td><td> If( Bf[-12]=1 ) <br> then Be:=Ba+Bb <br> else Be:=Ba <br></td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td rowspan="2">  i </td><td> IV, V </td><td> Ae := Aa + Ab <br></td><td> Ba:=Be/2 <br></td></tr><tr><td> I, II, III </td><td> Aa:=Ae <br></td><td> If( Bf[i-15]=1 ) <br> then Be:=Ba+Bb <br> else Be:=Ba <br></td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td rowspan="2">  15 </td><td> IV, V </td><td> Af:=Ae <br></td><td> Ba:=Be/2 <br></td></tr><tr><td> I, II, III </td><td> if(Be&gt;=2) then Ae:=Aa+1 <br></td><td> If( Bf[0]=1 ) <br> then Be:=Ba+Bb <br> else Be:=Ba <br></td></tr><tr><td>  sixteen </td><td> IV, V </td><td> Af:=Ae <br></td><td> If( Be &gt;= 2 ) <br> then Bf:=Be/2 <br> else Bf:=Be <br> Bb:=0 <br></td></tr></tbody></table><br><br><h5>  Division </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The division algorithm is very similar to the multiplication algorithm, with the exception that instead of cyclic addition, cyclic subtraction is used. At the beginning of the algorithm, the dividend is stored in a pair of registers &lt;Af, Bf&gt;, and the divisor in a pair of registers &lt;Ab, Bb&gt;. The intermediate pair of registers &lt;Aa, Ba&gt; is reset to 0. Table 7 shows the micro-sequence performed by the Micro-Sequence Control Wheel. The algorithm requires 18 cycles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The basic idea of ‚Äã‚Äãthe algorithm is very simple. The result exponent is obtained by subtracting the exponent of the dividend and the divisor. Now about mantissas: Let us need to calculate x / y for mantisses x and y.</font></font> Since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we deal with normalized numbers, then the first digit of the result is equal to one if x&gt; = y, and zero if x &lt;y. In the first case, we assign the result 1 to the first digit and calculate the remainder, which is x - y. The remainder is recursively divided by y. To do this, it shifts one digit to the left and the new effective bit is stored in the Bf register at position -1 (thus compensating for the effect of the shift). If the resulting bit is zero, then the remainder is simply x and the recursive division continues as in the first case. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main division cycle has the following form: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ba: = 2 √ó Be </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (Ba ‚Äì Bb&gt; 0) then Be: = Ba ‚Äì Bb, Bf [i]: = 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Be: = Ba </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bf [i]: = 0</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For i = 0, .., - 14. </font><font style="vertical-align: inherit;">The intermediate result in Be is shifted one digit to the left to execute the expression Ba: = 2 x Be. </font><font style="vertical-align: inherit;">This operation is performed in the shifter connected to the switch Fc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of mantissa division is the number 1/2 &lt;r &lt;2. This condition is checked in cycles 17 and 18. If r &lt;1, ‚Äã‚Äãthen the unit is subtracted from the exponent and the result is shifted one digit to the left to get the normalized number. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table 7. Multiplication Algorithm Cycles</font></font><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycle </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stage </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exhibitor </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mantissa </font></font></td></tr><tr><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td></td><td></td></tr><tr><td rowspan="2">  one </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aa: = Af </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ba: = Bf </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ae: = Aa - Ab </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Ba-Bb&gt; = 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Be: = Ba-Bb; </font><font style="vertical-align: inherit;">bt: = 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Be: = Ba; </font><font style="vertical-align: inherit;">bt: = 0</font></font><br></td></tr><tr><td rowspan="2">  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aa: = Ae, Ab: = 0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bf: = 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (bt = 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Bf [0]: = 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ba: = 2 x Be</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ae: = Aa + Ab </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Ba-Bb&gt; = 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Be: = Ba-Bb; </font><font style="vertical-align: inherit;">bt: = 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Be: = Ba; </font><font style="vertical-align: inherit;">bt: = 0</font></font><br></td></tr><tr><td rowspan="2">  3 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aa: = Ae </font></font><br></td><td> if( bt = 1 ) <br> then Bf[1] := 1 <br> Ba:=2 x Be <br></td></tr><tr><td> I, II, III </td><td> Ae:=Aa+Ab <br></td><td> If( Ba-Bb &gt;= 0 ) <br> then Be:=Ba-Bb; bt:=1 <br> else Be:=Ba; bt:=0 <br></td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td rowspan="2">  i </td><td> IV, V </td><td> Aa:=Ae <br></td><td> if( bt = 1 ) <br> then Bf[2-i] := 1 <br> Ba:=2 x Be <br></td></tr><tr><td> I, II, III </td><td> Ae:=Aa+Ab <br></td><td> If( Ba-Bb &gt;= 0 ) <br> then Be:=Ba-Bb; bt:=1 <br> else Be:=Ba; bt:=0 <br></td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td rowspan="2">  sixteen </td><td> IV, V </td><td> Af:=Ae <br></td><td> if( bt = 1 ) <br> then Bf[-14] := 1 <br> Ba:=2 x Be <br></td></tr><tr><td> I, II, III </td><td> Ae:=Aa+Ab <br></td><td> If( Ba-Bb &gt;= 0 ) <br> then Be:=Ba-Bb; bt:=1 <br> else Be:=Ba; bt:=0 <br></td></tr><tr><td rowspan="2">  17 </td><td> IV, V </td><td> If ( Bf[0] = 0 ) <br> then Ab := -1 <br></td><td> Ba:=Bf, Bb:=0 <br></td></tr><tr><td> I, II, III </td><td> Ae:=Aa+Ab <br></td><td> Be:=Ba+Bb <br></td></tr><tr><td>  18 </td><td> IV, V </td><td> Af:=Ae <br></td><td> If( Bf[0] = 0 ) <br> then Bf:=2xBe <br> else Bf:=Be <br></td></tr></tbody></table><br><br><h5>    </h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The square root extraction algorithm is the main highlight of the Z3. Table 8 presents the microsequence, consisting of 20 cycles, necessary to calculate the square root. Initially, the operation argument is stored in a pair of registers &lt;Af, Bf&gt;. The pair of registers &lt;Aa, Ba&gt; is reset to 0. The algorithm calculates the square root of a number with an even exponent. If the exponent of a number is not even, then the mantissa is shifted 1 digit to the left and the exponent is decremented. The total exponent (calculated in cycle 19) is equal to half the original exponent.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main idea of ‚Äã‚Äãthis classic algorithm is to reduce the square root operation to the division operation. To extract the square root of x, we need a series of Q such that x / Q = Q. The final Q is obtained by sequentially setting the i-th digit to 1, followed by checking the condition x&gt; Q </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If the condition has ceased to be fulfilled, then the i-th digit should be reset to 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let we have already calculated the result from zero to -i + 1 digit. Denote by Q-i + 1 the mantissa: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = Bf [0] * 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + Bf [-1] * 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + ... + Bf [-i + 1] * 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sup> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next discharge -i is set to q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which must preserve the condition: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x&gt; = Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= (Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This condition is true if: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x - Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = (x - Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1 </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (2 Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )&gt; = 0 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Define t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using the expression: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = x Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = (x - Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1 </font></font></sub> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- i</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (2 Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> q</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be written as: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (2 Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in which we use the recursive definition: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = (x - Q </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></sup> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplifying the previous expression, we get: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 2 t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (2 Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i is</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> positive for q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1, then we set the digit -i of the final result to 1, i.e. Bf [-i]: = 1. If t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i is</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> negative, then we set Bf [-i]: = 0. Recursive calculations start with t0 = x. Q </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i + 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at each step represents a partial result stored in Bf. -I pre-discharge is set to 1 and the sign verified t </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-i</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The basic cycle of the square root extraction algorithm for the discharge -i has the following form: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ba: = 2 x Be </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bb: = 2 x Bf </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bb [-i]: = 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (Ba - Bb&gt; = 0) then Be: = Ba - Bb , Bf [-i]: = 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Be: = Ba, Bf [-i]: = 0</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To calculate the square root, all bits of the Bf register are used. </font><font style="vertical-align: inherit;">If the original number is in the specified range, the result is also in the specified range. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table 8. Cycles of square root extraction algorithm</font></font><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycle </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stage </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exhibitor </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mantissa </font></font></td></tr><tr><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td></td><td></td></tr><tr><td rowspan="2">  one </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Af [0] = 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Ba: = 2 * Bf </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Ba: = Bf </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bb [0]: = 1</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Ba-Bb&gt; = 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Be: = Ba-Bb, bt: = 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Be: = Ba, bt: = 0</font></font><br></td></tr><tr><td rowspan="2">  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bf: = 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (bt = 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Bb [0]: = 1, Ba: = 2 * Be </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bb: = 2 * Bf, Bb [-1]: = 1</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Ba-Bb&gt; = 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Be: = Ba-Bb, bt: = 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Be: = Ba, bt: = 0</font></font><br></td></tr><tr><td rowspan="2">  3 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (bt = 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Bb [-1]: = 1, Ba: = 2 * Be </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bb: = 2 * Bf, Bb [-2]: = 1</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Ba-Bb&gt; = 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Be: = Ba-Bb, bt: = 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Be: = Ba, bt: = 0</font></font><br></td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td rowspan="2">  i </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if (bt = 1) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Bb [2-i]: = 1, Ba: = 2 * Be </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bb: = 2 * Bf, Bb [1-i]: = 1</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I, II, III </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If (Ba-Bb&gt; = 0) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Be: = Ba-Bb, bt: = 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else Be: = Ba, bt: = 0</font></font><br></td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td rowspan="2">  18 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IV, V </font></font></td><td></td><td> if(bt=1) <br> then Bb[-16]:=1, Ba:=2*Be <br> Bb:=2*Bf <br></td></tr><tr><td> I, II, III </td><td></td><td> If( Ba-Bb &gt;= 0 ) <br> then Be:=Ba-Bb, bt:=1 <br> else Be:=Ba, bt:=0 <br></td></tr><tr><td rowspan="2">  nineteen </td><td> IV, V </td><td> Aa:=Af / 2 <br></td><td> Ba:=Bf, Bb:=0 <br></td></tr><tr><td> I, II, III </td><td> Ae:=Aa+0 <br></td><td> Be:=Ba+Bb <br></td></tr><tr><td>  20 </td><td> IV, V </td><td> Af:=Ae <br></td><td> Bf:=Be <br></td></tr></tbody></table><br><br><h4>        </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The two most complex instructions Z3 c input and output in the decimal number system. Decimal numbers of 4 digits are entered through the keyboard and converted into a binary representation. This is done by reading each digit sequentially, converting it into a binary representation and storing the Ba [-10], Ba [-11], Ba [-12] and Ba [-13] Ba registers into bits. The number in the register is multiplied by 10 and the procedure is repeated with the remaining digits. After 4 iterations, the decimal input is completely converted into a binary representation (the binary representation exponent is formed indirectly through shifts when multiplied by 10). The most difficult part is handling exponents. If the exponent e is positive, the mantissa is multiplied e times by 10. If negative, then | e | times by 0.1. Multiplication by 10 is relatively simple:the mantissa in Be can be shifted 1 digit to the left and then saved in Ba (ie, Ba: = 2 x Be). At the same time, Be can be shifted 3 bits to the left and then saved in Bb (ie, Bb: = 8 x Be). Adding Ba and Bb gives the desired result: multiplying a number from Be by 10. The process takes 4 cycles for each multiplication, for a total of 32 cycles for the decimal exponent +8. Since read operations require at least nine cycles, this means that the decimal number with the exponent +8 is read in 41 cycles.Since read operations require at least nine cycles, this means that the decimal number with the exponent +8 is read in 41 cycles.Since read operations require at least nine cycles, this means that the decimal number with the exponent +8 is read in 41 cycles.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of a negative exponential, the multiplication by the constant 0.1 is also performed using shifts and addition. This multiplication is a bit more complicated, since the number 0.1 in the binary representation is periodic. The description of the microsequence would lead us too far away from the main topic, so we omit it. (It can be found in the patent application Zuse. [14]).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Display instructions are performed using iterative multiplications or divisions by 10. If the binary exponent in the R1 register is positive, then the number is multiplied by 0.1 as many times as required to make the binary exponent equal to two and while the 4 left digits of the Bf register contain the number from 0 to 9 (0000 and 1001). </font><font style="vertical-align: inherit;">This is a decimal number that can be displayed in the next column of the output panel. </font><font style="vertical-align: inherit;">The number is subtracted from the mantissa in Bf and the process continues with the next digit. </font><font style="vertical-align: inherit;">If the binary exponent in R1 is negative, then the process is similar, except that the multiplication by 10 is performed.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Z3 common architecture </font></font></h4><br><br>  Now consider the detailed diagram of Z3, shown in Fig.  8. Control devices and I / O panels have been previously discussed.  Note that the 4 decimal digits of the input keyboard are moved to the Ba register through the Za, Zb, Zc, and Zd switch blocks, which are activated one after the other. <br><br>  The switch blocks Eg and Ei are used to load some of the constants used in the exponent registers (+13 and -4, which are used to convert the number system).  The shifter Ee between the register Af and the register Aa is used in the square root algorithm.  The exponent of the result (Aa) becomes equal to half the exponent of the original number (Af). <br><br>  Ah1 is a two-state switch.  When it is at zero, a pair of registers &lt;Af, Bf&gt; is available for loading operands.  This switch is reset to zero by the control line ai.  The control lines al, aj, bl and bj are used to clear the register Af, Ab, Bf and Bb if necessary. <br><br>  The block called "zero, infinity" under Ae is an exception handling scheme.  They continuously monitor the data bus (the results of operations and data from memory) and, if necessary, set the appropriate exception flags.  The shifter under Be is used to shift the mantissa one rank to the right.  This is necessary for normalization, in cases when Be&gt; = 2. <br><br>  The switches Fp and Fq control the amount and direction of the shift in the shifter under the switch blocks Fc and Fa.  The switches Fh, Fi, Fk, Fl and Fm perform a similar function on another shifter.  These 5 digits represent a number from -16 to 15, which corresponds to the range of the second shifter.  After the shift, the number represented by the switches Fh through Fm is moved through the switch block Bn to the register Ab in accordance with the algorithm for changing the exponent of the result.  If the number is shifted 10 bits to the left, then +10 is subtracted from the exponent of the result.  Such large shifts are needed mainly after calculations. <br>  Take another look at the Z3 machine diagram.  Everything in this car looks like a modern floating point microprocessor.  It is amazing how Zuse could find such a good architectural solution at the very dawn of computers.  The Z3 processor includes a total of 600 relays;  the memory goes three times more.  In order to optimize the structure without the ability to change the hardware, Zuse was forced to rethink the logical structure of the machine all the time.  He did not have the luxury of the unlimited funding allocated by the US Department of Defense to develop ENIAC or IBM at Mark I. He was alone.  Despite the fact that it gave him an advantage on the conceptual side, it also brought its drawbacks, given the low impact the Z1 and Z3 machines had on the emerging computer industry in the United States after World War II.  [13] <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c28/d06/a9f/c28d06a9f06470cffa7129f51ff1f588.png"><br><br><h4>  Computer invention </h4><br>  The main disadvantage of Z3 is the complete absence of conditional transitions in a variety of instructions.  When a program is stored on a punched tape, a possible way to solve this problem is to introduce several tapes and a mechanism to switch between tapes (as was done in Harvard Mark I).  Another way is to use a software counter so that the punched tape can be rewound back and forth on demand. <br>  Sometimes the distinction between Computers and Universal Computers is drawn based on the way programs are stored (external and internal).  I believe that this criterion is not appropriate.  An external program can work as an interpreter of numeric data.  The external program becomes a permanent part of the processor, and the data becomes the program, in the same way that the <a href="http://ru.wikipedia.org/wiki/%25D3%25ED%25E8%25E2%25E5%25F0%25F1%25E0%25EB%25FC%25ED%25E0%25FF_%25EC%25E0%25F8%25E8%25ED%25E0_%25D2%25FC%25FE%25F0%25E8%25ED%25E3%25E0">Universal Turing machine</a> works as an interpreter.  I believe that a prerequisite for a Universal Computer is a minimum set of instructions and indirect addressing. [11]  Indirect addressing can be simulated by writing a self-modifying program, so the set of instructions becomes the decisive criterion.  A machine with enough addressable memory, battery and capable of executing CLR (clear), INC (increment), LOAD, STORE and BZ (branching if zero) instructions is a Universal Computer.  In this case, the Z1 was not a full-fledged computer, but so were many other early computers.  The ABC machine was a specialized machine for solving systems of linear equations by the Gauss method.  Harvard Mark I did not have a conditional transition, although he implemented cycles.  ENIAC was not programmable - the data flows between the building blocks were set by hardware.  Conditional transitions were available with restrictions, and of course, there could be no talk of self-modifiable programs. <br><br>  Table 9. Comparison of architectural features <br><table><tbody><tr><td>  A machine </td><td>  Memory and CPU are separated. </td><td>  Conditional transitions </td><td>  Software or hardware programmable </td><td>  Self-modifying programs </td><td>  Indirect addressing </td></tr><tr><td>  Z1 </td><td>  Yes </td><td>  not </td><td>  soft </td><td>  not </td><td>  not </td></tr><tr><td>  Atanasov's car </td><td>  Yes </td><td>  not </td><td>  hard </td><td>  not </td><td>  not </td></tr><tr><td>  Harvard Mark I </td><td>  not </td><td>  not </td><td>  soft </td><td>  not </td><td>  not </td></tr><tr><td>  ENIAC </td><td>  not </td><td>  partially </td><td>  hard </td><td>  not </td><td>  not </td></tr><tr><td>  Machester Mark I </td><td>  Yes </td><td>  Yes </td><td>  soft </td><td>  not </td><td>  not </td></tr></tbody></table><br><br>  Table 10. Some additional architectural features <br><table><tbody><tr><td>  A machine </td><td>  Internal number system </td><td>  With constant or floating point </td><td>  Bitwise arithmetic </td><td>  Architecture </td><td>  Technology </td></tr><tr><td>  Z1 </td><td>  binary </td><td>  floating </td><td>  not </td><td>  consistent </td><td>  mechanical </td></tr><tr><td>  Atanasov's car </td><td>  binary </td><td>  constant </td><td>  Yes </td><td>  vectorial </td><td>  electronic </td></tr><tr><td>  Harvard Mark I </td><td>  decimal </td><td>  constant </td><td>  not </td><td>  parallel </td><td>  electromechanical </td></tr><tr><td>  ENIAC </td><td>  decimal </td><td>  constant </td><td>  not </td><td>  stream given </td><td>  electronic </td></tr><tr><td>  Machester Mark I </td><td>  binary </td><td>  constant </td><td>  Yes </td><td>  consistent </td><td>  electronic </td></tr></tbody></table><br><br>  Tables 9 and 10 show the most relevant information about the early computers mentioned above.  As it should be clear from the tables, none of the early computers complied with all the conditions of the Universal Computer.  I also mentioned the Manchester Mark I, which was built from 1946 to 1948 because, as far as I know, this is the first machine that fully complies with my Universal Computer conditions.  The Mark I car was built under the guidance of <a href="http://en.wikipedia.org/wiki/Frederic_Calland_Williams">Frederick Williams</a> (FC Williams) and <a href="http://en.wikipedia.org/wiki/Tom_Kilburn">Tom Kilburn</a> (T. Kilburn).  She keeps her program in a random access memory implemented on a cathode ray tube.  All the necessary elementary instructions are available (in a modified form), and despite the fact that there is no indirect addressing in it, self-modifiable programs can be implemented in it.  The first program was launched in June 1948, which counted on the largest of its own divisors of a large number.  In September 1948, Turing received the title of Reader in the mathematics department of the University of Manchester and wrote several programs for the first universal computer in the world.  His vision of a universal computer was published in 1936, the same year when the memory device Z1 was completed.  Tables 9 and 10 express that the invention of the computer was a collective achievement and covers 12 years. <br><br><h4>  Thanks </h4><br>  Deciphering schematic documentation was possible only in collaboration with some of my students at universities in Halle and Berlin.  I thank Alexander Thurm and Axel Bauer for implementing the gata-level Z3 processor simulator.  We realized what a synchronization problem is when the simulator refused to start.  I also thank Franz Konieczny, Reimund Spitzer and Roland Schultes, who wrote part of the stand-alone processor simulator.  We started working on the Z3 with the help of Konrad Zuz, who willingly answers our questions.  We were amazed how, after more than 60 years, the whole Z3 design remains in his head.  Unfortunately, Zuse died in December 1995, before the description of his work was completed.  This work is dedicated to his memory. <br><br><h4>  Literature </h4><br><ol><li>  H. Aiken and G. Hopper, ‚ÄúThe Automatic Sequence Controlled Calculator,‚Äù reprinted in B. Randell, ed., The Origins of Digital Computers.  Berlin: Springer Verlag, 1982, pp.  203-222. </li><li>  AW Burks and AR Burks, ‚ÄúThe ENIAC: First General Purpose Electronic Computer,‚Äù Annals of the History of Computing, vol.  3, no.  4, pp.  310-399, 1981. </li><li>  AW Burks and The First Electronic Computer: The Atanasoff Story.  Ann Arbor: Univ.  of Michigan Press, 1988. </li><li>  K.-H.  Czauderna, Konrad Zuse, der Weg zu seinem Computer Z3.  Munich: Oldenbourg Verlag, 1979. </li><li>  D. Knuth, The Art of Computer Programming-Seminumerical Algorithms, vol.  2. Reading, Mass .: Addison Wesley, 1981. </li><li>  I. Koren, Computer Arithmetic Algorithms.  Englewood Cliffs, NJ: Prentice Hall, 1993. </li><li>  SH Lavington, A History of Manchester Computers.  Manchester, England: NCC Publications, 1975. </li><li>  SH Lavington, Early British Computers.  Manchester, England: Digital Press, 1980. </li><li>  B. Randell, ed., The Origins of Digital Computers.  Berlin: Springer Verlag, 1982. </li><li>  R. Rojas, ‚ÄúWho Invented the Computer?  The Futty Years Mathematics of Computation, Proceedings of Symposia in Applied Mathematics, AMS, pp.  361-366, 1993. </li><li>  R. Rojas, ‚ÄúOn Computer Systems,‚Äù Proc.  13th World Computer Congress, Hamburg, pp.  324-331, 1994. </li><li>  U. Schweier and D. Saupe, ‚ÄúFunktions und Konstruktions prinzipien der programmgesteuerten mechanischen Rechen maschine Z1,‚Äù Arbeitspapiere der GMD 321, Bonn, 1988. </li><li>  N. Stern, From ENIAC to UNIVAC.  Bedford: Digital Press, 1981. </li><li>  K. Zuse, Patentanmeldung Z-2391, German Patent Office, Berlin, 1941. </li><li>  K. Zuse, Der Computer mein Lebenswerk.  Berlin: Springer-Verlag, 1970. </li><li>  K. Zuse, personal communication, Mar.  18, 1995. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/210412/">https://habr.com/ru/post/210412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210388/index.html">Non-standard application of IT in everyday life: parsing, perceptual hash, image comparison = cost optimization</a></li>
<li><a href="../210390/index.html">7 simple optimizations that reduce the CPU load from 80% to 27%</a></li>
<li><a href="../210406/index.html">Lexand Capella: a smartphone with Full HD-screen and support for two SIM-cards for 9,600 rubles ($ 280)</a></li>
<li><a href="../210408/index.html">Forgotten zoom</a></li>
<li><a href="../210410/index.html">Implement an L2TP / IPsec VPN server using standard Windows 7/8 tools for connecting Windows / iOS / Android systems to an internal network</a></li>
<li><a href="../210416/index.html">Clear cookies</a></li>
<li><a href="../210418/index.html">Accident Alert Info Panel Project (Part 1)</a></li>
<li><a href="../210420/index.html">We write monitoring the availability of tickets for Russian Railways</a></li>
<li><a href="../210422/index.html">We try Audio API on an example of writing a visualizer</a></li>
<li><a href="../210424/index.html">Post preparation for printing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>