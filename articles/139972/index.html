<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with the coco / r translator generator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="coco / r generator compilers and translators, which according to attribute grammar generates a scanner (lexical analyzer) and a parser (syntax analyze...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with the coco / r translator generator</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://www.ssw.uni-linz.ac.at/Research/Projects/Coco/">coco / r</a> generator compilers and translators, which according to attribute grammar generates a scanner (lexical analyzer) and a parser (syntax analyzer).  The scanner is built as a deterministic finite state machine, and the parser is constructed by a recursive descent. <br><br><a name="habracut"></a><br>  <b>1. Grammar</b> <br><br>  The generator generates a code according to the RBNF rules.  Because  The parser is worth a recursive descent, and this is a top-down parsing, then the grammar should belong to LL (k).  Ideally, LL (1), but conflict resolution is done in coco / r. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      LL (1) conflicts are resolved by semantic actions and viewing ahead of the tokens. <br><br>  A grammar is LL (1) if the conditions for two different products S-&gt; A | B are: <br>  1. There is no such terminal a for which A and B generate a string starting with a. <br>  2. An empty line can be generated by no more than one of products A or B. <br>  3. If e belongs to the set FIRST (B), then the sets FIRST (A) FOLLOW (S) do not intersect.  A similar statement for e belonging to FIRST (A) is also true. <br><br>  <b>2. Language coco / r</b> <br><br>  The generator can create code in languages: java, C ++, C #, F #, VB.Net, Oberon. <br>  In the example C ++ was taken. <br><br>  All rules must end with a period. <br>  Products of the form S-&gt; AB will be written as S = A B. <br>  |  - or <br>  ( ) - Group <br>  [] - 0 or 1 <br>  {} - 0 or more <br><br>  <u>2.1 Import, i.e.</u>  <u>connect headers.</u> <br><pre><code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;fstream&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt;</span></span></span></span></code> </pre> <br><br>  <u>2.2 Compiler ID</u> , i.e.  followed by the keyword COMPILER, followed by the non-terminal where your grammar begins. <br><br>  COMPILER expr <br><br>  <u>2.3 Global variables and functions.</u> <br>  After the keyword COMPILER, you can insert a section with variables and functions.  If there are many functions, it is better to put them in a separate file, since  grammar and without them will turn out very scary and unreadable. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::wstring&amp; strbuf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wstringstream converter; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; converter &lt;&lt; strbuf; converter &gt;&gt; value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">wstring </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Number )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wostringstream ss; ss &lt;&lt; Number; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ss.str(); }</code> </pre><br><br>  <u>2.4 Rules for generating a scanner.</u> <br>  2.4.1 IGNORECASE keyword to ignore case of characters. <br><br>  2.4.2 CHARACTERS - section in which we describe a set of valid characters.  For example, what is a letter for us and what is a number. <br><br>  Charters <br>  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz". <br>  digit = "0123456789". <br><br>  Also here you can describe the characters separators. <br>  cr = '\ r'. <br>  lf = '\ n'. <br>  tab = '\ t'. <br><br>  An entry of the form char 1 .. char2 denotes a sequence of characters from char1 to char2. <br>  digit = '0' .. '9'. <br><br>  ANY - any sequence of characters. <br>  + including many <br>  - not including <br><br>  For example, you can describe a set of characters that does not include double quotes: <br>  verbatimStringChar = ANY - '"'. <br><br>  Set of characters for hexadecimal number system: <br>  hexDigit = digit + "ABCDEFabcdef". <br><br>  2.4.3 Tokens themselves, or another name - tokens.  Keyword section - TOKENS.  We describe what we mean by the lexeme "identifier" and the lexeme "number". <br><br>  TOKENS <br>  ident = letter {letter |  digit |  "_"}. <br>  number = digit {digit}. <br><br>  The token "string", like any sequence of characters enclosed in double quotes: <br>  string = "\" "{verbatimStringChar}" \ "". <br><br>  Number of hexadecimal system: <br>  hex = "0x" {hexDigit hexDigit}. <br><br>  2.4.4 Special Options Section. <br><br>  2.4.5 Comments. <br>  COMMENTS FROM "/ *" TO "* /" NESTED <br>  COMMENTS FROM "//" TO cr lf <br><br>  2.4.6 Separators.  We write which delimiters we ignore. <br>  IGNORE cr + lf + tab <br><br>  <u>2.5 Rules for parser generation.</u> <br>  Start with the keyword PRODUCTIONS. <br>  Expression grammar example: <br>  Expr = ident ': =' NumExpr ';' <br>  NumExpr = Term {('+' | '-') NumExpr} <br>  Term = Multiplier {('*' | '/') Term} <br>  Multiplier = ident |  number |  '(' NumExpr ')' <br><br>  All attributes are written in brackets &lt;&gt;.  If you use something from stl, for example, list, then attributes should be placed in brackets with dots, i.e.  &lt;.  .&gt;. <br>  Attributes are written at non-terminals and are translated as function parameters. <br>  The terminal has no attributes, but if you want so much, you can wrap it in a non-terminal: <br>  LogOp &lt;std :: wstring &amp; op&gt; = ("&amp;&amp;" | "||") (.op = t-&gt; val ;.). <br><br>  Semantic actions are written in brackets with dots (..).  This is the code that the generator inserts into the parser.  The code is written in the language in which the lexer and parser are generated. <br><br>  ANY is a keyword in the parser section for any token.  So we can describe the ‚Äútext‚Äù as {ANY}. <br><br>  <u>2.6 The keyword END</u> , followed by the name you entered after COMPILER in 2.2. <br><br>  <b>3. Conflict resolution.</b> <br><br>  It is very important to understand that the grammar should correspond to the type of the analyzer.  If this condition is violated, the generator begins to swear in terrible words. <br><br>  <u>3.1 Factoring.</u> <br>  Rules start with the same token.  The generator writes several alternatives <br>  Example: <br>  S-&gt; a '=' B |  a '(' C ')' <br>  As you can see, 2 rules start with the token "a", which violates the first rule LL (1).  We rewrite it as S-&gt; a ('=' B | '(' C ')') <br>  Some conflicts such as if-else cannot be resolved. <br>  Statement = if '(' Eepr ')' Statement [else Statement]. <br>  if (a&gt; b) if (a&gt; c) max = a;  else max = b; <br>  It is not clear what to choose here, therefore an agreement was made: to choose the first alternative.  In this example, the choice is correct, but in your grammar it is better to avoid such ambiguities. <br><br>  Failed to write. <br>  S = a [id b] A. <br>  A = id {.id}. <br>  It is not clear which rule to choose, since  [id b] and A begin with identical tokens.  In this case, it is best to rewrite the grammar: <br>  S = a id (b A | {. Id}). <br><br>  <u>3.2 Left recursion.</u> <br>  Left recursion for LL grammar is in no way valid.  It must be removed by conversion.  Fortunately, any left recursion can be converted to right. <br>  A-&gt; Aa1 | ... | Aan | b1 ... | bm <br>  on <br>  A-&gt; b1B | .. | bmB <br>  B-&gt; a1B | .. | anB | e <br><br>  Record in RBNF: <br>  A = A b |  c. <br>  on <br>  A = c {b}. <br><br>  <u>3.3 Semantic significance.</u> <br>  In some cases, the choice of rules is based on their semantics.  For example, an expression with types: <br>  Expr = Factor {'+' Factor}. <br>  Factor = '(' ident ')' Factor |  '(' Expr ')' |  ident |  number. <br><br>  Those.  Such a grammar allows the following chains: <br>  a + b <br>  (a) + b <br>  (int) a + b <br>  In the last thread, the choice of the rule '(' ident ')' Factor is determined by the semantics of the identifier.  Those.  This rule is chosen if we have the type as ident. <br><br>  !  An extremely unfortunate example in terms of building a language.  Usually in the grammar "keywords" are described by a separate rule.  Then there is no need for ID checks. <br><br>  Another example. <br>  A = ident (. X = 1;.) {',' Ident (.x ++ ;.)} ':' |  ident (.Foo () ;.) {',' ident (.bar () ;.)} ';'. <br>  In this case, the grammar cannot be edited, since the same parts of the rule have different semantic actions.  To define a rule, you must look at all the tokens to a colon or semicolon.  Only then will it become clear which rule to choose. <br><br>  Decision: <br>  In the grammar, you can insert a Boolean function, which will be selected alternative. <br>  S = a [id b] A. <br>  A = id {.id}. <br><br>  S = a [IF (isAlias ‚Äã‚Äã()) id b] A. <br>  IsAlias ‚Äã‚Äã() is a function that scans 2 tokens in front of it.  If it is b, then returns true. <br><br>  Token t - just recognized token <br>  Token la - the next token <br><br>  t.val - the value of the token <br>  t.kind - type of token, determined by lexer <br><br>  A = IF (FollowedByColon ()) <br>  ident (. x = 1;.) {',' ident (.x ++ ;.)} ':' <br>  |  ident (.Foo () ;.) {',' ident (. Bar () ;.)} ';'. <br><br><pre> <code class="hljs ruby">bool FollowedByColon(){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   Token x = la; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(x.kind==_comma <span class="hljs-params"><span class="hljs-params">||</span></span> x.kind== _ident) /<span class="hljs-regexp"><span class="hljs-regexp">/     x=scanner.Peek(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ true,     return x.kind==_colon; }</span></span></code> </pre><br><br>  Notes: <br>  <b>IF</b> keyword generator language. <br>  The FollowedByColon () function refers to the first rule.  If she gave true, then she considers him. <br>  The names of the types of tokens assigns a scanner.  But if in the TOKENS section to make such announcements <br>  ident = letter {letter |  digit |  "_"}. <br>  comma = ','. <br>  semicolon = ';'. <br>  colon = ':'. <br>  Then the scanner will generate constants with good names: <br>  const int _EOF = 0; <br>  const int _ident = 1; <br>  const int _comma = 2; <br>  const int _semicolon = 3; <br>  const int _colon = 4; <br><br>  From the point of view of building a language, a separate description of each special character as a token has no meaning.  But if the need arose to write the conditions in which verification is required of the tokens in front, this description can be useful. <br><br>  If in the first rule you had a function in which you checked tokens, and in the second rule you also have a function, then the scanner should return to its original position.  Reset position can function scanner.ResetPeek (). <br><br><br>  <b>4. Sample code</b> <br><br>  We translate the expression into a postfix notation.  Expressions should be derived from this grammar: <br>  Expr = ident ': =' NumExpr ';' <br>  NumExpr = Term {('+' | '-') NumExpr} <br>  Term = Multiplier {('*' | '/') Term} <br>  Multiplier = ident |  number |  '(' NumExpr ')' <br><br>  atg file: <br><br><pre> <code class="hljs rust">#include &lt;string&gt; #include &lt;sstream&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; COMPILER expr int toInt(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::wstring&amp; strbuf) { std::wstringstream converter; int value = <span class="hljs-number"><span class="hljs-number">0</span></span>; converter &lt;&lt; strbuf; converter &gt;&gt; value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } std::wstring toString ( int Number ) { std::wostringstream ss; ss &lt;&lt; Number; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ss.<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>(); } IGNORECASE CHARACTERS letter = <span class="hljs-string"><span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span></span>. digit = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>. cr = <span class="hljs-string"><span class="hljs-string">'\r'</span></span>. lf = <span class="hljs-string"><span class="hljs-string">'\n'</span></span>. tab = <span class="hljs-string"><span class="hljs-string">'\t'</span></span>. TOKENS ident = letter {letter | digit | <span class="hljs-string"><span class="hljs-string">"_"</span></span>}. number = digit {digit}. COMMENTS FROM <span class="hljs-string"><span class="hljs-string">"/*"</span></span> TO <span class="hljs-string"><span class="hljs-string">"*/"</span></span> NESTED COMMENTS FROM <span class="hljs-string"><span class="hljs-string">"//"</span></span> TO cr lf IGNORE cr + lf + tab PRODUCTIONS expr (.std::wstring <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>;.) = (.std::wstring s,s1,s2,s3,s4; .) ident (.s1=t-&gt;val;.)<span class="hljs-string"><span class="hljs-string">":="</span></span> NumExpr&lt;s2&gt; <span class="hljs-string"><span class="hljs-string">";"</span></span> (. <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=s1; <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=s2; <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=L<span class="hljs-string"><span class="hljs-string">":=\n"</span></span>;.) {ident(.s3=t-&gt;val; s4=L<span class="hljs-string"><span class="hljs-string">""</span></span>;.)<span class="hljs-string"><span class="hljs-string">":="</span></span> NumExpr&lt;s4&gt; <span class="hljs-string"><span class="hljs-string">";"</span></span> (. s+=s3; s+=s4; s+=L<span class="hljs-string"><span class="hljs-string">":=\n"</span></span>; .)} (. <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=s; std::wofstream outfile (<span class="hljs-string"><span class="hljs-string">"out.txt"</span></span>, std::ios_base::out); outfile &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> &lt;&lt; std::endl; outfile.close(); .) . NumExpr&lt;std::wstring &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = (.std::wstring s1,s2, op; .) Term&lt;s1&gt; (.<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=s1;.) { (<span class="hljs-string"><span class="hljs-string">"+"</span></span> (.op=L<span class="hljs-string"><span class="hljs-string">"+"</span></span>;.)|<span class="hljs-string"><span class="hljs-string">"-"</span></span> (.op=L<span class="hljs-string"><span class="hljs-string">"-"</span></span>;.)) NumExpr&lt;s2&gt; (. <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=s2; <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=op; .) }. Term&lt;std::wstring &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; =(.std::wstring s1,s2, op;.) Multiplier&lt;s1&gt; (.<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=s1;.) { (<span class="hljs-string"><span class="hljs-string">"*"</span></span> (.op=L<span class="hljs-string"><span class="hljs-string">"*"</span></span>;.)|<span class="hljs-string"><span class="hljs-string">"/"</span></span>(.op=L<span class="hljs-string"><span class="hljs-string">"/"</span></span>;.)) Term&lt;s2&gt; (. <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=s2; <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=op; .) }. Multiplier&lt;std::wstring &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = ident (.<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>=t-&gt;val; .) | number (.<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>=t-&gt;val;.) | (.std::wstring s; .) <span class="hljs-string"><span class="hljs-string">"("</span></span> NumExpr&lt;s&gt; <span class="hljs-string"><span class="hljs-string">")"</span></span> (.<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>=s;.). END expr.</code> </pre><br><br>  main: <br><pre> <code class="hljs mel">#include &lt;iostream&gt; #include &lt;wchar.h&gt; #include <span class="hljs-string"><span class="hljs-string">"Parser.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"Scanner.h"</span></span> #include &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; using <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> std; main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, char *argv[]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc == <span class="hljs-number"><span class="hljs-number">2</span></span>) { wchar_t *<span class="hljs-keyword"><span class="hljs-keyword">file</span></span> = coco_string_create(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); Scanner *scanner = new Scanner(<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>); Parser *parser = new Parser(scanner); parser-&gt;Parse(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> parser; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> scanner; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Use: translator filename"</span></span> &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre><br><br>  make: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">all</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">translator</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">translator</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">Coco</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">g</span></span>++ <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tr</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.exe</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">g</span></span>++ <span class="hljs-selector-tag"><span class="hljs-selector-tag">-c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">Scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">g</span></span>++ <span class="hljs-selector-tag"><span class="hljs-selector-tag">-c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">Parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">g</span></span>++ <span class="hljs-selector-tag"><span class="hljs-selector-tag">-c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Coco</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">expr</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.atg</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">coco</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">expr</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.atg</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">clean</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">del</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">del</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpp</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.old</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.old</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cpp</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.old</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.old</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">del</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">scanner</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">parser</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">del</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">translator</span></span></code> </pre><br><br>  Parser function, built on grammar <br><pre> <code class="hljs rust">void Parser::NumExpr(std::wstring &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { std::wstring s1,s2, op; Term(s1); <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=s1; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (la-&gt;kind == <span class="hljs-number"><span class="hljs-number">5</span></span> || la-&gt;kind == <span class="hljs-number"><span class="hljs-number">6</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (la-&gt;kind == <span class="hljs-number"><span class="hljs-number">5</span></span>) { Get(); op=L<span class="hljs-string"><span class="hljs-string">"+"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Get(); op=L<span class="hljs-string"><span class="hljs-string">"-"</span></span>; } NumExpr(s2); <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=s2; <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>+=op; } }</code> </pre><br><br>  entrance <br>  a: = b; <br>  a: = a-5; <br>  a: = 9-5 + 2; <br>  a: = 2 + 3 * 4; <br>  a: = (5-4) * (3 + 2); <br><br>  output <br>  ab: = <br>  aa5 -: = <br>  a952 + -: = <br>  a234 * +: = <br>  a54-32 + *: = </div><p>Source: <a href="https://habr.com/ru/post/139972/">https://habr.com/ru/post/139972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../139964/index.html">Twitter Kung Fu with SilverBird</a></li>
<li><a href="../139968/index.html">Nginx - we leave for technical work</a></li>
<li><a href="../139969/index.html">Crossbrowser CSS</a></li>
<li><a href="../139970/index.html">Fast image compression using JPEG for CUDA</a></li>
<li><a href="../139971/index.html">How was the Moscow Django Meetup</a></li>
<li><a href="../139974/index.html">A little about hashes and secure password storage</a></li>
<li><a href="../139976/index.html">Hello from NASA: an unusual jacket with a thermometer</a></li>
<li><a href="../139981/index.html">When will IPv4 end?</a></li>
<li><a href="../139983/index.html">Shkolnik participated in hacking the site of the space agency of Kazakhstan</a></li>
<li><a href="../139985/index.html">Energy accident in Kiev, lies a number of hosting companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>