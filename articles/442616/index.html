<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overclock event handling up to 1.6 million per second</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When the participants of HighLoad ++ came to the report of Alexander Krasheninnikov , they hoped to hear about handling 1,600,000 events per second. E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overclock event handling up to 1.6 million per second</h1><div class="post__text post__text-html js-mediator-article">  When the participants of <a href="http://www.highload.ru/">HighLoad ++</a> came to the report of <b>Alexander Krasheninnikov</b> , they hoped to hear about handling 1,600,000 events per second.  Expectations did not materialize ... Because during the preparation for the performance, this figure flew to <b>1,800,000</b> - so, on HighLoad ++, reality exceeds expectations. <br><br>  <a href="https://www.youtube.com/watch%3Fv%3D9odlNsz7stQ">3 years ago, Alexander told us</a> how they built a scalable near-realtime event handling system in Badoo.  Since then, it has evolved, volumes have grown in the process, it had to solve scaling and fault tolerance tasks, and at a certain point, radical measures were needed - a <b>change of the technological stack</b> . <br><br><img src="https://habrastorage.org/webt/q8/s-/cq/q8s-cqlxfrv8abkdotnudzeq1u8.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      From the decryption, you will learn how Badoo replaced the Spark + Hadoop bundle with ClickHouse, <b>saved hardware 3 times and increased the load 6 times</b> , why and with what means to collect statistics in the project, and what to do with this data. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5KQsNmRTQmg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <b>About speaker:</b> Alexander Krasheninnikov ( <a href="https://habr.com/ru/users/alexkrash/" class="user_link">alexkrash</a> ) - Head of Data Engineering in Badoo.  Engaged in a BI-infrastructure, scaling under load, leads teams that build data processing infrastructure.  Loves everything distributed: Hadoop, Spark, ClickHouse.  I am sure that cool distributed systems can be prepared from OpenSource. <a name="habracut"></a><br><br><h2>  Statistics collection </h2><br>  If we have no data, we are blind and cannot manage our project.  That is why we need statistics - to <strong>monitor the viability of the project.</strong>  We, as engineers, should strive to improve our products, but if <strong>you want to improve, measure.</strong>  I follow this motto in my work.  First of all, our goal is business value.  Statistics <strong>provides answers to business questions</strong> .  Technical metrics are technical metrics, but business is also interested in indicators, and they should also be considered. <br><br><h2>  The life cycle of statistics </h2><br>  I define the life cycle of statistics with 4 points, about each of which we will talk separately. <br><br><img src="https://habrastorage.org/webt/pp/kb/p5/ppkbp5uw_stwtzdgmakh9z_ffbw.jpeg"><br><br><h2>  Define Phase - Formalization </h2><br>  In the application, we collect several metrics.  First of all, these are <strong>business metrics</strong> .  If you have a photo service, for example, you wonder how many photos you upload per day, per hour, per second.  The following metrics are <strong>‚Äúsemi-technical‚Äù</strong> : the responsiveness of the mobile application or site, the work of the API, how quickly the user interacts with the site, the installation of applications, the UX.  <strong>Tracking user behavior</strong> is the third important metric.  These are systems like Google Analytics and Yandex. Metrics.  We have our own great tracking system in which we invest a lot. <br><br>  In the process of working with statistics, many users are involved - these are developers and business analysts.  It is important that everyone speak the same language, so you need to agree. <br><br><blockquote>  You can negotiate orally, but much better when it happens formally - in a clear structure of events. </blockquote><br>  <strong>Formalizing the structure of business events</strong> is when a developer tells how many registrations we have, the analyst understands that he was given information not only about the total number of registrations, but also broken down by country, gender and other parameters.  And all this information is formalized and is <strong>in the public domain for all users of the company</strong> .  The event has a typed structure and a formal description.  For example, we store this information in our own format in <strong>Protocol Buffers</strong> . <br><br>  Description of the event "Registration": <br><br><pre><code class="plaintext hljs">enum Gender { FEMALE = 1; MALE = 2; } message Registration { required int32 userid =1; required Gender usergender = 2; required int32 time =3; required int32 countryid =4; }</code> </pre> <br>  The registration event contains information about the <strong>user, the field, the time of the</strong> event and the <strong>country of</strong> registration of the user.  This information is available to analysts, and, further, business understands that we generally collect. <br><br><h3>  Why do we need a formal description? </h3><br>  The formal description is a <strong>uniformity for developers, analysts and the food department.</strong>  Then this information penetrates the description of the application business logic with a red thread.  For example, we have an internal system for describing business processes and there is a screen in it that we have a new feature. <br><br><img src="https://habrastorage.org/webt/qf/cv/hg/qfcvhgvo39rtidli5fxdq65hx2q.jpeg"><br><br>  In the <strong>product requirements document</strong> there is a section with instructions that when a user interacts with an application in this way, we must send an event with exactly the same parameters.  Subsequently, we will be able to validate how well our features work, and that we have correctly measured them.  The formal description allows us to further understand how to store this data in the database: NoSQL, SQL or others.  We have <strong>a data schema</strong> , and this is awesome. <br><br>  In some analytical systems, which are provided as a service, there are only 10 to 15 events in the stock photography.  We have this number increased by more than 1000 and is not going to stop - <strong>it is impossible to live without a single registry</strong> . <br><br><h3>  Define Phase Summary </h3><br>  We decided that <strong>statistics is important</strong> and <strong>described a certain subject area</strong> - this is already good, you can live on. <br><br><h2>  Phase Collect - data collection </h2><br>  We decided to build the system in such a way that when a business event takes place - registration, sending a message, like - then simultaneously with the preservation of this information, we separately send some statistical event. <br><br><blockquote>  In the code, statistics are sent simultaneously with the business event. </blockquote><br>  It is processed completely independently of the data warehouses in which the application is running, because the <strong>data flow passes through a separate processing pipeline.</strong> <br><br>  Description via EDL: <br><br><pre> <code class="plaintext hljs">enum Gender { FEMALE = 1; MALE = 2; } message Registration { required int32 user_id =1; required Gender user_gender = 2; required int32 time =3; required int32 country_id =4; }</code> </pre> <br>  We have a description of the registration event.  An API is automatically generated, accessible to developers from code that allows you to send statistics in 4 lines. <br><br>  EDL based API: <br><br><pre> <code class="plaintext hljs">\EDL\Event\Regist ration::create() -&gt;setUserId(100500) -&gt;setGender(Gender: :MALE) -&gt;setTime(time()) -&gt;send();</code> </pre> <br><h3>  Event Delivery </h3><br>  This is our external system.  We do this because we have incredible services that provide an API for working with data about photos, about something else.  They all store data in cool newfangled bases, for example, in Aerospike and CockroachDB. <br><br>  When you need to build some kind of reporting, you don‚Äôt have to go and beg: ‚ÄúGuys, how much do you have here and how much?‚Äù - all data is sent to a separate flow.  Processing conveyor - external system.  From the application context, we unbind all the data from the business logic repository, and send it further to a separate pipeline. <br><br>  Phase Collect assumes the availability of application servers.  We have this PHP. <br><br><img src="https://habrastorage.org/webt/az/vo/va/azvova-esx681etff8drvvkigeq.gif"><br><br><h3>  Transport </h3><br>  This is a subsystem that allows you to send to another pipeline what we did from the context of the application.  Vehicles are selected solely from your requirements, depending on the situation in the project. <br><br>  The transport has the characteristics, and the first is the <strong>delivery guarantee.</strong>  Characteristics of transport: at-least-once, exactly-once, you choose statistics for your tasks, based on how important these data are.  For example, for billing systems it is unacceptable that the statistics reflect more transactions than there are - this is money, that‚Äôs not the case. <br><br>  The second parameter is <strong>binding for programming languages.</strong>  You need to somehow interact with the transport, so it is selected under the language in which the project is written. <br><br>  The third parameter is <strong>scalability.</strong>  Since we are talking about millions of events per second, it would be good to keep in mind the reserve for further scalability. <br><br>  There are many transport options: application RDBMS, Flume, Kafka or LSD.  We use <strong>LSD</strong> - this is our special way. <br><br><h3>  Live streaming daemon </h3><br>  LSD has nothing to do with banned substances.  This is a <strong>lively, very fast streaming demon</strong> that does not provide any agent to write to it.  We can tyunit it, we have <strong>integration with other systems</strong> : HDFS, Kafka - we can peretimlivat sent data.  LSD does not have a network call on INSERT, and it can manage the network topology. <br><br>  The most important thing is that this is <strong>OpenSource from Badoo</strong> - there is no reason not to trust this software. <br><br>  If this were a perfect demon, then instead of Kafka we would discuss LSD at every conference, but in every LSD there is a fly in the ointment.  We have our limitations, which we live with, which suit us: <strong>there is no replication support in LSD</strong> and it guarantees delivery <strong>at-least once</strong> .  Also for cash transactions it is not the most suitable transport, but in general it is necessary to communicate with money only through ‚Äúacid‚Äù databases - supporting <a href="https://ru.wikipedia.org/wiki/ACID">ACID</a> . <br><br><h3>  Collect Phase Summary </h3><br>  Based on the results of the previous series, we received a <strong>formal description of the</strong> data, generated from them an excellent, convenient <strong>API for</strong> developers <strong>to send events</strong> , and figured out how to <strong>transport</strong> this data <strong>from the application context to a separate pipeline</strong> .  Already not bad, and we come to the next phase. <br><br><h2>  Process Phase - Data Processing </h2><br>  We collected data from registrations, uploaded photos, polls - what to do with all this?  From this data we want to get <strong>graphs</strong> with a long history and <strong>raw data</strong> .  Charts understand everything - you do not need to be a developer to understand the curve that the company's revenue is growing.  Raw data is used for operational reporting and ad-hoc.  For more complex cases, our analysts want to perform analytical queries on this data.  Both that, and that functionality are necessary to us. <br><br><h3>  Charts </h3><br>  Graphics are different types. <br><br><img src="https://habrastorage.org/webt/hu/c7/ap/huc7apcxpcajxhc5k3an8ken4wk.jpeg"><br><br>  Or, for example, a graph with a history that shows data for 10 years. <br><br><img src="https://habrastorage.org/webt/cq/_z/pc/cq_zpcmcbe2b_nipvwhbtnkme94.jpeg"><br><br>  Charts are even such. <br><br><img src="https://habrastorage.org/webt/rs/76/eg/rs76eg23gglv8m1xlaby2gr8vzg.jpeg"><br><br>  This is the result of some AB-test, and it is surprisingly similar to the Chrysler building in New York. <br><br>  There are two ways to draw a graph: a <strong>request for raw data</strong> and a <strong>time series</strong> .  Both approaches have disadvantages and advantages, which we will not dwell on in detail.  We use a <strong>hybrid approach</strong> : we keep a short ‚Äútail‚Äù of raw data for operational reporting, and a time series for long-term storage.  The second is calculated from the first. <br><br><h3>  How we grew to 1.8 million events per second </h3><br>  It's a long story ‚Äî millions of RPS don't happen in a day.  Badoo is a company with a ten-year history, and it can be said that the data processing system grew with the company. <br><br><img src="https://habrastorage.org/webt/av/o3/04/avo304ko07jkl4szc5dnz2x7zc8.jpeg"><br><br>  At first we had nothing.  We started collecting data - it turned out <strong>5,000 events per second.</strong>  One MySQL host and nothing else!  Any relational database management system will cope with this task, and it will be comfortable with it: you will have transactionality - put data, get requests for it - everything works great and works well.  So we lived for a while. <br><br>  At some point there was a functional sharding: registration data - here, and about photos - there.  So we lived up to <strong>200,000 events per second</strong> and began to use different combined approaches: to store not raw data, but <strong>aggregated</strong> data, but so far within the relational database.  We store counters, but the essence of most relational databases is such that it will be impossible to perform a <strong>DISTINCT query</strong> on this data later - the algebraic counter model does not allow you to calculate DISTINCT. <br><br>  We in Badoo have the motto <strong>‚ÄúUnstoppable force‚Äù</strong> .  We were not going to stop and grew further.  At the moment when they crossed the threshold of <strong>200,000 events per second</strong> , they decided to create a formal description, which I mentioned above.  Before that, there was a certain chaos, but now they received a structured registry of events: they began to scale the system, <strong>hooked up Hadoop</strong> , all the data went to <strong>Hive-tables.</strong> <br><br>  Hadoop is a huge software package, file system.  For distributed computing, Hadoop says: "Put the data here, I will let you perform analytical queries on them."  So we did - we wrote a <strong>regular calculation of all the graphs</strong> - it turned out great.  But schedules are valuable when they are updated promptly - once a day, looking at the updated schedule is not so fun.  If we rolled out to production something that leads to a fatal error, we would like to see the graphics fall immediately, and not every other day.  Therefore, the entire system began to degrade over time.  However, we realized that at this stage you can stick to the selected stack of technologies. <br><br><blockquote>  For us, Java was a novelty, we liked it, and we realized that we could do it differently. </blockquote><br>  At the stage from 400,000 to <strong>800,000 events per second</strong> , we replaced Hadoop in its pure form and Hive, as an analyst, performed <strong>Spark Streaming</strong> , wrote <strong>generic map / reduce</strong> and incremental calculation of metrics.  3 years ago I <a href="https://www.youtube.com/watch%3Fv%3D3XJhBRiVKW8">told</a> how we did it.  Then it seemed to us that Spark would live forever, but life decided otherwise - we rested against the limitations of Hadoop.  Perhaps if we had other conditions, we would continue to live with Hadoop. <br><br>  Another problem, in addition to calculating graphs on Hadoop, was incredible four-story SQL queries that analysts drove, and the graphs are not updated quickly.  The fact is that there is quite a tricky job with the operational processing of the data, so that it was realtime, fast and cool. <br><br>  Badoo is served by two data centers located on two sides of the Atlantic Ocean - in Europe and North America.  To build a single reporting, you need to send data from America to Europe.  It is in the European data center that we keep all statistics records, because there is more computing power.  <strong>Roundtrip</strong> between data centers of the order of <strong>200 ms</strong> - the network is quite delicate - making a request to another DC is not the same as going to the next rack. <br><br>  When we started to formalize events, both developers and product managers became involved, everyone liked everything - there was just an <strong>explosive growth of events</strong> .  At this time, it was time to buy iron into the cluster, but we didn‚Äôt really want to do that. <br><br>  When we passed the peak of <strong>800,000 events per second</strong> , we learned that Yandex had put <strong>ClickHouse</strong> into OpenSource and decided to try it.  <strong>They crammed the car of the cones</strong> , while they were trying to do something, and as a result, when everything worked, they organized a small reception on the first million events.  Probably, on ClickHouse it would be possible to finish the report. <br><br><blockquote>  Just take ClickHouse and live with it. </blockquote><br>  But this is not interesting, so let's continue to talk about data processing. <br><br><h3>  Clickhouse </h3><br>  ClickHouse is a hyip of the last two years and does not need to be presented: only on HighLoad ++ in 2018 I remember <a href="http://www.highload.ru/moscow/2018/schedule">about five reports</a> about it, as well as seminars and seminars. <br><br>  This tool is designed to solve exactly the tasks that we set for ourselves.  There is a <strong>realtime update</strong> and the chips that we received at the time from Hadoop: replication, sharding.  There was no reason not to try ClickHouse, because we understood that with the implementation on Hadoop we already broke through the bottom.  The tool is cool, and the documentation is generally fire - I wrote there myself, I like everything very much, and everything is great.  But we had to solve a number of issues. <br><br>  <strong>How to transfer the whole flow of events to ClickHouse?</strong>  <strong>How to combine data from two data centers?</strong>  From what we came to the admins and said: "Guys, let's populate ClickHouse", they will not make the network twice as thick, and the delay is two times less.  No, the network is still as thin and small as the first paycheck. <br><br>  <strong>How to store the results</strong> ?  At Hadoop, we understood how to draw graphics - but how to do it on the magic ClickHouse?  Magic wand not included.  <strong>How to deliver results</strong> to time series storage? <br><br>  As my lecturer at the institute said, we will consider 3 data schemes: strategic, logical and physical. <br><br><h4>  Strategic storage scheme </h4><br>  We have <strong>2 data centers</strong> .  We learned that ClickHouse knows how to know nothing about DC, and just populated into each DC over the cluster.  Now the <strong>data does not move through the cross-Atlantic cable</strong> - all data that occurred in DC is stored locally in its cluster.  When we want to make a request on the combined data, for example, to find out how many registrations are in both DCs, ClickHouse gives us this opportunity.  Low latency and availability for a request - just a masterpiece! <br><br><img src="https://habrastorage.org/webt/mr/dc/-2/mrdc-205rzloz1c2oemavnikcxu.jpeg"><br><br><h4>  Physical storage scheme </h4><br>  Again the questions: how will our data fit into the ClickHouse relational model, what to do in order not to lose replication and sharding?  The <a href="https://clickhouse.yandex/docs/ru/">ClickHouse documentation</a> is extensively described, and if you have more than one server, you will come across this article.  Therefore, we will not go into what is in the manual: replications, sharding, and requests for all shard data. <br><br><h4>  Logical storage scheme </h4><br>  The logic circuit is the most interesting.  In one pipeline, we handle heterogeneous events.  This means that we have a <strong>stream of heterogeneous events</strong> : registrations, voices, photo uploads, technical metrics, tracking user behavior ‚Äî all of these events have completely <strong>different attributes</strong> .  For example, I looked at the screen on a mobile phone - I need a screen id, I voted for someone - I need to understand whether the vote was for or against.  All these events have different attributes, different schedules are drawn on them, but all this must be processed in a single pipeline.  How to put it in a ClickHouse model? <br><br>  <strong>Approach # 1 - per event table.</strong>  This first approach, we extrapolated from the experience gained from MySQL - created a <strong>label for each event</strong> in ClickHouse.  It sounds pretty logical, but we ran into a number of difficulties. <br><br>  We have no restrictions on the fact that the event will change its structure when today's build comes out.  A patch can be done by any developer.  The scheme is generally mutable in all directions.  The only <strong>required-field</strong> is the <strong>timestamp event</strong> and what the event was.  Everything else changes on the fly, and, accordingly, these labels need to be modified.  ClickHouse has the ability to perform <strong>ALTER on a cluster</strong> , but this is a delicate, gentle procedure that is difficult to automate so that it works flawlessly.  Therefore, it is a minus. <br><br>  We have more than a thousand different events, which gives us a <strong>high INSERT rate for one machine</strong> - we constantly record all the data in a thousand tables.  For ClickHouse this is an anti-pattern.  If Pepsi slogan - "Live in big gulps", then ClickHouse - <strong>"Live in big batchy</strong> . <strong>"</strong>  If this is not done, replication chokes, ClickHouse refuses to accept new inserts - an unpleasant scheme. <br><br>  <strong>Approach # 2 is a wide table</strong> .  Siberian men tried to slip the chainsaw rail and apply a different data model.  We make a table with a <strong>thousand columns</strong> , where each event has reserved columns for its data.  We have a huge <strong>sparse table</strong> - fortunately this did not go further than the development environment, because from the very first inserts it became clear that the scheme was absolutely bad, and we would not do that. <br><br>  But still I want to use such a cool software product, a little bit more to finish - and it will be necessary. <br><br>  <strong>Approach # 3 - generic table.</strong>  We have one huge table in which we store data in arrays, because ClickHouse supports <strong>non-scalar data types</strong> .  That is, we start a column in which the names of the attributes are stored, and separately a column with an array in which the values ‚Äã‚Äãof the attributes are stored. <br><br><img src="https://habrastorage.org/webt/ot/s3/ro/ots3ronbcjh69ssxujqvbuxeghc.jpeg"><br><br>  ClickHouse here performs its task very well.  If we only needed to insert data, we would probably squeeze 10 more times on the current installation. <br><br>  However, the fly in the ointment is that this is also an anti-pattern for ClickHouse - <strong>to store arrays of strings</strong> .  This is bad, because arrays of strings <strong>take up more disk space</strong> - they hurt worse than simple columns and are <strong>more difficult to process</strong> .  But for our task, we turn a blind eye to this, as the merits outweigh. <br><br>  How to make a SELECT from such a table?  Our task is to calculate registrations grouped by gender.  You must first find in one array which position corresponds to the gender column, then climb into another column with this index and retrieve the data. <br><br><img src="https://habrastorage.org/webt/gh/pw/ek/ghpwekgjjrr0eisi8_zjmoi48tk.jpeg"><br><br><h4>  How to draw graphs on this data </h4><br>  Since all events are described, they have a strict structure, we create a four-story SQL query for each type of event, execute it and save the results to another table. <br><br>  The problem is that in order to draw two neighboring points on the graph, you need to <strong>scan the entire table</strong> .  Example: we look at the registration for the day.  This event is from the topmost row to the next to last.  Scanned once - great.  After 5 minutes, we want to draw a new point on the graph - again we scan the range of data that intersects with the previous scan, and so for each event.  It sounds logical, but it doesn't look great. <br><br>  In addition, when we take some strings, we still need to <strong>count the results under the aggregation</strong> .  For example, there is a fact that the servant of God registered in Scandinavia and was a man, and we need to calculate summary statistics: how many registrations, how many men, how many of them are people, and how many from Norway.  This is called in terms of analytical databases <strong>ROLLUP, CUBE</strong> and <strong>GROUPING SETS</strong> - turn one line into several. <br><br><h4>  How to treat </h4><br>  Fortunately, ClickHouse has a tool for solving this problem, namely the <strong>serialized state of aggregate functions</strong> .  This means that you can scan a piece of data once and save these results.  This is a <strong>killer feature</strong> .  Three years ago, we did exactly this on Spark and Hadoop, and it's cool that, in parallel with us, Yandex‚Äôs best minds implemented an analogue in ClickHouse. <br><br><h4>  Slow request </h4><br>  We have a slow query - count unique users today and yesterday. <br><br><pre> <code class="plaintext hljs">SELECT uniq(user_id) FROM table WHERE dt IN (today(), yesterday())</code> </pre> <br>  Physically, we can make a SELECT for the state of yesterday, get its binary representation, save it somewhere. <br><br><pre> <code class="plaintext hljs">SELECT uniq(user_id) 'xxx' AS ts, uniqState(user id) AS state FROM table WHERE dt IN (today(), yesterday())</code> </pre> <br>  For today, we simply change the condition that it will be today: <code>'yyy' AS ts</code> and <code>WHERE dt = today()</code> and the timestamp we will call ‚Äúxxx‚Äù and ‚Äúyyy‚Äù.            ,        ,    2 . <br><br><pre> <code class="plaintext hljs">SELECT uniqMerge(state) FROM ageagate_table WHERE ts IN ('xxx', 'yyy')</code> </pre> <br><h4>   </h4><br>  : <br><br><ul><li>    ,       ; </li><li>       ; </li><li>  . </li></ul><br>         ,   -      .     <strong>    </strong> .    ,     ,  ,   ,       ClickHouse,  : ¬´,      ! ,    !¬ª <br><br><h4>     </h4><br>   ,      ,    .      <strong>  ,</strong>          .    .    ‚Äî     SQL-,       . ,        ,      . <br><br><img src="https://habrastorage.org/webt/df/0b/o6/df0bo6pb7l6t94sxnrwtpctfcxk.jpeg"><br><br>     ,   -  time series.      :      ,  ,      ,    time series. <br><br>   time series    :   ,    ,    timestamp       .        ,    ,    .              .   ,        ,       ,      ‚Äî  ,    . ,     ,   ClickHouse  -,     ,     . <br><br>      ,       ,      ClickHouse: <br><br><blockquote> ‚Äî    ¬´ ¬ª,    ‚Äî      . </blockquote><br>     time series  2 ,     20   20-80 .   .  ClickHouse   <strong>GraphiteMergeTree</strong> ,    time series,      . <br><br><h4>    </h4><br> <strong>8  ClickHouse</strong> ,   6  -  ,  2  :    2 ‚Äî     ,    . <strong>  1.8 .   </strong>  ,     <strong>500</strong> <strong>   </strong> . ,   1,8 ,       500 !       . <br><br><h3>    Hadoop </h3><br> <strong>   2 </strong> .          .     <strong>3 </strong> ,   CPU ‚Äî  <strong>4</strong> .  ,        . <br><br><h3>   Process </h3><br>     <strong>   </strong> , ,   ,        .   ,    ,    ClickHouse    3 000   . ,  ,   ,      overkill. <br><br>   ,   ,     .   ClickHouse,   <strong>   </strong> . ,  ,   ,    .   ,  8      3‚Äì4     .  ‚Äî     . <br><br><h2>  Present ‚Äî    </h2><br>      ,     ?   time series,     <strong>  time series</strong> ,           ,   ,   . <br><br><img src="https://habrastorage.org/webt/82/uo/qq/82uoqq4jw6amtxph_jgcjpjnwkm.jpeg"><br><br> <strong>Drop Detect ‚Äî    SQL</strong> :  SQL-    ,     ,      . <br><br><img src="https://habrastorage.org/webt/ru/1v/up/ru1vuporiqj-suncjyc-sh06xrk.jpeg"><br><br>     <strong>Anomaly Detection</strong> ‚Äî      .    ,  ,       2%   ,    ‚Äî   40,    ,     ,        ,    . <br><br>    ‚Äî   ,  ,   - ,    Anomaly Detection. <br><br><h3> Anomaly Detection </h3><br>  ,   time series .    : ,  ,    .   time series     <strong></strong> .  ,       ,  .    ,   <strong>drop detection</strong> ‚Äî       ,  . <br><br>     UI. <br><br><img src="https://habrastorage.org/webt/sk/mg/hn/skmghn7mirsubwu-vpm2dq5tols.jpeg"><br><br>    .  -  ,       ‚Äî  .    -,  . <br><br><h3>   Present </h3><br>    ,      ,     <strong> </strong> .     <strong> </strong>    ,   :     1000 ‚Äî alarm,     0 ‚Äî alarm.    . <br><br>   <strong>Anomaly Detection</strong>    ,    .    Anomaly Detection     <strong>Exasol</strong> ,        ClickHouse.        Anomaly Detection  2 ,   . <br><br><h2>   </h2><br>  ,  ,  4    . <br><br>  , <strong>  </strong>  ,     ,     .  , <strong>    </strong> ,      . ,  <strong>    </strong> <strong> </strong> . <br><br><blockquote>     <a href="https://www.highload.ru/">HighLoad++</a>  ,    HighLoad++    -       .        ,        , <strong>    </strong> :) <br><br>  ,    <u><a href="https://phprussia.ru/2019">PHP Russia</a></u> ,  ,       .  , ,   ,      1,8 /,     ,      1 . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/442616/">https://habr.com/ru/post/442616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442606/index.html">Domain Object with Lombok: Battle Classics</a></li>
<li><a href="../442608/index.html">The QuadrigaCX cryptobirds cold wallets, the founder of which died, were empty</a></li>
<li><a href="../442610/index.html">Telegram-bot + Google Analytics</a></li>
<li><a href="../442612/index.html">Cardboard engine for an electrical board game. As we brought it closer to reality</a></li>
<li><a href="../442614/index.html">CI / CD using Jenkins at Kubernetes</a></li>
<li><a href="../442618/index.html">Not for Selfies: Digital ELISA with a new chip embedded in a smartphone</a></li>
<li><a href="../442620/index.html">Machine learning in IT monitoring</a></li>
<li><a href="../442622/index.html">How to make Korutin in Unity a little more convenient</a></li>
<li><a href="../442624/index.html">The book "The perfect algorithm. Basics</a></li>
<li><a href="../442626/index.html">Habrarating: building a cloud of Russian-language words on the example of Habr's headlines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>