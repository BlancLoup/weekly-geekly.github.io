<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explain the effect of the last line</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microclones are duplicated, very small pieces of code ‚Äî just a few instructions or lines. In this article, we will look at the ‚Äúlast line effect‚Äù - a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explain the effect of the last line</h1><div class="post__text post__text-html js-mediator-article">  Microclones are duplicated, very small pieces of code ‚Äî just a few instructions or lines.  In this article, we will look at the ‚Äúlast line effect‚Äù - a phenomenon in which the last line or instruction in a microclone is much more likely to contain an error than previous lines or instructions.  To this end, we studied 219 open source projects and 263 warnings about defective microclones, and also surveyed six authors of real applications who made such errors in their code.  In our interdisciplinary work, we also study the psychological mechanisms that cause relatively trivial errors of this type.  Based on the results of surveys and further technical analysis, we assume that the existence of the effect of the last line is played by so-called ‚Äúsequence of actions‚Äù errors: when copying code, the attention of developers switches to other tasks due to distracting factors and the monotonous nature of this procedure.  Moreover, all the microclones, whose origin we were able to establish, were found in unusually large commits.  Knowledge of this effect has two useful consequences for programmers: <br><br>  1) it will be easier for them to recognize situations in which the probability to make a mistake in microclones is especially great; <br><br>  2) they will be able to use the automatic microclone detector / PVS-Studio, which will simplify the detection of errors of this type. <br><a name="habracut"></a><br><h2>  Keywords </h2><br>  Microclones, code clones, detection of code clones, last line effect, psychology, interdisciplinary research. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  1. Introduction </h2><br>  Software developers often have to duplicate one line of code several times in a row with minor changes, as in the following example from the TrinityCore project: <br><br>  <b>Example 1</b> <br><br>  Trinitycore <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9f1/60a/5b9/9f160a5b9b29d132d8ce25e18b98cdcd.gif" alt="officeArt object"></p><br>  The spatial coordinates of the other object are added to the fields corresponding to the x, y, z coordinates, but the last line of this fragment of three lines of the same type contains an error: the y-coordinate is added to the z-coordinate.  In fact, the last line should look like this: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e01/35f/005/e0135f0059dad007fdf4fd0218d9a3af.gif" alt="officeArt object"></p><br>  The following example is taken from the popular Chromium web browser and demonstrates the manifestation of the effect in question in the same type of instructions within a single line: <br><br>  <b>Example 2</b> <br><br>  Chromium <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/496/02e/609/49602e6096fed14e3519237361f83824.gif" alt="officeArt object"></p><br>  Instead of double checking the host for an empty string, the second check should be performed for port_str: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3c7/96b/18d/3c796b18d53105c918e3175cd6a8bb4f.gif" alt="officeArt object"></p><br>  Lines 1-3 of example 1 are similar to each other, as well as the conditions of the if-operator in line 3 of example 2. We call such extremely short code blocks consisting of almost identical repeated lines or instructions microclones.  Our own experience in developing and advising on software quality issues prompted us on an intuitive level that the last line or instruction in the microclone is much more likely to contain an error than the previous lines or instructions.  The purpose of this work is to verify the truth of our sensations, and it is precisely this goal that are responsible for two questions posed in the framework of this study: <br><br><ul><li>  <b>RQ 1</b> Is it true that the last line in a multi-line multi-line is more likely to contain an error? </li><li>  <b>RQ 2</b> Is it true that the last instruction in a one-line microclone is more likely to contain an error? </li></ul><br>  Since copying blocks of code when writing programs is used in most programming languages, practically every developer can be affected by the effect of the last line.  If we are able to prove that the last of several consecutive instructions of the same type is more prone to error, the authors and code inspectors will know which areas should be given special attention, which will help improve the quality of the program by reducing the number of errors. <br><br>  Copying and pasting is one of the natural ways of creating code like examples 1 and 2. After working to determine the origin of the code among the duplicates in the examples we selected, we came to the conclusion that developers use a number of mechanical techniques to create them, of which the most important are line-by-line copy-paste and "cloning" sections of code.  These methods are one of the most common programming idioms (Kim et al. 2004), they require minimal physical and time costs, and therefore are cheap;  besides, it is known that such code is efficient.  Although copying small sections of code is often seen as a harmful technique (Kapser and Godfrey 2008), sometimes this is the only way to implement the desired program behavior, as in the examples discussed above.  Several tools have been developed to detect and, if possible, eliminate microclones (Bellon et al. 2007; Roy et al. 2009).  Despite the fact that these tools have shown impressive results down to the level of methods, they are poorly adapted to recognize microclones in practice due to too many false positives. <br><br>  After we published an article about the effect of the last line in a popular science blog, it quickly and with great enthusiasm began to be quoted in other forums.  Many programmers agreed with our observations and suggested that there were psychological reasons behind the effect under discussion.  This is the source of our third and final question in the framework of this study: <br><br><ul><li>  <b>RQ 3</b> What are the reasons for the existence of defective microclones in general and the effect of the last row in particular? </li></ul><br>  Based on the results of surveys of developers, a thorough technical analysis of examples and cooperation with a psychologist, we will try to find out whether psychological aspects - and if so, which ones - affect the effect of the last line.  Having studied the phenomena that have been observed by cognitive psychology for a long time, we will find out whether it is possible to explain with their help the effect of the last line in microclones of the code. <br><br>  Based on our previous study of the effect of the last line (Beller and others. 2015), we made the following additions to it: <br><br><ul><li>  They introduced the term "microclone" and defined it. </li><li>  Introduced the PVS-Studio diagnostic tools used by the automatic static analysis tool (Beller 2016) to detect defective microclones that cannot be detected by traditional methods. </li><li>  We studied each mistake separately in all 263 microclones selected from 219 popular open source projects based on 1,891 warning analyzers. </li><li>  Conducted a preliminary analysis of the psychological mechanisms underlying the effect of the last line. </li><li>  We surveyed six developers of real projects that made mistakes in microclones. </li><li>  We studied the repositories of four popular open source projects based on the results of surveys, which indicated a connection between errors and anomalously large commit sizes. </li></ul><br>  Our observations show that the last line or instruction in microclones, such as those presented in examples 1 and 2, are much more likely to contain an error than any of the preceding lines or instructions.  It seems to us that the existence of this phenomenon is not due to the technical complexity of microclones, but to psychological causes, which, in turn, are mainly reduced to an overload of the short-term memory of programmers.  A preliminary study based on five projects revealed that all microclones with errors were written in abnormally large commits during non-standard working hours.  Knowledge of these features and the help of our automated static analyzer PVS-Studio can help reduce the number of trivial errors associated with the effect of the last line, by automatically detecting them. <br><br><h2>  2 Study Plan </h2><br>  Our work consists of two parts: empirical studies of C1 and C2.  In this section, we describe the order of research and their objects. <br><br><h3>  2.1 Plan of the study C1: the prevalence and predominance of the effect of the last line in the microclones </h3><br>  In the C1 study, consisting of five easily reproducible stages, we conducted a statistical analysis of the prevalence of the effect of the last line in microclones.  Moreover, in an attempt to shed light on the process of creating microclones, we did additional work on identifying the original sections of the code and their copies. <br><br><ol><li> Conduct a static analysis of the objects of study using the PVS-Studio tool with all included diagnostics.  PVS-Studio is a commercial static analyzer developed by the Russian company OOO Program Verification Systems and includes dozens of diagnostic rules ranging from detecting cloned code blocks to anti-patterns of programming using specific C library functions. Those who want to reproduce our research can use the open access with free demo version of PVS-Studio. <br><br></li><li>  Examine the PVS-Studio report and remove false positives, as well as messages not related to microclones. <br><br></li><li>  For each defective microclone, count the total number of lines of code (RQ 1) or instructions (RQ 2) and indicate in which lines or instructions an error appears.  If possible, determine the original section of the code and its copy (for example, in example 6, the original is line 2 and the copy is line 3). <br><br></li><li>  Starting the study, we default on the assumption that in a defective microclone with a length of n lines, the error probability for each line is 1 / n regardless of its number inside the fragment under consideration (null hypothesis H0).  For example, lines 1 and 2 in a block of 2 lines have the same probability of an error of 0.5.  However, if at stage (3) it is possible to show that the distribution of errors in the lines is significantly different from the uniform distribution with a level of significance <img src="https://habrastorage.org/getpro/habr/post_images/c34/4fe/d17/c344fed17f5a6a7b0ff6999090ba0f91.png" alt="officeArt object">  , we abandon the null hypothesis and assume that errors are unevenly distributed.  For each length of n lines, Pearson's consent criterion is used. <img src="https://habrastorage.org/getpro/habr/post_images/06c/77b/d56/06c77bd56df206b4162af5200e63f0a5.png" alt="officeArt object">  with a degree of freedom n - 1 to establish the correspondence between the observed data and the null hypothesis (distribution 1 / n). <br><br></li><li>  If in step (4) a significant discrepancy between the estimated and actual distributions is found, we calculate the odds ratio between them as an intuitive measure of the intensity of the last-line effect (Bland and Altman (2000)). </li></ol><br><h3>  2.2 Plan C2 study: analysis of the last line effect </h3><br>  Having established the existence of the effect of the last line in the C1 study, we must now try to identify the reasons behind it (RQ 3).  To this end, we developed an initial hypothesis based on the results of research in the field of cognitive psychology, in which Rolf Zwaan, a professor of cognitive psychology, helped us.  To confirm our hypothesis, as well as to collect evidence from the practice of developers, we interviewed the programmers responsible for creating microclones found in the course of the C1 study.  Their observations and observations will help us develop a preliminary version explaining the existence of the effect of the last line.  Narrowing the circle of respondents exclusively to those whose authorship regarding defective microclones is precisely established allows us to: (1) focus on specific examples to which respondents are directly related;  (2) to obtain the most useful answers, since we know for sure that it was these developers who were responsible for writing the microclones under discussion. <br><br>  In fig.  1 shows the general outline of our study.  The main task is to establish contact with the authors of microclones (in many cases the defective code is not in the latest version of the project).  The plan includes four main stages: <br><br><ol><li>  Projects and examples of microclones are selected at random, since the work on the C2 study is a laborious process, involving contacting the authors of the examples and conducting individual surveys.  Given that the standard share of responding to ‚Äúcold calls‚Äù is 30%, we can count on three successful surveys that should give us enough information to formulate an initial hypothesis explaining the existence of the effect of the last line in terms of cognitive psychology.  When analyzing each of the microclones, you should familiarize yourself with the development rules adopted in this project and study the repository. <br><br></li><li>  Next, we determine the location of the microclone in the project's source tree.  Since many of the errors were corrected after the publication of our earlier observations and are absent in the current thread, at this stage we are forced to apply different search strategies.  First, we study the repository, dating from the day when the C1 study was conducted.  In case of failure - for example, if the code adjacent to the microclone was refactored (or the change history was overwritten) - we use the search on the project's bug tracker to find the commit where the fix was made.  If this step does not bring results, we resort to full-text search (using the ag tool) for all commits of the project. <br><br></li><li>  When the original microclone is detected, we trace its history with the git blame tool, in order to get information about the corrections made, as well as to establish the authorship of this code. <br><br></li><li>  Finally, we‚Äôll find out the developer‚Äôs email address using the git blame -e command.  To achieve a higher response rate, we collect additional information about respondents using Internet search: this will allow us to determine the relevance of the email address.  In order to achieve the most honest answers, we guarantee the respondents that we will not disclose their personal data.  Then we send each developer an e-mail with the text of the microclone of their authorship, a history of its change / correction, the context of the error, as well as an explanation of the reason for conducting the survey and attach the questionnaire. </li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7fb/12f/ecf/7fb12fecf7adf878f5e711f9a7a19910.gif" alt="officeArt object"></p><br>  <i>Fig.</i>  <i>1 - Study Plan C2</i> <br><br><h3>  2.3 Objects of study </h3><br>  To facilitate the replication of our work by other researchers, we have preferred well-known open source projects.  Among the 219 projects studied by us in the C1 study, erroneous microclones were found in such famous projects as audio editor Audacity (1 example), web browsers Chromium (9) and Firefox (9), XML-library libxml (1), MySQL database (1) and MongoDB (1), C compiler clang (14), Quake III FPS-shooters (3) and Unreal 4 (25), Blender (4) computer graphics creation package, VTK three-dimensional modeling and visualization software ( 8), Samba (4) and OpenSSL (2) network protocols, VirtualDub (3) video editor, as well as the programming language PHP (1).  For the C2 study, we selected 10 microclones from the Chromium, libjingle, Mesa 3D and LibreOffice projects. <br><br><h3>  2.4 Notes on the reproduction of the study </h3><br>  To facilitate the work of other researchers, we have prepared a special package, which includes all the initial data and diagnostics.  It includes all unfiltered PVS-Studio messages grouped in two directories: <i>findings_old /</i> , which contains the old data used in our article for the International Conference on Visibility of Programs (ICPC) (Beller et al. 2015), and <i>findings_new /</i> with more recent data used in this article.  In addition, the package includes microclones analyzed by us and sorted according to projects ( <i>analyzed_data.csv</i> ), a spreadsheet with data <i>evaluation</i> ( <i>evaluation.ods</i> ), and the results of the analysis of repositories from studies C1 and C2.  We also added scripts in the R language to reproduce the results and diagrams from this article.  Finally, the package contains a questionnaire template with questions for respondents. <br><br><h2>  3 Methods for the detection of microclones </h2><br>  In this section, we will look at traditional methods for detecting duplicate code fragments, explain why they are not suitable for searching microclones, and show how we were able to get around this problem using our own diagnostics of static analysis.  In addition, we will show how the original sections and copies were determined in microclones and how the dimensions of commits were taken into account. <br><br><h3>  3.1 Why modern code clone detection tools are not suitable for our task </h3><br>  As examples 1 and 2 show, the code fragments considered in the framework of this article either completely coincide in the text or contain ‚Äúclones with the same syntactic structure, differing only in identifiers of variables, types or functions‚Äù (Koschke 2007).  For this reason, they are clones of 1 <i>or</i> 2 <i>types of</i> extremely small size (usually less than 5 lines / instructions) - we call them <i>microclones</i> . <br><br>  Traditional methods for detecting duplicate code are comparing tokens, lines of code, abstract syntax tree (ASD) nodes, or graphs (Koschke 2007).  However, in practice, in any of these approaches, it is required to determine the minimum clone size in conventional units of measurement (be it tokens, instructions, lines or ASD nodes) in order to reduce the percentage of false positives.  As a rule, this value is taken in the region of 5-10 units (Bellon et al. 2007; Juergens et al. 2009), which is much larger than the microclones we are considering (2-5 units) and makes it impossible to search for them. <br><br>  Thus, in example 1, lines 1-3 represent a class of microclones.  Since there are three rows, this class is presented in this example in triplicate.  In turn, each instance consists of a variable, an assignment operation, an assignable object and its field, and thus has a length of 4 units. <br><br><h3>  3.2 Methods of detection of defective microclones used by us </h3><br>  Since in practice traditional search methods are unable to reliably detect microclones, we used our own approach.  Our task is not to detect any microclones, but only those that contain errors.  Given this additional limitation, we were able to develop a whole set of powerful diagnostics that detect microclones on the basis of the usual character-by-character match.  These diagnostics are able to find defective parts of the code that most likely appeared as a result of copying small fragments.  In tab.  1 lists and describes all twelve diagnostics, which allowed to detect errors in microclones in the framework of this study.  The last column shows the ratio of single and multi-line clones to the total number of warnings of this type.  For example, the V501 diagnostic only determines whether the operands of some logical operators are identical.  If the answer is yes, then at best it‚Äôs just an extra code that can make it difficult to support the program in the future, at worst - a real mistake.  Other diagnostics are not as narrowly specialized with microclones as V501.  We studied each of the 526 warnings and selected only 272 cases of real microclones for our study.  From tab.  1, it can also be seen that 78% of microclones were detected by a single diagnosis (V501) with a very low percentage of false positives - 3%.  Other diagnostics are more likely to work on non-microclone sections of code. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d56/586/613/d565866134784da5ccb4b8cf0980e5ad.png" alt="Table 1 - Types of errors detected by PVS-Studio and their distribution among 219 open projects"></p><br>  <font color="#999999"><i><i>Table 1 - Types of errors detected by PVS-Studio and their distribution among 219 open projects</i></i></font> <br><br><h3>  3.3 How the origin of the erroneous microclones was established </h3><br>  To competently talk about the reasons for the existence of the last line effect, answering the question RQ 3, we also found in each class of microclones an original copy of the code and an instance that was supposedly copied from it.  Although such an empirical analysis does not give one hundred percent certainty that the copying procedure went in that direction, we have sufficient evidence that at least some developers mechanically clone the code in this way (see RQ 3).  In most cases, you can immediately determine which of the two copies of the microclone is the original, and which is the copy.  Thus, in example 1, line 3, containing an error, includes traces of the code from line 2, which implies the influence of line 2 (original) on line 3 (copy).  A similar natural order of the original lines and copies is observed in most microclones - be it a lexicographic order, as, for example, in the sequence of variables <i>x, y, z</i> in example 1, or numerical: <br><br>  <b>Example 3</b> <br><br>  Cmake <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aef/43f/6c4/aef43f6c448c00218c8e60a378997f8d.gif" alt="officeArt object"></p><br>  Even in cases where the natural order of the original instance and the copy is not explicitly expressed, as in Examples 1 and 3, it can be restored to the context, as in Example 2: placing <i>port_str</i> in the first place and <i>host</i> on the second in line 3 contradicts the order in which these variables were defined earlier, it means that the first <i>host! = buzz :: STR_EMPTY</i> is the original, and the second is a copy. <br><br>  In the process of establishing the origin of a copy in the examples under consideration, we face two problems, namely: 1) the size of the copied section may vary;  2) microclones longer than 4 duplicates are represented by a smaller number of examples.  In order, nevertheless, to be able to generalize the data for different sizes of microclones, for each microclone <i>i</i> we calculate <img src="https://habrastorage.org/getpro/habr/post_images/2ae/30d/eb6/2ae30deb68ce7559b0c1310de3c0a683.png" alt="officeArt object">  that gives us the degree of distance <img src="https://habrastorage.org/getpro/habr/post_images/bc3/973/a8c/bc3973a8c1364972fc64469041327460.png" alt="officeArt object">  . <br><br>  The distance 1 is about copying from the immediately preceding line / instruction, as in example 4. Meaning 0: an error occurred in the same line of the microclone.  A value of -1 indicates the reverse copying order: from the second Edinet to the first: <br><br>  <b>Example 4</b> <br><br>  UnrealEngine4 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/50f/be7/e04/50fbe7e04b91628e918320c7f97264a9.gif" alt="officeArt object"></p><br><br>  In this example, in line 1 it is natural to expect <i>cx (). IsRelative</i> instead of <i>cy (). IsRelative</i> , which suggests a possible copy from the second line.  The logic of using variables with similar names, as well as the sequence of lines 3 and 4, indicate that the copy must begin with <i>return cx (). IsRelative ()</i> in the first line. <br><br>  From here we get the degree of distance <img src="https://habrastorage.org/getpro/habr/post_images/467/5ca/6be/4675ca6be08a3513986ce4417df8bf65.png" alt="officeArt object">  or <img src="https://habrastorage.org/getpro/habr/post_images/790/cd8/7cf/790cd87cfc90069c0b8d0829e4801c33.png" alt="officeArt object">  , which indicates the immediate proximity of two duplicates either on one line or on two adjacent ones, regardless of the total size of the cloned section. <br><br><h3>  3.4 How commit sizes are taken into account </h3><br>  To calculate and present the ratio of the sizes of each of the commits containing defective microclones to the rest of the commits, we first calculate the variability for each commit in the repository.  To do this, we use the <i>git log</i> tool, which allows us to build ordered graphs of all commits (excluding merges) in the repository, thus revealing the number of added and the number of deleted lines of code in each commit.  The sum of these numbers gives the total number of rows changed, i.e.  variability for each commit.  Then we compare the variability of commits containing defective microclones with the distribution of this parameter in other commits, and in particular with its median.  Although our sample (ten examples) is too small for reliable statistical analysis, this approach still allows us to draw valid conclusions about the possible difference in the commit size.  We use the median (and not the mean, for example), because we are dealing with the wrong distributions;  the median is an independent, real value with which we compare other similar values. <br><br><h2>  4 Results </h2><br>  In this section, we examine the defective microclones in more detail by examining examples and performing a statistical evaluation. <br><br><h3>  4.1 General Description of Results </h3><br>  In tab.  2 basic statistics on the results of the study C2.  During the period from mid-2011 to July 2015, we applied the full set of diagnostics of PVS-Studio on the 219 open source projects we selected.  Andrei Karpov, who specializes in consulting on software development, carried out an analysis of all these projects, using the latest versions of PVS-Studio, available at the time of checking each specific project.  He filtered out false positives, leaving 1,891 warnings left, indicating potential defects in the code.  These warnings were grouped by 162 diagnostics.  Then we studied each message and found that 272 of them were issued by twelve diagnostics and are related to microclones.  In nine cases, the messages were duplicated, so as a result, 263 microclones remained.  Statistical analysis at the project level shows that our diagnostics were able to recognize clones with defects in half of the selected projects.  Almost all of these cases (92%) contain at least one example of the effect of the last line. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/337/b8b/120/337b8b1209db857cbe029262822142e2.png" alt="Table 2 - Statistics on the results of the study"></p><br>  <font color="#999999"><i><i>Table 2 - Statistics on the results of the study</i></i></font> <br><br>  Tab.  3 contains a summary of the errors found in 263 microclones.  In total, 74% of multi-line clones contain an error in the last line and 90% of single-line clones in the last instruction. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0b8/13c/5d0/0b813c5d069021d8bf3e67a1a56161dc.png" alt="Table 3 - Summary of the results of the study"></p><br>  <font color="#999999"><i><i>Table 3 - Summary of the results of the study</i></i></font> <br><br><h3>  4.2 Detailed results analysis </h3><br>  For a more complete understanding of the principles of operation of the diagnostics that we used to detect microclones, below we will look at some of the most illustrative examples of 263 PVS-Studio warnings related to microclones and identifying the most frequent errors from the table.  one. <br><br><h4>  4.2.1 V501 - Same Subexpressions </h4><br>  As can be seen from the table.  1, most microclone warnings were issued by the V501 diagnostic.  The following is a typical example of such an error from the Chromium browser: <br><br>  <b>Example 5</b> <br><br>  Chromium <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c68/589/475/c6858947500acf429664612f3732350b.gif" alt="officeArt object"></p><br>  This is a single-line microclone, in which the second and third subexpressions coincide completely, but at the same time are joined by the logical operator OR ( <i>||</i> ), which makes the expression redundant.   ,      ( <i>NAME_LAST</i> ) ‚Äî           . <br><br><h4> 4.2.2 V517 ‚Äî    </h4><br>  V517       if-. <br><br> <b> 6</b> <br><br> linux-3.18.1 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/59e/856/063/59e85606397d502e7aadc1241d4377ad.gif" alt="officeArt object"></p><br>   <i>else if</i>      9   ,       . ,   <i>slot</i>  0,      . <br><br><h4> 4.2.3 V519 ‚Äî     </h4><br>            (, ,     ,   ,      ),   ,           .      MTASA  <i>m_ucRed</i>   ,      <i>m_ucBlue</i>   . <br><br> <b> 7</b> <br><br> MTASA <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac9/ef0/fb7/ac9ef0fb768f4d97733c3df61e1b0628.gif" alt="officeArt object"></p><br>  V519         ¬´¬ª ,             ,     8: <br><br> <b> 8</b> <br><br> linux-3.18.10 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/afd/de5/1dc/afdde51dcb821402858805647ff0aa26.gif" alt="officeArt object"></p><br>     <i>f-&gt;fmt.vbi.samples_per_line</i>   ,            .            ,  ,     1    . ,           ,            (,  ,   )   -  .          Release:        , ,   . <br><br><h4> 4.2.4 V523 ‚Äî      </h4><br>     if-   ,    ,      <i>Haiku</i> : <br><br> <b> 9</b> <br><br> Haiku <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6e3/267/284/6e32672842f0bbc0b973f38fab2e25f5.gif" alt="officeArt object"></p><br>  , ,    <i>else</i>  <i>mpa_size</i>     -  .     ,       3 ,  ¬´    ¬ª,        . <br><br><h4> 4.2.5 V524 ‚Äî    </h4><br>           .   10   5    <i>PerPtrBottomUp.clear()</i> .      ,          <img src="https://habrastorage.org/getpro/habr/post_images/27c/550/284/27c55028447557f82e0d393b0f7e1b1e.png" alt="officeArt object">  . <br><br> <b> 10</b> <br><br> Clang <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/461/3c2/24b/4613c224b1dc9e4b0ae0798b877de3ab.gif" alt="officeArt object"></p><br><h4> 4.2.6 V537 ‚Äî      </h4><br>    V537,  ,   Quake III.    PVS-Studio      <i>rectf.X</i> : <br><br> <b> 11</b> <br><br> Quake III <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/de4/bd8/87c/de4bd887cec524ff6ec7fc0560f398a3.gif" alt="officeArt object"></p><br>   (.. )    y-      <i>rectf.X</i> . <br><br><h4> 4.2.7 V656 ‚Äî      </h4><br>  V656   ,       .         ,         .       ,         ,  ,   ,  .    ,    V656,    LibreOffice. <br><br> <b> 12</b> <br><br> LibreOffice <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/528/920/825/528920825472dac403d3a78bc67c5054.gif" alt="officeArt object"></p><br>     <i>maSelection.Max()</i>    <i>aSelection</i>  ,     . <br><br><h4> 4.2.8  </h4><br>       12,            .    Chromium ‚Äî   12 ,         (. . 4): <br><br> <b> 13</b> <br><br> Chromium <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6e4/344/009/6e43440099680cf23f5ed611d461fe3f.gif" alt="officeArt object"></p><br>   2  <i>data_[M02]</i>    ,      : <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/516/989/3da/5169893da7798cb7b006df18cf225f2b.gif" alt=" 4 -      ??  2 "></p><br> <font color="#999999"><i><i> 4 ‚Äî      ?? 2 </i></i></font> <br><br><h3> 4.3   </h3><br>  . 4       158  ,   . 5 ‚Äî         105  .        . ,    2        .    ,   ,       . <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d2f/328/164/d2f328164b0f3314f22c47a08cd3a1db.gif" alt=" 5 -     "></p><br> <font color="#999999"><i><i> 5 ‚Äî     </i></i></font> <br><br>    . 4  5      <img src="https://habrastorage.org/getpro/habr/post_images/3af/dbb/1a7/3afdbb1a741c9cdcec03308ac5435537.png" alt="officeArt object">    p = 0,05,  ,     .    p-,            ,         .      2-6 . 4   2-4 .  five. <br><br>    RQ1  RQ2,     p-    2, 3, 4, 5  6      2, 3  4  (p &lt; 0,05).     ,         /     .             .  ,          ,        ,     .           . 4  5. <br><br>         : ¬´ <i></i>   /¬ª  ¬´   /¬ª (. . 3).    ,   ,   1,        ,       .    . 4,         2, 4  5  (  )         .        ,    2,  :       9,5  ,       .           72 ,  . <br><br>  ,  ,          /,       RQ 1  RQ 2. <br><br><h3> 4.4   </h3><br>      ,   ,   ,          .  RQ 3    : <br><br><ul><li> <b>RQ 3</b>            ? </li></ul><br>        ,          . <br><br>  . 6             .      ,           .  ,  263    245. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b7b/19f/76e/b7b19f76e32beaaadd872b1d572dbd0d.gif" alt=" 6 -   ( )     ( )"></p><br> <font color="#999999"><i><i> 6 ‚Äî   ( )     ( )</i></i></font> <br><br>  In fig. 2          .    ,  165   245 (67%)    .        ‚Äî 18 %,        (9%)    (3%).    4%        .  ,   ,   ,         . ,       :  ,         .          117      /, ,          33  (28%).      4,9 ,  ,       20% ,     .    28%   ,          ,     .   ,           ,   . <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7e7/7db/8de/7e77db8de9ad52f0a2db5e2bf861c280.gif" alt="officeArt object"></p><br><br>  <i>Fig.</i> <i>2 ‚Äî      ()         ()</i> <br><br>  In fig. 2   ,        <img src="https://habrastorage.org/getpro/habr/post_images/d35/1f3/a58/d351f3a58265505996799b051eeca319.png" alt="officeArt object"> (.  3.3).  ,  84%        (220   245), .. <img src="https://habrastorage.org/getpro/habr/post_images/2ad/595/443/2ad595443b7df9a7fc201c96c96ac90d.png" alt="officeArt object"><br><br>  89%   (195  220) <img src="https://habrastorage.org/getpro/habr/post_images/5fa/a98/075/5faa9807590a60123ff49ca6a0c20b70.png" alt="officeArt object">  or <img src="https://habrastorage.org/getpro/habr/post_images/5fa/a98/075/5faa9807590a60123ff49ca6a0c20b70.png" alt="officeArt object">  .  ,            .     , .. <img src="https://habrastorage.org/getpro/habr/post_images/612/d5c/c48/612d5cc48eb6f6eaf8f9dc6cbb6478ad.png" alt="officeArt object"> (3   220).          ,       , ,   81%         (66  81).  ,       : <br><br><ol><li>           .       ,          . </li><li> ,             .  ,          . </li></ol><br><h3> 4.5   </h3><br>    C2      ,        .           .    ,     : <br><br><ol><li>       (..    ). </li><li>      . </li><li>   ,      . </li><li>             . </li></ol><br> . 7          ,  .           Skype.         ,   ,     ,    ,       .      <i>I1-I7</i>     ID-         .  ,        ,     -    .          .  <i>I1, I2, I4, I6</i>  <i>I7</i>   .        ,         . <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d78/0ae/282/d780ae282829b55319ba44c128154572.png" alt=" 7 -           6.10.2016"></p><br> <font color="#999999"><i><i> 7 ‚Äî           6.10.2016</i></i></font> <br><br>    ,        .     ,   ,    ,       .     <i>7b37fbb</i>  I1 ,           (    . 7    ),      ,      ( <i>6b7fcb4</i> ). <br><br>  I1     : <br><br> <b> 14</b> <br><br>   I1 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/977/1ae/5ab/9771ae5ab9f8a9c3c929b9a31c373222.gif" alt="officeArt object"></p><br>   ,       -,   ,      <i>!has_mic</i>  <i>!has_audio</i> .   ,   ,       .  ,  ¬´  -      ¬ª,  ,    ¬´        ,      ¬ª.   ,      -      ,  ,   ,      <i>!a &amp;&amp; !a</i> . <br><br>  <i>I4</i> ,      ,     ,   ,     : <br><br> <b> 15</b> <br><br>   I4 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d80/100/c2f/d80100c2fb2a02e19f174ef713a6ac4f.gif" alt="officeArt object"></p><br><br>   ,      <i>field.type == trans(¬´string¬ª) ||,</i>        ,       : <br><br> <b> 16</b> <br><br>   I4 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/32f/c3c/a90/32fc3ca90c9663abaeffb59d26f54e69.gif" alt="officeArt object"></p><br><br>  He said that "he does not count the exact number of repetitions, but he does it by eye."  At the last stage of editing, the respondent deletes all unnecessary lines, but in this case he apparently forgot to do it or was distracted by something.  Determining the source line in this code (see Section 3.3), we also found that it was refactored twice, but the error was not corrected.  This happened because the developers relied on automatic edits and did not read the code with due care.  In conclusion, I4 reported that he often uses these techniques to create microclones, "but rarely forgets to delete extra lines."  Like the respondent I1, he concluded that such places should be identified by a code review or tests. <br><br>  Respondent I6 responded that ‚Äúa lot of time has passed since writing, but [...] this code looks like a copy and paste error, which is not uncommon‚Äù.  He also said that "every now and then he encounters this technique and uses it himself."  To speed up the development process and once again not to write code manually, I6 creates microclones using copy-paste, and then makes the appropriate edits to each of the copied lines.  "I missed the last line."  The respondent explained that he forgot to change the last duplicate in the microclone because ‚ÄúI began to think about less automatic tasks, and as a result, the quality of the automatic task was affected‚Äù.  Although respondent I6 was unable to recall the circumstances of that day, he argues that in their company, the developers "always try to write code quickly so that program improvements appear immediately."  He also said that he was confronted with microclones "constantly", at least a dozen times a day.  ‚ÄúOf these ten cases, about nine are caught in the process of self-review of the code or using the compiler.  The tenth is mostly detected by other programmers or unit tests.  But sometimes, about once a month [...], errors of this kind penetrate release versions and manifest themselves among end users. ‚Äù <br><br>  Respondent I7 is the author of the following microclone: <br><br>  <b>Example 17</b> <br><br>  Anonymous respondent I7 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/81b/8c4/5a4/81b8c45a46d56fd320599d6fccfc6786.gif" alt="officeArt object"></p><br><br>  According to his recollections, he ‚Äújust typed this line, without using copying and pasting,‚Äù and missed the error because, ‚Äúapparently, he was in a hurry and inattentively read the code‚Äù.  Although the respondent could not recall the exact date of the creation of this commit, he noted that ‚Äúthere is almost always a lot of work‚Äù. <br><br>  From the survey results, it can be concluded that the size of commits is one of the factors due to which a defective microclone is more likely to avoid detection by various means and defense mechanisms mentioned by respondents.  If this assumption is true, then the commits that carry such microclones must be abnormally large.  The definition of ‚Äúabnormally large‚Äù indicates a relative value and makes sense only when comparing commits within the repository.  Taking this into account, we compared the sizes of commits with defective microclones with the median size of the commit for each project, which is reflected in Fig.  3. The data obtained show that in all cases the size of commits with defective microclones is several orders of magnitude higher than the median. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/503/13c/952/50313c952b87e882f2f837a4416cf0e0.gif" alt="officeArt object"></p><br><br>  <i>Fig.</i>  <i>3 - The median of the commit size for the entire repository history (blue dashed line) and the size (expressed by the variability on a logarithmic scale) of commits with defective microclones (orange dashed line)</i> <br><br><h3>  4.6 Usefulness of results </h3><br>  Having discovered a lot of potential errors in open source projects, we wanted to help the open source development community and verify that the authors find the errors we find significant enough to correct them.  To do this, we posted our comments in the project tracker bug.  As a result, many of our messages were taken into account and led to an increase in the quality of the project code.  So, the verification error in Example 2 (Chromium project) was fixed.  Search query <i>pvs-studio bug |</i>  <i>issue</i> issues reports of numerous edits in Firefox, libxml, MySQL, Clang, samba and many other projects, aided by the results of our research.  As an example, we can take the case when, on October 11, 2016, at the caff670 <i>commit,</i> we fixed a defective microclone that had existed in the samba code since 2005. <br><br><h2>  5 Analysis of research results </h2><br>  In this section, we will combine the information we collected about error patterns and data on the psychological mechanisms underlying them.  In conclusion, we consider possible factors that threaten the validity of our findings. <br><br><h3>  5.1 Technical complexity and other technical reasons for the effect of the last line </h3><br>  As a possible technical reason for the effect of the last line, one might suspect a higher technical complexity of the last line as compared to the other lines and, as a result, a greater susceptibility to errors.  For example, the compiler may skip the last line when checking or fail to check it in time when the code is written in the IDE window and the last line of the microclone is also the last line in the current code editor window.  However, these considerations are wrong for the following reasons: <br><br><ol><li>  Modern IDEs, as a rule, are not subject to delays in syntax checking. </li><li>  The last line or instruction in the microclone is correct in terms of syntax, i.e.  the compiler cannot issue a warning that would draw the programmer's attention to the problem. </li></ol><br>  On the other hand, including IDEs and diagnostic compilers for detecting microclones could make it easier to find errors before they get into a commit. <br><br>  Another technical reason could be related to the fact that in the sequence of several instructions the last of them is more difficult to formulate than the others.  However, as examples 1, 2, 5, 7 and 11 show, the opposite is true: since all duplicates are built according to one pattern, only the very first of them can be the most complex, i.e.  the original, while all subsequent ones are just copies of it. <br><br><h3>  5.2 Psychological mechanisms and causes </h3><br>  Since it is doubtful that the existence of the last line effect is due to technical reasons, it is necessary to consider the psychological mechanisms that may underlie it.  For consultation, we turned to a professor of cognitive psychology (the fourth author of this article) and presented our observations to him.  At this stage, our conclusions are preliminary, since a more thorough study would require a psychological experiment, where we could directly observe the process of making mistakes, which cannot be reconstructed from the results of the analysis of the origin of defective duplicates (see section 3.3) and the respondents' memories (see section 4.5). <br><br>  In cognitive psychology, errors in the sequence of actions are those errors that occur when performing routine operations.  This type of error has been extensively studied by experts (Anderson 1990).  A typical example of such an error is when you add milk to coffee twice, instead of pouring milk once and then putting sugar.  As shown by the results of analysis of the origin of microclones, developers use a whole arsenal of various mechanical methods and algorithms when copying code.  One of these algorithms is: "[write original fragment], [copy original], [copy original], ..., [edit copy], [edit copy], ..." (see polls I4, I6).  Along with it, an algorithm is applied: "[write original fragment], [copy original, edit copy], [copy original, edit copy], ..." In some limiting cases, in our data set, this algorithm seems to be repeated up to 34 times .  Despite the fact that when writing microclones different methods are used, they all boil down to a sequence of actions with a different ratio of automatic and conscious operations.  Thus, from the point of view of cognitive psychology, errors made by developers in microclones are typical errors in the sequence of actions. <br><br>  Despite differences in the details, all patterns of sequence control agree that cognitive noise seems to be the main cause of errors of this kind (Botvinick and Plaut 2004; Cooper and Shallice 2006; Trafton et al. 2011).  Noise in this case means any events that are not related to the current task and distract the attention of the programmer.  Noise can be generated by stress caused by external causes, for example, restrictions on the timing of the task, or internal, for example, large commit.  Sequence control models provide a useful theoretical framework that allows you to speculate about the possible psychological mechanisms underlying the last line effect.  At this stage, we have only specific examples of microclones and information about their location in the code, but do not know the details of their occurrence.  Nevertheless, as shown in section 4.4, the answers of the interviewed developers and the results of the analysis of the origin of microclones allow us to draw reasonable conclusions about how they appear.  Copying and editing are basic operations performed by the programmer when writing code.  Let us look again at example 1. The editing operation here consists of two smaller steps: editing the variable name and editing the value. <br><br>  <b>Example 1</b> <br><br>  Trinitycore <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9f1/60a/5b9/9f160a5b9b29d132d8ce25e18b98cdcd.gif" alt="officeArt object"></p><br><br>  The error is in line 3. Apparently, this line was created by copying line 2. The first replacement was successful (the variable name was changed from <i>y</i> to <i>z</i> ), but the second step - editing the value - was skipped, which led to an error.  Theoretically, this code could have been created by double-copying line 1 and then editing the duplicates received.  However, the name of the variable <i>y</i> instead of <i>x</i> in line 3 gives us reason to believe that the second line was copied.  As shown in section 4.4, in most microclones longer than two lines, usually the preceding line is copied.  It follows that in such cases the algorithm was applied: "[copy, edit, edit], [copy, edit, edit], ..." <br><br>  According to the sequence control models, errors of this type are due to cognitive noise, which is most likely to occur near the end of a series of similar operations, because the programmer's attention switches to the next task prematurely, for example, writing new code (see survey I6).  As already mentioned, there are several slightly different versions explaining the causes of cognitive noise.  As an example, we present a version (Cooper and Shallice 2006) explaining the effect of the last line by choosing the wrong action plan (for example, the developer has already mentally moved on to the next lines, instead of focusing on the completion of the current fragment). <br><br>  Although none of the programmers interviewed complained about the excessively high level of stress while writing microclones, the testimonies of respondents I6 and I7 differ from the rest: they noted a high workload in general and a desire to move faster in writing code.  Analysis of the local creation time of commits with defective microclones according to the table.  7 shows that only two of them were created during the required working hours, while the rest of the programmers worked on the code at an inopportune time, although they did it on duty.  As you know, fatigue reduces the efficiency of the brain and affects the short-term memory (Kane et al. 2007).  Perhaps it is fatigue and haste that play a significant role in the appearance of defective microclones. <br><br>  In addition, we found that all commits (including refactoring) with defective microclones are extremely large in size, by orders of magnitude larger than the standard commit sizes in their repositories.  This gives us the idea that the size of a commit is an important, if not the key factor that provokes cognitive noise, due to which errors go unnoticed.  This conclusion is in good agreement with the version of short-term memory overload, as well as with the respondent I1's remark that the final code is very difficult to control due to the large volume. <br><br>  Surveys show that short-lived defective microclones are a widespread phenomenon in software development, but they usually come to light at the early stages or, at least, during the code review process, conducted independently or with the help of colleagues (Beller et al. 2014).  Thus, the cognitive error observed in the remaining, uncorrected microclones is not only a programming error, but also a review error (Healy 1980) and is that during the review of the code, the developer does not notice the defect in the last and other lines.  In fact, our polls show that, in all likelihood, in microclones caught in commits, such an error was made twice: once when the code was reviewed by the author and at least once again when the colleague was reading.  The appearance of an error in the last line is more likely than in previous ones, probably due, among other things, to the fact that it is an error in the sequence of actions.  The person mentally switches to the next task (for example, writing the next part of the code), without having finished the current one (review).  Another explanation suggests that the error is less noticeable due to the following instructions of the same type: the reviewer reads the last of them faster and therefore less carefully.  Moreover, the visual similarity of the original copy and the copy may make it difficult to perceive individual lines.  The study of code review problems shows that the similarity of fragments (manifested in the frequency of repetition of words) leads to the fact that the reviewer spends less time reading, and this negatively affects his ability to recognize errors in the text (Moravcsik and Healy 1995). <br><br>  All potential factors for the manifestation of the effect of the last line are associated with an increased probability of making mistakes of this kind in situations where the programmer‚Äôs attention is reduced due to cognitive noise.  The probable causes of its occurrence may, first of all, be associated with large commits, high workload, stress, distractions and fatigue (O'Malley and Gallas 1977).  Conversely, our observations show that the ability of developers to control their reaction to extraneous noise (Fukuda and Vogel 2009), i.e.  the ability to focus on a task greatly affects the probability of a microclone to appear with an error in the sequence of actions. <br><br><h3>  5.3 Factors threatening the validity of the research results </h3><br>  In this section, we will consider the internal and external threats to the validity of our results, and also show how we have reduced their influence to a minimum. <br><br><h4>  5.3.1 Internal factors </h4><br>  One of the main internal factors is to correctly determine which line contains the error.  So, in example 2, any of the two instructions can be taken as a copy.  However, reading and writing code usually occurs from top to bottom and from left to right (Siegmund et al. 2014).  Therefore, it is natural and only correct to assume that the arrangement of errors in lines and instructions follows the same order: in Example 2, we can understand that the second instruction is a copy of the first one only after reading it, therefore we mark the second instruction as defective.  Further, in many cases, as in this example, the closest context of the microclone (in example 2, the <i>host</i> variable is declared first and then <i>port_str is</i> declared) sets the natural order for the rest of the program text (check <i>host</i> first, then <i>port_str</i> in line 3) .  To minimize the potential impact of researchers bias, the data were distributed for independent processing between the first two authors, and the controversial cases were discussed together.  If it was not possible to agree on any result, it was discarded.  In the course of the work, we also re-classified all 202 results of the earlier study (Beller et al. 2015) and found that they are almost entirely consistent with previous findings.  Since the procedure for marking the defective lines in these circumstances is regulated in detail, we are sure of a high degree of mutual correspondence between the assessments of each expert, which guarantees the reproducibility of our research. <br><br>  It is possible that our diagnostics do not detect all defective microclones.  This factor is only a minor threat, since we do not claim to detect all errors of this type.  We believe that we were able to find most of the microclones by expanding the number of diagnostics to 12 (see Table 1).  This is confirmed by the fact that most of the errors were found by just a few key diagnostics: V501, V517, V519 and V537;  and also the fact that van Tonder and Le Gu found more than 24,000 erroneous microclones using the abbreviated set of our diagnostics (van Tonder and Le Goues 2016). <br><br>           ,   ,       .           ,    ‚Äî  .  ,   ¬´¬ª               ,        (Busjahn  . 2015; Siegmund  . 2014).   ,     ,   ,         , ..     .  ,      : 1)        ¬´ctrl+c, ctrl+v¬ª? 2)      ? 3)            ?     ,     ,          ¬´  ¬ª,  ,     WatchDog (Beller  . 2015, 2015, 2016).           CloneBoard,      ,     Eclipse (de Wit  . 2009). <br><br>                  .       ,            .         ,    -     .   ,  ,   ,      ,     ,     ,           .  ,    ,               ,     (Adair 1984),  ,        .   ,     ,    ,  ,                 . <br><br><h4> 5.3.2   </h4><br>        ,   PVS-Studio     C  C++. C ‚Äî       (Meyerovich and Rabkin 2013),          , ,   ,     C  C++ .   ,    ,    : , if-,     (.  1, 2, 5, 7  11).             ,      C: Java, JavaScript, C#, PHP, Ruby  Python.       ,      ?1,2 ,    (. . 2).       ,   PVS-Studio,   ,    ,   ,       ,              .       :           ,    . <br><br><h2> 6     </h2><br>          ¬´ ¬ª,            (Roy  . 2014).       : ¬´  ‚Äî   ,      -  ¬ª (Baxter  . (1998))  ¬´  ‚Äî [...]    ,   ¬ª (Basit and Jarzabek (2007)).         ,     ,         .   ,        (Koschke 2007).  1   ,   2      (  ).  3      ,   4        (Roy  . 2014).   ,        .          (Koschke 2007; Balazinska  . 1999; Kapser and Godfrey 2003).          : ,      ,      ¬´ ¬ª,             .        . <br><br>           .     2007           .        C  Java (Bellon  . 2007).               25 .  2014       ,             (Svajlenko and Roy 2014).         50 , 15   15  (Svajlenko and Roy 2014).        . ,       ,     .            . <br><br>     (Beller  . 2015)           380 125     Java (van Tonder and Le Goues 2016)   24 304  ,     ,      .    43     ,      .   ,                 . <br><br>           ,      ,  ,    9%  17% (Zibran  . 2011),    1, 2  3 (Koschke 2007).     ¬´ ¬ª     5% (Roy and Cordy 2007)   50% (Rieger  . 2004; Roy  . 2014).     , ,   ,            .       ,        ‚Äî   ,     ¬´ ¬ª. ,      ,    ,          . (Chatterji  . 2011; Gode and Koschke 2011; Inoue  . 2012; Xie  . 2013). <br><br><h2> 7     </h2><br>          ,       . <br><br>       ,    ,        .       ,       ,       .          .      ,     ,              .           IDE:       . <br><br>                  ,  , ,   ,   ,       .         . <br><br>  219  ,     263   .   ,               ‚Äî   .        .           ,       ,       ‚Äî    ,       . <br><br>    ,   ,     ,           -   ,   .    ,           - . ,               , -     .       , -,     ,      . <br><br>     ,        , ,         ,         .  ,    ,         ,        ,    .              ,     ;  ,          -   ,   ,   .   PVS-Studio    ,          , ,    . <br><br><h2>  Notes </h2><br><ol><li> <u>TrinityCore ‚Äî          - (MMOG), <a href="http://www.trinitycore.org/">www <u>.</u> trinitycore <u>.</u> org</a> .</u> </li><li> <u>Chromium ‚Äî   Google Chrome, <a href="http://www.chromium.org/">www.chromium.org</a> .</u> </li><li> <a href="http://www.viva64.com/ru/b/0260">http://www.viva64.com/ru/b/0260</a> </li><li> <a href="http://www.reddit.com/r/programming/comments/270orx/the_last_line_effect">www.reddit.com/r/programming/comments/270orx/the_last_line_effect</a> </li><li> <a href="http://www.viva64.com/ru/pvs-studio-download">http://www.viva64.com/ru/pvs-studio-download</a> </li><li> <a href="http://dx.doi.org/10.6084/m9.figshare.1313697">10.6084/m9.figshare.1313697</a> </li><li> <u>               .     ,     .</u> </li><li> <u>   : <a href="http://viva64.com/ru/d/0368/">http://viva64.com/ru/d/0368/</a> .</u> </li><li> <a href="https://codereview.chromium.org/7031055">https <u>://</u> codereview <u>.</u> chromium <u>.</u> org <u>/7031055</u></a> </li><li> <a href="http://www.google.com/search%3Fq%3Dpvs-studio%25252Bbug%25252B%25257C%25252Bissue">www <u>.</u> google <u>.</u> com <u>/</u> search <u>?</u> q <u>=</u> pvs <u>-</u> studio <u>+</u> bug <u>+|+</u> issue</a> </li><li> <a href="https://bugzilla.samba.org/show_bug.cgi%3Fid%3D12373">https <u>://</u> bugzilla <u>.</u> samba <u>.</u> org <u>/</u> show <u>_</u> bug <u>.</u> cgi <u>?</u> id <u>=12373</u></a> </li><li> <u> Clang     . : <a href="https://llvm.org/bugs/show_bug.cgi%3Fid%3D9952">https <u>://</u> llvm <u>.</u> org <u>/</u> bugs <u>/</u> show <u>_</u> bug <u>.</u> cgi <u>?</u> id <u>=9952</u></a> .</u> </li></ol><br><h2>  Thanks </h2><br>                   ICSE'15  ¬´Mercato Centrale¬ª,    ,         . <br><br><div class="spoiler">  <b class="spoiler_title">Bibliography</b> <div class="spoiler_text"> Adair JG (1984) Reconsideration of the methodological artifact.  J Appl Psychol 69 (2): 334-345 <a href="">CrossRef</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DThe%2520Hawthorne%2520effect%253A%2520a%2520reconsideration%2520of%2520the%2520methodological%2520artifact%26amp%3Bauthor%3DJG.%2520Adair%26amp%3Bjournal%3DJ%2520Appl%2520Psychol%26amp%3Bvolume%3D69%26amp%3Bissue%3D2%26amp%3Bpages%3D334-345%26amp%3Bpublication_year%3D1984">Google Scholar</a> <br><br>  Anderson JR (1990) Cognitive psychology and its implications.  WH Freeman / Times Books / Henry Holt &amp; Co <br><br>  Balazinska M, Merlo E, Dagenais M, Lague B, Kontogiannis K (1999) Measuring clone based reengineering opportunities.  In: Proceedings of the international software metrics symposium (METRICS).  IEEE, pp 292-303 <br><br>  Basit HA, Jarzabek S (2007) Efficient token based clone detection with flexible tokenization.  In: Proceedings of the 6th joint meeting of the European Conference and the European Conference of the Commonwealth of Independent States on the foundations of software engineering (ESEC / FSE).  ACM, pp 513-516 <br><br>  Baxter ID, Yahin A, de Moura LM, Sant'Anna M, Bier L (1998) Clone detection using abstract syntax trees.  In: Proceedings of the international conference on software maintenance (ICSM).  IEEE, pp 368-377 <br><br>  Beller M, Bacchelli A, Zaidman A, Juergens E (2014) Modern projects in open-source projects: Which problems do they fix?  In: Proceedings of the 11th working conference on mining software repositories.  ACM, pp 202-211 <br><br>  Beller M, Bholanath R, McIntosh S, Zaidman A (2016) Analyze a large-scale evaluation of open source software.  In: Proceedings of the 23rd IEEE international conference on software analysis, evolution, and reengineering.  IEEE, pp 470-481 <br><br>  Beller M, Gousios G, Panichella A, Zaidman A (2015) (ID).  In: Proceedings of the 10th joint meeting of the ACM SIGSOFT software on the foundations of software engineering (ESEC / FSE).  ACM <br><br>  Beller M, Gousios G, Zaidman A (2015) How (much) do developers test?  In: 37th International conference on software engineering (ICSE).  ACM, pp 559-562 <br><br>  Beller M, Levaja I, Panichella A, Gousios G, Zaidman A (2016) How to catch 'em all: watchdog  In: 3rd International workshop on software engineering (SER &amp; IP 2016).  IEEE, pp. 53-56 <br><br>  Beller M, Zaidman A, Karpov A (2015) The last line effect.  In: 23rd International conference on program comprehension (ICPC).  ACM, pp 240-243 <br><br>  Bellon S, Koschke R, Antoniol G, Krinke J, Merlo E (2007) Comparison and Evaluation of Clone Detection Tools.  IEEE Trans Softw Eng 33 (9): 577-591 <a href="http://dx.doi.org/10.1109/TSE.2007.70725">CrossRef</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DComparison%2520and%2520evaluation%2520of%2520clone%2520detection%2520tools%26amp%3Bauthor%3DS.%2520Bellon%26amp%3Bauthor%3DR.%2520Koschke%26amp%3Bauthor%3DG.%2520Antoniol%26amp%3Bauthor%3DJ.%2520Krinke%26amp%3Bauthor%3DE.%2520Merlo%26amp%3Bjournal%3DIEEE%2520Trans%2520Softw%2520Eng%26amp%3Bvolume%3D33%26amp%3Bissue%3D9%26amp%3Bpages%3D577-591%26amp%3Bpublication_year%3D2007">Google Scholar</a> <br><br>  Bland JM, Altman DG (2000) The odds ratio.  Bmj 320 (7247): 1468 <a href="">CrossRef</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DThe%2520odds%2520ratio%26amp%3Bauthor%3DJM.%2520Bland%26amp%3Bauthor%3DDG.%2520Altman%26amp%3Bjournal%3DBmj%26amp%3Bvolume%3D320%26amp%3Bissue%3D7247%26amp%3Bpages%3D1468%26amp%3Bpublication_year%3D2000">Google Scholar</a> <br><br>  Botvinick M, Plaut DC (2004) Doing without schema hierarchies: a recurrent connectionist approach 111: 395-429 <br><br>  Busjahn T, Bednarik R, Begel A, Crosby M, Paterson JH, Schulte C, Sharif B, Tamm S (2015) Eye movements.  In: Proceedings of International Conference on Program Comprehension (ICPC).  ACM, pp 255-265 <br><br>  Chatterji D, Carver JC, Massengil B, Oslin J, Kraft N, et al. (2011).  In: Proceedings of the international symposium on empirical software engineering and measurement (ESEM).  IEEE, pp 20-29 <br><br>  Cooper R, Shallice T (2006) Hierarchical schemas and vol 113 <br><br>  de Wit M, Zaidman A, van Deursen A (2009) Managing code clones using dynamic change tracking and resolution.  In: Proceedings of the international conference on software maintenance (ICSM).  IEEE, pp 169-178 <br><br>  Fukuda K, Vogel EK (2009) Human variation in overriding attentional capture.  J Neurosci 29 (27): 8726-8733 <a href="">CrossRef</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DHuman%2520variation%2520in%2520overriding%2520attentional%2520capture%26amp%3Bauthor%3DK.%2520Fukuda%26amp%3Bauthor%3DEK.%2520Vogel%26amp%3Bjournal%3DJ%2520Neurosci%26amp%3Bvolume%3D29%26amp%3Bissue%3D27%26amp%3Bpages%3D8726-8733%26amp%3Bpublication_year%3D2009">Google Scholar</a> <br><br>  Gode ‚Äã‚ÄãN, Koschke R (2011) Frequency and clones.  In: Proceedings of the international conference on software engineering (ICSE).  ACM, pp 311-320 <br><br>  Healy AF (1980) Proofreading errors.  J Exper Psychol Human Percep Perform 6 (1): 45 <a href="">CrossRef</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DProofreading%2520errors%2520on%2520the%2520word%2520the%253A%2520new%2520evidence%2520on%2520reading%2520units%26amp%3Bauthor%3DAF.%2520Healy%26amp%3Bjournal%3DJ%2520Exper%2520Psychol%2520Human%2520Percep%2520Perform%26amp%3Bvolume%3D6%26amp%3Bissue%3D1%26amp%3Bpages%3D45%26amp%3Bpublication_year%3D1980">Google Scholar</a> <br><br>  Inoue K, Higo Y, Yoshida N, Choi E, Kusumoto S, Kim K, Park W, Lee E (2012) Experience of finding inconsistently bugs in mobile phone software.  In: Proceedings of the international workshop on software clones (IWSC).  IEEE, pp 94-95 <br><br>  Juergens E, Deissenboeck F, Hummel B, Wagner S (2009) Do code clones matter?  In: Proceedings of the international conference on software engineering (ICSE).  IEEE, pp 485-495 <br><br>  Kane MJ, Brown LH, McVay JC, Silvia PJ, Myin-Germeys I, Kwapil TR (2007).  Psychol Sci 18 (7): 614-621 <a href="">CrossRef</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DFor%2520whom%2520the%2520mind%2520wanders%252C%2520and%2520when%2520an%2520experience-sampling%2520study%2520of%2520working%2520memory%2520and%2520executive%2520control%2520in%2520daily%2520life%26amp%3Bauthor%3DMJ.%2520Kane%26amp%3Bauthor%3DLH.%2520Brown%26amp%3Bauthor%3DJC.%2520McVay%26amp%3Bauthor%3DPJ.%2520Silvia%26amp%3Bauthor%3DI.%2520Myin-Germeys%26amp%3Bauthor%3DTR.%2520Kwapil%26amp%3Bjournal%3DPsychol%2520Sci%26amp%3Bvolume%3D18%26amp%3Bissue%3D7%26amp%3Bpages%3D614-621%26amp%3Bpublication_year%3D2007">Google Scholar</a> <br><br>  Kapser C, Godfrey M (2003) A taxonomy of the clones in the most wanted list.  In: 2nd International workshop on detection of software clones (IWDSC-03), vol 13 <br><br>  Kapser CJ, Godfrey MW (2008) Cloning considered harmful-patterns in software.  Emp Softw Eng 13 (6): 645-692 <a href="http://dx.doi.org/10.1007/s10664-008-9076-6">CrossRef</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DCloning%2520considered%2520harmful%25E2%2580%2593considered%2520harmful%253A%2520patterns%2520of%2520cloning%2520in%2520software%26amp%3Bauthor%3DCJ.%2520Kapser%26amp%3Bauthor%3DMW.%2520Godfrey%26amp%3Bjournal%3DEmp%2520Softw%2520Eng%26amp%3Bvolume%3D13%26amp%3Bissue%3D6%26amp%3Bpages%3D645-692%26amp%3Bpublication_year%3D2008">Google Scholar</a> <br><br>  Kim M, Bergman L, Lau T, Notkin D (2004) An ethnographic study of paste and paste programming practices in oopl.  In: Proc.  International symposium on empirical software engineering (ISESE).  IEEE, pp 83-92 <br><br>  Koschke R (2007) Survey of research on software clones.  In: Koschke R, Merlo E, Walenstein A (eds) Duplication, redundancy, and similarity in software, no.  06301 in Dagstuhl seminar meetings.  Internationales Begegnungs- und Forschungszentrum fur Informatik (IBFI).  <a href="http:/drops.dagstuhl.de/opus/volltexte/2007/962/">https://web.archive.org/web/20161024110147/http://drops.dagstuhl.de/opus/volltexte/2007/962/</a> .  Schloss Dagstuhl, Dagstuhl <br><br>  Meyerovich L, Rabkin A (2013) Empirical analysis of programming language adoption.  In: ACM SIGPLAN notices, vol 48. ACM, pp 1-18 <br><br>  Moravcsik JE, Healy AF (1995) Effect of meaning on letter detection.  J Exper Psychol Learn Memory Cogn 21 (1): 82 <a href="">CrossRef</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DEffect%2520of%2520meaning%2520on%2520letter%2520detection%26amp%3Bauthor%3DJE.%2520Moravcsik%26amp%3Bauthor%3DAF.%2520Healy%26amp%3Bjournal%3DJ%2520Exper%2520Psychol%2520Learn%2520Memory%2520Cogn%26amp%3Bvolume%3D21%26amp%3Bissue%3D1%26amp%3Bpages%3D82%26amp%3Bpublication_year%3D1995">Google Scholar</a> <br><br>  O'Malley JJ, Gallas J (1977) Noise and attention span.  Percep Motor Skills 44 (3): 919-922 <a href="">CrossRef</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DNoise%2520and%2520attention%2520span%26amp%3Bauthor%3DJJ.%2520O%25E2%2580%2599Malley%26amp%3Bauthor%3DJ.%2520Gallas%26amp%3Bjournal%3DPercep%2520Motor%2520Skills%26amp%3Bvolume%3D44%26amp%3Bissue%3D3%26amp%3Bpages%3D919-922%26amp%3Bpublication_year%3D1977">Google Scholar</a> <br><br>  Rieger M, Ducasse S, Lanza M (2004) Insights into system-wide code duplication.  In: Proceedings of the conference on reverse engineering (WCRE).  IEEE, pp 100-109 <br><br>  Roy C, Cordy J, Koschke R (2009): A qualitative approach.  Sci Comput Program 74 (7): 470-495 <a href="http://www.ams.org/mathscinet-getitem%3Fmr%3D2675254">MathSciNet</a> <a href="">CrossRef</a> <a href="http://www.emis.de/MATH-item%3F1183.68205">MATH</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DComparison%2520and%2520evaluation%2520of%2520code%2520clone%2520detection%2520techniques%2520and%2520tools%253A%2520a%2520qualitative%2520approach%26amp%3Bauthor%3DC.%2520Roy%26amp%3Bauthor%3DJ.%2520Cordy%26amp%3Bauthor%3DR.%2520Koschke%26amp%3Bjournal%3DSci%2520Comput%2520Program%26amp%3Bvolume%3D74%26amp%3Bissue%3D7%26amp%3Bpages%3D470-495%26amp%3Bpublication_year%3D2009">Google Scholar</a> <br><br>  Roy CK, Cordy JR (2007) A survey on software clone detection research.  Tech.  Rep.  TR 2007-541.  Queens university <br><br>  Roy CK, Zibran MF, Koschke R (2014) The clone management: past, present, and future (keynote paper).  In: 2014 Software evolution week - IEEE conference on software maintenance, reengineering, and reverse engineering, (CSMR-WCRE).  IEEE, pp 18-33 <br><br>  Siegmund J, Kastner C, Apel S, Parnin C, Bethmann A, Leich T, Saake G, Brechmann A (2014).  In: Proceedings of the international conference on software engineering (ICSE).  ACM, pp 378-389 <br><br>  Svajlenko J, Roy CK (2014) Evaluating modern clone detection tools.  In: The 30th IEEE International Conference on Software Maintenance and Evolution (ICSME).  IEEE, pp 321-330 <br><br>  van Tonder R, Le Goues C (2016) Defending against the micro clones.  In: 2016 IEEE 24th International Conference on Program Comprehension (ICPC).  IEEE, pp 1-4 <br><br>  Trafton JG, Altmann EM, Ratwani RM (2011) A memory for goals model of sequence errors.  Cogn Syst Res 12: 134-143 <a href="">CrossRef</a> <a href="http://scholar.google.com/scholar_lookup%3Ftitle%3DA%2520memory%2520for%2520goals%2520model%2520of%2520sequence%2520errors%26amp%3Bauthor%3DJG.%2520Trafton%26amp%3Bauthor%3DEM.%2520Altmann%26amp%3Bauthor%3DRM.%2520Ratwani%26amp%3Bjournal%3DCogn%2520Syst%2520Res%26amp%3Bvolume%3D12%26amp%3Bpages%3D134-143%26amp%3Bpublication_year%3D2011">Google Scholar</a> <br><br>  Xie S, Khomh F, Zou Y (2013).  In: Proceedings of the 10th working conference on mining software repositories (MSR).  IEEE <br><br>  Zibran MF, Saha RK, Asaduzzaman M, Roy CK (2011) Analyzing and forecasting software: an empirical study.  In: Proceedings of ICCCS.  IEEE, pp 295-304 </div></div><br><h2>  Copyright </h2><br>  The team of authors, 2016 <br><br>  <b>Open access</b> <br>  This article is subject to the <a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International license</a> , which permits unrestricted use, distribution and reproduction on any medium, provided that the licensee specifies the authorship and location of the original text, and also provides a link to the Creative Commons license and indicates changes, if any. were made. </div><p>Source: <a href="https://habr.com/ru/post/323914/">https://habr.com/ru/post/323914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323904/index.html">Position-independent code (PIC) in shared libraries</a></li>
<li><a href="../323906/index.html">Monitoring windows service using Zidium</a></li>
<li><a href="../323908/index.html">Spotify: Google Cloud event subsystem migration (part 3)</a></li>
<li><a href="../323910/index.html">IBM Watson will work as a tax specialist</a></li>
<li><a href="../323912/index.html">Dark secrets of the "bright budget"</a></li>
<li><a href="../323916/index.html">Construction of DMZ DMZ in ACS TP systems using Modbus and IEC-60870-5-104 protocols</a></li>
<li><a href="../323918/index.html">Report from OWASP Russia Meetup # 6: video and presentation of reports</a></li>
<li><a href="../323920/index.html">The saga is about how Java developers should test their applications. Part 1</a></li>
<li><a href="../323922/index.html">The saga is about how Java developers should test their applications. Part 2</a></li>
<li><a href="../323924/index.html">Autism - programming geeks: the destruction of myths</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>