<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>9 years in monolith on Node.JS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A week ago, I spoke at the Node.JS Mitap, and promised to lay out a speech recording for many. Later I realized that I did not manage to accommodate s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>9 years in monolith on Node.JS</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/p-/5g/we/p-5gweh68uzyj3_baevjuocr8xi.png" alt="monolith from https://reneaigner.deviantart.com"></p><br><p>  A week ago, I spoke at the Node.JS Mitap, and promised to lay out a speech recording for many.  Later I realized that I did not manage to accommodate some interesting facts in the regulated half-hour.  And I myself like to read more, and not to watch and listen, so I decided to put the speech in the format of an article.  However, the video will also be at the end of the post in the links section. </p><br><p>  I decided to tell about the topic that has gotten the edge of teeth - life in the monolith.  About this on Habr√© already have hundreds of articles, thousands of copies are broken in the comments, the truth has long died in disputes, but ... The fact is that we have a very specific experience in OneTwoTrip, unlike many people who write about certain architectural patterns in vacuum: </p><br><ul><li>  Firstly, our monolith is already 9 years old. </li><li>  Secondly, he spent his whole life under the highload (now it‚Äôs 23 million requests per hour). </li><li>  And in NaNs, we write our monolith on Node.JS, which over the past 9 years has changed beyond recognition.  Yes, we started writing at the node in 2010, madness of the brave, we sing a song! </li></ul><br><p>  So we have quite a lot of any specificity and real experience.  Interesting?  Go! </p><a name="habracut"></a><br><p>  <strong>Disclaimer times</strong> </p><br><blockquote>  This presentation reflects only the personal opinion of its author.  It may coincide with the position of the OneTwoTrip company, or it may not coincide.  Then how lucky.  I work as a technical member of one of the company's teams and I do not pretend to objectivity or the expression of someone's opinion except my own. </blockquote><p>  <strong>Disclaimer two</strong> </p><br><blockquote>  This article describes historical events, and at the moment everything is completely wrong, so do not be intimidated. </blockquote><br><h2 id="0-kak-zhe-tak-vyshlo">  0. How did it happen </h2><br><p>  <a href="https://trends.google.ru/trends/explore%3Fdate%3Dall%26q%3Dmicroservice">Trend query</a> word "microservice" in google: <br><img src="https://habrastorage.org/webt/i5/ss/lm/i5sslmpta1fldeztaxgmmnd50ag.png"><br>  Everything is very simple - nine years ago nobody knew about microservices.  So we started writing, like everyone else - in the monolith. </p><br><h2 id="1-bol-v-monolite">  1. Pain in the monolith </h2><br><p>  Here I will describe the problem situations that have happened in these 9 years.  Some of them have been solved, some have been circumvented by hacks, some have simply lost their relevance.  But the memory of them, like battle scars - will never leave me. </p><br><h3 id="11-obnovlenie-svyaznyh-komponentov">  1.1 Updating Connected Components </h3><br><p><img src="https://habrastorage.org/webt/0a/h-/8f/0ah-8f7ijb259t-blaohq1_dceg.png"><br>  The very case when synergy is evil.  Because any component was reused several hundred times, and if it was possible to use it crookedly, then it was not missed.  Any action can cause completely unpredictable effects, and not all of them are tracked by units and integration tests.  Remember the story about mops, fan and balloon?  If not, google.  It is the best illustration of the code in the monolith. </p><br><h3 id="12-migraciya-na-novye-tehnologii">  1.2 Migration to new technologies </h3><br><p>  Want Express?  Linter?  Another test or mock framework?  Update validator or at least lodash?  Update Node.js?  I'm sorry.  To do this, you have to edit thousands of lines of code. </p><br><p>  Many say about the advantage of the monolith, which is that <strong>any edit is an atomic commit</strong> .  These people are silent about one <strong>thing</strong> - <strong>this revision will never be made</strong> . </p><br><p>  Do you know the old joke about semantic versioning? </p><br><blockquote>  the real semantics of semantic versioning: <br><br>  major = a breaking change <br>  minor = a minor breaking change <br>  patch = a little-bitty breaking change </blockquote><p>  Now imagine that in your code almost any little-bitty breaking change will almost certainly come up.  No, it is possible to live with it, and we periodically gathered strength and migrated, but it was really hard.  Highly. </p><br><h3 id="13-relizy">  1.3 Releases </h3><br><p>  Here it must be said about some specifics of our product.  We have a huge number of external integrations, and various branches of the business of logic, which emerge separately rather rarely.  I really envy products that actually execute all the branches of their code in 10 minutes in production, but this is not the case.  Through trial and error, we found for ourselves an optimal release cycle that minimized the number of errors that would reach the end users: </p><br><ol><li>  release is going and half a day passes integration tests </li><li>  next day it lies under careful supervision on the Stage (for 10% of users) </li><li>  then there is still a day on production under even more careful supervision. </li><li>  And only after that we give him the green light in the master. </li></ol><br><p>  Since we love our colleagues and do not release on Fridays, in the end, this means that the release goes to the master about 1.5-2 times a week.  Which leads to the fact that the release can have 60 tasks and more.  such a number causes merge conflicts, sudden synergistic effects, full QA workload on log analysis, and other sorrows.  In general, it was very hard for us to release a monolith. </p><br><h3 id="14-prosto-ochen-mnogo-koda">  1.4 Just a lot of code </h3><br><p>  It would seem that the amount of code should not be of fundamental importance.  But ... Actually, no.  In the real world, this is: </p><br><ul><li>  Higher entry threshold </li><li>  Huge build artifacts for each task </li><li>  Long CI processes, including integration tests, unit tests, and even lint code </li><li>  Slow IDE work (at the dawn of the development of Jetbrains, we repeatedly shocked them with our logs) </li><li>  Sophisticated contextual search (do not forget, we do not have static typing) </li><li>  The difficulty of finding and removing unused code </li></ul><br><h3 id="15-otsutstvuyut-vladelcy-koda">  1.5 There are no code owners </h3><br><p>  Very often there are tasks with an incomprehensible sphere of responsibility - for example, in adjacent libraries.  And the original developer could have already moved to another team, or even left the company altogether.  The only way to find a person responsible in this case is administrative arbitrariness - to take and appoint a person.  That is not always pleasant and the developer and the one who does it. </p><br><h3 id="16-slozhnost-otladki">  1.6 Debugging Difficulty </h3><br><p>  Did the memory run out?  Increased CPU consumption?  Wanted to build flame graphs?  I'm sorry.  In the monolith, so much of everything happens at the same time that it becomes extremely difficult to locate a problem.  For example, it is almost impossible to understand which of the 60 tasks when rolling out in production causes an increased resource consumption (although locally, on test and aging media). </p><br><h3 id="17-odin-stek">  1.7 Single stack </h3><br><p>  On the one hand, it‚Äôs good when all the developers "speak" the same language.  In the case of JS, it turns out that even Backend with Frontend developers understand each other.  But... </p><br><ul><li>  There is no silver bullet, and for some tasks you sometimes want to use something else.  But we have a monolith, and we have nowhere to stick other developers. </li><li>  We can not just take on the recommendation of a good team that came to us on the advice of friends - we have nowhere to put it. </li><li>  Over time, we run into the fact that the market simply lacks the developers on the right stack. </li></ul><br><h3 id="18-mnogo-komand-s-raznym-predstavleniem-o-schaste">  1.8 Many teams with different ideas about happiness </h3><br><p><img src="https://habrastorage.org/webt/1k/bc/k1/1kbck116yjf9-ozmoee08oeacxi.png"></p><br><p>  If you have two developers, then you already have two different ideas about what is the best framework, what standards to follow, use libraries, and so on. <br>  If you have ten teams, each of which has several developers, then this is simply a disaster. <br>  And there are only two ways to solve it - either ‚Äúdemocratic‚Äù (everyone does what he wants), or totalitarian (standards are imposed from above).  In the first case, quality and standardization suffers, in the second - people who are not allowed to realize their idea of ‚Äã‚Äãhappiness. </p><br><h2 id="2-plyusy-monolita">  2. Pluses of monolith </h2><br><p>  Of course, there are some advantages in the monolith, which may be different for different stacks, products and teams.  Of course, there are many more than three, but for all possible I will not answer, only for those that were relevant to us. </p><br>
<h3 id="21-prostota-razvyortyvaniya">  2.1 Ease of Deployment </h3><br><p>  When you have one service, it is much easier to pick up and test it than a dozen services.  However, plus this is relevant only at the initial stage - for example, you can raise the test environment, and use all services, except for those developed, from it.  Or from containers.  Or whatever else you like. </p><br><h3 id="22-net-overheda-na-peredachu-dannyh">  2.2 No overhead data transfer </h3><br><p>  Quite a doubtful plus, if you do not have highload.  But we have just such a case - therefore the cost of transport between microservices is noticeable for us.  No matter how hard you try to do it quickly, store and transfer everything in RAM most quickly - this is obvious. </p><br><h3 id="22-odna-sborka">  2.2 One build </h3><br><p>  If you need to roll back at some point in history, then it‚Äôs really simple to do it with a monolith - it took and rolled away.  In the case of microservices, it is necessary to select compatible versions of services that were used with each other at a particular point in time, which may not always be easy.  True, this is also solved with the help of infrastructure. </p><br><h2 id="3-mnimye-plyusy-monolita">  3. Imaginary pluses of the monolith </h2><br><p>  Here I brought all those things that are usually considered pluses, but from my point of view they are not. </p><br><h3 id="31-kod---eto-i-est-dokumentaciya">  3.1 Code - this is the documentation </h3><br><p>  Often heard this opinion.  But usually it is followed by novice developers who have not seen files in tens of thousands of lines of code written years ago by departed people.  Well, for some reason, most often this point is brought in plus by supporters of the monolith - they say, we don‚Äôt need any documentation, we don‚Äôt have any transport or api - everything is in the code, it‚Äôs easy and clear.  I will not argue with this statement, just say that I do not believe in it. </p><br><h3 id="32-net-raznyh-versiy-bibliotek-servisov-i-api-net-raznyh-repozitoriev">  3.2 There are no different versions of libraries, services and APIs.  No different repositories. </h3><br><p>  Yes.  But no.  Because at a second glance, you understand that service does not exist in a vacuum.  And among a huge number of other code and products with which it integrates - starting from third-party libraries, continuing with versions of server software, and not ending with external integrations, versions of IDE, CI tools, and so on.  And as soon as you understand how many different versioned things are mediated by yourself, it includes your service, it immediately becomes clear that this plus is just demagoguery. </p><br><h3 id="33-prosche-monitoring">  3.3 Easier monitoring </h3><br><p>  Simpler.  Because you have, roughly, speaking, one dashboard, instead of several dozen.  But it is more complicated, and sometimes even impossible - because you cannot decompose your schedules into different parts of the code, and you only have the average temperature in the hospital.  In general, I have already said everything in the paragraph about the complexity of debugging, I‚Äôll just clarify that the same complexity applies to monitoring. </p><br><h3 id="34-prosche-soblyudat-edinye-standarty">  3.4 Easier to follow uniform standards </h3><br><p>  Yes.  But, as I already wrote in the paragraph about many teams with the notion of happiness - standards are either imposed totalitarianly, or weakened almost to the lack of them. </p><br><h3 id="35-menshe-veroyatnost-dublirovaniya-koda">  3.5 Less chance of code duplication </h3><br><p>  A strange opinion that the code is not duplicated in the monolith.  But I met him quite often.  In my practice, it turns out that duplication of code depends solely on the development culture in the company.  If it is, then the common code is allocated to all sorts of libraries, modules and microservices.  If it is not there, then there will be a copy-peist twenty times in the monolith. </p><br><h2 id="4-plyusy-mikroservisov">  4. Pluses of microservices </h2><br><p>  Now I will write about what we got after the migration.  Again, these are real conclusions from the real situation. </p><br><h3 id="41-mozhno-delat-geterogennuyu-infrastrukturu">  4.1 You can make a heterogeneous infrastructure </h3><br><p>  Now we can write code on the stack that is optimal for solving a specific problem.  And rationally use any good developers who came to us.  For an example - here is an exemplary list of technologies that we have at the moment: <br><img src="https://habrastorage.org/webt/mt/oc/nr/mtocnrvjvhfhxxtsjfnjx3z8knc.png"></p><br><h3 id="42-mozhno-delat-mnogo-chastyh-relizov">  4.2 You can do a lot of frequent releases </h3><br><p>  Now we can do a lot of small independent releases, and they are easier, faster, and do not cause pain.  Once we had only one team, and now there are already 18 of them. If they all remained in the monolith, then he would probably have broken.  Or people who are responsible for him ... </p><br><h3 id="43-prosche-delat-nezavisimye-testy">  4.3 Easier to do independent tests </h3><br><p>  We have reduced the time of integration tests, which are now testing only what has really changed, and at the same time we are not afraid of the effects of sudden synergy.  Of course, I had to walk around the rake to begin with - for example, learning how to make backward-compatible APIs - but over time everything settled down. </p><br><h3 id="44-legche-vnedryat-i-testirovat-novye-fichi">  4.4 Easier to implement and test new features. </h3><br><p>  Now we are open to experimentation.  Any frameworks, stacks, libraries - everything can be tried, and if successful, move on. </p><br><h3 id="45-mozhno-obnovlyat-chto-ugodno">  4.5 You can update anything </h3><br><p>  You can update the version of the engine, libraries, anything!  As part of a small service, finding and fixing all the breaking changes is a matter of minutes.  And not weeks, as it was before. </p><br><h3 id="46--a-mozhno-ne-obnovlyat">  4.6 And you can not update </h3><br><p>  Oddly enough, this is one of the coolest features of microservices.  If you have a stable working code, then you can just freeze it and forget about it.  And you will never have to update it, for example, in order to run the product code on a new engine.  The product itself works on a new engine, and microservice continues to live as it lived.  Flies with meatballs can finally be eaten separately. </p><br><h2 id="5-minusy-mikroservisov">  5 Cons of microservices </h2><br><p>  Of course, the tar was not without a spoon, and the perfect solution, in order to just sit and get paid, did not work out.  What we faced: </p><br><h3 id="51-nuzhna-shina-dlya-obmena-dannymi-i-vnyatnoe-logirovanie">  5.1 Need a bus for data exchange and clear logging. </h3><br><p>  The interaction of services over HTTP is a classic model, and in general even a working one, provided that there are logging and balancing layers between them.  But it is better to have a more intelligible tire.  In addition, you should think about how to collect and merge logs among themselves - otherwise you will have just porridge on your hands. </p><br><h3 id="52-nuzhno-sledit-za-tem-chto-delayut-razrabotchiki">  5.2 Need to follow what developers are doing </h3><br><p>  In general, this should always be done, but in microservices, developers obviously have more freedom, which sometimes can give rise to such things that would give Stephen King goosebumps.  Even if outwardly it seems that the service is working - do not forget that there must be a person who keeps an eye on what is inside him. </p><br><h3 id="53-nuzhna-horoshaya-komanda-devops-chtoby-vsem-etim-upravlyat">  5.3 We need a good DevOps team to manage all of this. </h3><br><p>  Almost any developer can somehow unroll a monolith and upload its releases (for example, via FTP or SSH, I saw this).  But with microservices there appear all sorts of centralized services for collecting logs, metrics, dashboards, chefs for managing configs, volts, jenkins, and other good, without which you can live on the whole, but it‚Äôs not good and not clear.  So to manage microservices you need to have a good DevOps command. </p><br><h3 id="54-mozhno-popytatsya-slovit-hayp-i-vystrelit-sebe-v-nogu">  5.4 You can try to catch the HYIP and shoot yourself in the foot. </h3><br><p>  This is probably the main disadvantage of architecture and its danger.  Very often, people blindly follow trends and begin to introduce architecture and technology without understanding it.  After that, everything falls, they are confused in the resulting porridge, and write an article on Habr "how we moved from microservices to a monolith," for example.  In general, move only if you know why you are doing this and what problems you will solve.  And what will get. </p><br><h2 id="6-haki-v-monolite">  6 Khaki in the monolith </h2><br><p>  Some of the hacks that allowed us to live in the monolith a little better and a little longer. </p><br><h3 id="61-linting">  6.1 Lintting </h3><br><p>  The introduction of the linter in the monolith is not as simple as it seems at first glance.  Of course, you can make strict rules, add a config, and ... Nothing will change, everything will just turn off the linter, because half the code will turn red. </p><br><p>  For the gradual introduction of lint, we wrote a simple add-on over eslint - <a href="https://www.npmjs.com/package/slowlint">slowlint</a> , which allows us to do one simple thing - to contain a list of temporarily ignored files.  As a result: </p><br><ul><li>  All incorrect code is highlighted in IDE </li><li>  New files are created according to the rules of linting, otherwise CI will not miss them. </li><li>  The old gradually rule and leave the exceptions. </li></ul><br><p>  For the year, we managed to bring about half of the monolith code under a single style, that is, almost all of the actively written code. </p><br><h3 id="62-dorabotki-yunit-testov">  6.2 Improvements unit tests </h3><br><p>  Formerly, unit tests were carried out for three minutes.  The developers did not want to wait so much time, so everything was checked only in the CI on the server.  After some time, the developer found out that the tests had fallen, cursed, opened a branch, returned to the code ... In general, he suffered.  What we did with it: </p><br><ol><li>  For a start, they started running tests multithreaded.  Yandex has a variant of multi-stream mocha, but with us it did not take off, so they themselves wrote a simple wrapper.  Tests began to be performed one and a half times faster. </li><li>  Then we moved from 0.12 node to 8th (yes, the process itself draws on a separate report).  This, oddly enough, didn‚Äôt give any significant performance gains on production, but the tests were run 20% faster. </li><li>  And then we still sat down to debug the tests and optimize them separately.  What gave the greatest increase in speed. </li></ol><br><p>  In general, at the current moment, unit tests are run in the prepress hook and work out in 10 seconds, which is quite comfortable and allows them to run without interrupting production. </p><br><h3 id="63--oblegchenie-vesa-artefakta">  6.3 Lightweight Artifact </h3><br><p>  The monolith artifact eventually began to occupy 400 megabytes.  Taking into account that it is created for each commit, the total volumes were quite large.  With this we were helped by the <a href="https://www.npmjs.com/package/diarrhea">diarrhea</a> module, fork of the <a href="https://www.npmjs.com/package/modclean">modclean</a> module.  We removed unit tests from the artifact and cleaned it of various debris like readme files, tests inside packages, and so on.  The gain was about 30% by weight! </p><br><h3 id="64--keshirovanie-zavisimostey">  6.4 Dependency Caching </h3><br><p>  Once installing dependencies with npm took so much time that it was possible not only to drink coffee, but also, for example, to bake pizza.  Therefore, we first used the <a href="https://github.com/jehy/npm-cache">npm-cache</a> module, which was forked and doped a little.  He allowed to maintain dependencies on a shared network drive, from which all other builds would later take him. </p><br><p>  Then we thought about the reproducibility of assemblies.  When you have a monolith, the change of transitive dependencies is the scourge of God.  Considering that we were then far behind the version of the engine, the change of some kind of dependency of the fifth level easily broke our entire assembly.  So we started using npm-shrinkwrap.  It was already easier with him, although the merdzhit of his changes is a pleasure for the strong in spirit. </p><br><p> And then finally came the package-lock and the excellent <code>npm ci</code> command - which was executed at a slightly lower speed than installing dependencies from the file cache.  Therefore, we began to use only it, and ceased to store the dependency assembly.  On this day, I brought to work a few boxes of donuts. </p><br><h3 id="65--raspredelenie-ocheryodnosti-relizov">  6.5 Distribution of release order. </h3><br><p>  And this is more of an administrative hack than a technical one.  Initially, I was against him, but time has shown that the second technical leader was right and well done.  When the releases were distributed in turn between several teams, it became clearer where exactly the errors appeared, and what is more important - each team felt its responsibility for speed, and tried to solve problems and roll out as quickly as possible. </p><br><h3 id="66-udalenie-myortvogo-koda">  6.6 Delete Dead Code </h3><br><p>  In the monolith, it is very scary to delete the code - you never know where it could be tied to.  Therefore, most often it just remains to lie on the side.  For years.  And even the dead code has to be maintained, not to mention the confusion it introduces.  Therefore, over time, we began to use <a href="https://www.npmjs.com/package/require-analyse">require-analyze</a> for superficial search for dead code, and integration tests, plus running in coverage check mode ‚Äî for a deeper search. </p><br><h2 id="7-raspil-monolita">  7 Cut monolith </h2><br><p>  For some reason, many believe that in order to switch to microservices, you need to abandon your monolith, write a bunch of microservices next to zero, and all this will start at once - and there will be happiness.  But this model ... Hmm ... is fraught with the fact that you do not do anything, and only spend a lot of time and money writing code that you have to throw out. </p><br><p>  I propose another option, which seems to me more working, and which was implemented here: </p><br><ol><li>  We are starting to write new services in microservices.  Running in technology, jumping on rakes, we understand whether we want to do it at all. </li><li>  Select the code in modules, libraries, or whatever you use there. </li><li>  Select the services from the monolith. </li><li>  We select microservices from the services.  Without haste and one by one. </li></ol><br><h2 id="8-i-naposledok">  8 And finally </h2><br><p><img src="https://habrastorage.org/webt/z8/tl/cv/z8tlcv6aibivr83m9q-fxzhusay.png" alt="The picture is taken from https://fvl1-01.livejournal.com/"></p><br><p>  In the end, I decided to leave the most important thing. </p><br><p>  Remember: </p><br><ul><li>  You are not google </li><li>  You are not Microsoft </li><li>  You are not facebook </li><li>  You are not Yandex </li><li>  You are not Netflix </li><li>  You are not OneTwoTrip </li></ul><br><p>  If something works in other companies - absolutely not the fact that it will benefit you.  If you try to blindly copy the experience of other companies with the words ‚Äúit works for them‚Äù, then it will most likely end badly.  Every company, every product and every team is unique.  What works for some will not work for others.  I do not like to say the obvious things, but too many people begin to build a cargo cult around other companies, blindly copying approaches, and bury themselves under false Christmas decorations.  Do not do this.  Experiment, try, develop solutions that are optimal for you.  And only then everything will work out. </p><br><h2 id="poleznye-ssylki">  Useful links: </h2><br><ul><li>  <a href="https://www.youtube.com/watch%3Fv%3Dk5kuXS7PVOg%26list%3DPLP9HCuzqwEwWQCN9LsHiEkCMiEqWqjhDD">My report</a> in video format </li><li>  <a href="https://www.youtube.com/playlist%3Flist%3DPLP9HCuzqwEwWQCN9LsHiEkCMiEqWqjhDD">Full playlist</a> with mitap by Node.JS </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/459206/">https://habr.com/ru/post/459206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459194/index.html">How we made friends with SCSS with CSS Variables on the example of UI Kit temization</a></li>
<li><a href="../459196/index.html">From monoliths to modular commands</a></li>
<li><a href="../459198/index.html">Performance analysis queries in ClickHouse. Yandex report</a></li>
<li><a href="../4592/index.html">List of reasons why VoIP will destroy traditional telecoms</a></li>
<li><a href="../459204/index.html">10 ++ ways to work with hardware registers in C ++ (for example, IAR and Cortex M)</a></li>
<li><a href="../459208/index.html">Running with prostheses: nekstgen simulation of human movement with the help of muscles, bones and neural networks</a></li>
<li><a href="../45921/index.html">Home server - AMD, Debian x64, Bind9, Apache 2, PHP5, MySQL5, Trac, Subversion and a lot of fun</a></li>
<li><a href="../459212/index.html">Implementing properties in C ++</a></li>
<li><a href="../459214/index.html">Fault tolerance in storage Qsan</a></li>
<li><a href="../459216/index.html">B-tree data structure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>