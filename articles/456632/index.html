<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are building the fourth floor of C ++ templates in RESTinio. Why and how?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RESTinio is a relatively small project, which is an asynchronous HTTP server embedded in C ++ applications. Its characteristic feature is the wide, on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are building the fourth floor of C ++ templates in RESTinio. Why and how?</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="https://github.com/Stiffstream/restinio">RESTinio</a> is a relatively small project, which is an asynchronous HTTP server embedded in C ++ applications.  Its characteristic feature is the wide, one might say, universal application of C ++ templates.  Both in implementation and in public API. </p><br><p>  C ++ templates in RESTinio are used so actively that the first article, which told about RESTinio on Habr√©, was called " <a href="https://habr.com/ru/post/345788/">Three-storey C ++ templates in the implementation of an embedded asynchronous HTTP server with a human face</a> ". </p><br><p>  Three-story patterns.  And this, in general, was not a figure of speech. </p><br><p>  And recently, we once again updated RESTinio, and in order to add new functionality to version 0.5.1, we had to make the number of storeys higher.  So in some places C ++ templates in RESTinio are already four-story. </p><br><p><img src="https://habrastorage.org/webt/vz/t3/vw/vzt3vwbp8snyu3y7hhrcr6crela.jpeg"></p><br><p>  And if someone wonders why it took us and how we used the templates, then stay with us, under the cut there will be some details.  Older C ++ gurus are unlikely to find anything new for themselves, but less advanced C ++ nicknames will be able to look at how templates are used to insert / remove pieces of functionality.  Almost in the "wild". </p><a name="habracut"></a><br><h1 id="slushatel-sostoyaniya-podklyucheniy">  Connection Status Listener </h1><br><p>  The main feature for which version 0.5.1 was created is the ability to inform the user that the connection status to the HTTP server has changed.  For example, the client "fell off" and this made it unnecessary to process requests from this client, who are still waiting for their turn. </p><br><p>  Sometimes we were asked about this feature and now our hands have reached its realization.  But since  far from everything was asked about this feature, it was thought that it should be optional: if some user needs it, then let it explicitly include it, and everyone else should not pay anything for its existence in RESTinio. </p><br><p>  And since the main characteristics of the HTTP server in RESTinio are set through the "properties" (traits), it was decided to enable / disable the listening of the connection status through the server properties. </p><br><h2 id="kak-polzovatel-zadaet-sobstvennogo-slushatelya-sostoyaniya-podklyucheniy">  How does a user define their own connection state listener? </h2><br><p>  In order to set your <a href="https://stiffstream.com/en/docs/restinio/0.5/connectionstate.html">connection status listener, the</a> user must perform three steps. </p><br><p>  Step 1: define your own class, which should have a non-static state_changed method of the following form: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>;</code> </pre> <br><p>  For example, it might be something like: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_state_listener</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex lock_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; l{lock_}; .... } ... };</code> </pre> <br><p>  Step 2: Inside the server properties, you need to define a typedef with the name <code>connection_state_listener_t</code> , which should refer to the name of the type created in step # 1: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; };</code> </pre> <br><p>  Accordingly, these properties should be used when starting the HTTP server: </p><br><pre> <code class="cpp hljs">restinio::run(restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>)...);</code> </pre> <br><p>  Step 3: the user must create an instance of his listener and pass this pointer through shared_ptr in the server settings: </p><br><pre> <code class="cpp hljs">restinio::run( restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>) .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .request_handler(...) .connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;my_state_listener&gt;(...)) ) );</code> </pre> <br><p>  If the user does not make a call to the <code>connection_state_listener</code> method, an exception will be thrown when the HTTP server is started: the north cannot work if the user wants to use the state listener, but this same listener was not asked. </p><br><h3 id="a-esli-ne-zadavat-connection_state_listener_t">  And if you do not specify connection_state_listener_t? </h3><br><p>  If the user sets the name <code>connection_state_listener_t</code> in the server properties, he must call the <code>connection_state_listener</code> method when setting the server parameters.  But if the user does not specify <code>connection_state_listener_t</code> ? </p><br><p>  In this case, the server properties will still have the name <code>connection_state_listener_t</code> , but this name will indicate the special type <code>restinio::connection_state::noop_listener_t</code> . </p><br><p>  In essence, the following happens: in RESTinio, when defining regular traits, the value of <code>connection_state_listener_t</code> is set.  Sort of: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> restinio { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_traits_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">time_manager_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">asio_time_manager_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">null_logger_t</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = connection_state::<span class="hljs-keyword"><span class="hljs-keyword">noop_listener_t</span></span>; }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace restinio */</span></span></code> </pre> <br><p>  And when the user is inherited from <code>restinio::default_traits_t</code> , then the staff definition of <code>connection_state_listener_t</code> is also inherited.  But if the new name <code>connection_state_listener_t</code> defined in the derived class: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; ... };</code> </pre> <br><p>  then the new name hides the inherited definition for <code>connection_state_listener_t</code> .  And if there is no new definition, then the old definition remains visible. </p><br><p>  So, if the user does not define his own value for <code>connection_state_listener_t</code> , then RESTinio will use the default value, <code>noop_listener_t</code> , which is handled by RESTinio in a special way.  For example: </p><br><ul><li>  RESTinio does not store shared_ptr for <code>connection_state_listener_t</code> in this case.  And, accordingly, a call to the <code>connection_state_listener</code> method is prohibited (such a call will result in a compile-time error); </li><li>  RESTinio does not make any additional calls related to changing the state of the connection. </li></ul><br><p>  And just about how all this is achieved speech and will go below. </p><br><h2 id="kak-eto-realizovano-v-restinio">  How is this implemented in RESTinio? </h2><br><p>  So, in the RESTinio code, you need to check what the <code>connection_state_listener_t</code> definition has in the server properties and, depending on this value: </p><br><ul><li>  whether or not to store the shared_ptr instance for an object of type <code>connecton_state_listener_t</code> ; </li><li>  allow or deny calls of <code>connection_state_listener</code> methods to set HTTP server parameters; </li><li>  check or not check for the presence of an actual pointer to an object of type <code>connection_state_listener_t</code> before starting the HTTP server; </li><li>  or not to make <code>state_changed</code> method <code>state_changed</code> when the client connection state changes. </li></ul><br><p>  The fact that RESTinio is still being developed as a library for C ++ 14 is added to the boundary conditions, so the implementation cannot use the features of C ++ 17 (the same if constexpr). </p><br><p>  All this is implemented through simple techniques: template classes and their specializations for the type <code>restinio::connection_state::noop_listener_t</code> .  For example, here‚Äôs how storage of shared_ptr is made for an object of type <code>connection_state_listener_t</code> in server settings.  Part one: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//  compile-time . std::shared_ptr&lt; Listener &gt; m_connection_state_listener; static constexpr bool has_actual_connection_state_listener = true; void check_valid_connection_state_listener_pointer() const { if( !m_connection_state_listener ) throw exception_t{ "connection state listener is not specified" }; } }; template&lt;&gt; struct connection_state_listener_holder_t&lt; connection_state::noop_listener_t &gt; { static constexpr bool has_actual_connection_state_listener = false; void check_valid_connection_state_listener_pointer() const { // Nothing to do. } };</span></span></code> </pre> <br><p>  A template structure is defined here that either has a useful content or not.  Just for the type <code>noop_listener_t</code> it has no useful content. </p><br><p>  And part two: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_server_settings_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">socket_type_dependent_settings_t</span></span>&lt; Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">stream_socket_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_t</span></span> &gt; { ... };</code> </pre> <br><p>  The class that contains the parameters for the HTTP server is inherited from <code>connection_state_listener_holder_t</code> .  Thus, in the server settings, either it turns out to be shared_ptr for an object of the <code>connection_state_listener_t</code> type, or not. </p><br><p>  It must be said that storing or not storing shared_ptr in the parameters is flowers.  And the berries went when trying to make the methods designed for working with the state listener in <code>basic_server_settings_t</code> available only if <code>connection_state_listener_t</code> is different from <code>noop_listener_t</code> . </p><br><p>  Ideally, I wanted to make sure that the compiler didn‚Äôt see them at all.  But I was tortured to write down conditions for <code>std::enable_if</code> order to hide these methods.  Therefore, I just limited myself to adding static_asser: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Derived &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener(listener) can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference_to_derived(); } <span class="hljs-function"><span class="hljs-function">Derived &amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener))); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; &amp; connection_state_listener() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener() can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ensure_valid_connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;check_valid_connection_state_listener_pointer(); }</code> </pre> <br><p>  There was just another moment when <a href="https://habr.com/post/449122/">it was regrettable that in C ++ if constexpr is not the same as static if in D.</a>  And indeed in C ++ 14 there is nothing like :( </p><br><p>  Here you can see the presence of the <code>ensure_valid_connection_state_listener</code> method.  This method is called in the <code>http_server_t</code> constructor to check that the server parameters contain all the necessary values: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">http_server_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">io_context_holder_t</span></span> io_context, <span class="hljs-keyword"><span class="hljs-keyword">basic_server_settings_t</span></span>&lt; D, Traits &gt; &amp;&amp; settings ) : m_io_context{ io_context.giveaway_context() } , m_cleanup_functor{ settings.giveaway_cleanup_func() } { <span class="hljs-comment"><span class="hljs-comment">// Since v.0.5.1 the presence of custom connection state // listener should be checked before the start of HTTP server. settings.ensure_valid_connection_state_listener(); ...</span></span></code> </pre> <br><p>  At the same time inside <code>ensure_valid_connection_state_listener</code> method inherited from <code>connection_state_listener_holder_t</code> is <code>check_valid_connection_state_listener_pointer</code> , which, due to the <code>connection_state_listener_holder_t</code> specialization, either performs an actual check or does nothing. </p><br><p>  Similar techniques are used to either call the current <code>state_changed</code> , if the user wishes to use the state listener, or not to call anything otherwise. </p><br><p>  First we need another version of <code>state_listener_holder_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> connection_settings_details { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; Listener &gt; m_connection_state_listener; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; settings ) : m_connection_state_listener{ settings.connection_state_listener() } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; lambda )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ m_connection_state_listener-&gt;state_changed( lambda() ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class">&lt; connection_state::noop_listener_t &gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; ) { <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*lambda*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace connection_settings_details */</span></span></code> </pre> <br><p>  Unlike <code>connection_state_listener_holder_t</code> , which was shown earlier and used to store the connection state listener in the parameters of the entire server (that is, objects of the type <code>basic_server_settings_t</code> ), this <code>state_listener_holder_t</code> will be used for similar purposes, but not in the parameters of the entire server but of Connection: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_settings_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>&lt; Traits &gt; &gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span> = connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt;; ...</code> </pre> <br><p>  There are two features here. </p><br><p>  First, the initialization <code>state_listener_holder_t</code> .  It is either needed or not.  But only <code>state_listener_holder_t</code> knows about it.  Therefore, the constructor <code>connection_settings_t</code> simply "pulls" the constructor <code>state_listener_holder_t</code> , which is called, just in case: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>( Settings &amp;&amp; settings, http_parser_settings parser_settings, <span class="hljs-keyword"><span class="hljs-keyword">timer_manager_handle_t</span></span> timer_manager ) : <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>{ settings } , m_request_handler{ settings.request_handler() }</code> </pre> <br><p>  And the <code>state_listener_holder_t</code> constructor <code>state_listener_holder_t</code> either performs the necessary actions or does nothing at all (in the latter case, a more or less intelligent compiler will not generate any code at all to initialize <code>state_listener_holder_t</code> ). </p><br><p>  Secondly, it is the <code>state_listner_holder_t::call_state_listener</code> , which makes the <code>state_changed</code> call to the state listener.  Or does not, if there is no state listener.  This <code>call_state_listener</code> in places where RESTinio diagnoses a connection state change.  For example, when it is detected that the connection has been closed: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_logger.trace( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt::format( <span class="hljs-string"><span class="hljs-string">"[connection:{}] close"</span></span>, connection_id() ); } ); ... <span class="hljs-comment"><span class="hljs-comment">// Inform state listener if it used. m_settings-&gt;call_state_listener( [this]() noexcept { return connection_state::notice_t{ this-&gt;connection_id(), this-&gt;m_remote_endpoint, connection_state::cause_t::closed }; } ); }</span></span></code> </pre> <br><p>  A <code>call_state_listener</code> is sent to <code>call_state_listener</code> , from which the <code>notice_t</code> object is <code>notice_t</code> with information about the connection status.  If there is a current listener, then this lambda will indeed be called, and the value returned by it will be passed to <code>state_changed</code> . </p><br><p>  However, if there is no listener, then <code>call_state_listener</code> will be empty and, accordingly, no lambda will be called.  In fact, a normal compiler simply throws all calls to an empty <code>call_state_listener</code> .  And in this case, in the generated code there will be nothing at all related to the connection state being addressed to the listener. </p><br><h1 id="esche-i-ip-blocker">  More IP blocker </h1><br><p>  In RESTinio-0.5.1, in addition to the connection status listener, such a thing as an <a href="https://stiffstream.com/en/docs/restinio/0.5/ipblocker.html">IP blocker</a> was added.  Those.  the user can specify an object that RESTinio will ‚Äúpull‚Äù for each new incoming connection.  If the IP blocker says that you can work with the connection, then RESTinio starts the normal maintenance of the new connection (reads and parses the request, calls the request-handler, controls the time-outs, etc.).  But if the IP-blocker prohibits work with the connection, then RESTinio stupidly closes this connection and does nothing with it. </p><br><p>  Like the state listener, an IP blocker is optional functionality.  To use the IP blocker, you must explicitly enable it.  Through the properties of the HTTP server.  Just as with the listener connection status.  And the implementation of IP blocker support in RESTinio uses the same techniques that were already described above.  Therefore, we will not dwell on how the IP blocker is used inside RESTinio.  Instead, consider an example in which both the IP blocker and the state listener are the same object. </p><br><h2 id="razbor-shtatnogo-primera-ip_blocker">  Parsing a regular ip_blocker example </h2><br><p>  In version 0.5.1, another example is included in the regular RESTinio examples: <a href="">ip_blocker</a> .  This example demonstrates how you can limit the number of parallel connections to a server from a single IP address. </p><br><p>  This will require not only an IP blocker that will allow or deny accepting connections.  But also the listener of the connection state.  The listener is needed to keep track of the moments of creating and closing connections. </p><br><p>  At the same time, both the IP blocker and the listener will need the same data set.  Therefore, the simplest solution is to make the IP blocker and the listener be the same object. </p><br><p>  No problem, we can easily do it: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blocker_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m_lock; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt; restinio::asio_ns::ip::address, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; restinio::<span class="hljs-keyword"><span class="hljs-keyword">connection_id_t</span></span> &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> m_connections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   IP-blocker-. restinio::ip_blocker::inspection_result_t inspect( const restinio::ip_blocker::incoming_info_t &amp; info ) noexcept {...} //     . void state_changed( const restinio::connection_state::notice_t &amp; notice ) noexcept {...} };</span></span></code> </pre> <br><p>  Here we have no inheritance from any interfaces and redefinition of inherited virtual methods.  The only requirement for the listener is the presence of the <code>state_changed</code> method.  This requirement is met. </p><br><p>  Similarly, with the only requirement for IP blocker: is there an <code>inspect</code> method with the required signature?  There is!  So everything is fine. </p><br><p>  It remains to determine the correct properties for the HTTP server: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">shared_ostream_logger_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      . using connection_state_listener_t = blocker_t; using ip_blocker_t = blocker_t; };</span></span></code> </pre> <br><p>  After that, it remains only to create an instance of <code>blocker_t</code> and pass it in the parameters to the HTTP server: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> blocker = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">blocker_t</span></span>&gt;(); restinio::run( ioctx, restinio::on_thread_pool&lt;<span class="hljs-keyword"><span class="hljs-keyword">my_traits_t</span></span>&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::hardware_concurrency() ) .port( <span class="hljs-number"><span class="hljs-number">8080</span></span> ) .address( <span class="hljs-string"><span class="hljs-string">"localhost"</span></span> ) .connection_state_listener( blocker ) .ip_blocker( blocker ) .max_pipelined_requests( <span class="hljs-number"><span class="hljs-number">4</span></span> ) .handle_request_timeout( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">20</span></span>} ) .request_handler( [&amp;ioctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler( ioctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req) ); } ) );</code> </pre> <br><h1 id="zaklyuchenie">  Conclusion </h1><br><h2 id="o-cnyh-shablonah">  About C ++ templates </h2><br><p>  In my opinion, C ++ templates are what are called "too big gun".  Those.  so powerful feature that one involuntarily has to think about how well its use is justified.  Therefore, the modern C ++ community is divided into several warring camps. </p><br><p>  Representatives of one of them prefer to stay away from the templates.  Since templates are complex, generating unimaginable length unreadable sheets of error messages increase compile time significantly.  Not to mention the urban legends about bloating code and reduced performance. </p><br><p>  Representatives of the other camp (like me), believe that the patterns are one of the most powerful sides of C ++.  It is even possible that templates are one of the few most serious competitive advantages of C ++ in the modern world.  Therefore, in my opinion, the future of C ++ is exactly the templates.  And some of the current inconveniences associated with the extensive use of templates (such as lengthy and resource-intensive compilation or low-informative error messages) will in some way be eliminated over time. </p><br><p>  Therefore, it seems to me personally that the approach chosen during the implementation of RESTinio, namely, the widespread use of templates and setting the characteristics of an HTTP server through properties, still justifies itself.  Thanks to this, we get good customizability for specific needs.  And, at the same time, we literally do not pay for what we do not use. </p><br><p>  However, on the other hand, it seems that programming in C ++ templates is still unreasonably difficult.  You especially feel this when programming is not always necessary, but switching between different types of activities.  If you distract from coding for a couple of weeks, then you come back and start to bluntly and specifically stupid if necessary to hide some method using SFINAE or check the presence of a method with a specific signature on the object. </p><br><p>  So it's good that there are templates in C ++.  It would be even better if they were brought to such a state that even old-footed runners, like me, could use C ++ templates without pain, without having to study cppreference and stackoverflow every 10-15 minutes. </p><br><h2 id="o-tekuschem-sostoyanii-restinio-i-buduschey-funkcionalnosti-restinio-i-ne-tolko-restinio">  About the current state of RESTinio and the future functionality of RESTinio.  And not only RESTinio </h2><br><p>  At the moment, RESTinio develops on the principle "when there is time and there is a Wishlist."  For example, in the fall of 2018 and in the winter of 2019, we didn‚Äôt have much on the development of RESTinio.  They answered questions from users, minor edits were made, but there was not enough of our resources for something greater. </p><br><p>  But at the end of the spring of 2019, the time for RESTinio was found and we first did RESTinio <a href="https://stiffstream.com/ru/news/2019/6/restinio_0_5_0_released.html">0.5.0</a> , and then <a href="https://stiffstream.com/ru/news/2019/6/restinio_0_5_1_released.html">0.5.1</a> .  In this case, the stock of our and others hotelok was exhausted.  Those.  what we ourselves wanted to see in RESTinio and what users were telling us about is already in RESTinio. </p><br><p>  Obviously, RESTinio can be filled with many more.  But what exactly? </p><br><p>  And here the answer is very simple: RESTinio will only get what we are asked for.  So if you want to see something you need in RESTinio, then take the time to inform us about it (for example, through the issues on <a href="https://github.com/Stiffstream/restinio/issues">GitHub</a> or <a href="https://bitbucket.org/sobjectizerteam/restinio/issues">BitBucket</a> , either through the <a href="https://groups.google.com/forum/">Google group</a> , or right in the comments here on Habr√©) .  Do not say anything - and get nothing;) </p><br><p>  Actually, the same situation with our other projects, in particular with <a href="https://github.com/Stiffstream/sobjectizer">SObjectizer</a> .  Their new versions will be released as they become intelligible hotelok. </p><br><p>  Well, at the very end, I would like to offer to anyone who has not tried RESTinio: try it <del>  is free </del>  don't hurt.  Suddenly like it.  But do not like it, then share what exactly.  This will help us to make RESTinio more convenient and functional. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/456632/">https://habr.com/ru/post/456632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456614/index.html">How the frame is rendered A Plague Tale: Innocence</a></li>
<li><a href="../456616/index.html">3 million rubles for those who know how to code</a></li>
<li><a href="../456618/index.html">Larabeer Moscow - June 21</a></li>
<li><a href="../456622/index.html">How to create an OS certified for I class of protection</a></li>
<li><a href="../456624/index.html">Useful Python Tools</a></li>
<li><a href="../456634/index.html">Nginx recipes: CAS (central authorization service)</a></li>
<li><a href="../456638/index.html">Comparing the same project in Rust, Haskell, C ++, Python, Scala and OCaml</a></li>
<li><a href="../456640/index.html">Reviewing the Competitive Intelligence Competition on PHDays 9</a></li>
<li><a href="../456642/index.html">The first issue of the corporate master program of JetBrains and ITMO University</a></li>
<li><a href="../456644/index.html">On Kickstarter appeared budget photopolymer 3D-printer Longer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>