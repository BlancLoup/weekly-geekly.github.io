<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In any incomprehensible situation - write scripts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scripts - one of the most common ways to make the application more flexible, with the ability to fix something right on the go. Of course, this approa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In any incomprehensible situation - write scripts</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/a5/ng/5b/a5ng5b6thpfbxpcasm51swkuzgk.jpeg" alt="image"><br><br>  Scripts - one of the most common ways to make the application more flexible, with the ability to fix something right on the go.  Of course, this approach has its drawbacks, you should always remember about the balance between flexibility and controllability.  But in this article we will not talk ‚Äúin general‚Äù about the pros and cons of using scripts, we will look at practical ways to implement this approach, and also present a library that provides a convenient infrastructure for adding scripts to applications written in the Spring Framework. <br><a name="habracut"></a><br><h2>  A few introductory words </h2><br>  When you want to add the ability to change the business logic in the application without recompiling and subsequent deployment, the scripts are one of the ways that comes to mind first.  Often, the scripts appear not because it was intended, but because it happened.  For example, in the specification there is a part of logic that is not completely clear right now, but in order not to spend an extra couple of days (and sometimes longer) on analysis, you can make an extension point and call the script stub.  And then, of course, this script will be rewritten when the requirements become clear. <br><br>  The method is not new, and its advantages and disadvantages are well-known: flexibility - you can change the logic on a running application and save time for redeployed, but, on the other hand, scripts are harder to test, hence, possible problems with security, performance, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Those techniques, which will be discussed later, can be useful both to developers who already use scripts in their application, and to those who only think about it. <br><br><h2>  Nothing personal, only scripting </h2><br>  With JSR-233, scripting in Java has become very simple.  There are enough scripting engines based on this API (Nashorn, JRuby, Jython, and some more), so adding a little scripting magic to the code is not a problem: <br><br><pre><code class="java hljs">Map&lt;String, Object&gt; parameters = createParametersMap(); ScriptEngineManager manager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScriptEngineManager(); ScriptEngine scriptEngine = manager.getEngineByName(<span class="hljs-string"><span class="hljs-string">"groovy"</span></span>); Object result = scriptEngine.eval(script.getScriptAsString(<span class="hljs-string"><span class="hljs-string">"discount.groovy"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleBindings(parameters));</code> </pre> <br>  Obviously, if such a code is scattered throughout the application, it will become incomprehensible into what.  And, of course, if you have more than one script call in your application, then you need to make a separate class for working with them.  Sometimes you can go even further and make special classes that will wrap the <code>evaluateGroovy()</code> calls into regular, typed Java methods.  In these methods there will be a rather uniform service code, as in the example: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyCustomerDiscount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, BigDecimal orderAmount)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; params = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); params.put(<span class="hljs-string"><span class="hljs-string">"cust"</span></span>, customer); params.put(<span class="hljs-string"><span class="hljs-string">"amount"</span></span>, orderAmount); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (BigDecimal)scripting.evalGroovy(getScriptSrc(<span class="hljs-string"><span class="hljs-string">"discount.groovy"</span></span>), params); }</code> </pre><br>  This approach greatly increases the transparency when calling scripts from the application code - you can immediately see which parameters the script accepts, what type they are and what is returned.  The main thing - do not forget to add to the standards of writing code a ban on calling scripts from non-typed methods! <br><br><h2>  We pump scripts </h2><br>  Despite the fact that scripts are easy, if you have a lot of them and you use them intensively, then there is a real chance to face performance problems.  For example, if a bunch of groovy templates are used to generate reports and you run them at the same time, sooner or later this will become one of the bottlenecks in the application's performance. <br>  Therefore, many frameworks make various add-ons over the standard API for improving performance, caching, monitoring execution, using different scripting languages ‚Äã‚Äãin one application, etc. <br><br>  For example, in CUBA a rather clever <a href="https://doc.cuba-platform.com/manual-6.10-ru/scripting.html">scripting</a> engine was made that supports additional features, such as: <br><br><ol><li>  Ability to write scripts in Java and Groovy </li><li>  Class cache to not re-compile scripts </li><li>  JMX bean to control the engine </li></ol><br>  All this, of course, improves performance and usability, but still the low-level engine remains low-level, and you still need to read the script text, pass parameters, and call the API to execute the script.  So you need to still do some wrappers in each project to make development more efficient. <br><br>  And it would be unfair not to mention GraalVM - an experimental engine that can execute programs in different languages ‚Äã‚Äã(JVM and non-JVM) and allows inserting <a href="https://medium.com/p/12d9111f307d">modules into these languages</a> in <a href="https://medium.com/p/12d9111f307d">Java applications</a> .  I hope that Nashorn will go down in history sooner or later, and we will have the opportunity to write parts of the code in different languages ‚Äã‚Äãin one source.  But this is only a dream. <br><br><h2>  Spring Framework: hard to refuse offer? </h2><br>  Spring has built-in support for script execution, built on the basis of the JDK API.  In the <code>org.springframework.scripting.*</code> Package, you can find many useful classes ‚Äî all so that you can conveniently use a low-level API for scripting in your application. <br><br>  In addition, there is a higher level support, it is described in detail in the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/languages.html">documentation</a> .  In short, you need to make a class in a scripting language (for example, Groovy) and publish it as a bin via XML description: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lang:groovy</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"messenger"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script-source</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"classpath:Messenger.groovy"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lang:property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"message"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"I Can Do The Frug"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lang:groovy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  After a bin is published, it can be added to its classes using IoC.  Spring provides automatic script update when changing text in a file, you can hang aspects on methods, etc. <br><br>  It looks good, but you need to make ‚Äúreal‚Äù classes in order to publish them, you can‚Äôt write the usual function in the script.  In addition, the scripts can be stored only in the file system, to use the database will have to climb inside Spring.  Yes, and XML configuration, many consider obsolete, especially if the application is all on the annotations.  This, of course, tastes, but it often has to be considered. <br><br><h2>  Scripts: difficulties and ideas </h2><br>  So, each solution has its price, and, if we talk about scripts in Java applications, then with the implementation of this technology, you may encounter some difficulties: <br><br><ol><li>  Controllability.  Often, script calls are scattered throughout the application, and with changes in the code, it is quite difficult to track calls to the necessary scripts. </li><li>  Ability to find call points.  If something goes wrong in a particular script, then finding all its call points will be a problem, unless you use the search by file name or method calls <code>evaluateGroovy()</code> </li><li>  Transparency.  Writing a script is not an easy task in itself, and even more difficult is for those who call this script.  It is necessary to remember how the input parameters are called, what data type they have and what is the result of the execution.  Or every time to look at the source code of the script. </li><li>  Testing and updating - it is not always possible to test the script in the environment of the application code, and after uploading it to the ‚Äúcombat‚Äù server, you need to somehow be able to quickly roll back everything if something goes wrong. </li></ol><br>  It seems that wrapping script calls in Java methods will help to solve most of the above tasks.  It is quite good if such classes can be published in the IoC container and call methods with normal, meaningful names in their services, instead of calling <code>eval(‚Äúdisc_10_cl.groovy‚Äù)</code> from some utility class.  Another plus is that the code becomes self-documenting, the developer doesn‚Äôt have to worry what algorithm lies behind the file name. <br><br>  On top of that, if each script is associated with only one method, you can quickly find all call points in the application using the ‚ÄúFind Usages‚Äù menu from the IDE and understand the place of the script in each specific business logic algorithm. <br><br>  Testing is simplified - it turns into ‚Äúordinary‚Äù testing of classes, using familiar frameworks, mocks and so on. <br><br>  All of the above is very consonant with the idea mentioned at the beginning of the article - ‚Äúspecial‚Äù classes for methods that are implemented by scripts.  But what if you take one more step and hide the entire service code of the same type for invoking the script engines from the developer so that he doesn't even think about it (well, almost)? <br><br><h2>  Script Repositories - Concept </h2><br>  The idea is quite simple and should be familiar to those who have ever worked with Spring, especially with Spring JPA.  What you need is to make a Java interface and call the script when calling its methods.  In JPA, by the way, an identical approach is used - the call to CrudRepository is intercepted, a query is created based on the method name and parameters, which is then executed by the database engine. <br><br>  What you need to implement the concept? <br><br>  For starters, class level annotation, so that you can find the repository interface and make a bin based on it. <br><br>  Also, probably, annotations on the methods of this interface will be useful in order to store the metadata needed to call the method.  For example - where to get the script text and which engine to use. <br><br>  A useful addition will be the ability to use methods with the implementation in the interface (aka default) - this code will work until the business analyst does not deduce a more complete version of the algorithm, and the developer does not make a script based on <br>  this information.  Or let the analyst script write, and the developer then simply copy it to the server.  There are many options :-) <br><br>  So, suppose that for an online store you need to make a service for calculating discounts based on a user profile.  Right now it is not clear how to do this, but the business analyst swears that all registered users are entitled to a 10% discount, he will find out the rest within a week at the customer.  Service is needed right tomorrow - the season after all.  What might the code look like for such a case? <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ScriptRepository</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PricingRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ScriptMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyCustomerDiscount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, BigDecimal orderAmount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orderAmount.multiply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(<span class="hljs-string"><span class="hljs-string">"0.9"</span></span>)); } }</code> </pre><br>  And then the algorithm itself, written, for example, on groovy, arrives, and there the discounts will be slightly different: <br><br><pre> <code class="plaintext hljs">def age = 50 if ((Calendar.YEAR - customer.birthday.year) &gt;= age) { return orderAmount.multiply(0.75) } else { return orderAmount.multiply(0.9) }</code> </pre><br>  The purpose of all this is to give the developer the opportunity to write only the interface code and the script code, and not to bother with all these calls <code>getEngine</code> , <code>eval</code> and others.  The library for working with scripts should do all the magic - intercept the method call of the interface, get the script text, substitute parameter values, get the necessary script engine, execute the script (or call the default method if there is no script text) and return the value.  Ideally, in addition to code that has already been written, the program should have something like this: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerServiceBean</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomerService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PricingRepository pricingRepository; <span class="hljs-comment"><span class="hljs-comment">//Other injected beans here @Override public BigDecimal applyCustomerDiscount(Customer cust, BigDecimal orderAmnt) { if (customer.isRegistered()) { return pricingRepository.applyCustomerDiscount(cust, orderAmnt); } else { return orderAmnt; } //Other service methods here }</span></span></code> </pre><br>  The challenge is readable, understandable, and to make it, you do not need to have any special skills. <br><br>  These were ideas on the basis of which a small library for working with scripts was made.  It is designed for Spring applications, this framework was used to create a library.  It provides an extensible API for downloading scripts from various sources and executing them, which hides the chore of scripting engines. <br><br><h2>  How it works </h2><br>  For all interfaces marked with <code>@ScriptRepository</code> , when the Spring context is initialized, proxy objects are created using the <code>newProxyInstance</code> class's <code>newProxyInstance</code> method.  These proxies are published in the Spring context as singleton bins, so you can declare a class field with an interface type and annotate it with <code>@Autowired</code> or <code>@Inject</code> .  Exactly as planned. <br><br>  Scanning and processing of script interfaces is activated using the <code>@EnableSriptRepositories</code> annotation, just as in Spring JPA or repositories for MongoDB are activated ( <code>@EnableJpaRepositories</code> and <code>@EnableMongoRepositories</code> respectively).  As parameters of the annotation, you need to specify an array with the names of the packages that you want to scan. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableScriptRepositories</span></span>(basePackages = {<span class="hljs-string"><span class="hljs-string">"com.example"</span></span>, <span class="hljs-string"><span class="hljs-string">"com.sample"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoreConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//More configuration here. }</span></span></code> </pre><br>  Methods need to be annotated with <code>@ScriptMethod</code> (there is also <code>@GroovyScript</code> and <code>@JavaScript</code> , with the appropriate specialization) to add metadata to invoke the script.  Of course, default methods are supported in interfaces. <br><br>  The general library device is shown in the diagram.  Blue highlights the components that need to be developed, whites - which already exist in the library.  The Spring icon indicates components that are available in the Spring context. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/h0/xc/rzh0xc48cr_kw1d97y2i3wrbdvu.png"></div><br>  When the interface method is invoked (in fact, a proxy object), the call handler is launched, which in the context of the application searches for two beans: the provider that will search for the script text, and the executor who will actually execute the found text.  Then the handler returns the result to the calling method. <br><br>  The names of the provider and the executor <code>@ScriptMethod</code> specified in the <code>@ScriptMethod</code> annotation, and there you can also put a limit on the execution time of the method.  Below is an example of library use code: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ScriptRepository</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PricingRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ScriptMethod</span></span> (providerBeanName = <span class="hljs-string"><span class="hljs-string">"resourceProvider"</span></span>, evaluatorBeanName = <span class="hljs-string"><span class="hljs-string">"groovyEvaluator"</span></span>, timeout = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyCustomerDiscount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( @ScriptParam(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cust"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Customer customer, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScriptParam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"amount"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> BigDecimal orderAmount) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orderAmount.multiply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(<span class="hljs-string"><span class="hljs-string">"0.9"</span></span>)); } }</code> </pre><br>  You can see the <code>@ScriptParam</code> annotations - they are needed to specify the names of the parameters when transferring them to the script, since the Java compiler erases the original names from the source (there are ways to force it not to do it, but it‚Äôs better not to rely on it).  You can not specify the names of the parameters, but in this case, the script will need to use ‚Äúarg0‚Äù, ‚Äúarg1‚Äù, which does not greatly improve readability. <br><br>  By default, the library has providers for reading .groovy and .js files from disk and the corresponding artists, which are wrappers over the standard JSR-233 API.  You can create your own beans for different sources of scripts and for different engines, for this you need to implement the appropriate interfaces: <code>ScriptProvider</code> and <code>SpringEvaluator</code> .  The first interface uses <code>org.springframework.scripting.ScriptSource</code> and the second is <code>org.springframework.scripting.ScriptEvaluator</code> .  The Spring API was used so that you could use ready-made classes if they already exist in the application. <br>  The search for the provider and the contractor is done by name for more flexibility ‚Äî you can replace the standard bins from the library in your application, calling your components with the same names. <br><br><h2>  Testing and Versioning </h2><br>  Since the scripts change frequently and easily, you need to have a way to somehow make sure that the changes do not break anything.  The library is compatible with JUnit, the repository can simply be tested as a normal class as part of a unit or integration test.  Mock libraries are also supported, in the tests for the library you can find an example of how to make a mock for the script repository method. <br><br>  If you need versioning, you can create a provider that will read different versions of scripts from the file system, from the database or from Git, for example.  So you can easily organize a rollback to the previous version of the script in case of problems on the main server. <br><br><h2>  Total </h2><br>  The presented library will help to organize scripts in the Spring application: <br><br><ol><li>  The developer will always have information about what parameters the scripts need and what is returned.  And if the interface methods are named meaningfully, then what the script does. </li><li>  Providers and executors will help to keep the code for getting scripts and interaction with the script engine in one place and these calls will not be scattered throughout the application code. </li><li>  All script calls can be easily found using Find Usages. </li></ol><br>  Spring Boot auto configuration, unit testing, mock'i ‚Äã‚Äãis supported.  You can get information about the ‚Äúscript‚Äù methods and their parameters through the API.  You can also wrap the result of the execution with a special ScriptResult object, in which there will be a result or an exception instance, if you do not want to bother with try ... catch when invoking scripts.  XML configuration is supported if it is required for one reason or another.  And finally - you can specify a timeout for the execution of the script method, if the need arises. <br><br>  <a href="https://github.com/cuba-rnd/spring-script-repositories">Library sources are here.</a> </div><p>Source: <a href="https://habr.com/ru/post/431084/">https://habr.com/ru/post/431084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431072/index.html">JavaScript Guide, Part 7: strict mode, this keyword, events, modules, mathematical calculations</a></li>
<li><a href="../431074/index.html">JavaScript Guide, Part 8: ES6 Standard Feature Overview</a></li>
<li><a href="../431078/index.html">Javascript error handling guide</a></li>
<li><a href="../431080/index.html">How to organize remote offices and not lose a team in space</a></li>
<li><a href="../431082/index.html">Kotlin: Looking for Head of Marketing</a></li>
<li><a href="../431086/index.html">Everything you wanted to know about PVS-Studio and did not hesitate to ask</a></li>
<li><a href="../431088/index.html">File management done wrong - Part 1: Hailing from the 90s</a></li>
<li><a href="../431090/index.html">One VC bot, one C # and an orange</a></li>
<li><a href="../431092/index.html">ROS: Map of the depths on the Raspberry Pi "little blood"</a></li>
<li><a href="../431094/index.html">Solitaire sorting</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>