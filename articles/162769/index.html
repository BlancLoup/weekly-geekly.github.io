<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to find a PCI device without an operating system</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the course of work, we occasionally have to deal with rather low-level interaction with the hardware. In this article we want to show how PCI devic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to find a PCI device without an operating system</h1><div class="post__text post__text-html js-mediator-article">  In the course of work, we occasionally have to deal with rather low-level interaction with the hardware.  In this article we want to show how PCI devices are polled to identify them and load the appropriate device drivers. <br><br>  As a minimum base for working with PCI devices, we will use a kernel that supports the Multiboot specification.  This will avoid the need to write your own boot sector and loader.  In addition, this issue is already well covered on the Internet.  GRUB will be the loader.  We will boot from the flash drive, since it is convenient to load both a virtual and a real machine from it.  We will use QEMU as a virtual machine.  The real machine should be a machine with a normal BIOS (not UEFI) that supports booting from USB-HDD (usually there is an option Legacy USB support).  You will need Ubuntu Linux with the following programs: expect, qemu, grub (they can be easily installed using the command sudo apt-get install).  The gcc used should compile a 32 bit code. <br><a name="habracut"></a><br>  Consider the first step - creating a kernel that supports the Multiboot specification.  In the case of using GRUB as a loader, the kernel will be created from 3 files: <br>  <b>Kernel.c</b> is the main file with the code of our program and the main () procedure; <br>  <b>Loader.s</b> - contains the multiboot header for GRUB; <br>  <b>Linker.ld</b> is the ld linker script, which specifically indicates which address the kernel will be located at. <br><br>  Content Linker.ld: <br><pre><code class="cpp hljs">ENTRY (loader) SECTIONS { . = <span class="hljs-number"><span class="hljs-number">0x00100000</span></span>; .<span class="hljs-function"><span class="hljs-function">text </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ALIGN</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span></span>{ *(.text) } .<span class="hljs-function"><span class="hljs-function">rodata </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ALIGN</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span></span>{ *(.rodata*) } .<span class="hljs-function"><span class="hljs-function">data </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ALIGN</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span></span>{ *(.data) } .bss : { sbss = .; *(COMMON) *(.bss) ebss = .; } }</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The linker script indicates how to link the already compiled object files.  The first line indicates that the entry point in our kernel will be the address labeled ‚Äúloader‚Äù.  Further in the script it is indicated that starting from the address 0x00100000 (1Mb) the text section will be located.  The rodata, data, and bss sections are aligned at 0x1000 (4Kb) and are located after the text section. <br><br>  Loader.s content: <br><pre> <code class="cpp hljs">.global loader .<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> FLAGS, <span class="hljs-number"><span class="hljs-number">0x0</span></span> .<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> MAGIC, <span class="hljs-number"><span class="hljs-number">0x1BADB002</span></span> .<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> CHECKSUM, -(MAGIC + FLAGS) .align <span class="hljs-number"><span class="hljs-number">4</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> MAGIC .<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> FLAGS .<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> CHECKSUM <span class="hljs-meta"><span class="hljs-meta"># reserve initial kernel stack space .set STACKSIZE, 0x4000 .lcomm stack, STACKSIZE .comm mbd, 4 .comm magic, 4 loader: movl $(stack + STACKSIZE), %esp movl %eax, magic movl %ebx, mbd call kmain cli hang: hlt jmp hang</span></span></code> </pre><br><br>  After downloading the kernel image from the disk, GRUB searches for the first 8Kb of the downloaded image for the signature 0x1BADB002.  The signature is the first multiboot header field.  The title itself looks like this: <br><table cellpadding="1" width="361"><tbody><tr><td width="55">  <strong>Offset</strong> <br><br></td><td width="54">  <strong>Type</strong> <br><br></td><td width="108">  <strong>Field name</strong> <br><br></td><td width="137">  <strong>Note</strong> <br><br></td></tr><tr><td width="55">  0 <br><br></td><td width="54">  u32 <br><br></td><td width="108">  magic <br><br></td><td width="137">  required <br><br></td></tr><tr><td width="55">  four <br><br></td><td width="54">  u32 <br><br></td><td width="108">  flags <br><br></td><td width="137">  required <br><br></td></tr><tr><td width="55">  eight <br><br></td><td width="54">  u32 <br><br></td><td width="108">  checksum <br><br></td><td width="137">  required <br><br></td></tr><tr><td width="55">  12 <br><br></td><td width="54">  u32 <br><br></td><td width="108">  header_addr <br><br></td><td width="137">  if flags [16] is set <br><br></td></tr><tr><td width="55">  sixteen <br><br></td><td width="54">  u32 <br><br></td><td width="108">  load_addr <br><br></td><td width="137">  if flags [16] is set <br><br></td></tr><tr><td width="55">  20 <br><br></td><td width="54">  u32 <br><br></td><td width="108">  load_end_addr <br><br></td><td width="137">  if flags [16] is set <br><br></td></tr><tr><td width="55">  24 <br><br></td><td width="54">  u32 <br><br></td><td width="108">  bss_end_addr <br><br></td><td width="137">  if flags [16] is set <br><br></td></tr><tr><td width="55">  28 <br><br></td><td width="54">  u32 <br><br></td><td width="108">  entry_addr <br><br></td><td width="137">  if flags [16] is set <br><br></td></tr><tr><td width="55">  32 <br><br></td><td width="54">  u32 <br><br></td><td width="108">  mode_type <br><br></td><td width="137">  if flags [2] is set <br><br></td></tr><tr><td width="55">  36 <br><br></td><td width="54">  u32 <br><br></td><td width="108">  width <br><br></td><td width="137">  if flags [2] is set <br><br></td></tr><tr><td width="55">  40 <br><br></td><td width="54">  u32 <br><br></td><td width="108">  height <br><br></td><td width="137">  if flags [2] is set <br><br></td></tr><tr><td width="55">  44 <br><br></td><td width="54">  u32 <br><br></td><td width="108">  depth <br><br></td><td width="137">  if flags [2] is set <br><br></td></tr></tbody></table><br>  The header must include at least 3 fields - magic, flag, checksum.  The magic field is a signature and, as mentioned above, is always 0x1BADB002.  The flag flag contains additional requirements for the state of the machine at the time of transferring control to the OS.  Depending on the value of this field, the set of fields in the Multiboot Information structure may change.  The pointer to the Multiboot Information structure contains the EBX register at the moment of passing control to the loaded kernel.  In our case, the flag field is set to 0, and the multiboot header consists of only 3 fields. <br><br>  At the time of transferring control to the kernel, the processor is operating in protected mode with paging address turned off.  Device interrupt handling is disabled.  GRUB does not form a stack for a bootable kernel, and this is the first thing the operating system should do.  In our case, 16Kb is allocated for the stack.  The last assembler instruction executed will be the call kmain instruction, which transfers control to the C code, namely the void kmain (void) function. <br><br>  Contents of kernel.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"screen.h"</span></span></span><span class="hljs-meta"> void kmain(void) { clear_screen(); printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" -- Kernel started! -- \n"</span></span></span><span class="hljs-meta">); }</span></span></code> </pre><br><br>  While there is nothing interesting.  From the point of view of loading, it should not contain anything specific, only the entry point for the C code. To display the implementation of the printf function found on the Internet, and several functions for working with video memory, such as putchar, clear_screen, were added. <br><br>  The following simple makefile will be used to build the kernel: <br><pre> <code class="bash hljs">CC = gcc CFLAGS = -Wall -nostdlib -fno-builtin -nostartfiles -nodefaultlibs LD = ld OBJFILES = \ loader.o \ printf.o \ screen.o \ pci.o \ kernel.o start: all cp ./kernel.bin ./flash/boot/grub/ expect ./grub_install.exp qemu /dev/sdb all: kernel.bin .so: as -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> $&lt; .co: $(CC) $(CFLAGS) -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> -c $&lt; kernel.bin: $(OBJFILES) $(LD) -T linker.ld -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> $^ clean: rm $(OBJFILES) kernel.bin</code> </pre><br><br>  Now we have a kernel that can be downloaded.  It's time to check that it really loads.  Install GRUB on a USB flash drive and tell it to load our kernel at startup.  To do this, follow these steps: <br><br>  1. Create a partition on a flash drive, format it into a file system supported by GRUB (in our case it is FAT32 file system).  We used Disk Utility from the Ubuntu suite, which allowed us to create a partition: <br><br><img src="http://habrastorage.org/storage2/a84/013/8be/a840138be0b3a6390363451ae40c85f9.jpg"><br><br>  2. Mount the USB flash drive and create the directory / boot / grub /.  Copy stage1, stage2, fat_stage1_5 files from / usr / lib into it.  Create a menu.lst text file in the / boot / grub / directory and write to it <br><pre> <code class="cpp hljs">timeout <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-function">title start_kernel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hd0,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> kernel /boot/grub/kernel.bin</span></span></code> </pre><br><br>  To install GRUB on a USB flash drive, use the expect script in the grub_install.exp file.  Its contents are: <br><br><pre> <code class="cpp hljs">log_user <span class="hljs-number"><span class="hljs-number">0</span></span> spawn grub expect <span class="hljs-string"><span class="hljs-string">"grub&gt; "</span></span> send <span class="hljs-string"><span class="hljs-string">"root (hd1,0)\r"</span></span> expect <span class="hljs-string"><span class="hljs-string">"grub&gt; "</span></span> send <span class="hljs-string"><span class="hljs-string">"setup (hd1)\r"</span></span> expect <span class="hljs-string"><span class="hljs-string">"grub&gt; "</span></span> send <span class="hljs-string"><span class="hljs-string">"quit\r"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><br>  In a particular case, other disk numbers and device names are possible.  Ultimately, compiling and running the virtual machine should be done with the make start command.  This makefile command will install GRUB on a flash drive using the grub_install.exp script, and then start the QEMU virtual machine with our program.  Since everything is loaded from a real flash drive, it is possible to boot from it not only the QEMU virtual machine, but also the real computer. <br><br>  A running QEMU virtual machine with our program looks like this: <br><br><img src="http://habrastorage.org/storage2/edb/dda/872/edbdda872318214dc2440ed37887467b.png"><br><br>  Now we will deal with the main task - transfer of all PCI devices available on a computer.  PCI is the main bus with devices on the computer.  In addition to the usual devices that are inserted into the well-known slots on the motherboard, there are devices connected to the motherboard itself (the so-called On-board devices), as well as a number of controllers (for example, USB) and bridges to other buses ( for example, PCI-ISA bridge).  Thus, PCI is the main bus on the computer from which to begin polling all its devices. <br><br>  Associated with each PCI device is a 256-byte structure (PCI Configuration Space) in which its settings are located.  The device configuration ultimately boils down to writing and reading data from this structure.  For all PCI devices, reading and writing data occurs via 2 I / O ports: <br>  0xcf8 is a configuration port where a PCI address is written; <br>  0xcfc is the data port through which data is read and written to the PCI address specified in the configuration port. <br><br>  When reading data from the PCI Configuration Space, you can get information about the device, and by writing data to the device you can configure it. <br><br>  The PCI address is the following 32-bit structure: <br><table cellpadding="7" width="639"><tbody><tr><td width="67">  Bit 31 <br><br></td><td width="118">  Bits 30 - 24 <br><br></td><td width="68">  Bits 23 - 16 <br><br></td><td width="75">  Bits 15 - 11 <br><br></td><td width="71">  Bits 10 - 8 <br><br></td><td width="71">  Bits 7 - 2 <br><br></td><td width="68">  Bits 1 - 0 <br><br></td></tr><tr><td width="67">  Always 1 <br><br></td><td width="118">  Reserved <br><br></td><td width="68">  Tire number <br><br></td><td width="75">  Device number <br><br></td><td width="71">  Function number <br><br></td><td width="71">  Register number <br><br></td><td width="68">  Always 0 <br><br></td></tr></tbody></table><br>  The bus number along with the device number identify the physical device on the computer.  A physical device may include several logical devices that are identified by a function number (for example, a video capture card with a Wi-Fi controller will have at least two functions). <br><br>  PCI Configuration Space is conventionally divided into registers of 4 bytes.  The register number that is accessed is stored from 2nd to 7th bits in a 32-bit PCI address.  The fields of the PCI Configuration Space structure describing a PCI device depend on its type.  But for all types of devices, the first 4 registers of the structure contain the following fields: <br><table><tbody><tr><td width="113">  Register number <br><br></td><td width="114">  Bits 31 - 24 <br><br></td><td width="114">  Bits 23 - 16 <br><br></td><td width="114">  Bits 15 - 8 <br><br></td><td width="113">  Bits 7 - 0 <br><br></td></tr><tr><td width="113">  0 <br><br></td><td colspan="2" width="241">  Device ID <br><br></td><td colspan="2" width="241">  Vendor id <br><br></td></tr><tr><td width="113">  one <br><br></td><td colspan="2" width="241">  Status <br><br></td><td colspan="2" width="241">  Command <br><br></td></tr><tr><td width="113">  2 <br><br></td><td width="114">  Class code <br><br></td><td width="114">  Subclass <br><br></td><td width="114">  Prog IF <br><br></td><td width="113">  Revision ID <br><br></td></tr><tr><td width="113">  3 <br><br></td><td width="114">  Bist <br><br></td><td width="114">  Header type <br><br></td><td width="114">  Latency timer <br><br></td><td width="113">  Cache Line Size <br><br></td></tr></tbody></table><br>  <b>Class code</b> - describes the type (class) of the device in terms of the functions that the device performs (network adapter, video card, etc.); <br>  <b>Vendor ID</b> - identifier of the device manufacturer (each device manufacturer in the world has one or several such unique identifiers).  These numbers are issued by the international organization PCI SIG; <br>  <b>Device ID</b> - unique device identifier (unique for a given Vendor ID).  Their numbering is determined by the manufacturer itself. <br><br>  The DeviceID (abbreviated as DEV) and VendorID (abbreviated as VEN) fields determine the driver corresponding to this device.  Sometimes this also uses the additional RevisionID (abbreviated as REV).  In other words, Windows, when discovering a new device on a computer, uses VEN, DEV, and REV numbers to search for the corresponding drivers on their disk or on the Internet, using a Microsoft server.  Also, these numbers can be found in the device manager: <br><br><img src="http://habrastorage.org/storage2/d5c/1f6/823/d5c1f68233bef8ceb9cab3c3f489bd44.png"><br><br>  Consider the code that implements the easiest way to get a list of PCI devices on a computer: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadPCIDevHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 bus, u32 dev, u32 func, PCIDevHeader *p_pciDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_pciDevice == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(p_pciDevice-&gt;header)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(p_pciDevice-&gt;header[<span class="hljs-number"><span class="hljs-number">0</span></span>]); i++) ReadConfig32(bus, dev, func, i, &amp;p_pciDevice-&gt;header[i]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_pciDevice-&gt;option.vendorID == <span class="hljs-number"><span class="hljs-number">0x0000</span></span> || p_pciDevice-&gt;option.vendorID == <span class="hljs-number"><span class="hljs-number">0xffff</span></span> || p_pciDevice-&gt;option.deviceID == <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kmain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bus; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dev; clear_screen(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" -- Kernel started! -- \n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (bus = <span class="hljs-number"><span class="hljs-number">0</span></span>; bus &lt; PCI_MAX_BUSES; bus++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (dev = <span class="hljs-number"><span class="hljs-number">0</span></span>; dev &lt; PCI_MAX_DEVICES; dev++) { u32 func = <span class="hljs-number"><span class="hljs-number">0</span></span>; PCIDevHeader pci_device; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ReadPCIDevHeader(bus, dev, func, &amp;pci_device)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; PrintPCIDevHeader(bus, dev, func, &amp;pci_device); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pci_device.option.headerType &amp; PCI_HEADERTYPE_MULTIFUNC) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (func = <span class="hljs-number"><span class="hljs-number">1</span></span>; func &lt; PCI_MAX_FUNCTIONS; func++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ReadPCIDevHeader(bus, dev, func, &amp;pci_device)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; PrintPCIDevHeader(bus, dev, func, &amp;pci_device); } } } }</code> </pre><br><br>  In this code, a complete enumeration of bus numbers and device numbers in the address at which reading occurs occurs.  If the Header type field contains the PCI_HEADERTYPE_MULTIFUNC flag, then this physical device implements several logical devices, and when searching for PCI devices in the address that is written to the configuration port, it is necessary to go through the function number.  If VendorID has an incorrect value, then there is no device with that number on this bus.  On Qemu, this code displays the following result: <br><br><img src="http://habrastorage.org/storage2/a5d/e14/e04/a5de14e041c9e46580215ca756c31d9c.png"><br><br>  0x8086 is Intel's VendorID hardware.  A DeviceID of 0x7000 corresponds to the PIIX3 PCI-to-ISA Bridge device.  Boot from the resulting flash drive in VmWare Workstation 9.0.  The list of PCI devices is much longer and looks like this: <br><br><img src="http://habrastorage.org/storage2/3a3/97c/bae/3a397cbaeb8109e7926c0ac29f4ccdd8.png"><br><br>  Here is the search for PCI devices in the system.  This action is performed on all modern operating systems running on IBM PCs.  The next step in the operation of the operating system is to search for drivers and configure the devices found, and this already happens in a unique way for each device individually. </div><p>Source: <a href="https://habr.com/ru/post/162769/">https://habr.com/ru/post/162769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162757/index.html">THQ and nVidia give out Metro 2033 for free</a></li>
<li><a href="../162759/index.html">Moving from Google Maps to Yandex MapKit</a></li>
<li><a href="../162763/index.html">Feedback on the book "Durov Code" N. Kononov</a></li>
<li><a href="../162765/index.html">Simple-Science - Simple Experiments (Digest # 11)</a></li>
<li><a href="../162767/index.html">Million downloads per month or how to make a good start on Google Play</a></li>
<li><a href="../162771/index.html">Pong machine reconstruction</a></li>
<li><a href="../162773/index.html">Digitization of large negatives</a></li>
<li><a href="../162775/index.html">JavaScript update of the ECT template engine has been released</a></li>
<li><a href="../162777/index.html">New for web designer for the first half of December</a></li>
<li><a href="../162779/index.html">Google refuses to sync Exchange on free accounts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>