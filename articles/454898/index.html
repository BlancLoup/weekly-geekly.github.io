<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming is more than coding</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a translation of the Stanford workshop . But before her a small entry. How are zombies formed? Everyone got into a situation when they...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming is more than coding</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ow/dt/zc/owdtzc1fkeq1an3-af8nvvntpvw.jpeg"></p><br><p>  This article is a translation of the <a href="https://www.youtube.com/watch%3Fv%3D6QsTfL-uXd8">Stanford workshop</a> .  But before her a small entry.  How are zombies formed?  Everyone got into a situation when they want to pull a friend or colleague up to their level, but it does not work.  Moreover, ‚Äúit does not work out‚Äù not so much with you, as with him: on one side of the scale there is a normal salary, tasks and so on, and on the other - the need to think.  Thinking is unpleasant and painful.  He quickly gives up and continues to write code, completely without including the brain.  You can imagine how much effort you need to spend to overcome the barrier of learned helplessness, and you simply do not do it.  This is how zombies are formed, which seem to be cured, but no one seems to be doing this either. </p><br><p>  When I saw that <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D1%258D%25D0%25BC%25D0%25BF%25D0%25BE%25D1%2580%25D1%2582,_%25D0%259B%25D0%25B5%25D1%2581%25D0%25BB%25D0%25B8">Leslie Lamport</a> (yes, that very comrade of textbooks) was <a href="https://hydraconf.ru/2019/talks/6evatt1mvwvpnwfxxveivw/%3Futm_source%3Dhabr%26utm_medium%3D454898">coming to Russia</a> and was not making a report, but a question-and-answer session, I was wary of a bit.  Just in case, Leslie is a world-renowned scientist, the author of fundamental works in distributed computing, and you can also know him by the letters La in the word LaTeX - ‚ÄúLamport TeX‚Äù.  The second alarming factor is his demand: everyone who comes must (absolutely for free) listen in advance to a couple of his reports, come up with at least one question on them and only then come.  I decided to see what Lamport is saying there - and this is great!  That is exactly the thing, the magic reference tablet for treating zombies.  I warn you: from the text can significantly burn in lovers of super-flexible methodologies and nonlovers to test writing. </p><br><p>  After Habrokat, in fact, the translation of the seminar begins.  Enjoy reading! <a name="habracut"></a></p><hr><br><p>  Whatever task you undertake, you always need to go through three steps: </p><br><ul><li>  decide what goal you want to achieve; </li><li>  decide exactly how you will achieve your goal; </li><li>  come to your goal. </li></ul><br><p>  This also applies to programming.  When we write code, we need to: </p><br><ul><li>  decide what the program should do; </li><li>  determine exactly how it should perform its task; </li><li>  write the appropriate code. </li></ul><br><p>  The last step, of course, is very important, but I will not talk about it today.  Instead, we discuss the first two.  Each programmer executes them before starting work.  You do not sit down to write if you have not decided what you are writing: a browser or a database.  A certain idea of ‚Äã‚Äãthe goal must be present.  And you always think over what exactly the program will do, and do not write somehow in the hope that the code itself will somehow turn into a browser. </p><br><p>  How exactly does this preliminary code thinking?  How much effort should we spend on it?  It all depends on how difficult the problem we solve.  Suppose we want to write a fault-tolerant distributed system.  In this case, we should think about everything properly before sitting behind the code.  And if we just need to increase the integer variable by 1?  At first glance, everything is trivial here, and no thinking is needed, but then we recall that an overflow may occur.  Therefore, even in order to understand whether a problem is simple or complex, one must first think. </p><br><p>  If you first think about possible solutions to the problem, you can avoid mistakes.  But for this you need your thinking to be clear.  To achieve this, you need to write down your thoughts.  I really like Dick Gindon's quote: ‚ÄúWhen you write, nature shows you how untidy your thinking is.‚Äù  If you do not write, it only seems to you that you are thinking.  And you need to write down your thoughts in the form of specifications. </p><br><p>  Specifications perform many functions, especially in large projects.  But I will only talk about one of them: they help us to think clearly.  Clear thinking is very important and quite difficult, so here we need any help.  What language should we write the specifications in?  In general, this is always the first question for programmers: in what language we will write.  There is no one right answer to it: the problems that we solve are too diverse.  For some, TLA + is a specification language that I developed.  For others, it is more convenient to use Chinese.  It all depends on the situation. </p><br><p>  Another question is more important: how to achieve clearer thinking?  Answer: we must think like scientists.  This is a way of thinking that has proven itself well over the past 500 years.  In science, we build mathematical models of reality.  Astronomy was probably the first science in the strict sense of the word.  In the mathematical model used in astronomy, celestial bodies appear as points with mass, position and momentum, although in reality they are extremely complex objects with mountains and oceans, ebbs and flows.  This model, like any other, was created to solve certain problems.  It is great for determining where to send a telescope if you need to find a planet.  But if you want to predict the weather on this planet, this model will not work. </p><br><p>  Mathematics allows us to determine the properties of the model.  And science shows how these properties relate to reality.  Let's talk about our science, computer science.  The reality with which we work is computing systems of various types: processors, game consoles, computers, executing programs, and so on.  I will talk about the execution of the program on the computer, but, by and large, all these conclusions apply to any computer system.  In our science, we use many different models: the Turing machine, partially ordered sets of events, and many others. </p><br><p>  What is a program?  This is any code that can be considered independently.  Suppose we need to write a browser.  We perform three tasks: we design the presentation of the program for the user, then we write the high-level scheme of the program, and, finally, we write the code.  In the course of writing code, we understand that we need to write a tool for formatting text.  Here again we need to solve three problems: to determine what text this tool will return;  select an algorithm for formatting;  write code.  This task has its own subtask: correctly insert a hyphen in the words.  We also solve this subtask in three steps - as we see, they are repeated on many levels. </p><br><p>  Let us consider in more detail the first step: what problem the program solves.  Here we most often model a program as a function that receives some input data and gives some output data.  In mathematics, a function is usually described as an ordered set of pairs.  For example, the squaring function for natural numbers is described as a set {&lt;0,0&gt;, &lt;1,1&gt;, &lt;2,4&gt;, &lt;3,9&gt;, ...}.  The domain of such a function is the set of the first elements of each pair, that is, natural numbers.  To define a function, we need to specify its scope and formula. </p><br><p> But functions in mathematics are not the same as functions in programming languages.  Math is much simpler.  Since I have no time for complex examples, consider a simple one: a function in C or a static method in Java that returns the greatest common divisor of two integers.  In the specification of this method, we write: calculates <code>GCD(M,N)</code> for the arguments <code>M</code> and <code>N</code> , where <code>GCD(M,N)</code> is the function whose domain is the set of pairs of integers, and the return value is the largest integer divided by <code>M</code> and <code>N</code>  How does reality relate to this model?  The model operates with integers, and in C or Java we have a 32-bit <code>int</code> .  This model allows us to decide if the <code>GCD</code> algorithm is correct, but it does not prevent an overflow error.  This would require a more complex model for which there is no time. </p><br><p>  Let's talk about the limitations of the function as a model.  The work of some programs (for example, operating systems) is not limited to returning a specific value for certain arguments, they can be performed continuously.  In addition, the function as a model is poorly suited for the second step: planning the way to solve the problem.  Quick sorting and bubble sorting compute the same function, but these are completely different algorithms.  Therefore, to describe how to achieve the goal of the program, I use a different model, let's call it the standard behavioral model.  The program in it is represented as the set of all permissible behaviors, each of which, in turn, is a sequence of states, and the state is the assignment of values ‚Äã‚Äãto variables. </p><br><p>  Let's see what the second step will look like for the Euclidean algorithm.  We need to calculate <code>GCD(M, N)</code> .  We initialize <code>M</code> as <code>x</code> , and <code>N</code> as <code>y</code> , then retake the smaller of these variables from the larger one until they are equal.  For example, if <code>M = 12</code> and <code>N = 18</code> , we can describe the following behavior: </p><br><p> <code>[x = 12, y = 18] ‚Üí [x = 12, y = 6] ‚Üí [x = 6, y = 6]</code> </p> <br><p>  And if <code>M = 0</code> and <code>N = 0</code> ?  Zero is divided into all numbers, so the greatest divisor in this case is not.  In this situation, we need to go back to the first step and ask: do we really need to calculate the GCD for non-positive numbers?  If this is not necessary, then you just need to change the specification. </p><br><p>  Here we should make a small digression about productivity.  It is often measured in the number of lines of code written per day.  But your work is much more useful if you get rid of a certain number of lines, because you have less space for bugs.  And the easiest way to get rid of the code is in the first step.  It is possible that you simply do not need all the bells and whistles that you are trying to implement.  The fastest way to simplify a program and save time is not to do things you should not do.  The second step is second in potential to save time.  If you measure productivity in the number of written lines, thinking through the way to perform the task will make you <em>less productive</em> , since you can solve the same problem with a smaller amount of code.  I can‚Äôt give exact statistics here, because I don‚Äôt have a way to count the number of lines that I didn‚Äôt write because I spent the time on the specification, that is, on the first and second steps.  And the experiment here is also not set, because in the experiment we do not have the right to perform the first step, the task is determined in advance. </p><br><p>  In informal specifications, it is easy to ignore many difficulties.  There is nothing difficult in writing strict specifications for functions; I will not discuss this.  Instead, we'll talk about writing strict specifications for standard behavioral models.  There is a theorem that states that any set of behaviors can be described using the <em>safety</em> property and the <em>liveness property</em> .  Security means that nothing bad will happen, the program will not give the wrong answer.  Vitality means that sooner or later something good will happen, that is, the program will sooner or later give the correct answer.  As a rule, security is a more important indicator, errors often occur here.  Therefore, to save time, I will not talk about survivability, although it is, of course, also important. </p><br><p>  We achieve security by prescribing, firstly, the set of possible initial states.  And, secondly, the relationship with all possible following states for each state.  We will behave as scientists and determine the state mathematically.  The set of initial states is described by the formula, for example, in the case of the Euclidean algorithm: <code>(x = M) ‚àß (y = N)</code> .  For certain values ‚Äã‚Äãof <code>M</code> and <code>N</code> there is only one initial state.  The relationship with the next state is described by a formula in which the variables of the next state are written with a stroke, and the current state is written without a stroke.  In the case of the Euclidean algorithm, we will deal with the disjunction of two formulas, in one of which <code>x</code> is the largest value and in the second - <code>y</code> : </p><br><p><img width="400" src="https://habrastorage.org/webt/cy/uf/ny/cyufnyfpfzj-oe6jwdxr7p3jwn4.png"><br></p><br><p>  In the first case, the new value of y is equal to the former value of y, and we get the new value of x, taking the smaller variable from the larger variable.  In the second case, we do the opposite. </p><br><p>  Let's return to the Euclidean algorithm.  Suppose again that <code>M = 12</code> , <code>N = 18</code> .  This defines a single initial state, <code>(x = 12) ‚àß (y = 18)</code> .  Then we substitute these values ‚Äã‚Äãinto the formula above and we get: </p><br><p><img width="400" src="https://habrastorage.org/webt/r5/q7/wd/r5q7wdsl5ag5ivq_lj_aggn003i.png"><br></p><br><p>  Here the only possible solution is: <code>x' = 18 - 12 ‚àß y' = 12</code> , and we get the behavior: <code>[x = 12, y = 18]</code> .  In the same way, we can describe all the states in our behavior: <code>[x = 12, y = 18] ‚Üí [x = 12, y = 6] ‚Üí [x = 6, y = 6]</code> . </p><br><p>  In the last state <code>[x = 6, y = 6]</code> both parts of the expression will be false, therefore, it does not have the next state.  So, we have the complete specification of the second step - as we see, this is quite ordinary mathematics, as in engineers and scientists, and not strange, as in computer science. </p><br><p>  These two formulas can be combined into one formula of temporal logic.  She is elegant and easy to explain, but there is no time for her now.  We may need temporal logic only for the property of liveliness, for safety it is not needed.  Temporal logic doesn‚Äôt like per se, it‚Äôs not quite ordinary mathematics, but in the case of liveliness it is a necessary evil. </p><br><p>  In the Euclidean algorithm, for each value of <code>x</code> and <code>y</code> there are unique values ‚Äã‚Äãof <code>x'</code> and <code>y'</code> , which make the relationship with the next state true.  In other words, the Euclidean algorithm is deterministic.  To model a non-deterministic algorithm, it is necessary that the current state has several possible future states, and that each value of a variable without a prime has several values ‚Äã‚Äãof a variable with a stroke, in which the relation with the next state is true.  It is easy to do, but now I will not give examples. </p><br><p>  To make a working tool, you need formal mathematics.  How to make a specification formal?  For this we need a formal language, for example, <a href="https://en.wikipedia.org/wiki/TLA%252B">TLA +</a> .  The specification of the Euclidean algorithm in this language will be as follows: </p><br><p><img src="https://habrastorage.org/webt/zo/lj/d_/zoljd_r8zrqhtvbxw2lsrfrowd0.png"></p><br><p>  The symbol of an equals sign with a triangle means that the value to the left of the sign is defined as equal to the value to the right of the sign.  In essence, a specification is a definition, in our case two definitions.  To the specification in TLA + you need to add declarations and some syntax, as in the slide above.  In ASCII, it will look like this: </p><br><p><img src="https://habrastorage.org/webt/mm/nr/oi/mmnroilzmfk9stt9ayv8lkzmo6w.png"></p><br><p>  As you can see, nothing complicated.  The specification for TLA + can be checked, i.e. bypass all possible behaviors in a small model.  In our case, this model will be certain values ‚Äã‚Äãof <code>M</code> and <code>N</code>  This is a very effective and easy way to check, which is entirely performed automatically.  In addition, you can write a formal proof of truth and check them mechanically, but it takes a lot of time, so almost no one does. </p><br><p>  The main disadvantage of TLA + is that it is math, and programmers and computer scientists are afraid of mathematics.  At first glance, this sounds like a joke, but, unfortunately, I say this in all seriousness.  My colleague just told me how he tried to explain TLA + to several developers.  As soon as the formulas appeared on the screen, they immediately had glass eyes.  So if TLA + is scary, <a href="https://en.wikipedia.org/wiki/PlusCal">PlusCal</a> can be used, it's a kind of toy programming language.  The PlusCal expression can be any TLA + expression, that is, by and large, any mathematical expression.  PlusCal also has syntax for non-deterministic algorithms.  Due to the fact that PlusCal can write any TLA + expression, it is much more expressive of any real programming language.  Further, PlusCal is compiled into an easily readable TLA + specification.  This does not mean, of course, that the PlusCal complex specification will turn into a simple one on TLA + - just the correspondence between them is obvious, there will be no additional complexity.  Finally, this specification can be verified with TLA + tools.  In general, PlusCal can help overcome the phobia of mathematics, it is easy to understand even for programmers and computer scientists.  In the past, I have been posting algorithms on it for some time (about 10 years). </p><br><p>  Perhaps someone will argue that TLA + and PlusCal is mathematics, and mathematics only works on invented examples.  In practice, we need a real language with types, procedures, objects, and so on.  This is not true.  Here is what Chris Newcomb, who worked at Amazon, writes: <em>‚ÄúWe used TLA + in ten large projects, and in each case its use made a significant contribution to the development, because we were able to catch dangerous bugs before getting into production, and because he gave us understanding and confidence required for aggressive performance optimizations that do not affect the truth of the program</em> . <em>‚Äù</em>  You can often hear that when using formal methods we get an inefficient code - in practice everything is exactly the opposite.  In addition, there is a perception that managers cannot be convinced of the need for formal methods, even if programmers are convinced of their usefulness.  And Newcomb writes: <em>"Managers are now strongly urging them to write specifications for TLA +, and they specifically set aside time for this</em> . <em>"</em>  So when managers see that TLA + works, they gladly accept it.  Chris Newcomb wrote this about six months ago (in October 2014), now, as far as I know, TLA + is used in 14 projects, not 10. Another example relates to designing the XBox 360. An intern came to Charles Tecker and wrote specification for memory system.  Thanks to this specification, a bug was found that otherwise would not have been noticed, and because of which each XBox 360 would fall after four hours of use.  IBM engineers confirmed that their tests would not have discovered this bug. </p><br><p>  For more information about TLA +, you can read on the Internet, and now let's talk about informal specifications.  We rarely have to write programs that compute the smallest common factor and the like.  Much more often, we write programs like the pretty print printer tool I wrote for TLA +.  After the simplest processing, the TLA + code would look like this: </p><br><p><img src="https://habrastorage.org/webt/mj/ec/pn/mjecpnkv3gl2fc19kkjx2b9efjc.png"></p><br><p>  But in the above example, the user most likely wanted the conjunction and equality signs to be aligned.  So correct formatting would look more like this: </p><br><p><img src="https://habrastorage.org/webt/ge/wv/hw/gewvhwsosox33onfpga4lhmygx8.png"></p><br><p>  Consider another example: </p><br><p><img src="https://habrastorage.org/webt/bo/ld/b1/boldb1vyzar9r21bc4x2mwwhaju.png"></p><br><p>  Here, on the contrary, the alignment of the signs of equality, addition and multiplication in the source was random, therefore the simplest processing itself is quite sufficient.  In general, there is no exact mathematical definition of correct formatting, because ‚Äúcorrect‚Äù in this case means ‚Äúwhat the user wants,‚Äù and this cannot be mathematically determined. </p><br><p>  It would seem that if we do not have a definition of truth, then the specification is useless.  But it is not.  If we don‚Äôt know what the program should do, it doesn‚Äôt mean that we don‚Äôt need to think about its work - on the contrary, we have to spend even more on it.  The specification here is especially important.  It is impossible to determine the optimal program for structural printing, but this does not mean that we should not take it at all, and writing code as a stream of consciousness is not the case.  As a result, I wrote a specification of six rules with definitions <strong>in the form of comments</strong> in a Java file.  Here is an example of one of the rules: <code>a left-comment token is LeftComment aligned with its covering token</code> .  This rule is written in, say, mathematical English: <code>LeftComment aligned</code> , <code>left-comment</code> and <code>covering token</code> are terms with definitions.  This is how mathematicians describe mathematics: they write definitions of terms and, based on them, the rules.  The benefit of such a specification is that it is much easier to understand and debug six rules than 850 lines of code.  I must say that it was not easy to write these rules, it took quite a lot of time to debug them.  Especially for this purpose, I wrote code that reported exactly which rule is used.  Due to the fact that I checked these six rules with a few examples, I did not need to debug 850 lines of code, and the bugs were quite easy to find.  Java has excellent tools for this.  If I just wrote the code, then it would take me much more time, and the formatting would be of worse quality. </p><br><p>  Why it was impossible to use a formal specification?  On the one hand, the correctness of the implementation here is not too important.  Structural printout surely will not please someone, so I didn‚Äôt have to seek correct work in all non-ordinary situations.  More importantly, I did not have the right tools.  The TLA + model validator is useless here, so I would have to manually write examples. </p><br><p>  This specification has features common to all specifications.  It is a higher level than the code.  You can implement it in any language.  To write it useless any tools or methods.  No programming course will help you write this specification.  And there are no tools that could make this specification unnecessary, unless, of course, you are not writing a language specifically for writing TLA + structural print programs.  Finally, this specification says nothing about how exactly we will write code, it only indicates what this code does.  We are writing a specification to help us think through a problem before we start thinking about code. </p><br><p>  But this specification has features that distinguish it from other specifications.  95% of other specifications are significantly shorter and simpler: </p><br><p><img src="https://habrastorage.org/webt/0e/h0/yc/0eh0yc0ql97fhbwkcc6l5opii8c.png"></p><br><p>  Further, this specification is a set of rules.  This is usually a sign of poor specs.  It is rather difficult to understand the consequences of a set of rules, which is why I had to spend a lot of time debugging them.  However, in this case I could not find a better way. </p><br><p>  It is worth saying a few words about programs that run continuously.  As a rule, they work in parallel, for example, operating systems or distributed systems.  Very few people can understand them in mind or on paper, and I don‚Äôt belong to them, although once I could do it.  Therefore, we need tools that will check our work - for example, TLA + or PlusCal. </p><br><p>  Why was it necessary to write a specification if I already knew what exactly the code should do?  In fact, it only seemed to me as if I knew it.  In addition, if there is a specification, the stranger no longer needs to get into the code in order to understand what he is doing.  I have a rule: there should be no general rules.  This rule, of course, has an exception, this is the only general rule that I follow: the specification of what the code does should tell people everything they need to know when using this code. </p><br><p>  So, what exactly do programmers need to know about thinking?  For a start, the same as everyone: if you don‚Äôt write, it only seems to you that you are thinking.  In addition, you need to think before you code, which means you need to write, before you code.  The specification is what we write before we start coding.  The specification is needed for any code that can be used or modified by anyone.  And this ‚Äúsomeone‚Äù can be the author of the code itself a month after writing it.  Specification is needed for large programs and systems, for classes, for methods, and sometimes even for complex sections of a particular method.  What exactly needs to be written about the code?  It is necessary to describe what it does, that is, something that can be useful to anyone using this code.  Sometimes it may also be necessary to specify exactly how the code achieves its goal.  If this method we passed in the course of the algorithms, then we call it an algorithm.  If it is something more special and new, then we call it high-level design.  There is no formal difference: both are abstract models of the program. </p><br><p>  How exactly should write the code specification?  The main thing: it should be a level above the code itself.  It should describe the state and behavior.  It must be as strict as the task requires.  If you are writing a specification for how to implement a task, you can write it in pseudo-code or using PlusCal.  Learning to write specifications is necessary on formal specifications.  This will give you the necessary skills that will help including with the informal.  How to learn to write formal specifications?  When we studied programming, we wrote programs and then debugged them.    :   ,          . TLA+, ,       ,           .  TLA+  ,      . </p><br><p>     ?   ,       .     ,            .    ,       . </p><br><p>  ,           .    ,     ,       .      ,     .        .      ,  ,    .  ,           .      ,      . </p><br><p>   ‚Äî      .         ‚Äî        Amazon.      .          ?    .   ,      ,    .    ,  .       ‚Äî    ,    .        .  . </p><br><p>    .   -  ,    ,     .  ,  - ,  ,        .             .   ,     .      , ,  .       ,     ? -,  ,     ,         ,        .       ,    .     ,  . ,    ,    . -,      ,       .   .       ,      ,         . </p><br><p>   <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25B9%25D0%25B7%25D0%25B5%25D0%25BD%25D1%2585%25D0%25B0%25D1%2583%25D1%258D%25D1%2580,_%25D0%2594%25D1%2583%25D0%25B0%25D0%25B9%25D1%2582_%25D0%2594%25D1%258D%25D0%25B2%25D0%25B8%25D0%25B4"></a> , <em>       ,         </em> .    -  .  ,    ‚Äî   .    ,    ,    .    , ,      ,  ,     .       .    ,     .   ,     ,   ‚Äî  .      ,    . </p><br><p>   TLA+  PlusCal     ,        <a href="https://lamport.azurewebsites.net/tla/tla.html"> </a> .     ,   . </p><br><blockquote> ,   .      ‚Äî ,     .       ,      Hydra 2019,   11-12  2019   -.    <a href="https://hydraconf.ru/%3Futm_source%3Dhabr%26utm_medium%3D454898">  </a> . </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/454898/">https://habr.com/ru/post/454898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454884/index.html">Readable Naming Tests in JS and Behavioral Pattern</a></li>
<li><a href="../454886/index.html">In the liver sits. Why removal of liver tumors is an indicator of the surgeon's superior skill</a></li>
<li><a href="../45489/index.html">Unicode Normalization</a></li>
<li><a href="../454894/index.html">WWDC 2019 :: what to see</a></li>
<li><a href="../454896/index.html">Why I changed my freelance to a remote team</a></li>
<li><a href="../4549/index.html">AllofMP3.com accuses America of "speculation"</a></li>
<li><a href="../45490/index.html">Programming cost</a></li>
<li><a href="../454900/index.html">How to make web forms on the site convenient and safe: development tools and designers</a></li>
<li><a href="../454904/index.html">Samsung opens a free online course on neural networks in computer vision tasks</a></li>
<li><a href="../454906/index.html">Rating sites additional education in IT: the results of the study "My Circle"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>