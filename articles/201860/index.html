<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lua API ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello colleagues. 
 I want to introduce you to my small project, which I hope can be useful to you. 

 I met Lua a few years ago when I was looking fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lua API ++</h1><div class="post__text post__text-html js-mediator-article">  Hello colleagues. <br>  I want to introduce you to my small project, which I hope can be useful to you. <br><br>  I met <a href="http://www.lua.org/">Lua a</a> few years ago when I was looking for a scripting language to be implemented that is distinguished by its modest size and high performance.  Lua not only answers these requests, but also captivates with surprising simplicity and expressiveness. <br><br>  I can not say that I am dissatisfied with the Lua API: it is an excellent set of functions, convenient and easy to use.  The integration of the language into your application and the addition of your own extensions did not cause difficulties, there were no ‚Äúpitfalls‚Äù either.  But still, using this C-oriented API, I was not left with the idea that this process could be more comfortable.  The first attempt to make a convenient object-oriented wrapper failed: with the available means I did not manage to create something worthy of existence, everything was too cumbersome and not obvious. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And then <b>C ++ 11 appeared</b> , which removed all the obstacles that hindered me (more precisely, added what was missing), and the puzzle gradually began to take shape.  The second run was successful, and as a result I was able to create a fairly lightweight wrapper library with the natural syntax of most operations.  This library, which I called <a href="https://github.com/OldFisher/lua-api-pp">Lua API ++</a> , is intended to serve as a convenient replacement for the Lua API.  This article, based on my presentation at the Lua Workshop, will help you get acquainted with the basic concepts of the Lua API ++ and the features it provides. <a name="habracut"></a><br><br><hr><br><h4>  The main actors </h4><br>  Familiarity should begin with the basic concepts used by the library, and the relationship between them.  As expected, these concepts are reflected in the corresponding types. <br><br>
<h5> <code>State</code> </h5>  <code>State</code> is the owner of the Lua state.  This is a standalone type, practically unrelated to the rest of the library.  In addition to controlling the creation and destruction of the state, it provides only the means to execute files, strings, and Lua-compatible functions.  Errors that occur during their work are converted to exceptions. <br><br><h5> <code>LFunction</code> </h5>  Everything else in the library happens inside <code>LFunction</code> , functions of a special format, compatible with Lua API ++.  This is an analogue of Lua-compatible functions, which in turn was given the name <code>CFunction</code> .  The special format of the function was needed mainly in order to let in our next character: <br><br><h5> <code>Context</code> </h5>  <code>Context</code> is the context of the function, as well as the access center to all Lua features.  With it, you can access global variables, function arguments, the <abbr title="special storage in Lua">registry,</abbr> and <abbr title="values ‚Äã‚Äãstored in the closure">upvalues</abbr> .  You can manage the garbage collector, signal errors, pass multiple return values, and create closures.  Simply put, everything that is not directly related to operations on values ‚Äã‚Äãthat are the prerogative of our closing is done through <code>Context</code> . <br><br><h5>  Value </h5>  Unlike previous concepts, which uniquely corresponded to the same class, the ‚Äúvalue‚Äù in the Lua API ++ is somewhat vague (although the <code>Value</code> class, of course, exists).  First of all, it is connected with the policy of ‚Äúopen borders‚Äù, which allows free migration of native values ‚Äã‚Äãin Lua and vice versa.  Wherever Lua values ‚Äã‚Äãare expected, you can substitute the native values ‚Äã‚Äãof the supported types and they will automatically ‚Äúmove‚Äù to the Lua stack.  Operators of implicit type conversion will help to move the values ‚Äã‚Äãin the opposite direction, and in case of incompatibility of the real and expected type, they will notify us with an exception. <br>  In addition, the values ‚Äã‚Äãin Lua, depending on their origin, can be represented by different types that support a common interface.  This interface implements all valid operations on values: explicit and implicit conversion to native types, function calls, indexing, arithmetic operations, comparison, type checking, writing and reading of metatables. <br><br><h6> <code>Valref</code> </h6>  This is a reference to the value placed on the stack, or more precisely, not so much the value as the specific slot on the Lua stack.  <code>Valref</code> does not <code>Valref</code> with placing or deleting values ‚Äã‚Äãon the stack, but focuses solely on value operations.  In the Lua API ++ <code>Valref</code> serves as a model that follows an interface of other types representing values. <br><br><h6>  Temporal </h6>  With temporary values ‚Äã‚Äãthat are the result of operations, somewhat more complicated.  These are the values ‚Äã‚Äãthat <i>will be placed</i> (or maybe not) on the stack as a result of the operation, used <i>once</i> , and then deleted.  In addition, the arguments of the operation themselves may be the results of other operations, and even without guarantees of success.  Yes, and the use is different: when indexing as a result of reading, a new value is created on the stack instead of a key, and as a result of writing, the key and the recorded value are removed from the stack.  And what about the need to strictly observe the order of placement of arguments of operations?  And what to do with unused objects? <br>  Many probably already guessed what I'm getting at.  Temporary values ‚Äã‚Äãare represented by proxy types.  Invisible to the user, they are constructed using templates and reproduce the <code>Valref</code> interface.  Using them is easy, simple and convenient, but make a mistake, and the compiler will ‚Äúdelight‚Äù you with a voluminous work full of angle brackets. <br><br><h6>  Anchors </h6>  Anchors are so named because they allow one or several values ‚Äã‚Äãto be ‚Äústicked‚Äù to the stack.  <code>Value</code> is a universal ‚Äúanchor‚Äù for one value, <code>Table</code> specialized for tables, and <code>Valset</code> stores several values. <br><br><hr><br>  Now that the main characters are presented to us, we can proceed to a more detailed analysis of what we can do with them. <br><br><h4> <code>State</code> </h4>  <code>State</code> has a default constructor that performs all the actions necessary to initialize the context.  An alternative constructor allows you to use a <a href="http://www.lua.org/manual/5.2/manual.html">custom memory management function</a> .  You can query the ‚Äúraw‚Äù pointer to the state object used in the Lua API by <code>getRawState</code> function. <br>  Included are the <code>runFile</code> , <code>runString</code> and <code>call</code> functions that allow you to make the simplest interpreter: <br><br><div class="spoiler">  <b class="spoiler_title">The simplest interpreter</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;luapp/lua.hpp&gt; using namespace std; using namespace lua; void interpretLine(State&amp; state, const string&amp; line) { try { state.runString(line); //    } catch(std::exception&amp; e) { //          cerr &lt;&lt; e.what() &lt;&lt; endl; } } void interpretStream(State&amp; state, istream&amp; in) { string currentLine; while(!in.eof()) { //        getline(in, currentLine); interpretLine(state, currentLine); } } int main() { State state; interpretStream(state, cin); }</span></span></span></span></code> </pre> </div></div><br><br><hr><br><h4>  Error processing </h4><br>  The approach used by the library is to keep Lua from getting underfoot, therefore, those errors that are related to the work of the library itself are diagnosed, such as attempts to create a <code>Table</code> not from a table, or those that need to be (possibly) intercepted in user code , like type conversion errors.  The library does not attempt to diagnose in advance those errors that may appear when calling the Lua API.  Therefore, an attempt, for example, to use a function call on a value that is actually a number, will not cause an exception.  It will be detected inside the <code>lua_call</code> call and will cause a Lua-style error (abort execution and return to the closest point of the secure call). <br><br><hr><br><h4> <code>LFunction</code> </h4> <br>  In general, the library supports a ‚Äútransparent‚Äù wrapper for functions that operate on supported types (and even member functions).  Simply mention the name of the function where the Lua value is expected.  But if we want to get access to all Lua conveniences provided by the Lua API ++, we need to write L-functions in accordance with the following prototype: <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Retval </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context&amp; c)</span></span></span></span>;</code> </pre> <br>  Everything is simple here: our function gets the <code>Context</code> , and <code>Retval</code> is a special type that helps to conveniently return an arbitrary number of values ‚Äã‚Äãthrough the function <code>Context::ret</code> . <br><br>  The <code>mkcf</code> template allows <code>mkcf</code> to make from <code>LFunction</code> what Lua will make friends with: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*myCfunc)(lua_State*) = mkcf&lt;myFunc&gt;;</code> </pre> <br>  Thus, we can explicitly create wrappers for our function.  The ‚Äútransparent‚Äù wrapper will also work, but the overhead will be slightly higher.  On the other hand, <code>mkcf</code> will create a separate wrapper function in each case. <br>  One way or another, but in any case, the ‚Äúwrapper‚Äù will create a <code>Context</code> object, pass it to our function, and upon completion of the work, return the values ‚Äã‚Äãreturned via <code>Retval</code> to Lua.  All exceptions exceeding the limits of the wrapped function will be intercepted and converted to a Lua error. <br><div class="spoiler">  <b class="spoiler_title">A function that returns itself?</b>  <b class="spoiler_title">Give two!</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Retval </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retSelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context&amp; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.ret(retSelf, mkcf&lt;retSelf&gt;); <span class="hljs-comment"><span class="hljs-comment">//    ,  - }</span></span></code> </pre> </div></div><br><br><hr><br><h4> <code>Context</code> </h4> <br>  The function context is the central access point for Lua.  Everything that is not directly related to working with values ‚Äã‚Äãis performed via <code>Context</code> .  I will not reject hints of an obvious resemblance to the <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582">god object</a> , but in this case, this decision is dictated by the architecture of the Lua API.  Through <code>Context</code> you can manage the garbage collector, you can find out the version number and the number of values ‚Äã‚Äãplaced on the stack.  It is implicitly converted to <code>lua_State*</code> in case you need to conjure the Lua API directly.  On the same case, a magic word (more precisely, a static constant of the signal type) is provided <code>initializeExplicitly</code> , which allows you to create a <code>Context</code> explicitly, outside of the <code>LFunction</code> . <br><br><h5>  Return Values </h5>  No matter how pleasant it is to simply indicate in the <b>return statement</b> the values ‚Äã‚Äãreturned from the function, this is impossible.  It was necessary to make a choice between two closest alternatives: a cunning "starter" with operator overloading with a comma or a function call.  Defeated <s>friendship</s> feature.  Therefore, <code>LFunction</code> requires you to return <code>Retval</code> , which can only be created by <code>Retval</code> the <code>Context</code> method with the modest name <code>ret</code> .  This is a special function: after its call, work with the stack stops, so as not to throw off our values ‚Äã‚Äãfrom it, therefore, it should be used only directly in the <b>return statement</b> .  In a <code>ret</code> call, you can list as many return values ‚Äã‚Äãas you need. <br><div class="spoiler">  <b class="spoiler_title">Comparison</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx.ret(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, three);</code> </pre> <br>  Equivalent code: <br><pre> <code class="cpp hljs">lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"two"</span></span>); lua_pushvalue(ctx, three); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br></div></div><br><br><h5>  Error reporting </h5>  Claiming that the only way to create a <code>Retval</code> is to access the <code>ret</code> function, I did not sin against the truth, but there is one nuance ... From a formal point of view, there is also an <code>error</code> function, which also returns this type.  Only in fact, <code>Retval</code> does not reach the creation of the <code>Retval</code> , because no return occurs from this function.  The maximum you can count on is to pass your message to the Lua error handling mechanism.  The Lua API documentation recommends using the <code>lua_error</code> call in the <b>return statement</b> to indicate the fact that the execution of the function is interrupted during the call.  The same approach is applied in the Lua API ++, that is why the <code>error</code> declared as returning <code>Retval</code> . <br>  Lua-value with an error message is taken as an argument, and the concatenation here will be quite appropriate, especially since the originator can be the <code>where</code> function, which creates a string describing the current function.  The same value is used if the message is not specified at all. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(verbose) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx.error(ctx.where() &amp; <span class="hljs-string"><span class="hljs-string">" intentional error "</span></span> &amp; <span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx.error(); <span class="hljs-comment"><span class="hljs-comment">//   ,  return ctx.error(ctx.where());</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Equivalent code</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(verbose) { luaL_where(ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>); lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">" intentional error "</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">42</span></span>); lua_concat(ctx, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lua_error(ctx); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { luaL_where(ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lua_error(ctx); }</code> </pre><br></div></div><br><h5>  Access to the environment </h5>  Our <code>Context</code> is obviously the primary source of the values.  In fact, where else would they come from? <br>  We are given access to use objects that are designed as open members of the <code>Context</code> class, allowing us to reach various interesting places of the environment.  All of them allow both reading and writing values. <br><br>  First of all it is <code>args</code> , function arguments.  Unlike other objects of access, for each of which a special type inaccessible to the user was created, here the usual constant <code>Valset</code> .  Its constancy means only that we cannot change its size, but to rewrite the values ‚Äã‚Äãof the arguments for health.  Since Valset was created as an STL-compatible container, the numbering of elements in it starts from 0. In other cases, the library follows the rules of Lua and implies that indexing starts from 1. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ctx.args.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; ctx.args[<span class="hljs-number"><span class="hljs-number">0</span></span>].is&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()) {...};</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Equivalent code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nArgs &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; lua_isstring(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>) ) {...};</code> </pre></div></div><br>  In second place is access to global variables.  The <code>global</code> object is indexed by strings. <br><pre> <code class="cpp hljs">ctx.global[<span class="hljs-string"><span class="hljs-string">"answer"</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      ,  </span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Equivalent code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">42</span></span>); lua_setglobal(ctx, <span class="hljs-string"><span class="hljs-string">"answer"</span></span>);</code> </pre></div></div><br>  If our LFunction concurrently is a closure, then we can access the values ‚Äã‚Äãstored in it through <code>upvalues</code> with an integer index (starting with 1, everything is correct).  There is no way to find out the number of stored values: it is assumed that this is already known. <br><br>  The registry Lua, accessible through the <code>registry</code> , is used in two ways.  For string keys, metatables for user data are stored there.  Integer keys are used when using the registry as a repository of values.  The key is created by calling <code>registry.store</code> and is subsequently used to read and write to the <code>registry</code> , erasing the value and releasing the key occurs when writing <code>nil</code> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> k = ctx.registry.store(ctx.upvalues[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// decltype(k) == int ctx.registry [k] = nil; //  k       store</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Equivalent code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">lua_pushvalue(ctx, lua_upvalueindex(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> k = luaL_ref(ctx, LUA_REGISTRYINDEX); luaL_unref(ctx, LUA_REGISTRYINDEX, k);</code> </pre></div></div><br><h5>  Functions </h5>  I just mentioned that Lua allows you to create closures.  In the <code>Context</code> object, the <code>closure</code> function is used for this, which receives the <code>CFunction</code> and the values ‚Äã‚Äãthat will be stored in the closure.  The result is a temporary object, that is, a full Lua value. <br>  Instead of <code>CFunction</code> we can specify <code>LFunction</code> at once, but this lightness has its price.  In the resulting closure, the first upvalue will be reserved (the address of the function is stored there, since the wrapper is the same for any LFunction).  The same function is used for transparent migration of <code>LFunction</code> with the same consequences.  This is different from the <code>mkcf</code> template, which does not reserve anything, but it creates a separate wrapper function for each function. <br><br>  And you can also create chunks: compiled Lua code.  The text itself is compiled using the <code>chunk</code> method, and the contents of the file using <code>load</code> .  For the cases of ‚Äúdone and forgotten‚Äù there is a <code>runString</code> and <code>runFile</code> , exactly the same as in <code>State</code> .  In terms of using a chunk, this is a common function. <br><br>  Closures can also be created from incompatible functions using the <code>wrap</code> method.  It automatically creates a wrapper that takes the arguments from the Lua stack, converts them to the values ‚Äã‚Äãaccepted by our function, makes the call and places the result on the Lua stack as the return value.  By default, this works with all supported types, including user data.  And if this is not enough (for example, we need to get something up with strings stored in a <b><code>vector</code> , then we can also specify the conversion to one side or the other using special macros.</b> <b><br></b>  <b>That <code>wrap</code> works when implicit migration functions.</b>  <b>The fraternal <code>vwrap</code> method does almost everything the same, only ignores the return value of the function being wrapped.</b> <b><br><br></b> <hr> <b><br></b> <h4>  <b>Value migration</b> </h4> <b><br></b>  <b>The Lua API ++ supports the following native types:</b> <b><br></b> <table><tbody><tr><th>  <b>Numeric</b> </th></tr><tr><td> <b><b><code>int</code></b></b> </td> </tr><tr><td> <b><b><code>unsigned int</code></b></b> </td> </tr><tr><td> <b><b><code>long long</code></b></b> </td> </tr><tr><td> <b><b><code>unsigned long long</code></b></b> </td> </tr><tr><td> <b><b><code>float</code></b></b> </td> </tr><tr><td> <b><b><code>double</code></b></b> </td> </tr><tr><th>  <b>String</b> </th></tr><tr><td> <b><b><code>const char*</code></b></b> </td> </tr><tr><td> <b><code>std::string</code></b> </td> </tr><tr><th>  <b>Functions</b> </th></tr><tr><td> <b><code>CFunction: int (*) (lua_State*)</code></b> </td> </tr><tr><td> <b><code>LFunction: Retval (*) (Context&amp;)</code></b> </td> </tr><tr><td>  <b>Arbitrary functions</b> </td></tr><tr><td>  <b>Member functions</b> </td></tr><tr><th>  <b>miscellanea</b> </th></tr><tr><td> <b><code>Nil</code></b> </td> </tr><tr><td> <b><b><code>bool</code></b></b> </td> </tr><tr><td> <b><code>LightUserData: void*</code></b> </td> </tr><tr><td>  <b>registered user types</b> </td></tr></tbody></table> <b><br></b>  <b>The values ‚Äã‚Äãof the types listed in the table can migrate to the Lua stack and back (except, of course, <code>Nil</code> and ‚Äúwrapped‚Äù functions, which remain pointers to wrappers).</b> <b><br></b>  <b>The reverse migration is performed using the implicit conversion operators built into the Value-types and using the <code>cast</code> template function. If the Lua value contains data that cannot be converted to what we are trying to, an exception will be thrown.</b>  <b>The <code>optcast</code> function instead of exceptions will return a ‚Äúspare‚Äù value.</b> <b><br></b> <pre> <b><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = val; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> b = val.cast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = val.optcast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code></b> </pre> <b><br></b> <div class="spoiler">  <b><b class="spoiler_title">Equivalent code</b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lua_isnumber(ctx, valIdx)){ lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"Conversion error"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lua_error(ctx); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = lua_tointeger(ctx, valIdx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lua_isnumber(ctx, valIdx)){ lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"Conversion error"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lua_error(ctx); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> b = lua_tointeger(ctx, valIdx); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = lua_isnumber(ctx, valIdx) ? lua_tointeger(ctx, valIdx) : <span class="hljs-number"><span class="hljs-number">42</span></span>;</code></b> </pre></div></div> <b><br><br></b>  <b>It is possible to check compatibility with the desired type using the is function, and using <code>type</code> to find out the type of the stored value directly.</b> <b><br></b> <pre> <b><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(val.is&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;()) ...; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(val.type() == ValueTypes::Number) ...;</code></b> </pre> <b><br><br></b> <hr> <b><br></b> <h4>  <b>Single value operations</b> </h4> <b><br></b> <h5>  <b>Assignment</b> </h5>  <b>If we have a Value, then in general it is possible to assign something to it, both other Value and native ones.</b>  <b>But this does not apply to some temporary values, for example, to the result of a function call or length: when they are on the left side of the <b><code>=</code></b> sign, they will give a tricky error.</b>  <b>But other temporary values, such as indexing or metatable, assignment is fully admissible.</b>  <b>According to the meaning of the action performed, it is easy to guess what can be appropriated and what cannot.</b> <b><br><br></b> <h5>  <b>Metatables</b> </h5>  <b>The <code>mt</code> method gives access to the metatable of a value that can be read and written.</b> <b><br></b> <pre> <b><code class="cpp hljs">{ Table mt = val.mt(); val.mt() = nil; }</code></b> </pre> <b><br></b> <div class="spoiler">  <b><b class="spoiler_title">Equivalent code</b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lua_getmetatable(ctx, valIdx)){ lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"The value has no metatable"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lua_error(ctx); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mtIdx = lua_gettop(ctx); lua_pushnil(ctx); lua_setmetatable(ctx, valIdx); lua_pop(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code></b> </pre></div></div> <b><br><br></b> <h5>  <b>Length</b> </h5>  <b>The operation of the <code>len</code> function differs in different versions of Lua: in compatibility mode with 5.1, it returns the native <code>size_t</code> , and in mode 5.2, a temporary value.</b> <b><br><br></b> <h5>  <b>Indexing</b> </h5>  <b>Access to the elements of the table by key is carried out by indexing, the key can be of any supported type.</b>  <b>But we must remember that when wrapping functions, new closures will be created:</b> <b><br></b> <pre> <b><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Retval </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context&amp; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Table </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c)</span></span></span></span>; t[myFunc] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  myFunc   ... assert(t[myFunc].is&lt;Nil&gt;()); //   -  ,   . t[mkcf&lt;example&gt;] = 42.42; //     CFunction,   "" assert(t[mkcf&lt;example&gt;] == 42.42); }</span></span></code></b> </pre> <b><br></b> <div class="spoiler">  <b><b class="spoiler_title">Equivalent code</b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapped_void_void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lua_State* s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lua_islightuserdata(ctx, lua_upvalueindex(<span class="hljs-number"><span class="hljs-number">1</span></span>))) { lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"Conversion error"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lua_error(ctx); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*fptr) () = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(*)()&gt;(lua_touserdata(ctx, lua_upvalueindex(<span class="hljs-number"><span class="hljs-number">1</span></span>))); fptr(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mkcf_myFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lua_State* s)</span></span></span><span class="hljs-function"> </span></span>{ myFunc(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lua_State* ctx)</span></span></span><span class="hljs-function"> </span></span>{ lua_createtable(ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = lua_gettop(ctx); lua_pushlightuserdata(ctx, <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(&amp;myFunc)); lua_pushcclosure(ctx, &amp;wrapped_void_void, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">42</span></span>); lua_settable(ctx, t); lua_pushlightuserdata(ctx, <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(&amp;myFunc)); lua_pushcclosure(ctx, &amp;wrapped_void_void, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_gettable(ctx, t); assert(lua_isnil(ctx, <span class="hljs-number"><span class="hljs-number">-1</span></span>)); lua_pushcfunction(ctx, &amp;mkcf_myFunc); lua_pushnumber(ctx, <span class="hljs-number"><span class="hljs-number">42.42</span></span>); lua_settable(ctx, t); lua_pushcfunction(ctx, &amp;mkcf_myFunc); lua_gettable(ctx, t); lua_pushnumber(ctx, <span class="hljs-number"><span class="hljs-number">42.42</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = lua_compare(ctx, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, LUA_OPEQ); lua_pop(ctx, <span class="hljs-number"><span class="hljs-number">2</span></span>); assert(result == <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code></b> </pre></div></div> <b><br><br></b> <h5>  <b>Function call</b> </h5> <b> Lua-    .   <code>call</code>   ,   ,   - .   <code>pcall</code>   . <br></b> <pre> <b><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = fn(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = fn.call(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    int z = fn.pcall(1); //     ,   </span></span></code></b> </pre> <b><br></b> <h6> <b>  </b> </h6> <b>   ,         .     ,     ?       Lua:</b> <pre> <b><code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mrv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code></b> </pre> <b><br>      . <br> -,     ,     .      . <br></b> <pre> <b><code class="cpp hljs">mrv();</code></b> </pre> <b><br></b> <div class="spoiler"> <b><b class="spoiler_title"> </b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs">lua_pushvalue(ctx, mrvIdx); lua_call(ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code></b> </pre></div></div> <b><br> -,        Lua-.        ( <code>nil</code> ,      ),      . <br></b> <pre> <b><code class="cpp hljs">Value x = mrv(); <span class="hljs-comment"><span class="hljs-comment">// x == 2</span></span></code></b> </pre> <b><br></b> <div class="spoiler"> <b><b class="spoiler_title"> </b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs">lua_pushvalue(ctx, mrvIdx); lua_call(ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = lua_gettop(ctx);</code></b> </pre></div></div> <b><br> -,  ,    (,  )    :     . <br></b> <pre> <b><code class="cpp hljs">print(<span class="hljs-number"><span class="hljs-number">1</span></span>, mrv(), <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  1 2 3 4 5</span></span></code></b> </pre> <b><br></b> <div class="spoiler"> <b><b class="spoiler_title"> </b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs">lua_pushvalue(ctx, printIdx); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldtop = lua_gettop(ctx); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_pushvalue(ctx, mrvIdx); lua_call(ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>, LUA_MULTRET); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nArgs = lua_gettop(ctx) - oldtop; lua_call(ctx, nArgs, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code></b> </pre></div></div> <b><br> -,      <code>Valset</code> ,    . <br></b> <pre> <b><code class="cpp hljs">Valset vs = mrv.pcall(); <span class="hljs-comment"><span class="hljs-comment">// vs.size() == 3, vs.success() == true</span></span></code></b> </pre> <b><br></b> <div class="spoiler"> <b><b class="spoiler_title"> </b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vsBegin = lua_gettop(ctx) + <span class="hljs-number"><span class="hljs-number">1</span></span>; lua_pushvalue(ctx, mrvIdx); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> vsSuccess = lua_pcall(ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>, LUA_MULTRET) == LUA_OK; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vsSize = lua_gettop(ctx) + <span class="hljs-number"><span class="hljs-number">1</span></span> - vsBegin;</code></b> </pre></div></div> <b><br> <code>Valset</code>   ,      (     ).         .  , <code>Valset</code>        ,    . <br></b> <pre> <b><code class="cpp hljs">print(<span class="hljs-number"><span class="hljs-number">1</span></span>, vs, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  1 2 3 4 5</span></span></code></b> </pre> <b><br></b> <div class="spoiler"> <b><b class="spoiler_title"> </b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs">lua_pushvalue(ctx, printIdx); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldTop = lua_gettop(ctx); lua_pushInteger(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_pushvalue(ctx, mrvIdx); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vsSize; ++i) lua_pushvalue(ctx, vsBegin + i); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nArgs = lua_gettop(ctx) - oldtop; lua_call(ctx, nArgs, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code></b> </pre></div></div> <b><br>    <code>Valset</code>  .   STL-        STL,    ¬´¬ª   <code>Valref</code> .  <code>Valset</code>    ,          <code>push_back</code>  <code>pop_back</code> .     <code>Valref</code>    ,        (   <code>Valset</code> ),     .     ,       . <br><br></b> <hr> <b><br></b> <h4> <b>   </b> </h4> <b><br>     ,  Value-      ,          : <br></b> <pre> <b><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s = <span class="hljs-string"><span class="hljs-string">"The answer to question "</span></span> &amp; val &amp; <span class="hljs-string"><span class="hljs-string">" is "</span></span> &amp; <span class="hljs-number"><span class="hljs-number">42</span></span>;</code></b> </pre> <b><br></b> <div class="spoiler"> <b><b class="spoiler_title"> </b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs">lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"The answer to question "</span></span>); lua_pushvalue(ctx, valIdx); lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">" is "</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">42</span></span>); lua_concat(ctx, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s = lua_tostring(ctx, <span class="hljs-number"><span class="hljs-number">-1</span></span>); lua_pop(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code></b> </pre></div></div> <b><br>  &amp;  .      , ¬´¬ª   .       ,       <code>Valset</code> . <br><br>     Lua,     . <br><br>   5.2   ,    ,    ¬´¬ª  <code>^</code>     . <br><br></b> <hr> <b><br></b> <h4> <b></b> </h4> <b><br>  ,   <code>Table</code> ,     <code>Valref</code>  .  ,  , ,          .     <code>raw</code> ,     ,   ,    <code>iterate</code>    ,  <code>for_each</code> .           ,   <code>iterate</code>   ( ,   ,      ),    -.         <code>Valref</code>   <b><code>true</code></b> ,     <b><code>false</code></b> ,  .           : <br></b> <pre> <b><code class="cpp hljs">Table t = ctx.global[<span class="hljs-string"><span class="hljs-string">"myTable"</span></span>]; t.iterate([] (Valref k, Valref v) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(k) &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(v); });</code></b> </pre> <b><br></b> <div class="spoiler"> <b><b class="spoiler_title"> </b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs">lua_getglobal(ctx, <span class="hljs-string"><span class="hljs-string">"myTable"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lua_istable(ctx, <span class="hljs-number"><span class="hljs-number">-1</span></span>)){ lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"Conversion error"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lua_error(ctx); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = lua_gettop(ctx); lua_pushnil(ctx); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> visited = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(lua_next(ctx, t)) { ++ visited; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lua_isnumber(ctx, <span class="hljs-number"><span class="hljs-number">-2</span></span>) || !lua_isnumber(ctx, <span class="hljs-number"><span class="hljs-number">-1</span></span>)){ lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"Conversion error"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lua_error(ctx); } <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; lua_tointeger(ctx, <span class="hljs-number"><span class="hljs-number">-2</span></span>) &lt;&lt; lua_tointeger(ctx, <span class="hljs-number"><span class="hljs-number">-1</span></span>); lua_pop(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code></b> </pre></div></div> <b><br>  <code>iterate</code>    . <br><br>      <code>Table</code> ‚Äî   <code>array</code>  <code>records</code> .          . <br></b> <pre> <b><code class="cpp hljs">fn(Table::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(ctx, <span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, Table::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))); <span class="hljs-comment"><span class="hljs-comment">//  ? !</span></span></code></b> </pre> <b><br></b> <div class="spoiler"> <b><b class="spoiler_title"> </b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs">lua_pushvalue(ctx, fn); lua_createtable(ctx, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"one"</span></span>); lua_settable(ctx, <span class="hljs-number"><span class="hljs-number">-3</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">2</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">42</span></span>); lua_settable(ctx, <span class="hljs-number"><span class="hljs-number">-3</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">3</span></span>); lua_createtable(ctx, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_settable(ctx, <span class="hljs-number"><span class="hljs-number">-3</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">2</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">2</span></span>); lua_settable(ctx, <span class="hljs-number"><span class="hljs-number">-3</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">3</span></span>); lua_pushinteger(ctx, <span class="hljs-number"><span class="hljs-number">3</span></span>); lua_settable(ctx, <span class="hljs-number"><span class="hljs-number">-3</span></span>); lua_settable(ctx, <span class="hljs-number"><span class="hljs-number">-3</span></span>); lua_call(ctx, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code></b> </pre></div></div> <b><br>        ,         .    ,  <code>array</code>       ,   1.      ,      <code>Valset</code> . <br><br>  <code>records</code> ,    -.          . <br></b> <pre> <b><code class="cpp hljs">x.mt() = Table::records(ctx, <span class="hljs-string"><span class="hljs-string">"__index"</span></span>, xRead, <span class="hljs-string"><span class="hljs-string">"__newindex"</span></span>, xWrite, <span class="hljs-string"><span class="hljs-string">"__gc"</span></span>, xDestroy );</code></b> </pre> <b><br></b> <div class="spoiler"> <b><b class="spoiler_title"> </b></b> <div class="spoiler_text"><pre> <b><code class="cpp hljs">lua_createtable(ctx, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"__index"</span></span>); lua_pushlightuserdata(ctx, <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(&amp;xRead)); lua_pushcclosure(ctx, &amp;wrapped_signature_1, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_settable(ctx, <span class="hljs-number"><span class="hljs-number">-3</span></span>); lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"__newindex"</span></span>); lua_pushlightuserdata(ctx, <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(&amp;xWrite)); lua_pushcclosure(ctx, &amp;wrapped_signature_2, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_settable(ctx, <span class="hljs-number"><span class="hljs-number">-3</span></span>); lua_pushstring(ctx, <span class="hljs-string"><span class="hljs-string">"__gc"</span></span>); lua_pushlightuserdata(ctx, <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(&amp;xDestroy)); lua_pushcclosure(ctx, &amp;wrapped_signature_3, <span class="hljs-number"><span class="hljs-number">1</span></span>); lua_settable(ctx, <span class="hljs-number"><span class="hljs-number">-3</span></span>); lua_setmetatable(ctx, x);</code></b> </pre></div></div> <b><br></b> <hr> <b><br></b> <h4> <b> </b> </h4> <b><br>     .      -         ,   :        ,   <code>cast</code> ,     . <br>     .     <code>LUAPP_USERDATA</code>        . ,    ,      .   ,  <code>registry</code> -,        : <br></b> <pre> <b><code class="cpp hljs">LUAPP_USERDATA(MyType, <span class="hljs-string"><span class="hljs-string">"MyType Lua ID"</span></span>) <span class="hljs-function"><span class="hljs-function">Retval </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context&amp; ctx)</span></span></span><span class="hljs-function"> </span></span>{ ctx.mt&lt;MyType&gt;() = Table::records(ctx); <span class="hljs-comment"><span class="hljs-comment">//   ,     ctx.registry["MyType Lua ID"] }</span></span></code></b> </pre> <b><br>    Lua       .       ,     , ¬´¬ª    ,    ‚Äî       <s></s> . <br><br>     Lua ,      Lua        . Lua API++  placement new       ,   ,   .      POD-.  ,     ,             . <br><br>              .   ,     -,    ,          . ,         Lua    ,  : <br></b> <pre> <b><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; using dvec = std::vector&lt;double&gt;; //      LUAPP_USERDATA(dvec, "Number array") //      dvec aCreate(size_t size) //    . { //  -       . return dvec(size); //  RVO        } void aDestroy(dvec&amp; self) //  -        . { self.~dvec(); } void aWrite(dvec&amp; self, size_t index, double val) //          __newindex { self.at(index) = val; //     at,     Lua } Retval setup(Context&amp; c) { //   c.mt&lt;dvec&gt;() = Table::records(c, //     "__index", static_cast&lt;double&amp; (dvec::*)(size_t)&gt; (&amp;dvec::at), //         at //    (const  -const),      "__newindex", aWrite, "__len", dvec::size, //   size  vector ,    "__gc", aDestroy ); c.global["createArray"] = aCreate; //      return c.ret(); }</span></span></span></span></code></b> </pre> <b><br><br></b> <hr> <b><br></b> <h4>  <b>Conclusion</b> </h4> <b><br>     ,        Lua    .     Lua API  ++,  .        Lua  Lua API (coroutine, string buffers,  ). <br><br>    ,      Lua API,         Lua.     <b><code>inline</code></b> ,      Lua API     ,      ,    Link time code generation (LTO  GCC).        header-only.            <b><code>inline</code></b>     Lua. <br><br>     ,       <b>C++11</b> ,   Lua  STL.      <a href="http://www.boost.org/">Boost Unit Test Framework</a> . <br><br>      Lua  5.2 (   5.3     ),       5.1,     LuaJIT. <br><br>  <a href="https://github.com/OldFisher/lua-api-pp">Lua API++</a>   MIT ‚Äî   ,   Lua,       .       HTML,       . <br><br> ,      -  .</b> </div><p>Source: <a href="https://habr.com/ru/post/201860/">https://habr.com/ru/post/201860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../201838/index.html">Updates and plans</a></li>
<li><a href="../201840/index.html">CRON in the cloud: the complete guide to the new Windows Azure Scheduler task scheduler service</a></li>
<li><a href="../201844/index.html">Microsoft released a set of updates, November 2013</a></li>
<li><a href="../201854/index.html">Astronauts assistant Robonaut finally gets legs</a></li>
<li><a href="../201856/index.html">Problems removing regular clutter on printed forms</a></li>
<li><a href="../201862/index.html">Comparison of the performance of the entire line of Nexus smartphones in one video</a></li>
<li><a href="../201864/index.html">How to realize a childhood dream and program something for Dendy</a></li>
<li><a href="../201868/index.html">Two paradoxes in C programs</a></li>
<li><a href="../201870/index.html">Solving the problem of sound in one ear for some videos on Youtube</a></li>
<li><a href="../201872/index.html">What is the best e-mail address to do?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>