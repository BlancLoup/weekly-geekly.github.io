<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Option of conditional routing in AngularJS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am new to AngularJS, just recently decided to use it in my hobby project. Pretty quickly, I was faced with the task of setting up routing for certai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Option of conditional routing in AngularJS</h1><div class="post__text post__text-html js-mediator-article">  I am new to AngularJS, just recently decided to use it in my hobby project.  Pretty quickly, I was faced with the task of setting up routing for certain conditions, the simplest and most obvious of these conditions - whether the user is authorized or not.  The application contains pages that are open to any user, and pages that can only be accessed by logging in.  If there is no authorization, you need to try to get it transparently for the user, if that fails - refer to the login page. <br><br>  As far as I understand, this is a fairly common task, however I have not found a simple ready-made way to do it out of the box.  Having spent a fair amount of time on googling, reading documentation and experiments, I finally found a rather elegant solution for my case.  I hasten to share my bike, I hope this will help save time to the same novice AngularJS users.  Perhaps there is a guru who will indicate the very standard solution that I somehow did not find.  For example, I did not understand <a href="https://github.com/angular-ui/ui-router">ui-router</a> yet. <br><a name="habracut"></a><br><h2>  Task </h2><br>  It is worth a little more to write about my task.  There is a one-page web application (Single Page Application).  For simplicity, we assume that there is one publicly accessible "main" page along the path "/", that is, at the root of the site.  On it, the user can register or login.  If the login is successful, the application receives an authorization token and a user profile.  The profile is a spreading data structure and, to reduce the load on the server, I want to load it once at login, and not in parts on each page.  The authorization token can be stored for a long time in the browser‚Äôs local storage, but the profile data is reloaded each time the page is refreshed.  Having received the token once, I can freely browse all closed pages, reload any of them, add to bookmarks, etc.  The profile is being loaded transparently for me.  But if the token becomes rotten or I give a link to a closed page of the site to a friend, the site should send me (or a friend) to the main page. <br><br><h2>  Search solutions </h2><br>  The only useful thing that Google issued to the request of ‚ÄúAngularjs conditional routing‚Äù is this <a href="http://stackoverflow.com/questions/11541695/angular-js-redirecting-to-a-certain-route-based-on-condition">question on stackoverflow</a> .  Two solutions were proposed there: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first is to send status 401 from the server and intercept it via the $ http service ‚Äî a request to the server from each protected page is assumed.  Maybe someone will do it, but not for me - I load the data once and I would not like to finish the server for the sake of routing on the client. <br><br>  The second is to intercept the $ routeChangeStart message, check where we are going, whether there is authorization and, if not, redirect it.  As an option, listen to path changes through $ scope. $ Watch (function () {return $ location.path ();}. The disadvantages of this solution are: <br><br>  1. In the case of $ routeChangeStart, the next object does not provide a routing path; it is not very convenient to understand where we are going;  the message will be thrown on redirects from non-existent pages, as a result, the expressions in the routing conditions will not be very beautiful, tied to the names of templates, the names of controllers and other strange things. <br>  2. If you need to load data, as in my case, there is no way to delay the routing until the end of loading.  At the same time, the routing may depend on the data itself in the user profile - for example, it has a new super-offer and you have to drop everything and go to the page of this offer immediately. <br><br>  I had a thought with the missing data to redirect to a separate ‚Äúdownload page‚Äù, there to load data and redirect by results, but firstly the routing logic is spread in two places - in one we look the way, in the other data;  secondly, the user in history will have this intermediate page.  The history can be overwritten using $ location.replace (), but if the download is delayed for some reason and the user has time to press Back, the wrong page will be erased, but also among the other page, you need to somehow handle this case that does not add simplicity to the solution.  Thirdly, we need to memorize somewhere where we were going in order to correctly correct, taking into account the situation from the ‚Äúsecond‚Äù.  This decision did not inspire me and I continued searching. <br><br><h1>  Decision </h1><br>  AngularJS provides a service with the interesting name $ q.  The <a href="">documentation</a> can read why q and the specification for defered / promise is a fairly simple and interesting concept.  In short, we ask the service to make a special object. <br><br> <code>var defered = $q.defer(); <br></code> <br><br>  From this object, we obtain a promise object and give it to the client of our code. <br><br> <code>return defered.promise; <br></code> <br><br>  The client hangs on promise callbacks of success and failure of the operation <br><br> <code>promise.then(function (result) {...}, function (reason) {...}); <br></code> <br><br>  Now when we we do at our facility <br><br> <code>defered.resolve(result); <br></code> <br><br>  or <br><br> <code>defered.reject(); <br></code> <br><br>  The client will call the appropriate callback.  How is this better than ordinary callbacks?  promises can be chained (for details in the documentation) and, importantly for my task, many AngularJS services can work with them, including in $ routerProvider in the route configuration you can specify the field field and pass the function returning promise .  Moreover, if this function returns an object that is not a promise, it will be interpreted as a promise that has already been resolved.  The route will wait until the promise is raised, and if a reject happens, it will be canceled altogether.  Then everything is simple - we write a function that loads the data, if necessary, does all the checks and redirects.  If you need to load the data, a promise is returned, if you need to make a redirect, the promise will be rejected in front of it so that the old route will not wait in vain. <br><br>  Solution code: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = angular.module(<span class="hljs-string"><span class="hljs-string">'app'</span></span>, []) .config([<span class="hljs-string"><span class="hljs-string">'$routeProvider'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$routeProvider</span></span></span><span class="hljs-function">) </span></span>{ $routeProvider .when(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">templateUrl</span></span>: <span class="hljs-string"><span class="hljs-string">"login.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: LoginController }) .when(<span class="hljs-string"><span class="hljs-string">'/private'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">templateUrl</span></span>: <span class="hljs-string"><span class="hljs-string">"private.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: PrivateController, <span class="hljs-attr"><span class="hljs-attr">resolve</span></span>: { <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: checkRouting } }) .when(<span class="hljs-string"><span class="hljs-string">'/private/anotherpage'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">templateUrl</span></span>:<span class="hljs-string"><span class="hljs-string">"another-private.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: AnotherPriveController, <span class="hljs-attr"><span class="hljs-attr">resolve</span></span>: { <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: checkRouting } }) .otherwise({ <span class="hljs-attr"><span class="hljs-attr">redirectTo</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span> }); }]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> checkRouting= <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$q, $rootScope, $location</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($rootScope.userProfile) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defered = $q.defer(); $http.post(<span class="hljs-string"><span class="hljs-string">"/loadUserProfile"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">userToken</span></span>: <span class="hljs-string"><span class="hljs-string">"blah"</span></span> }) .success(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ $rootScope.userProfile = response.userProfile; defered.resolve(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }) .error(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ defered.reject(); $location.path(<span class="hljs-string"><span class="hljs-string">"/"</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defered.promise; } };</code> </pre><br><br>  As a result, it turned out quite simply and transparently, it is even strange why I didn‚Äôt find one right away on the network (now, I hope, it will be easier to find).  Among the shortcomings it can be noted that resolve should be specified in each route, but on the other hand, this gives a clear configuration and flexibility - you can write a couple more of the same check * functions (if the logic for different pages is completely different) and use where necessary. <br><br>  <b>UPDATE:</b> Comments encouraged me to write code with the transfer of promises along the chain from $ http.post (), which, like other methods of the $ http service, returns a promise.  With this, natural, use of promises we get a cool clear separation of the process in stages and functions with a clear contract. <br><br>  The mechanism of the chain of promises is this: the then method of the promise returns another ‚Äúderivative‚Äù promise, which is resolved with the value returned by one of the handlers specified in the then - resolv or reject - or ordered if one of the handlers throws an exception.  Moreover, if the return value is the promise itself, then its result will determine the result of the derived promise.  So, to book a derivative promise, it suffices to return $ q.reject (). <br><br>  As a result, the solution looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,   resolve . var checkRouting = function ($q, $rootScope, $http, $location, localStorageService) { //     function redirect(path) { if ($location.path() != path) { $location.path(path); //  . return $q.reject(); //   . } else { return true; //   . } } return getUserDataPromise($q, $rootScope, $http, localStorageService) .then(function (userData) { //       . if (userData.sales.lenght &gt; 0) { return redirect("/sales"); //   ,   ! } else { return true; //  ,  . } }, function (reason) { //      . console.error(reason); //     ; ) return redirect("/"); }); }; //  ,      userData,  . var getUserDataPromise = function ($q, $rootScope, $http, localStorageService) { if ($rootScope.userData) { return $q.when($rootScope.userData); //    ( ) . } else { var userToken = localStorageService.get("userToken"); if (!userToken) { return $q.reject("No user token."); //     . } else { //  ,        , //  ,     . return $http.post("/loadUserData", { userToken: userToken }) .then(function (result) { if (result.data.userData) { $rootScope.userData = result.data.userData; return result.data.userData; } else { return $q.reject("Got response from server but without user data."); } }, function (reason) { return $q.reject("Error requesting server: " + reason); }); } } };</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/200662/">https://habr.com/ru/post/200662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../200646/index.html">Build Android applications on Travis CI</a></li>
<li><a href="../200652/index.html">The digest of interesting materials from the world of web development and IT for the last week No. 81 (October 27 - November 2, 2013)</a></li>
<li><a href="../200654/index.html">We are refining equipment Turnigy 9x</a></li>
<li><a href="../200658/index.html">Is your disassembler working correctly?</a></li>
<li><a href="../200660/index.html">Service beautiful animated cards LikeShareIt.com</a></li>
<li><a href="../200664/index.html">Why typeof null === 'object'?</a></li>
<li><a href="../200666/index.html">DIY dimmer for modern skilled hands</a></li>
<li><a href="../200668/index.html">Power Management through Mikrotik + Windows Phone</a></li>
<li><a href="../200670/index.html">Optimize long list performance in AngularJS</a></li>
<li><a href="../200674/index.html">Transferring files to Java using √òMQ and JZMQ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>