<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RS232 3-in-1 device for a home Linux server: Part 2 (Server)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Part 1 (Hardware) 
- Part 2 (Server) Driver Demon Management utility 
- Driver 
- Demon 
- Management utility 


 To eliminate some of the shortcomi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RS232 3-in-1 device for a home Linux server: Part 2 (Server)</h1><div class="post__text post__text-html js-mediator-article"><ul><li>  <a href="https://habr.com/post/394261/">Part 1 (Hardware)</a> </li><li>  <strong>Part 2 (Server)</strong> <br><ul><li>  <a href="https://habr.com/post/300968/">Driver</a> </li><li>  <a href="https://habr.com/post/300968/">Demon</a> </li><li>  <a href="https://habr.com/post/300968/">Management utility</a> </li></ul></li></ul><br><p>  To eliminate some of the shortcomings of the server, assembled from household components, recently developed a device that I want to share.  Its detailed description, with the scheme and source codes, is in the <a href="https://habr.com/post/394261/">first part</a> . </p><br><p>  In this part of the article, we will look at how to interact with the serial port from the kernel space (kernel space) and how to organize work with several subsystems of the device via RS232 in Linux. </p><br><p>  The device includes the following subsystems: </p><br><ul><li> Watchdog hardware <code>watchdog</code> ; </li><li>  True random number generator; </li><li>  Radio module nRF24L01 + for data collection from autonomous sensors. </li></ul><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6b0/170/387/6b017038743ee2a7d30af616d240e3e6.png" alt="WRN device"></p><a name="habracut"></a><br><p>  The serial port, relatively speaking, is two endpoints (endpoint).  In this case, they need at least four: </p><br><ul><li>  to send commands; </li><li>  reading responses; </li><li>  receiving a stream of random numbers; </li><li>  receiving data from sensors. </li></ul><br><p>  The task can be solved if commands are sent directly to the device, and the traffic from it is disassembled using the dispatcher.  The idea, after some thought, took the following form: </p><br><p>  <em>(click to enlarge)</em> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a9b/3eb/425/a9b3eb4255cadce63938da9fbf4096f4.png" alt="Software package"></a> </p><br><p>  The <code>wrnd</code> background process (daemon) acts as a dispatcher here, its purpose is to filter traffic into three FIFO channels: </p><br><ul><li>  <strong>rng.fifo</strong> - a stream of random numbers; </li><li>  <strong>nrf.fifo</strong> - data flow from sensors; </li><li>  <strong>cmd.fifo</strong> - data returned by commands. </li></ul><br><p>  Also shown on the diagram: </p><br><ul><li>  <strong>wrn_wdt</strong> - character device driver <code>/dev/watchdog</code> , which controls the watchdog timer; </li><li>  <strong>wrnctrl</strong> - utility for firmware, monitoring and device management; </li><li>  <strong>orange</strong> indicates the services with which the project interacts. </li></ul><br><p>  Commands are transmitted to the device in text form, in the format <code>[C|W|R|N][0-99]:[1]</code> , where the first letter is the subsystem identifier, then the command number and an argument can be followed by a colon. </p><br><p>  Basically the software is written in pure C, contains scripts in Bash and Makefile.  The installer is designed for Gentoo, but if you prefer, you can easily adapt it to other distributions. </p><br><p>  The source code for the project is available on the GitHub <a href="https://github.com/alexcustos/wrn-project">alexcustos / wrn-project</a> in the <strong>wrnd</strong> directory.  The code contains data processing from the sensor, which can be found at the link: <a href="https://habr.com/post/388079/">ATtiny85: prototype of a wireless sensor</a> . </p><br><p>  Further more about all the components. </p><br><a name="wrn_driver"></a><br><h2 id="drayver">  Driver </h2><br><p>  After the publication of the article, the wdt.fifo channel was added to the project, which is served by the <code>wrnd</code> daemon and duplicates the device file <code>/dev/watchdog</code> .  Both options are suitable for working with a <code>watchdog</code> daemon and are generally similar.  Therefore, the information given below is still relevant, and it will be useful if you want to get acquainted with how the watchdog timer driver is arranged. </p><br><p>  From a programming point of view, Linux drivers are fairly simple.  Their development is simplified by the fact that many well-documented examples are available in the kernel source tree.  Some difficulties can arise only when you try to compile and debug your plans.  The fact is that familiar functions from the glibc library are not available in the kernel space, you can only work with the functions represented in the kernel.  In addition, interactive debugging of the code is very difficult. </p><br><p>  But in this case, it is not scary, because the task is extremely simple, implement the character device <code>/dev/watchdog</code> ( <em>code in full:</em> <a href="">wrn_wdt.c</a> ).  The device is serviced by driver number 10 (miscdevice), so you first need to determine the appropriate data structure: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">miscdevice</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wrn_wdt_miscdev</span></span></span><span class="hljs-class"> = </span></span>{ .minor = <span class="hljs-type"><span class="hljs-type">WATCHDOG_MINOR</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   watchdog .name = "watchdog", //    /dev .fops = &amp;wrn_wdt_fops, //      };</span></span></code> </pre> <br><p>  Then set the handlers: </p><br><pre> <code class="hljs ruby">static const struct file_operations wrn_wdt_fops = { .owner = THIS_MODULE, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     .llseek = no_llseek, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      .write = wrn_wdt_write, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      .unlocked_ioctl = wrn_wdt_ioctl, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ioctl .open = wrn_wdt_open, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     .release = wrn_wdt_release, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     };</code> </pre> <br><p>  Here, unlocked_ioctl, this is the usual handler for accessing the device descriptor via ioctl (), only for some time now, the call has become non-blocking, therefore additional measures need to be taken for synchronization, if necessary. </p><br><p>  Now we need to define handlers for the operations of loading and unloading the module: </p><br><pre> <code class="hljs lisp">module_init(<span class="hljs-name"><span class="hljs-name">wrn_wdt_init</span></span>)<span class="hljs-comment"><span class="hljs-comment">; //       module_exit(wrn_wdt_exit); //    </span></span></code> </pre> <br><p>  If necessary, you can add parameters to the module through module_param (), MODULE_PARM_DESC () and specify for the order: </p><br><pre> <code class="hljs ruby">MODULE_DESCRIPTION(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  MODULE_AUTHOR(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  MODULE_LICENSE(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> </code> </pre> <br><p>  You can view this information with the command: </p><br><pre> <code class="bash hljs">modinfo [path]/[module].ko</code> </pre> <br><p>  At this step, the driver is almost ready, it remains to make it useful.  This requires the ability to, at a minimum, send data to the serial port.  You cannot do this directly, because, in the kernel space, there is no API for this.  The option associated with the removal of the standard driver and the development of its own can be immediately excluded as ideologically incorrect.  Therefore, there are two options: </p><br><ol><li>  from the kernel space to access the file system in user space; </li><li>  register in LDISC (line discipline) core space to intercept and control the serial port traffic. </li></ol><br><p>  I think it is already clear that I chose the first option, and I have no excuse for that.  But seriously, the line discipline would be worth using to place the traffic controller in the kernel space.  But, as already noted, programming and debugging in this space is not trivial, and, if possible, should be avoided, as well as I / O operations that can be done in user space. </p><br><p>  But the main reason for the inappropriate development of such a driver is that it is impossible to achieve autonomy, as if it were a USB driver.  Line discipline is just an interlayer, which requires code in user space to configure the port parameters and install the required line discipline. </p><br><p>  Anyway, the choice is made and the main driver code is the following: </p><br><pre> <code class="hljs ruby">static int __init wrn_wdt_init(void) { int ret; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,     wrnd  filp_port = filp_open(serial_port, O_RDWR <span class="hljs-params"><span class="hljs-params">| O_NOCTTY |</span></span> O_NDELAY, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_ERR(filp_port)) ... /<span class="hljs-regexp"><span class="hljs-regexp">/   else { ret = misc_register(&amp;wrn_wdt_miscdev); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  miscdevice if (ret == 0) wdt_timeout(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     } return ret; } static void wdt_enable(void) { ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   spin_lock(&amp;wrn_wdt_lock); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ( ) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ watchdog   keep-alive      interval, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  WRN   ,    getnstimeofday(&amp;t); time_delta = (t.tv_sec - wdt_keep_alive_sent.tv_sec) * 1000; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ sec to ms time_delta += (t.tv_nsec - wdt_keep_alive_sent.tv_nsec) /</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ns to ms <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time_delta &gt;= WDT_MIN_KEEP_ALIVE_INTERVAL) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     cmd_keep_alive    fs = get_fs(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    FS set_fs(get_ds()); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    KERNEL_DS (    ) ret = vfs_write(filp_port, cmd_keep_alive, strlen(cmd_keep_alive), &amp;pos); set_fs(fs); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  FS <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret != strlen(cmd_keep_alive)) ... /<span class="hljs-regexp"><span class="hljs-regexp">/   getnstimeofday(&amp;wdt_keep_alive_sent); } spin_unlock(&amp;wrn_wdt_lock); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ( ) } static long wrn_wdt_ioctl(struct file *file, unsigned int cmd, unsigned long arg) { ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   switch (cmd) { case WDIOC_KEEPALIVE: wdt_enable(); ret = 0; break; case WDIOC_SETTIMEOUT: ret = get_user(t, (int *)arg); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    timeout = t; wdt_timeout(); wdt_enable(); /</span></span>*   *<span class="hljs-regexp"><span class="hljs-regexp">/ case WDIOC_GETTIMEOUT: ret = put_user(timeout, (int *)arg); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      break; ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   } return ret; }</span></span></code> </pre><br><p>  Beyond the framework of the code snippet above, support for MAGICCLOSE remains.  It is necessary because the driver disables the watchdog when the device file is closed.  Therefore, it is important to recognize the non-staffing completion of the <code>watchdog</code> daemon, at which the file will be closed by the system.  In this case, the MAGICCLOSE mechanism helps ensure a reboot.  Its support provides for the deactivation of the watchdog timer only when the device file is closed immediately after receiving a special character, usually V. </p><br><p>  The driver is built using the <code>make driver</code> using the <a href="https://github.com/alexcustos/wrn-project/blob/master/wrnd/Makefile">Makefile</a> , its part is responsible for this: </p><br><pre> <code class="hljs mel">TARGET_WDT = wrn_wdt ifneq ($(KERNELRELEASE),) #  ,        obj-m := $(TARGET_WDT).o <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #      make KERNEL := $(shell uname -r) #        driver: $(MAKE) -C /lib/modules/$(KERNEL)/build M=$(PWD) #         install: driver $(MAKE) -C /lib/modules/$(KERNEL)/build M=$(PWD) modules_install endif</code> </pre> <br><p>  In order for the module to be loaded at system startup after installation, you need to add a line to the <code>/etc/conf.d/modules</code> file: </p><br><pre> <code class="hljs objectivec">modules=<span class="hljs-string"><span class="hljs-string">"wrn_wdt"</span></span></code> </pre> <br><p>  The manual module can be loaded with the commands: <code>modprobe wrn_wdt</code> or <code>insmod ./wrn_wdt.ko</code> ;  unload: <code>modprobe -r wrn_wdt</code> or <code>rmmod wrn_wdt</code> ;  make sure the module is loaded: <code>lsmod | grep wrn_wdt</code>  <code>lsmod | grep wrn_wdt</code> . </p><br><p>  When using the wdt.fifo channel as a device file for a <code>watchdog</code> daemon, it is important to make sure that the dependencies are correctly set and the <code>wrnd</code> daemon starts earlier and the <code>watchdog</code> stops later.  Otherwise, respectively, the FIFO channel may not yet be created or the timer will not be deactivated, which may lead to an unwanted reset. </p><br><a name="wrn_daemon"></a><br><h2 id="demon">  Demon </h2><br><p>  The purpose of the <code>wrnd</code> daemon is to sort the stream of binary data coming from the serial port and convert them to a convenient format for services. </p><br><p>  The default serial port settings are optimized for text terminals, so you need to align them, and the mode of operation with the device ( <em>full code:</em> <a href="">serialport.c</a> ): </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/    termios       /</span></span>  struct termios2 ttyopts; memset(&amp;ttyopts, <span class="hljs-number"><span class="hljs-number">0</span></span>, sizeof ttyopts); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ioctl(fd, TCGETS2, &amp;ttyopts) != <span class="hljs-number"><span class="hljs-number">0</span></span>) ... /<span class="hljs-regexp"><span class="hljs-regexp">/   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/          ttyopts.c_cflag &amp;= ~CBAUD; ttyopts.c_cflag |= BOTHER; ttyopts.c_ispeed = speed; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ unsigned int,     B9600 ttyopts.c_ospeed = speed; ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         ttyopts.c_cc[VMIN] = vmin; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ( )        ttyopts.c_cc[VTIME] = vtime; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    if (ioctl(fd, TCSETS2, &amp;ttyopts) != 0) ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  </span></span></code> </pre> <br><p>  Here it is important to choose the optimal values ‚Äã‚Äãof VMIN and VTIME.  If they are zero, the port will be polled without delay, consuming system resources unnecessarily.  A non-zero VMIN value, if there is no data, can block the stream indefinitely. </p><br><p>  In this case, the data is read by one byte in the main program stream.  Blocking it for a long time is not good, so VMIN is always zero, and VTIME can be changed through parameters, by default it is 5 (maximum delay is 0.5 seconds). </p><br><p>  Received bytes go to a fixed-size buffer.  Upon receipt of the expected number of bytes, the buffer is converted to the corresponding data structure (struct).  This method is good, but has features that must be kept in mind.  The compiler optimizes data structures by adding spaces between fields, aligning them at will, usually to the word boundary.  Since the data is sent between different platforms, inconsistencies are possible due to the different word size and the order of the bytes in it (endian). </p><br><p>  To get rid of alignment, you need to declare the data structures packed.  AtmelStudio projects are built by default with the <code>-fpack-struct</code> key, so it‚Äôs enough to make sure that there are no warnings about the cancellation of this key.  It is not desirable to collect a wrnd project with this key, since there is no task to save memory at the expense of data access speed.  It is enough to specify the corresponding attribute where necessary, for example: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">payload_header</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">//   } __attribute__ ((__packed__));</span></span></code> </pre> <br><p>  The process is started in the background by the <code>daemon</code> function: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>-&gt;daemonize &amp;&amp; daemon(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ... <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><p>  As a result, a copy of the process (fork) is created with the new PID, which continues to work further, and the current process ends.  The arguments of the function indicate that for the new process, you must set the root directory as working and redirect the standard input, output and error streams to <code>/dev/null</code> . </p><br><p>  To prevent the daemon from shutting down when attempting to write to a FIFO to which the reader is not connected, you must ignore the SIGPIPE signal: </p><br><pre> <code class="hljs lisp">signal(<span class="hljs-name"><span class="hljs-name">SIGPIPE</span></span>, SIG_IGN)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  The purpose of the rest of the code, it is possible to list the following list: </p><br><ul><li>  analysis of the passed parameters; </li><li>  checking conditions for launching, creating and opening the necessary files; </li><li>  working with log files and their rediscovery by the SIGHUP signal from <code>logrotate</code> ; </li><li>  signal processing SIGINT, SIGTERM for proper shutdown; </li><li>  synchronization with the device and its initialization; </li><li>  processing incoming data and recording the result in the corresponding FIFO channel. </li></ul><br><h3 id="kanal-rngfifo">  Rng.fifo channel </h3><br><p>  Data enters the channel on a straight line in binary form at a speed of approximately 636 bytes / sec.  To add entropy to <code>/dev/random</code> use the <code>rngd</code> daemon.  In order to use only the necessary source, it needs to pass the parameters " <code>--no-tpm=1 --no-drng=1 --rng-device /run/wrnd/rng.fifo</code> ". </p><br><p>  It is worth noting that in order to solve the problem of lack of entropy, it is not necessary to use a true random number generator.  It is enough to run <code>rngd</code> with the parameter " <code>--rng-device /dev/urandom</code> ".  The algorithms used in <code>/dev/urandom</code> quite good and the recommendations for not doing this are usually not completely justified.  The results of comparative testing can be viewed in the <a href="https://habr.com/post/394261/">first part</a> , towards the end of the publication. </p><br><p>  My choice in favor of a true random number generator is simple - I wanted to assemble such a device, and I did not find any arguments against it. </p><br><h3 id="kanal-nrffifo">  Nrf.fifo channel </h3><br><p>  The data from the sensors are processed and then sent to the channel in the form of SQL queries to insert records into the table.  The <a href="">wrnsensors.sh</a> example shows <a href="">how to</a> work with a SQLite3 database, but the INSERT query is universal and must go to any SQL database. </p><br><h3 id="kanal-cmdfifo">  Channel cmd.fifo </h3><br><p>  The channel is used by the management utility <code>wrnctrl</code> , about it just below. </p><br><p>  <code>wrnd</code> can <code>wrnd</code> using the <code>make daemon</code> with the <a href="https://github.com/alexcustos/wrn-project/blob/master/wrnd/Makefile">Makefile</a> .  To build a debug version, a <strong>debug</strong> target is provided. </p><br><a name="wrn_control"></a><br><h2 id="utilita-upravleniya">  Management utility </h2><br><p>  The wrnctrl <code>wrnctrl</code> requires a running <code>wrnd</code> daemon, since it receives data from the device from the cmd.fifo channel. </p><br><p>  Open at the same time FIFO with a predictable result, you can only write, while the reader will receive data from all sources.  If several readers open one FIFO, then it is impossible to predict which of them will receive the data.  This behavior is true by definition, but not desirable, therefore you need to synchronize access to cmd.fifo. </p><br><p>  You can declare a file in Linux using <code>flock</code> , and thus exclude simultaneous work with it, but only in your code.  Since this mechanism does not work for named pipes (pipe), it is necessary to use an additional file in <code>/tmp</code> ( <em>full code:</em> <a href="https://github.com/alexcustos/wrn-project/blob/master/wrnd/gentoo/wrnctrl">wrnctrl</a> ): </p><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">device_cmd</span></span></span></span>() { cmd=<span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-comment"><span class="hljs-comment">#   #    (subshell),       4 ( #     4,      if ! flock -w ${FIFO_MAX_WAIT} 4; then return; fi #    #     ,    if [ -O ${LOCK_NAME} ]; then chmod 666 ${LOCK_NAME}; fi #  cmd.fifo   3,   exec 3&lt; &lt;(timeout ${FIFO_MAX_LOCK} cat ${WRND_CMDFIFO}) sleep 0.2 #       if [ -r /dev/fd/3 ]; then echo "$cmd" &gt;${WRND_DEVICE} #      #  ,    FIFO   timeout while read log_line &lt;&amp;3; do echo "$log_line" #   done exec 3&gt;&amp;- #    3 fi ) 4&gt;${LOCK_NAME} #  4      subshell,    }</span></span></code> </pre> <br><p>  For flashing the device, the <code>wrnctrl flash [firmware].hex</code> .  Before its launch, you must stop the <code>watchdog</code> and <code>wrnd</code> .  The command uses the <code>avrdude</code> utility, you can install it through the package manager, for example: </p><br><pre> <code class="bash hljs">emerge -av dev-embedded/avrdude</code> </pre> <br><p>  In addition to the files mentioned above, the project installation package also includes: </p><br><ul><li>  daemon settings file; </li><li>  OpenRC script to control the daemon; </li><li>  settings file for logrotate; </li><li>  a script launched via cron to write to the log the statuses of all subsystems of the device. </li></ul><br><p>  The project is assembled and installed using the command <code>make install</code> .  The installation should run as root.  The files are copied by the <code>install</code> system utility, which allows you to immediately set the rights and owner on the target files. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  The USB interface for this device would certainly be preferable.  But the lack of an available USB port in my server led to the appearance of the project in this form.  Nevertheless, it turned out to be a fairly simple and stable device that I can recommend for playback. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/300968/">https://habr.com/ru/post/300968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../300952/index.html">Multithreading in PHP: pthreads</a></li>
<li><a href="../300954/index.html">Writing a forum from scratch on Ruby on Rails and AngularJS</a></li>
<li><a href="../300956/index.html">Lazy event sourcing or how to live for today</a></li>
<li><a href="../300960/index.html">Snake fruit or fruit python?</a></li>
<li><a href="../300966/index.html">Deep into the core: familiarity with LTTng</a></li>
<li><a href="../300972/index.html">Record of the webinar "Light cloud protection of corporate networks with low total cost of ownership"</a></li>
<li><a href="../300974/index.html">"Astronauts" in Chile: how we did the entire IT infrastructure for four telescopes in the Andes</a></li>
<li><a href="../300976/index.html">8 tips for every day for those who want to be happy (part 1)</a></li>
<li><a href="../300978/index.html">Design differences for b2b and b2c spheres</a></li>
<li><a href="../300984/index.html">Basics of B2B e-commerce or what you should think about before diving into this pool with your head</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>