<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Electronics and seals: we collect a robot toy for a cat on STM32</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear habrovchane. 
 A lot of time has passed since the last time I wrote articles on development here, it's time to fix this thing. 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Electronics and seals: we collect a robot toy for a cat on STM32</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/6bb/a72/5c1/6bba725c15c30156964ab5bc65eecf15.jpg"><br>  Good afternoon, dear habrovchane. <br>  A lot of time has passed since the last time I wrote articles on development here, it's time to fix this thing. <br>  In this article I will talk about how I assembled a small robot on the STM32F101 microcontroller to entertain my Maine Coon, Arthas, about what problems they had to face and what came of it. <br><a name="habracut"></a><br><h4>  Background and formulation of the problem </h4><br>  Half a year ago I had this black handsome Maine Coon, whom I named Arthas after the famous computer game hero. <br><img src="https://habrastorage.org/getpro/habr/post_images/83e/33f/a1c/83e33fa1c2bf66016c71fca3d980dcd8.jpg" alt="image"><br><br>  The cat is incredibly playful, loves to run, ambush and even bring a ball like a dog.  Since I haven‚Äôt collected anything for a long time, it was decided to develop a small toy for a cat. <br>  The main requirements for it were: <br><br><ol><li>  Protection of critical parts of the structure from cat teeth and claws, ideally, fully enclosed body (ball) </li><li>  From the previous paragraph follows the requirement for small dimensions of the device, since  it is desirable that it still was a small ball, and not a soccer ball. </li><li>  The ability to control from a mobile phone / tablet and desktop computer - in order not to reinvent the wheel and ensure compatibility with mobile devices, Bluetooth connectivity is ideal. </li><li>  To make it more interesting, it is desirable to have at least some sensor that would allow in the future to make the robot more or less autonomous, and not just a radio-controlled machine. </li><li>  Having some way to get the sound out to attract the attention of the kote. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Immediately I will demonstrate a short video of what happened, the koshkob was launched in test mode (controlled by me, from a computer): <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Rh2qzw0OQ0w%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhgfmOclPmKiMwPOGOdh9P8GzP1dzg" frameborder="0" allowfullscreen=""></iframe><br>  <i>Koshkob tested without the outer shell, makes sounds cat attracts and can not escape because</i>  <i>one of the drives fails.</i> <i><br></i>  <i>(More about this at the end of the article)</i> <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/osUz2b2Yzac%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhjcyIUsKW8rCrptlnQopoz6L0Wg8w" frameborder="0" allowfullscreen=""></iframe><br>  <i>Koshkob complete</i> <br><br>  It may seem to some that the cat is not very actively responding to the robot, but in fact the reason is that during the test it has already snatched it from me a hundred times, carried it away and gnawed.  Of course, I took away the robot (until it is finished), so the cat, seeing the robot on the floor, decided to wait some time to make sure that it was not taken away from him as soon as he attacked) <br><br>  Next, I will talk about the development process itself. <br><br><h5>  Development: selection of components and preparation </h5><br><h6>  Housing </h6><br>  Having decided on the proposed design, I purchased a pair of plastic balls consisting of two halves ‚Äî one with a diameter of 60 mm and the other with 80 mm, in case the first one fails to fit.  Such dimensions greatly limited the choice of engines and sensors (in the sense that, for example, an ultrasonic sensor could be forgotten, it would not fit in the ball and, moreover, would not work in an enclosed space. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc6/e2e/1bd/fc6e2e1bd25fba4e1758cbf6c79a35e1.jpg" alt="image"><br><br><h6>  Microcontroller </h6><br>  After cutting off the "ear", the balls became ideal candidates for the role of the body.  Due to the limited size, it was decided to design the entire schematic using the most compact cases, that is, for the most part, QFN. <br>  <a href="http://www.st.com/web/en/catalog/mmc/FM141/SC1169/SS1031/LN1567/PF189785">STM32F101</a> was chosen as the central processor, since it is a microcontroller on the Cortex M3 core, and not a truncated M0, while it can operate at 36 MHz, has 64 KB of flash and 16 KB of RAM, and, most importantly, comes in 6x6 mm QFN -casing <br><br><h6>  Sensor </h6><br>  As a sensor, a three-axis accelerometer <a href="http%253A%252F%252Fwww.st.com%252Fweb%252Fcatalog%252Fsense_power%252FFM89%252FFM89%252FSC444%252FPF191236%26ei%3DseatUomYDOqY4wTd2oHgBQ%26usg%3DAFQjCNFK49MYwt9DdiapxMEN7f1dhSAn2w%26sig2%3DWCmDFe3HRYRexSqlwTCS8Q%26bvm%3Dbv.57967247,d.bGE">LIS331DL</a> from the same ST was chosen, which was just a discount in Terraelectronics, so I got it at a price of about 30 rubles per item. <br><br>  The accelerometer is available in a QFN case, 3x3 mm and can communicate via the I2C bus, which is very useful in conditions of limited dimensions.  With the help of an accelerometer, it is possible to subtract the tilt of the robot along three axes, and it is also possible to try to get information from it about whether the robot is moving or has run into an obstacle (by changing the acceleration).  And, of course, determine the time at which the cat kicks him to make a squeak - so the cat will consider it to be something alive) <br><br><h6>  Connection </h6><br>  As a means of communication, of course, we take proven, cheap and small Chinese modules <a href="http://dx.com/p/hc-05-wireless-bluetooth-serial-pass-through-module-for-arduino-green-240417">HC-05</a> <br><img src="https://habrastorage.org/getpro/habr/post_images/7ca/fb6/23a/7cafb623a8502cd7395fa53080010b1a.png"><br>  This is the only finished module in the robot. <br><br><h6>  Sound source </h6><br>  Initially, I wanted to use compact speakers, but, unfortunately, even the smallest speakers were still very large.  In addition, they consumed a great deal and demanded at least a transistor and a filter in order to shake them with WMA.  After some amount of googling, I found just such an entertaining piezo-squeaker: <br><img src="https://habrastorage.org/getpro/habr/post_images/5fe/9b8/e58/5fe9b8e5889d690590ee4fd42d2f2d92.jpg"><br>  Murata's <a href="http://www.chipdip.ru/product/pklcs1212e4001/">PKLCS1212E4001</a> costs 48 rubles, has dimensions of 11x11 mm (the largest element on the board!) And is a standard Piezo Sounder, a device that makes a sound due to the bending of a membrane by the piezoelectric effect.  And this means that it consumes an order of magnitude less current than a speaker squeaking at the same volume. <br>  But, in contrast to the dynamics of her very tricky and uneven frequency response, so that the best she knows how to squeak.  And the loudest she gets to do it at 4 KHz (but this does not mean that you can‚Äôt squeak at others!) <br><br><h6>  Drives </h6><br>  The most important element is the drives that will move the robot.  Unfortunately, everything was not as smooth with them as we would like, more on this at the end of the article.  As drives, I decided to take the smallest servos that I could find and remake them for constant rotation. <br>  My choice is explained by the fact that by taking servos I get a motor + gearbox + control board in a housing of about 15x20x8 mm.  With all the desire, I could not find a gear motor of such dimensions. <br>  As a result, the choice fell on <a href="http://dx.com/p/2g-plastic-analog-servo-for-rc-model-toy-black-dc-2-5-4-8v-201358">sub-micro servas</a> , at the price of 187 rubles per share: <br><img src="https://habrastorage.org/getpro/habr/post_images/95e/acf/118/95eacf1186663ddfa8e79ee9be14f0c3.jpg"><br><br><h6>  Nutrition </h6><br>  All elements are selected, it remains to decide how and what to feed the system.  Obviously, the smallest lithium-polymer battery is the smallest and most suitable source.  Since the drives require 4.8V, we increase the voltage to 5V with a <a href="http://www.maximintegrated.com/datasheet/index.mvp/id/5770">compact DC-DC converter</a> from MAXIM Semiconductors.  The MAX8815 is a superb 3x3 mm microcircuit that allows you to load up to 1A with 97% efficiency (which, of course, depends on the correctness of the PCB layout, operation mode and choice of strapping, as always). <br>  Since the drives consume no more than 600 mA together at peak times, this is more than enough. <br><br>  To power the rest of the electronics and protect it from interference from the engines, after the DC-DC boost converter, we put a small-sized linear regulator from TI, <a href="http://www.ti.com/product/lp2985-n">LP2985</a> , with a fixed 3.3V output. <br><br><h5>  Circuit design and some design </h5><br><br>  First, a few words about the design of the robot.  In order to minimize the size and cost, I decided to use printed circuit boards as structural elements.  That is, the drives are clamped between two printed circuit boards, which are fastened with screws.  Assembled (and after debugging modifications of the board, which are later), it all looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/786/1f8/ed4/7861f8ed44eebb31c4a7fa041e47ed6b.jpg"><br><br>  To prevent the drives from moving down, I put wonderful material between the board and their surface - latex from the Torres expander <br><img src="https://habrastorage.org/getpro/habr/post_images/3ce/334/5b4/3ce3345b4a261909e764fb8a2ad09702.jpg" alt="image"><br><br>  The fact is that once I bought a slingshot in China.  The cattle was very comfortable, made of titanium alloy, but the rubber was not to hell there.  On the Internet, experts on slingshots advised to immediately throw it out, to buy this very expander, and to cut out replacement harnesses from it.  The result exceeded all my expectations and the slingshot became incredibly powerful.  And since  The expander is a big thing, then most of the material remained untouched and lay in a drawer, waiting for its time. <br>  After using this latex as a gasket between the drives and the board, the drives stood up like a glove, not moving a millimeter. <br><br>  Accordingly, for the implementation of this design requires two boards, in which all components are focused on the outer sides. <br>  Once we have such a sudden increase in usable area, on the bottom board you can place a battery charger, a mini USB connector, charging LEDs, and at the same time bring a BT module so that it does not cover the battery and does not interfere with communication. <br>  Thus, two PCBs, TOP and BOTTOM, were developed.  On the bottom is what I have already said, and on the top is the whole ‚Äúbrain‚Äù and, so to speak, the digestive system of the robot - a microcontroller, an accelerometer, a converter and a power regulator strapping and, of course - a piezo-squeaker. <br><br>  The scheme of the top board looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee0/53d/7fd/ee053d7fd14cda466b42fead1d4b8187.jpg"><br>  <i>Power scheme</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a69/383/cc1/a69383cc120dad67e94c136fede6cd73.jpg"><br>  <i>Brain</i> <br><br>  In order for USB not to drive its five volts where it is not necessary, the ON inputs of the U1 converter and the U2 regulator are connected, pulled up to power and brought to J1 on the edge of the board ‚Äî the GND level feed puts the converter's inputs and outputs into a high impedance state, essentially breaking the circuit and letting the USB current flow where it should be ‚Äî into the battery charging circuit.  The rest of the connection scheme is typical of datasheet. <br><br>  The U4 accelerometer is connected to the I2C bus of the controller without pull-up resistors - yes, they are necessary for the bus to work, but in the datasheet they assert that they <i>are connected inside the LIS331DL</i> .  Strangely enough, there is no more information about them, I never recognized the nominal (and in the off state it is not measured, apparently, they are disconnected from the bus by transistors).  So I had to blindly rely on datasheet.  I must say, in this I did not lose - the accelerometer actually works fine without additional resistors. <br>  However, another major fac-up was associated with it, which you can read about in the ‚ÄúTesting and Facs-ups‚Äù section. <br><br>  In addition to the accelerometer, a D1 LED is connected to the controller, which is intended to visually attract the cat's attention and serve as a means of indication, as well as a voltage divider on resistors R4 and R5, which is connected to the ADC input of the controller through a smoothing capacitor C5.  This divider leads the battery voltage to the range that ADC can measure, making it possible to judge the level of battery charge. <br>  Incidentally, a mini-factor was connected with these resistors.  The fact is that I assumed the presence in the controller of the built-in reference voltage (about 1.2 volts), as in the older models.  But, as it turned out, in the models in the QFN36 case, there is no built-in source, and the REF input inside the case is shorted to the supply voltage (3.3V), so the resistors that at 4.2V battery gave 1V at the output had to be changed to those that give 3V . <br><br>  The LS1 squeaker, thanks to its piezo essence, can be connected directly to the controller pin - its consumption is very small, at its resonant frequency its impedance is several hundred ohms.  The only potential problem is that it can work in the opposite direction, that is, to generate voltage during deformation (shock), for which protective diodes or resistors are usually used.  However, according to the results of the experiment, the voltage at the impact of an average force did not exceed 1.5V, which the protection diodes of the controller output can do well with, so I ventured not to put on additional protection. <br><br>  The outputs from the onboard PWM generator of the controller are mapped to pins J8 and J9 to control the drives.  As an additional (and, as it turned out, not superfluous) measures to reduce consumption in inactive mode, contacts J11 and J12, to which GND drives are connected, are cut off from ground by a power transistor Q1 - supplying a high level to the gate gives the drives a ground force and allows current flow through their insides.  As it turned out, even at zero PWM signal, the control circuit of the drives still supplies some voltage to them and the consumption increases by 10 mA compared to completely disconnected ones. <br><br>  An important point was the choice of debugging interface.  In conditions of very limited dimensions, of course, I wanted to do with the minimum number of wires.  But the information about the minimum amount turned out to be quite contradictory.  After thoughtful googling and experiments, I stopped at the SWD interface, removing only the SWDIO and SWCLK pins.  Related to this is another fac-up described in the section ‚ÄúTesting and Facs-ups‚Äù.  But in short - yes, these two pins are really enough for debugging <i>in most cases</i> . <br><br>  The bottom board is quite simple: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ce/cb3/914/5cecb39148feb58cd272b186b286570b.jpg"><br>  <i>Bottom fee</i> <br><br>  It contains two parallel Li-Pol (Li-Ion) battery charging linear circuits connected in parallel, <a href="http://cds.linear.com/docs/en/datasheet/405442xf.pdf">LTC4054</a> from Linear Technology.  This is the easiest way to charge single-cell lithium-polymers and lithium-ions, known to me, if not pretty low efficiency (which is due to the fact that the chips are linear). <br>  They stand perfectly in parallel, in some Chinese schemes saw as many as four similar mikruhi in parallel, providing a large charge current.  Separately, each can give up to 800 mA, but this is only if you want to fry eggs on them.  With a load above 500 mA and a fully discharged battery, the microcircuit begins to heat up so that it is impossible to hold a finger.  Since  A protection circuit for temperature is built into it, which, in principle, is not terrible - it will automatically reset the load current when it warms up to 120 degrees.  But still this is not very pleasant, so I chose to put two pieces, since the place allowed.  The charge current is set by resistors R4 and R5, selected by me so that it is about 500 mA for two (that is, 250 mA for each), at which they are not so heated. <br><br>  In addition, the board has a mini-USB connector (J2), a Q1 transistor, a pull-up ON input of the power supply circuit on the top board to ground, with USB connected, and a Bluetooth communication module. <br><br>  I ordered the boards at Rezonita, it came out quite budget-wise, I paid less than 2000r for a panel of six different boards, on which there were two boards from a cat-hobo. <br>  Top and bottom boards are 32x26 mm.  After assembly (and before the fix-up fix), the top board looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/0c5/c10/f63/0c5c10f63fbc4e08a7a924710559ee5e.jpg"><br><br>  And the bottom is like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/def/a4a/3f3/defa4a3f3a4e304931a0ea6a0bd29e1d.jpg"><br><br>  It's time to write a test firmware! <br><br><h5>  Test firmware </h5><br><br>  I plan to make the final firmware based on FreeRTOS (so as not to waste time implementing normal multitasking, blocking queues and other things), but for the test I sketched a small firmware initializing all the peripherals and allowing it to be controlled by simple commands from the computer.  Go through the initialization: <br><br><h6>  Clocking and GPIO </h6><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitRCC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2|RCC_APB1Periph_TIM3,ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitGPIO</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GPIO_InitTypeDef GPIO_InitStructure; <span class="hljs-comment"><span class="hljs-comment">//LED GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //ADC GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //Buzzer GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_WriteBit(GPIOA, GPIO_Pin_2, Bit_RESET); //Servo GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //Servo On/Off GPIO_WriteBit(GPIOA, GPIO_Pin_5, Bit_RESET); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //Accel GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //UART &amp; BT Control GPIO_WriteBit(GPIOA, GPIO_Pin_8, Bit_RESET); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); }</span></span></code> </pre> <br></div></div><br>  Everything is simple here - we submit the clock to all the peripherals we need, that is, to the I / O ports, the ADC, the UART, a couple of timers (one for a tweeter, the second for PWM drives) and I2C.  Then we set up all GPIO. <br><br><h6>  Squeaker </h6><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitBuzzer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; TIM_TimeBaseStructure.TIM_Period = <span class="hljs-number"><span class="hljs-number">4</span></span>; TIM_TimeBaseStructure.TIM_Prescaler = <span class="hljs-number"><span class="hljs-number">1800</span></span>; TIM_TimeBaseStructure.TIM_ClockDivision = <span class="hljs-number"><span class="hljs-number">0</span></span>; TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure); TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number"><span class="hljs-number">0</span></span>; TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; TIM_OC3Init(TIM2, &amp;TIM_OCInitStructure); TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable); TIM_ARRPreloadConfig(TIM2, ENABLE); TIM_Cmd(TIM2, ENABLE); }</code> </pre><br></div></div><br>  Setup is reduced to the initialization of the timer, the output of which is connected to the squeaker.  We adjust the PWM, but, in fact, it is the pulse width that will not be changed, always setting it to 50%.  Instead, we will change the divider, forcing the timer to change the frequency of the pulses in order to squeak in a different tone. <br>  Since the system frequency is 36 MHz, we set the period to 4 (we still do not need a lot of PIMA discharge), and the prescaler is 1800, receiving a frequency of 4 KHz. <br><br><h6>  Drives </h6><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitServo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; TIM_TimeBaseStructure.TIM_Period = <span class="hljs-number"><span class="hljs-number">0xFFF</span></span>; TIM_TimeBaseStructure.TIM_Prescaler = <span class="hljs-number"><span class="hljs-number">0xB0</span></span>; TIM_TimeBaseStructure.TIM_ClockDivision = <span class="hljs-number"><span class="hljs-number">0</span></span>; TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number"><span class="hljs-number">0</span></span>; TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; TIM_OC1Init(TIM3, &amp;TIM_OCInitStructure); TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure); TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable); TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable); TIM_ARRPreloadConfig(TIM3, ENABLE); TIM_Cmd(TIM3, ENABLE); }</code> </pre><br></div></div><br>  We do the same thing as with the beeper, but we are already sharpening the output of PWM with the parameters required by the drives, namely, the frequency around 50 Hz, and a sufficiently large number of digits to control the speed with great accuracy.  Thus, we set the prescaler to 176, and the period to 4096, which gives us approximately 50 Hz and 12 bits of PWM. <br><br><h6>  Accelerometer and Bluetooth </h6><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitAccel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ I2C_InitTypeDef I2C_InitStructure; I2C_InitStructure.I2C_Mode = I2C_Mode_I2C; I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2; I2C_InitStructure.I2C_OwnAddress1 = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; I2C_InitStructure.I2C_Ack = I2C_Ack_Enable; I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit; I2C_InitStructure.I2C_ClockSpeed = <span class="hljs-number"><span class="hljs-number">200000</span></span>; I2C_Init(I2C1, &amp;I2C_InitStructure); I2C_Cmd(I2C1, ENABLE); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitBT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; USART_InitStructure.USART_BaudRate = <span class="hljs-number"><span class="hljs-number">9600</span></span>; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(USART1, &amp;USART_InitStructure); USART_Cmd(USART1, ENABLE); USART_ITConfig(USART1, USART_IT_RXNE, ENABLE); NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number"><span class="hljs-number">0</span></span>; NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number"><span class="hljs-number">0</span></span>; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); }</code> </pre><br></div></div><br>  Everything is simple here - for the accelerometer, we simply turn on I2C for a speed of 200 KHz (although it is possible more and less, the axel allows), and Bluetooth is our usual UART, which we turn on for standard 9600 and at the same time set up intercept reception in which we will process commands. <br><br>  Next, write the UART interrupt handling code.  Of course, it is not the most successful, it will not hurt at least to check the checksum, but it will do for the test.  In order not to waste time on the command queue, let's make it equal to one team - it still only affects how often you can throw commands to the controller and not be afraid that he will let them through. <br><br><h6>  Command Reception Code </h6><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OPCODE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LENGTH 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PAYLOAD 2 enum CommandStates {CS_DONE, CS_RECEIVING, CS_EXECUTING}; enum CommandCodes {CC_TEST=0x01, CC_SERVO_STATE, CC_SET_SERVO1_DS, CC_SET_SERVO2_DS, CC_GET_ACCEL_REG, CC_SET_ACCEL_REG, CC_GET_BATTERY, CC_LED_STATE, CC_BUZZER, CC_INVALID}; enum ErrorCodes {EC_NONE, EC_INVALID_CMD, EC_MAX_LEN_EXCEEDED}; enum ReplyCodes {RC_NONE, RC_EXECUTED, RC_TEST, RC_ACCELREG, RC_ERROR}; typedef struct { unsigned char Command; unsigned char State; unsigned char Length; unsigned char Payload[CMD_BUFFER_LEN]; }CommandDescriptor; CommandDescriptor Cmd; void InitCmd(CommandDescriptor *Comm) { Comm-&gt;Command=0; Comm-&gt;Length=0; unsigned char i; for(i=0;i</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;CMD_BUFFER_LEN;i++) Comm-&gt;Payload[i]=0; Comm-&gt;State=CS_DONE; //Init state at the end, to prevent interrupt from interfering } void SetInvalidCmd(CommandDescriptor *Comm, unsigned char ErrorCode) { Comm-&gt;Command=CC_INVALID; Comm-&gt;Length=3; Comm-&gt;State=CS_EXECUTING; //Just send back error Comm-&gt;Payload[0]=ErrorCode; } void USART1_IRQHandler(void) { char data; if ((USART1-&gt;SR &amp; USART_FLAG_RXNE) != (u16)RESET) { data = USART_ReceiveData(USART1); switch(Cmd.State) { case CS_DONE: if(data&gt;=CC_INVALID) { SetInvalidCmd(&amp;Cmd, EC_INVALID_CMD); return; } Cmd.Command=data; Cmd.Length=0; Cmd.State=CS_RECEIVING; return; case CS_RECEIVING: if(Cmd.Length==0) { if(data&gt;CMD_BUFFER_LEN) { SetInvalidCmd(&amp;Cmd, EC_MAX_LEN_EXCEEDED); return; } Cmd.Length=data; BufPtr=0; return; } if(BufPtr&lt;Cmd.Length-2) //Including opcode and length fields { Cmd.Payload[BufPtr]=data; BufPtr++; } if(BufPtr&gt;=Cmd.Length-2) { Cmd.State=CS_EXECUTING; return; } case CS_EXECUTING: return; } } }</span></span></span></span></code> , CC_SET_SERVO1_DS, CC_SET_SERVO2_DS, CC_GET_ACCEL_REG, CC_SET_ACCEL_REG, CC_GET_BATTERY, CC_LED_STATE, CC_BUZZER, CC_INVALID}; <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OPCODE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LENGTH 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PAYLOAD 2 enum CommandStates {CS_DONE, CS_RECEIVING, CS_EXECUTING}; enum CommandCodes {CC_TEST=0x01, CC_SERVO_STATE, CC_SET_SERVO1_DS, CC_SET_SERVO2_DS, CC_GET_ACCEL_REG, CC_SET_ACCEL_REG, CC_GET_BATTERY, CC_LED_STATE, CC_BUZZER, CC_INVALID}; enum ErrorCodes {EC_NONE, EC_INVALID_CMD, EC_MAX_LEN_EXCEEDED}; enum ReplyCodes {RC_NONE, RC_EXECUTED, RC_TEST, RC_ACCELREG, RC_ERROR}; typedef struct { unsigned char Command; unsigned char State; unsigned char Length; unsigned char Payload[CMD_BUFFER_LEN]; }CommandDescriptor; CommandDescriptor Cmd; void InitCmd(CommandDescriptor *Comm) { Comm-&gt;Command=0; Comm-&gt;Length=0; unsigned char i; for(i=0;i</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;CMD_BUFFER_LEN;i++) Comm-&gt;Payload[i]=0; Comm-&gt;State=CS_DONE; //Init state at the end, to prevent interrupt from interfering } void SetInvalidCmd(CommandDescriptor *Comm, unsigned char ErrorCode) { Comm-&gt;Command=CC_INVALID; Comm-&gt;Length=3; Comm-&gt;State=CS_EXECUTING; //Just send back error Comm-&gt;Payload[0]=ErrorCode; } void USART1_IRQHandler(void) { char data; if ((USART1-&gt;SR &amp; USART_FLAG_RXNE) != (u16)RESET) { data = USART_ReceiveData(USART1); switch(Cmd.State) { case CS_DONE: if(data&gt;=CC_INVALID) { SetInvalidCmd(&amp;Cmd, EC_INVALID_CMD); return; } Cmd.Command=data; Cmd.Length=0; Cmd.State=CS_RECEIVING; return; case CS_RECEIVING: if(Cmd.Length==0) { if(data&gt;CMD_BUFFER_LEN) { SetInvalidCmd(&amp;Cmd, EC_MAX_LEN_EXCEEDED); return; } Cmd.Length=data; BufPtr=0; return; } if(BufPtr&lt;Cmd.Length-2) //Including opcode and length fields { Cmd.Payload[BufPtr]=data; BufPtr++; } if(BufPtr&gt;=Cmd.Length-2) { Cmd.State=CS_EXECUTING; return; } case CS_EXECUTING: return; } } }</span></span></span></span></code> </pre><br></div></div><br>  To begin, we will declare the structure of the command, which will consist of, in fact, the command itself, the state (completed, in the process of receiving, during processing), the packet length (including the two fields already listed) and the payload, which can be from 0 to 8 bytes . <br>  We describe a helper function for initializing this structure and another one for filling it with Invalid Command values. <br>  Now we describe the interrupt.  Having received one byte on the UART, let's see what happens with the current command (the one and only one in the ‚Äúqueue‚Äù) - <br>  if its status tells us that the execution has been completed, then we will check if we received the correct opcode, if not, we will report an error, if yes, we will begin to receive a new command, setting the status to <i>CS_RECEIVING</i> . <br>  If we are in the process of receiving, we control the length of what we get - so that it does not exceed 10 bytes (2 bytes of the header and payload) and the length declared in the second byte of the header.  If something is wrong, we report an error, otherwise we say that the command has been received and has passed to the <i>CS_EXECUTING</i> state.  From this point on, we ignore everything that comes to us, until someone <i>sets</i> this team to <i>CS_DONE</i> . <br>  If we had a real queue, it would be possible to throw the received command into it and for now take the following. <br><br>  That's all - the main function of the firmware simply initializes the peripherals, turns on the Bluetooth and waits until the command has the status <i>CS_EXECUTING</i> .  After that, it processes the command (I will not give this code, there is just a big switch on opcodes with entering bytes from the payload to the registers) and sets it to <i>CS_DONE</i> status. <br><br><h6>  void main () </h6><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ InitCmd(&amp;Cmd); InitHardware(); DisableServos(); EnableBT(); EnableLED(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Cmd.State==CS_EXECUTING) { ProcessCmd(&amp;Cmd); InitCmd(&amp;Cmd); } } }</code> </pre><br></div></div><br><br><h5>  Modification of drives for constant rotation and design issues </h5><br>  Since the drives were originally designed to rotate within 170 degrees, they need to be slightly upgraded in order to use them as robot engines.  Because of their small size, this may not be very easy at first. <br>  In general, all drives are built in the same way, regardless of size - they have a motor, they have a gearbox, the output shaft of which sits on the same axis with a variable resistor, from which the control circuit removes information about the current position of the shaft. <br><img src="https://habrastorage.org/getpro/habr/post_images/7aa/693/010/7aa6930109473695e806fcb12047aedd.jpg"><br>  The resistor is turned on as a divider between power and ground.  On one of the gears on the output shaft, there is a stopper that does not allow the server to spin further than it should be, and the potentiometer itself acts as such a stopper.  Specifically, in these drives everything is rather trivial - the stopper is an outgrowth on the output shaft, it is large enough, so it‚Äôs easier not to cut it, and then - what it rests against, the protrusion inside the drive cover <br><img src="https://habrastorage.org/getpro/habr/post_images/74a/cc0/d45/74acc0d4516271376e8d4becbbb1dea9.jpg"><br>  This protrusion is easily melted by a soldering iron, the main thing then is to make sure that there are no pieces of plastic left that will interfere with the rotation. <br>  The potentiometer shaft contains a small cut at the end, due to which it is not turned in the gear of the output shaft.  By the way, it is located in a small depression in which this gear comes in.  Therefore, we simply cut / fuse it with a soldering iron until a trace of this cut remains.  Everything, the gear wheel quietly turns, without touching the variable resistor. <br><img src="https://habrastorage.org/getpro/habr/post_images/582/7e1/2c1/5827e12c16251b25b4c3fa5cc4aee0fa.jpg"><br>  Lubricate everything additionally, because  The Chinese feel sorry for the grease, close the top cover.  There are very few. <br>  Open the bottom cover, see the control circuit connected to the motor and potentiometer. <br><img src="https://habrastorage.org/getpro/habr/post_images/3f1/ce2/e22/3f1ce2e224aea04e222f12f2ead6122d.jpg"><br>  Ruthlessly cut off the wires from the potentiometer, remove them from the servos so as not to interfere.  To the contact pads to which they walked, we solder two identical small SMD resistors, with a total resistance of about 5 KŒ© (if a little more or a little less is not terrible), forming a permanent divider.  I soldered two for 2.4Kom. <br>  Since the motors will lie mirror relative to each other, one of them also swaps the wires going to the motor.  You can, of course, do this software, but it is ironier more pleasant. <br><br>  That's it, now the serv will always assume that its shaft is exactly in the middle.  And by submitting a PWM signal with a duty ratio greater than the average, the output shaft will begin to rotate in one direction, and at less - in the other.  And the more the filed value is separated from the average, the faster the shaft rotates. <br><br><h5>  Testing and Facs </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/12d/6bd/9fb/12d6bd9fbbad9f533d6b9183d9250abb.jpg"><br>  <i>Customer tests device prototype</i> <br><br>  Since I have already demonstrated the video and photo of the device above, this section will mainly contain a text description of the rake I stepped on.  Some of them occurred through my fault, some did not depend on me. <br><br><h6>  Fak-up with food </h6><br>  The very first factor-up, entailed the most improvements in the scheme.  Connected to the boost converter.  When I first started the device (so far without drives), I didn‚Äôt notice anything, the controller started up and flashed.  5B were present at the output of the converter.  The time has come to check the drives, this is where the rakes came out.  When connecting the drives, the converter was instantly cut off - its built-in protection triggered, disabling the microcircuit, in case the output voltage drops more than 10 percent below the set point (5V).  Debugging took me a very long time, including sitting at an oscilloscope, replacing the converter chip itself with a similar one, testing different chokes, etc. <br>  Interestingly, even the containers hung around the drives did not help, so I decided that the problem was in the PCB layout or in the choke.  Measurements have shown that the converter stops working at a load of more than 90 mA, and even in the case of a pure resistive load!  At the same time, the efficiency was about 40 percent, of course, this is unacceptable for a pulse converter. <br><br>  The reason turned out to be incredibly commonplace - it seems that instead of the output ceramic capacitor of 10 ¬µF, I mistakenly soldered the same to 1 ¬µF.  With such an output capacitance, the microcircuit could not reach the mode, and the large capacitors mounted on the snot did not help it at all. <br>  Lightly stripping the board from the mask, I soldered two 22 microfarads of ceramic capacitor to the converter output, to its input, and right in front of the servos. <br>  At the same time I set a smoothing choke (more precisely, ferrite bead), <a href="http://search.murata.co.jp/Ceramy/image/img/PDF/ENG/L0110S0100BLM41P.pdf">BLM41PG471SN1</a> , calculated for 2A, between the output of the converter and the servers. <br>  In addition, as it turned out, the place on the board allows you to push there one tantalum capacitor in the ‚ÄúA‚Äù case, 150 ŒºF, right next to the converter output. <br>  In fact, one 22 microfarad capacitor at the output and one at the input would be enough for correct operation, but since space allowed, I decided to play it safe. <br>  The result was just great, the 5V output, even under load, was almost not noisy, and the converter's efficiency, according to my measurements (I included ammeters in the input and output circuits), reached 93 percent, which is a very good figure in itself. <br><br>  <b>Conclusion from the FAQ:</b> Check which elements are soldered to the board.  Pulse converters are sensitive, and the components mounted on snot will not improve the situation, even if the direction of thought (insufficient output capacity) was correct. <br>  The resistance of the probes and the shunt of the multimeter, the capacity and inductance of the prototypes distort the picture, so it is necessary to test such things in the final configuration, and not on snot. <br><br><h6>  Fac-up with accelerometer </h6><br>  Hemorrhoid fak-ap, again because of inattention.  When testing the periphery, it turned out that the accelerometer is not responding.  Since  He sits on the I2C bus, the conversation begins (not counting the starting impulse) by passing the address of the device.  After that, it should respond with a confirmation pulse, if the address coincided.  There was no impulse. <br>  Since the accelerometer case was the most disgusting for soldering (3x3 mm and there was no earthen pad on the belly of the chip, which made it disgustingly centered), I decided that the problem was soldering and spent a lot of time re-soldering it several times.  Did not help. <br>  Then I decided that the promised built-in resistors were still insufficient, cleaned the board and soldered their own.  Did not help. <br>  Many times I checked the code and checked the address with the datasheet.  Did not help. <br>  As a result, by some miracle, he gave an address that differs from the one given (in one of the digits of the binary representation of the address).  It helped. <br>  I started digging datasheets, because this simply could not be - so that the device responded to another address.  And found a great thing. <br>  It turns out that there are two modifications of the accelerometer: <a href="http://www.st.com/st-web-ui/static/active/en/resource/technical/document/datasheet/CD00172345.pdf">LIS331DL</a> and <a href="http://www.st.com/web/en/resource/technical/document/datasheet/CD00213470.pdf">LIS331DLH</a> . <br>  The same case.  Same datasheets.   .      2g/4g/8g,   ‚Äî  2g/4g. <br>      .  ,     LIS133    ¬´LIS133DLH¬ª,       ,      . <br><br> <b>  -:</b>     .           ‚Äî  ,     .               ,       . <br><br><h6> -  Bluetooth- </h6><br>   -    . ,      , HC-04, HC-05, HC-06 ‚Äî    ,  .       . <br>   HC-04  HC-05,   ,   04  , ,  05           GPIO,  05    ,   ,  04     (  ,        ),                . <br>           . <br>  ,          ,   ‚Äî      20  40    . <br>            RESET .           RESET   . <br><br> <b>  -:</b>  ‚Äî  .    ,    , ,     ‚Äî . <br><br><h6> -    </h6><br>    -,    . ,            SWD ‚Äî   . ,      (ST-LINK   ),    <i>VAPP</i>      .           ,   -            3.3. , ,    ‚Äî       . <br>   .   <i>NRST</i> , ,  ,   .     SWD    ,    ,    .  But. <br>       .  ,          32,  <b>Debug support for low-power modes</b> : <i>The core does not allow FCLK or HCLK to be turned off during a debug session. As these are required for the debugger connection, during a debug, they must remain active.</i> <br>     ,  Stand-By,     .  And since           -,        . <br>         ‚Äî    - ,  -    (         ),        ,    <i>NRST</i>    . <br>  ,   ,    ,     -,        .        GND,   ,      -   . ,    ,           . <br><br> <b>  -:</b> ,   ,   .     ,      ,      . <br><br><h6> -   </h6><br>   -,      . , , .      -,  ,    <i></i>      .    .  ,        ,   .          ‚Äî   ,         (  ,  )    . <br><img src="https://habrastorage.org/getpro/habr/post_images/eb7/663/c98/eb7663c983dbf263c454cdfe586f0e61.jpg"><br>  , ,    ‚Äî ,  .        .      ,            1-2   .          ,      MG90,   ,      . <br>         (  ,     )    . <br> , , - . <br><br> <b>  -:</b>      ,    ,      .    ‚Äî      . ,        ,   ,   . <br><br> <b>   :</b>   ‚Äî  .        ,       . ,   ) <br>         ‚Äî   (    ) ‚Äî  ,                 .      .    ‚Äî    ,            .   ‚Äî   .           .     , . <br>          ,            (     ).   ‚Äî   ,   v1.5,      FreeRTOS! <br><br>     ,      ! <br><img src="https://habrastorage.org/getpro/habr/post_images/bfb/fe0/baa/bfbfe0baa4eebca116b3f8322a970eee.jpg" alt="image"></div><p>Source: <a href="https://habr.com/ru/post/206128/">https://habr.com/ru/post/206128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206116/index.html">Algorithm for Improved Self-Organizing Growing Neural Network (ESOINN)</a></li>
<li><a href="../206120/index.html">Simple Unity State Machine</a></li>
<li><a href="../206122/index.html">Cheap USB PC Button</a></li>
<li><a href="../206124/index.html">FT232H and almost universal USB <-> JTAG adapter for 15 euros</a></li>
<li><a href="../206126/index.html">Foxconn nanoPC AT-7300 nettop review on Intel Core i3-3217U</a></li>
<li><a href="../206130/index.html">NASA unveiled Valkyrie - a humanoid robot that will participate in the final competition DARPA</a></li>
<li><a href="../206136/index.html">Broadcasting XXI century</a></li>
<li><a href="../206138/index.html">Cisco vs Aruba: Arguments Exhausted?</a></li>
<li><a href="../206142/index.html">Arcanum and Fallout 2 with touch screen and stylus in Windows 8</a></li>
<li><a href="../206144/index.html">The power of a word. How a simple explanation saved user relationships.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>