<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Trojan-Downloader.Win32.Cabby.cemx - Part Two - Functional</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous part, the first defense layer of the malware was dismantled and removed. We dumped the process after decrypting the main code, saving ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Trojan-Downloader.Win32.Cabby.cemx - Part Two - Functional</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/dfe/47a/8ab/dfe47a8abb7b9fbc8374943cac7c7909.png"><br><br>  In the <a href="http://habrahabr.ru/post/257413/">previous part, the</a> first defense layer of the malware was dismantled and removed.  We dumped the process after decrypting the main code, saving it in a separate executable file. <br>  It is time to understand the logic and meaning of the Downloader itself. <br><a name="habracut"></a><br><br><h2>  Network activity </h2><br>  Express analysis of network activity showed that the malware scans a few resources on the list and downloads some efax.jpg from the first available.  Here is an example request: <br><img src="https://habrastorage.org/files/6d6/42e/fc4/6d642efc40074f82b27abd2f7f2f5a95.png"><br>  Download .jpg and see the insides of this file - a random collection of bytes.  Neither the JPG "FF D8" signatures, nor any lines.  Again encrypted data?  We will understand later. <br><img src="https://habrastorage.org/files/66f/359/1db/66f3591dbce4420db6c31e183db0a9c5.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  API Recovery </h2><br>  Almost at the very beginning of the listing we stick into the procedure <b>0x0040214C</b> .  It recovers the addresses of the API functions necessary for executing the Downloader code. <br>  There is no point in citing the entire listing of the procedure - too bulky and of the same type.  At the very beginning, the lines with the DLL names are decrypted, after which these DLLs are connected using LoadLibrary, and pointers to them are saved to the stack: <br><img src="https://habrastorage.org/files/973/774/5f4/9737745f414b401aae75fbc6254693ba.png"><br>  Next, using the received pointers and the decrypted names of the required APIs, using GetProcAddress, the addresses of the required APIs are found and stored in variables. <br><img src="https://habrastorage.org/files/825/482/1e7/8254821e74434addac0b8510bc198e38.png"><br>  This is all the meaning of this procedure. <br>  The only thing that can be considered in more detail is the procedure for decoding string variables. <br>  An example of its use: <br><img src="https://habrastorage.org/files/52c/bda/4e3/52cbda4e31804187b77323ee8b53218e.png"><br>  The insides of the procedure itself: <br><img src="https://habrastorage.org/files/04d/566/2d5/04d5662d5040448e8c67e149bfc79205.png"><br>  Decryption byte, key 16 bytes.  If the string is more than 16 bytes, the key is repeated cyclically. <br><br><h2>  Cheat for user </h2><br>  Immediately after the restoration of the required API, the allocation of three 512 byte buffers.  We will follow them. <br><img src="https://habrastorage.org/files/641/03e/0ab/64103e0ab7064116a7e174fbae24da14.png"><br>  Next, one of the buffers is used to save the path to the% Temp% directory obtained with GetTempPath.  Take note ... <br>  Slightly below, the resource name string is decrypted using the <b>0x00402F4F</b> procedure parsed above, its offset is located and stored in the% Temp% directory, as an .cab archive.  The archive name is randomly generated by the procedure <b>0x00401EE8</b> . <br>  An example of creating a file: <br><img src="https://habrastorage.org/files/f7c/474/379/f7c474379a7b4bcbb3fd85101e0afbd7.png"><br>  Writing data from resources to a new file: <br><img src="https://habrastorage.org/files/625/bd8/e4b/625bd8e4b75846289c6103344bf76565.png"><br>  From the archive created in% Temp% .cab, the .rtf file is extracted with the file name, as in the case of the executable module, after which it is launched for display to the user: <br><img src="https://habrastorage.org/files/108/aa6/7de/108aa67def06418d9e660ce468782c7f.png"><br><br><h2>  Antiheuristics? </h2><br>  After unpacking and launching .rtf, we note a relatively pleasant discovery - this procedure: <br><img src="https://habrastorage.org/files/b96/582/f46/b96582f46b574240864925dbe056dc4a.png"><br>  The call is at offset <b>0x00401D04</b> . <br>  At the very beginning, GetTickCount returns the number of milliseconds since the system was started, after which there is a cycle with Sleep and the second GetTickCount request.  Further, the first is subtracted from the last result, and the resulting delta is compared with the constant <b>0x668A0</b> .  We translate the constant to decimal, we get 420000, or 7 minutes.  Why is the discovery pleasant?  Yes, because after opening .rtf, you can simply complete the process within 7 minutes and forget about the CTB-Locker (although, probably, someone who suspects the process of suspicious actions and complete it will not even launch an unknown attachment).  Perhaps this is a time-attack on the heuristics of some antiviruses. <br>  For reversing, this is not a particularly pleasant moment, since  I don‚Äôt really want to wait for 7 minutes every time I have to restart the process.  Therefore, we change the constant for 1 second and forget about this timer, like this: <br><img src="https://habrastorage.org/files/979/4b4/5af/9794b45af51b4966a67f172fb6c6e713.png"><br><br><h2>  JPG download </h2><br>  Came to the fragment that loads from the network the .jpg mentioned at the very beginning.  There is a loop that randomly selects a pointer to an encrypted string variable (URL), decrypts the procedure parsed above, passes the URL to the download procedure (we will not parse it, nothing interesting - the standard formation of a request to the web server), again encrypts the URL with the same procedure.  After the described actions, the response from the web server is transmitted to the procedure <b>0x00402019</b> , at the very beginning of which, by the amount of received data, it is determined whether the file or an empty response was received from the server, after which it is decided to continue the search cycle of the URL or decrypt the received file. <br><img src="https://habrastorage.org/files/729/87f/8ab/72987f8abd384bdaa3e2bd7a9c88451b.png"><br>  The first request always goes to ‚Äúsintjoep.nl/images/efax.jpg‚Äù, and the response from the server is not checked at all, and the cycle for searching the remaining URLs immediately begins.  It is not clear why ... <br>  How to calculate all the resources from which fake .jpg can load?  After all, after each request, the URL is encrypted again, and if the download is successful, the loop from the resource search cycle occurs ... Minor manipulations with the code and BP at key points: <br><img src="https://habrastorage.org/files/7ae/e0e/112/7aee0e11275f4e7cab212816376f373e.png"><br>  Here we are overwritten by the NOPs (No OPeration) of the URL reverse encryption procedure.  Do not forget about the exit from the loop iteration.  There, too, we will block the conditional transition after checking the response from the server, which will lead to an infinite loop: <br><img src="https://habrastorage.org/files/ccc/75c/10f/ccc75c10f79241dca2057588f0933fce.png"><br>  As a result, this is what was achieved: <br><img src="https://habrastorage.org/files/d78/809/3bf/d788093bf4de458db7a51df6d6a824c0.png"><br>  So, as the URL is randomly selected in the cycle, then the chance that the first time all the lines are decrypted is in order somehow not enough ... As you can see in the screenshot, one URL was not deciphered during rather long attempts at searching.  "Korean random!" Nah, so not interesting ... There is the procedure <b>0x00401FF3</b> , which generates this random, but why listen to it?  After all, you can immediately transfer to the required string and its size in the ‚Äúhands‚Äù decoding procedure!  (why it didn‚Äôt immediately come to mind ...) <br>  Pointers to encrypted strings and their sizes were saved immediately after the process started, beyond EntryPoint (it was not clear then).  Now, above, in the screenshot of the stack are visible pointers to the URL, and under each of them is the size of the string.  So we look - the pointer to the remaining encrypted URL is at offset <b>0x00401708</b> , and the size of the string is 0x24 (36 bytes).  We take into account that the size is specified for ASCII, and we have UNICODE, therefore we multiply by 2 and get 0x48 (72 bytes).  We change the values ‚Äã‚Äãof the EDI registers (pointer to string) and ESI (string size in bytes) for the calculated values ‚Äã‚Äãand transfer control to the decryption procedure.  We get a profit - all the resources from which this sample Downloader can load CTB-Locker: <br><img src="https://habrastorage.org/files/c3b/b40/a41/c3bb40a41a924b5bb1147cb81fc18a91.png"><br>  All these are absolutely normal sites, pre-hacked to use them as a springboard for the spread of malware.  These resources are valid only for this sample Downloader'a.  Another copy of Trojan-Downloader.Win32.Cabby came into my hands.  <b>cfeu</b> (according to KAV classification), there are other URLs in it.  His activity was noticed a couple of days after catching and the appearance of signatures at first. <br>  Someone will say that it is easier and faster to remove the track with a packet analyzer and analyze DNS queries - and it will be right.  But the purpose of the article is not in simplicity, but in knowledge. <br><br><h2>  JPG decryption </h2><br>  So, got malicious .jpg: <br><img src="https://habrastorage.org/files/72d/666/2e0/72d6662e077041dc9581e3fdbeb9eb80.png"><br>  Then we get into the decryption procedure.  At the very beginning of the file, four bytes at offset 0x4 is the size of the encrypted data, which starts at offset 0x8 and will be decoded: <br><img src="https://habrastorage.org/files/6d3/586/e5d/6d3586e5d6ca442e9f1becca40412d4c.png"><br>  The decryption procedure itself is similar to the one that worked with strings ‚Äî the same key, the same logic ‚Äî so there is no sense in disassembling it.  By the way, the 16 byte key itself: "CA 95 02 43 17 46 67 E4 FF 6E 8E D1 4E 7A BE 86". <br>  After decryption we get the expected result: <br><img src="https://habrastorage.org/files/474/b62/b75/474b62b75fd14443af38ed4d2fab2a41.png"><br><br><h2>  Surprise </h2><br>  As it turned out, the received and decrypted .jpg is not just an executable file, but a container with executable files.  As mentioned above, four bytes at offset 0x4 is the size of all data in the container.  Next come the payloads, in front of each of which are four bytes - the size of the payload.  In our case, the container was not only a CTB-Locker ... <br>  After decryption, the offset of the first payload and its size is offset by the second, which is transferred to a fairly large procedure <b>0x00402AC9</b> .  I will not describe it, because  this can stretch out for another article.  In essence, this is a self-written PE Loader, which projects the DLL from its decrypted container into its process and transfers control to the Grab_Psw function.  As you can already guess from the name of the exported function, this DLL is nothing more than a Password Stealer, stealing credentials from various applications.  The range of applications is quite wide. <br>  Passwords go through HTTP POST in the same encrypted JPG.  Here is an example: <br><img src="https://habrastorage.org/files/d10/b2e/dec/d10b2edec97d4ff19ba8f460b78f0b3e.png"><br>  At the time of analysis on all target resources, the host 3858850926.php has already been deleted.  And then bad luck - the malware died in an endless cycle of searching for resources to send stolen credentials. <br>  Hmm ... but this is not the end, the files were encrypted to users. <br>  After each attempt, the response from the server is checked for the presence of the string ‚ÄúConfirmed‚Äù using the SHLWAPI.StrStrA API: <br><img src="https://habrastorage.org/files/2a9/937/037/2a99370379cd42029b768fc5da5df3dc.png"><br>  The conditional transition is performed on the result returned by SHLWAPI.StrStrA: <br><img src="https://habrastorage.org/files/a5c/0c1/71b/a5c0c171b10a48c387bb8cec0382d5b2.png"><br>  Well, let's make JNZ out of it: <br><img src="https://habrastorage.org/files/bc0/eca/0fb/bc0eca0fb7ad405c9efea56f066d25c9.png"><br>  Thereby they deceived the application, letting it know that the passwords were successfully sent - you can continue. <br><br><h2>  CTB-Locker </h2><br>  Immediately after the malware ‚Äúsent‚Äù stolen credentials to the server, a transition occurs to the procedure <b>0x004028CC</b> , which creates a new .exe file with a random name in the% Temp% directory.  After that, it writes the first payload from the decrypted container (JPG, which was taken earlier), maintains timeout before launching, launches the created .exe, again maintains timeout and deletes the file. <br><img src="https://habrastorage.org/files/f84/afa/f1c/f84afaf1c063432f99e12b4b5545d262.png"><br>  The downloader process then terminates. <br>  We get the file from% Temp% before launch for execution and send it to Virustotal.  Expected Verdict: <br><img src="https://habrastorage.org/files/082/e6b/9ef/082e6b9efab344409da48d9c045bfa69.png"><br>  <b>Link to <a href="https://www.virustotal.com/ru/file/311633b8f946f97a7a15e5a562eab350bb79807dd7b02d3be243ff6e021f53c9/analysis/1431312950/">report</a> .</b> <br><br><h2>  Conclusion </h2><br>  General Downloader script: <br><ol><li>  Extracts from the .rtf resource section and opens it to deceive the user; </li><li>  After 7 minutes, download the encrypted container under the guise of .jpg; </li><li>  Decrypts the container and projects the DLL from it into its own memory using the self-written PE Loader; </li><li>  Calls the ‚ÄúGrab_Psw‚Äù function from the DLL, which steals credentials from various applications; </li><li>  Sends stolen credentials in an encrypted container disguised as a .jpg file to the Internet; </li><li>  Extracts the CTB-Locker container received in section 2 to the% Temp% directory and launches it. </li></ol><br>  The analysis revealed that the CTB-Locker is not the only threat that this sample brings with it Trojan-Downloader.Win32.Cabby.cemx.  Together with the cryptographer, the network leaks the credentials of a wide range of applications that the attackers do not warn anyone about, asking them to pay for the decryption of user data. </div><p>Source: <a href="https://habr.com/ru/post/257681/">https://habr.com/ru/post/257681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257671/index.html">Deploy web application with Fabric</a></li>
<li><a href="../257673/index.html">How 3CX solves security problems (part 2)</a></li>
<li><a href="../257675/index.html">Laboratory penetration testing "Test lab v.7" eyes hackers</a></li>
<li><a href="../257677/index.html">Low Blood Application Architecture</a></li>
<li><a href="../257679/index.html">Analysis of CPL malware, part 1</a></li>
<li><a href="../257683/index.html">Likbez - how to become a programmer</a></li>
<li><a href="../257685/index.html">Product design digest, April 2015</a></li>
<li><a href="../257687/index.html">Write on Rust - run everywhere. Rust and C interaction</a></li>
<li><a href="../257689/index.html">Practical experience with little-known European cloud hosting</a></li>
<li><a href="../257691/index.html">PHP Digest number 62 - interesting news, materials and tools (April 26 - May 11, 2015)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>