<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Micro course on programming SCADAPack controllers in C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√©, there are frankly few articles about automated process control systems. Moreover, I suspect that programming in the industry of industrial a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Micro course on programming SCADAPack controllers in C</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/kx/-h/fr/kx-hfr0mbd1gfq40t2a4rxgud2k.jpeg" alt="image"><br><br>  On Habr√©, there are frankly few articles about automated process control systems.  Moreover, I suspect that programming in the industry of industrial automation for the majority of habrovchan is a kind of magical dark forest with strange legends and creatures.  And here I wanted to conduct a small tour of this forest for educational purposes, but we will not be limited to educational purposes, and we will try to make this material useful for people just starting their way in an automated process control system, or having first encountered the type of controllers in question. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/mz/xn/l3/mzxnl3dyg6zvqp0xmr8w4n2fe4k.jpeg" alt="image"><br><br><img src="https://habrastorage.org/webt/qt/a2/zd/qta2zdxnvacpxghp06jr5czb7pu.jpeg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, get acquainted.  This is a programmable logic controller (PLC) called SCADAPack by Schneider Electric (formerly Control Microsystems). <br><blockquote>  Programmable logic controller (abbr. PLC; English programmable logic controller, abbr. PLC; more accurate translation into Russian - controller with programmable logic), programmable controller - an industrial controller used to automate technological processes.  The main mode of operation of the PLC is its long-term autonomous use, often in adverse environmental conditions, without serious maintenance and with little or no human intervention.  [Wikipedia] </blockquote><br>  These PLCs have earned fame for their reliability and rich programming possibilities.  Inside the controller, depending on the series, there is an ARM processor running the VxWorks operating system. <br><br>  In industrial automation, the generally accepted standard is the languages ‚Äã‚Äãof IEC, such as LD / LAD, FDB and ST.  The first of them is nothing more than schemes similar to ladder logic circuits.  The second is nothing more than circuits that are similar to circuits with logic elements and electronic components (timers, counters, etc.).  The third is a textual language, evoking memories of Pascal.  But today we will not talk about them (anyone can always google it), but about developing for these controllers in C, which is, firstly, much closer to ‚Äúsimple programmers‚Äù, and secondly, it saves if necessary to program complex mathematical calculations or implement non-standard communication protocols . <br><br>  To compile, we will need a compiler, header files, and a standard controller library.  All this can be found on the manufacturer's website under the name <a href="https://www.schneider-electric.com/en/download/document/SCADAPack%2B300%2Band%2B4203%2BC%25252B%25252B%2Btools%2B1.73/">C Tools</a> , and the <a href="https://www.plcsystems.ru/catalog/SCADAPack/doc/SCADAPack_300_4203_C%2B%2B_Tools_User_Manual.pdf">description of the API</a> is there. <br>  Development begins with writing a Makefile (a script to build a project from source to a binary file).  An example makefile can be found in the C Tools directory: <br> <code>C:\Program Files\Control Microsystems\CTools\Controller\Framework Applications\TelePACE</code> <br>  There is also an example of main.cpp and the appstart.cpp file (it is also required for assembly). <br> <code>Ctools.h   C:\Program Files\Control Microsystems\CTools\Controller\TelePACE</code> <br> <br>  Pay attention to it stands on 3 things: <br> <code>objects = appstart.o main.o</code> <br>  This line specifies which files to compile to build the firmware.  If your project is divided (as it should be) into .c- or .cpp-files with headers (.h- or .hpp-files), then they should be listed in this section.  If you forget something, the compiler will remind you of the Undefined reference error. <br><br> <code>CTOOLS_PATH = C:\Program Files\Control Microsystems\CTools</code> <br>  This is the way to ctools.  Score if you have it different. <br><br> <code>TARGET = SCADAPack350</code> <br>  This line defines for which family of controllers we compile the firmware.  Possible options: <br> <code>SCADAPack350 (  357,  ..), SCADAPack33x, 4203</code> <br> <br>  The firmware is <code>make</code> using the command line command <code>make</code> . <br>  If a message is displayed that you could not find this command, check that the path to the C-Tools libraries is registered in your PATH system variable: <br> <code>C:\Program Files\Control Microsystems\CTools\Arm7\host\x86-win32\bin</code> <br> <br><h2>  Simple application </h2><br>  To compile a simple (and empty) firmware, we will need a <code>Makefile</code> , the appstart.cpp and main.cpp files. <br><br>  Their examples can be found in the same C Tools directory that was mentioned above.  Appstart.cpp is responsible for initializing the hardware and the runtime, and in main.cpp we can write the code we need. <br><br>  The general structure of the C program for SP looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctools.h&gt; #include "nvMemory.h" int main(void) { //    -  , ,  ,  ,  .. while (TRUE) { //        release_processor(); } }</span></span></span></span></code> </pre><br>  The call to release_processor () is necessary in each cycle, because in addition to our program, the controller's OS also performs other utility processes (port and protocol handlers, runtime, etc.).  Without calling this function, for example, after starting the program it will be impossible to stop it or reflash the controller. <br><br>  C Tools‚Äôs coding style, alas, leaves much to be desired: there are different styles of function naming (process_io () and release_processor (), but ioReadDin16 () and addRegAssignment (), and also getclock () / setclock ()), in some similar functions with the same arguments, these very arguments are reversed; in short, be careful. <br><br>  From the general tips for developing reliable embedded systems: try to write as simple and clear code as possible, stick to the chosen coding standard, be careful with type conversions, better avoid dynamic memory allocation and pointer arithmetic without much need. <br><br>  As a basis for the rules, you can take the individual items of the MISRA standards (development standard for embedded software for cars) or JSF (for aviation). <br><br><h2>  Download the program to the controller </h2><br>  For this we need TelePACE.  It is possible to connect to the controller via RS232 / 485, via Ethernet and even via USB (if the used scadapack model has it). <br><br><img src="https://habrastorage.org/webt/7j/a9/wn/7ja9wnkfm8p3rwourfpwr3ldkry.png" alt="image"><br><br>  The principle is about the same: <br><br><ol><li>  Select the desired protocol in the Protocol field (Modbus RTU, Modbus TCP or Modbus USB) </li><li>  Click Configure Settings and set all the necessary data (RTU address, port speed for RS232 / 485 or IP address for TCP) </li><li>  Click Connect and make sure that you are connected to the controller. </li><li>  On the Initialize tab, you can reset the controller to its original appearance ‚Äî delete all programs, LAD projects, port settings, and register assignments. </li><li>  On the C / C ++ tab, you can see how the program is loaded into the controller, stop / start it, load a new one (examine the buttons at the top of the tab!). </li></ol><br>  On the web, there was a very helpful video showing the process: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/93e_qxt6__g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Work with timers </h2><br>  Let's start with the simplest program - Hello World, namely, we blink the LED on the controller :) <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctools.h&gt; #include "nvMemory.h" //  ID  .      10,    primitiv.h #define TIMER1EVENT 10 int main(void) { int led_state = 0; //  ,    1   1  (  0.1 ) startTimedEvent(TIMER1EVENT,10); while (TRUE) { // ,    if (poll_event(TIMER1EVENT)) { if (led_state == 0) ledPower(LED_ON); else ledPower(LED_OFF); led_state = led_state ^ 1; } release_processor(); } }</span></span></span></span></code> </pre><br><h2>  Working with modbus registers </h2><br><blockquote>  Modbus is an open communication protocol based on the master-slave architecture.  It is widely used in industry for organizing communication between electronic devices.  It can be used for data transmission through serial communication lines RS-485, RS-422, RS-232, and TCP / IP networks (Modbus TCP).  There are also non-standard implementations using UDP.  The main advantages of the standard are openness and mass character.  The industry now produces a lot of types and models of sensors, actuators, modules for processing and normalizing signals, etc. Almost all industrial control and management systems have software drivers for working with MODBUS networks.  [Wikipedia] </blockquote><br>  In SCADAPack, working with Modbus is implemented beautifully and conveniently. <br><br>  The modbus registers memory of the controller is non-volatile, and is not lost even after a reboot or power failure.  On the one hand, this is a bit inconvenient (do not forget to clear or initialize the registers at the start, if necessary), but on the other hand, it allows you to store settings, setpoints, and even small archives in the address space of the modbus. <br><br>  In addition, the results of the execution of various commands (reading the status of discrete and analog inputs, polling external devices, etc.) are placed in the modbus registers. <br><br>  The modbus handler in the skadapas is implemented at the operating system level, and therefore after starting the program, on all COM ports (and on Ethernet) we can immediately interrogate the controller on the modbass (we will discuss port configuration later).  Moreover, the controller will respond to modbus requests even if the program is stopped. <br><br>  Writing and reading modbus registers is performed by dbase () and setdbase () functions, for example, like this: <br><br><pre> <code class="cpp hljs">request_resource(IO_SYSTEM); a = dbase(MODBUS, <span class="hljs-number"><span class="hljs-number">30001</span></span>); b = dbase(MODBUS, <span class="hljs-number"><span class="hljs-number">30002</span></span>); setdbase(MODBUS, <span class="hljs-number"><span class="hljs-number">40020</span></span>, a * b); release_resource(IO_SYSTEM);</code> </pre><br>  This example reads two numbers from the registers 0001 and 0002 of the Inputs zone and stores the result of their multiplication in register 0020 of the Holding zone.  It's simple. <br><br><h2>  Work with I / O signals </h2><br>  Work modules input and output can take place in three ways: <br><br><h3>  First way </h3><br>  The first option is to create a ‚Äúregister assignment‚Äù.  The state (discrete and analog values) of the input channels of the DIN and AIN modules will be automatically ‚Äúdisplayed‚Äù in the modbus registers, and vice versa, for the DOUT and AOUT modules, the state of the outputs will be determined by the values ‚Äã‚Äãrecorded in the registers.  To do this, use the clearRegAssignmnet (clear all old assignments) and addRegAssignment (create new) functions. <br><br>  The first function addRegAssignment is the module type (a list of constants can be found in the TelePACE documentation and in the header files, can be DIN_5401, DIN_5404, AIN_5301 and others), the second is the module address (it is usually set with a jumper on the module itself, and if built-in SP inputs, then 0), and then go the addresses of registers, starting with which the recording should be made (if the module provides data of different types, then there will be several groups of registers - coils, status, inputs, etc.) <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   IO_SYSTEM //         -  modbus- request_resource(IO_SYSTEM); //   assignments    clearRegAssignment(); //   IO    5601    10001    30001   //   DOUT      1 (00001) addRegAssignment(SCADAPack_lowerIO, 0, 1, 10001, 30001, 0); //   , SCADAPack_upperIO -     (  ) //     5604: //    ,     AOUT,     40001   // addRegAssignment(SCADAPack_5604IO, 0, 1, 10001, 30001, 40001 ); //     AOUT ( 1): //      ,   modbus   40001 addRegAssignment(SCADAPack_AOUT, 1, 40001, 0, 0, 0); //     IO_SYSTEM release_resource(IO_SYSTEM);</span></span></code> </pre><br>  It should be borne in mind that if you forcefully stop the runtime environment (runTarget (FALSE)), they will not work, but if you did not make changes to the standard appstart.c file for optimization purposes, then there is nothing to worry about. <br><br>  Do not forget to perform clearRegAssignment ();  when you start the program, even if you do not use them - who knows who did what on this controller to you. <br><br>  If you don‚Äôt know exactly which I / O board will be on the controller where your firmware will be running, you can use the solution proposed by the experts from <a href="http://ozna.forum24.ru/%3F1-11-0-00000001-000-0-0">OZNA</a> . <br><br><h3>  Second way </h3><br>  Call explicitly read functions that store data in the specified modbus registers. <br>  These can be functions ioRead8Din, ioRead8Ain, ioRead16Din, ioRead16Ain, ioRead5604Inputs, ioWrite16Dout, ioWrite5604Outputs, ioRead4Counter (for counting inputs), ioReadSP2 (for embedded inputs, for example, for read inputs, ioRead4Counter (for counting inputs), ioReadSP2 (for built-in inputs, for example, for read inputs, for ioRead4Counter, for counting inputs), ioReadSP2 (for embedded inputs, for example inputs, for learning inputs, for learning inputs, for learning inputs for learning inputs for learning inputs, for learning)  Details and syntax of these commands can be found in the documentation for C Tools, usually the first argument is the module address (0 for embedded inputs), and the second and further are modbus register addresses from which the values ‚Äã‚Äãof the signals should be saved (or where they should be taken for recording on weekends). <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   5607 (0, ..    ) int Module5607Addr = 0; //   IO_SYSTEM request_resource(IO_SYSTEM); //      ioRequest(MT_5607Inputs, Module5607Addr); ioRequest(MT_SP2Inputs, 0); //     //      ,    ( wait_event  poll_event) ioNotification(IO_COMPLETE); wait_event(IO_COMPLETE); //     5607,   ‚Äì    10001,  ‚Äì    30001 ioRead5607Inputs(Module5607Addr, 10001, 30001); //      ,   ‚Äì    10101,  ‚Äì    30101 ioReadSP2Inputs(10101,30101); //   IO_SYSTEM release_resource(IO_SYSTEM);</span></span></code> </pre><br>  Calling ioWrite * functions will similarly set the required values ‚Äã‚Äãfrom modbus registers to the output channels of the controller and modules. <br><br><h3>  Third way </h3><br>  The same, but with the preservation of the results not in the modbus registers, but in variables or an array.  Functions are called the same, but have an overloaded implementation with different arguments. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Module5607Addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   IO_SYSTEM,        - request_resource(IO_SYSTEM); // ,           5607 UCHAR DIData [3]; // ,           5607 INT16 AIData [8]; //          UCHAR DIData2 [2]; //          INT16 AIData2 [8]; //    ioRequest(MT_5607Inputs, Module5607Addr); ioRequest(MT_SP2Inputs, 0); //     //      ,    ( wait_event  poll_event) ioNotification(IO_COMPLETE); wait_event(IO_COMPLETE); //       ioRead5607Inputs(Module5607Addr,DIData,AIData); ioReadSP2Inputs(DIData2,AIData2); release_resource(IO_SYSTEM);</span></span></code> </pre><br>  Something similar can be done with the data we want to write to the output channels (for example, to close the relay output): <br><br><pre> <code class="cpp hljs">UINT16 InputType[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) InputType[i] = <span class="hljs-number"><span class="hljs-number">3</span></span>; UINT16 InputFilter = <span class="hljs-number"><span class="hljs-number">3</span></span>; UINT16 ScanFrequency = <span class="hljs-number"><span class="hljs-number">0</span></span>; UINT16 OutputType = <span class="hljs-number"><span class="hljs-number">1</span></span>; UINT16 Mask2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; ioWrite5607Outputs(Module5607Addr,DOData,AOData,InputType,InputFilter,ScanFrequency,OutputType); ioRequest(MT_5607Outputs, Module5607Addr);</code> </pre><br>  Specific functions and constants for reading and writing data to the modules used must be viewed in the documentation and in the C Tools header files.  For example, the functions for the 5607 module, as you can see above, have additional options for setting the input type, filter parameters, etc.  They are also described in the documentation. <br><br>  There are also functions for obtaining the current temperature of the controller and battery voltage - readThermistor (T_CELSIUS), readBattery ().  Trifle, but useful. <br><br><h2>  AI scaling </h2><br>  The analog input channels of the controller modules can operate in different modes (for example, with input ranges of 0‚Äì20 or 4‚Äì20 mA, this is determined by jumpers on the module).  They give out the data in ADC units, and converting them to the scale we need (for example, 4-20 mA will correspond to 0-100%) is quite simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,        AI,     #define AIWaterLevelReg 30001 float WaterLevelScaled = ((float)dbase(MODBUS, AIWaterLevelReg) - 6554) / 26214 * 100; //   4-20  //  float WaterLevelScaled = (float)dbase(MODBUS, AIWaterLevelReg) / 32767 * 100; //   0-20 </span></span></code> </pre><br>  Naturally, instead of 100 you can multiply the number by the upper limit of the scale you need. <br><br><h2>  Configuring RS-232 / RS-485 Ports </h2><br>  Here, again, no magic: <br><br><pre> <code class="cpp hljs">PROTOCOL_SETTINGS comsettings; pconfig portSettings; <span class="hljs-comment"><span class="hljs-comment">//     COM2,    getProtocolSettings(com2, &amp;comsettings); // modbus-,         comsettings.station = 1; comsettings.type = MODBUS_RTU; comsettings.mode = AM_standard; get_port(com2,&amp;portSettings); //  , 38400 portSettings.baud = BAUD38400; portSettings.duplex = HALF; portSettings.parity = PARITY_NONE; portSettings.data_bits = DATA8; portSettings.stop_bits = STOP1; portSettings.flow_tx = TFC_NONE; portSettings.flow_rx = RFC_MODBUS_RTU; portSettings.type = RS232; setProtocolSettings(com2, &amp;comsettings); set_port(com2,&amp;portSettings);</span></span></code> </pre> <br>  Port settings are saved in the EEPROM, however, depending on the controller configuration, library versions, etc., it is possible to read, for example, from the same modbus registers to a specific event (command, jumper closure, etc.) to automatically reconfigure and update them. <br><br><h2>  Modbus Device Polling </h2><br>  If you want not only to work as a slave device, but also to poll other controllers or sensors yourself, there are functions of the master_message () type that allow you to poll external devices on the modbase, and save the results to your registers, from where they can be read and used in the algorithm (or just provide the top level).  There are examples in the documentation, just consider two nuances: you must check the result of the function execution with the command get_protocol_status () before sending a second request or working with the received data, and the second thing: you must either disable the modbus handler on the port you are using, or monitor so that its address does not coincide with the address of the polled device (otherwise you can get undefined behavior or strange errors). <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">master_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE * stream, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> function, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> slave_station, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> slave_address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> master_address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span></span>;</code> </pre> <br>  stream - the port through which data will be exchanged (for example, com1), function is the modbus function number for the request (for example, 3), slave_station is the RTU address of the polled device, slave_address is the starting address of the registers in the remote device that we want to read, master_address - the starting address of the registers on our controller, where the data will be written, length - the number of registers to read). <br><br>  Example: <br><br><pre> <code class="cpp hljs">request_resource(IO_SYSTEM); <span class="hljs-comment"><span class="hljs-comment">//   com2 3- modbus- ( Holding )     1    0001 (40001) 17 ,    513   master_message(com2, 3, 1, 40001, 40513, 17); //      struct prot_status polling_status; polling_status = get_protocol_status( com2); if (polling_status.command == MM_SENT) { //   ,     . //      ,   ,         } else if (polling_status.command == MM_RECEIVED) { //  ,     ! //          } else { // -   .         } release_resource(IO_SYSTEM);</span></span></code> </pre><br><br>  You can also install your Modbus handler (installModbusHandler ()) to implement any protocol extensions. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The system keeps statistics of the exchange (accepted / sent, number of errors, etc.), which can also be read from the relevant structures. </font></font><br><br><h3>  Communications </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also install your own data handler that came through COM ports (install_handle ()) to implement some non-standard protocols. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TCP / IP is fine too. </font><font style="vertical-align: inherit;">Standard BSD Sockets functions are available: bind (), getsockopt (), etc. </font><font style="vertical-align: inherit;">Network settings on the controller can be programmatically read and written (ethernetGetIP (), ethernetSetIP ()).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintaining archives </font></font></h2><br>   SCADAPack      DataLog   C Tools, ,  ,    ,      ,           .         , ,    Holding   Inputs (     , )   ,      . <br><br>    ,         POSIX-,             (    USB Flash-),           ,       . <br><br>         -: <br><br><pre> <code class="cpp hljs">FILE *mdata; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* file_mdata = <span class="hljs-string"><span class="hljs-string">"/d0/logs.dat"</span></span>; mdata = fopen(file_mdata, <span class="hljs-string"><span class="hljs-string">"w"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">fputs</span></span>(<span class="hljs-string"><span class="hljs-string">"test log string"</span></span>, mdata); fclose(mdata);</code> </pre><br>        (  ‚Äî   )    ,                  modbus-,     () modbus-  . <br><br><img src="https://habrastorage.org/webt/6s/m_/y8/6sm_y8tlrh0cuo6bsggdbuyzjiq.jpeg" alt="image"><br><br>   /d0/   ,  /bd0/ ‚Äî  USB- .  ,                 ,    . <br><br>  TelePACE     ,        . <br><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I have already noted, in the non-volatile memory, first of all, the data of the Modbus registers are stored, that is, the values ‚Äã‚Äãstored in them will be available even after the controller is rebooted.</font></font><br>  ,    s_nvMemory,    nvMemory.h,    8 ,        (  )    ,             .   ,    allocateMemory()         1      , ,  ..      ‚Äî              s_nvMemory,     ,       ,   (freeMemory()).             DYNAMIC_MEMORY. <br><br><h2>    </h2><br>       ,           ( createTask(), getTaskInfo()  ..),              (  'envelopes'). <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multitasking is cooperative, that is, switching between tasks and programs is not performed by the operating system, but alternately when they themselves are ready to transfer the execution further or when certain events occur. </font><font style="vertical-align: inherit;">On the one hand, this solves the problem of the atomicity of operations when sharing data, and on the other hand, one should not forget to call release_processor () and not to seize resources for too long. </font><font style="vertical-align: inherit;">An example of a multitasking program and state change graphs when events occur are described in the documentation in the chapters "RTOS Example Application Program" and "Explanation of Task Execution".</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic memory </font></font></h2><br> malloc()  free()  ,   new  delete.     ‚Äî    (,   Stop),     :        (installExitHandler)        . <br><br><h2>      </h2><br>         . <br>         getclock  setclock,     . <br><br><h2>    </h2><br> ,       - 5604,   AI 2       ,   DO1    . <br><br>        (    SCADA    HMI),         ,  ,      . <br><br>   0020  Holding (40020)         SCADA  HMI-. <br><br>         ¬´¬ª    ,      . <br><br>       COM2. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctools.h&gt; #include "nvMemory.h" /** * @brief      5604    modbus- */ void initialize_io() { request_resource(IO_SYSTEM); clearRegAssignment(); addRegAssignment(SCADAPack_5604IO, 0, 1, 10001, 30001, 40001); release_resource(IO_SYSTEM); } /** * @brief   COM2    Modbus Slave,  = 1,  = 9600 */ void initialize_ports() { request_resource(IO_SYSTEM); PROTOCOL_SETTINGS comsettings; pconfig portSettings; getProtocolSettings(com2, &amp;comsettings); comsettings.station = 1; comsettings.type = MODBUS_RTU; comsettings.mode = AM_standard; get_port(com2,&amp;portSettings); portSettings.baud = BAUD9600; portSettings.duplex = HALF; portSettings.parity = PARITY_NONE; portSettings.data_bits = DATA8; portSettings.stop_bits = STOP1; portSettings.flow_tx = TFC_NONE; portSettings.flow_rx = RFC_MODBUS_RTU; portSettings.type = RS232; setProtocolSettings(com2, &amp;comsettings); set_port(com2,&amp;portSettings); request_resource(IO_SYSTEM); } /** * @brief   AI- * @param ai_value ""  AI    * @param max    AI (   ) * @return      */ float scale_ain(int ai_value, float max) { return ((float)ai_value - 6554) / 26214 * max; } /* .          #include */ #define AILevelReg 30002 // ,      AI    (2-  AI) #define LevelScaledReg 40020 // ,           #define PumpLevelTriggerReg 40050 // ,    SCADA          ( ) #define PumpOutReg 1 //   DO,        (1-  DO) #define LevelHyst 50 //     .   ,     #define MaxLevelMeters 500 //      (   ),   int main(void) { //   COM initialize_ports(); //      - initialize_io(); while (TRUE) { request_resource(IO_SYSTEM); //   AI  ,          int level_raw = dbase(MODBUS, AILevelReg); float level_scaled = scale_ain(level_raw, MaxLevelMeters); setdbase(MODBUS, LevelScaledReg, (int)level_scaled); //    ,   if (level_scaled &gt; (dbase(MODBUS, PumpLevelTriggerReg) + LevelHyst)) setdbase(MODBUS, PumpOutReg, 1); else //     -  if (level_scaled &lt; (dbase(MODBUS, PumpLevelTriggerReg) - LevelHyst)) setdbase(MODBUS, PumpOutReg, 0); release_resource(IO_SYSTEM); release_processor(); } }</span></span></span></span></code> </pre><br><h2> , ,   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A description of all functions and examples of their use are in the documentation for C Tools. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is very good to have complete knowledge of C (for example, when implementing algorithms, this concerns type conversion) in order to write code beautifully and without errors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Learn, experiment, and succeed! </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many thanks to Denis for help in preparing the material and valuable comments :)</font></font></i> </div><p>Source: <a href="https://habr.com/ru/post/350282/">https://habr.com/ru/post/350282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350272/index.html">FastTrack Training. "Network Basics". "Switches from Cisco". Eddie Martin December 2012</a></li>
<li><a href="../350274/index.html">Developing a game on SVG + React. Part 1</a></li>
<li><a href="../350276/index.html">Splunk + Excel. What happens?</a></li>
<li><a href="../350278/index.html">React + SVG game development. Part 2</a></li>
<li><a href="../350280/index.html">Existention of the railway in the auto parts market</a></li>
<li><a href="../350286/index.html">Mathematical package for Android ‚ÄúMicro-Mathematics‚Äù: what's new?</a></li>
<li><a href="../350288/index.html">Basics of information security of a virtual server. Part 4: Standards and Specifications</a></li>
<li><a href="../350290/index.html">The creator of Vue.js is responsible Habra</a></li>
<li><a href="../350292/index.html">Writing a component - a table, not in the usual way.</a></li>
<li><a href="../350294/index.html">Automate CleanTalk Anti-Spam Updates for WordPress</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>