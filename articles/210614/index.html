<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generating trees on HTML5 Canvas</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello Habr! 
 Today I want to talk about generating trees on HTML5 Canvas using JavaScript. Immediately I will explain that this is not about referenc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generating trees on HTML5 Canvas</h1><div class="post__text post__text-html js-mediator-article">  Hello Habr! <br>  Today I want to talk about generating trees on HTML5 Canvas using JavaScript.  Immediately I will explain that this is not about reference trees or B-trees, but about those trees that we see every day outside our window, those that make our air cleaner and richer in oxygen, those that turn yellow in autumn and lose their leaves in winter , in general, about those very living, forest, real trees, only painted on Canvas and will be discussed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/501/72d/063/50172d063297b4d5b1b0d15188b9a269.png"><br>  <i>Such trees are obtained</i> <br><br>  Tree generation was needed for my game.  But I could not find any adequate algorithms.  So I wrote my generator ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  <a href="https://habr.com/ru/post/210614/">I do not want to read anything, I want the result immediately!</a> <br><h4>  And so, what under a soot? </h4><br>  Everything works the notorious Bezier curves, thanks to them the trunk and branches are rounded and seem alive.  I tried many ways, it was the use of curves that turned out to be the most productive and simplest.  They are easy to build, it is easy to get the right direction from them, and you can also calculate their trajectory programmatically. <br><br>  The structure of the generator is as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1b/848/50a/d1b84850a0acc8867ef01b6f14103464.png"><br><br>  The TreeGenerator class (in the Generator diagram) uses the Branch class object to generate branches and the trunk, and TreeGenerator calls the Drawer method to generate leaves.  Branch is an abstraction providing each branch as an object.  He also uses Drawer for drawing. <br><br><h4>  Step 1. Generate the branch </h4><br>  The Drawer class is a layer between the canvas API and Branch.  This class performs the drawing of leaves and branches according to specified parameters. <br>  And here is the function for drawing a branch from Drawer: <br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//x  y -   , leng -  , w - , deform -  , rotate -  DrawStick = function(x, y, leng, w, deform, rotate) { // canvas   . this.c.save(); this.c.translate(x, y); this.c.rotate(rotate.degree()); // degree     // x  y  . x = 0; y = w / -2; //       this.c.beginPath(); //  x  y this.c.moveTo(x, y); //        xy    (  w/BRANCH_CONSTRICTION) this.c.bezierCurveTo(x, y, x + leng / 2, y + deform, x + leng, y + (w - (w / BRANCH_CONSTRICTION)) / 2); //     this.c.lineTo(x + leng, y + w / BRANCH_CONSTRICTION + (w - (w / BRANCH_CONSTRICTION)) / 2); //     this.c.bezierCurveTo(x + leng, y + w / BRANCH_CONSTRICTION + (w - (w / BRANCH_CONSTRICTION)) / 2, x + leng / 2, y + w + deform, x, y + w); //   this.c.lineTo(x, y); this.c.closePath(); // ,     this.c.arc(x + leng, y + w / BRANCH_CONSTRICTION / 2 + (w - (w / BRANCH_CONSTRICTION)) / 2, w / BRANCH_CONSTRICTION / 2, 0 * Math.PI, 2 * Math.PI, false); //  this.c.fillStyle = BRANCH_COLOR; this.c.fill(); // canvas this.c.restore(); }</span></span></code> </pre> <br>  From the code, you probably did not understand how the top points of the branch are defined.  As you know, a tree branch at the end is a bit narrower than at the beginning.  How much is already defined by the constant BRANCH_CONSTRICTION.  By default, it is 1.5.  BRANCH_COLOR - sets the color.  The value is selected randomly from an array of colors. <br><br>  The result of this function will be something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c5/9dd/873/6c59dd8739713b62dd6539ab3221ae58.png"><br><br>  Frankly, as long as it is not very similar to what we need.  Therefore, go further! <br><br><h4>  Step 2. Generating a tree from branches </h4><br><br>  If you have ever looked narrowly at small trees, only sprouted from seed, you might notice that they are one single branch with leaves, then other branches sprout from this branch, and it also grows and expands itself.  What is it for me?  And besides, the trunk is essentially one big branch from which other branches grow, and from these branches there are eyelids, and so on ... <br><br>  Proceeding from this, it will be more convenient for us to represent each branch, in the form of an object that will store parameters and methods and information about processes and branches.  For this, as I said, the Branch class: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Branch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, leng, width, deformation, rotate</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.params = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: x, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: y, <span class="hljs-attr"><span class="hljs-attr">leng</span></span>: leng, <span class="hljs-attr"><span class="hljs-attr">width</span></span>: width, <span class="hljs-attr"><span class="hljs-attr">deformation</span></span>: deformation, <span class="hljs-attr"><span class="hljs-attr">rotate</span></span>: rotate, }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,  ,     this.children = []; // ,   . //   canvas   this.render = function() { drawer.DrawStick(this.params.x, this.params.y, this.params.leng, this.params.width, this.params.deformation, this.params.rotate); } //       this.getEndPoints = function() { var ex = this.params.x + this.params.leng * Math.cos(this.params.rotate.degree()), ey = this.params.y + this.params.leng * Math.sin(this.params.rotate.degree()); return [ex, ey]; } // ,     this.createChild = function(leng, width, deform, rotate) { var exy = this.getEndPoints(); //  //          children this.children.push(new Branch(exy[0], exy[1], leng, width, deform, rotate)); //     this.children[this.children.length - 1].parent = this; return this.children[this.children.length - 1]; } this.render(); //    }</span></span></code> </pre><br><br>  Let's try a new class.  Let's call: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Branch(<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span>,<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">-60</span></span>,<span class="hljs-number"><span class="hljs-number">-50</span></span>).createChild(<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>/<span class="hljs-number"><span class="hljs-number">1.5</span></span>,<span class="hljs-number"><span class="hljs-number">30</span></span>,<span class="hljs-number"><span class="hljs-number">-60</span></span>);</code> </pre><br>  The result will be: <br><img src="https://habrastorage.org/getpro/habr/post_images/741/bab/5df/741bab5dfaf6ac70d5f415a088564fe8.png"><br><br>  Well, well, vaguely like a branch, right?  However, the trees all the time branch out and stretch towards the sun.  To create, we need a kind of add-on to createChild, the createDivarication function.  In nature, most often there are divisions of a branch into 2 shoots, one of which is main, it is therefore thicker, and the second thinner.  As a result of some tests and rebounds, I realized that the best ratio is 1.9: 1.4.  You can use a different attitude for your trees. <br>  And here is the createDivarication function code: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// branches -  c   [{leng:,deform:,rotate:},{}] main -    createDivarication = function(branches, main) { //   var wi = this.params.width / BRANCH_CONSTRICTION / 2; for (var i = 0; i &lt; 2; i++) { bi = branches[i]; //     branches         this.createChild(bi.leng, (i == main) ? (1.9 * wi) : wi * 1.4, bi.deform, this.params.rotate - bi.rotate //     ); } return this.children; }</span></span></code> </pre><br><br>  Here's what we got: <br><br><img src="http://habrastorage.org/storage3/1cf/7bd/660/1cf7bd660709d78bb6f22bf1679c0f84.png"><br><br>  Well, you can draw by hand, and so you can, but we need random trees.  That is what the TreeGenerator class is intended for.  Here he is in person: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> TreeGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    - branch this.genF=function(branch) { if (branch.params.width &gt; 1) { //      var divarications = [], //    dfm = BRANCH_DEFORMATION * branch.params.width / branch.params.leng; //      //    for (var di = 0; di &lt;= 2; di++) { divarications.push({ leng: rand(40, branch.params.leng), //       deform: rand(-dfm, dfm), //      rotate: (di == 0) ? (rand(-20, -10)) : (rand(10, 20)) //     }); } //    var chld = branch.createDivarication(divarications, Math.floor(rand(0, 2))); //     for (var ci = 0; ci &lt; 2; ci++) { this.genF(chld[ci]); } } else { //   ,        } } //  ,    this.genT=function(x,y){ //         var mainTreeBranch = new Branch(x, y, rand(70, BRANCH_MAXLENGTH), rand(10, BRANCH_MAXWIDTH), rand(-40, 40), rand(-120, -70)); //    this.genF(mainTreeBranch); // ()   drawer.DrawHill(x,y+20); return mainTreeBranch; } }</span></span></code> </pre><br><br>  Reading the code, you probably noticed the new constants BRANCH_DEFORMATION - deformation (curvature) of the branches (not the trunk), BRANCH_MAXLENGTH - the maximum length of the trunk and BRANCH_MAXWIDTH - the width of the trunk.  In the deformations of the branches, their thickness also plays a role in relation to the width; the thinner the branch, the smaller the final devortment is, because it is initially defined in pixels.  As for the length, the branch can not be longer than the one from which it grew.  I did not show the code of the DrawHill function since it consists of only six lines, and draws a semicircle at the point x and y. <br><br>  Well, well, it's time to test the generator.  By calling the genT function with the necessary parameters, we get something like this: <br><br><img src="http://habrastorage.org/storage3/be2/a65/f89/be2a65f89282b70f23d4d956a54ff4ad.png"><br><br>  Agree, the tree is growing!  This could put an end to and rejoice in the dark silhouettes of trees, especially if we consider that it is winter and the trees are no better and sometimes much worse, however, I will not stop and continue to improve the generator to make the trees more lively and interesting.  If you are with me, then we have to go to the next item. <br><br><h4>  Step 3. Generation of branches from branches </h4><br><br>  When trees stand without foliage, it can be seen that they consist not only of laconic, thick branches that grow from the tops of the same branches, but also from those small and not very twigs that grow from the main ones in arbitrary places.  They do this so that the tree has more foliage, because the foliage performs things that are very important for our planet - it evaporates moisture and converts carbon dioxide to oxygen.  These branches in this post will be called shoots.  In fact, they are also branches (branch), as I said, they grow from arbitrary places, and not just from the top.  And we have branches on Bezier curves!  How to calculate where the process is located?  The Bezier curve <a href="http://en.wikipedia.org/wiki/B%25C3%25A9zier_curve">formula</a> itself will help us with this: <br><img src="http://upload.wikimedia.org/math/b/7/4/b74953d8d7ccca2592b0b3382d294743.png" alt="image"><br><br>  On js - it will be like this: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    Branch. pointPos       getPointOnCurve = function(pointPos) { //       var ex = this.params.x + this.params.leng / 2 * Math.cos((this.params.rotate + this.params.deformation).degree()), ey = this.params.y + this.params.leng / 2 * Math.sin((this.params.rotate + this.params.deformation).degree()); //t -  t   [0,1] t = pointPos / 100; //    ep = this.getEndPoints(); //    x,y x = [this.params.x, ep[0]]; y = [this.params.y, ep[1]];   x,y p1 = [ex, ey]; //  par1 = Math.pow((1 - t), 2) * x[0] + (1 - t) * 2 * t * p1[0] + Math.pow(t, 2) * x[1]; // x par2 = Math.pow((1 - t), 2) * y[0] + (1 - t) * 2 * t * p1[1] + Math.pow(t, 2) * y[1]; // y return [par1, par2]; }</span></span></code> </pre><br><br>  The curve will be in the center of the branch.  Visually, it will be like this: <br><br><img src="http://habrastorage.org/storage3/a44/900/afb/a44900afbcd5d0533b391ddfa199d48c.png"><br><br>  Now it's time to generate the processes: create a new function in Branch <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//branches -      this.createOutgrowth = function(leng, width, pos, deform, rotate) { var startXY = this.getPointOnCurve(pos); //  outgrowths( )      this.outgrowths.push(new Branch(startXY[0], startXY[1], leng, width, deform, this.params.rotate + rotate)); return this.outgrowths.reverse()[0]; }</span></span></code> </pre><br><br>  We also expand the generator: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.genO = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">branch</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (branch.params.width &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   1 var outgrowthsCount = rand(0, BRANCH_OUTGROWTH); //  BRANCH_OUTGROWTH - .   for (var io = 0; io &lt; outgrowthsCount; io++) { //        this.genF(branch.createOutgrowth(rand(10, branch.params.leng), rand(1, branch.params.width), rand(1, 100), rand(-10, 10), rand(-40, 40))); } } }</span></span></code> </pre><br><br>  And extend the genF function by replacing this: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     for (var ci = 0; ci &lt; 2; ci++) { this.genF(chld[ci]); }</span></span></code> </pre><br>  on this: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        for (var ci = 0; ci &lt; 2; ci++) { if (OUTGROWTH_ISSHOWN) { //OUTGROWTH_ISSHOWN   ,   true if (chld[ci].params.width &lt; OUTGROWTH_BRANCH_WIDTH) { //OUTGROWTH_BRANCH_WIDTH -       this.genO(chld[ci]); //   } } this.genF(chld[ci]); }</span></span></code> </pre><br><br>  Try it out?  Here is a tree: <br><br><img src="http://habrastorage.org/storage3/54f/531/96c/54f53196c8dc19bf11d890399f3d4d93.png"><br><br>  Looks not very beautiful, not enough leaves.  The next step is about them. <br><br><h4>  Step 4. Leaf generation </h4><br><br>  The leaves are an integral part of any tree (needles are leaves, too, only deformed for protection from cold) and they are too different to generate them programmatically, so we will take one of the five types of leaves created by hand.  Leaves are also best drawn on Bezier curves and stored in arrays with end points and deformation point of the curve.  The leaf is a sevenfold entity and we only need to draw the left side, and the rights will be added automatically. <br>  For example, take the simplest sheet code: <br><pre> <code class="javascript hljs">[[ [<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-comment"><span class="hljs-comment">// (  -  ) [70, 40] //   ]],</span></span></code> </pre><br><br>  Also consider the draw function from Drawer: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DrawLeaf = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, leafPoints, colors, scale, rotate</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  x  y lx = x; ly = y; //    for (var io = 0; io &lt; 2; io++) { this.c.save(); //  this.c.translate(x, y); // this.c.rotate((rotate).degree()); //  this.c.scale(scale, scale); //    if (io == 1) { //    this.c.setTransform(-1, 0, 0, 1, x, y); this.c.scale(scale, scale); this.c.rotate((-180 - (rotate)).degree()); } x = 100 / -2; y = 0; this.c.beginPath(); this.c.moveTo(x, y); var lastPair = [0, 0]; //  -    for (var bi in leafPoints) { var bp = leafPoints[bi]; //   this.c.bezierCurveTo(x + lastPair[0], y + lastPair[1], x + bp[1][0], y + bp[1][1], x + bp[0][0], y + bp[0][1]); //      lastPair = [bp[0][0], bp[0][1]]; } //    this.c.lineTo(x + LEAF_LENG, y); // LEAF_LENG -  .   100 this.c.closePath(); this.c.fillStyle = colors[1]; //  this.c.fill(); this.c.strokeStyle = colors[0]; //   this.c.stroke(); this.c.restore(); x = lx; y = ly; } }</span></span></code> </pre><br><br>  And now it's time to attach it to the generator.  Write the function genL <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.genL = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">branch</span></span></span><span class="hljs-function">) </span></span>{ leafCount = branch.params.leng / (LEAF_LENG * LEAF_SCALE) * LEAF_DENSITY; <span class="hljs-comment"><span class="hljs-comment">//   : LEAF_SCALE - , LEAF_DENSITY -   for (var li = 1; li &lt; leafCount; li++) { // var lxy=branch.getPointOnCurve(branch.params.leng/leafCount*li); //    //  drawer.DrawLeaf(lxy[0], lxy[1], LeafMaps[LEAF_TYPE], ['#353', 'green'], LEAF_SCALE, branch.params.rotate - 180 ); } }</span></span></code> </pre><br><br>  Screw this function to genF, replacing the comment ‚ÄúThere will be additional code, which will be discussed in the following steps‚Äù with the call to genL - like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LEAF_ISSHOWN){ <span class="hljs-comment"><span class="hljs-comment">//LEAF_ISSHOWN - ,   .   true this.genL(branch); }</span></span></code> </pre><br><br>  Well, that tree has grown! <br><br><img src="http://habrastorage.org/storage3/a65/c83/f73/a65c83f735879e6513a9eb49d6704e6f.png"><br><a name="Result"></a><br>  And thank you for your attention, all the code is on <a href="https://github.com/RAZVOR/TreeGenerator">GitHub</a> , <br>  the result of my labors, you can touch <a href="http://razvor.github.io/TreeGenerator/">here</a> </div><p>Source: <a href="https://habr.com/ru/post/210614/">https://habr.com/ru/post/210614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210602/index.html">Implant to prevent apnea</a></li>
<li><a href="../210604/index.html">The evolution of memory - from stone to electronic</a></li>
<li><a href="../210608/index.html">"I am a businessman": how to win 300,000 business development</a></li>
<li><a href="../210610/index.html">Monthly expenses of a design studio for electronic services</a></li>
<li><a href="../210612/index.html">The most popular web analytics in RuNet</a></li>
<li><a href="../210616/index.html">What is faster? foreach vs. List.ForEach vs. for-loop</a></li>
<li><a href="../210618/index.html">Masyanya: crowdfunding returns</a></li>
<li><a href="../210620/index.html">For the first time in history, scientists managed to shoot a fireball on video and study its spectrum.</a></li>
<li><a href="../210622/index.html">Spacecraft Generator from Rebar</a></li>
<li><a href="../210626/index.html">Magic Chocolatey: apt-get and yum for Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>