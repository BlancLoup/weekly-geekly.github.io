<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Where are the brakes in ORM?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Analysis of some python ORM overhead costs 

 Introduction 
 When developing a python django application, I encountered inadequate inhibition. 
 After...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Where are the brakes in ORM?</h1><div class="post__text post__text-html js-mediator-article">  <i>Analysis of some python ORM overhead costs</i> <br><br><h4>  Introduction </h4><br>  When developing a python django application, I encountered inadequate inhibition. <br>  After several attempts to improve the rather complex calculation algorithms, I noticed that the substantial improvements of these algorithms led to a very modest result - from which I concluded that the bottleneck was not in the algorithms. <br><br>  The subsequent analysis showed that the main unproductive consumer of processor resources turned out to be the django ORM, which was used to access the data needed in the calculations. <a name="habracut"></a><br>  Interested in this question, I decided to check what the overheads are when using ORM.  To get the result, I used the most elementary operation: getting the username of the first and only user in the newly created new database. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a database, MySQL was used, located on localhost (MyISAM tables). <br><br>  As a starting ‚Äúexample for imitation‚Äù, I used the code that uses the django specifics minimally and almost optimally obtains the necessary value: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_native</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.db <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> connection, transaction cursor = connection.cursor() t1 = datetime.datetime.now() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>): cursor.execute(<span class="hljs-string"><span class="hljs-string">"select username from auth_user limit 1"</span></span>) f = cursor.fetchone() u = f[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] t2 = datetime.datetime.now() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"native req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span> t1 = datetime.datetime.now() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>): cursor.execute(<span class="hljs-string"><span class="hljs-string">"select username,first_name,last_name,email,password,is_staff,is_active,is_superuser,last_login,date_joined from auth_user limit 1"</span></span>) f = cursor.fetchone() u = f[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] t2 = datetime.datetime.now() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"native (1) req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span> t1 = datetime.datetime.now() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>): cursor = connection.cursor() cursor.execute(<span class="hljs-string"><span class="hljs-string">"select username,first_name,last_name,email,password,is_staff,is_active,is_superuser,last_login,date_joined from auth_user limit 1"</span></span>) f = cursor.fetchone() u = f[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] t2 = datetime.datetime.now() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"native (2) req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span></code> </pre> <br><br>  The result of this code: <br><br><pre> &gt;&gt;&gt; test_native ()
 native req / seq: 8873.05935101 req time (ms): 0.1127007
 native (1) req / seq: 5655.73751948 req time (ms): 0.1768116
 native (2) req / seq: 3815.78751558 req time (ms): 0.2620691
</pre><br><br>  Thus, the optimal ‚Äúsample‚Äù gives about 8 and a half thousand calls to the database per second. <br>  Usually, django and other ORMs pull upon themselves getting other attributes of the object when it is received from the database.  As it is easy to see, getting a ‚Äúlocomotive‚Äù from the rest of the fields in the table rather worsened the result: up to 5 and a half thousand requests per second.  However, this deterioration is relative, since often more than one data field is required to obtain the result of calculations. <br>  The operation of getting a new cursor turned out to be quite difficult - it takes about 0.1ms and degrades the speed of code execution almost 1.5 times. <br><br>  Take for example the second result for the sample and see what losses the ORM adds to the obtained indicators. <br><br><h4>  Django orm </h4><br>  We will execute several variants of queries, starting from the simplest ones, and trying to consistently use the django tools to optimize queries. <br>  At first we will execute the most unpretentious code for obtaining the necessary attribute, starting directly with the User type. <br>  Then we will try to improve the result by first saving the query object. <br>  Then, recall the use of the only () method and try to further improve the result. <br>  And finally, another attempt to improve the situation is to use the values ‚Äã‚Äã() method, which eliminates the need to create a target object. <br>  Here is the final code that verifies the result of our efforts: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_django</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>   t1 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>):       u = User.objects.all()[<span class="hljs-number"><span class="hljs-number">0</span></span>].username   t2 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"django req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span>   t1 = datetime.datetime.now()   q = User.objects.all()   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>):       u = q[<span class="hljs-number"><span class="hljs-number">0</span></span>].username   t2 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"django (1) req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span>   t1 = datetime.datetime.now()   q = User.objects.all().only(<span class="hljs-string"><span class="hljs-string">'username'</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>):       u = q[<span class="hljs-number"><span class="hljs-number">0</span></span>].username   t2 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"django (2) req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span>   t1 = datetime.datetime.now()   q = User.objects.all().values(<span class="hljs-string"><span class="hljs-string">'username'</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>):       u = q[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'username'</span></span>]   t2 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"django (3) req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span></code> </pre><br>  Execution results discourage: <br><pre> &gt;&gt;&gt; test_django ()
 django req / seq: 1106.3929598 req time (ms): 0.903838
 django (1) req / seq: 1173.20686476 req time (ms): 0.8523646
 django (2) req / seq: 695.949871009 req time (ms): 1.4368851
 django (3) req / seq: 1383.74156246 req time (ms): 0.7226783
</pre><br>  Firstly, the use of ORM in itself has degraded performance by more than 5 times (!) In comparison with even a non-optimal ‚Äúsample‚Äù.  Transferring the preparation of the query outside the cycle is not much (less than 10%) improved the result.  But the use of only () completely spoiled the picture - we see a deterioration in the result by almost 2 times, instead of the expected improvement.  At the same time, what is interesting, the exclusion of the creation of an object helped to increase productivity by 20%. <br>  Thus, django ORM gives an increase in overheads of approximately 0.7226783-0.1768116 = 0.5458667ms to receive one object. <br>  Omitting further experiments that required the creation of additional objects and tables, I inform you that these results are also true for obtaining a list of objects: obtaining <i>each individual object of a</i> collection of objects that is the result of a single query results in losses of <i>about half a millisecond and more</i> on each object. <br>  In the case of MySQL, these losses amount to a slowdown in code execution by <b>more than 5 times</b> . <br><br><h4>  SQLAlchemy </h4><br>  For SQLAlchemy, I created a class AUser, declaratively declaring a data structure corresponding to the standard class django.contrib.auth.models.User. <br>  For maximum performance, after a thoughtful reading of the documentation and some experiments, a simple query cache was used: <br><pre> <code class="python hljs">query_cache = {} engine = create_engine(<span class="hljs-string"><span class="hljs-string">'mysql://testalchemy:testalchemy@127.0.0.1/testalchemy'</span></span>, execution_options={<span class="hljs-string"><span class="hljs-string">'compiled_cache'</span></span>:query_cache})</code> </pre><br>  Performance testing is performed first on the ‚Äúfrontal‚Äù version of access to the object. <br>  Then an optimization is attempted by moving the query preparation out of the cycle. <br>  Then optimization is attempted by eliminating the creation of the target object. <br>  Then we will further optimize the query by limiting the set of requested fields. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_alchemy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>   t1 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>):       u = session.query(AUser)[<span class="hljs-number"><span class="hljs-number">0</span></span>].username   t2 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"alchemy req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span>   q = session.query(AUser)   t1 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>):       u = q[<span class="hljs-number"><span class="hljs-number">0</span></span>].username   t2 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"alchemy (2) req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sqlalchemy.sql <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> select   table = AUser.__table__   sel = select([table],limit=<span class="hljs-number"><span class="hljs-number">1</span></span>)   t1 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>):       u = sel.execute().first()[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]   t2 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"alchemy (3) req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span>   table = AUser.__table__   sel = select([<span class="hljs-string"><span class="hljs-string">'username'</span></span>],from_obj=table,limit=<span class="hljs-number"><span class="hljs-number">1</span></span>)   t1 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>):       u = sel.execute().first()[<span class="hljs-string"><span class="hljs-string">'username'</span></span>]   t2 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"alchemy (4) req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span></code> </pre><br>  Here are the test results: <br><pre> &gt;&gt;&gt; test_alchemy ()
 alchemy req / seq: 512.719730527 req time (ms): 1.9503833
 alchemy (2) req / seq: 526.34332554 req time (ms): 1.8999006
 alchemy (3) req / seq: 1341.40897306 req time (ms): 0.7454848
 alchemy (4) req / seq: 1995.34167532 req time (ms): 0.5011673
</pre><br>  In the first two cases, the alchemy did not cache requests, despite their identity (I found why, but the developers still offer to drown it with some kind of plug, which they then promise to stick into the code, I did not do that).  Cached queries allow alchemy to be 30% -35% higher than django ORM in performance. <br>  Immediately, I note that the SQL generated by the django ORM and SQLAlchemy is almost identical and introduces a minimum of distortion to the test. <br><br><h4>  ORM on the knee </h4><br><br>  Naturally, after such results, we redid all of our code, which received data in processing algorithms, into direct requests.  Working with code that performs direct requests is inconvenient - so we wrapped the most frequently performed operations into a simple class that performs tasks similar to ORM: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,**kw)</span></span></span><span class="hljs-function">:</span></span>       self.__dict__.update(kw)   @classmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list_from_cursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls,cursor)</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [cls(**dict(zip([col[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cursor.description],row))) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cursor.fetchall()]   @classmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_cursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls,cursor)</span></span></span><span class="hljs-function">:</span></span>       row = cursor.fetchone()       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> row:           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cls(**dict(zip([col[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cursor.description],row)))   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__str__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str(self.__dict__)   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str(self)   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__getitem__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,ind)</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getattr(self,ind)</code> </pre><br><br>  We measure the performance losses brought about by the use of this class. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_S</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.db <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> connection, transaction   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> util   cursor = connection.cursor()   t1 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>):       cursor.execute(<span class="hljs-string"><span class="hljs-string">"select * from auth_user limit 1"</span></span>)       u = util.S.from_cursor(cursor).username   t2 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"S req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span>   t1 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>):       cursor.execute(<span class="hljs-string"><span class="hljs-string">"select username from auth_user limit 1"</span></span>)       u = util.S.from_cursor(cursor).username   t2 = datetime.datetime.now()   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"S opt req/seq:"</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>/(t2-t1).total_seconds(),<span class="hljs-string"><span class="hljs-string">'req time (ms):'</span></span>,(t2-t1).total_seconds()/<span class="hljs-number"><span class="hljs-number">10.</span></span></code> </pre><br>  Test results: <br><pre> &gt;&gt;&gt; test_S ()
 S req / seq: 4714.92835902 req time (ms): 0.2120923
 S opt req / seq: 7473.3388636 req time (ms): 0.133809
</pre><br>  As you can see, the losses are very modest: 0.2120923-0.1768116 = 0.0352807ms in the non-optimal case and 0.133809-0.1127007 = 0.0211083ms in the optimal one.  I note that in our ORM, made on the knee, a full-fledged python object is created. <br><br><h4>  General conclusion </h4><br>  The use of powerful universal ORM leads to a <i>very noticeable loss of</i> performance.  In the case of using fast DBMS engines such as MySQL, the performance of data access is reduced by <b>more than 3-5 times</b> .  The performance loss is about 0.5ms or more per access to a single object on the Intel Pentium Dual CPU E2200 @ 2.20GHz platform. <br>  A significant part of the loss is the creation of an object from a row of data obtained from the database: approximately 0.1ms.  Another 0.1ms eats away creating the cursor, which is quite difficult to get rid of in ORM. <br>  The origin of the remaining losses remains unknown.  One can only assume that a sufficiently large amount of losses may be caused by the number of calls during the processing of the result ‚Äî by abstracting the data processing layers. <br><br>  In order to achieve adequate performance, ORM developers should keep in mind the losses due to the passage of the code of layers of abstraction, on the design of the query, and on other operations specific to ORM.  A truly productive ORM should allow for a developer using this ORM to <i>once prepare a parameterized query</i> and then use it with different parameters with minimal impact on overall performance.  One way to implement this approach is to use some cache for the generated SQL expressions and handles for prepared queries specific to the underlying DBMS.  To my surprise, despite the fact that this optimization was done in SQLAlchemy, performance still suffers, albeit somewhat less. <br><br>  For me personally, it remains a mystery from where another 0.3-0.4ms of losses are taken when reading one object on both ORMs.  It is characteristic that both ORMs spend <i>almost equally</i> unproductive processor resources.  This makes you think that the losses are not caused by any local ORM problems (like the lack of a cache of prepared queries from django), but by <i>architectural elements</i> that are probably the same for both ORMs.  I would be grateful to the community for professional comments. </div><p>Source: <a href="https://habr.com/ru/post/148044/">https://habr.com/ru/post/148044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148031/index.html">Switchvox Home - IP PBX for very small businesses</a></li>
<li><a href="../148034/index.html">Even in the prisons of Silicon Valley, there are incubators startups</a></li>
<li><a href="../148037/index.html">Can your programming language do this?</a></li>
<li><a href="../148040/index.html">Steve Wozniak showed the contents of his backpack</a></li>
<li><a href="../148043/index.html">How the team maps.nokia.com launched the Nokia 808 PureView over Berlin</a></li>
<li><a href="../148045/index.html">Direct PCB printing on PCB</a></li>
<li><a href="../148046/index.html">Group resistance</a></li>
<li><a href="../148047/index.html">Marketing by Sharing (translation and subtitles for Jason Fried speech)</a></li>
<li><a href="../148048/index.html">Self-organizing teams</a></li>
<li><a href="../148049/index.html">Review of scrolling shooters for NES game console (Famicom)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>