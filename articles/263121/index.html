<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We continue to get acquainted with Intel Xeon Phi: "native" code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article , an acquaintance with the Intel Xeon Phi co-processor was described using offload - the main code runs on the host, and individua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We continue to get acquainted with Intel Xeon Phi: "native" code</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/262019/">last article</a> , an acquaintance with the Intel Xeon Phi co-processor was described using offload - the main code runs on the host, and individual blocks are uploaded to the coprocessor.  In this article we will look at the compilation and use of the ‚Äúnative‚Äù code in order to find out what it gives and what it threatens.  At the end of the post there will be four suggestions regarding the use of Fortran and sample programs. <br><a name="habracut"></a><br>  This article is not advertising or anti-advertising of any software or hardware product, but only describes the personal experience of the author. <br>  Like last time, we will consider the body interaction problem (n-body problem).  We will take the solution of the problem on the CPU from the previous article, and then, if necessary, modify the code to run on the MIC (hereinafter referred to as MIC) we will call Intel Xeon Phi). <br><div class="spoiler">  <b class="spoiler_title">Parallel code using OpenMP</b> <div class="spoiler_text"><pre><code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/*---------------------------------------------------------*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* N-Body simulation benchmark */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* written by MSOzhgibesov */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 04 July 2015 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*---------------------------------------------------------*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;stdio.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;stdlib.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;math.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;string.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">time</span></span>.h&gt; #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;omp.h&gt; #define HOSTLEN <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> numProc; // Initial conditions <span class="hljs-type"><span class="hljs-type">void</span></span> initCoord(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, \ <span class="hljs-type"><span class="hljs-type">float</span></span> initDist, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod, <span class="hljs-type"><span class="hljs-type">int</span></span> nI); // Forces acting <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> body <span class="hljs-type"><span class="hljs-type">void</span></span> forces(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod); // Calculate velocities <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> coordinates <span class="hljs-type"><span class="hljs-type">void</span></span> integration(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod); <span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, const <span class="hljs-type"><span class="hljs-type">char</span></span> * argv[]) { <span class="hljs-type"><span class="hljs-type">int</span></span> const nI = <span class="hljs-number"><span class="hljs-number">32</span></span>; // Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> bodies <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> X, Y <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Z directions <span class="hljs-type"><span class="hljs-type">int</span></span> const nBod = nI*nI*nI; // Total Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> bodies <span class="hljs-type"><span class="hljs-type">int</span></span> const maxIter = <span class="hljs-number"><span class="hljs-number">20</span></span>; // Total number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterations (<span class="hljs-type"><span class="hljs-type">time</span></span> steps) <span class="hljs-type"><span class="hljs-type">float</span></span> const initDist = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; // Initial distance <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> the bodies <span class="hljs-type"><span class="hljs-type">float</span></span> *rA; // Coordinates <span class="hljs-type"><span class="hljs-type">float</span></span> *vA; // Velocities <span class="hljs-type"><span class="hljs-type">float</span></span> *fA; // Forces <span class="hljs-type"><span class="hljs-type">int</span></span> iter; <span class="hljs-type"><span class="hljs-type">double</span></span> startTime0, endTime0; <span class="hljs-type"><span class="hljs-type">char</span></span> host[HOSTLEN]; rA = (<span class="hljs-type"><span class="hljs-type">float</span></span>*)malloc(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod*sizeof(<span class="hljs-type"><span class="hljs-type">float</span></span>)); fA = (<span class="hljs-type"><span class="hljs-type">float</span></span>*)malloc(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod*sizeof(<span class="hljs-type"><span class="hljs-type">float</span></span>)); vA = (<span class="hljs-type"><span class="hljs-type">float</span></span>*)malloc(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod*sizeof(<span class="hljs-type"><span class="hljs-type">float</span></span>)); gethostname(host, HOSTLEN); printf("Host name: %s\n", host); numProc = omp_get_num_procs(); printf("Available number of processors: %d\n", numProc); // Setup initial conditions initCoord(rA, vA, fA, initDist, nBod, nI); startTime0 = omp_get_wtime(); // Main <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; iter &lt; maxIter; iter++ ) { forces(rA, fA, nBod); integration(rA, vA, fA, nBod); } endTime0 = omp_get_wtime(); printf("\nTotal time = %10.4f [sec]\n", endTime0 - startTime0); free(rA); free(vA); free(fA); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } // Initial conditions <span class="hljs-type"><span class="hljs-type">void</span></span> initCoord(<span class="hljs-type"><span class="hljs-type">float</span></span> *rA, <span class="hljs-type"><span class="hljs-type">float</span></span> *vA, <span class="hljs-type"><span class="hljs-type">float</span></span> *fA, \ <span class="hljs-type"><span class="hljs-type">float</span></span> initDist, <span class="hljs-type"><span class="hljs-type">int</span></span> nBod, <span class="hljs-type"><span class="hljs-type">int</span></span> nI) { <span class="hljs-type"><span class="hljs-type">int</span></span> i, j, k; <span class="hljs-type"><span class="hljs-type">float</span></span> Xi, Yi, Zi; <span class="hljs-type"><span class="hljs-type">float</span></span> *rAx = &amp;rA[ <span class="hljs-number"><span class="hljs-number">0</span></span>]; //<span class="hljs-comment"><span class="hljs-comment">---- float *rAy = &amp;rA[ nBod]; // Pointers on X, Y, Z components of coordinates float *rAz = &amp;rA[2*nBod]; //---- int ii = 0; memset(fA, 0.0, 3*nBod*sizeof(float)); memset(vA, 0.0, 3*nBod*sizeof(float)); for (i = 0; i &lt; nI; i++) { Xi = i*initDist; for (j = 0; j &lt; nI; j++) { Yi = j*initDist; for (k = 0; k &lt; nI; k++) { Zi = k*initDist; rAx[ii] = Xi; rAy[ii] = Yi; rAz[ii] = Zi; ii++; } } } } // Forces acting on each body void forces(float *rA, float *fA, int nBod) { int i, j; float Xi, Yi, Zi; float Xij, Yij, Zij; // X[j] - X[i] and so on float Rij2; // Xij^2+Yij^2+Zij^2 float invRij2, invRij6; // 1/rij^2; 1/rij^6 float *rAx = &amp;rA[ 0]; //---- float *rAy = &amp;rA[ nBod]; // Pointers on X, Y, Z components of coordinates float *rAz = &amp;rA[2*nBod]; //---- float *fAx = &amp;fA[ 0]; //---- float *fAy = &amp;fA[ nBod]; // Pointers on X, Y, Z components of forces float *fAz = &amp;fA[2*nBod]; //---- float magForce; // Force magnitude float const EPS = 1.E-10; // Small value to prevent 0/0 if i==j #pragma omp parallel for num_threads(numProc) private(Xi, Yi, Zi, \ Xij, Yij, Zij, magForce, invRij2, invRij6, j, i) for (i = 0; i &lt; nBod; i++) { Xi = rAx[i]; Yi = rAy[i]; Zi = rAz[i]; fAx[i] = 0.0; fAy[i] = 0.0; fAz[i] = 0.0; for (j = 0; j &lt; nBod; j++) { Xij = rAx[j] - Xi; Yij = rAy[j] - Yi; Zij = rAz[j] - Zi; Rij2 = Xij*Xij + Yij*Yij + Zij*Zij; invRij2 = Rij2/((Rij2 + EPS)*(Rij2 + EPS)); invRij6 = invRij2*invRij2*invRij2; magForce = 6.f*invRij2*(2.f*invRij6 - 1.f)*invRij6; fAx[i]+= Xij*magForce; fAy[i]+= Yij*magForce; fAz[i]+= Zij*magForce; } } } // Integration of coordinates an velocities void integration(float *rA, float *vA, float *fA, int nBod) { int i; float const dt = 0.01; // Time step float const mass = 1.0; // mass of a body float const mdthalf = dt*0.5/mass; float *rAx = &amp;rA[ 0]; float *rAy = &amp;rA[ nBod]; float *rAz = &amp;rA[2*nBod]; float *vAx = &amp;vA[ 0]; float *vAy = &amp;vA[ nBod]; float *vAz = &amp;vA[2*nBod]; float *fAx = &amp;fA[ 0]; float *fAy = &amp;fA[ nBod]; float *fAz = &amp;fA[2*nBod]; #pragma omp parallel for num_threads(numProc) private(i) for (i = 0; i &lt; nBod; i++) { rAx[i]+= (vAx[i] + fAx[i]*mdthalf)*dt; rAy[i]+= (vAy[i] + fAy[i]*mdthalf)*dt; rAz[i]+= (vAz[i] + fAz[i]*mdthalf)*dt; vAx[i]+= fAx[i]*dt; vAy[i]+= fAy[i]*dt; vAz[i]+= fAz[i]*dt; } }</span></span></code> </pre> <br></div></div><br>  The code on the coprocessor can be run in two ways: <br><ul><li>  Compile the entire program into native code for the MIC architecture using the -mmic option </li><li>  Run individual subroutines / functions through offload, so part of the code will run on the host and part on Xeon Phi </li></ul><br>  The <a href="http://habrahabr.ru/post/262019/">last time</a> work was considered through the unloading, this time we will try to collect and run the "native" code for MIC. <br>  This method allows you to run an existing program on the coprocessor with minimal changes.  However, the following points should be considered: <br><ul><li>  MIC usually has much less RAM than the host; </li><li>  The algorithm should have as few ‚Äúserial‚Äù sections as possible; </li><li>  The number of I / O operations should be reduced to zero - each such operation is an appeal to the host, and this, as in the case of CUDA, is a very ‚Äúexpensive‚Äù pleasure. </li></ul><br>  The created executable file for MIC is copied to the coprocessor using scp (Intel Xeon Phi has its Linux-based micro-OS) and starts. <br><br><h1>  Create / add user on MIC </h1><br><ol><li>  Under the user (let it be micuser), which we want to add, create ssh keys: <br><pre> <code class="bash hljs">$ ssh-keygen</code> </pre> <br>  We remember the way where they were saved: /home/micuser/.ssh/ <br></li><li>  Under the root, create a new user for MIC: <br><pre> <code class="bash hljs">$ micctrl ‚Äì-useradd=micuser ‚Äì-uid=500 ‚Äì-gid=500 ‚Äì-sshkeys=/home/micuser/.ssh/</code> </pre> <br>  where uid and gid are user ID and group ID. <br></li></ol><br>  If you do not specify a directory with ssh keys, then login under the user will not work - will ask for a password which we do not know.  <a href="https://software.intel.com/sites/default/files/managed/bd/53/System_Administration_Guide_Intel%2528R%2529XeonPhi%2528TM%2529Coprocessor.pdf">A detailed description of the administration process Xeon Phi.</a>  <a href="http://themerakisoul.blogspot.sg/2015/03/how-to-add-user-to-xeon-phi-co-processor.html">An alternative way to create a user on MIC</a> : log in as root to the coprocessor (by default, only root has access to MIC via ssh) and create a user via useradd.  The second method did not check - I want to follow the official manual, and not to deal with possible glitches. <br><br><h1>  Go to "MIKE" </h1><br>  To verify the statement that the program for the CPU can be used on the MIC with minimal changes, we will use the CPU-wide version of the program shown at the very beginning.  Compile for MIC, copy and run: <br><pre> <code class="bash hljs">$ icc nbody_CPU.c -mmic -openmp -O3 -o nbdMIC.run $ scp nbdMIC.run mic0: $ ssh mic0 $ ./nbdMIC.run ./nbdMIC.run: error <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> loading shared libraries: libiomp5.so: cannot open shared object file: No such file or directory</code> </pre><br>  It's not funny at all - they've got it all right!  In fact, almost nowhere - the point is that Xeon Phi is a separate device, with its own file system and, by default, it does not know much!  The solution is simple: you need to copy them to MIC as the executable program.  We exit to the host and copy (note that we copy not just any library, but compiled for MIC): <br><pre> <code class="bash hljs">$ scp /opt/intel/composer_xe_2013_sp1.2.144/compiler/lib/mic/libiomp5.so mic0:/tmp/ $ ssh mic0 $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$LD_LIBRARY_PATH</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LD_LIBRARY_PATH=/tmp $ ./nbdMIC.run Host name: mic0.local Available number of processors: 240 Total time = 1.0823 [sec]</code> </pre><br>  Here we see two interesting things: <br><ol><li>  The number of available threads is 240 ( <a href="http://ark.intel.com/products/71992/Intel-Xeon-Phi-Coprocessor-5110P-8GB-1_053-GHz-60-core">Intel Xeon 5110P has 60 physical cores</a> ), not 236 as when using unloading; </li><li>  The ‚Äúnative‚Äù code works ~ 1.3x times faster than the one being unloaded (1.08 seconds vs. 1.44 seconds). </li></ol><br><div class="spoiler">  <b class="spoiler_title">The results of the program with the upload</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/49c/768/3ac/49c7683acf0a4347af218865bf47cf2c.png"><br></div></div><br>  In the case of unloading, <a href="https://software.intel.com/en-us/articles/best-known-methods-for-using-openmp-on-intel-many-integrated-core-intel-mic-architecture">one kernel is given offload daemon</a> to provide interaction with the host, while the ‚Äúnative‚Äù code is executed with all available resources. <br>  The increase in speed is due to the almost complete absence of data exchange between the host and the MIC (except for printing), as well as through an additional computational core (not so much, but still). <br>  As noted above, the coprocessor is a separate device, and therefore copied libraries, the executable file itself must be stored somewhere, but the coprocessor does not have its SSD / HDD (at least 5110P).  Where, then, is everything copied?  The answer is simple: in RAM and copied.  Thus, each copied file reduces the amount of RAM available to run the program.  And if the output of the program is a file in a couple of gigabytes?  For such purposes, you can mount a folder from the host to the MIC. <br>  Tiring and copying all the necessary libraries is also a tedious task, fortunately there is a micnativeloadex utility that allows you to determine all the dependencies of a compiled program.  Description of the application of this utility, as well as how to mount the directory can be found <a href="https://software.intel.com/en-us/articles/building-a-native-application-for-intel-xeon-phi-coprocessors">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Four sentences about Fortran </h1><br>  In the last article, the first acquaintance with the Intel Xeon Phi co-processor was described, which took place exclusively under C. At the same time, the possibility of using the Fortran language was mentioned, but without describing exactly how to do it, as a result, a request was received to correct the situation.  The basic idea that in the case of using Fortran, that the C language remains unchanged, only the syntax of directives changes.  Therefore, below are only the source code Fortran programs. <br><div class="spoiler">  <b class="spoiler_title">Fortran program for CPU</b> <div class="spoiler_text"><pre> <code class="hljs matlab">!---------------------------------------------------------! ! N-Body simulation benchmark ! ! written by MSOzhgibesov ! ! <span class="hljs-number"><span class="hljs-number">14</span></span> July <span class="hljs-number"><span class="hljs-number">2015</span></span> ! !---------------------------------------------------------! program nbody_CPU use omp_lib implicit none integer, parameter:: nI = <span class="hljs-number"><span class="hljs-number">32</span></span> ! Number of bodies in X, Y and Z directions integer, parameter:: nBod = nI**<span class="hljs-number"><span class="hljs-number">3</span></span> ! Total Number of bodies integer, parameter:: maxIter = <span class="hljs-number"><span class="hljs-number">20</span></span> ! Total number of iterations (time steps) integer:: numProc ! Number of available processors integer:: iter character(len=<span class="hljs-number"><span class="hljs-number">50</span></span>):: host <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), parameter:: initDist = <span class="hljs-number"><span class="hljs-number">1.0</span></span> ! Initial distance between the bodies <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), allocatable:: rA(:) ! Coordinates <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), allocatable:: vA(:) ! Velocities <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), allocatable:: fA(:) ! Forces <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>):: startTime0, endTime0 common/ourCommonData/numProc allocate(rA(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod), vA(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod), fA(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod)) call hostnm(host) write(*,<span class="hljs-string"><span class="hljs-string">'(A11,A50)'</span></span>)<span class="hljs-string"><span class="hljs-string">"Host name: "</span></span>, host numProc = omp_get_num_procs() write(*,<span class="hljs-string"><span class="hljs-string">'(A32,I4)'</span></span>)<span class="hljs-string"><span class="hljs-string">"Available number of processors: "</span></span>,numProc ! Setup initial conditions call initCoord(rA, vA, fA, initDist, nBod, nI) ! Main loop startTime0 = omp_get_wtime() do iter = <span class="hljs-number"><span class="hljs-number">1</span></span>, maxIter call forces(rA, vA, nBod) call integration(rA, vA, fA, nBod) enddo endTime0 = omp_get_wtime() write(*,<span class="hljs-string"><span class="hljs-string">'(A13,F10.4,A6)'</span></span>), <span class="hljs-string"><span class="hljs-string">"Total time = "</span></span>, endTime0 - startTime0,<span class="hljs-string"><span class="hljs-string">" [sec]"</span></span> deallocate(rA, vA, fA) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> program ! Initial conditions subroutine initCoord(rA, vA, fA, initDist, nBod, nI) implicit none integer:: <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>, k, ii integer:: nI, nBod integer:: initDist integer:: numProc <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>):: Xi, Yi,Zi <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>):: rA(*), fA(*), vA(*) fA(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod) = <span class="hljs-number"><span class="hljs-number">0.E0</span></span> vA(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod) = <span class="hljs-number"><span class="hljs-number">0.E0</span></span> ii = <span class="hljs-number"><span class="hljs-number">1</span></span> do <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, nI Xi = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>*(initDist - <span class="hljs-number"><span class="hljs-number">1</span></span>) do <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, nI Yi = <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>*(initDist - <span class="hljs-number"><span class="hljs-number">1</span></span>) do k = <span class="hljs-number"><span class="hljs-number">1</span></span>, nI Zi = k*(initDist - <span class="hljs-number"><span class="hljs-number">1</span></span>) rA(ii ) = Xi rA(ii+ nBod) = Yi rA(ii+<span class="hljs-number"><span class="hljs-number">2</span></span>*nBod) = Zi ii = ii + <span class="hljs-number"><span class="hljs-number">1</span></span> enddo enddo enddo <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine initCoord ! Forces acting on each body subroutine forces(rA, fA, nBod) use omp_lib implicit none integer:: <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> integer:: nI, nBod integer:: numProc <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>):: Xi, Yi, Zi <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>):: Xij, Yij, Zij ! X[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>] - X[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] and so on <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>):: Rij2 ! Xij^<span class="hljs-number"><span class="hljs-number">2</span></span>+Yij^<span class="hljs-number"><span class="hljs-number">2</span></span>+Zij^<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>):: invRij2, invRij6 ! <span class="hljs-number"><span class="hljs-number">1</span></span>/rij^<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>/rij^<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>):: rA(*), fA(*) <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>):: magForce ! Force magnitude <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>):: fAix, fAiy, fAiz <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), parameter:: EPS = <span class="hljs-number"><span class="hljs-number">1.E-10</span></span> ! Small value to prevent <span class="hljs-number"><span class="hljs-number">0</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>==<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> common/ourCommonData/numProc !$OMP PARALLEL NUM_THREADS(numProc) &amp; !$OMP PRIVATE(Xi, Yi, Zi, Xij, Yij, Zij, magForce, invRij2, invRij6, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>)&amp; !$OMP PRIVATE(fAix, fAiy, fAiz) !$OMP DO do <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, nBod Xi = rA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> ) Yi = rA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+ nBod) Zi = rA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>*nBod) fAix = <span class="hljs-number"><span class="hljs-number">0.E0</span></span> fAiy = <span class="hljs-number"><span class="hljs-number">0.E0</span></span> fAiz = <span class="hljs-number"><span class="hljs-number">0.E0</span></span> do <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, nBod Xij = rA(<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> ) - Xi Yij = rA(<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>+ nBod) - Yi Zij = rA(<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>*nBod) - Zi Rij2 = Xij*Xij + Yij*Yij + Zij*Zij invRij2 = Rij2/((Rij2 + EPS)**<span class="hljs-number"><span class="hljs-number">2</span></span>) invRij6 = invRij2*invRij2*invRij2 magForce = <span class="hljs-number"><span class="hljs-number">6.0</span></span>*invRij2*(<span class="hljs-number"><span class="hljs-number">2.0</span></span>*invRij6 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>)*invRij6 fAix = fAix + Xij*magForce fAiy = fAiy + Yij*magForce fAiz = fAiz + Zij*magForce enddo fA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> ) = fAix fA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+ nBod) = fAiy fA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>*nBod) = fAiz enddo !$OMP END PARALLEL <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine forces subroutine integration(rA, vA, fA, nBod) use omp_lib implicit none integer:: <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> integer:: nI, nBod integer:: numProc <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), parameter:: dt = <span class="hljs-number"><span class="hljs-number">0.01</span></span> ! Time step <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), parameter:: mass = <span class="hljs-number"><span class="hljs-number">1.0</span></span> ! mass of a body <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), parameter:: mdthalf = dt*<span class="hljs-number"><span class="hljs-number">0.5</span></span>/mass <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>):: rA(*), vA(*), fA(*) common/ourCommonData/numProc !$OMP PARALLEL NUM_THREADS(numProc) PRIVATE(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) !$OMP DO do <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>*nBod rA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) = (rA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) + fA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>)*mdthalf)*dt vA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) = fA(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>)*dt enddo !$OMP END PARALLEL <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine integration</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fortran program with unloading on Xeon Phi</b> <div class="spoiler_text"><pre> <code class="hljs ruby">!---------------------------------------------------------! ! N-Body simulation benchmark ! ! written by MSOzhgibesov ! ! <span class="hljs-number"><span class="hljs-number">14</span></span> July <span class="hljs-number"><span class="hljs-number">2015</span></span> ! !---------------------------------------------------------! program nbody_XeonPhi use omp_lib implicit none integer, parameter:: nI = <span class="hljs-number"><span class="hljs-number">32</span></span> ! Number of bodies <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> X, Y <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Z directions integer, parameter:: nBod = nI**<span class="hljs-number"><span class="hljs-number">3</span></span> ! Total Number of bodies integer, parameter:: maxIter = <span class="hljs-number"><span class="hljs-number">20</span></span> ! Total number of iterations (time steps) integer:: numProc integer:: iter character(len=<span class="hljs-number"><span class="hljs-number">50</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: host real(<span class="hljs-number"><span class="hljs-number">4</span></span>), parameter:: initDist = <span class="hljs-number"><span class="hljs-number">1.0</span></span> ! Initial distance between the bodies real(<span class="hljs-number"><span class="hljs-number">4</span></span>), allocatable:: rA(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>) ! Coordinates real(<span class="hljs-number"><span class="hljs-number">4</span></span>), allocatable:: vA(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>) ! Velocities real(<span class="hljs-number"><span class="hljs-number">4</span></span>), allocatable:: fA(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>) ! Forces real(<span class="hljs-number"><span class="hljs-number">8</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: startTime<span class="hljs-number"><span class="hljs-number">0</span></span>, endTime<span class="hljs-number"><span class="hljs-number">0</span></span> common/ourCommonData/numProc allocate(rA(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod), vA(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod), fA(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod)) ! Mark variable numProc as needing to be allocated ! on both the host <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> device !DIR$ ATTRIBUTES <span class="hljs-symbol"><span class="hljs-symbol">OFFLOAD:</span></span>mic::numProc, hostnm !DIR$ OFFLOAD <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TARGET(mic) OUT(host, numProc) call hostnm(host) numProc = omp_get_num_procs() !DIR$ <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> OFFLOAD write(*,<span class="hljs-string"><span class="hljs-string">'(A11,A50)'</span></span>)<span class="hljs-string"><span class="hljs-string">"Host name: "</span></span>, host write(*,<span class="hljs-string"><span class="hljs-string">'(A32,I4)'</span></span>)<span class="hljs-string"><span class="hljs-string">"Available number of processors: "</span></span>,numProc ! Setup initial conditions call initCoord(rA, vA, fA, initDist, nBod, nI) ! Mark routines integration <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> forces as needing both ! host <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> coprocessor version !DIR$ ATTRIBUTES <span class="hljs-symbol"><span class="hljs-symbol">OFFLOAD:</span></span>mic::integration, forces ! Main loop startTime<span class="hljs-number"><span class="hljs-number">0</span></span> = omp_get_wtime() !DIR$ OFFLOAD <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> TARGET(mic) INOUT(rA,fA,<span class="hljs-symbol"><span class="hljs-symbol">vA:</span></span>length(<span class="hljs-number"><span class="hljs-number">3</span></span>*nBod)) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> iter = <span class="hljs-number"><span class="hljs-number">1</span></span>, maxIter call forces(rA, vA, nBod) call integration(rA, vA, fA, nBod) enddo !DIR$ <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> OFFLOAD endTime<span class="hljs-number"><span class="hljs-number">0</span></span> = omp_get_wtime() write(*,<span class="hljs-string"><span class="hljs-string">'(A13,F10.4,A6)'</span></span>), <span class="hljs-string"><span class="hljs-string">"Total time = "</span></span>, endTime<span class="hljs-number"><span class="hljs-number">0</span></span> - startTime<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">" [sec]"</span></span> deallocate(rA, vA, fA) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> program nbody_XeonPhi ! Initial conditions subroutine initCoord(rA, vA, fA, initDist, nBod, nI) implicit none integer:: i, j, k, ii integer:: nI, nBod integer:: initDist integer:: numProc real(<span class="hljs-number"><span class="hljs-number">4</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: Xi, Yi,Zi real(<span class="hljs-number"><span class="hljs-number">4</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: rA(*), fA(*), vA(*) fA(<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">3</span></span>*nBod) = <span class="hljs-number"><span class="hljs-number">0</span></span>.D<span class="hljs-number"><span class="hljs-number">0</span></span> vA(<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">3</span></span>*nBod) = <span class="hljs-number"><span class="hljs-number">0</span></span>.D<span class="hljs-number"><span class="hljs-number">0</span></span> ii = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, nI Xi = i*(initDist - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>, nI Yi = j*(initDist - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> k = <span class="hljs-number"><span class="hljs-number">1</span></span>, nI Zi = k*(initDist - <span class="hljs-number"><span class="hljs-number">1</span></span>) rA(ii ) = Xi rA(ii+ nBod) = Yi rA(ii+<span class="hljs-number"><span class="hljs-number">2</span></span>*nBod) = Zi ii = ii + <span class="hljs-number"><span class="hljs-number">1</span></span> enddo enddo enddo <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine initCoord ! Forces acting on each body !DIR$ ATTRIBUTES <span class="hljs-symbol"><span class="hljs-symbol">OFFLOAD:</span></span>mic:: forces subroutine forces(rA, fA, nBod) implicit none integer:: i, j integer:: nI, nBod integer:: numProc real(<span class="hljs-number"><span class="hljs-number">4</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: Xi, Yi, Zi real(<span class="hljs-number"><span class="hljs-number">4</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: Xij, Yij, Zij ! X[j] - X[i] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> so on real(<span class="hljs-number"><span class="hljs-number">4</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: Rij2 ! Xij^<span class="hljs-number"><span class="hljs-number">2</span></span>+Yij^<span class="hljs-number"><span class="hljs-number">2</span></span>+Zij^<span class="hljs-number"><span class="hljs-number">2</span></span> real(<span class="hljs-number"><span class="hljs-number">4</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: invRij2, invRij6 ! <span class="hljs-number"><span class="hljs-number">1</span></span>/rij^<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>/rij^<span class="hljs-number"><span class="hljs-number">6</span></span> real(<span class="hljs-number"><span class="hljs-number">4</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: rA(*), fA(*) real(<span class="hljs-number"><span class="hljs-number">4</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: magForce ! Force magnitude real(<span class="hljs-number"><span class="hljs-number">4</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: fAix, fAiy, fAiz real(<span class="hljs-number"><span class="hljs-number">4</span></span>), parameter:: EPS = <span class="hljs-number"><span class="hljs-number">1</span></span>.E-<span class="hljs-number"><span class="hljs-number">10</span></span> ! Small value to prevent <span class="hljs-number"><span class="hljs-number">0</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i==j common/ourCommonData/numProc !$OMP PARALLEL NUM_THREADS(numProc) &amp; !$OMP PRIVATE(Xi, Yi, Zi, Xij, Yij, Zij, magForce, invRij2, invRij6, i, j)&amp; !$OMP PRIVATE(fAix, fAiy, fAiz) !$OMP DO <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, nBod Xi = rA(i ) Yi = rA(i+ nBod) Zi = rA(i+<span class="hljs-number"><span class="hljs-number">2</span></span>*nBod) fAix = <span class="hljs-number"><span class="hljs-number">0</span></span>.E<span class="hljs-number"><span class="hljs-number">0</span></span> fAiy = <span class="hljs-number"><span class="hljs-number">0</span></span>.E<span class="hljs-number"><span class="hljs-number">0</span></span> fAiz = <span class="hljs-number"><span class="hljs-number">0</span></span>.E<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>, nBod Xij = rA(j ) - Xi Yij = rA(j+ nBod) - Yi Zij = rA(j+<span class="hljs-number"><span class="hljs-number">2</span></span>*nBod) - Zi Rij2 = Xij*Xij + Yij*Yij + Zij*Zij invRij2 = Rij2/((Rij2 + EPS)**<span class="hljs-number"><span class="hljs-number">2</span></span>) invRij6 = invRij2*invRij2*invRij2 magForce = <span class="hljs-number"><span class="hljs-number">6.0</span></span>*invRij2*(<span class="hljs-number"><span class="hljs-number">2.0</span></span>*invRij6 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>)*invRij6 fAix = fAix + Xij*magForce fAiy = fAiy + Yij*magForce fAiz = fAiz + Zij*magForce enddo fA(i ) = fAix fA(i+ nBod) = fAiy fA(i+<span class="hljs-number"><span class="hljs-number">2</span></span>*nBod) = fAiz enddo !$OMP <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> PARALLEL <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine forces !DIR$ ATTRIBUTES <span class="hljs-symbol"><span class="hljs-symbol">OFFLOAD:</span></span>mic::integration subroutine integration(rA, vA, fA, nBod) implicit none integer:: i integer:: nI, nBod integer:: numProc real(<span class="hljs-number"><span class="hljs-number">4</span></span>), parameter:: dt = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">01</span></span> ! Time step real(<span class="hljs-number"><span class="hljs-number">4</span></span>), parameter:: mass = <span class="hljs-number"><span class="hljs-number">1.0</span></span> ! mass of a body real(<span class="hljs-number"><span class="hljs-number">4</span></span>), parameter:: mdthalf = dt*<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>/mass real(<span class="hljs-number"><span class="hljs-number">4</span></span>)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: rA(*), vA(*), fA(*) common/ourCommonData/numProc !$OMP PARALLEL NUM_THREADS(numProc) PRIVATE(i) !$OMP DO <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>*nBod rA(i) = (rA(i) + fA(i)*mdthalf)*dt vA(i) = fA(i)*dt enddo !$OMP <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> PARALLEL <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine integration</code> </pre><br></div></div><br><br><h1>  Instead of conclusion </h1><br>  Working with the ‚Äúnative‚Äù code, in some way, is even simpler than with unloading - you can use the program available for the CPU, moreover, the ‚Äúnative‚Äù program worked even faster than offload.  At the same time, it should be taken into account that if the program depends on third-party libraries, then they will have to be recompiled for MIC or alternatively should be sought.  Also, it should be noted that any files copied to the coprocessor are stored in RAM, which is not much. <br>  In one of the comments to the previous article, the question of comparing the performance of Xeon Phi and CUDA GPU was raised, on the one hand everything depends on the task, and on the other hand it is interesting to compare.  In the next article we will see who is faster, and also try to combine the efforts of the devices. </div><p>Source: <a href="https://habr.com/ru/post/263121/">https://habr.com/ru/post/263121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263109/index.html">User data leakage in QIWI</a></li>
<li><a href="../263111/index.html">Chronos library: make writing long operations easier</a></li>
<li><a href="../263113/index.html">Trouble came from not waiting, XSS vulnerability in Yandex.Metrica</a></li>
<li><a href="../263115/index.html">Clojure Web Applications</a></li>
<li><a href="../263117/index.html">10 years "on the knee" and forced evolution - note for young</a></li>
<li><a href="../263125/index.html">International Mathematical Olympiad for Schoolchildren 2015. Am I? If I want to? Will I decide?</a></li>
<li><a href="../263129/index.html">Microsoft has released an unscheduled security update for Windows MS15-078</a></li>
<li><a href="../263131/index.html">Clojure web application. Part 2</a></li>
<li><a href="../263139/index.html">Pussy: Refactoring. Part two or addiction treatment</a></li>
<li><a href="../263143/index.html">Geek online vacations of a modern child</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>