<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Package Manager opkg. Offline installation of packages in the root file system image</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The lightweight package manager opkg, widely known in narrow circles, has become popular on embedded Linux not by accident. Opkg is used in many embed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Package Manager opkg. Offline installation of packages in the root file system image</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/68c/dd6/58a/68cdd658abc24142ac312be8910d839d.png" alt="pinguin_packet_dry"><br><br>  The lightweight package manager <strong>opkg,</strong> widely known in narrow circles, <strong>has</strong> become popular on embedded Linux not by accident.  Opkg is used in many embedded distributions and projects, for example, in <a href="http://www.openembedded.org/" title="Project website">OpenEmbedded</a> , <a href="http://www.ibm.com/developerworks/ru/library/l-yocto-linux/" title="Creating custom Linux distributions for embedded systems using the Yocto Project">Yocto Project</a> , <a href="https://www.openwrt.org/" title="Openwrt - scalable Linux distribution for embedded devices">OpenWRT</a> , <a href="http://www.angstrom-distribution.org/" title="Project website">√Öngstr√∂m</a> , <a href="http://arago-project.org/" title="Very much exotic from Texas Instruments">Arago Project</a> and some others.  The manager is easy to use, in order to complete the work, the built-in help is quite enough, and on the World Wide Web there are many articles about the ipk package itself (opkg works with this format): how to create it, how to install, etc., etc. .  However, the overwhelming majority of information is devoted to how to work on an already installed system on the target platform (target) in an online mode, but the specificity of Embedded implies that the root file system image and the kernel are prepared in advance on some instrumental platform (host) different from target.  In other words, we assemble the kernel and file system on the working computer, package it into an image, replicate the image with iron.  This article focuses on how to install packages into the prepared rootfs image using the opkg manager. <br><br><a name="habracut"></a><br><h2>  Road rake and bike </h2><br>  Many years ago, when I was an engineer at one small factory, when I launched Linux on the first shawl of my own production, using opkg I installed all the required packages from a remote repository, set up all applications, the laboratory head said: "Excellent! Now do the same on all devices in the party. "  "Sure, not a problem!"  - I replied.  The system is there, it is running, it works.  We copy all the files from the root to external media, then pack it into an image and enjoy life!  At that time, I did not understand that when operating, the operating system performs a number of local settings, creates temporary files, configuration files, generates some keys, and when it first starts it also executes initialization scripts.  Although transferring files from one working system to another using the blunt copying method from the media gave the result, but the effectiveness of this method very soon became doubtful for me.  It is impossible to get a "clean" system in this way: the system remembers its previous life in another hardware body, and from time to time it is stifled by phantom pains. <br><div class="spoiler">  <b class="spoiler_title">Another crazy idea</b> <div class="spoiler_text">  On the target, mount the external drive with rootfs, execute chroot and install packages.  I will not comment. </div></div><br>  The next step for me was to understand the structure of the package itself <strong>* .ipk</strong> .  In fact, the <strong>ipk</strong> package is an archive, which can be easily unpacked using the command: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="bash hljs">ar -x *.ipk</code> </pre> <br>  As a result, we get: <br><br><pre> <code class="bash hljs"> . ‚îú‚îÄ‚îÄ control.tar.gz ‚îú‚îÄ‚îÄ data.tar.gz ‚îî‚îÄ‚îÄ debian-binary</code> </pre> <br>  The <em>data.tar.gz</em> archive contains files that should be placed in the target‚Äôs root directory. <br>  The archive <em>control.tar.gz</em> contains service files: a file with a description and scripts.  The idea is simple: since <strong>ipk</strong> is just an archive with scripts, we can always unpack it into the directory with the file system, and then run (if necessary) the scripts.  But we will have to install all dependencies of the package manually. <br>  And if the dependencies have more dependencies?  There is an idea, maybe write a script to automate the process?  As it often happens in the linux world, if a task has arisen before you, then, most likely, such a task did not arise before you alone, and, most likely, you are not the first in this matter. <br>  I didn‚Äôt have to go far, in fact, the opkg package manager itself has such a mode, when packages are installed in the inactive rootfs file system.  At the same time, the architecture of the host machine (where the opkg utilities are launched) and the target machines can be excellent.  This mode is called <strong>Offline mode</strong> .  In this mode, opkg becomes the most powerful tool for cross-development. <br><br><h2>  We collect opkg for host </h2><br>  To work <strong>offline,</strong> opkg must run on the host.  For a long time, Ubuntu (Ubuntu 14.04 LTS is now on my computer) settled on my computer, and we will build our toolkit on it.  I did not manage to find a repository with opkg for Ubuntu, therefore we collect a set of utilities from source codes. <br>  You can get the source code from the <a href="http://git.yoctoproject.org/cgit/cgit.cgi/opkg/">Yocto Project</a> git repository: <br><br><pre> <code class="bash hljs"> git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.yoctoproject.org/opkg.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> opkg</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">For those who are afraid of git</b> <div class="spoiler_text">  You can do without it.  At the time of this writing, the current version of the utility is <strong>opkg-0.3.1</strong> .  Download the source from the site and unpack: <pre> <code class="bash hljs">tar xzf opkg-0.3.1.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> opkg-0.3.1/</code> </pre> </div></div><br>  In fact, the configuration and compilation of the project is done in a fairly standard way, but there are some nuances, and therefore everything is in order. <br>  Run: <br><br><pre> <code class="bash hljs">./autogen.sh</code> </pre> <br>  To the note: if you run <code>./autogen.sh</code> with the <code>--clean</code> parameter, then all works on the project configuration will be deleted. <br>  After executing <code>./autogen.sh</code> , the <code>configure</code> script appears in the source directory, it will configure the package, determine and set system-dependent variables.  As a result of the script, a Makefile is created.  You can view all script options in the standard way: <br><br><pre> <code class="bash hljs">./configure --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre> <br>  We will build the package for the current platform, so we‚Äôll skip the options for configuring cross-compilation.  We will take care of the installation.  By default, running <code>make install</code> , the script scatters all useful files (binaries, scripts, documentation) in the root directory: <code>/etc</code> , <code>/usr/local</code> , which is completely useless to us.  We're not going to use opkg to configure packages on the current system?  In addition, having installed the manager in the system folders, to use the utilities, you will need superuser rights, in my opinion, this is unnecessary when setting up the embedded linux image.  The <code>configure.sh</code> script allows you to specify a prefix for the package installation directory.  Specifying any working directory as a prefix, we will inform the installer where to put the package.  If necessary, you can separately specify the prefix for architecture-dependent (binaries and libraries) and architecture-independent (scripts and documentation) files. <br>  With fantasy, I have always been weak, because for the installation in the home directory we will create the opkg_offline directory. <br><br><pre> <code class="bash hljs">mkdir <span class="hljs-variable"><span class="hljs-variable">${HOME}</span></span>/opkg_offline</code> </pre> <br>  Run the configuration: <br><br><pre> <code class="bash hljs">./configure --prefix=<span class="hljs-variable"><span class="hljs-variable">${HOME}</span></span>/opkg_offline</code> </pre> <br>  If necessary, deliver the required dependencies.  So, on Ubuntu 14.04 I needed to deliver <code>libarchive-dev</code> , <code>libcurl4-gnutls-dev</code> , <code>libssl-dev</code> , <code>libgpgme11-dev</code> to build successfully. <br><div class="spoiler">  <b class="spoiler_title">But how to do it?</b> <div class="spoiler_text"><pre> <code class="bash hljs">sudo apt-get install libarchive-dev sudo apt-get install libcurl4-gnutls-dev sudo apt-get install libssl-dev sudo apt-get install libgpgme11-dev</code> </pre> </div></div><br><br>  Compile and install opkg: <br><br><pre> <code class="bash hljs">make make install</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">As a result, in the opkg_offline directory we have:</b> <div class="spoiler_text"><pre> <code class="bash hljs">opkg_offline ‚îú‚îÄ‚îÄ bin ‚îÇ  ‚îú‚îÄ‚îÄ opkg ‚îÇ  ‚îú‚îÄ‚îÄ opkg-check-config ‚îÇ  ‚îî‚îÄ‚îÄ opkg-key ‚îú‚îÄ‚îÄ lib ‚îÇ  ‚îú‚îÄ‚îÄ libopkg.a ‚îÇ  ‚îú‚îÄ‚îÄ libopkg.la ‚îÇ  ‚îú‚îÄ‚îÄ libopkg.so -&gt; libopkg.so.1.0.0 ‚îÇ  ‚îú‚îÄ‚îÄ libopkg.so.1 -&gt; libopkg.so.1.0.0 ‚îÇ  ‚îú‚îÄ‚îÄ libopkg.so.1.0.0 ‚îÇ  ‚îî‚îÄ‚îÄ pkgconfig ‚îÇ  ‚îî‚îÄ‚îÄ libopkg.pc ‚îî‚îÄ‚îÄ share ‚îú‚îÄ‚îÄ man ‚îÇ  ‚îî‚îÄ‚îÄ man1 ‚îÇ  ‚îú‚îÄ‚îÄ opkg.1 ‚îÇ  ‚îî‚îÄ‚îÄ opkg-key.1 ‚îî‚îÄ‚îÄ opkg ‚îî‚îÄ‚îÄ intercept ‚îú‚îÄ‚îÄ depmod ‚îú‚îÄ‚îÄ ldconfig ‚îî‚îÄ‚îÄ update-modules</code> </pre> <br></div></div><br>  Package Manager is built and installed.  Executable files are located in the opkg_offline / bin directory.  To work with them, you can set the path to the PATH variable, either export (call in) for each terminal session, or do as I do ‚Äî go to the opkg_offline directory and run directly <code>./bin/opkg</code> . <br><br><h2>  Anatomy Short Course </h2><br>  Let's take a quick look at how the package manager works in standard mode.  After executing the <code>opkg update</code> command, the utility reads configuration files that are located by default in <code>/etc/opkg</code> and have the extension .conf.  From these files, the system determines the type of architecture, for example, <em>armv5hf-vfp</em> or <em>armv5tehf-vfp</em> (there may be several supported architectures, you can set a priority for each), a list of repositories, and some settings of the program itself.  Next, for each repository from the list, an archive of the type <code>*_Packages.gz</code> .  Default archives are placed in the <code>var/cache/opkg/</code> .  After unpacking, the contents are placed in <code>var/lib/opkg/lists</code> .  Each archive contains a text file with a list of packages in the repository.  For each package, in addition to the name, there is a version, architecture, size, short description, license, and most importantly, dependencies.  Based on these files, the package manager can provide information about the required package upon request, and when installing it, determine all dependencies and resolve them. <br>  The <code>opkg list</code> command <code>opkg list</code> all packages available for installation;  The <code>opkg list-installed</code> command <code>opkg list-installed</code> will show only installed packages, the <code>opkg info</code> command will show information about the specified package, and if it is installed, then the installation time. <br>  To install a package, you must run <code>opkg install packname</code> .  As a result, the required package from the repository will be downloaded to the temporary directory and distributed.  All files from the data.tar.gz archive will go to rootfs in their places, and based on the contents of control.tar.gz, service files will be created in the <code>var/lib/opkg/info</code> <code>packname.control</code> : <code>packname.control</code> - complete information about the package, <code>packname.list</code> - the list of directories in which the files from data.tar.gz went (this list will go through opkg when the package is deleted), and script files such as <code>packname.postinst</code> , <code>packname.preinst</code> , <code>packname.prerm</code> , <code>packname.postrm</code> , whose purposes are clear from the title.  Information about the installed package will be added to the <code>var/lib/opkg/status</code> file as (example for the popular <a href="https://en.wikipedia.org/wiki/Minicom">minicom</a> ): <br><br><pre> <code class="hljs pgsql">Package: minicom <span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>: <span class="hljs-number"><span class="hljs-number">2.6</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>-r0<span class="hljs-number"><span class="hljs-number">.2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Depends</span></span>: libtinfo5 (&gt;= <span class="hljs-number"><span class="hljs-number">5.9</span></span>), libc6 (&gt;= <span class="hljs-number"><span class="hljs-number">2.17</span></span>) Status: install ok installed Architecture: armv7ahf-vfp-neon Installed-<span class="hljs-type"><span class="hljs-type">Time</span></span>: <span class="hljs-number"><span class="hljs-number">1454529423</span></span></code> </pre> <br>  It is important to pay attention to <code>Status</code> .  If the package was installed according to all the rules: all files are copied to their place, all scripts are executed, then the status will be <code>Status: install ok installed</code> .  When working offline, all files will be copied, but the scripts will not be executed, such packages will be marked as <code>Status: install ok unpacked</code> . <br>  In this case, opkg has a special <em>post configuration</em> mechanism <em>for</em> packages.  It is launched by the <code>opkg configure &lt;packname&gt;</code> .  If you specify the name of a specific package, the scripts from var / lib / opkg / info will be executed for this package;  if the name is omitted, the manager will configure for all packages whose status is <code>Status: install ok unpacked</code> .  Thus, when installing packages to the host in offline mode, when you first load the operating system on the target, you should run <code>opkg configure</code> .  You can entrust this either to a special script or, if <strong>systemd is</strong> used, to a special service. <br><br><h2>  Work with target rootfs </h2><br>  It is time to try the system in action.  For example, install the minicom serial port terminal emulator. <br>  To install packages, we need an unpacked image of the root file system of the target rootfs platform.  Suppose that the opkg manager is installed in rootfs, and there are configuration files in the <code>etc/opkg</code> directory * .conf.  If it is not there, or for some reason we do not want to use the configuration from rootfs, we can use the parameter to specify which settings file to use: <code>-f etc/opkg/opkg.conf</code> .  The path to the target file system is passed through the parameter <code>--offline-root /path/to/rootfs</code> . <br>  Updating package lists: <br><br><pre> <code class="bash hljs">bin/opkg update --offline-root /path/to/rootfs</code> </pre> <br>  We look through the list of available packages, we look for minicom. <br><br><pre> <code class="bash hljs">bin/opkg list --offline-root ~/board/rootfs/angstrom/rootfs-v2015.10 | grep minicom minicom - 2.7-r0.0 - Text-based modem control and terminal emulation program Minicom is a minicom-dbg - 2.7-r0.0 - Text-based modem control and terminal emulation program - Debugging files minicom-dev - 2.7-r0.0 - Text-based modem control and terminal emulation program - Development minicom-doc - 2.7-r0.0 - Text-based modem control and terminal emulation program - Documentation</code> </pre><br>  See information about the package: <br><br><pre> <code class="bash hljs">bin/opkg info minicom --offline-root ~/board/rootfs/angstrom/rootfs-v2015.10</code> </pre> <br><pre> <code class="hljs pgsql"> Package: minicom <span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>: <span class="hljs-number"><span class="hljs-number">2.7</span></span>-r0<span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Depends</span></span>: libtinfo5 (&gt;= <span class="hljs-number"><span class="hljs-number">5.9</span></span>), libc6 (&gt;= linaro<span class="hljs-number"><span class="hljs-number">-2.20</span></span>) Status: <span class="hljs-type"><span class="hljs-type">unknown</span></span> ok <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-installed Section: console/network Architecture: armv7at2hf-vfp-neon Maintainer: Angstrom Developers &lt;angstrom-distro-devel@linuxtogo.org&gt; MD5Sum: e4d11b7277fbc1c7db6bbd97ac52ca2c Size: <span class="hljs-number"><span class="hljs-number">79354</span></span> Filename: minicom_2<span class="hljs-number"><span class="hljs-number">.7</span></span>-r0<span class="hljs-number"><span class="hljs-number">.0</span></span>_armv7at2hf-vfp-neon.ipk Description: <span class="hljs-type"><span class="hljs-type">Text</span></span>-based modem control <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> terminal emulation program Minicom <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a <span class="hljs-type"><span class="hljs-type">text</span></span>-based modem control <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> terminal emulation program <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Unix-<span class="hljs-keyword"><span class="hljs-keyword">like</span></span> operating systems</code> </pre> <br>  Install the package: <br><br><pre> <code class="bash hljs">bin/opkg install minicom --offline-root ~/board/rootfs/angstrom/rootfs-v2015.10</code> </pre> <br>  An <code>var/lib/opkg</code> appeared in the <code>var/lib/opkg</code> file: <br><br><pre> <code class="hljs pgsql"> Package: minicom <span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>: <span class="hljs-number"><span class="hljs-number">2.7</span></span>-r0<span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Depends</span></span>: libtinfo5 (&gt;= <span class="hljs-number"><span class="hljs-number">5.9</span></span>), libc6 (&gt;= linaro<span class="hljs-number"><span class="hljs-number">-2.20</span></span>) Status: install <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> unpacked Architecture: armv7at2hf-vfp-neon Installed-<span class="hljs-type"><span class="hljs-type">Time</span></span>: <span class="hljs-number"><span class="hljs-number">1454594718</span></span></code> </pre> <br>  After the system was launched from the created image and the <code>opkg configure</code> command <code>opkg configure</code> , the entry in the file changed: <br><br><pre> <code class="hljs pgsql"> Package: minicom <span class="hljs-keyword"><span class="hljs-keyword">Version</span></span>: <span class="hljs-number"><span class="hljs-number">2.7</span></span>-r0<span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Depends</span></span>: libtinfo5 (&gt;= <span class="hljs-number"><span class="hljs-number">5.9</span></span>), libc6 (&gt;= linaro<span class="hljs-number"><span class="hljs-number">-2.20</span></span>) Status: install <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> installed Architecture: armv7at2hf-vfp-neon Installed-<span class="hljs-type"><span class="hljs-type">Time</span></span>: <span class="hljs-number"><span class="hljs-number">1454594718</span></span></code> </pre> <br>  Since custom rootfs is designed for an embedded computer, the final image size matters.  Therefore, I recommend that after all the necessary packages have been installed, delete the downloaded lists and clean the cache: <br><br><pre> <code class="bash hljs">rm -rvf ~/board/rootfs/angstrom/rootfs-v2015.10/var/cache/opkg/* rm -rvf ~/board/rootfs/angstrom/rootfs-v2015.10/var/lib/opkg/lists/*</code> </pre> <br>  To the note: the option <code>--volatile-cache</code> will allow clearing the cache automatically upon completion of work. <br><br><h2>  Instead of conclusion </h2><br>  Despite the performance, <strong>Offline mode</strong> has some drawbacks.  The fact is that the <code>opkg configure</code> command runs only <code>\*.postinst</code> <code>opkg configure</code> for execution, but the question remains with the execution of <code>\*.preinst</code> .  Due to the fact that <code>\*.preinst</code> is quite rare in packages, for me it is acceptable to view the scripts manually, and, if necessary, to work them out when you first start the target system (special services for systemd).  I would be grateful for the advice. <br><br><h2>  Read on: </h2><br><ul><li>  <a href="http://dream.altmaster.net/showthread.php%3Ft%3D4598">IPK-package or what it eats</a> </li><li>  <a href="https://wiki.openwrt.org/doc/techref/opkg">OpenWrt.OPKG Package Manager</a> .  The most intelligible help. </li><li>  <a href="http://git.yoctoproject.org/cgit/cgit.cgi/opkg/">Yocto Project</a> .  Repository  Sources </li></ul></div><p>Source: <a href="https://habr.com/ru/post/276609/">https://habr.com/ru/post/276609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276595/index.html">Quadcopter navigation using monocular vision</a></li>
<li><a href="../276597/index.html">Binding Request Traker 4.x on Ubuntu to ldap using the example of ActiveDirectory</a></li>
<li><a href="../276599/index.html">What brings the idea (Objective-C) - target-action on the blocks and a lot of runtime</a></li>
<li><a href="../276603/index.html">Evgeny Kaspersky spoke about cybercrime at Innopolis University [video]</a></li>
<li><a href="../276607/index.html">Performance and memory profiling from multiple viewing angles</a></li>
<li><a href="../276611/index.html">Criticism of the article ‚ÄúHow to write in C in 2016‚Äù</a></li>
<li><a href="../276613/index.html">Notes of a true architect: just about the most important thing (Part 2)</a></li>
<li><a href="../276617/index.html">Chakra officially adopted by Node.js</a></li>
<li><a href="../276619/index.html">Analysis of Android Malvari Matryoshka</a></li>
<li><a href="../276621/index.html">Mitap SPB .NET Community # 9</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>