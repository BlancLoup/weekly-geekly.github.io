<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RabbitMQ tutorial 2 - Queue of tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In continuation of the first lesson in the study of the basics of RabbitMQ I publish a translation of the second lesson from the official site . All e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RabbitMQ tutorial 2 - Queue of tasks</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/0fd/e8f/feb/0fde8ffebb772c7d486921464ae55a29.png"><br><br>  In continuation of the <a href="http://habrahabr.ru/post/149694/">first lesson</a> in the study of the basics of RabbitMQ I publish a translation of the second lesson from the <a href="http://www.rabbitmq.com/tutorials/tutorial-two-python.html">official site</a> .  All examples, as before, in python, but still they can be implemented on most <a href="http://www.rabbitmq.com/devtools.html">popular PL</a> . <br><a name="habracut"></a><br><h4>  Task queues </h4><br>  In the first lesson we wrote two programs: one sent messages, the second received them.  In this lesson, we will create a queue that will be used to distribute resource-intensive tasks among multiple subscribers. <br><br>  The main purpose of such a queue is not to start the task right now and not wait until it is completed.  Instead, tasks are postponed.  Each message corresponds to one task.  The handler program running in the background will accept the task for processing, and after some time it will be executed.  When you run multiple handlers, tasks will be divided between them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This principle of operation is especially useful for applications in web applications where it is impossible to process a resource-intensive task during an HTTP request. <br><br><h4>  Training </h4><br>  In the previous lesson, we sent a message with the text ‚ÄúHello World!‚Äù.  And now we will send messages corresponding to resource-intensive tasks.  We will not perform real tasks, such as resizing an image or rendering a pdf file, let's just do a stub using the <b>time.sleep ()</b> function.  The complexity of the task will be determined by the number of points in the message line.  Each point will be ‚Äúexecuted‚Äù one second.  For example, a task with the message ‚ÄúHello ...‚Äù will be executed for 3 seconds. <br><br>  We will slightly <b>modify the send.py</b> program <b>code</b> from the <a href="http://habrahabr.ru/post/149694/">previous example</a> so that it is possible to send arbitrary messages from the command line.  This program will send messages to our queue, planning to perform new tasks.  Let's call it <b>new_task.py</b> : <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys message = <span class="hljs-string"><span class="hljs-string">' '</span></span>.join(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span> channel.basic_publish(exchange=<span class="hljs-string"><span class="hljs-string">''</span></span>, routing_key=<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, body=message) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">" [x] Sent %r"</span></span> % (message,)</code> </pre> <br>  The <b>receive.py</b> program from the previous example should also be changed: it is necessary to simulate the performance of useful work, a second for each point of the message text.  The program will receive a message from the queue and perform the task.  Let's call it <b>worker.py</b> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ch, method, properties, body)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">" [x] Received %r"</span></span> % (body,) time.sleep( body.count(<span class="hljs-string"><span class="hljs-string">'.'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">" [x] Done"</span></span></code> </pre><br><h4>  Cyclic distribution </h4><br>  One of the advantages of using the task queue is the ability to perform work in parallel with several programs.  If we do not have time to perform all incoming tasks, we can simply add the number of handlers. <br><br>  To begin, let's launch two programs <b>worker.py at once</b> .  Both will receive messages from the queue, but how?  Now we will see. <br><br>  You need to open three terminal windows.  In two of them the <b>worker.py</b> program will be launched.  It will be two subscribers - C1 and C2. <br><br><pre> <code class="bash hljs">shell1$ python worker.py [*] Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> messages. To <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> press CTRL+C</code> </pre><br><pre> <code class="bash hljs">shell2$ python worker.py [*] Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> messages. To <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> press CTRL+C</code> </pre><br>  In the third window, we will publish new tasks.  After subscribers are started, you can send any number of messages: <br><br><pre> <code class="bash hljs">shell3$ python new_task.py First message. shell3$ python new_task.py Second message.. shell3$ python new_task.py Third message... shell3$ python new_task.py Fourth message.... shell3$ python new_task.py Fifth message.....</code> </pre><br>  Let's see what has been delivered to subscribers: <br><br><pre> <code class="bash hljs">shell1$ python worker.py [*] Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> messages. To <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> press CTRL+C [x] Received <span class="hljs-string"><span class="hljs-string">'First message.'</span></span> [x] Received <span class="hljs-string"><span class="hljs-string">'Third message...'</span></span> [x] Received <span class="hljs-string"><span class="hljs-string">'Fifth message.....'</span></span></code> </pre><br><pre> <code class="bash hljs">shell2$ python worker.py [*] Waiting <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> messages. To <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> press CTRL+C [x] Received <span class="hljs-string"><span class="hljs-string">'Second message..'</span></span> [x] Received <span class="hljs-string"><span class="hljs-string">'Fourth message....'</span></span></code> </pre><br>  By default, RabbitMQ will send each new message to the next subscriber.  Thus, all subscribers will receive the same number of messages.  This kind of message distribution is called <i><a href="http://ru.wikipedia.org/wiki/Round-robin_(%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC)">round-robin</a> [ <a href="http://ru.wikipedia.org/wiki/Round-robin_(%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC)">round-robin</a> algorithm]</i> .  Try the same with three or more subscribers. <br><br><h4>  Message Verification </h4><br>  These tasks take a few seconds to complete.  You may have already wondered what would happen if the handler started the task, but unexpectedly stopped working, having completed it only partially.  In the current implementation of our programs, the message is deleted as soon as RabbitMQ delivered it to the subscriber.  Therefore, if you stop the handler during operation, the task will not be executed, and the message will be lost.  Delivered messages that have not yet started processing will also be lost. <br><br>  But we do not want to lose any tasks.  We need to, in the event of an emergency exit of one handler, the message is transferred to another. <br><br>  So that we can be sure that there are no lost messages, RabbitMQ supports message acknowledgment.  A confirmation is sent by the subscriber to inform RabbitMQ that the received message has been processed and RabbitMQ can delete it. <br><br>  If the subscriber has stopped working and has not sent a confirmation, RabbitMQ will understand that the message has not been processed and will forward it to another subscriber.  So you can be sure that no message will be lost, even if the execution of the handler program has stopped unexpectedly. <br><br>  There is no timeout to process messages.  RabbitMQ will transfer them to another subscriber only if the connection with the first one is closed, therefore there are no restrictions on the processing time of the message. <br><br>  The default is manual confirmation of messages.  In the previous example, we forced the automatic confirmation of messages by specifying <b>no_ack = True</b> .  Now we will remove this flag and send the confirmation from the handler immediately after the task is completed. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ch, method, properties, body)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">" [x] Received %r"</span></span> % (body,) time.sleep( body.count(<span class="hljs-string"><span class="hljs-string">'.'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">" [x] Done"</span></span> ch.basic_ack(delivery_tag = method.delivery_tag) channel.basic_consume(callback, queue=<span class="hljs-string"><span class="hljs-string">'hello'</span></span>)</code> </pre><br>  Now, even if you stop the handler by pressing <b>Ctrl + C</b> while processing the message, nothing will be lost.  After stopping the handler, RabbitMQ will re-transmit unconfirmed messages. <br><br><h5>  Do not forget to confirm messages. </h5><br>  Sometimes developers forget to add <b>basic_ack</b> to the code.  The consequences of this small error can be significant.  The message will be re-transmitted only when the handler program is stopped, but RabbitMQ will consume more and more memory, because  will not delete unconfirmed messages. <br>  To debug this kind of error, you can use <b>rabbitmqctl</b> to display the <b>messages_unacknowledged</b> field (unconfirmed messages): <br><br><pre> <code class="bash hljs">$ sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged Listing queues ... hello 0 0 ...<span class="hljs-keyword"><span class="hljs-keyword">done</span></span>.</code> </pre><br>  <i>[or use a more convenient monitoring script, which I cited in the <a href="http://habrahabr.ru/post/149694/">first part</a> ]</i> <br><br><h4>  Message persistence </h4><br>  We figured out how not to lose the task if the subscriber suddenly stopped working.  But tasks will be lost if RabbitMQ server stops working. <br><br>  By default, when the RabbitMQ server stops or crashes, all queues and messages are lost, but this behavior can be changed.  In order for messages to remain in the queue after the server is restarted, it is necessary to make both the queues and the messages stable. <br><br>  First, make sure that the queue is not lost.  For this you need to declare it as stable ( <b>durable</b> ): <br><br><pre> <code class="python hljs">channel.queue_declare(queue=<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, durable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre><br>  Although this command itself is correct, it will not work now, because the <b>hello</b> queue has already been declared unstable.  RabbitMQ does not allow overriding parameters for an existing queue and will return an error when trying to do this.  But there is a simple workaround - let's declare a queue with a different name, for example, <b>task_queue</b> : <br><br><pre> <code class="python hljs">channel.queue_declare(queue=<span class="hljs-string"><span class="hljs-string">'task_queue'</span></span>, durable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre><br>  This code must be corrected for both the supplier and the subscriber. <br>  So we can be sure that the <b>task_queue</b> queue <b>will</b> not be lost when the RabbitMQ server is restarted.  Now you need to mark messages as resilient.  To do this, pass the <b>delivery_mode</b> property with a value of <b>2</b> : <br><br><pre> <code class="python hljs">channel.basic_publish(exchange=<span class="hljs-string"><span class="hljs-string">''</span></span>, routing_key=<span class="hljs-string"><span class="hljs-string">"task_queue"</span></span>, body=message, properties=pika.BasicProperties( delivery_mode = <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-comment"><span class="hljs-comment"># make message persistent ))</span></span></code> </pre><br><h5>  Message Resilience Notice </h5><br>  Marking a message as sustainable does not guarantee that the message will not be lost.  Despite the fact that this causes RabbitMQ to save the message to the disk, there is a short period of time when RabbitMQ has confirmed the acceptance of the message, but has not yet recorded it.  Also RabbitMQ does not do <b>fsync (2)</b> for each message, so some of them can be saved to the cache, but not yet written to disk.  The message stability guarantee is not complete, but it is more than enough for our task queue.  If you need higher reliability, you can wrap transactions in a transaction. <br><br><h4>  Uniform distribution of messages </h4><br>  You may have noticed that the distribution of messages still does not work as we need.  For example, when two subscribers work, if all odd messages contain complex tasks <i>[require a lot of time to perform]</i> , and even ones are simple, then the first handler will be constantly busy, and the second will be free most of the time.  But RabbitMQ knows nothing about it and will still send messages to subscribers in turn. <br>  This happens because RabbitMQ distributes messages at a time when they are in the queue, and does not take into account the number of unacknowledged messages from subscribers.  RabbitMQ simply sends every nth message to the nth subscriber. <br><br><img src="https://habrastorage.org/storage2/f0e/b4d/c62/f0eb4dc626e5da02d78a49fc05536b34.png"><br><br>  In order to change this behavior, we can use the <b>basic_qos</b> method with the <b>prefetch_count = 1</b> option.  This will force RabbitMQ not to give the subscriber more than one message at a time.  In other words, the subscriber will not receive a new message until he processes and confirms the previous one.  RabbitMQ will send the message to the first released subscriber. <br><br><pre> <code class="python hljs">channel.basic_qos(prefetch_count=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><h5>  Remark on queue size </h5><br>  If all subscribers are busy, the queue size may increase.  You should pay attention to this and, possibly, increase the number of subscribers. <br><br><h4>  Well, now all together </h4><br>  The full code of the program <b>new_task.py</b> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python import pika import sys connection = pika.BlockingConnection(pika.ConnectionParameters( host='localhost')) channel = connection.channel() channel.queue_declare(queue='task_queue', durable=True) message = ' '.join(sys.argv[1:]) or "Hello World!" channel.basic_publish(exchange='', routing_key='task_queue', body=message, properties=pika.BasicProperties( delivery_mode = 2, # make message persistent )) print " [x] Sent %r" % (message,) connection.close()</span></span></code> </pre><br>  The complete code for <b>worker.py is</b> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python import pika import time connection = pika.BlockingConnection(pika.ConnectionParameters( host='localhost')) channel = connection.channel() channel.queue_declare(queue='task_queue', durable=True) print ' [*] Waiting for messages. To exit press CTRL+C' def callback(ch, method, properties, body): print " [x] Received %r" % (body,) time.sleep( body.count('.') ) print " [x] Done" ch.basic_ack(delivery_tag = method.delivery_tag) channel.basic_qos(prefetch_count=1) channel.basic_consume(callback, queue='task_queue') channel.start_consuming()</span></span></code> </pre><br>  Using the confirmation of messages and <b>prefetch_count</b> , you can create a queue of tasks.  Resilience tuning will allow tasks to persist even after the RabbitMQ server is restarted. <br><br>  In the third lesson we will discuss how you can send one message to several subscribers. </div><p>Source: <a href="https://habr.com/ru/post/150134/">https://habr.com/ru/post/150134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150128/index.html">Microsoft has changed the logo</a></li>
<li><a href="../150130/index.html">Russian subtitles in Coursera courses</a></li>
<li><a href="../150131/index.html">Debian / Ubuntu Admin Manager Package Management Cheat Sheet</a></li>
<li><a href="../150132/index.html">Do you want to be a YouTube star?</a></li>
<li><a href="../150133/index.html">The insides of the QML engine. Part 2: Bindings</a></li>
<li><a href="../150135/index.html">Facebook stores data in one data center and processes 500 TB of data per day.</a></li>
<li><a href="../150140/index.html">I'll just leave it here</a></li>
<li><a href="../150142/index.html">Small and BIG companies</a></li>
<li><a href="../150143/index.html">Change view. Change the look of the interface</a></li>
<li><a href="../150144/index.html">Celestia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>