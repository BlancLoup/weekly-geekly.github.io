<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basics of JavaScript engines: common forms and inline caching. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello friends. At the end of April, we are launching a new course , Information Security . And now we want to share with you the translation of the ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basics of JavaScript engines: common forms and inline caching. Part 1</h1><div class="post__text post__text-html js-mediator-article">  Hello friends.  At the end of April, we are launching a new course <a href="https://otus.pw/CswX/">, Information Security</a> .  And now we want to share with you the translation of the article, which will certainly be very useful for the course.  The original article can be <a href="https://mathiasbynens.be/notes/shapes-ics">found here</a> . <br><br>  The article describes the key fundamentals, they are common to all JavaScript engines, and not just the <a href="https://twitter.com/v8js">V8</a> , on which the authors of the engine ( <a href="https://twitter.com/bmeurer">Benedict</a> and <a href="https://twitter.com/mathias">Mathias</a> ) are working.  As a JavaScript developer, I can say that a deeper understanding of how the JavaScript engine works will help you figure out how to write effective code. <br><br><img src="https://habrastorage.org/webt/14/ef/xe/14efxewawb3ttgslcsxyzicgjy0.png"><br><a name="habracut"></a><br><blockquote>  <b>Attention</b> : if you like watching presentations more than reading articles, then watch this <a href="https://youtu.be/5nmpokoRaZI">video</a> .  If not, then skip it and read on. </blockquote>  <b>Pipeline (engine) JavaScript engine</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It all starts with the fact that you write code in JavaScript.  After that, the JavaScript engine processes the source code and presents it as an abstract syntax tree (AST).  Based on the AST built, the interpreter can finally get to work and start generating bytecode.  Fine!  This moment the engine executes JavaScript code. <br><br><img src="https://habrastorage.org/webt/i6/8r/f2/i68rf23urqlxa20gzhubwz2-snq.jpeg"><br><br>  So that it is executed faster, you can send bytecode to the optimizing compiler along with the profiling data.  The optimizing compiler makes certain assumptions based on the profiling data, then it generates highly optimized machine code. <br><br>  If at some point the assumptions are wrong, the optimizing compiler deoptimizes the code and returns to the interpreter stage. <br><br>  <b>Interpreter / compiler pipelines in JavaScript engines</b> <br><br>  And now let's take a closer look at the parts of the pipeline that execute your JavaScript code, namely where the code is interpreted and optimized, and also consider some of the differences between the main JavaScript engines. <br><br>  At the heart of everything is pipeline, which contains an interpreter and an optimizing compiler.  The interpreter quickly generates a non-optimized bytecode, the optimizing compiler, in turn, runs longer, but the output has highly optimized machine code. <br><br><img src="https://habrastorage.org/webt/gh/ap/o6/ghapo68sxzyqniyjqw0v0xewpry.jpeg"><br><br>  Next is the pipeline, which shows exactly how V8 works, the JavaScript engine that is used by Chrome and Node.js. <br><br><img src="https://habrastorage.org/webt/8i/nu/0w/8inu0wkuzc8_enexkp8o7pn7jgi.jpeg"><br><br>  The interpreter in V8 is called Ignition, it is responsible for the generation and execution of bytecode.  It collects profiling data that can be used to speed up execution in the next step while bytecode is being processed.  When a function gets <i>hot</i> , for example, if it runs frequently, the generated bytecode and profiling data is transferred to the Turbo Fan (TurboFan), that is, to the optimizing compiler to generate highly optimized machine code based on the profiling data. <br><br><img src="https://habrastorage.org/webt/ww/n5/zi/wwn5zi7l8vzzcfaik86qwhdtprc.jpeg"><br><br>  For example, the Mozilla JavaScript SpiderMonkey engine, which is used in Firefox and <a href="https://github.com/mozilla/spidernode">SpiderNode</a> , works a little differently.  There is not one but two optimizing compilers in it.  The interpreter is optimized to the base compiler (Baseline compiler), which produces in some way optimized code.  Together with the profiling data collected during the execution of the code, the IonMonkey compiler can generate a heavily optimized code.  If speculative optimization fails, IonMonkey returns to the base code (Baseline code). <br><br><img src="https://habrastorage.org/webt/gu/ek/ps/guekpsu0p1nqwv-pynj7ts8skdo.jpeg"><br><br>  Chakra - Microsoft's JavaScript engine, used in Edge and <a href="https://github.com/nodejs/node-chakracore">Node-ChakraCore</a> , has a very similar structure and uses two optimizing compilers.  The interpreter is optimized in SimpleJIT (where JIT means ‚ÄúJust-In-Time compiler‚Äù, which produces some optimized code. Together with profiling data, FullJIT can create even more highly optimized code. <br><br><img src="https://habrastorage.org/webt/z-/bl/0v/z-bl0va0qlsrvgandnxrb08q52g.jpeg"><br><br>  JavaScriptCore (abbreviated as JSC), Apple's JavaScript engine that is used in Safari and React Native, generally has three different optimizing compilers.  LLInt is a low-level interpreter, optimized to the basic compiler, which in turn is optimized in the DFG (Data Flow Graph) compiler, and it is already optimized in the FTL (Faster Than Light) compiler. <br><br>  Why do some engines have more optimizing compilers than others?  Here it‚Äôs all a matter of compromise.  The interpreter can quickly handle bytecode, but bytecode itself is not very efficient.  An optimizing compiler, on the other hand, runs a little longer, but produces more efficient machine code.  This is a trade-off between fast code generation (interpreter) or some waiting and running code with maximum performance (optimizing compiler).  Some engines choose the addition of several optimizing compilers with different characteristics of time and efficiency, which allows to provide the best control over this compromise solution and to understand the cost of additional complication of the internal structure.  Another trade-off relates to the use of memory, take a look at this <a href="https://mathiasbynens.be/notes/prototypes">article</a> to get a better understanding of it. <br><br>  We have just reviewed the main differences between pipelines of interpreters and optimizing compilers for various JavaScript engines.  Despite these high-level differences, all JavaScript engines have the same architecture: they all have a parser and some kind of interpreter / compiler pipeline. <br><br>  <b>JavaScript object model</b> <br><br>  Let's see what else is common in the JavaScript engines and what methods do they use to speed up access to the properties of JavaScript objects?  It turns out that all the main engines do it in a similar way. <br><br>  The ECMAScript specification defines all objects as dictionaries with string keys mapped to <a href="https://tc39.github.io/ecma262/">property</a> attributes. <br><br><img src="https://habrastorage.org/webt/7s/vv/qq/7svvqqqqfcqi2y-v88nlstidtik.jpeg"><br><br>  In addition to the <code>[[Value]]</code> , the specification defines the following properties: <br><br><ul><li>  <code>[[Writable]]</code> determines whether a property can be reassigned; </li><li>  <code>[[Enumerable]]</code> determines whether the property is displayed in for-in loops; </li><li>  <code>[[Configurable]]</code> determines whether the property can be deleted. </li></ul><br>  The notation <code>[[  ]]</code> looks strange, but this is how the specification describes properties in JavaScript.  You can still get these property attributes for any given object and property in JavaScript using the <code>Object.getOwnPropertyDescriptor</code> API: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí { value: 42, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br>  Well, so JavaScript defines objects.  What about arrays? <br><br>  You can imagine for yourself arrays, as special objects.  The only difference is that arrays have special handling of indexes.  Here the array index is a special term in the ECMAScript specification.  In JavaScript, there are limitations on the number of elements in the array - up to 2¬≥¬≤ ‚àí 1.  An array index is any available index from this range, that is, any integer value from 0 to 2¬≥¬≤ ‚Äì 2. <br><br>  Another difference is that arrays have the magic property <code>length</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; array.length; <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 2 array[2] = 'c'; array.length; // ‚Üí 3</span></span></code> </pre> <br>  In this example, the array has a length of 2 at the time of creation.  Then we assign another element to index 2 and the length is automatically increased. <br><br>  JavaScript defines arrays as well as objects.  For example, all keys, including array indices, are represented explicitly as strings.  The first element of the array is stored under the key '0'. <br><br><img src="https://habrastorage.org/webt/a0/nr/18/a0nr18etozy9wzmzzsd9zbykxt0.jpeg"><br><br>  The <code>length</code> property is just another property that turns out to be non-enumerable and non-configurable. <br><br>  As soon as an element is added to the array, JavaScript automatically updates the <code>[[Value]]</code> property of the <code>length</code> property. <br><br><img src="https://habrastorage.org/webt/ws/hs/89/wshs896vflemplsrai-wqu5brkw.jpeg"><br><br>  In general, it can be said that arrays behave similarly to objects. <br><br>  <b>Property Access Optimization</b> <br><br>  Now that we know how objects are defined in JavaScript, let's take a look at how JavaScript engines allow you to work with objects efficiently. <br><br>  In everyday life, access to properties is the most common operation.  It's extremely important for the engine to do this quickly. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">'qux'</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Here, we're accessing the property `foo` on `object`: doSomething(object.foo); // ^^^^^^^^^^</span></span></code> </pre> <br>  <b>Forms</b> <br><br>  In JavaScript programs, a fairly common practice is to assign many objects the same property keys.  It is said that such objects have the same <i>shape (shape)</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// `object1` and `object2` have the same shape.</span></span></code> </pre> <br>  Also the usual mechanics is access to the property of objects of one form: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object.x); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^ } const object1 = { x: 1, y: 2 }; const object2 = { x: 3, y: 4 }; logX(object1); logX(object2);</span></span></code> </pre> <br>  Knowing this, JavaScript engines can optimize access to the property of an object based on its shape.  See how it works. <br><br>  Suppose we have an object with x and y properties, it uses the data structure dictionary, which we talked about earlier;  it contains key strings that point to their respective attributes. <br><br><img src="https://habrastorage.org/webt/ss/ne/v9/ssnev9md3jko58annrfjraz35ay.jpeg"><br><br>  If you are accessing a property, such as <code>object.y,</code> the JavaScript engine searches for a JSObject using the <code>'y'</code> key, then loads the attributes of the properties that correspond to this request, and finally returns <code>[[Value]]</code> . <br><br>  But where are these property attributes stored in memory?  Should we store them as part of a JSObject?  If we do this, we will see more objects of this form later, in this case, a waste of space - to keep a complete dictionary containing the names of properties and attributes in the JSObject itself, since the property names are repeated for all objects of the same form.  This causes a lot of duplication and leads to poor memory usage.  To optimize the engines keep the shape of the object separately. <br><br><img src="https://habrastorage.org/webt/mc/yr/mt/mcyrmt9jarqodgtvnwoxzatiwyy.jpeg"><br><br>  This form ( <code>Shape</code> ) contains all property names and attributes, except <code>[[Value]]</code> .  Instead, the form contains an offset ( <code>offset</code> ) of the values ‚Äã‚Äãinside the JSObject, so the JavaScript engine knows where to look for the values.  Each JSObject with a common form points to a specific form instance.  Now every JSObject has to store only values ‚Äã‚Äãunique to the object. <br><br><img src="https://habrastorage.org/webt/-0/-q/t5/-0-qt5an58iyuoeskzaibbtgcno.jpeg"><br><br>  The advantage becomes obvious as soon as we have a lot of objects.  Their number does not matter, because if they have one form, we save information about the form and property only once. <br><br>  All JavaScript engines use forms as a means of optimization, but they do not call them directly shapes ( <code>shapes</code> ): <br><br><ol><li>  Academic documentation calls them Hidden Classes (similar to classes in JavaScript); </li><li>  V8 calls them Maps; </li><li>  Chakra calls them Types; </li><li>  JavaScriptCore calls them Structures; </li><li>  SpiderMonkey calls them Shapes. </li></ol><br>  In this article we will continue to call them <code>shapes</code> . <br><br>  <b>Transition chains and trees</b> <br><br>  What happens if you have an object of a certain shape, but do you add a new property to it?  How does the JavaScript engine define a new form? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = {}; object.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; object.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Forms create the so-called transition chains (transition chains) in the JavaScript engine.  Here is an example: <br><br><img src="https://habrastorage.org/webt/tm/tz/np/tmtznpiuyzkz9vpxqe6byhw2x-k.jpeg"><br><br>  The object initially has no properties; it corresponds with the empty form.  The following expression adds the property <code>'x'</code> with a value of 5 to this object, then the engine goes to the form that contains the property <code>'x'</code> and the value 5 is added to the JSObject at the first offset of 0. The next line adds the property <code>'y'</code> , then the engine moves to the next a form that already contains both <code>'x'</code> and <code>'y'</code> , and also adds the value 6 to the JSObject at offset 1. <br><blockquote>  <b>Caution</b> : The sequence in which properties are added affects the shape.  For example, {x: 4, y: 5} will lead to a different form than {y: 5, x: 4}. <br></blockquote>  We do not even need to store the entire property sheet for each form.  Instead, each form needs to know only the new property that they are trying to include in it.  For example, in such a case, we do not need to store information about the 'x' in the latter form, since it can be found earlier in the chain.  For this to work, the form connects with its previous form. <br><br><img src="https://habrastorage.org/webt/ks/ou/pv/ksoupve8bep3jsp0v7u2ahyv9jg.jpeg"><br><br>  If you write <code>ox</code> in your JavaScript code, JavaScript will search for the <code>'x'</code> property along the transition chain, until it finds a form that already has the <code>'x'</code> property in it. <br><br>  But what happens if it is impossible to create a transitional circuit?  For example, what happens if you have two empty objects and add different properties to them? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; object2.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  In this case, we have a branch, and instead of the transition chain, we get a transition tree: <br><br><img src="https://habrastorage.org/webt/bc/ga/ax/bcgaaxeskfqwqt8geu_pxmqwdou.jpeg"><br><br>  We create an empty object <code>a</code> and add the property <code>'x'</code> .  As a result, we have a <code>JSObject</code> containing a single value and two forms: empty and a form with a single property <code>'x'</code> . <br><br>  The second example starts with the fact that we have an empty object <code>b</code> , but then we add another property <code>'y'</code> .  As a result, here we have two chains of forms, and in the end there are three chains. <br><br>  Does this mean that we always start with an empty form?  Not necessary.  The engines apply some optimization of object literals ( <code>object literal</code> ), which already contain properties.  Let's say that we add x, starting with an empty object literal, or we have an object literal that already contains <code>x</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> };</code> </pre> <br>  In the first example, we start with an empty form and a transition to a chain that also contains <code>x</code> , as well as we saw earlier. <br><br>  In the case of <code>object2</code> it makes sense to directly create objects that already have x from the very beginning, rather than starting with an empty object and a transition. <br><br><img src="https://habrastorage.org/webt/qv/_0/l-/qv_0l-f5eekqflfmto7lfd-awwq.jpeg"><br><br>  The literal of an object that contains the property <code>'x'</code> starts with a form that contains <code>'x'</code> from the very beginning, and the empty form is effectively skipped.  This is what (at least) what V8 and SpiderMonkey do.  Optimization shortens the transition chain and makes it easier to assemble objects from literals. <br><br>  A post on Benedict's blog about the amazing polymorphism of applications on <a href="https://medium.com/%40bmeurer/surprising-polymorphism-in-react-applications-63015b50abc">React</a> talks about how such subtleties can affect performance. <br><br>  Next you will see an example of points of a three-dimensional object with the properties <code>'x'</code> , <code>'y'</code> , <code>'z'</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = {}; point.x = <span class="hljs-number"><span class="hljs-number">4</span></span>; point.y = <span class="hljs-number"><span class="hljs-number">5</span></span>; point.z = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  As you understood earlier, we create an object with three forms in memory (not counting the empty form).  To access the <code>'x'</code> property of this object, for example, if you write <code>point.x</code> in your program, the JavaScript engine must follow a linked list: starting with the form at the bottom, and then gradually stepping up to the form that has <code>'x'</code> at the top. <br><br><img src="https://habrastorage.org/webt/tv/rn/mp/tvrnmp1s5p25dseplockgifr6x0.jpeg"><br><br>  It turns out very slowly, especially if you do it often and with a large number of properties of the object.  The time of finding the property is <code>O(n)</code> , that is, it is a linear function that correlates with the number of properties of the object.  To speed up searching by properties, JavaScript engines add a ShapeTable data structure.  ShapeTable is a dictionary where the keys are mapped in a certain way with the forms and give the desired property. <br><br><img src="https://habrastorage.org/webt/y8/vh/40/y8vh40rwdlx99jdv-rpumbe1u3u.jpeg"><br><br>  Wait a second, now we return to the dictionary search ... This is exactly what we started with when we put the forms in the first place!  So why do we even care about forms? <br>  The fact is that forms contribute to another optimization, which is called <i>Inline Caches.</i> <br><br>  We will talk about the concept of inline caches or ICs in the <a href="https://habr.com/ru/company/otus/blog/447220/">second part of the</a> article, and now we want to invite you to a <a href="https://otus.pw/mpEp/">free open webinar</a> , which is already held on April 9 by a well-known virus analyst and part-time our teacher, <a href="https://otus.pw/6MAn/">Alexander Kolesnikov</a> . </div><p>Source: <a href="https://habr.com/ru/post/446446/">https://habr.com/ru/post/446446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446436/index.html">How to generate hypotheses about the needs of potential consumers of your future product</a></li>
<li><a href="../446438/index.html">Our experience in creating API Gateway</a></li>
<li><a href="../446440/index.html">The book "React quickly. Web applications on React, JSX, Redux and GraphQL ¬ª</a></li>
<li><a href="../446442/index.html">Happy Party or a couple of memory lines about your introduction to PostgreSQL10 partitioning</a></li>
<li><a href="../446444/index.html">From Skype to WebRTC: how we organized video calling over the web</a></li>
<li><a href="../446448/index.html">5 basic rules for conducting problem interviews to identify consumer needs</a></li>
<li><a href="../446452/index.html">Lunar mission "Bereshit" - April 4, 2019 made a transition to lunar orbit, ahead of 7 days of flight, 6 maneuvers and 1 landing</a></li>
<li><a href="../446454/index.html">Web server development on Golang - from easy to hard</a></li>
<li><a href="../446456/index.html">Import substitution in practice. Part 1. Options</a></li>
<li><a href="../446458/index.html">Universal DRO based on Arduino Nano - shDRO. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>