<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to work with multiple queries. Composition, Reducer, OP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. My name is Maxim, I am an iOS developer at FINCH. Today I will show you some of the functional programming practices that we have developed ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to work with multiple queries. Composition, Reducer, OP</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr.  My name is Maxim, I am an iOS developer at FINCH.  Today I will show you some of the functional programming practices that we have developed in our department. <br><a name="habracut"></a><br>  I want to note right away that I do not urge you to use functional programming everywhere - this is not a panacea for all problems.  But it seems to me that in some cases, the OP can provide the most flexible and elegant solutions to non-standard tasks. <br><br>  OP is a popular concept, so I will not explain the basics.  I am sure that you are already using map, reduce, compactMap, first (where :) and similar technologies in your projects.  The article focuses on solving the problem of multiple queries and working with a reducer. <br><br><h3>  The problem of multiple queries </h3><br>  I work in outsourcing production, and there are situations when a client with his subcontractors takes over the creation of a backend.  This is not the most convenient backend and you have to do multiple and parallel requests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Sometimes I could write something like: <br><br><pre><code class="swift hljs">networkClient.sendRequest(request1) { result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response1): <span class="hljs-comment"><span class="hljs-comment">// ... self.networkClient.sendRequest(request2) { result in // ... switch result { case .success(let response2): // ...  -     response self.networkClient.sendRequest(request3) { result in switch result { case .success(let response3): // ...  -     completion(Result.success(response3)) case .failure(let error): completion(Result.failure(.description(error))) } } case .failure(let error): completionHandler(Result.failure(.description(error))) } } case .failure(let error): completionHandler(Result.failure(.description(error))) } }</span></span></code> </pre> <br>  Disgusting, right?  But this is the reality with which I needed to work. <br><br>  I had to send three consecutive requests for authorization.  During refactoring, I thought it would be a good idea to break up each request for individual methods and call them inside the completion, thereby unloading one huge method.  It turned out something like: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">obtainUserStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Result&lt;AuthResponse&gt;)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> endpoint= <span class="hljs-type"><span class="hljs-type">AuthEndpoint</span></span>.loginRoute networkService.request(endpoint: endpoint, cachingEnabled: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (result: <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">LoginRouteResponse</span></span>&gt;) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response): <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.obtainLoginResponse(response: response, completion: completion) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error): completion(.failure(error)) } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">obtainLoginResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> response: LoginRouteResponse, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Result&lt;AuthResponse&gt;)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> endpoint= <span class="hljs-type"><span class="hljs-type">AuthEndpoint</span></span>.login networkService.request(endpoint: endpoint, cachingEnabled: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (result: <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">LoginResponse</span></span>&gt;) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response): <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.obtainAuthResponse(response: response, completion: completion) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error): completion(.failure(error)) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">obtainAuthResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> response: LoginResponse, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Result&lt;AuthResponse&gt;)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> endpoint= <span class="hljs-type"><span class="hljs-type">AuthEndpoint</span></span>.auth networkService.request(endpoint: endpoint, cachingEnabled: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { (result: <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">AuthResponse</span></span>&gt;) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> completion(result) } }</code> </pre> <br>  It can be seen that in each of the private methods I have to proxy <br><br><pre> <code class="swift hljs">completion: @escaping (<span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">AuthResponse</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span></code> </pre> <br>  and I do not really like it. <br><br>  Then the thought came to me - ‚ÄúWhy not resort to functional programming?‚Äù Besides, the swift, with its magic and syntactic sugar, makes it interesting and convenient to break the code into separate elements. <br><br><h2>  Composition and Reducer </h2><br>  Functional programming is closely related to the concept of composition - mixing, combining something.  In functional programming, the composition assumes that we combine the behavior of individual blocks, and then, later on, work with it. <br><br>  Composition from a mathematical point of view is something like: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-function">&lt;A,B,C&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>, and g: @escaping (<span class="hljs-type"><span class="hljs-type">B</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">C</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">C</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> g(f(a)) } }</code> </pre> <br>  There are functions f and g, which internally define the output and input parameters.  We want to get some resultant behavior from these input methods. <br><br>  As an example, you can make two closure, one of which increases the input number by 1, and the second multiplies by itself. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> increment: (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = { value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value + <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> multiply: (<span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = { value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * value }</code> </pre> <br>  As a result, we want to apply both of these operations: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = compose(multiply, and: increment) result(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     101</span></span></code> </pre><br><br>  Unfortunately my example is not associative. <br>  (if we swap the increment and multiply, then we get the number 121), but for now let us omit this moment. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = compose(increment, and: multiply) result(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     121</span></span></code> </pre><br>  PS I specifically try to make my examples simpler so that it is as clear as possible) <br><br>  In practice, you often need to do something like this: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = array .<span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> .<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span> } .first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { $<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; <span class="hljs-number"><span class="hljs-number">10</span></span> })</code> </pre><br>  This is the composition.  We set the input action and get some output action.  But this is not just the addition of some objects - this is the addition of a whole behavior. <br><br><h3>  And now let's think more abstract :) </h3><br>  In our application, we have a state.  This may be the screen that the user is currently seeing or current data that is stored in the application, etc. <br>  In addition, we have an action - this is the action that the user can do (press a button, check the collection, close the application, etc.).  As a result, we operate with these two concepts and connect them with each other, that is, we combine, hmmm, we combine (I heard it somewhere). <br><br>  And what if you create an entity that just combines my state and action together? <br><br>  So we get a Reducer <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reducer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>: (<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">S</span></span> }</code> </pre><br>  At the input of the reduce method, we will give the current state and action, and at the output we will get a new state that was formed inside the reduce. <br><br>  We can describe this structure in several ways: by specifying a new state, using a functional method or using mutable models. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reducer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>: (<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">S</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reducer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>: (<span class="hljs-type"><span class="hljs-type">S</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">S</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reducer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>: (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> }</code> </pre> <br>  The first option is "classic". <br><br>  The second is more functional.  The point is that we do not return a state, but a method that accepts action, which in turn returns a state.  In essence, this is a currying of the reduce method. <br><br>  The third option is to work with state by reference.  With this approach, we do not just issue the state, but work with a link to the object that comes in.  It seems to me that this method is not very good, because similar (mutable) models are bad.  It is better to reassemble the new state (instance) and return it.  But for simplicity and to demonstrate further examples, we agree to use the last option. <br><br><h3>  Application reducer </h3><br>  Let's apply the Reducer concept to the existing code - create RequestState, then initialize it, and set it. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestState</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MARK: - Private properties private let semaphore = DispatchSemaphore(value: 0) private let networkClient: NetworkClient = NetworkClientImp() // MARK: - Public methods func sendRequest&lt;Response: Codable&gt;(_ request: RequestProtocol, completion: ((Result&lt;Response&gt;) -&gt; Void)?) { networkClient.sendRequest(request) { (result: Result&lt;Response&gt;) in completion?(result) self.semaphore.signal() } semaphore.wait() } }</span></span></code> </pre> <br>  For query synchronization, I added the DispatchSemaphore <br><br>  Go ahead.  Now we need to create RequestAction with, say, three requests. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sendFirstRequest(<span class="hljs-type"><span class="hljs-type">FirstRequest</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sendSecondRequest(<span class="hljs-type"><span class="hljs-type">SecondRequest</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sendThirdRequest(<span class="hljs-type"><span class="hljs-type">ThirdRequest</span></span>) }</code> </pre> <br>  Now create a Reducer that has RequestState and RequestAction.  We set the behavior - what we want to do at the first, second, third request. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> requestReducer = <span class="hljs-type"><span class="hljs-type">Reducer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">RequestState</span></span>, <span class="hljs-type"><span class="hljs-type">RequestAction</span></span>&gt; { state, action <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> action { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .sendFirstRequest(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request): state.sendRequest(request) { (result: <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">FirstResponse</span></span>&gt;) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1 Response } case .sendSecondRequest(let request): state.sendRequest(request) { (result: Result&lt;SecondResponse&gt;) in // 2 Response } case .sendThirdRequest(let request): state.sendRequest(request) { (result: Result&lt;ThirdResponse&gt;) in // 3 Response } } }</span></span></code> </pre> <br>  In the end, we call these methods.  It turns out a more declarative style, in which it is clear that the first, second and third requests are being made.  Everything is readable and clearly. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = <span class="hljs-type"><span class="hljs-type">RequestState</span></span>() requestReducer.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(&amp;state, .sendFirstRequest(<span class="hljs-type"><span class="hljs-type">FirstRequest</span></span>())) requestReducer.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(&amp;state, .sendSecondRequest(<span class="hljs-type"><span class="hljs-type">SecondRequest</span></span>())) requestReducer.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(&amp;state, .sendThirdRequest(<span class="hljs-type"><span class="hljs-type">ThirdRequest</span></span>()))</code> </pre><br><h3>  Conclusion </h3><br>  Do not be afraid to learn new things and do not be afraid to learn functional programming.  I think that the best practices are at the junction of technology.  Try to combine and take better from different programming paradigms. <br><br>  If there is some nontrivial task, then it makes sense to look at it from a different angle. </div><p>Source: <a href="https://habr.com/ru/post/455840/">https://habr.com/ru/post/455840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45583/index.html">O'Reilly about keeping tempting profits in the Clouds with a translator afterword</a></li>
<li><a href="../455830/index.html">A look at Go through the eyes of a .NET developer. Week # 1</a></li>
<li><a href="../455832/index.html">The story of a single SQL investigation</a></li>
<li><a href="../455834/index.html">Benchmarks for Linux servers: 5 open tools</a></li>
<li><a href="../45584/index.html">Amarok 2 RC1 came out and is in the repositories.</a></li>
<li><a href="../455842/index.html">Double-page list rotation. Swift Edition</a></li>
<li><a href="../455844/index.html">Creating a Roslyn analyzer using the encapsulation test as an example</a></li>
<li><a href="../455846/index.html">Distributed computing in Julia</a></li>
<li><a href="../455852/index.html">Sinus lifting and simultaneous implantation</a></li>
<li><a href="../455854/index.html">How to implement context menus (Context Menu) in iOS 13</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>