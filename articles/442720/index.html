<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast generalization of markers on a WebGL card</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Markers are a good thing. Useful in reasonable quantities. When there are too many of them, the benefits disappear. What to do if you want to mark on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast generalization of markers on a WebGL card</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/wl/if/9y/wlif9yuvumhoa16egkvqphgdzyo.png" alt="image"></p><br><p>  Markers are a good thing.  Useful in reasonable quantities.  When there are too many of them, the benefits disappear.  What to do if you want to mark on the map the search results, in which tens of thousands of objects?  In the article I will tell how we solve this problem on the WebGL-card without prejudice to its appearance and performance. </p><a name="habracut"></a><br><h1 id="predystoriya">  Prehistory </h1><br><p>  In 2016, 2GIS launched its first project on WebGL - Floors: three-dimensional floor plans of buildings. </p><br><p><img src="https://habrastorage.org/webt/dt/90/4v/dt904vhpl-gjcyju0tuf_n-nefc.png" alt="image"><br>  <em>Floors of the Novosibirsk shopping center Aura</em> </p><br><p>  Immediately after the release of the Floors, our team began developing a full-fledged three-dimensional mapping engine on WebGL.  The engine was developed in conjunction with the new version of 2gis.ru and is now in the status of a <a href="https://beta.2gis.ru/">public beta</a> . </p><br><p><img src="https://habrastorage.org/webt/_9/nl/q9/_9nlq9yh87m2vbaznj3_tvji6q8.png" alt="image"><br>  <em>Red Square, drawn on WebGL.</em>  <em>Building plans are now built right into the map.</em> </p><br><h1 id="zadacha-generalizacii-podpisey">  The task of the generalization of signatures </h1><br><p>  Anyone who wants to write their own mapping engine, sooner or later will face the problem of placing signatures on the map.  There are many objects on the map, and it is impossible to sign each one so that the signatures do not overlap with each other. </p><br><p><img src="https://habrastorage.org/webt/si/0j/cf/si0jcfdcbaz8tqeazopjba1f1b8.png" alt="image"><br>  <em>What will happen if in Novosibirsk to sign all objects at once?</em> </p><br><p>  To solve this problem, <a href="https://en.wikipedia.org/wiki/Cartographic_generalization">generalization of</a> signatures is necessary.  Generalization in a general sense - the transformation of map data in such a way that they are suitable for display on small scales.  It can be done by different methods.  For signatures, the method of selection is usually used: from the total number, a subset of the highest priority signatures is chosen that do not overlap with each other. </p><br><p>  Signature priority is determined by its type, as well as the current scale of the map.  For example, with a small scale, signatures of cities and countries are needed, and with a large scale, signatures of roads and house numbers become more important.  Often the priority of the name of a settlement is determined by the size of its population.  The larger it is, the more important the signature. </p><br><p>  Generalization is required not only for signatures, but also for markers that mark search results on the map.  For example, when searching for "store" in Moscow there are more than 15,000 results.  To mark them all on the map at once is obviously a bad idea. </p><br><p><img src="https://habrastorage.org/webt/2a/in/jj/2ainjj57s8zfmdjv4103va5trqm.png" alt="image"><br>  <em>All shops of Moscow on the map.</em>  <em>Without generalization can not do here</em> </p><br><p>  Any user interaction with the map (movement, zooming, rotation and tilt) changes the position of the markers on the screen, so the generalization must be able to recalculate on the fly.  Therefore, it must be fast. </p><br><p>  In this article, using the example of generalization of markers, I will show different ways to solve this problem, which were used in our projects at different times. </p><br><h1 id="obschiy-podhod-k-generalizacii">  General approach to generalization </h1><br><ol><li>  Project each marker into the screen plane and calculate the sound for it - a rectangular area that it occupies on the screen. </li><li>  Sort the markers by priority. </li><li>  Sequentially examine each marker and place it on the screen if it does not intersect with other markers placed in front of it. </li></ol><br><p>  With paragraph 1, everything is clear - it's just a calculation.  With point 2, we are also lucky: the list of markers that comes to us from the backend is already ordered by the priority of the search algorithms.  At the top of the issue get the most relevant results that are most likely to be of interest to the user. </p><br><p>  The main problem is in point 3: the time it takes to calculate the generalization can strongly depend on how it is implemented. </p><br><p>  To search for intersections between markers, we need some data structure that: </p><br><ol><li>  Stores bounds of markers added to the screen. </li><li> It has a <code>insert(marker)</code> method to add a marker to the screen. </li><li>  It has a <code>collides(marker)</code> method to check the marker for intersection with those already added to the screen. </li></ol><br><p>  Consider several implementations of this structure.  All further examples will be written in TypeScript, which we use in most of our projects.  In all examples, markers will be represented by objects of the following form: </p><br><pre> <code class="plaintext hljs">interface Marker { minX: number; maxX: number; minY: number; maxY: number; }</code> </pre> <br><p>  All considered approaches will be implementations of the following interface: </p><br><pre> <code class="plaintext hljs">interface CollisionDetector { insert(item: Marker): void; collides(item: Marker): boolean; }</code> </pre> <br><p>  For performance comparison, the execution time of the following code will be measured: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!impl.collides(marker)) { impl.insert(marker); } }</code> </pre> <br><p>  The <code>markers</code> array will contain 100,000 30x50 items randomly placed on a 1920x1080 size plane. </p><br><p>  Performance will be measured on Macbook Air 2012. </p><br><p>  The tests and code samples provided in the article are also <a href="https://github.com/RLRR/collision-buffer-research">posted on GitHub</a> . </p><br><h1 id="naivnaya-realizaciya">  Naive implementation </h1><br><p>  To begin, consider the simplest option when the marker is checked for intersection with the rest in a simple cycle. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NaiveImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private markers: Marker[]; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers = []; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers.push(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( candidate.minX &lt;= marker.maxX &amp;&amp; candidate.minY &lt;= marker.maxY &amp;&amp; candidate.maxX &gt;= marker.minX &amp;&amp; candidate.maxY &gt;= marker.minY ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Calculation time of generalization for 100,000 markers: <strong>420 ms</strong> .  Too much.  Even if the calculation of generalization goes in the web worker and does not block the main thread, such a delay will be noticeable, especially since this operation must be performed after each movement of the map.  Moreover, on mobile devices with a weak processor, the delay can be even greater. </p><br><h1 id="realizaciya-s-primeneniem-r-dereva">  Implementation using R-tree </h1><br><p>  Since in a naive implementation, each marker is checked for intersection with all the previous ones, in the worst case, the complexity of this algorithm is quadratic.  You can improve it by applying the R-tree data structure.  As an implementation of an R-tree, take the <a href="https://github.com/mourner/rbush">RBush</a> library: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> rbush <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rbush'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RTreeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private tree: rbush.RBush&lt;Marker&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree = rbush(); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.insert(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.collides(candidate); } }</code> </pre> <br><p>  Calculation time of generalization for 100,000 markers: <strong>173 ms</strong> .  Much better.  We applied this approach in the Floors (this was mentioned in <a href="https://habr.com/ru/company/2gis/blog/282207/">my previous article</a> ). </p><br><p><img src="https://habrastorage.org/webt/44/mp/v5/44mpv5pc8gwyqr4jfr5mqcibwqu.png" alt="image"><br>  <em>Visualize the storage of points in the R-tree.</em>  <em>Hierarchical division of the plane into rectangles allows you to quickly narrow the search area and not to iterate over all objects</em> </p><br><h1 id="realizaciya-s-primeneniem-bufera-kolliziy">  Implementing with a collision buffer </h1><br><p>  Drawing a map is a much more difficult task than drawing a plan for one building.  This is manifested in generalization.  Even in the largest shopping centers in the world, there are rarely 1,000 organizations on one floor.  At the same time, a simple search query in a large city can return tens of thousands of results. </p><br><p>  When we started developing the WebGL map, we began to think: is it possible to further accelerate the generalization.  An interesting idea was then suggested to us by the <a href="https://habr.com/ru/users/stellarator/" class="user_link">stellarator</a> working for us: instead of an R-tree, use a buffer in which to store the state of each pixel of the screen (busy or not busy).  When inserting a marker on the screen, ‚Äúpaint over‚Äù the corresponding place in the buffer, and when checking the possibility of insertion, check the pixel values ‚Äã‚Äãin the required area. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferByteImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; private height: number; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(width * height); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = candidate; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Calculation time of generalization for 100,000 markers: <strong>46 ms</strong> . </p><br><p>  Why so fast?  At first glance, this approach seems to be naive, and the nested loops in both methods are not similar to fast code.  However, if you take a closer look at the code, you will notice that the execution time of both methods does not depend on the total number of markers.  Thus, at a fixed size of the WxH markers, we obtain the labor intensity O (W * H * n), that is, linear! </p><br><h1 id="optimizaciya-podhoda-s-buferom-kolliziy">  Optimized collision buffer approach </h1><br><p>  It is possible to improve the previous approach both in speed and memory, if we make it so that one pixel is represented in memory not by one byte, but by one bit.  The code after this optimization, however, is noticeably more complicated and overgrown with some amount of bitwise magic: </p><br><div class="spoiler">  <b class="spoiler_title">Source</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferBitImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private width: number; private height: number; private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.ceil(width / <span class="hljs-number"><span class="hljs-number">8</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height / <span class="hljs-number"><span class="hljs-number">8</span></span>); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { buffer[i] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } buffer[end] = buffer[end] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } } } collides(marker: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { sum = buffer[i] | sum; } sum = buffer[end] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))) | sum; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> </div></div><br><p>  Calculation time of generalization for 100,000 markers: <strong>16 ms</strong> .  As we see, the complication of logic justifies itself and allows us to accelerate the calculation of generalization almost three times more. </p><br><h1 id="ogranicheniya-bufera-kolliziy">  Collision Buffer Limitations </h1><br><p>  It is important to understand that the collision buffer is not a complete replacement for the R-tree.  It has much less features and more restrictions: </p><br><ol><li>  It is impossible to understand exactly what the marker intersects with.  The buffer only stores data on which pixels are occupied and which are not.  Therefore, it is impossible to implement an operation that returns a list of markers intersecting with the given. </li><li>  Cannot delete previously added marker.  The buffer does not store data about how many markers are in a given pixel.  Therefore, it is impossible to correctly implement the operation of removing the marker from the buffer. </li><li>  High sensitivity to the size of the elements.  If you try to add to the collision buffer markers that occupy the entire screen, the performance drops sharply. </li><li>  Works in a limited area.  The size of the buffer is set when it is created, and it is impossible to place a marker in it that goes beyond this size.  Therefore, when using this approach, it is necessary to manually filter out markers that do not fall on the screen. </li></ol><br><p>  All these restrictions did not prevent the solution of the task of generalization of the markers.  Now this method is successfully used for markers in beta 2gis.ru. </p><br><p>  However, to generalize the main signatures on the map, the requirements are more complex.  For example, for them it is necessary to do so that the POI icon could not ‚Äúkill‚Äù its own signature.  Since the collision buffer does not distinguish exactly with what intersection occurred, it does not allow implementing such logic.  Therefore, they had to leave the decision with RBush. </p><br><h1 id="vyvod">  Conclusion </h1><br><p><img src="https://habrastorage.org/webt/cl/ey/uq/cleyuqjc1utr1xm4elsi2g_uxxs.png" alt="image"><br>  The article shows the path we have gone from the simplest solution to the one used now. </p><br><p>  The use of the R-tree was the first important step that allowed us to speed up the naive implementation.  It works fine in Floors, but in fact we use only a small part of the capabilities of this data structure. </p><br><p>  By abandoning the R-tree and replacing it with a simple two-dimensional array, which does exactly what we need, and nothing but this, we have an even greater increase in productivity. </p><br><p>  This example showed us how important it is, choosing a solution for a problem from several options, to understand and be aware of the limitations of each of them.  Restrictions are important and useful, and you should not be afraid of them: if you skillfully limit yourself to something irrelevant, you can get great benefit in return where you really need it.  For example, to simplify the solution of a problem, or to protect yourself from a whole class of problems, or, as in our case, at times improve performance. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/442720/">https://habr.com/ru/post/442720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442706/index.html">MySQL - Using Variables in Query</a></li>
<li><a href="../442712/index.html">According to sources: the controversial program of interception of the NSA is curtailed</a></li>
<li><a href="../442714/index.html">Like Defects</a></li>
<li><a href="../442716/index.html">Footcloths</a></li>
<li><a href="../442718/index.html">Google employees have discovered that work on a search engine version for China is ongoing.</a></li>
<li><a href="../442722/index.html">Stop pumping and storing zeros.</a></li>
<li><a href="../442724/index.html">The film "Office Space" 20 years: how he changed our jobs</a></li>
<li><a href="../442726/index.html">MIT's cheetah robot can do back flips and run fast</a></li>
<li><a href="../442730/index.html">Microsoft: Russia is ahead of the US and Europe in the implementation of artificial intelligence</a></li>
<li><a href="../442736/index.html">6 board games for upgrading English</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>