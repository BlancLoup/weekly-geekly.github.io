<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multi-release JARs - Bad or Good?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: we are actively working on translating the platform onto rails of Java 11 and are thinking about how to effectively develop Java ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multi-release JARs - Bad or Good?</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/cn/ee/cmcnee4gyidm3xbo-0fl1fatdme.png"></div><br><p>  <em>From the translator: we are actively working on translating the <a href="https://www.cuba-platform.com/">platform</a> onto rails of Java 11 and are thinking about how to effectively develop Java libraries (such as <a href="https://github.com/cuba-platform/yarg">YARG</a> ), taking into account the features of Java <a href="https://github.com/cuba-platform/yarg">8/11</a> , so that we do not have to make separate branches and releases.</em>  <em>One of the possible solutions is a multi-release JAR, but even this is not all smooth.</em> </p><br><p>  Java 9 includes a new Java runtime option called multi-release JARs.  This is probably one of the most controversial innovations in the platform.  <em>TL; DR: we consider this a crooked solution to a serious problem</em> .  In this post, we will explain why we think so, and also tell you how to build such a JAR if you really want. </p><br><p>  <a href="http://openjdk.java.net/jeps/238">Multi-release JARs</a> , or MR JARs, is a new feature of the Java platform, introduced in JDK 9. Here we will explain in detail about the significant risks associated with using this technology, and how to create multi-release JARs using Gradle, if you still want. </p><br><p>  In fact, a multi-release JAR is a Java archive that includes several variants of the same class for working with different versions of the execution environment.  For example, if you are working in JDK 8, the Java environment will use the class version for JDK 8, and if in Java 9, the version for Java 9 is used. Similarly, if the version is created for a future release of Java 10, runtime uses this version instead of the Java version 9 or the default version (java 8). </p><br><p>  Under the cut, we understand the device of the new JAR format and find out if this is all necessary. </p><a name="habracut"></a><br><h2 id="kogda-ispolzovat-multi-release-jars">  When to use multi-release JARs </h2><br><ul><li>  Optimized runtime.  This is a solution to the problem faced by many developers: when developing an application, it is not known in which environment it will be executed.  However, for some versions of the runtime, you can embed generic versions of the same class.  Suppose you want to display the version number of the Java in which the application is running.  For Java 9, you can use the Runtime.getVersion method.  However, this is a new method, available only in Java 9+.  If you need other runtimes, say, Java 8, you will have to parse the java.version property.  As a result, you will have 2 different implementations of one function. </li><li><p>  Conflicting APIs: resolving conflicts between APIs is also a common problem.  For example, you need to support two runtimes, but in one of them the API is deprecated.  There are 2 common solutions to this problem: </p><br><ol><li>  The first is reflection.  For example, you can set the VersionProvider interface, then 2 specific classes Java8VersionProvider and Java9VersionProvider, and load the corresponding class into runtime (funny that you have to parse the version number to choose between two classes!).  One of the variants of this solution is the creation of a single class with various methods, which are evoked through reflection. </li><li>  A more advanced solution is to use <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/invoke/MethodHandle.html">Method Handles</a> where possible.  Most likely, the reflection will seem to you brake and uncomfortable, and, in general, the way it is. </li></ol><br></li></ul><br><h2 id="izvestnye-alternativy-podhodu-multi-release-jars">  Known alternatives to multi-release JARs </h2><br><p>  The second way, which is simpler and easier to understand, is to create 2 different archives for different runtimes.  In theory, you create two implementations of the same class in the IDE, and compiling, testing and correctly packaging them into 2 different artifacts is the task of the build system.  This is the approach that has been used in Guava or Spock over the years.  But it is also required for languages ‚Äã‚Äãsuch as Scala.  And all because there are so many options for the compiler and runtime, that binary compatibility becomes almost unattainable. </p><br><p>  But there are many other reasons for using separate JAR archives: </p><br><ul><li>  JAR is only a way of packing. </li></ul><br><p>  This is an assembly artifact that includes classes, but this is not all: resources, as a rule, are also included in the archive.  Packaging, like resource processing, has its price.  The Gradle team aims to improve the build quality and reduce the developer's time to wait for the results of the compilation, tests and the build process in general.  If the archive appears in the process too early, an unnecessary synchronization point is created.  For example, to compile API-dependent classes, the only thing needed is .class files.  No jar archives, no resources in jar.  Similarly, to run Gradle tests, you need only class files and resources.  For testing, there is no need to create a jar.  He will need only the external user (that is, when publishing).  But if the creation of an artifact becomes mandatory, some tasks cannot be executed in parallel and the entire assembly process is inhibited.  If for small projects this is not critical, for large-scale corporate projects this is the main slowing factor. </p><br><ul><li>  more importantly, being an artifact, the jar-archive cannot carry dependency information. </li></ul><br><p>  The dependencies of each class in Java 9 and Java 8 runtime can hardly be the same.  Yes, in our simple example it will be like this, but for larger projects this is not true: the user usually imports the library's backport for Java 9 functionality and uses it to implement the version of the Java 8 class. However, if both versions are packaged in one archive, in one artifact there will be elements with different dependency trees.  This means that if you are working with Java 9, you have dependencies that you never need.  Moreover, it pollutes the classpath, creating probable conflicts for library users. </p><br><p>  Finally, in one project, you can create JARs for different purposes: </p><br><ul><li>  for API </li><li>  for java 8 </li><li>  for java 9 </li><li>  with native binding </li><li>  etc. </li></ul><br><p>  Incorrect use of <em>classifier</em> dependencies leads to conflicts associated with the sharing of the same mechanism.  Usually <em>sources</em> or <em>javadocs</em> are installed as classifiers, but in fact they have no dependencies. </p><br><ul><li>  We do not want to generate inconsistencies, the build process should not depend on how you get the classes.  In other words, using multi-release jars has a side effect: a call from the JAR archive and a call from the class directory are now completely different things.  They have a huge difference in semantics! </li><li>  Depending on what tool you use to create a JAR, you may end up with incompatible JAR archives!  The only tool that ensures that when you pack two class options into one archive, they have a single open API, this is the <em>jar</em> utility itself.  Which, not without reasons, not necessarily involve assembly tools or even users.  JAR is, in fact, an ‚Äúenvelope‚Äù that resembles a ZIP archive.  So depending on how you collect it, you will get different behavior, and maybe you will collect an incorrect artifact (and you will not notice). </li></ul><br><h2 id="bolee-effektivnye-sposoby-upravleniya-otdelnymi-jar-arhivami">  More efficient ways to manage individual JAR archives </h2><br><p>  The main reason that developers do not use separate archives is that they are inconvenient to collect and use.  The tools of the assembly are to blame, which, before the appearance of the Gradle, could not cope with this at all.  In particular, those who used this method in Maven could only rely on the weak <em>classifier</em> function to publish additional artifacts.  However, <em>classifier</em> does not help in this difficult situation.  They are used for various purposes, from the publication of source codes, documentation, javadocs, to the implementation of library options (guava-jdk5, guava-jdk7, ...) or various use cases (api, fat jar, ...).  In practice, there is no way to show that the <em>classifier</em> dependency tree is different from the dependency tree of the main project.  In other words, the POM format is fundamentally broken, because  represents both the way the component is assembled and the artifacts it delivers.  Suppose you need to implement 2 different jar archives: a classic and a fat jar, including all dependencies.  Maven decides that 2 artifacts have identical dependency trees, even if this is obviously wrong!  In this case, it is more than obvious, but the situation is the same as with multi-release JARs! </p><br><p>  The solution is to handle the options correctly.  It is able to do Gradle, managing dependencies with the given options.  At the moment, this feature is available for development on Android, but we are also working on its version for Java and native applications! </p><br><p>  Dependency management based on options is based on the fact that modules and artifacts are completely different things.  The same code can work fine in different runtimes, taking into account different requirements.  For those who work with native compilation, this is obvious for a long time: we compile for <em>i386</em> and <em>amd64</em> and cannot in any way interfere with the dependence of the <em>i386</em> library with <em>arm64</em> !  In the context of Java, this means that for Java 8 you need to create a version of the ‚Äújava 8‚Äù JAR archive, where the class format will correspond to Java 8. This artifact will contain metadata with information about which dependencies to use.  For Java 8 or 9, dependencies corresponding to the version will be selected.  Just like that (in fact, the reason is not that runtime is only one field of options, you can combine several). </p><br><p>  Of course, no one has done this before because of excessive complexity: Maven, apparently, will never allow to turn such a complicated operation.  But with gradle it is possible.  Now the Gradle team is working on a new metadata format that tells users which option to use.  Simply put, the build tool must deal with the compilation, testing, packaging, and processing of such modules.  For example, the project should work in Java 8 and Java 9 runtimes. Ideally, you should implement 2 versions of the library.  So, there are 2 different compilers (to avoid using Java 9 API when working in Java 8), 2 class directories and, finally, 2 different JAR archives.  And still, most likely, it will be necessary to test 2 runtimes.  Or you implement 2 archives, but decide to test the behavior of the Java 8 version in Java 9 runtime (because this can happen at startup!). </p><br><p>  So far this scheme has not been implemented, but the Gradle team <a href="">has made significant progress</a> in this direction. </p><br><h2 id="kak-sozdat-multi-release-jar-s-pomoschyu-gradle">  How to create a multi-release JAR using Gradle </h2><br><p>  But if this function is not ready yet, what should I do?  Relax, correct artifacts are created the same way.  Before the appearance of the above function in the Java ecosystem, there are two options: </p><br><ul><li>  the good old way using reflection or different JAR archives; </li><li>  use multi-release JARs (note that this can be a bad decision, even with good usage examples). </li></ul><br><p>  No matter what you choose, different archives or multi-release JARs, the scheme will be the same.  Multi-release JARs are essentially the wrong packaging: they should be an option, but not a goal.  Technically, the source layout for the individual and external JARs is the same.  This <a href="https://github.com/melix/mrjar-gradle">repository</a> describes how to create a multi-release JAR using Gradle.  The essence of the process is briefly described below. </p><br><p>  First of all, you should always keep in mind one bad habit of developers: they launch Gradle (or Maven) using the same version of Java on which they plan to launch artifacts.  Moreover, a later version is sometimes used to run Gradle, and compilation takes place with an earlier API level.  But there is no particular reason to do so.  In Gradle is possible to <a href="https://docs.gradle.org/current/userguide/java_plugin.html">Ross compilation</a> .  It allows you to describe the position of the JDK, as well as launch a compilation by a separate process in order to compile a component using this JDK.  The best way to configure various JDKs is to set up the path to the JDK via environment variables, as done <a href="https://github.com/melix/mrjar-gradle/blob/master/jdks.gradle">in this file</a> .  Then you only need to configure Gradle to use the desired JDK, based on compatibility <a href="https://github.com/melix/mrjar-gradle/blob/master/jdks.gradle">with the source / target platform</a> .  It is worth noting that, starting with JDK 9, previous versions of the JDK are not needed for cross-compiling.  This makes a new feature, -release.  Gradle <a href="https://github.com/melix/mrjar-gradle/blob/master/jdks.gradle">uses this function and sets up the compiler</a> as needed. </p><br><p>  Another key point is the <a href="https://docs.gradle.org/current/userguide/java_plugin.html">source set</a> designation.  Source set is a set of source files that need to be compiled together.  A JAR is obtained by compiling one or more source sets.  For each set, Gradle automatically creates a corresponding custom compilation task.  This means that if there are sources for Java 8 and Java 9, these sources will be in different sets.  This is exactly how everything is arranged <a href="https://github.com/melix/mrjar-gradle/blob/master/build.gradle">in the source code for Java 9</a> , which will include the version of our class.  It really works, and you do not need to create a separate project, as in Maven.  But most importantly, this method allows you to fine-tune the compilation of the set. </p><br><p> One of the difficulties of having different versions of the same class is that the class code is rarely independent of the rest of the code (it has dependencies with classes that are not part of the main set).  For example, its API can use classes that don‚Äôt need special sources for Java 9 support. At the same time, I don‚Äôt want to recompile all these common classes and package their versions for Java 9. They are general classes, so they must exist separately from classes for a particular JDK.  Customize it <a href="https://github.com/melix/mrjar-gradle/blob/master/build.gradle">here</a> : add a dependency between the source set for Java 9 and the main set so that when compiling a version for Java 9 all common classes remain in the compilation classpath. </p><br><p>  <a href="https://github.com/melix/mrjar-gradle/blob/master/build.gradle">The next step is simple</a> : you need to explain Gradle that the main source set will be compiled with the Java 8 API level, and the Java 9 set with the Java 9 level. </p><br><p>  All of the above will help you when using both of the previously mentioned approaches: the implementation of separate JAR archives or a multi-release JAR.  Since this is a post on this topic, let's look at an example of how to get Gradle to build a multi-release JAR: </p><br><pre><code class="java hljs">jar { into(<span class="hljs-string"><span class="hljs-string">'META-INF/versions/9'</span></span>) { from sourceSets.java9.output } manifest.attributes( <span class="hljs-string"><span class="hljs-string">'Multi-Release'</span></span>: <span class="hljs-string"><span class="hljs-string">'true'</span></span> ) }</code> </pre> <br><p>  This block describes: wrapping classes for Java 9 into the <em>META-INF / versions / 9</em> directory, which is used for MR JAR, and setting a multi-release tag in the manifest. </p><br><p>  And everything, your first MR JAR is ready! </p><br><p>  But, unfortunately, the work is not over.  If you have worked with Gradle, you know that when using the application plugin, you can run the application directly through the <em>run</em> task.  However, due to the fact that usually Gradle tries to reduce the amount of work to a minimum, the <em>run</em> task must use both class directories and directories of processed resources.  For multi-release JARs, this is a problem, because JAR is needed immediately!  Therefore, instead of using the plugin, you will have to <a href="https://github.com/melix/mrjar-gradle/blob/master/build.gradle">create your task</a> , and this is an argument against the use of multi-release JARs. </p><br><p>  Last but not least, we mentioned that we would need to test 2 versions of the class.  To do this, you can use only VMs in a separate process, because there is no equivalent of a <em>-release</em> marker for Java runtime.  The idea is that you only need to write one test, but it will be executed twice: in Java 8 and Java 9. This is the only way to make sure that runtime-specific classes work correctly.  By default, Gradle creates one testing task, and it also uses class directories instead of JAR.  Therefore, we will do two things: create a testing task for Java 9 and configure both tasks so that they use the JAR and the specified Java runtime.  The implementation will look like this: </p><br><pre> <code class="java hljs">test { dependsOn jar def jdkHome = System.getenv(<span class="hljs-string"><span class="hljs-string">"JAVA_8"</span></span>) classpath = files(jar.archivePath, classpath) - sourceSets.main.output executable = file(<span class="hljs-string"><span class="hljs-string">"$jdkHome/bin/java"</span></span>) doFirst { println <span class="hljs-string"><span class="hljs-string">"$name runs test using JDK 8"</span></span> } } <span class="hljs-function"><span class="hljs-function">task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testJava9</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type: Test)</span></span></span><span class="hljs-function"> </span></span>{ dependsOn jar def jdkHome = System.getenv(<span class="hljs-string"><span class="hljs-string">"JAVA_9"</span></span>) classpath = files(jar.archivePath, classpath) - sourceSets.main.output executable = file(<span class="hljs-string"><span class="hljs-string">"$jdkHome/bin/java"</span></span>) doFirst { println classpath.asPath println <span class="hljs-string"><span class="hljs-string">"$name runs test using JDK 9"</span></span> } } check.dependsOn(testJava9)</code> </pre> <br><p>  Now when you run the <em>check</em> task, Gradle will compile each set of sources using the correct JDK, create a multi-release JAR, then run the tests with this JAR on both JDKs.  Future versions of Gradle will help you do this more declaratively. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Let's sum up.  You have learned that multi-release JARs are an attempt to solve a real problem faced by many library developers.  However, this solution looks wrong.  Correct management of dependencies, binding artifacts and variants, care for performance (the ability to perform as many tasks as possible in parallel) - all this makes MR JAR a solution for the poor.  This problem can be solved correctly with options.  And yet, while dependency management with options from Gradle is under development, multi-release JARs are quite convenient in simple cases.  In this case, this post will help you understand how to do this, and how Gradle's philosophy differs from Maven (source set vs project). </p><br><p>  Finally, we do not deny that there are cases in which multi-release JARs make sense: for example, when it is not known in what environment the application will be executed (not the library), but this is rather the exception.  In this post, we described the main problems faced by library developers, and how multi-release JARs try to solve them.  Proper modeling of dependencies as options improves performance (through fine-grained parallelism) and reduces maintenance costs (avoiding unforeseen complexity) compared to multi-release JARs.  In your situation, MR JARs may also be needed, so Gradle has already taken care of this.  Take a look at <a href="https://github.com/melix/mrjar-gradle">this sample project</a> and try it yourself. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/428868/">https://habr.com/ru/post/428868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428856/index.html">A wonderful trick to make the day to the open source project maintainer</a></li>
<li><a href="../428858/index.html">Conference DEFCON 17. Laugh at your viruses! Part 1</a></li>
<li><a href="../428860/index.html">Conference DEFCON 17. Laugh at your viruses! Part 2</a></li>
<li><a href="../428864/index.html">Making the web great again</a></li>
<li><a href="../428866/index.html">7 principles of design, attitude to design trends, UX-designer portfolio, ...</a></li>
<li><a href="../428870/index.html">Mrr: Total FRP for React</a></li>
<li><a href="../428872/index.html">The story of one eye and 20 operations (not read impressionable), or he wanted to be a pilot, but he was not allowed into the sky</a></li>
<li><a href="../428874/index.html">The government has banned registration in messengers by someone else's numbers</a></li>
<li><a href="../428876/index.html">There is no way back: personal tester experience</a></li>
<li><a href="../428878/index.html">Flying Pigs, or Optimizing Bytecode Interpreters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>