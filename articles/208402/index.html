<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating previews of images on the client: the fight against voracious browsers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Today we have the following task: it is necessary to create an interface for uploading pictures, which would be generated before downloading a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating previews of images on the client: the fight against voracious browsers</h1><div class="post__text post__text-html js-mediator-article">  Hello!  Today we have the following task: it is necessary to create an interface for uploading pictures, which would be generated before downloading a thumbnail of a small format.  At the moment, HTML5 is sweeping across the planet, and it would seem that how to implement this should be very clear.  There are several Russian-language articles on this topic (for example, for example).  But there is one thing.  In the approach considered there, no attention is paid to the memory consumption of the browser.  And the expense can reach the gigantic sizes.  Of course, if you download at the same time no more than 5-10 pictures of a small format, then everything remains within the normal range;  but our interface should allow loading at once many images of a format not less than that of modern cameras-soap cases.  And then the free memory begins to melt before our eyes. <br><a name="habracut"></a><br>  To begin with, in order to assess the scale of the problem, we will <a href="http://safron.pro/playground/previews/0/">implement the approach</a> described with virtually no changes in all articles on this topic, and try to follow the memory usage.  I tried to make the code of examples as simple as possible to demonstrate the creation of a preview.  How to implement Drag &amp; Drop and download can be viewed at least even in my previous <a href="http://habrahabr.ru/post/109079/">article</a> <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listen = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element, event, fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element.addEventListener(event, fn, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }; listen(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>, <span class="hljs-string"><span class="hljs-string">'DOMContentLoaded'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileInput = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#file-input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listView = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#list-view'</span></span>); listen(fileInput, <span class="hljs-string"><span class="hljs-string">'change'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> files = fileInput.files; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (files.lenght == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; files.length; i++) { generatePreview(files[i]); } fileInput.value = <span class="hljs-string"><span class="hljs-string">""</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> generatePreview = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(); reader.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataUrl = e.target.result; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> li = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'LI'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Image(); image.width = <span class="hljs-number"><span class="hljs-number">100</span></span>; image.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some action here }; image.src = dataUrl; li.appendChild(image); listView.appendChild(li); }; reader.readAsDataURL(file); }; });</span></span></code> </pre> <br></div></div><br><br>  For tests, I used a folder of unremarkable photos of 3648x2736 pixels and an average size of 4 megabytes.  As well as a set of current version of browsers: Chrome (31.0), Yandex (13.12), Firefox (26.0), and IE (11.0.1).  Well, the usual Task Manager (Win 8.1). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, we select 20 photos in the field.  We look: <br><table><tbody><tr><th>  Browser </th><th>  Memory consumption, MB </th></tr><tr><td>  Chrome </td><td>  994 </td></tr><tr><td>  Yandex </td><td>  1045 </td></tr><tr><td>  Firefox </td><td>  1388 </td></tr><tr><td>  IE </td><td>  1080 </td></tr></tbody></table><br><br>  Two points are worth noting here: 1) Yandex and Chrome keep a separate process for each tab, but Firefox and IE do not, therefore for the last two some overhead costs not directly related to our testing also fall into the measurements;  2) I took measurements (hereafter) approximately 20 seconds after loading all the images to allow browsers to free up memory in hot pursuit, which they do, albeit very slightly, within 50MB, i.e.  continue to hold still too large volumes.  After updating / closing the page, all browsers slowly free up memory to normal volumes. <br><br>  So, it is clear that this situation does not suit us in a decisive way.  We think that we can take ... <br><br><h4>  The first approach to the projectile </h4><br>  My first thought was: ‚Äúwhat if such an overrun comes from trying to load all the pictures in parallel?  Maybe try to do it consistently, thereby giving browsers a chance to catch a little breath? ‚Äù.  Well, we try to <a href="http://safron.pro/playground/previews/1/">implement the</a> simplest queue. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ...    ... var queue = []; var isProcessing = false; listen(fileInput, 'change', function(event) { var files = fileInput.files; if (files.lenght == 0) { return; } for(var i = 0; i &lt; files.length; i++) { queue.push(files[i]); } fileInput.value = ""; processQueue(); }); var processQueue = function() { if (isProcessing) { return; } if (queue.length == 0) { isProcessing = false; return; } isProcessing = true; file = queue.pop(); var reader = new FileReader(); reader.onload = function(e) { var dataUrl = e.target.result; var li = document.createElement('LI'); var image = new Image(); image.width = 100; image.src = dataUrl; li.appendChild(image); listView.appendChild(li); isProcessing = false; processQueue(); }; reader.readAsDataURL(file); };</span></span></code> </pre><br></div></div><br><br>  <b>Results (on the same 20 photos):</b> <br><table><tbody><tr><th>  Browser </th><th>  Memory consumption, MB </th></tr><tr><td>  Chrome </td><td>  979 </td></tr><tr><td>  Yandex </td><td>  1119 </td></tr><tr><td>  Firefox </td><td>  1360 </td></tr><tr><td>  IE </td><td>  399 </td></tr></tbody></table><br><br>  We see that it helped only in the case of IE.  Well, what to do - we recommend that all users abandon the use of any browsers other than IE.  Joke.  We think further ... <br><br><h4>  Second approach </h4><br>  After a session of some shamanism, the thought comes to mind: ‚Äúmaybe the problem is that browsers have to keep huge images in memory, although in fact we only need to shrink the image to the size of the preview?  What if instead of the usual img we use canvas, where should I put the already compressed image? ‚Äù.  <a href="http://safron.pro/playground/previews/2/">So do</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queue = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isProcessing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; listen(fileInput, <span class="hljs-string"><span class="hljs-string">'change'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }); var processQueue = function() { // ...       file = queue.pop(); var reader = new FileReader(); reader.onload = function(e) { var dataUrl = e.target.result; var li = document.createElement('LI'); var canvas = document.createElement('CANVAS'); var ctx = canvas.getContext('2d'); var image = new Image(); listView.appendChild(li); image.onload = function() { var newWidth = 100; var newHeight = image.height * (newWidth / image.width); ctx.drawImage(image, 0, 0, newWidth, newHeight); li.appendChild(canvas); }; image.src = dataUrl; isProcessing = false; processQueue(); }; reader.readAsDataURL(file); };</span></span></code> </pre><br></div></div><br><br>  <b>Results (all the same 20 pictures):</b> <br><table><tbody><tr><th>  Browser </th><th>  Memory consumption, MB </th></tr><tr><td>  Chrome </td><td>  188 (at peak times reached ~ 800MB, but quickly threw off) </td></tr><tr><td>  Yandex </td><td>  201 (at peak times reached ~ 1GB, but immediately threw off, like Chrome) </td></tr><tr><td>  Firefox </td><td>  661 (peak ~ 900. It should be noted that after waiting a minute more, threw up to 300) </td></tr><tr><td>  IE </td><td>  103 (peak ~ 260) </td></tr></tbody></table><br><br>  Despite the high consumption in the process (for everyone except IE), browsers at least started immediately freeing memory.  It can not but rejoice.  But to celebrate the final victory is still too early.  We think that you can still take ... <br><br><h4>  Third approach </h4><br>  In the process of further throwing and not too successful experiments, we recall that once came across an API such as ObjectURL ( <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL.createObjectURL">creation</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL.revokeObjectURL">recycling</a> ), which allows you to create local links to any binary data stored in the browser's cache, as well as to recycle them.  In theory, this can help us avoid processing giant DataURLs.  <a href="http://safron.pro/playground/previews/3/">Rather, we try</a> <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ...     var processQueue = function() { // ...     isProcessing = true; file = queue.pop(); var li = document.createElement('LI'); var canvas = document.createElement('CANVAS'); var ctx = canvas.getContext('2d'); var image = new Image(); listView.appendChild(li); image.onload = function() { var newWidth = 100; var newHeight = image.height * (newWidth / image.width); ctx.drawImage(image, 0, 0, newWidth, newHeight); URL.revokeObjectURL(image.src); li.appendChild(canvas); isProcessing = false; processQueue(); }; image.src = URL.createObjectURL(file); };</span></span></code> </pre><br></div></div><br><br>  <b>Results:</b> <br><table><tbody><tr><th>  Browser </th><th>  Memory consumption, MB </th></tr><tr><td>  Chrome </td><td>  881 </td></tr><tr><td>  Yandex </td><td>  927 </td></tr><tr><td>  Firefox </td><td>  140 (peak ~ 860) </td></tr><tr><td>  IE </td><td>  36 (peak ~ 70) </td></tr></tbody></table><br><br>  What did we get?  Well, firstly, excellent results in IE.  More or less acceptable in FF.  But with WebKit browsers, they seemed to be bounced back.  For the sake of fairness, it should be noted that in all browsers, images began to be processed faster purely on sensations, but at the same time, short-term friezes appeared in IE.  It is also possible that, frankly, FF and IE immediately release resources after calling URL.revokeObjectURL (), and webkit browsers need some time to do this (it is even possible that they will be faster to do this in conditions of low memory).  Then you can go in two ways: 1) divide the approaches - in the webkite browsers return to the second approach (with this, everything is clear - a matter of technology);  and 2) try to bring the third approach everywhere.  Let's try the last option ... <br><br><h4>  Approach the fourth (and last): what else is it to optimize? </h4><br>  A little pushing, squeeze out a couple of improvements.  First, we remove the creation of the img element from the queue handler: now we will reuse the same pre-created object.  Looking ahead, I‚Äôll say that it helped to significantly improve the memory situation in webkits of <s>online</s> browsers - as required.  And second, this is a well-known trick - we postpone every next processing with setTimeout (), this helped to improve the situation with short-term friezes.  So, the <a href="http://safron.pro/playground/previews/result/">result</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    var listen = function(element, event, fn) { return element.addEventListener(event, fn, false); }; listen(document, 'DOMContentLoaded', function() { var fileInput = document.querySelector('#file-input'); var listView = document.querySelector('#list-view'); var queue = []; var isProcessing = false; var image = new Image(); //     img var imgLoadHandler; listen(fileInput, 'change', function(event) { var files = fileInput.files; if (files.lenght == 0) { return; } for(var i = 0; i &lt; files.length; i++) { queue.push(files[i]); } fileInput.value = ""; processQueue(); }); var processQueue = function() { if (isProcessing) { return; } if (queue.length == 0) { isProcessing = false; return; } isProcessing = true; file = queue.pop(); var li = document.createElement('LI'); var canvas = document.createElement('CANVAS'); var ctx = canvas.getContext('2d'); //      image.removeEventListener('load', imgLoadHandler, false); imgLoadHandler = function() { var newWidth = 100; var newHeight = image.height * (newWidth / image.width); ctx.drawImage(image, 0, 0, newWidth, newHeight); URL.revokeObjectURL(image.src); li.appendChild(canvas); isProcessing = false; setTimeout(processQueue, 200); //    }; listView.appendChild(li); listen(image, 'load', imgLoadHandler); image.src = URL.createObjectURL(file); }; });</span></span></code> </pre><br></div></div><br><br>  <b>Testing:</b> <br><table><tbody><tr><th>  Browser </th><th>  Memory consumption, MB </th></tr><tr><td>  Chrome </td><td>  103 (peak ~ 150) </td></tr><tr><td>  Yandex </td><td>  113 (peak ~ 150, as in Chrome) </td></tr><tr><td>  Firefox </td><td>  107 (peak ~ 510) </td></tr><tr><td>  IE </td><td>  40 (and it‚Äôs not raised above. As if there was no work at all) </td></tr></tbody></table><br><br>  <b>At the same time we will also test on 100 pictures of the same size:</b> <br><table><tbody><tr><th>  Browser </th><th>  Memory consumption, MB </th></tr><tr><td>  Chrome </td><td>  98 (peak ~ 150) </td></tr><tr><td>  Yandex </td><td>  150 (peak ~ 180) </td></tr><tr><td>  Firefox </td><td>  104 (peak ~ 520) </td></tr><tr><td>  IE </td><td>  40 (all the same 40MB!) </td></tr></tbody></table><br><br>  We see that the increase in the number of processed images practically does not increase consumption.  On this, perhaps, dwell. <br><br><h4>  Conclusion </h4><br>  To admit, after the very first surveys, at some point I thought that in the present state of affairs it would not be possible to realize this possibility without excessive memory overruns.  Still, it is ugly to suspend the user [who wished to upload 100 pictures at once] of his hypothetical netbook.  But it is nice that we managed to overcome these doubts :) <br><br>  So, we managed to figure out a few points.  Number one: using DataURL is only suitable for working with very small format images (for larger ones, it is preferable to use the objectURL API, which consists of only two methods).  Number two: be careful with creating a large number of Image objects.  Number three: do not do all processing at the same time. <br><br>  Well, since this small study inexplicably led to a comparison of browsers, let's go over each one individually. <br><br><h6>  Firefox lost? </h6><br>  Despite the peak consumption in comparison with the others, I think that the situation is quite acceptable.  Firstly (I did not mention it above), even 30 seconds after the measurements, the memory dropped to 60MB, which is even lower compared to webkit ones;  and secondly, it is likely that, in the conditions of a severe shortage, Firefox would periodically clean up the memory during processing and, in the end, even at the peak would not eat off so much.  In general, we set off. <br><br><h6>  Equalize with IE! </h6><br>  This is a joke again :) But if we speak objectively, then we must admit that IE now is not just a tool for downloading a normal browser, but at least one more good browser. <br><br><h6>  Is Yandex Browser a bit behind the older brothers? </h6><br>  I do not think.  And here's why: the fact is that it is now used as the main one for me, and therefore the experiment cannot be called crystal clear.  A couple of plugins, history, synchronization - all this could well cause this slight lag. <br><br><h6>  And where is the Opera? </h6><br>  I really did not want to put the 12th version separately for this experiment.  Despite the fact that it is still being used by some people, soon this number of loyal fans will either have to be updated or migrated to another browser.  And about the new, webkitova - there is every reason to believe that the situation is similar to Yandex and Chrome. <br><br>  <strong>UPD:</strong> I checked all the same in the 12th Opera.  The results are as follows: the 3rd (and, respectively, the 4th) approaches do not work.  The second approach eats away 500MB at the peak and 300MB after the end of processing. <br><br><h6>  But what about Safari? </h6><br>  On win, this is a rare beast, but on a poppy it tested the final version (all in the same 20 photos).  During processing, the memory consumption did not increase at all. <br><br><h6>  What with mobile browsers? </h6><br>  Checked also in Safari on iPhone 5S.  There is a short-term frieze, but at the same time, the amount of free memory has practically not decreased.  I did not find out right away whether it was possible to somehow see how much each process specifically reserves, I would be grateful if someone tells you in the kamentah.  Devices on Android, unfortunately, was not at hand.  Perhaps someone is not too lazy to check on their own and share the results. <br><br>  Thanks for attention.  I hope someone will help the article not to waste time on similar research.  And with the past holidays you,% username%! </div><p>Source: <a href="https://habr.com/ru/post/208402/">https://habr.com/ru/post/208402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208390/index.html">High-precision machines must not be moved without the permission of the manufacturer.</a></li>
<li><a href="../208392/index.html">Name in success or success in name? (trademarks part2)</a></li>
<li><a href="../208394/index.html">PlayStation Now: games for PlayStation on a tablet, TV, smartphone</a></li>
<li><a href="../208396/index.html">CoolRF: Project News Digest # 1</a></li>
<li><a href="../208400/index.html">The principles of the DBMS. MVCC</a></li>
<li><a href="../208406/index.html">NinjaMock is a free interface prototyping application.</a></li>
<li><a href="../208408/index.html">The first eight videos from our book are publicly available.</a></li>
<li><a href="../208410/index.html">Game Kakuro - Postmortem</a></li>
<li><a href="../208412/index.html">CentOS joins forces with Red Hat</a></li>
<li><a href="../208414/index.html">Java'o'Fido: continued</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>