<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a puzzle for iPhone</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why not present your own puzzle in the app store - as we did! In this tutorial, I will step by step talk about creating such an application. The final...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a puzzle for iPhone</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/701/e93/78b/701e9378bcced6e8818b81348902b0ec.png" alt="image">  Why not present your own puzzle in the app store - as we did!  In this tutorial, I will step by step talk about creating such an application.  The final result will look something like the photo.  A cup of coffee - and you can start. <br><br>  As real programmers, first we will focus on what a <strong>slider puzzle is</strong> and how to implement it.  Probably everyone remembers the children's game "tag", where the chips with numbers needed to be built in order.  In our case, these will be scattered fragments of an image that are assembled into a single whole (they are one less so that the pieces can be moved).  Now we will think what it takes to bring such a project to life. <br><br>  First you need an image that we divide into fragments.  We will place them in disarray in order to reassemble them.  The truth before that you need to somehow remember where this or that fragment should be located.  To do this, we introduce a new class that will contain both the original and the current position of each fragment in the matrix (by the matrix is ‚Äã‚Äãmeant the grid on which the pattern is formed).  This way we will be able to determine whether the user has assembled the puzzle or not (comparing the current position with the source for each fragment).  The next task is to determine the allowed displacements.  For this purpose, replace one of the fragments with an empty one.  In its place is allowed to move the adjacent fragment.  Well, in principle, that's all.  If I missed something, let's figure it out. <a name="habracut"></a><br>  So, we list everything that needs to be done: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  split image; </li><li>  bind each part of the image to a specific piece of the puzzle (responsible for storing its original and current position); </li><li>  randomly mix all the fragments (we start the nth cycle, during which a randomly selected fragment moves to the empty space); </li><li>  fix the user touching the puzzle pieces;  if movement is allowed, swap the empty fragment with the selected one and check if the image has returned to its original state. </li></ul><br>  Let's start?  Open <strong>Xcode</strong> and create a <strong>windows based</strong> application.  (Here I will dwell mainly on logic. Details on the settings can be obtained by downloading the source code or referring to the previous lessons). <br><br>  As usual, we will need a new controller " <strong>UIViewController</strong> ".  Create it and give it an appropriate name.  Now look for a suitable image among your files (slightly smaller than the view). <br><br>  The first task is to divide the image into parts.  Create a new method " <strong>initPuzzle: (NSString *) imagePath</strong> " - it will break the drawing into separate fragments.  In parallel, add two constants that define the total number of fragments: <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">#define</font> NUM_HORIZONTAL_PIECES    3 <br> <font color="#0000ff">#define</font> NUM_VERTICAL_PIECES    3 <br> <br> -( <font color="#0000ff">void</font> ) initPuzzle:(NSString *) imagePath{ <br> UIImage *orgImage = [UIImage imageNamed:imagePath]; <br> <font color="#0000ff">if</font> ( orgImage == nil ){ <br> <font color="#0000ff">return</font> ; <br> } <br> tileWidth = orgImage.size.width/NUM_HORIZONTAL_PIECES; <br> tileHeight = orgImage.size.height/NUM_VERTICAL_PIECES; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> x=0; x&lt;NUM_HORIZONTAL_PIECES; x++ ){ <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> y=0; y&lt;NUM_VERTICAL_PIECES; y++ ){ <br> CGRect frame = CGRectMake(tileWidth*x, tileHeight*y, <br> tileWidth, tileHeight ); <br> CGImageRef tileImageRef = CGImageCreateWithImageInRect( orgImage.CGImage, frame ); <br> UIImage *tileImage = [UIImage imageWithCGImage:tileImageRef]; <br> UIImageView *tileImageView = [[UIImageView alloc] initWithImage:tileImage]; <br> tileImageView.frame = frame; <br> <font color="#008000">//  </font> <br> [tileImage release]; <br> CGImageRelease( tileImageRef ); <br> <font color="#008000">//   </font> <br> [self.view insertSubview:tileImageView atIndex:0]; <br> [tileImageView release]; <br> } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  We start the application - an image already divided into 9 fragments appears on the iPhone screen.  This was done by the " <strong>GFImageCreateWithImageInRect</strong> " method (Core Graphics), which takes a link to an image and a rectangle, and returns a link to the cropped image (in this case, the shape of the rectangle).  Having a link, proceed to the creation of an instance of " <strong>UIImage</strong> ". <br><br>  As mentioned above, for each piece, the initial position is remembered (to determine the end of the puzzle assembly), as well as the current position relative to the grid.  For this purpose, we extend the class " <strong>UIImageView</strong> " and add two more properties.  Additionally, you can slightly push the fragments so that they look more like a standard puzzle, and add an empty area, opening the possibility of moving. <br><br>  To begin with, we will add constants in the header file at intervals along with variables responsible for the position of the fragments (including the empty one). <br><br>  As a result, the header file should look like this: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">#define</font> NUM_HORIZONTAL_PIECES    3 <br> <font color="#0000ff">#define</font> NUM_VERTICAL_PIECES    3 <br> <font color="#0000ff">#define</font> TILE_SPACING      4 <br> @ <font color="#0000ff">interface</font> SliderController : UIViewController { <br> CGFloat tileWidth; <br> CGFloat tileHeight; <br> NSMutableArray *tiles; <br> CGPoint blankPosition; <br> } <br> @property (nonatomic,retain) NSMutableArray *tiles; <br> @end</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  I propose to fill in the blanks in the implementation class myself. <br><br>  Now we have a placeholder for fragments and empty space - we can proceed to the display of a separate fragment.  Expand the " <strong>UIImageView</strong> " class (as described above) and add new properties. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">@ <font color="#0000ff">interface</font> Tile : UIImageView { <br> CGPoint originalPosition; <br> CGPoint currentPosition; <br> } <br> @property (nonatomic,readwrite) CGPoint originalPosition; <br> @property (nonatomic,readwrite) CGPoint currentPosition; <br> @end <br> <br> @implementation Tile <br> @synthesize originalPosition; <br> @synthesize currentPosition; <br> - ( <font color="#0000ff">void</font> ) dealloc <br> { <br> [self removeFromSuperview]; <br> [super dealloc]; <br> } <br> @end</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  In the comments to this code I will only mention that after the object is released, we remove it from the parent level.  This is explained by the fact that we are dealing with an array of fragments.  When we drop it (release), each of the fragments must remove itself from the view. <br><br>  Let's go back to the " <strong>- (void) initPuzzle: (NSString *) imagePath</strong> " <strong>method</strong> and make a number of adjustments: <br><ul><li>  skip the "empty" fragment; </li><li>  add a position in the grid to each fragment; </li><li>  increase the distance between the fragments. </li></ul><br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">-( <font color="#0000ff">void</font> ) initPuzzle:(NSString *) imagePath{ <br> UIImage *orgImage = [UIImage imageNamed:imagePath]; <br> <font color="#0000ff">if</font> ( orgImage == nil ){ <br> <font color="#0000ff">return</font> ; <br> } <br> [self.tiles removeAllObjects]; <br> tileWidth = orgImage.size.width/NUM_HORIZONTAL_PIECES; <br> tileHeight = orgImage.size.height/NUM_VERTICAL_PIECES; <br> blankPosition = CGPointMake( NUM_HORIZONTAL_PIECES-1, NUM_VERTICAL_PIECES-1 ); <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> x=0; x&lt;NUM_HORIZONTAL_PIECES; x++ ){ <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> y=0; y&lt;NUM_VERTICAL_PIECES; y++ ){ <br> CGPoint orgPosition = CGPointMake(x,y); <br> <font color="#0000ff">if</font> ( blankPosition.x == orgPosition.x &amp;&amp; blankPosition.y == orgPosition.y ){ <br> <font color="#0000ff">continue</font> ; <br> } <br> CGRect frame = CGRectMake(tileWidth*x, tileHeight*y, <br> tileWidth, tileHeight ); <br> CGImageRef tileImageRef = CGImageCreateWithImageInRect( orgImage.CGImage, frame ); <br> UIImage *tileImage = [UIImage imageWithCGImage:tileImageRef]; <br> CGRect tileFrame = CGRectMake((tileWidth+TILE_SPACING)*x, (tileHeight+TILE_SPACING)*y, <br> tileWidth, tileHeight ); <br> Tile *tileImageView = [[Tile alloc] initWithImage:tileImage]; <br> tileImageView.frame = tileFrame; <br> tileImageView.originalPosition = orgPosition; <br> tileImageView.currentPosition = orgPosition; <br> <font color="#008000">//  </font> <br> [tileImage release]; <br> CGImageRelease( tileImageRef ); <br> [tiles addObject:tileImageView]; <br> <font color="#008000">//   </font> <br> [self.view insertSubview:tileImageView atIndex:0]; <br> [tileImageView release]; <br> } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  To begin, clear the array, then specify the empty position of the last in the grid.  For each fragment, we create a point describing its position, tying it to the " <strong>originalPosition</strong> " and " <strong>currentPosition</strong> " <strong>properties</strong> .  Before processing a fragment, we check whether its position corresponds to an empty position.  If confirmed, skip the snippet.  I almost forgot - and add it to the array of fragments. <br><br>  Having finished with this, we proceed to the next stage of the project.  Now you need to randomly place the fragments on the screen, so that the user had to break his head over how to assemble the image back.  Having started the <strong>n-</strong> th number of cycles, we will randomly select one of the fragments next to the empty one, changing their places.  To do this, we first define the allowed displacements, which the following code snippet can easily do: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">#define</font> SHUFFLE_NUMBER  100 <br> typedef <font color="#0000ff">enum</font> { <br> NONE      = 0, <br> UP      = 1, <br> DOWN      = 2, <br> LEFT      = 3, <br> RIGHT      = 4 <br> } ShuffleMove;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Here <strong>n</strong> (the number of random movements of fragments) and the type " <strong>enum</strong> " are given, with which the allowed and incorrect moves will be distinguished. <br><br>  The first method " <strong>validMove: (Tile *) tile</strong> " takes a fragment and returns an <strong>enum</strong> " <strong>ShuffleMove</strong> ", determining whether the specified fragment can move and in what direction.  To do this, check the position of the fragment with respect to the empty one.  If the specified fragment is adjacent to empty, it can take its place. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">-(ShuffleMove) validMove:(Tile *) tile{ <br> <font color="#008000">//     </font> <br> <font color="#0000ff">if</font> ( tile.currentPosition.x == blankPosition.x &amp;&amp; tile.currentPosition.y == blankPosition.y+1 ){ <br> <font color="#0000ff">return</font> UP; <br> } <br> <font color="#008000">//     </font> <br> <font color="#0000ff">if</font> ( tile.currentPosition.x == blankPosition.x &amp;&amp; tile.currentPosition.y == blankPosition.y-1 ){ <br> <font color="#0000ff">return</font> DOWN; <br> } <br> <font color="#008000">//      </font> <br> <font color="#0000ff">if</font> ( tile.currentPosition.x == blankPosition.x+1 &amp;&amp; tile.currentPosition.y == blankPosition.y ){ <br> <font color="#0000ff">return</font> LEFT; <br> } <br> <font color="#008000">//      </font> <br> <font color="#0000ff">if</font> ( tile.currentPosition.x == blankPosition.x-1 &amp;&amp; tile.currentPosition.y == blankPosition.y ){ <br> <font color="#0000ff">return</font> RIGHT; <br> } <br> <font color="#0000ff">return</font> NONE; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  We implement the methods responsible for moving the fragment.  There will be two: " <strong>(movePiece: (Tile *) tile withAnimation: (BOOL) animate)</strong> " will determine in which direction the fragment can move, and pass the task of the actual movement to the following method - " <strong>movePiece: (Tile *) tile inDirectionX: (NSInteger ) dx inDirectionY: (NSInteger) dy withAnimation: (BOOL) animate)</strong> ".  The second method calculates the difference in <strong>x</strong> and <strong>y</strong> coordinates (depending on how empty it is with respect to the moving fragment) and, based on it, calculates the new position, interchanging the values ‚Äã‚Äãof " <strong>currentPosition</strong> " and " <strong>blankPosition</strong> ".  If " <strong>animate</strong> " is true, <strong>enclose</strong> the position parameters in the animation operators. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">-( <font color="#0000ff">void</font> ) movePiece:(Tile *) tile withAnimation:(BOOL) animate{ <br> <font color="#0000ff">switch</font> ( [self validMove:tile] ) { <br> <font color="#0000ff">case</font> UP: <br> [self movePiece:tile <br> inDirectionX:0 inDirectionY:-1 withAnimation:animate]; <br> <font color="#0000ff">break</font> ; <br> <font color="#0000ff">case</font> DOWN: <br> [self movePiece:tile <br> inDirectionX:0 inDirectionY:1 withAnimation:animate]; <br> <font color="#0000ff">break</font> ; <br> <font color="#0000ff">case</font> LEFT: <br> [self movePiece:tile <br> inDirectionX:-1 inDirectionY:0 withAnimation:animate]; <br> <font color="#0000ff">break</font> ; <br> <font color="#0000ff">case</font> RIGHT: <br> [self movePiece:tile <br> inDirectionX:1 inDirectionY:0 withAnimation:animate]; <br> <font color="#0000ff">break</font> ; <br> <font color="#0000ff">default</font> : <br> <font color="#0000ff">break</font> ; <br> } <br> } <br> <br> -( <font color="#0000ff">void</font> ) movePiece:(Tile *) tile inDirectionX:(NSInteger) dx inDirectionY:(NSInteger) dy withAnimation:(BOOL) animate{ <br> tile.currentPosition = CGPointMake( tile.currentPosition.x+dx, <br> tile.currentPosition.y+dy); <br> blankPosition = CGPointMake( blankPosition.x-dx, blankPosition.y-dy ); <br> <font color="#0000ff">int</font> x = tile.currentPosition.x; <br> <font color="#0000ff">int</font> y = tile.currentPosition.y; <br> <font color="#0000ff">if</font> ( animate ){ <br> [UIView beginAnimations: <font color="#A31515">@"frame"</font> context:nil]; <br> } <br> tile.frame = CGRectMake((tileWidth+TILE_SPACING)*x, (tileHeight+TILE_SPACING)*y, <br> tileWidth, tileHeight ); <br> <font color="#0000ff">if</font> ( animate ){ <br> [UIView commitAnimations]; <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  The final step is to create the " <strong>shuffle</strong> " method, which, as mentioned above, will perform the cycle the number of times corresponding to " <strong>SHUFFLE_NUMBER</strong> ", randomly moving the fragments for which movement is allowed. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">-( <font color="#0000ff">void</font> ) shuffle{ <br> NSMutableArray *validMoves = [[NSMutableArray alloc] init]; <br> srandom(time(NULL)); <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i=0; i&lt;SHUFFLE_NUMBER; i++ ){ <br> [validMoves removeAllObjects]; <br> <font color="#008000">// ,    </font> <br> <font color="#0000ff">for</font> ( Tile *t <font color="#0000ff">in</font> tiles ){ <br> <font color="#0000ff">if</font> ( [self validMove:t] != NONE ){ <br> [validMoves addObject:t]; <br> } <br> } <br> <font color="#008000">//      </font> <br> NSInteger pick = random()%[validMoves count]; <br> <font color="#008000">//NSLog(@"shuffleRandom using pick: %d from array of size %d", pick, [validMoves count]);</font> <br> [self movePiece  Tile *)[validMoves objectAtIndex:pick] withAnimation:NO]; <br> } <br> [validMoves release]; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Nothing new - we do what we have planned.  To select the fragment allowed to move, we cyclically move between everyone, putting those that can move into the array.  Having considered all the fragments, we randomly select one and shift it. <br><br>  It remains only to call the desired method.  At the bottom of the " <strong>initPuzzle (NSString *) imagePath</strong> " <strong>method</strong> , add the following line: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">[self shuffle];</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  OK.  Now our fragments are displayed on the screen, and in disarray.  It remains to add interactivity so that the user can move them.  To do this, we fix the touch and define the fragment that the user clicked.  If the fragment is allowed to move, move it. <br><br>  To begin with, we will implement a helper method that will return a fragment bound to a user‚Äôs touch. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">-(Tile *) getPieceAtPoint:(CGPoint) point{ <br> CGRect touchRect = CGRectMake(point.x, point.y, 1.0, 1.0); <br> <font color="#0000ff">for</font> ( Tile *t <font color="#0000ff">in</font> tiles ){ <br> <font color="#0000ff">if</font> ( CGRectIntersectsRect(t.frame, touchRect) ){ <br> <font color="#0000ff">return</font> t; <br> } <br> } <br> <font color="#0000ff">return</font> nil; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Now, having information on touch, we will determine which fragment the user clicked.  <strong>Cancel the touchesEnded</strong> method and move the selected fragment. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">- ( <font color="#0000ff">void</font> )touchesEnded:(NSSet *)touches withEvent:(UIEvent *) <font color="#0000ff">event</font> { <br> UITouch *touch = [touches anyObject]; <br> CGPoint currentTouch = [touch locationInView:self.view]; <br> Tile *t = [self getPieceAtPoint:currentTouch]; <br> <font color="#0000ff">if</font> ( t != nil ){ <br> [self movePiece:t withAnimation:YES]; <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  That's all - before you own puzzle.  Of course, you still need to determine the end of the game.  Add the following method to the code and access it each time the " <strong>touchesEnded</strong> " method moves a fragment. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">-(BOOL) puzzleCompleted{ <br> <font color="#0000ff">for</font> ( Tile *t <font color="#0000ff">in</font> tiles ){ <br> <font color="#0000ff">if</font> ( t.originalPosition.x != t.currentPosition.x || t.originalPosition.y != t.currentPosition.y ){ <br> <font color="#0000ff">return</font> NO; <br> } <br> } <br> <font color="#0000ff">return</font> YES; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  I leave the rest to you.  Those who are too lazy to finish can simply download the source code.  :) Thanks for attention. <br><br>  The source code for the lesson can be downloaded <a href=""><b>here</b></a> . </div><p>Source: <a href="https://habr.com/ru/post/68693/">https://habr.com/ru/post/68693/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../68680/index.html">Supercomputers go to SSD?</a></li>
<li><a href="../68681/index.html">Nao humanoid robot is easily controlled with Microsoft Surface</a></li>
<li><a href="../68684/index.html">Snow Leopard will come to Moscow tonight</a></li>
<li><a href="../68686/index.html">Combine the power of WebSphere sMash and Adobe Flex</a></li>
<li><a href="../68692/index.html">drivovo.com.ua - take 2</a></li>
<li><a href="../68695/index.html">Opera 10 Bookmark Indicator</a></li>
<li><a href="../68699/index.html">How to use operating system styles in CSS</a></li>
<li><a href="../68701/index.html">Video bodybuilding and fitness lessons or packaging information with DLE</a></li>
<li><a href="../68703/index.html">"Rosnano" will launch 100 training programs on nanotechnology</a></li>
<li><a href="../68705/index.html">Pedigree MS Windows `7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>