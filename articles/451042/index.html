<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The Basics of Database Design - PostgreSQL, Cassandra and MongoDB Comparison</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, friends. Before leaving for the second part of the May holidays, we are sharing with you the material that we translated on the eve of the laun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The Basics of Database Design - PostgreSQL, Cassandra and MongoDB Comparison</h1><div class="post__text post__text-html js-mediator-article">  Hello, friends.  Before leaving for the second part of the May holidays, we are sharing with you the material that we translated on the eve of the launch of a new stream in the <a href="https://otus.pw/zZdO/">‚ÄúRelational DBMS‚Äù</a> course. <br><br><img src="https://habrastorage.org/webt/tg/jk/pk/tgjkpk23xr333l_ee0lddnylafa.png"><br><br>  Application developers spend a lot of time comparing several operational databases to choose the one that best suits their intended workload.  Requirements may include simplified data modeling, transaction guarantees, read / write performance, scaling out, and fault tolerance.  Traditionally, the choice begins with a database category, SQL or NoSQL, since each category provides a clear set of trade-offs.  High performance in terms of low latency and high bandwidth is usually considered as a non-compromising requirement, and therefore is necessary for any database in the sample. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The purpose of this article is to help application developers make the right choice between SQL and NoSQL in the context of modeling application data.  We will look at one SQL database, namely PostgreSQL and two NoSQL databases, Cassandra and MongoDB, to talk about the basics of database design, such as creating tables, filling them, reading data from a table, and deleting them.  In the next article, we will definitely look at indices, transactions, JOINs, TTL directives, and JSON-based database design. <br><br>  <b>What is the difference between SQL and NoSQL?</b> <br><br><blockquote>  SQL databases increase application flexibility through transactional ACID guarantees, as well as through its ability to query data using a JOIN in unexpected ways, over existing normalized relational database models. </blockquote><br>  Considering their monolithic / single node architecture and the use of the master-slave replication model for redundancy, traditional SQL databases do not have two important features - linear write scalability (i.e., automatic separation into several nodes) and automatic / zero data loss.  This means that the amount of data received can not exceed the maximum throughput records of a single node.  In addition, some temporary data loss should be taken into account in fault tolerance (in an architecture without resource sharing).  Here we must keep in mind that recent commits have not yet been reflected in the slave copy.  Upgrades without downtime are also difficult to achieve in SQL databases. <br><br>  NoSQL databases are usually distributed by their nature, i.e.  data in them is divided into sections and distributed over several nodes.  They require denormalization.  This means that the entered data must also be copied several times to respond to specific requests that you send.  The overall goal is to achieve high performance by reducing the number of shards available during reading.  From this follows the statement that NoSQL requires you to simulate your queries, while SQL requires you to simulate your data. <br><br><blockquote>  NoSQL focuses on achieving high performance in a distributed cluster and this is the main rationale for many database design compromises, which include the loss of ACID transactions, JOINs and consistent global secondary indices. </blockquote><br>  It is believed that, although NoSQL databases provide linear write scalability and high fault tolerance, the loss of transactional guarantees makes them unsuitable for mission-critical data. <br><br>  The following table shows how data modeling in NoSQL differs from SQL. <br><br><img src="https://habrastorage.org/webt/sv/6k/or/sv6kor2fwminli9ywljf1hf5h34.png"><br><br>  <b>SQL and NoSQL: Why do we need both?</b> <br><br>  Real-world applications with a large number of users, such as Amazon.com, Netflix, Uber, and Airbnb, are performing complex, multi-sorted tasks.  For example, an e-commerce application like Amazon.com needs to store lightweight, highly critical data, such as information about users, products, orders, invoices, along with heavy, but less sensitive data, such as product reviews, support service messages. , user activity, reviews and user recommendations.  Naturally, these applications rely on at least one SQL database along with at least one NoSQL database.  In the interregional and global systems, the NoSQL database operates as a geo-distributed cache for data stored in a trusted source, an SQL database running in a single region. <br><br>  <b>How does YugaByte DB integrate SQL and NoSQL?</b> <br><br>  Built on log-based mixed storage engine, auto-sharding, sharding distributed consensus replication and ACID distributed transactions (inspired by Google Spanner), YugaByte DB is the world's first open source database that is also compatible with NoSQL (Cassandra &amp; Redis) ) and SQL (PostgreSQL).  As shown in the table below, YCQL, the YugaByte DB API compatible with Cassandra, adds the concepts of single- and multi-key ACID transactions and global secondary indexes to the NoSQL API, thereby opening the era of transactional NoSQL databases.  In addition, YCQL, a PostgreSQL compatible YugaByte DB API, adds the notion of linear write scaling and automatic fault tolerance to the SQL API, presenting distributed SQL databases to the world.  Since the YugaByte DB database is inherently transactional, the NoSQL API can now be used in the context of critical data. <br><br><img src="https://habrastorage.org/webt/ln/1a/_9/ln1a_9ouduu15ccxhvud1nssmme.png"><br><br>  As previously stated in the article <a href="https://blog.yugabyte.com/introducing-ysql-a-postgresql-compatible-distributed-sql-api-for-yugabyte-db/">‚ÄúIntroducing YSQL: A PostgreSQL Compatible Distributed SQL API for YugaByte DB‚Äù</a> , the choice between SQL or NoSQL in YugaByte DB depends entirely on the characteristics of the main workload: <br><br><ul><li>  If the main workload is a multi-key operation with JOINs, then when choosing YSQL, understand that your keys can be distributed across several nodes, which will lead to a higher delay and / or lower throughput than in NoSQL. </li><li>  Otherwise, choose either of the two NoSQL APIs, remembering that you will get better performance as a result of queries served from one node at a time.  YugaByte DB can serve as a single operating database for real complex applications in which you need to manage multiple workloads at the same time. </li></ul><br>  The data section lab in the next section is based on the PostgreSQL and Cassandra API-compatible YugaByte DB APIs, unlike the original databases.  This approach emphasizes the simplicity of interacting with two different APIs (on two different ports) of the same database cluster, as opposed to using completely independent clusters of two different databases. <br><br>  In the following sections, we will introduce the data modeling laboratory to illustrate the difference and some common features of the databases in question. <br><br>  <b>Laboratory data modeling</b> <br><br>  <b>Database installation</b> <br><br>  Given the emphasis on designing a data model (and not on complex deployment architectures), we will install the databases in the Docker containers on the local computer, and then we will interact with them using the corresponding command line shells. <br><br>  <b>Compatible with PostgreSQL &amp; Cassandra, YugaByte DB database</b> <br><br><pre><code class="sql hljs">mkdir ~/yugabyte &amp;&amp; cd ~/yugabyte wget https://downloads.yugabyte.com/yb-docker-ctl &amp;&amp; chmod +x yb-docker-ctl docker pull yugabytedb/yugabyte ./yb-docker-ctl <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-comment"><span class="hljs-comment">--enable_postgres</span></span></code> </pre> <br>  <b>MongoDB</b> <br><br><pre> <code class="sql hljs">docker run <span class="hljs-comment"><span class="hljs-comment">--name my-mongo -d mongo:latest</span></span></code> </pre> <br>  <b>Access via command line</b> <br><br>  Let's connect to databases using the command line shell for the corresponding APIs. <br><br>  <b>PostgreSQL</b> <br><br>  <a href="https://www.postgresql.org/docs/9.3/static/app-psql.html">psql</a> is a command line shell for interacting with PostgreSQL.  For ease of use, YugaByte DB comes with psql right in the bin folder. <br><br><pre> <code class="sql hljs">docker exec -it yb-postgres-n1 /home/yugabyte/postgres/bin/psql -p 5433 -U postgres</code> </pre> <br>  <b>Cassandra</b> <br><br>  <a href="http://cassandra.apache.org/doc/latest/tools/cqlsh.html">qlsh</a> is a command line shell for interacting with Cassandra and its compatible databases through CQL (Cassandra query language).  For ease of use, YugaByte DB comes with <code>cqlsh</code> in the <code>bin</code> . <br><br>  Note that CQL was inspired by SQL and has similar concepts for tables, rows, columns, and indexes.  However, as the NoSQL language, it adds a certain set of restrictions, most of which we will also cover in other articles. <br><br><pre> <code class="sql hljs">docker exec -it yb-tserver-n1 /home/yugabyte/bin/cqlsh</code> </pre> <br>  <b>MongoDB</b> <br><br>  <a href="https://docs.mongodb.com/manual/mongo/">mongo</a> is a command line shell for interacting with MongoDB.  It can be found in the bin directory of the MongoDB installation. <br><br><pre> <code class="sql hljs">docker exec -it my-mongo bash cd bin mongo</code> </pre> <br>  <b>Creating a table</b> <br><br>  Now we can interact with the database to perform various operations using the command line.  Let's start by creating a table that stores information about songs written by different artists.  These songs can be part of an album.  Also optional attributes for the song - year of release, price, genre and rating.  We need to take into account additional attributes that may be needed in the future through the "tags" field.  It can store semi-structured data as key-value pairs. <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music ( Artist <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SongTitle <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, AlbumTitle <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">25</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, Price <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Genre <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>), CriticRating <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Tags <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(Artist, SongTitle) );</code> </pre> <br>  <b>Cassandra</b> <br><br>  Creating a table in Cassandra is very similar to PostgreSQL.  <b>One of the main differences is the lack of integrity constraints (for example, NOT NULL), but this is the responsibility of the application, not the NoSQL database</b> .  The primary key consists of a partition key (the Artist column in the example below) and a clustering column set (the SongTitle column in the example below).  The partition key defines in which partition / shard a line is to be placed, and the clustering columns indicate how the data inside the current shard should be organized. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> KEYSPACE myapp; <span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> myapp; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music ( Artist <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, SongTitle <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, AlbumTitle <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>, Price <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Genre <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, CriticRating <span class="hljs-built_in"><span class="hljs-built_in">FLOAT</span></span>, Tags <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>(Artist, SongTitle) );</code> </pre> <br>  <b>MongoDB</b> <br><br>  MongoDB organizes data into databases (similar to Keyspace in Cassandra), where there are collections (similar to tables) containing documents (Documents) (similar to rows in a table).  In MongoDB, in principle, no initial schema definition is required.  The <i>‚Äúuse database‚Äù</i> command shown below creates a database instance on the first call and changes the context for the newly created database.  Even collections do not need to be created explicitly, they are created automatically, simply by adding the first document to a new collection.  Please note that MongoDB uses a test database by default, so any collection-level operation without specifying a specific database will be executed in it by default. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> myNewDatabase;</code> </pre> <br>  <b>Getting information about the PostgreSQL table</b> <br><br><pre> <code class="sql hljs">\d Music Table "public.music" Column | Type | Collation | Nullable | Default <span class="hljs-comment"><span class="hljs-comment">--------------+-----------------------+-----------+----------+-------- artist | character varying(20) | | not null | songtitle | character varying(30) | | not null | albumtitle | character varying(25) | | | year | integer | | | price | double precision | | | genre | character varying(10) | | | criticrating | double precision | | | tags | text | | | Indexes: "music_pkey" PRIMARY KEY, btree (artist, songtitle)</span></span></code> </pre> <br>  <b>Cassandra</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DESCRIBE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> MUSIC; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> myapp.music ( artist <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, songtitle <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, albumtitle <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, price <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>, genre <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, tags <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (artist, songtitle) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLUSTERING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> (songtitle <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> default_time_to_live = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> transactions = {<span class="hljs-string"><span class="hljs-string">'enabled'</span></span>: <span class="hljs-string"><span class="hljs-string">'false'</span></span>};</code> </pre> <br>  <b>MongoDB</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> myNewDatabase; <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> collections;</code> </pre> <br>  <b>Entering data into the PostgreSQL table</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, <span class="hljs-keyword"><span class="hljs-keyword">Year</span></span>, Price, Genre, CriticRating, Tags) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>, <span class="hljs-string"><span class="hljs-string">'Call Me Today'</span></span>, <span class="hljs-string"><span class="hljs-string">'Somewhat Famous'</span></span>, <span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">2.14</span></span>, <span class="hljs-string"><span class="hljs-string">'Country'</span></span>, <span class="hljs-number"><span class="hljs-number">7.8</span></span>, <span class="hljs-string"><span class="hljs-string">'{"Composers": ["Smith", "Jones", "Davis"],"LengthInSeconds": 214}'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre, CriticRating) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>, <span class="hljs-string"><span class="hljs-string">'My Dog Spot'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hey Now'</span></span>, <span class="hljs-number"><span class="hljs-number">1.98</span></span>, <span class="hljs-string"><span class="hljs-string">'Country'</span></span>, <span class="hljs-number"><span class="hljs-number">8.4</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span>, <span class="hljs-string"><span class="hljs-string">'Look Out, World'</span></span>, <span class="hljs-string"><span class="hljs-string">'The Buck Starts Here'</span></span>, <span class="hljs-number"><span class="hljs-number">0.99</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> Music (Artist, SongTitle, AlbumTitle, Price, Genre, Tags) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>( <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span>, <span class="hljs-string"><span class="hljs-string">'Still In Love'</span></span>, <span class="hljs-string"><span class="hljs-string">'The Buck Starts Here'</span></span>, <span class="hljs-number"><span class="hljs-number">2.47</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-string"><span class="hljs-string">'{"radioStationsPlaying": ["KHCR", "KBQX", "WTNR", "WJJH"], "tourDates": { "Seattle": "20150625", "Cleveland": "20150630"}, "rotation": Heavy}'</span></span> );</code> </pre> <br>  <b>Cassandra</b> <br><br>  In general, the <code>INSERT</code> in Cassandra looks very similar to that in PostgreSQL.  However, there is one big difference in semantics.  In Cassandra, the <code>INSERT</code> actually a <code>UPSERT</code> operation, where the last values ‚Äã‚Äãare added to the string, in case the string already exists. <br><blockquote>  Data entry is similar to PostgreSQL <code>INSERT</code> above. </blockquote><br>  <b>MongoDB</b> <br><br>  Although MongoDB is a NoSQL database, like Cassandra, its data entry operation has nothing to do with semantic behavior in Cassandra.  In MongoDB, <a href="https://docs.mongodb.com/manual/reference/method/db.collection.insert/">insert ()</a> does not have a <code>UPSERT</code> capability, which makes it look like PostgreSQL.  Adding default data without <code>_idspecified</code> will add a new document to the collection. <br><br> <code>db.music.insert( { <br> artist: "No One You Know", <br> songTitle: "Call Me Today", <br> albumTitle: "Somewhat Famous", <br> year: 2015, <br> price: 2.14, <br> genre: "Country", <br> tags: { <br> Composers: ["Smith", "Jones", "Davis"], <br> LengthInSeconds: 214 <br> } <br> } <br> ); <br> db.music.insert( { <br> artist: "No One You Know", <br> songTitle: "My Dog Spot", <br> albumTitle: "Hey Now", <br> price: 1.98, <br> genre: "Country", <br> criticRating: 8.4 <br> } <br> ); <br> db.music.insert( { <br> artist: "The Acme Band", <br> songTitle: "Look Out, World", <br> albumTitle:"The Buck Starts Here", <br> price: 0.99, <br> genre: "Rock" <br> } <br> ); <br> db.music.insert( { <br> artist: "The Acme Band", <br> songTitle: "Still In Love", <br> albumTitle:"The Buck Starts Here", <br> price: 2.47, <br> genre: "Rock", <br> tags: { <br> radioStationsPlaying:["KHCR", "KBQX", "WTNR", "WJJH"], <br> tourDates: { <br> Seattle: "20150625", <br> Cleveland: "20150630" <br> }, <br> rotation: "Heavy" <br> } <br> } <br> );</code> <br> <br>  <b>Query table</b> <br><br>  Perhaps the most significant difference between SQL and NoSQL in terms of query design is the use of the <code>FROM</code> and <code>WHERE</code> clauses.  SQL allows you to select several tables after the <code>FROM</code> , and the <code>WHERE</code> can be of any complexity (including <code>JOIN</code> operations between tables).  However, NoSQL tends to impose a hard constraint on the <code>FROM</code> , and to work with only one specified table, and in <code>WHERE</code> , the primary key must always be specified.  This is due to the desire to improve the performance of NoSQL, which we talked about earlier.  This desire leads to a complete reduction of any cross-tabular and cross-key interaction.  It can lead to a large delay in inter-node communication when responding to a request and, therefore, it is best avoided in principle.  For example, Cassandra requires that queries be limited to certain operators (only allowed <code>=, IN, &lt;, &gt;, =&gt;, &lt;=</code> ) on partition keys, except when requesting a secondary index (only operator = is allowed here). <br><br>  <b>PostgreSQL</b> <br><br>  Below are three examples of queries that can be easily executed by a SQL database. <br><br><ul><li>  Display all the songs of the artist; </li><li>  Display all the songs of the artist, coinciding with the first part of the title; </li><li>  Print all the songs of the artist with a certain word in the title and having a price less than 1.00. </li></ul><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'Call%'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'%Today%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Price &gt; <span class="hljs-number"><span class="hljs-number">1.00</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br>  Of the PostgreSQL queries listed above, only the first will work unchanged in Cassandra, since the <code>LIKE</code> operator cannot be applied to clustering columns, such as <code>SongTitle</code> .  In this case, only the <code>=</code> and <code>IN</code> operators are allowed. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist=<span class="hljs-string"><span class="hljs-string">'No One You Know'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'Call Me Today'</span></span>, <span class="hljs-string"><span class="hljs-string">'My Dog Spot'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Price &gt; <span class="hljs-number"><span class="hljs-number">1.00</span></span>;</code> </pre> <br>  <b>MongoDB</b> <br><br>  As shown in the previous examples, the main method for creating queries in MongoDB is <a href="https://docs.mongodb.com/manual/reference/method/db.collection.find/">db.collection.find ()</a> .  This method explicitly contains the name of the collection ( <code>music</code> in the example below), so a request for several collections is prohibited. <br><br><pre> <code class="sql hljs">db.music.find( { artist: "No One You Know" } ); db.music.find( { artist: "No One You Know", songTitle: /<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>/ } );</code> </pre> <br>  <b>Read all rows in a table</b> <br><br>  Reading all the lines is just a special case of the query template we considered earlier. <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music;</code> </pre> <br><br>  <b>Cassandra</b> <br><br><blockquote>  Similar to the example in PostgreSQL above. </blockquote><br><br>  MongoDB <br><br><pre> <code class="sql hljs">db.music.find( {} );</code> </pre> <br>  <b>Editing data in the table</b> <br><br>  <b>PostgreSQL</b> <br><br>  PostgreSQL provides an <code>UPDATE</code> for modifying data.  It does not have <code>UPSERT</code> capabilities, so the execution of this instruction will fail if the row is no longer in the database. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Genre = <span class="hljs-string"><span class="hljs-string">'Disco'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist = <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle = <span class="hljs-string"><span class="hljs-string">'Still In Love'</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br>  Cassandra has <code>UPDATE</code> similar to PostgreSQL.  <code>UPDATE</code> has the same <code>UPSERT</code> semantics, like <code>INSERT</code> . <br><br><blockquote>  Similar to the example in PostgreSQL above. </blockquote><br>  <b>MongoDB</b> <br>  The <a href="https://docs.mongodb.com/manual/reference/method/db.collection.update/">update ()</a> operation in MongoDB can completely update an existing document or update only certain fields.  By default, it updates only one document with the <code>UPSERT</code> semantics <code>UPSERT</code> .  Updating of several documents and behavior similar to <code>UPSERT</code> can be applied by setting additional flags for the operation.  As for example, in the example below, the genre of a particular artist is updated according to his song. <br><br><pre> <code class="sql hljs">db.music.update( {"artist": "The Acme Band"}, { $<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: { <span class="hljs-string"><span class="hljs-string">"genre"</span></span>: <span class="hljs-string"><span class="hljs-string">"Disco"</span></span> } }, {<span class="hljs-string"><span class="hljs-string">"multi"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"upsert"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>} );</code> </pre> <br>  <b>Deleting data from a table</b> <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Music <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> Artist = <span class="hljs-string"><span class="hljs-string">'The Acme Band'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> SongTitle = <span class="hljs-string"><span class="hljs-string">'Look Out, World'</span></span>;</code> </pre> <br>  <b>Cassandra</b> <br><br><blockquote>  Similar to the example in PostgreSQL above. </blockquote><br>  <b>MongoDB</b> <br><br>  In MongoDB, there are two types of operations for deleting documents ‚Äî <a href="https://docs.mongodb.com/manual/reference/method/db.collection.deleteOne/">deleteOne ()</a> <a href="https://docs.mongodb.com/manual/reference/method/db.collection.deleteMany/">/ deleteMany ()</a> and <a href="https://docs.mongodb.com/manual/reference/method/db.collection.remove/">remove ()</a> .  Both types delete documents, but return different results. <br><br><pre> <code class="sql hljs">db.music.deleteMany( { artist: "The Acme Band" } );</code> </pre><br>  <b>Deleting a table</b> <br><br>  <b>PostgreSQL</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Music;</code> </pre> <br>  <b>Cassandra</b> <br><br><blockquote>  Similar to the example in PostgreSQL above. </blockquote><br>  <b>MongoDB</b> <br><br><pre> <code class="sql hljs">db.music.drop();</code> </pre> <br>  <b>Conclusion</b> <br><br>  The debate about choosing between SQL and NoSQL has been raging for more than 10 years.  There are two main aspects of this dispute: the database core architecture (monolithic, transactional SQL versus distributed, non-transactional NoSQL) and the database design approach (data modeling in SQL versus modeling your queries in NoSQL). <br><br>  With a distributed transactional database, such as YugaByte DB, debates about database architecture can be easily dispelled.  As data volumes become larger than what can be written to a single node, a fully distributed architecture that supports linear scalability of recording with automatic sharding / rebalancing becomes necessary. <br><br>  In addition, as stated in one of the articles of <a href="https://cloud.google.com/blog/products/gcp/why-you-should-pick-strong-consistency-whenever-possible">Google Cloud</a> , transactional, strictly coordinated architectures are now more widely used to provide better development flexibility than non-transactional, ultimately consistent architectures. <br><br>  Returning to the discussion of database design, it is fair to say that both design approaches (SQL and NoSQL) are necessary for any complex real-world application.  The SQL ‚Äúdata modeling‚Äù approach allows developers to more easily meet changing business requirements, while the NoSQL ‚Äúquery modeling‚Äù approach allows the same developers to handle large amounts of data with low latency and high throughput.  It is for this reason that YugaByte DB provides the SQL and NoSQL API in a common core, and does not promote any one of the approaches.  In addition, ensuring compatibility with popular database languages, including PostgreSQL and Cassandra, YugaByte DB ensures that developers do not have to learn another language in order to work with a distributed, strictly consistent database engine. <br><br>  In this article, we figured out how the basics of database design differ in PostgreSQL, Cassandra, and MongoDB.  In the following articles, we will dive into advanced design concepts such as indices, transactions, JOINs, TTL directives, and JSON documents. <br><br>  We wish you a great rest of the weekend and invite you to a <a href="https://otus.pw/3vwc/">free webinar</a> , which will be held on May 14th. </div><p>Source: <a href="https://habr.com/ru/post/451042/">https://habr.com/ru/post/451042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45102/index.html">One billion downloads addons</a></li>
<li><a href="../45103/index.html">Photosynty and panorama of Yekaterinburg</a></li>
<li><a href="../451032/index.html">We write HTTP / 1.1 & HTTP / 2 client and server on Golang</a></li>
<li><a href="../45104/index.html">my.opera.com loves Habrahabr</a></li>
<li><a href="../451040/index.html">Unrestrained fun in May, or Standoff approaching</a></li>
<li><a href="../451044/index.html">IMaskjs - 3 years in open source</a></li>
<li><a href="../45105/index.html">Russian group order for Neo FreeRunners arrived</a></li>
<li><a href="../451056/index.html">Introduction to MS Dynamics CRM</a></li>
<li><a href="../451058/index.html">Corporate workshop</a></li>
<li><a href="../451066/index.html">We disassemble the ending of "Alien"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>