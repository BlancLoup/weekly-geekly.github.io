<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From Scheduler to Scheduler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="See two other articles in this group - Multi- tasking and Pre-emptiveness: How to take away the processor . 

 Immediately request to strict readers. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From Scheduler to Scheduler</h1><div class="post__text post__text-html js-mediator-article">  See two other articles in this group - <a href="https://habrahabr.ru/post/282049/">Multi-</a> <a href="https://habrahabr.ru/post/282037/">tasking</a> and <a href="https://habrahabr.ru/post/282049/">Pre-emptiveness: How to take away the processor</a> . <br><br>  Immediately request to strict readers.  If you do not understand any of the terms used - ask, I will tell you what I had in mind.  And if you <b>like a</b> different spelling or translation of this term - enter it in the comments.  I apply those that I like. <br><br>  So, in the previous articles, the mechanism of multitasking minus the scheduler is described, he is a sheduler, he is a skeduler, <s>he is Vaska tagged</s> , sorry, I will talk to these terms ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As I have already said, the sheduler is just a function that answers the question: what thread and how long to put on the processor. <br><br>  By the way, in the SMP system the sheduler is no different from a single-processor one.  In general, to make it easier to understand the structure of interaction of entities on one and several processors, it is easiest to imagine the following model: for each processor there is a ‚Äúidle‚Äù thread (which works, if there is no one else at all, and just stop the processor before the interruption), which constantly tries to ‚Äúgive‚Äù "The processor (which it seems to own) to other threads, choosing a thread using a sheduler. <br><br>  Speaking of the sheduler can not be said about the priorities. <br><br>  The priority is the property of the thread (or process) affecting the competition of this thread with other threads for the processor. <br><br>  The priority is usually described by the pair &lt;priority class, priority value inside the class&gt;. <br><a name="habracut"></a><br>  To date, a fairly clear scheme for the implementation of priorities has been formed.  Thread priorities are divided into three classes: <br><br><ul><li>  Real time: threads of this class are always crowded out of the processor by threads of other classes as quickly as possible, and are never removed from the processor except by the presence of a thread with a higher <b>real-time</b> priority.  That is, such threads themselves must decide when they no longer need a processor. </li><li>  Separation of time: the threads of this class always crowd out the idle class threads from the processor, and the time division threads compete softly among themselves.  Two threads of this class with different values ‚Äã‚Äãof priority will receive a different percentage of processor time, but they will definitely receive it, even if the values ‚Äã‚Äãof priorities differ in the limiting way. </li><li>  Idle class: threads of this class receive a processor only if there are no threads of other classes ready for execution, ‚Äúfor change‚Äù.  Personally, I do not see the point in the priority value inside the idle class.  Although this also happens. </li></ul><br><br>  By the way.  They say that Kernighan was somehow asked what he would have done differently if Unix had written anew.  ‚ÄúI would write creat as create,‚Äù replied the master.  I would add another bag of absurdities to the list of fixes, starting with nice - for some reason, the concept of priority in Unix is ‚Äã‚Äãprimed.  Than nice less, the priority is higher. <br><br>  We are in this article will adhere to a more human-loving scale: higher numerical value = more processor. <br><br>  Someone, probably, already wants to glance in the code.  Here he is: <br>  <a href="">The original text of the Phantom Scheduler</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Here we play a little Pushkin :)</b> <div class="spoiler_text">  And now frost is cracking <br>  And silver among the fields ... <br>  (The reader is waiting for the rhyme of the rose; <br>  On, here, take it soon!) <br></div></div><br><br>  By the way about Pushkin.  I categorically do not pretend to any sacred knowledge in the field of writing planners.  The example given is a hackneyed and banal, albeit a quite reasonable implementation.  Nevertheless, the writing of a good sheduler is a very serious scientific task, theses write about it, and if it comes to real time, everything becomes very serious.  In this article I only cover the basics.  There are specialists in our country who know about three orders of magnitude more on this subject than yours truly. <br><br>  For this - we continue. <br><br>  A fairly traditional implementation of a sheduler implies the existence of a so-called run queue - a queue of threads ready for execution.  Actually, this is not necessarily a queue, and if there is a queue, then, usually, a set of queues belonging to different classes, and sometimes to levels of priorities. <br><br>  Specifically, in Phantom there are three lines according to the classes: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** Idle prio threads */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">queue_head_t</span></span> runq_idle = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">/** Normal prio threads */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">queue_head_t</span></span> runq_norm = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">/** Realtime prio threads */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">queue_head_t</span></span> runq_rt = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre> <br><br>  In general, the thread in relation to the processor can be in three states: <br><br><ul><li>  Blocked.  Not on the processor, can not be put on it.  Missing in any run queue. </li><li>  Performed.  Missing in any run queue. </li><li>  It can be executed.  Present in any run queue. </li></ul><br><br>  That is, there are threads in the run queue that would like to get to the processor. <br><br>  Hence, the work of the scheduler is to: <br><br><ol><li>  To decide on the thread of which priority class we will now run.  It's simple - check if the realtime queue is not empty - if not empty, then we start the realtime thread, check the queue of normal priorities - if not empty, then we start the normal thread.  Otherwise, run the idle thread.  If there are no such ones, we note that the idle processor and go to the thread of "eternal" sleep. </li><li>  If you decide on a priority - choose the correct thread for execution in this priority. </li><li>  Assign threads time interval for execution. </li></ol><br><br>  In general, the implementation is rather banal.  Let's start with real time.  The naive implementation sorts the available threads and starts the thread with the maximum numerical value of the priority.  The time interval is not assigned, since it is not checked for real-time priority threads. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Have some realtime? if( !queue_empty(&amp;runq_rt) ) { int maxprio = -1; phantom_thread_t *best = 0; phantom_thread_t *it = 0; queue_iterate(&amp;runq_rt, it, phantom_thread_t *, runq_chain) { if( it-&gt;thread_flags &amp; THREAD_FLAG_NOSCHEDULE ) continue; if( ((int)it-&gt;priority) &gt; maxprio ) { maxprio = it-&gt;priority; best = it; } } if( best ) { assert(t_is_runnable(best)); return best; } }</span></span></code> </pre><br><br>  The obvious improvement of the code is not to sort all the threads in the sheduler, but to insert the thread into the queue in descending order of numerical priority.  Then the scheduler simply takes out the first thread from the queue and starts it. <br><br>  Now threads with a time-sharing class priority ‚Äî that is, regular threads gently competing for the processor. <br><br>  Here it should be noted that the variable ticks_left in the structure of the thread state determines how many 10 ms intervals the thread will hold on the processor. <br><br>  First, consider what the t_assign_time () function does: <br><br><pre> <code class="cpp hljs"> it-&gt;ticks_left = NORM_TICKS + it-&gt;priority;</code> </pre><br><br>  She checks that all threads have spent their ticks_left, and if so - assigns them new ticks_left - to those with higher priority - gives more CPU time. <br><br>  What does the scheduler do?  It selects the thread with the highest priority and with a non-zero remainder of the processor time, and it launches it: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Have normal one? if( !queue_empty(&amp;runq_norm) ) { // If no normal thread has ticks left, reassign // ticks and retry do { unsigned int maxprio = 0; // NB! not a negative number! phantom_thread_t *best = 0; phantom_thread_t *it = 0; queue_iterate(&amp;runq_norm, it, phantom_thread_t *, runq_chain) { if( it-&gt;thread_flags &amp; THREAD_FLAG_NOSCHEDULE ) continue; if( (it-&gt;priority &gt; maxprio) &amp;&amp; (it-&gt;ticks_left &gt; 0) ) { maxprio = it-&gt;priority; best = it; } } if( best ) { return best; } } while(t_assign_time()); }</span></span></code> </pre><br><br>  When all the residues of all threads have run out - asks t_assign_time () to assign new residues to the threads. <br><br>  In general, sorting is relatively redundant here.  Simply add the threads to the end of the queue, and choose from the beginning - fair enough.  In general, sorting all the threads is obviously bad, don't do that.  I will also rewrite this piece in a more optimal way, for example, as already described above, for realtime. <br><br>  By the way, when reading the scheduler code, it is necessary to take into account that the threads do not always ‚Äúeat up‚Äù their time quantum - the thread can be locked on the synchronization primitive and part of the time not standing on its own accord.  This is the reason for sorting: if the priority of the thread is high, then the thread after unlocking will return to the processor before finalizing all other threads. <br><br>  Ok, let's move on to the idle priority class.  We will get here only if in previous classes all threads are asleep or missing. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Have idle one? ret = (phantom_thread_t *)queue_first(&amp;runq_idle); if( ret ) { if( ret-&gt;thread_flags &amp; THREAD_FLAG_NOSCHEDULE ) goto idle_retry; // Just take first. Switched off thread will become // last on runq, so all idle threads will run in cycle ret-&gt;ticks_left = NORM_TICKS; return ret; } else goto idle_no;</span></span></code> </pre><br><br>  Everything is simple here - we take the first one that we get, we start it at the standard time.  Since it is at the end of the runq_idle queue when removed from the processor, all such threads will be launched in a circle. <br><br>  Finally, if there is nothing at all, we have a special idlest thread for this case. <br><br><pre> <code class="cpp hljs"> STAT_INC_CNT(STAT_CNT_THREAD_IDLE); percpu_idle_status[GET_CPU_ID()] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// idle return GET_IDLEST_THREAD(); // No real thread is ready to run</span></span></code> </pre><br><br>  It has its own processor, simply because one thread cannot be run twice.  Simple as mooing: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { hal_sti(); hal_wait_for_interrupt(); }</code> </pre><br><br>  Almost all. <br><br>  What is not considered here. <br><br>  <b>Interactive thread prio boost</b> : Usually, schedulers increase the actual priority to threads that are seen in the I / O from the console or another entity, which, potentially, hides an interactive user.  This increases the perceptual reactivity of the system - ‚ÄúOS less tupit‚Äù from the point of view of a person.  And vice versa - if the thread ‚Äúfinishes up‚Äù its timeline to the end, and makes it stable, it lowers its priority a little, considering it to be purely computational.  With the same purpose - to increase the reactivity of the system. <br><br>  This, of course, applies only to threads with a normal priority class - no one ever touches real-time priorities. <br><br>  <b>Planning real time with a guaranteed share of the processor</b> .  Strict real-time systems have a hard plan, within which a thread or group of threads can receive a clearly defined amount of processor time. <br><br>  <b>Inversion of priorities.</b> <br><br>  Suppose we have a terribly important thread R with maximum real-time priority, and thread I with class priority idle, which deals with insignificant nonsense.  As well as the usual thread U, which works with the user - reads commands from the console.  Shell, for example. <br><br>  The user is idle, waiting for input-output and the thread U. <br><br>  Thread I receives a processor, decides to do its own nonsense and wants to allocate some memory for itself.  The kernel memory allocation function locks the global mutex and starts allocating.  Working on an idle prio, obviously. <br><br>  At this moment, the thread R wakes up, and it is time to correct the position of the core of the absorber of the reactor core.  And also wants some memory. <br><br>  (Let's not pick and choose what U and R are doing on the same machine - U might be a TCP statistics server, for example.) <br><br>  Naturally, R takes the processor from I, but rests on the global mutex when allocating memory, and stops. <br><br>  Here I would continue to work, but the user is typing a command, and U gets to work, taking the processor away from I. Now, suddenly, a high-priority real-time thread R is waiting for the end of the U thread, and the reactor explodes to hell. <br><br>  In order for this not to happen, they do what I have not done in Phantom yet - inversion of priorities. <br><br>  It is formulated as follows: if a higher priority thread is blocked on a resource occupied by a low priority thread, the second thread receives the priority of the first thread for the time of such blocking. <br><br>  That is, in our example, thread I should have received real-time priority from thread R for blocking mutex allocation, displacing thread U to the hell and finishing what blocks thread R. After unlocking mutex, its priority should go back to idle and the processor will go to R, as it should be. <br><br>  Now, probably, everything.  :) </div><p>Source: <a href="https://habr.com/ru/post/282213/">https://habr.com/ru/post/282213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282199/index.html">Robokassa stopped working with individual entrepreneurs and individuals</a></li>
<li><a href="../282203/index.html">Pavel Durov will distribute $ 1 000 000 to Telegram bots developers</a></li>
<li><a href="../282205/index.html">Backdrop Licensing FAQ</a></li>
<li><a href="../282207/index.html">Floors: 3D-navigation on WebGL in 2gis.ru</a></li>
<li><a href="../282209/index.html">PHDays VI member stories: how Moxy Marlinspike defeated the FBI, and John Bambenek figured out hacker No. 1</a></li>
<li><a href="../282215/index.html">Tomorrow, April 23, 2016 - see the online broadcast of the Russian final of the Imagine Cup</a></li>
<li><a href="../282217/index.html">Once again about deb packages</a></li>
<li><a href="../282223/index.html">Analysis of email messages in 18 years: Unsuccessful time travel experiment</a></li>
<li><a href="../282225/index.html">Escape from Crypto Pro. Director's version, SMEV-edition</a></li>
<li><a href="../282227/index.html">FBI generously rewarded hackers for exploiting for iPhone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>