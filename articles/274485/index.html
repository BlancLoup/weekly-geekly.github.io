<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>String and & str in Rust functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is dedicated to all those who are confused by the need to use to_string() to make the program compile. And I hope to shed some light on the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>String and & str in Rust functions</h1><div class="post__text post__text-html js-mediator-article"><a href="http://habrahabr.ru/post/274485/"><img align="left" src="https://habrastorage.org/files/072/404/e65/072404e65d40439ebae44842d3752178.png" alt="" title="KDPV"></a> <br>  This post is dedicated to all those who are confused by the need to use <code>to_string()</code> to make the program compile.  And I hope to shed some light on the question of why Rust has two string types, <code>String</code> and <code>&amp;str</code> . <br><a name="habracut"></a><br><br><br><h3>  Functions that take strings </h3><br>  I want to discuss how to create interfaces that accept strings.  I am a big fan of hypermedia and am passionate about creating easy-to-use interfaces.  Let's start with the method that accepts <a href="https://doc.rust-lang.org/std/string/struct.String.html%3Fsearch%3DString"><code>String</code></a> .  Our search will lead us to the type <code>std::string::String</code> , which is not bad at first. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_me</span></span></span></span>(msg: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">": {}"</span></span>, msg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">", "</span></span>; print_me(message); }</code> </pre><br>  We get a compilation error: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="rust hljs">expected `collections::string::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>`, found `&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>`</code> </pre><br>  It turns out that the string literal of the type <code>&amp;str</code> not compatible with the type <code>String</code> .  We need to change the type of the <code>message</code> variable to <code>String</code> so that the compilation succeeds: <code>let message = ", ".to_string();</code>  .  It will work this way, but it's like using <code>clone()</code> to fix ownership-inheritance errors.  Here are three reasons to change the type of the <code>print_me</code> argument to <code>&amp;str</code> : <br><br><ul><li>  The symbol <code>&amp;</code> denotes the reference type, that is, we give the variable a <i>loan</i> .  When <code>print_me</code> finishes working with a variable, ownership is returned to its original owner.  If we don't have a good reason to <i>transfer</i> ownership of the <code>message</code> variable to our function, we should use borrowing. </li><li>  Using links more effectively.  Using <code>String</code> for <code>message</code> means the program should <i>copy the</i> value.  When using a link such as <code>&amp;str</code> , copying does not occur. </li><li>  Type <code>String</code> can magically turn into <code>&amp;str</code> using the <a href="http://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code>Deref</code></a> type and type casting.  An example will allow to understand this moment much better. </li></ul><br><h3>  Example of dereference reduction </h3><br>  In this example, lines are created in four different ways, and they all work with the <code>print_me</code> function.  The main point by which all this works is the transfer of values ‚Äã‚Äãby reference.  Instead of passing the owned string <code>owned_string</code> as a <code>String</code> , we pass it as a <code>&amp;String</code> pointer.  When the compiler sees that <code>&amp;String</code> passed to a function that accepts <code>&amp;str</code> , it leads <code>&amp;String</code> to <code>&amp;str</code> .  Exactly the same conversion is used when using strings with a normal and atomic reference counter.  The variable <code>string</code> already a reference, so there is no need to use <code>&amp;</code> when calling <code>print_me(string)</code> .  With this knowledge, we no longer need to constantly call <code>.to_string()</code> on our code. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_me</span></span></span></span>(msg: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"msg = {}"</span></span>, msg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> string = <span class="hljs-string"><span class="hljs-string">", "</span></span>; print_me(string); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> owned_string = <span class="hljs-string"><span class="hljs-string">", "</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">//  String::from_str(", ") print_me(&amp;owned_string); let counted_string = std::rc::Rc::new(", ".to_string()); print_me(&amp;counted_string); let atomically_counted_string = std::sync::Arc::new(", ".to_string()); print_me(&amp;atomically_counted_string); }</span></span></code> </pre><br>  You can also use dereferencing casts with other types, such as <code>Vec</code> .  All the same, <code>String</code> is just a vector of eight-byte characters.  You can read more about <a href="http://kgv.github.io/rust_book_ru/src/deref-coercions.html">coercion with dereferencing</a> ( <a href="https://doc.rust-lang.org/stable/book/deref-coercions.html">English</a> ) in the book ‚Äú <a href="https://www.gitbook.com/book/kgv/rust_book_ru/details">Rust Programming Language</a> ‚Äù ( <a href="https://doc.rust-lang.org/stable/book/">English</a> ). <br><br><h3>  Use of structures </h3><br>  At this point, we should already be free from unnecessary calls <code>to_string()</code> .  However, we may have some problems when using structures.  Using existing knowledge, we could create such a structure: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span> { name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _person = Person { name: <span class="hljs-string"><span class="hljs-string">"Herman"</span></span> }; }</code> </pre><br>  We will get this error: <br><br><pre> <code class="rust hljs">&lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span> error: missing lifetime specifier [E0106] &lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">2</span></span> name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>,</code> </pre><br>  Rust tries to make sure that <code>Person</code> cannot survive the <code>name</code> reference.  If <code>Person</code> survives the <code>name</code> , there is a risk of the program crashing.  The main goal of Rust is to prevent this.  Let's make this code compile.  We need to specify the <a href="http://kgv.github.io/rust_book_ru/src/lifetimes.html">time of life</a> ( <a href="http://doc.rust-lang.org/stable/book/lifetimes.html">English</a> ), or scope, so that Rust could provide us security.  Typically, the lifetime is called: <code>'a</code> .  I do not know where this tradition came from, but we will follow it. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span> { name: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>,' } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _person = Person { name: <span class="hljs-string"><span class="hljs-string">"Herman"</span></span> }; }</code> </pre><br>  When trying to compile, we get the following error: <br><br><pre> <code class="rust hljs">&lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">14</span></span> error: <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of undeclared lifetime name `<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>` [E0261] &lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">2</span></span> name: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>,</code> </pre><br>  Let's think about it.  We know that we want to somehow convey to the Rust compiler the idea that the <code>Person</code> structure should not survive the <code>name</code> field.  So we need to declare the lifetime of the <code>Person</code> structure.  Short searches lead us to syntax for declaring the lifetime: <code>&lt;'a&gt;</code> . <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { name: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _person = Person { name: <span class="hljs-string"><span class="hljs-string">"Herman"</span></span> }; }</code> </pre><br>  It compiles!  Usually we implement some methods on structures.  Let's add a <code>greet</code> method to our <code>Person</code> class. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { name: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Person { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">",   {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = Person { name: <span class="hljs-string"><span class="hljs-string">"Herman"</span></span> }; person.greet(); }</code> </pre><br>  Now we get this error: <br><br><pre> <code class="rust hljs">&lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">12</span></span> error: wrong number of lifetime parameters: expected <span class="hljs-number"><span class="hljs-number">1</span></span>, found <span class="hljs-number"><span class="hljs-number">0</span></span> [E0107] &lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Person {</code> </pre><br>  Our <code>Person</code> structure has a lifetime parameter, so our implementation should also have it.  Let's declare the lifetime <code>'a</code> in the implementation of <code>Person</code> like this: <code>impl Person&lt;'a&gt; {</code> .  Alas, now we get this strange compilation error: <br><br><pre> <code class="rust hljs">&lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span> error: <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> of undeclared lifetime name `<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>` [E0261] &lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Person&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; {</code> </pre><br>  In order for us <i>to declare</i> the lifetime, we need to specify the lifetime immediately after the <code>impl</code> like this: <code>impl&lt;'a&gt; Person {</code> .  We compile again, we get an error: <br><br><pre> <code class="rust hljs">&lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span> error: wrong number of lifetime parameters: expected <span class="hljs-number"><span class="hljs-number">1</span></span>, found <span class="hljs-number"><span class="hljs-number">0</span></span> [E0107] &lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Person {</code> </pre><br>  Already clearer.  Let's add the lifetime parameter in the description of the <code>Person</code> structure to its implementation like this: <code>impl&lt;'a&gt; Person&lt;'a&gt; {</code> .  Now the program will be compiled.  Here is the full working code: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { name: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Person&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">",   {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = Person { name: <span class="hljs-string"><span class="hljs-string">"Herman"</span></span> }; person.greet(); }</code> </pre><br><h3>  String or &amp; str in structures </h3><br>  Now the question arises: when should <code>String</code> be used, and when <code>&amp;str</code> in structures?  In other words, when should I use a reference to another type in a structure?  We should use references if our structure does not require ownership of the variable.  The meaning may be slightly blurred, so I use several rules to answer this question. <br><br><ul><li>  Should I use a variable outside the structure?  Here is a slightly contrived example: </li></ul><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Person { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">",   {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from_str(<span class="hljs-string"><span class="hljs-string">"Herman"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = Person { name: name }; person.greet(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  {}"</span></span>, name); <span class="hljs-comment"><span class="hljs-comment">// move error }</span></span></code> </pre><br>  Here I should use the link, since I will need to use a variable before placing it in the structure.  A real-life example is <a href="">rustc_serialize</a> .  The <code>Encoder</code> structure does not need to own the variable <code>writer</code> , which implements the type <a href="http://doc.rust-lang.org/stable/std/fmt/trait.Write.html"><code>std::fmt::Write</code></a> , so only borrowing is used.  Actually <code>String</code> implements <code>Write</code> .  In this example, when using the <a href=""><code>encode</code></a> function, a variable of type <code>String</code> passed to the <code>Encoder</code> and then returned back to <code>encode</code> . <br><br><ul><li>  Is my type big?  If the type is large, then passing by reference will save memory.  Remember, passing by reference does not copy the variables.  Provide a <code>String</code> buffer with a large amount of data.  Copying it every time you transfer to another function can slow down the program significantly. </li></ul><br>  Now we can create a function that accepts strings in the form of <code>&amp;str</code> , <code>String</code> or even with a reference count.  We can also create structures that contain links.  The lifetime of the structure is related to the references contained in it, so that the structure cannot survive the variables to which it refers, and thus lead to errors in the program.  And now we have a basic understanding of when to use links within structures, and when not. <br><br><h3>  Concerning 'static </h3><br>  I think that you should pay attention to one more thing.  We can use static static <code>'static</code> lifetime (as in the first example) to make our example compile, but I wouldn‚Äôt advise you to do this: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span> { name: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Person { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">",   {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = Person { name: <span class="hljs-string"><span class="hljs-string">"Herman"</span></span> }; person.greet(); }</code> </pre><br>  The static lifetime of <code>'static</code> valid throughout the life of the program.  You hardly want <code>Person</code> or <code>name</code> live for so long.  <i>(For example, static string literals compiled into the program itself have the type <code>&amp;'static str</code> , that is, they live throughout the life of the program - approx. Transl.)</i> <br><br><h3>  What else to read </h3><br><ul><li>  <a href="http://habrahabr.ru/post/274455/">Creating a function on Rust that accepts a <code>String</code> or <code>&amp;str</code></a> ( <a href="http://hermanradtke.com/2015/05/06/creating-a-rust-function-that-accepts-string-or-str.html">original</a> ) </li><li>  <a href="http://habrahabr.ru/post/274565/">Creating a function on Rust that returns a <code>String</code> or <code>&amp;str</code></a> ( <a href="http://hermanradtke.com/2015/05/29/creating-a-rust-function-that-returns-string-or-str.html">original</a> ) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/274485/">https://habr.com/ru/post/274485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274475/index.html">Rip network dictionaries using Node.js, part 1: static pages; CLI; DSL -> TXT, PDF, DjVu; related tasks</a></li>
<li><a href="../274477/index.html">Localization of WPF applications and instant culture change</a></li>
<li><a href="../274479/index.html">Yii2 bad behaviors</a></li>
<li><a href="../274481/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ192 (December 28, 2015 - January 3, 2016)</a></li>
<li><a href="../274483/index.html">Creating game levels: tips and tricks (part 1)</a></li>
<li><a href="../274487/index.html">Digest on the results of 2015</a></li>
<li><a href="../274489/index.html">Java in Android: Change is Coming (Rumors)</a></li>
<li><a href="../274491/index.html">C # string comparison (default)</a></li>
<li><a href="../274493/index.html">One more analysis of bubble sort</a></li>
<li><a href="../274495/index.html">Flash Player (ActiveX) update for January 1, 2016</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>