<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>I am writing a toy OS (about mutex implementation)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue the blog about the development of a toy OS (previous posts: one , two , three ). Having paused in coding (May holidays, after all), I conti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>I am writing a toy OS (about mutex implementation)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/475/760/6c2/4757606c29bf8ec0ae56132cc3aef9d9.jpg"><br>  I continue the blog about the development of a toy OS (previous posts: <a href="http://habrahabr.ru/post/175749/">one</a> , <a href="http://habrahabr.ru/post/177403/">two</a> , <a href="http://habrahabr.ru/post/177569/">three</a> ).  Having paused in coding (May holidays, after all), I continue to work.  Just sketched a PCI bus scan.  This thing is needed to work with the SATA controller: the next thing I want to do is a simple disk driver.  It will allow to experiment with the projection of permanent memory to the address space (swapping, brought to a logical end).  For now I would like to describe the implementation of the mutex. <br><a name="habracut"></a><br>  To implement the mutex (defined and implemented in <a href="">src / sync.h</a> and <a href="">src / sync.c</a> ), there is no need to modify the existing scheduler described in the two previous posts.  A mutex can be built on the basis of only two of its functions: start and pause a thread (see <a href="">src / schedule.h</a> ). <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex_node</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">head</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spinlock</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mlock</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ilock</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_mutex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct mutex *mutex)</span></span></span><span class="hljs-function"> </span></span>{ mutex-&gt;head = mutex-&gt;tail = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; create_spinlock(&amp;mutex-&gt;mlock); create_spinlock(&amp;mutex-&gt;ilock); }</code> </pre> <br>  My implementation of the mutex involves two spinlock and a queue of sleeping threads.  The first spinlock (mlock) is responsible for accessing the protected mutex resource, i.e.  it is captured if and only if the mutex is captured.  The second spinlock (ilock) protects the queue of waiting threads from simultaneous modification. <br><br>  So how does it work?  When a thread tries to get a mutex, it tries to capture mlock, making N attempts.  If it succeeds, the mutex is captured.  Otherwise, it should safely (i.e. via ilock) add itself to the queue of waiting threads and fall asleep. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> err_code </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acquire_mutex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct mutex *mutex)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> err_code __sleep_in_mutex(struct mutex *mutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!acquire_spinlock_int(&amp;mutex-&gt;mlock, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __sleep_in_mutex(mutex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERR_NONE; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex_node</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex_node</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> thread_id id; }; INTERNAL err_code __sleep_in_mutex(struct mutex *mutex) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex_node</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> acquired; acquire_spinlock(&amp;mutex-&gt;ilock, <span class="hljs-number"><span class="hljs-number">0</span></span>); acquired = acquire_spinlock_int(&amp;mutex-&gt;mlock, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!acquired) { node = alloc_block(&amp;mutex_node_pool); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node) { node-&gt;next = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; node-&gt;id = get_thread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mutex-&gt;head) mutex-&gt;head-&gt;next = node; mutex-&gt;head = node; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mutex-&gt;tail) mutex-&gt;tail = node; pause_this_thread(&amp;mutex-&gt;ilock); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node) release_spinlock(&amp;mutex-&gt;ilock); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (acquired || node) ? ERR_NONE : ERR_OUT_OF_MEMORY; }</code> </pre><br>  The above code needs some explanation: <br><br>  1. The acquire_spinlock_int function is similar to acquire_spinlock, except that it does not disable interrupts until the spinlock is released.  When capturing mlock, we don‚Äôt want to disable interrupts - possession of a mutex can be long.  Another thing is when, capturing ilock, we want to add a stream to the queue ‚Äî this operation must be fast. <br><br>  2. The following line of the function __sleep_in_mutex is at first glance meaningless: <br><br><pre> <code class="cpp hljs"> acquired = acquire_spinlock_int(&amp;mutex-&gt;mlock, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  In fact, why re-try to grab the spinlock when we have failed?  Then, between the first attempt and the capture of ilock, the owner of the mutex can return it, and only later our thread will receive a planning quantum.  Without another attempt, we will add ourselves to the queue and put them to sleep forever.  Therefore, it is important to check again after the capture of ilock (the owner of the mutex will return to it when returning). <br><br>  3. The functions alloc_block and free_block relate to a pool of pre-allocated fixed-size memory blocks (see <a href="">src / memory.h</a> ).  The salt of this pool is not to call a slow malloc whenever we need a block (in this case, struct __mutex_node).  By the way, I still have this pool without implementation (only a stub that directly calls malloc), just like malloc itself.  If anyone has an overwhelming desire to realize the first or to port the second - write. <br><br>  4. Why make N attempts to capture mlock if you can fall asleep after the first attempt?  You can, it just is not very effective.  The context switching time is significantly higher than one attempt to get a spinlock.  Therefore, it is rational to make N attempts (in code 1000, taken from the ceiling; in the future, it is necessary to take practical measurements, derive and substantiate a more reasonable N) before putting it to sleep. <br><br>  5. The code uses a modified version of pause_thread: pause_this_thread.  In addition to putting the current stream to sleep, it atomically (in an interrupt) releases the spinlock passed to it. <br><br>  When releasing a mutex, the host captures ilock, and then checks for waiting threads in the queue.  If a thread is found, then it wakes up, becoming the new owner of the mutex.  If there are no waiting threads, then the host returns mlock and exits. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release_mutex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct mutex *mutex)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __awake_in_mutex(struct mutex *mutex); acquire_spinlock(&amp;mutex-&gt;ilock, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mutex-&gt;tail) __awake_in_mutex(mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> release_spinlock_int(&amp;mutex-&gt;mlock); release_spinlock(&amp;mutex-&gt;ilock); } INTERNAL <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __awake_in_mutex(struct mutex *mutex) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex_node</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class">;</span></span> err_code err; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { node = mutex-&gt;tail; mutex-&gt;tail = node-&gt;next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mutex-&gt;head == node) mutex-&gt;head = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; err = resume_thread(node-&gt;id); free_block(&amp;mutex_node_pool, node); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (mutex-&gt;tail &amp;&amp; err); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mutex-&gt;tail) release_spinlock_int(&amp;mutex-&gt;mlock); }</code> </pre><br>  I wanted to, it was still to talk about the implementation of the sleep function, but this post already contains enough food for thought, so I will postpone it until the next time. <br><br>  PS If you find errors in the code - be sure to write. </div><p>Source: <a href="https://habr.com/ru/post/179561/">https://habr.com/ru/post/179561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../179541/index.html">Remove the starry sky with Emgu CV</a></li>
<li><a href="../179543/index.html">How to drop Windows with six lines of code</a></li>
<li><a href="../179547/index.html">How are you looking for freelance orders on exchanges?</a></li>
<li><a href="../179553/index.html">How I bought a 42-inch LCD TV: the experience of choice and operation</a></li>
<li><a href="../179559/index.html">Dr. Tariff (tariffs and balance): How I began to help people save on mobile costs</a></li>
<li><a href="../179569/index.html">Gmail + GDrive = now 15 gigabytes free</a></li>
<li><a href="../179573/index.html">The second phase of the Intel¬Æ Perceptual Computing Challenge has started.</a></li>
<li><a href="../179575/index.html">Now all developers can respond to reviews on Google Play</a></li>
<li><a href="../179579/index.html">Igor Ashmanov on iForum-2013. Information sovereignty, modern reality</a></li>
<li><a href="../179583/index.html">Video interview from Silicon Valley. Sergey Burkov - a serial entrepreneur, mentor 500 Startups, the first head of the Google development center in Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>