<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Torrent file What's inside it?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 Good day. 
 I use, like many, a large torrent tracker - rutracker.org, but there is one feature that annoys me. 
 This is adding to th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Torrent file What's inside it?</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br><img src="https://habrastorage.org/storage/habraeffect/ae/b8/aeb8bbbd880eac2e82d8785a5a47654f.jpg" alt="image"><br>  Good day. <br>  I use, like many, a large torrent tracker - rutracker.org, but there is one feature that annoys me. <br>  This is adding to the list of trackers <i>ix * .rutracker.net address</i> , which serves for purposes I do not understand.  However, that often (with me - almost always) gives errors ( <b>502 Bad Gateway</b> and <b>0 No Response</b> ).  The torrent client (I have Transmission) marks the torrent broken.  Which by itself rather bothers me.  Especially if you take into account the Transmission feature - it sets the status of the torrent by the last answer of the tracker.  That is, we poll ix *, it returns an error, the torrent is marked as Broken, after n minutes / seconds the next tracker from the list is polled - <i>bt * .rutracker.org</i> or <i>retracker.local</i> , which return a successful code and the torrent again becomes normal.  Such a leapfrog doesn't make me particularly happy. <br><br>  The solution is trite - remove this bad address from the list.  However, I have a lot of files, I don‚Äôt want to cut out from everyone manually, and there was no desire to take an additional action when adding a new torrent.  Therefore, I decided to understand the format and automate the removal of the tracker from the list. <br><a name="habracut"></a><br><h4>  Bencode </h4><br><br>  This is the name of the data encoding format in .torrent files.  He is almost nowhere else used, he caught my eye also in the format of storing the trans-information in Transmission. <br>  For most of the current languages, libraries are written to work with this format, but not for C ++, yes, of course, there is such a <a href="http://funzix.git.sourceforge.net/git/gitweb.cgi%3Fp%3Dfunzix/funzix%3Ba%3Dblob%3Bf%3Dbencode/bencode.c">thing</a> , but this is pure C and besides, the presentation form did not seem successful to me, so I wrote my own simple bike, because the format is extremely simple. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      4 data types are described - byte array, number, list, associative array. <br><br>  Let's go in order: <br><ul><li>  Numbers are given in the form <b>i &lt;sequence of digits&gt; e</b> , &lt;sequence of digits&gt; are numbers in the ascii representation, that is, 1 is specified as '1' or 0x31.  It is noticeable that in this way we can specify huge numbers that do not fit in either long or long long, but most neglect the lack of a limit and use 64-bit numbers. </li><li>  The byte array is <b>&lt;array length&gt;: &lt;array itself&gt;</b> .  The length of the array is also formed by an unlimited sequence of numbers. </li><li>  List - <b>l &lt;list items&gt; e</b> .  The element can be any of the data types.  Including a nested list.  The end, as can be seen from the format, is marked with the literal 'e'. </li><li>  Associative array - <b>d &lt;array elements&gt; e</b> .  Each element of the array looks like this - <b>&lt;byte array&gt; &lt;element&gt;</b> .  An array of bytes is the name of the record in the form of clause 2. Again, there can be any element ‚Äî a list, an array, an associative array, a number. </li></ul><br><br>  It's all.  The file itself is a sequence of such records.  Therefore, decoding is extremely simple: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CTorrentFile::ReadBencElement(ifstream &amp; fin, tree &lt;BencElement&gt;::pre_order_iterator &amp; parent, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name) { BencElement el; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = fin.get(); el.name = name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'i'</span></span>) { el.type = BencInteger; fin &gt;&gt; el.integer; m_tree.append_child(parent, el); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'l'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = fin.peek(); el.type = BencList; tree &lt;BencElement&gt;::pre_order_iterator it = m_tree.append_child(parent, el); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l != <span class="hljs-string"><span class="hljs-string">'e'</span></span>) { ReadBencElement(fin, it, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>)); l = fin.peek(); } fin.seekg(<span class="hljs-number"><span class="hljs-number">1</span></span>, ios_base::cur); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'d'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = fin.peek(); el.type = BencDict; tree &lt;BencElement&gt;::pre_order_iterator it = m_tree.append_child(parent, el); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l != <span class="hljs-string"><span class="hljs-string">'e'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len; fin &gt;&gt; len; fin.seekg(<span class="hljs-number"><span class="hljs-number">1</span></span>, ios_base::cur); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (len--) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> s = fin.get(); name += s; } ReadBencElement(fin, it, name); l = fin.peek(); } fin.seekg(<span class="hljs-number"><span class="hljs-number">1</span></span>, ios_base::cur); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) { fin.seekg(<span class="hljs-number"><span class="hljs-number">-1</span></span>, ios_base::cur); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len; el.type = BencString; fin &gt;&gt; len; el.bstr.len = len; <span class="hljs-comment"><span class="hljs-comment">// skip ':' fin.seekg(1, ios_base::cur); el.bstr.byteStr = new char[len + 1]; for (int i = 0; i &lt; len; i++) { char s = fin.get(); el.bstr.byteStr[i] = s; } el.bstr.byteStr[el.bstr.len] = 0; m_tree.append_child(parent, el); } }</span></span></code> </pre> <br><br>  Coding is also easy: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CTorrentFile::WriteBencElement(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ofstream &amp; fout, tree &lt;BencElement&gt;::sibling_iterator &amp; el) { tree &lt;BencElement&gt;::sibling_iterator it; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (el-&gt;type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BencInteger: fout &lt;&lt; <span class="hljs-string"><span class="hljs-string">'i'</span></span> &lt;&lt; el-&gt;integer &lt;&lt; <span class="hljs-string"><span class="hljs-string">'e'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BencString: fout &lt;&lt; el-&gt;bstr.len &lt;&lt; <span class="hljs-string"><span class="hljs-string">':'</span></span>; fout.write(el-&gt;bstr.byteStr, el-&gt;bstr.len); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BencList: fout &lt;&lt; <span class="hljs-string"><span class="hljs-string">'l'</span></span>; it = m_tree.child(el, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_tree.number_of_children(el); i++, ++it) WriteBencElement(fout, it); fout &lt;&lt; <span class="hljs-string"><span class="hljs-string">'e'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BencDict: fout &lt;&lt; <span class="hljs-string"><span class="hljs-string">'d'</span></span>; tree &lt;BencElement&gt;::sibling_iterator it = m_tree.child(el, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_tree.number_of_children(el); i++, ++it) { fout &lt;&lt; it-&gt;name.length() &lt;&lt; <span class="hljs-string"><span class="hljs-string">':'</span></span> &lt;&lt; it-&gt;name.c_str(); WriteBencElement(fout, it); } fout &lt;&lt; <span class="hljs-string"><span class="hljs-string">'e'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><br><h4>  The structure of a .torrent file. </h4><br><br>  As I wrote above, Bencode is used for encoding. <br>  It is worth adding that if an array of bytes can be interpreted as a string (the names of elements in an associative array, just string fields), then the utf-8 encoding is used. <br><br>  Content is one large associative array with the following fields: <br><ul><li>  <b>info</b> - a nested associative array that actually describes the files that the torrent transmits. </li><li>  <b>announce</b> - URL for the tracker.  Along with <b>info</b> is a required field, everything else is optional. </li><li>  <b>announce-list</b> - list of trackers, if there are several.  In Bencode-form - a list of lists. </li><li>  <b>creation date</b> - the creation date.  UNIX Timestamp. </li><li>  <b>comment</b> - text description of the torrent.  rutracker.org stores here a link to the forum topic. </li><li>  <b>created by</b> - tells us who created this torrent. </li></ul><br><br>  It is necessary to mention that the files are presented in the protocol in chunks.  That is, the files contained in the torrent are combined into a single array, and then this array is divided into relatively small pieces.  In this form, the data is processed by the BitTorrent protocol. <br><br>  The associative <b>info</b> array consists of: <br><ul><li>  <b>piece length</b> - the size of one piece - 512 kilobytes, 1 meter, and so on.  Too many pieces will inflate a .torrent file. </li><li>  <b>pieces</b> is a string that contains the concatenation of SHA1 hashes that describe each piece.  The length of this string is 20 * the number of pieces. </li><li>  <b>name</b> is a recommendable file name (if the file is one) or directories.  Alas, many torrent clients see this as an axiom. </li><li>  <b>length</b> - if the file is one, then this field will be set, which contains the length of the file. </li><li>  <b>files</b> - if there are several files, a list of associative arrays will appear. </li></ul><br><br>  Format of <b>files</b> list items: <br><ul><li>  <b>length</b> - the length of the file. </li><li>  <b>path</b> - a list of strings that specify the path.  Each line is an element of the path relative to the root directory of the torrent.  For the path <i>a / b / c / d.jpg there</i> will be 4 lines in this list - <b>['a', 'b', 'c', 'd.jpg']</b> . </li></ul><br><br>  In general, that's all. <br>  We currently only need one field - <b>announce-list</b> .  Going over this list we find the objectionable tracker and cut it out: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CTorrentFile::RemoveTracker(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * mask) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> deletedCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; tree &lt;BencElement&gt;::pre_order_iterator root = m_tree.child(m_tree.begin(), <span class="hljs-number"><span class="hljs-number">0</span></span>); tree &lt;BencElement&gt;::sibling_iterator it = m_tree.child(root, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_tree.number_of_children(root); i++, ++it) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it-&gt;type == BencString &amp;&amp; !it-&gt;name.compare(<span class="hljs-string"><span class="hljs-string">"announce"</span></span>) &amp;&amp; it-&gt;bstr.len &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; it-&gt;bstr.byteStr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wildcardMatch(it-&gt;bstr.byteStr, mask)) { it-&gt;bstr.len = <span class="hljs-number"><span class="hljs-number">0</span></span>; it-&gt;bstr.byteStr[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; deletedCount++; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it-&gt;type == BencList &amp;&amp; !it-&gt;name.compare(<span class="hljs-string"><span class="hljs-string">"announce-list"</span></span>)) { tree &lt;BencElement&gt;::sibling_iterator trackerList = m_tree.child(it, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; it.number_of_children(); j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (trackerList-&gt;type != BencList) { ++trackerList; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } tree &lt;BencElement&gt;::sibling_iterator tracker = m_tree.child(trackerList, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; trackerList.number_of_children(); k++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tracker-&gt;type != BencString || tracker-&gt;bstr.len &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || !tracker-&gt;bstr.byteStr) { ++tracker; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wildcardMatch(tracker-&gt;bstr.byteStr, mask)) { tracker = m_tree.erase(tracker); deletedCount++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ++tracker; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (trackerList.number_of_children() == <span class="hljs-number"><span class="hljs-number">0</span></span>) trackerList = m_tree.erase(trackerList); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ++trackerList; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deletedCount; }</code> </pre> <br><br>  Build everything into one source: <br>  <a href="">Download</a> - cross-platform (win + * nix), we need <b>boost :: filesystem</b> . <br><br>  It's easy to use: <br>  <b>torrentEditor &lt;file name&gt; &lt;template&gt;</b> , where the template is a wildcard string ('*' and '?'), for my case - <i>http: //ix*rutracker.net/*</i> <br>  If you substitute the directory name as the file name, then a recursive traversal along this directory and modification of the * .torrent files will be performed. <br>  The backup for <i>&lt;name&gt; .torrent is</i> saved in <i>&lt;name&gt; .old</i> . <br><br><h4>  Daemons and watch-directory. </h4><br><br>  This way we can go over existing .torrent files and cut the tracker, but what about new files? <br>  I use the convenient directory - watch directory.  We throw there a .torrent and the client, finding it in this folder, will automatically add it to itself. <br>  However, I don‚Äôt want to cut the tracker at all, but I want to automate this matter. <br>  Therefore, I wrote a simple daemon that monitors its own watch directory, deletes the tracker and throws the file into the watch directory of the torrent client. <br>  For me, as a user, absolutely nothing has changed, I throw files into the same folder, I get a torrent at the output in the client. <br><br>  We write a demon on C using a wonderful thing - <b>inotify</b> , <br><pre> <code class="cpp hljs"> notifyDesc = inotify_init(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notifyDesc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); watchDesc = inotify_add_watch(notifyDesc, argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], IN_CREATE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (watchDesc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); <span class="hljs-comment"><span class="hljs-comment">// endless loop while (1) { processEvents(notifyDesc, argv[2], argv[3], argv[1]); }</span></span></code> </pre> <br><br>  We initialize the module using <b>inotify_init ()</b> , then add the directory for tracking <b>inotify_add_watch ()</b> , we are only interested in creating the file, therefore we specify the <b>IN_CREATE</b> flag.  And then we twist the endless loop of tracking the directory. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processEvents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * moveDir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pattern, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * watchDir)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUF_SIZE ((sizeof(struct inotify_event) + FILENAME_MAX) * 10) int len, i = 0; char buf[BUF_SIZE]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// blocked read, we wake up when directory changed len = read(wd, buf, BUF_SIZE); while (i &lt; len) { struct inotify_event * ev; ev = (struct inotify_event *)&amp;buf[i]; processNewFile(ev-&gt;name, moveDir, pattern, watchDir); i += sizeof(struct inotify_event) + ev-&gt;len; } }</span></span></span></span></code> </pre> <br>  The blocking call <b>read ()</b> will return control to us as soon as the necessary changes occur to us in one of the directories we are watching.  Thus, we absolutely do not ship the processor while waiting. <br>  The file processing itself is nothing interesting - a pair of <b>rename ()</b> calls and one <b>system ()</b> call. <br><br>  Demonization is also standard: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create child-process pid = fork(); // error? if (pid &lt; 0) exit(EXIT_FAILURE); // parent? if (pid &gt; 0) exit(EXIT_SUCCESS); // new session for child sid = setsid(); if (sid &lt; 0) exit(EXIT_FAILURE); // change current directory if (chdir("/") &lt; 0) exit(EXIT_FAILURE); // close opened descriptors close(STDIN_FILENO); close(STDOUT_FILENO); close(STDERR_FILENO);</span></span></code> </pre> <br><br>  <a href="">Source code</a> </div><p>Source: <a href="https://habr.com/ru/post/119753/">https://habr.com/ru/post/119753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../119745/index.html">Live broadcast from the conference LintConf (Life in Technology)</a></li>
<li><a href="../119748/index.html">Authors, how often do you visit your recently published topic to look at the rating?</a></li>
<li><a href="../119749/index.html">Bitcoin generation in the browser: Reverse</a></li>
<li><a href="../119751/index.html">IC 555. Practice</a></li>
<li><a href="../119752/index.html">Using ITIL methodology in small business</a></li>
<li><a href="../119754/index.html">Older time to learn</a></li>
<li><a href="../119755/index.html">I want this beautiful thing</a></li>
<li><a href="../119756/index.html">Gmail Chat and AIM are now compatible.</a></li>
<li><a href="../119757/index.html">We put Dingux on Dingoo A320 from under Win, Mac and Linux for all types of screen loader</a></li>
<li><a href="../119759/index.html">Google Advisor Financial Advisor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>