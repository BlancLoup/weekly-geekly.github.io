<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Sort in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The sorting task is a classic task that any programmer should know. That is why this article is devoted to this topic - the implementation of sorting ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Sort in .NET</h1><div class="post__text post__text-html js-mediator-article">  The sorting task is a classic task that any programmer should know.  That is why this article is devoted to this topic - the implementation of sorting on the .NET platform.  I want to talk about how array sorting works in .NET, talk about its features, implementations, and also make a small comparison with Java. <br><br>  So let's start with the fact that the first versions of .NET use the quick sort algorithm by default.  Therefore, a small excursion into the quick sort: <br><a name="habracut"></a><br>  <b>Advantages:</b> <br><ol><li>  One of the fastest (in practice) of general-purpose internal sorting algorithms; </li><li>  Easy to implement; </li><li>  Requires only O (logn) additional memory for its work (not improved recursive algorithm in the worst case O (n) memory); </li><li>  Goes well with caching and virtual memory. </li></ol><br>  <b>Disadvantages:</b> <br><ol><li>  It degrades greatly in speed to O (n <sup>2</sup> ) with unsuccessful selections of supporting elements, which can happen with unsuccessful input data.  This can be avoided by choosing a supporting element in an accidental, rather than a fixed way; </li><li>  A naive implementation of the algorithm can lead to a stack overflow error, since it may need to make O (n) nested recursive calls.  In improved implementations, in which the recursive call occurs only for sorting by the smaller of the two parts of the array, the recursion depth is guaranteed not to exceed O (logn); </li><li>  Unstable - if stability is required, you have to expand the key. </li></ol><br>  A naive implementation of the quick sort algorithm might look something like this: <br><br><div class="spoiler">  <b class="spoiler_title">Naive QuickSort</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QuickSort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = left; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = right; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> avg = array[(l + r) / <span class="hljs-number"><span class="hljs-number">2</span></span>)]; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (array[l] &lt; avg) ++l; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (array[r] &gt; avg) --r; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt;= r) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; r) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temp = array[l]; array[l] = array[r]; array[r] = temp; } ++l; --r; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt;= r); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &lt; r) QuickSort(left, r); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; right) QuickSort(l, right); }</code> </pre> <br></div></div><br>  <b>The above sorting algorithm has the following disadvantages:</b> <br><ol><li>  Since the reference element is chosen as the middle of the array, it is possible that this will always be a maximum, as a result of which the array will be divided into two parts of length n - 1 and 1 and the speed of the algorithm will degrade to O (n <sup>2</sup> ); </li><li>  Under the above conditions, the recursion depth reaches O (n), as a result of which, for large n, a software stack may overflow; </li><li>  The algorithm is unstable, that is, it changes the elements with the same values.  This does not affect the example of sorting numbers, but if we sort an array of objects by some property, this is significant, because as a result of several calls to the Sort method, we get an array of elements of which differ in order. </li></ol><br>  <b>Moving on to the implementation in .NET.</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  .NET 1.0 </h4><br>  So, consider what happens in .NET 1.0.  Looking ahead, I will say that we will not see anything good here, especially for user-significant types ... (due to the lack of generalizations in particular) <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Array array</span></span></span><span class="hljs-function">)</span></span> { Array.Sort(array, (Array) <span class="hljs-literal"><span class="hljs-literal">null</span></span>, array.GetLowerBound(<span class="hljs-number"><span class="hljs-number">0</span></span>), array.Length, (IComparer) <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Array keys, Array items, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length, IComparer comparer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comparer == Comparer.Default || comparer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TrySZSort(array, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, index, index + length - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] keys1 = keys <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[]; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] items1 = (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[]) <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keys1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) items1 = items <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keys1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (items == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || items1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Array.SorterObjectArray(keys1, items1, comparer).QuickSort(index, index + length - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Array.SorterGenericArray(keys, items, comparer).QuickSort(index, index + length - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  And now the classes SorterObjectArray and SorterGenericArray itself: <br><br><div class="spoiler">  <b class="spoiler_title">SorterObjectArray</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SorterObjectArray</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] keys; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] items; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IComparer comparer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SorterObjectArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] keys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] items, IComparer comparer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comparer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) comparer = (IComparer)Comparer.Default; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys = keys; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items = items; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.comparer = comparer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QuickSort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left1 = left; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> right1 = right; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj1 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys[left1 + right1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.comparer.Compare(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys[left1], obj1) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ++left1; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.comparer.Compare(obj1, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys[right1]) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) --right1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left1 &lt;= right1) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left1 &lt; right1) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj2 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys[left1]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys[left1] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys[right1]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys[right1] = obj2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj3 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items[left1]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items[left1] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items[right1]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items[right1] = obj3; } } ++left1; --right1; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left1 &lt;= right1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right1 - left &lt;= right - left1) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &lt; right1) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.QuickSort(left, right1); left = left1; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left1 &lt; right) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.QuickSort(left1, right); right = right1; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left &lt; right); } }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">SorterGenericArray</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SorterGenericArray</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Array keys; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Array items; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IComparer comparer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SorterGenericArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Array keys, Array items, IComparer comparer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comparer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) comparer = (IComparer)Comparer.Default; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys = keys; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items = items; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.comparer = comparer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QuickSort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num1 = left; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num2 = right; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj1 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys.GetValue(num1 + num2 &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.comparer.Compare(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys.GetValue(num1), obj1) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ++num1; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.comparer.Compare(obj1, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys.GetValue(num2)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) --num2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num1 &lt;= num2) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num1 &lt; num2) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj2 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys.GetValue(num1); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys.SetValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys.GetValue(num2), num1); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys.SetValue(obj2, num2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj3 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items.GetValue(num1); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items.SetValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items.GetValue(num2), num1); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items.SetValue(obj3, num2); } } ++num1; --num2; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (num1 &lt;= num2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num2 - left &lt;= right - num1) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &lt; num2) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.QuickSort(left, num2); left = num1; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num1 &lt; right) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.QuickSort(num1, right); right = num2; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left &lt; right); } }</code> </pre></div></div><br>  So what's going on here?  Following code <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] keys1 = keys <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[]; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] items1 = (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[]) <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keys1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) items1 = items <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[];</code> </pre><br>  this is nothing more than an attempt to use the covariance of arrays, which, as is known, works only for reference types.  It turns out that SorterObjectArray is used for reference types, and SorterGenericArray is used for significant types.  But wait, what is the difference between these classes?  As you can see, they differ only in the way the array elements are accessed.  For meaningful types, the GetValue and SetValue methods are used, which, as you know, are very slow ... It turns out that an array of integers will be sorted for a very long time (because an integer is a significant type)?  Not!  An array of integers sorted quickly, and very quickly.  It's all about the following code. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comparer == Comparer.Default || comparer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TrySZSort(array, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, index, index + length - <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre><br>  Of interest is the Array.TrySZSort method.  This method calls the native sorting implementation implemented in C ++ in the CLR itself.  And it works for primitive types when we use the standard logic of comparing elements, that is, when comparer == Comparer.Default ||  comparer == null. <br><br>  And here is the native implementation: <br><br><div class="spoiler">  <b class="spoiler_title">Native TrySZSort</b> <div class="spoiler_text"><pre> <code class="cpp hljs">FCIMPL4(INT32, ArrayHelper::TrySZSort, ArrayBase * keys, ArrayBase * items, UINT32 left, UINT32 right) <span class="hljs-comment"><span class="hljs-comment">//           if (keys-&gt;GetRank() != 1 || keys-&gt;GetLowerBoundsPtr()[0] != 0) return FALSE; //     TypeHandle keysTH = keys-&gt;GetElementTypeHandle(); //       const CorElementType keysElType = keysTH.GetSigCorElementType(); if (!CorTypeInfo::IsPrimitiveType(keysElType)) return FALSE; if (items != NULL) { TypeHandle itemsTH = items-&gt;GetElementTypeHandle(); if (keysTH != itemsTH) return FALSE; // Can't currently handle sorting different types of arrays. } //       if (left == right || right == 0xffffffff) return TRUE; //        ++. switch(keysElType) { case ELEMENT_TYPE_I1: // 1-    (sbyte) ArrayHelpers&lt;I1&gt;::QuickSort((I1*) keys-&gt;GetDataPtr(), (I1*) (items == NULL ? NULL : items-&gt;GetDataPtr()), left, right); break; case ELEMENT_TYPE_U1: // 1-     (byte) case ELEMENT_TYPE_BOOLEAN: //   (bool) ArrayHelpers&lt;U1&gt;::QuickSort((U1*) keys-&gt;GetDataPtr(), (U1*) (items == NULL ? NULL : items-&gt;GetDataPtr()), left, right); break; case ELEMENT_TYPE_I2: // 2-    (short) ArrayHelpers&lt;I2&gt;::QuickSort((I2*) keys-&gt;GetDataPtr(), (I2*) (items == NULL ? NULL : items-&gt;GetDataPtr()), left, right); break; case ELEMENT_TYPE_U2: // 2-     (ushort) case ELEMENT_TYPE_CHAR: //   (char) ArrayHelpers&lt;U2&gt;::QuickSort((U2*) keys-&gt;GetDataPtr(), (U2*) (items == NULL ? NULL : items-&gt;GetDataPtr()), left, right); break; case ELEMENT_TYPE_I4: // 4-    (int) ArrayHelpers&lt;I4&gt;::QuickSort((I4*) keys-&gt;GetDataPtr(), (I4*) (items == NULL ? NULL : items-&gt;GetDataPtr()), left, right); break; case ELEMENT_TYPE_U4: // 4-     (uint) ArrayHelpers&lt;U4&gt;::QuickSort((U4*) keys-&gt;GetDataPtr(), (U4*) (items == NULL ? NULL : items-&gt;GetDataPtr()), left, right); break; case ELEMENT_TYPE_R4: // 4-     (float) ArrayHelpers&lt;R4&gt;::QuickSort((R4*) keys-&gt;GetDataPtr(), (R4*) (items == NULL ? NULL : items-&gt;GetDataPtr()), left, right); break; case ELEMENT_TYPE_I8: // 8-    (long) ArrayHelpers&lt;I8&gt;::QuickSort((I8*) keys-&gt;GetDataPtr(), (I8*) (items == NULL ? NULL : items-&gt;GetDataPtr()), left, right); break; case ELEMENT_TYPE_U8: // 8-     (ulong) ArrayHelpers&lt;U8&gt;::QuickSort((U8*) keys-&gt;GetDataPtr(), (U8*) (items == NULL ? NULL : items-&gt;GetDataPtr()), left, right); break; case ELEMENT_TYPE_R8: // 8-     (double) ArrayHelpers&lt;R8&gt;::QuickSort((R8*) keys-&gt;GetDataPtr(), (R8*) (items == NULL ? NULL : items-&gt;GetDataPtr()), left, right); break; case ELEMENT_TYPE_I: //       (IntPtr) case ELEMENT_TYPE_U: //         (UIntPtr) // In V1.0, IntPtr &amp; UIntPtr are not fully supported types. They do // not implement IComparable, so searching &amp; sorting for them should // fail. In V1.1 or V2.0, this should change. return FALSE; default: return FALSE; } return TRUE; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Native QuickSort</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// -    template &lt;class KIND&gt; class ArrayHelpers { static void QuickSort(KIND keys[], KIND items[], int left, int right) { do { int i = left; int j = right; KIND x = keys[(i + j) &gt;&gt; 1]; do { while (Compare(keys[i], x) &lt; 0) i++; while (Compare(x, keys[j]) &lt; 0) j--; if (i &gt; j) break; if (i &lt; j) { KIND key = keys[i]; keys[i] = keys[j]; keys[j] = key; if (items != NULL) { KIND item = items[i]; items[i] = items[j]; items[j] = item; } } i++; j--; } while (i &lt;= j); if (j - left &lt;= right - i) { if (left &lt; j) QuickSort(keys, items, left, j); left = i; } else { if (i &lt; right) QuickSort(keys, items, i, right); right = j; } } while (left &lt; right); } };</span></span></code> </pre><br></div></div><br>  As you can see, native sorting works only for primitive types.  These include all numeric types + boolean + character.  And for significant custom types, everything will work deplorably slowly. <br><br>  We now turn to the consideration of the implementation of the sorting algorithm itself.  We will consider the implementation in the SorterObjectArray class, since the native implementation and the implementation for the relevant types are similar. <br><br>  1. The middle of the array is always taken as the reference element: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj1 = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.keys[left1 + right1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre><br>  This is not good, because with poor input data, the execution time of the algorithm can become quadratic.  In addition, the middle is taken according to the formula num1 + num2 &gt;&gt; 1, which can lead to an overflow of type int.  The same mistake was made in the binary search and sorting algorithm in Java ( <a href="http://bugs.sun.com/bugdatabase/view_bug.do%3Fbug_id%3D5045582">link to the bug</a> ). <br><br>  As you will see in the next versions of .NET this flaw will be fixed. <br><br>  2. In order to avoid stack overflow, this implementation provides optimization that eliminates one branch of recursion: instead of calling the recursive separation procedure for both found subarrays after dividing the array, the recursive call is made only for the smaller subarray, and the larger one is processed in a loop in within the same procedure call.  From the point of view of efficiency, on average, there is practically no difference: the overhead costs for an additional recursive call and for organizing the comparison of the lengths of subarrays and the cycle are approximately of the same order.  But the depth of recursion, under no circumstances will exceed log <sub>2</sub> n, and in the worst case of a degenerate separation, it will generally be no more than 2 - all processing will take place in a cycle of the first level of recursion. <br><br><h4>  .NET 2.0 </h4><br>  New implementation has undergone minor changes.  Since there are generalizations in .NET 2.0, I will provide a generalized sorting option. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Sort&lt;T&gt;(T[] array, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length, IComparer&lt;T&gt; comparer) { <span class="hljs-comment"><span class="hljs-comment">// TrySZSort      . //        Int32.CompareTo    "&lt;"  "&gt;". if (length &lt;= 1 || (comparer == null || comparer == Comparer&lt;T&gt;.Default) &amp;&amp; Array.TrySZSort((Array) array, (Array) null, index, index + length - 1)) return; ArraySortHelper&lt;T&gt;.Default.Sort(array, index, length, comparer); }</span></span></code> </pre><br>  But the actual method that sorts <br><br><div class="spoiler">  <b class="spoiler_title">Quicksort</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SwapIfGreaterWithItems</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] keys, IComparer&lt;T&gt; comparer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b || comparer.Compare(keys[a], keys[b]) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; T obj = keys[a]; keys[a] = keys[b]; keys[b] = obj; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QuickSort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] keys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right, IComparer&lt;T&gt; comparer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index1 = left; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index2 = right; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index3 = index1 + (index2 - index1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); ArraySortHelper&lt;T&gt;.SwapIfGreaterWithItems(keys, comparer, index1, index3); ArraySortHelper&lt;T&gt;.SwapIfGreaterWithItems(keys, comparer, index1, index2); ArraySortHelper&lt;T&gt;.SwapIfGreaterWithItems(keys, comparer, index3, index2); T obj1 = keys[index3]; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (comparer.Compare(keys[index1], obj1) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ++index1; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (comparer.Compare(obj1, keys[index2]) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) --index2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index1 &lt;= index2) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index1 &lt; index2) { T obj2 = keys[index1]; keys[index1] = keys[index2]; keys[index2] = obj2; } ++index1; --index2; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (index1 &lt;= index2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index2 - left &lt;= right - index1) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &lt; index2) ArraySortHelper&lt;T&gt;.QuickSort(keys, left, index2, comparer); left = index1; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index1 &lt; right) ArraySortHelper&lt;T&gt;.QuickSort(keys, index1, right, comparer); right = index2; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left &lt; right); }</code> </pre><br></div></div><br>  It should be said that there is still an optimization for the built-in primitive types, despite the presence of generalizations (see the comments of the developers).  That is, primitive types still use native sorting. <br><br>  Now the median from the first, middle and last elements of the array is taken as the reference element now, not the middle of the array. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index3 = index1 + (index2 - index1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ArraySortHelper&lt;T&gt;.SwapIfGreaterWithItems(keys, comparer, index1, index3); ArraySortHelper&lt;T&gt;.SwapIfGreaterWithItems(keys, comparer, index1, index2); ArraySortHelper&lt;T&gt;.SwapIfGreaterWithItems(keys, comparer, index3, index2); T obj1 = keys[index3];</span></span></code> </pre><br>  In addition, the middle is now calculated by the formula index1 + (index2 - index1 &gt;&gt; 1), which eliminates errors associated with overflow. <br><br>  Otherwise, everything is still intact. <br><br>  <i><b>Now a small digression:</b></i> let us need to sort the array of integers in descending order.  How will you do it? <br><br>  Considering the above, the following code <br><br><pre> <code class="cs hljs">Array.Sort(a); Array.Reverse(a);</code> </pre><br>  on my computer it works about 3 times faster than <br><br><pre> <code class="cs hljs">Array.Sort(a, (x, y) =&gt; -x.CompareTo(y))</code> </pre><br>  You may be confused by the fact that the Array.Reverse method is not generalized, which means that it will work slowly with significant types (packaging and GetValue, SetValue methods), but if you look at its implementation, we will again see optimization for the built-in significant types, namely calls the native Array.TrySZReverse method, which looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Reverse</b> <div class="spoiler_text"><pre> <code class="cs hljs">template &lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">KIND</span></span>&gt; <span class="hljs-title"><span class="hljs-title">static</span></span> <span class="hljs-title"><span class="hljs-title">void</span></span> <span class="hljs-title"><span class="hljs-title">Reverse</span></span>(<span class="hljs-title"><span class="hljs-title">KIND</span></span> <span class="hljs-title"><span class="hljs-title">array</span></span>[], <span class="hljs-title"><span class="hljs-title">UINT32</span></span> <span class="hljs-title"><span class="hljs-title">index</span></span>, <span class="hljs-title"><span class="hljs-title">UINT32</span></span> <span class="hljs-title"><span class="hljs-title">count</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } UINT32 i = index; UINT32 j = index + count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; j) { KIND temp = array[i]; array[i] = array[j]; array[j] = temp; i++; j--; } } };</code> </pre><br></div></div><br>  In general, the optimization in the standard library is waiting for us around every corner. <br><br>  By the way, it is very strange that there is no generalized version of this method.  There is a Reverse method as an extension method for Enumerable, but its disadvantage is that it does not do it in place.  It turns out that a call to Array.Reverse on an array of user-significant types always leads to autoboxing. <br><br><h4>  .NET 3.0 - .NET 4.0 </h4><br>  The algorithm has not changed. <br><br><h4>  .NET 4.5 </h4><br>  The most interesting begins here! <br><br>  But before proceeding to the consideration of the algorithm, I must say a few words about the deployment of .NET 4.5.  For a complete understanding of the situation I advise you to read this <a href="http://www.west-wind.com/weblog/posts/2012/Mar/13/NET-45-is-an-inplace-replacement-for-NET-40">article</a> (unfortunately, in English).  When installing VS 2012, that is, when installing .NET 4.5, it replaces build 4 framework.  In fact, this means that even when you are now writing to .NET 4, you are using .NET 4.5 assemblies.  It turns out an interesting thing: before installation 4.5 you use one sorting algorithm, after installation you use another algorithm, and everything happens without your knowledge. <br><br>  To understand what is actually happening, take a look at the code from .NET 4.5: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] keys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length, IComparer&lt;T&gt; comparer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BinaryCompatibility.TargetsAtLeast_Desktop_V4_5) ArraySortHelper&lt;T&gt;.IntrospectiveSort(keys, index, length, comparer); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ArraySortHelper&lt;T&gt;.DepthLimitedQuickSort(keys, index, length + index - <span class="hljs-number"><span class="hljs-number">1</span></span>, comparer, <span class="hljs-number"><span class="hljs-number">32</span></span>); }</code> </pre><br>  As you can see, the method is worth checking for what .NET we work in: if it is 4.5, then we use IntrospectiveSort if it is 4.0 then DepthLimitedQuickSort. <br><br>  Let's find out how DepthLimitedQuickSort differs from sorting, which was used in .NET 4.0 before installing VS 2012. Let's look at the code of this method: <br><br><div class="spoiler">  <b class="spoiler_title">DepthLimitedQuickSort</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DepthLimitedQuickSort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] keys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right, IComparer&lt;T&gt; comparer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depthLimit</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (depthLimit != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index1 = left; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index2 = right; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index3 = index1 + (index2 - index1 &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); ArraySortHelper&lt;T&gt;.SwapIfGreater(keys, comparer, index1, index3); ArraySortHelper&lt;T&gt;.SwapIfGreater(keys, comparer, index1, index2); ArraySortHelper&lt;T&gt;.SwapIfGreater(keys, comparer, index3, index2); T obj1 = keys[index3]; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (comparer.Compare(keys[index1], obj1) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ++index1; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (comparer.Compare(obj1, keys[index2]) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) --index2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index1 &lt;= index2) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index1 &lt; index2) { T obj2 = keys[index1]; keys[index1] = keys[index2]; keys[index2] = obj2; } ++index1; --index2; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (index1 &lt;= index2); --depthLimit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index2 - left &lt;= right - index1) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &lt; index2) ArraySortHelper&lt;T&gt;.DepthLimitedQuickSort(keys, left, index2, comparer, depthLimit); left = index1; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index1 &lt; right) ArraySortHelper&lt;T&gt;.DepthLimitedQuickSort(keys, index1, right, comparer, depthLimit); right = index2; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &gt;= right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ArraySortHelper&lt;T&gt;.Heapsort(keys, left, right, comparer); }</code> </pre><br></div></div><br>  As you can see, this is the same quick sort with the exception of one: the algorithm switches to pyramidal sorting if we exhaust the recursion depth, which is 32 by default. <br><br>  But actually pyramid sorting: <br><br><div class="spoiler">  <b class="spoiler_title">Heapsort</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Heapsort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] keys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hi, IComparer&lt;T&gt; comparer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = hi - lo + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = n / <span class="hljs-number"><span class="hljs-number">2</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; --i) ArraySortHelper&lt;T&gt;.DownHeap(keys, i, n, lo, comparer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = n; index &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; --index) { ArraySortHelper&lt;T&gt;.Swap(keys, lo, lo + index - <span class="hljs-number"><span class="hljs-number">1</span></span>); ArraySortHelper&lt;T&gt;.DownHeap(keys, <span class="hljs-number"><span class="hljs-number">1</span></span>, index - <span class="hljs-number"><span class="hljs-number">1</span></span>, lo, comparer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DownHeap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] keys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lo, IComparer&lt;T&gt; comparer</span></span></span><span class="hljs-function">)</span></span> { T x = keys[lo + i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt;= n / <span class="hljs-number"><span class="hljs-number">2</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num; i = num;}) { num = <span class="hljs-number"><span class="hljs-number">2</span></span> * i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; n &amp;&amp; comparer.Compare(keys[lo + num - <span class="hljs-number"><span class="hljs-number">1</span></span>], keys[lo + num]) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ++num; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comparer.Compare(x, keys[lo + num - <span class="hljs-number"><span class="hljs-number">1</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) keys[lo + i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = keys[lo + num - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } keys[lo + i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = x; }</code> </pre><br></div></div><br>  The DepthLimitedQuickSort algorithm is nothing but IntroSort. <br><br>  <i>Introsort or introspective sorting is a sorting algorithm proposed by David Musser in 1997.</i>  <i>It uses a quick sort and switches to pyramid sorting when the depth of recursion exceeds a predetermined level.</i>  <i>This approach combines the advantages of both methods with the worst case of O (n log n) and speed, comparable to the quick sort.</i>  <i>Since both algorithms use comparisons, this algorithm also belongs to the class of sorting based on comparisons.</i> <br><br>  Now let's take a look at what happens in IntrospectiveSort.  In fact, this is the same introspective sorting only more optimized.  By the way, MSDN still says that it uses quick sort. <br><br><div class="spoiler">  <b class="spoiler_title">IntroSort</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntroSort</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T[] keys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depthLimit, IComparer&lt;T&gt; comparer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; hi &gt; lo; {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num; hi = num - <span class="hljs-number"><span class="hljs-number">1</span></span>;}) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = hi - lo + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt;= <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   16    { if (num == 1) //   break; if (num == 2) //   { ArraySortHelper&lt;T&gt;.SwapIfGreater(keys, comparer, lo, hi); break; } else if (num == 3) //   { ArraySortHelper&lt;T&gt;.SwapIfGreater(keys, comparer, lo, hi - 1); ArraySortHelper&lt;T&gt;.SwapIfGreater(keys, comparer, lo, hi); ArraySortHelper&lt;T&gt;.SwapIfGreater(keys, comparer, hi - 1, hi); break; } else { ArraySortHelper&lt;T&gt;.InsertionSort(keys, lo, hi, comparer); //  break; } } else if (depthLimit == 0) //    { ArraySortHelper&lt;T&gt;.Heapsort(keys, lo, hi, comparer); //   break; } else //      { --depthLimit; num = ArraySortHelper&lt;T&gt;.PickPivotAndPartition(keys, lo, hi, comparer); ArraySortHelper&lt;T&gt;.IntroSort(keys, num + 1, hi, depthLimit, comparer); } } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">PickPivotAndPartition</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     private static int PickPivotAndPartition(T[] keys, int lo, int hi, IComparer&lt;T&gt; comparer) { int index = lo + (hi - lo) / 2; ArraySortHelper&lt;T&gt;.SwapIfGreater(keys, comparer, lo, index); ArraySortHelper&lt;T&gt;.SwapIfGreater(keys, comparer, lo, hi); ArraySortHelper&lt;T&gt;.SwapIfGreater(keys, comparer, index, hi); T obj = keys[index]; ArraySortHelper&lt;T&gt;.Swap(keys, index, hi - 1); int i = lo; int j = hi - 1; while (i &lt; j) { do ; while (comparer.Compare(keys[++i], obj) &lt; 0); do ; while (comparer.Compare(obj, keys[--j]) &lt; 0); if (i &lt; j) ArraySortHelper&lt;T&gt;.Swap(keys, i, j); else break; } ArraySortHelper&lt;T&gt;.Swap(keys, i, hi - 1); return i; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">InsertionSort</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  private static void InsertionSort(T[] keys, int lo, int hi, IComparer&lt;T&gt; comparer) { for (int index1 = lo; index1 &lt; hi; ++index1) { int index2 = index1; T x; for (x = keys[index1 + 1]; index2 &gt;= lo &amp;&amp; comparer.Compare(x, keys[index2]) &lt; 0; --index2) keys[index2 + 1] = keys[index2]; keys[index2 + 1] = x; } }</span></span></code> </pre><br></div></div><br>  Now sorting in arrays is a mixture of sorting: sorting by inserts, quick sorting and pyramidal sorting. <br><br>  The use of Introsort has a positive effect on performance, since in real-life tasks, data are partially ordered, and sorting by inserts works very quickly on such data, as is well known. <br><br><h4>  Performance comparison </h4><br><img src="https://habrastorage.org/storage2/03a/28d/51f/03a28d51fd0ccfaad3170cb3ba560bfd.png"><br><br><h4>  Java comparison </h4><br>  In terms of sorting, Java is quite different from .NET.  However, as in .NET in Java, the algorithm also changed. <br><br>  As you know, quick sorting is unstable, which is a disadvantage when sorting reference types.  Since Java is ‚Äúlike objects‚Äù, this problem is exacerbated, so merge sort is used to sort reference types.  This sorting is stable and guarantees O (n logn) runtime in the worst case, however, it also requires O (n) additional memory. <br><br>  Since the stability problem concerns only reference types, for primitives it does not matter whether we change items with one key or not.  Therefore, to sort primitives, Java uses an advanced quick sort algorithm, DualPivotQuicksort.  Normal Quicksort divides an array into two segments, selecting a random element P. Then sorts the array so that all elements less than P fall into the first segment, and the rest into the second.  Then the algorithm is recursively repeated on the first and second segments.  DualPivotQuicksort divides an array into three segments, instead of two.  As a result, the number of operations to move the elements of the array is significantly reduced. <br><br>  In Java 7, the algorithm for sorting reference types has changed to TimSort. <br><br>  <i>Timsort is a hybrid sorting algorithm that combines sorting by inserts and merge sorting, published in 2002 by Tim Peters.</i>  <i>Currently Timsort is a standard sorting algorithm in Python, OpenJDK 7 and implemented in Android JDK 1.5.</i>  <i>The basic idea of ‚Äã‚Äãthe algorithm is that in the real world, sortable data files often contain ordered subarrays.</i>  <i>On such data, Timsort is significantly faster than many sorting algorithms.</i> <br><br> Timsort ‚Äî ,        30   . <br><br>            ?        ,     ,       Java?      ,           .NET?      .NET,   ,       ,  ,   ,   ,    4     , ,             , ,       . <br><br><h4>  Conclusion </h4><br>      .NET    ,  ,     .   ,         .  ,   .  I hope the article was helpful. </div><p>Source: <a href="https://habr.com/ru/post/188012/">https://habr.com/ru/post/188012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../187988/index.html">Overview of the Chinese DPSS laser 532nm</a></li>
<li><a href="../187992/index.html">American agents "lucky" in the pursuit of Russian hackers</a></li>
<li><a href="../187994/index.html">Streaming in Rails 4</a></li>
<li><a href="../188002/index.html">Interrupts in pipelined processors</a></li>
<li><a href="../188010/index.html">Know the complexity of the algorithms</a></li>
<li><a href="../188014/index.html">Twitter Bootstrap 3 RC Released 1</a></li>
<li><a href="../188016/index.html">The court forbade the publication of launch codes for luxury cars</a></li>
<li><a href="../188018/index.html">Windows NT today is 20 years old</a></li>
<li><a href="../188020/index.html">Scientists have managed to stop the light for one minute.</a></li>
<li><a href="../188022/index.html">Free translation of executive summary from The Innovator's Solution book on the innovator's dilemma and its possible solution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>