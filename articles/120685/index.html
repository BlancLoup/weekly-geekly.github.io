<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We start talking about multitasking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings. 
 I apologize for the fact that this post was delayed so much, but it was not possible to write earlier. In this issue, let's start talking...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We start talking about multitasking</h1><div class="post__text post__text-html js-mediator-article"> Greetings. <br>  I apologize for the fact that this post was delayed so much, but it was not possible to write earlier.  In this issue, let's start talking about multitasking for our system. <br><a name="habracut"></a><br>  First, let's solve one important question: what kind of multitasking will we implement?  There is hardware, there is software multitasking ... <br>  At first it seems that the hardware is better, because after all, Intel clearly tried to make this mechanism 'fly', but there are pitfalls.  First, it is slower.  How?  Ask Intel engineers.  Secondly, everyone has probably already read that with hardware multitasking we must use TSS (Task-State Segment), whose descriptors are stored in the GDT, which can accommodate ... (drum roll) ... 8192 descriptors.  It may seem that this is enough, but on the server (yes, yes, we dream) this may not be enough.  In principle, this is not important for us, but we will do it conscientiously - software multitasking. <br>  In this issue, I propose to consider only the mechanism for switching tasks. <br>  Now let's talk about what we need to do. <br>  1) Come up with some kind of TSS replacement. <br>  2) Decide how to implement address space for processes. <br>  3) Consider switching tasks. <br>  Let's implement preemptive multitasking, that is, we will do this: by the tick of the timer (which is triggered by default every 18.2 times per second), we will switch tasks.  Instead of TSS, you can enter a structure in which the state of the process will be saved.  The address space for each process is static (you need to start somewhere, right?).  That is, roughly speaking, we take a piece of RAM and divide it into N equal parts. <br>  Now you can begin to implement. <br><br>  To begin, let's introduce a replacement TSS;  Let it proudly called TSS_struct and looks like this: <br><br> <code>TSS_struct: <br> 0: privilage level (0|3) <br> 1: ESP (Ring0) <br> 5: CR3 <br> 9: EIP <br> 13: EFLAGS <br> 17: EAX <br> 21: ECX <br> 25: EDX <br> 29: EBX <br> 33: ESP (Ring3) <br> 37: EBP <br> 41: ESI <br> 45: EDI <br> 49: ES <br> 51: CS <br> 53: SS <br> 55: DS <br> 57: FS <br> 59: GS <br> 61: LDT_selector <br> 63-256 - free <br></code> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we will implement the function that we will call with each tick of the timer. <br>  We need to keep the state of the old task, find the next task, load the new one.  For marking TSS_struct'ov we will use 10 bytes, where each bit will denote 1 task.  It is also worth considering 2 situations that will affect the stack: <br>  1) The level of privilege does not change; <br>  2) is changing; <br>  In the first version, the stack will look like this: <br><br> <code>;|EFLAGS <br> ;|CS <br> ;|EIP &lt;---- ESP   <br> ;V <br></code> <br><br>  In the second so: <br> <code>;|SS <br> ;|ESP <br> ;|EFLAGS <br> ;|CS <br> ;|EIP &lt;---- ESP   <br> ;V <br></code> <br><br>  Note that only those registers that are simply necessary for the execution of an interrupt handler change their values. <br>  In this issue, I propose to consider only Ring0.  Ring (1 | 2 | 3) we have not yet considered, and the behavior there will be different, so we restrict ourselves. <br>  Before we start writing the code, let me tell you where the slippery places are, where I personally stalled, and, often, for a long time. <br>  1) The most elementary: incorrectly specify the return address, which we push into the stack. <br>  2) Do not set the IF (Interrupt Flag) flag in EFLAGS.  Ie, masked interrupts are prohibited, and you can forget about switching tasks. <br>  3) It is important not to be mistaken in the search function for the next task.  Despite the simplicity there can breed beetles.  Personally, I drove her separately through Olga, so that the result was guaranteed to be correct. <br>  4) If you decide not to jump from procedure to procedure, but to act calmly and calmly via call, do not forget about the stack!  In general, the stack, in my opinion, is the most slippery place in this business. <br>  Now consider the abbreviated context switching procedure.  Why abbreviated?  You need to show multitasking, so it will not write a lot of code here now.  We have a demo. <br>  Okay, let's start with the fact that we need to describe a new task.  Since it is executed in Ring0, the stack and the value of all segment registers will be left alone.  Just put the data to return.  This is just a demonstration!  It should not generally have the proud name create_task.  Just put the values ‚Äã‚Äãfor the loading procedure and set the bit in the bitmap of the busy TSS_structs.  So: <br><br> <code>create_task: <br> mov ax,20h; - .  <br> mov es,ax <br> mov [es:100h+9],dword task;EIP <br> pushfd ;EFLAGS   <br> pop eax <br> mov [es:100h+13],eax;EFLAGS <br> mov [es:100h+51],word 8h ;CS ‚Äì Ring0,   <br> <br> bts word [bysi_TSS_map],6 ;    <br> mov ax,10h;    <br> mov es,ax <br> ret <br></code> <br><br>  The selector used here is 20h.  I have an area for storing TSS_structs.  Still.  Why set the 6th bit?  And the snag is.  Code that is already being executed should also become ....  challenge  Therefore it is necessary to mark this 7th bit: <br><br> <code>bts word [bysi_TSS_map],7 <br></code> <br><br>  Now let's look at the procedures for saving and switching contexts, searching for a new task. <br>  Everything is simple and easy here: we calculate the address of TSS_struct by the task number, look for a new one, read data from its TSS_struct and jump to the new task. <br>  So, from the PIT handler, jump to the task switching procedure - task_switch: <br> <code>task_switch: <br> <br> mov [temp_1],eax <br> mov [temp_2],es <br> <br> xor eax,eax <br> mov ax,20h <br> mov es,ax <br> <br> call calculate_TSS_struct_address ;: EDI ‚Äì   <br> jmp store_context <br></code> <br><br>  Where are the storage variables: <br><br> <code>temp_1 dd 0;EAX <br> temp_2 dw 0;ES <br></code> <br><br>  We will need to calculate the address in the future.  So we issue in the form of procedures. <br><br> <code>calculate_TSS_struct_address: <br> push eax <br> push ebx <br> mov eax,[cur_task_num];  dword'     .  <br> mov ebx,100h <br> mul ebx <br> pop ebx <br> mov edi,eax;EDI ‚Äì  TSS_struct <br> pop eax <br> ret <br></code> <br><br>  Now consider the process of saving the context.  Banalism - on the bias we put the values.  Everything. <br><br> <code>store_context: <br> ;mov eax,cr3 ;    <br> ;mov [es:edi+5],eax <br> <br> pushfd <br> pop eax <br> mov [es:edi+13],eax;EFLAGS <br> <br> mov [es:edi+21],ecx <br> mov [es:edi+25],edx <br> mov [es:edi+29],ebx <br> mov [es:edi+37],ebp <br> mov [es:edi+41],esi <br> mov [es:edi+45],edi <br> <br> mov ax,[temp_2] <br> mov [es:edi+49],ax;ES <br> <br> mov eax,[temp_1] <br> mov [es:edi+17],eax <br> mov [es:edi+53],ss <br> mov [es:edi+55],ds <br> mov [es:edi+57],fs <br> mov [es:edi+59],gs <br> ;sldt ax ;       <br> ;mov [es:edi+61],ax <br> <br> pop eax <br> mov [es:edi+9],eax;EIP <br> ;   <br> pop ax <br> mov [es:edi+51],ax;CS <br> <br> popfd ;EFLAGS <br> <br> jmp find_next_task <br></code> <br><br>  The next function searches for the next victim in the bitmap and returns its address to EDI. <br><br> <code>find_next_task: <br> xor edx,edx <br> mov eax,[cur_task_num] <br> mov ecx,8 <br> div ecx <br> ;EAX -   <br> ;EDX - ''   <br> test edx,edx <br> jnz .norm <br> <br> mov edi,7 <br> jmp .step <br> <br> .norm: mov edi,8 <br> .step: sub edi,edx;real bit # <br> mov edx,edi <br> mov edi,eax <br> <br> .cycle: <br> bt word [bysi_TSS_map+edi],dx <br> jc .found <br> cmp dx,0 <br> je .inc_byte <br> dec dx <br> jmp .cycle <br> <br> .inc_byte: <br> cmp edi,10;    -  800- . <br> je .error <br> inc edi <br> mov dx,7 <br> jmp .cycle <br> <br> .found: <br> push edx <br> mov eax,8 <br> mul edi <br> pop edx <br> <br> mov di,7 <br> sub di,dx <br> add eax,edi <br> mov [cur_task_num],eax <br> call calculate_TSS_struct_address <br> jmp load_context <br> <br> .error: <br> mov dx,7;   . <br> xor edi,edi <br> jmp .cycle <br></code> <br><br>  Now there is only a loading context. <br><br> <code>load_context: <br> ;mov eax,[es:edi+5];CR3 -      <br> ;mov cr3,eax <br> <br> ;mov esp,[es:edi+1];      <br> ;mov ss,[es:edi+53] <br> <br> mov ecx,[es:edi+21] <br> mov edx,[es:edi+25] <br> mov ebx,[es:edi+29] <br> mov ebp,[es:edi+37] <br> mov esi,[es:edi+41] <br> mov edi,[es:edi+45] <br> <br> ;mov ds,[es:edi+55];      .        <br> ;mov fs,[es:edi+57] <br> ;mov gs,[es:edi+59] <br> <br> ; ''     ( iretd) <br> push dword [es:edi+13];EFLAGS <br> push word [es:edi+51] ;CS <br> push dword [es:edi+9];EIP <br> <br> jmp timer.s_t <br></code> <br><br>  Here it is worth paying attention.  As we remember, when interrupting the stack (in this case, the utility one), 3 values ‚Äã‚Äãare stored (the privilege level does not change).  Before the transition, we push the 'coordinates' of the new task onto the stack, transfer control to the PIT handler and do iretd.  Are our torments over?  Nearly.  In the context of the new task, sti needs to be done to enable interrupts.  That's all.  And you were afraid! <br>  The handler for the timer will look as follows: <br><br> <code>timer: <br> ;........ <br> .s_t: <br> push ax ;  EOI <br> mov al,20h <br> out 20h,al <br> out 0a0h,al <br> pop ax <br> iretd ;    <br></code> <br><br>  Now we introduce the task. <br>  Remember, before this, we have code ending up with jmp $? <br>  Now you can put an increase in the character.  Visually and quickly. <br>  And the task that we mentioned before can be represented as <br><br> <code>task: <br> sti <br> inc byte [gs:0] <br> jmp task <br></code> <br><br>  Now we collect all this together and admire the result. <br><br>  So.  Here is the introductory article and ended. <br>  Implemented the similarity of multitasking.  Tasks do not have their own stack, their segments and local descriptor tables ... There is still a lot of work to be done.  Here are the topics for future releases.  I apologize for my English ('bysi' = 'busy'; it's just a long time to fix it everywhere in the code). </div><p>Source: <a href="https://habr.com/ru/post/120685/">https://habr.com/ru/post/120685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120675/index.html">Free books in Russian - Windows Phone, Visual Studio, Small Basic</a></li>
<li><a href="../120676/index.html">TileMill - cartographic design studio</a></li>
<li><a href="../120678/index.html">Do not miss SharePoint Conference 2011 Russia</a></li>
<li><a href="../120681/index.html">Myths about SaaS, cloud platforms and cloud computing</a></li>
<li><a href="../120684/index.html">We are friends with AirPlaySDK</a></li>
<li><a href="../120686/index.html">Graphics via OpenGL on Haskell</a></li>
<li><a href="../120688/index.html">Your tool for team work on texts.</a></li>
<li><a href="../120690/index.html">Service for convenient embedding of content 200+ services in your website / blog</a></li>
<li><a href="../120692/index.html">The law of the Astrakhan Region ‚ÄúOn the Universal Electronic Card‚Äù was adopted by the Duma in the first reading.</a></li>
<li><a href="../120693/index.html">Virtualize! Virtualization News Digest # 0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>