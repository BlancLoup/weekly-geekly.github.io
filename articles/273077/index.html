<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Software multitasking timer on the MK</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In various kinds of complexity of the implemented algorithms when programming MK, routine cyclic and not-so-difficult problems always arise. Some requ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Software multitasking timer on the MK</h1><div class="post__text post__text-html js-mediator-article">  In various kinds of complexity of the implemented algorithms when programming MK, routine cyclic and not-so-difficult problems always arise.  Some require increased accuracy, others do not have to have such a criterion.  Hardware timers on board the MK can be a decent amount, for example STM32F4 - as many as 14 pieces, and this is not counting SysTick (system), and in others a pair of three for happiness: the same PIC16, for example. <br><br>  To solve such unhurried, time-critical tasks, you can and should use a software timer based on one of the hardware.  But first things first... <a name="habracut"></a><br><br><h4>  <b>Instead of the preface</b> </h4><br>  Ask the HUGLA what he thinks about it? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Without thinking, the search engine will produce something like this: <br><br><ol><li>  <a href="http://chipenable.ru/index.php/programming-avr/item/28-programmnye-taymery-chast-1.html">Software timers.</a>  <a href="http://chipenable.ru/index.php/programming-avr/item/28-programmnye-taymery-chast-1.html">Part 1</a> </li><li>  <a href="http://we.easyelectronics.ru/STM32/mnogozadachnyy-programmnyy-taymer.html">Multitasking program timer.</a> </li><li>  <a href="http://we.easyelectronics.ru/STM32/mnogozadachnyy-programmnyy-taymer-ver-20.html">Multitasking software timer, ver 2.0</a> </li><li>  <a href="http://we.easyelectronics.ru/Soft/programmnyy-taymer-primenenie-hal.html">Program timer.</a>  <a href="http://we.easyelectronics.ru/Soft/programmnyy-taymer-primenenie-hal.html">HAL Application</a> </li></ol><br>  These articles served as a starting point in the implementation of the algorithm. <br><br><h4>  <b>Foreword</b> </h4><br>  As a developer of automated process control systems, I often program PLCs of various companies.  For any PLC in the development environment, libraries for software timers are stored.  Almost all of them have the same type of functionality.  The use of timers in the PLC program is required in many kinds of tasks, it makes no sense to describe all of them, so I will show a couple of examples from the industrial control system and these examples are ‚Äúroughly porting‚Äù into this module. <br><br><h4>  <b>Mini TK</b> </h4><br>  What kind of timers are needed in this module?  I opted for four types: <br><br><ul><li>  Delayed Timer </li><li>  Off-delay timer </li><li>  Cyclic timer </li><li>  Single timer </li></ul><br>  The first two timers clearly migrated from the PCS and PLC programming.  The last two are a logical extension of the hardware timer of any MK.  Consider each type of timer separately. <br><br><h5>  <b>Delayed Timer</b> </h5><br>  A trivial example of such a timer is the implementation of a time relay.  The high (active) level signal arrives at the triggering (controlling) timer input and the timer obediently starts counting the time after which the active level at the input translates its output into the active state too.  As soon as we remove the signal at the timer input, the output also becomes inactive.  The timing chart is presented below. <br><img src="https://habrastorage.org/files/555/4bb/839/5554bb839aa64eba8f8a8640037c5c55.jpg"><br><br>  In the world of MK, this timer will find its use if it is necessary to provide an anti-detour of ‚Äúdry‚Äù contact, for detecting a long keystroke, etc.  The scope of this timer is clearly not limited to this. <br><br><h5>  <b>Off-delay timer</b> </h5><br>  The timer is essentially the same as the first, but with the opposite logic.  While active input, active and timer output.  As soon as the input is low (not active), the timer starts counting down and at the end it resets its output to zero too.  Here is his timeline. <br><img src="https://habrastorage.org/files/6c9/6fe/2da/6c96fe2daed24705b30277916373f5b3.jpg"><br><br>  This is necessary when it is necessary to stop the task not at the same time as its ‚Äúparent‚Äù, but a little later.  This type of timer may seem exotic to someone, when programming the MK, maybe so, but as they say, let it be. <br><br><h5>  <b>Cyclic timer</b> </h5><br>  Well, everything is trite here.  Each overflow of this timer should trigger an event for which we perform this or that routine task.  Interrogation of the sensor of the inertial medium, flashing of the LED, telling us that the MK is in ‚Äúorder‚Äù, for organizing equal intervals of time for all sorts of filters, etc.  The timing chart below. <br><br><img src="https://habrastorage.org/files/62b/b42/869/62bb4286992f4d208e1bbad03912f241.jpg"><br><br><h5>  <b>Single timer</b> </h5><br>  It is almost a complete copy of the cyclic, except for the fact that this type of timer switches itself off (stops) after operation.  That is, they launched, counted their delay, set a flag (pointed to an event) and stopped themselves.  Here is his chart. <br><br><img src="https://habrastorage.org/files/e17/f0d/c9c/e17f0dc9c55e40eeb377094097c26564.jpg"><br><br>  Now all this is implemented in the code. <br><br><h4>  <b>SwTimer module</b> </h4><br>  The name of the module speaks for itself.  The module consists of two files: header and sorts. <br><br>  Consider the leader: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SW_TIMER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SW_TIMER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SwTimerCount 64 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   /*  */ typedef enum { SWTIMER_MODE_EMPTY, SWTIMER_MODE_WAIT_ON, SWTIMER_MODE_WAIT_OFF, SWTIMER_MODE_CYCLE, SWTIMER_MODE_SINGLE } SwTimerMode; /*  */ typedef struct { unsigned LocalCount:32; //    unsigned Count:24; //    unsigned Mode:3; //  unsigned On:1; //  unsigned Reset:1; //      unsigned Off:1; //  unsigned Out:1; //  unsigned Status:1; //  }SW_TIMER; #if (SwTimerCount&gt;0) volatile SW_TIMER TIM[SwTimerCount]; //   #endif void SwTimerWork(volatile SW_TIMER* TIM, unsigned char Count); //     void OnSwTimer(volatile SW_TIMER* TIM, SwTimerMode Mode, unsigned int SwCount); //     unsigned char GetStatusSwTimer(volatile SW_TIMER* TIM); //   #endif /* SW_TIMER_H_ */</span></span></span></span></code> </pre> <br>  This header contains a defayn indicating the number of software timers in the array.  Announced enum for the "conscious" description of the timer operation modes.  The following is the structure of the software timer.  The only thing I would like to draw attention to is that the timer itself is 24-bit.  In this structure, this allows the software timer to take up space of 8 bytes.  24 bits when the hardware timer overflows to 1 ms, it allows to achieve a delay of 4.66 hours or 16,777 seconds.  Quite enough. <br><br>  Functions a bit. <br><br>  The main function that ensures the operation of the entire module: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SwTimerWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SW_TIMER* TIM, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Count)</span></span></span></span>;</code> </pre><br>  This function should be called when the hardware timer overflows.  It organizes the entire algorithm of the module.  Let's look at the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SwTimerWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SW_TIMER* TIM, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Count)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;Count; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TIM-&gt;Mode==SWTIMER_MODE_EMPTY) { TIM++; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TIM-&gt;Mode==SWTIMER_MODE_WAIT_ON){ <span class="hljs-comment"><span class="hljs-comment">//     if (TIM-&gt;On){ if (TIM-&gt;LocalCount&gt;0) TIM-&gt;LocalCount--; else { TIM-&gt;Out=1; TIM-&gt;Status=1; } } else { TIM-&gt;Out=0; TIM-&gt;LocalCount=TIM-&gt;Count-1; } } if (TIM-&gt;Mode==SWTIMER_MODE_WAIT_OFF){ //     if (TIM-&gt;On){ TIM-&gt;Out=1; TIM-&gt;Status=1; TIM-&gt;LocalCount=TIM-&gt;Count-1; } else { if (TIM-&gt;LocalCount&gt;0) TIM-&gt;LocalCount--; else TIM-&gt;Out=0; } } if (TIM-&gt;Mode==SWTIMER_MODE_CYCLE){ if (TIM-&gt;Off){ if (TIM-&gt;On){ TIM-&gt;Off=0; if (TIM-&gt;LocalCount&gt;0) TIM-&gt;LocalCount--; } } else{ if (TIM-&gt;LocalCount&gt;0) { TIM-&gt;LocalCount--; TIM-&gt;Out=0; } else { TIM-&gt;Out=1; TIM-&gt;Status=1; TIM-&gt;LocalCount=TIM-&gt;Count-1; } } if (TIM-&gt;Reset){ TIM-&gt;LocalCount=TIM-&gt;Count-1; TIM-&gt;Out=0; TIM-&gt;Status=0; } } if (TIM-&gt;Mode==SWTIMER_MODE_SINGLE){ if (TIM-&gt;Off){ if (TIM-&gt;On){ TIM-&gt;Off=0; if (TIM-&gt;LocalCount&gt;0) TIM-&gt;LocalCount--; } } else{ if (TIM-&gt;LocalCount&gt;0) { TIM-&gt;LocalCount--; TIM-&gt;Out=0; } else { TIM-&gt;Out=1; TIM-&gt;Status=1; TIM-&gt;LocalCount=TIM-&gt;Count-1; TIM-&gt;Off=1; } } if (TIM-&gt;Reset){ TIM-&gt;LocalCount=TIM-&gt;Count-1; TIM-&gt;Out=0; TIM-&gt;Status=0; } } TIM++; } }</span></span></code> </pre><br>  In the loop we go through the entire array of timers.  If the timer is empty = EMPTY, then go to the next timer.  Depending on the mode of the timer, its own logic is organized. <br><br>  The call of this function can be organized both from the interruption of the hardware timer and from the cycle in the main program by flag. <br>  Here is an example of an interrupt for STM32. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sw_timer.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 0 */</span></span></span><span class="hljs-meta"> void SysTick_Handler(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN SysTick_IRQn 0 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END SysTick_IRQn 0 */</span></span></span><span class="hljs-meta"> HAL_IncTick(); HAL_SYSTICK_IRQHandler(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN SysTick_IRQn 1 */</span></span></span><span class="hljs-meta"> SwTimerWork(TIM,SwTimerCount); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END SysTick_IRQn 1 */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  But from the main loop: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> FlagSwTimer; <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END 0 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SysTick_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN SysTick_IRQn 0 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END SysTick_IRQn 0 */</span></span> HAL_IncTick(); HAL_SYSTICK_IRQHandler(); <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN SysTick_IRQn 1 */</span></span> FlagSwTimer=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END SysTick_IRQn 1 */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FlagSwTimer){ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (SwTimerCount&gt;0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    sw_timer.c SwTimerWork(TIM,SwTimerCount); #endif FlagSwTimer=0; }</span></span></span></span></code> </pre><br>  Other functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSwTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SW_TIMER* TIM, SwTimerMode Mode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SwCount)</span></span></span></span>;</code> </pre><br>  This function sets the operation mode of a specific timer, sets the required delay. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStatusSwTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SW_TIMER* TIM)</span></span></span></span>;</code> </pre><br>  Read the status of the timer status.  Returns -1 if the specified timer is empty. <br><br><h4>  <b>Application</b> </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> I_DI_READ_0() HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  OnSwTimer(&amp;TIM[0],SWTIMER_MODE_WAIT_OFF,1000); OnSwTimer(&amp;TIM[1],SWTIMER_MODE_SINGLE,1000); OnSwTimer(&amp;TIM[2],SWTIMER_MODE_WAIT_ON,1000); OnSwTimer(&amp;TIM[3],SWTIMER_MODE_CYCLE,1000); TIM[3].Off=0; TIM[3].On=1; //   TIM[1].Off=0; TIM[1].On=1; //  </span></span></span></span></code> </pre><br>  We initialize several timers with different modes.  In the main cycle we use at our discretion: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>){ TIM[<span class="hljs-number"><span class="hljs-number">2</span></span>].On=I_DI_READ_0(); <span class="hljs-comment"><span class="hljs-comment">// ,       HAL_GPIO_WritePin(GPIOD,GPIO_PIN_15,TIM[2].Out); //  ,   TIM[0].On=I_DI_READ_0(); //  ,        HAL_GPIO_WritePin(GPIOD,GPIO_PIN_14,TIM[0].Out); // ,   if (GetStatusSwTimer(&amp;TIM[3])){ HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_13); //   ,   } if (GetStatusSwTimer(&amp;TIM[1])){ HAL_GPIO_TogglePin(GPIOD,GPIO_PIN_12); //   ,   } TIM[3].Reset=I_DI_READ_0(); //  ,    }</span></span></code> </pre><br>  If you need to stop the cyclic or single timer, then you need to reset the enable bit and set the disable bit. <br><br><pre> <code class="cpp hljs"> TIM[<span class="hljs-number"><span class="hljs-number">3</span></span>].On=<span class="hljs-number"><span class="hljs-number">0</span></span>; TIM[<span class="hljs-number"><span class="hljs-number">3</span></span>].Off=<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Re-enable by setting trigger bit On. <br><br>  Status reading can be done both as a function and directly reading the bit. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetStatusSwTimer(&amp;TIM[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-comment"><span class="hljs-comment">//  if (TIM[3].Status){ //  TIM[3].Status=0; // ,         //   ,       /*UserCode*/ }</span></span></code> </pre><br>  If the timer is no longer needed, then you can reduce the execution time of the function of processing the array of timers if you do not just stop the timer, but delete it, that is, put it into NULL mode.  To do this, call the timer preparation function with the SWTIMER_MODE_EMPTY mode.  Or just point it out. <br><br><pre> <code class="cpp hljs"> OnSwTimer(&amp;TIM[<span class="hljs-number"><span class="hljs-number">3</span></span>],SWTIMER_MODE_EMPTY,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  TIM[3].Mode=SWTIMER_MODE_EMPTY; // </span></span></code> </pre><br>  The first two timers and the second two are slightly different in one structure, so as not to produce unnecessary functions, etc.  You can download the program timer module <a href="">from here</a> . <br><br>  This article is a recycled material from <a href="http://druid.su/index.php%3Fview%3Drubrik%26name%3Dstm32_program%26id%3D30">STM32.</a>  <a href="http://druid.su/index.php%3Fview%3Drubrik%26name%3Dstm32_program%26id%3D30">STM32F4 programming lessons.</a>  <a href="http://druid.su/index.php%3Fview%3Drubrik%26name%3Dstm32_program%26id%3D30">Lesson number 4. Software multitask timer STM32F4.</a>  the author of which I am. <br><br>  Video demonstrating the functions of this module software multitask timer: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/gmtpVsPCLUM%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhicBbr2V93yGdNeNpUDd8x07D-AxA" frameborder="0" allowfullscreen=""></iframe><br>  Probably that's all. </div><p>Source: <a href="https://habr.com/ru/post/273077/">https://habr.com/ru/post/273077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273067/index.html">Receptions work in Blender. Part 1</a></li>
<li><a href="../273069/index.html">Experience Evaluation of Diplomas in the USA (WES)</a></li>
<li><a href="../273071/index.html">Web without a mouse</a></li>
<li><a href="../273073/index.html">Free tools for database developers</a></li>
<li><a href="../273075/index.html">Xamarin and Xamarin.Forms - cactus in chocolate. Part 1</a></li>
<li><a href="../273081/index.html">Changes in RAD Studio 10 Seattle Update 1</a></li>
<li><a href="../273083/index.html">Manage Drones with Intel RealSense SDK Speech Recognition Applications</a></li>
<li><a href="../273087/index.html">The button bar in the elevator: the door, do not rush to close</a></li>
<li><a href="../273089/index.html">Selenium for Python. Chapter 5. Expectations</a></li>
<li><a href="../273093/index.html">How to replace a domain controller and not break the current infrastructure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>