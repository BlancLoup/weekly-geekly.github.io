<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compile-time functional programming in D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will look at one of the main features of the D language, for which it was created - it is advanced programming at the compilation stage. Some...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compile-time functional programming in D</h1><div class="post__text post__text-html js-mediator-article">  Today we will look at one of the main features of the D language, for which it was created - it is advanced programming at the compilation stage.  Some may recall how factorial is calculated in C ++ or, more difficultly, the <a href="http://habrahabr.ru/post/218229/">implementation of the game ‚ÄúLife‚Äù</a> and get scared.  It is not necessary, the patterns in D are an order of magnitude simpler and more powerful than the analogue from C ++, but still they require a special approach in thinking, therefore, for acclimatization, the complexity of the material will increase gradually. <br><br><a name="habracut"></a><br><br><h4>  Formulation of the problem </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In D, <a href="http://en.wikipedia.org/wiki/Structural_type_system">structural typing is</a> very often used (analogous to duck typing for static typing), for example, to check if the type of operation supports it for use in the <b>foreach statement</b> : <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.range; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(isInputRange!(uint[]))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// true static assert(isInputRange!string); // true static assert(!isInputRange!void); // false</span></span></code> </pre> <br><br>  <b>static assert</b> is a variant of classic <b>assert</b> , but which is executed at the compilation stage, and if an expression of false is passed to it, it will stop compilation.  And <b>isInputRange is</b> declared as a template that checks for the presence of the necessary methods (you can go into the following example in detail and consider all the concepts below): <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isInputRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isInputRange = is(typeof( (inout <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) { R r = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-comment"><span class="hljs-comment">// can define a range object if (r.empty) {} // can test for empty r.popFront(); // can invoke popFront() auto h = r.front; // can get the front of the range })); }</span></span></code> </pre><br><br>  And for each of your compile-time interface you have to do one or several testing templates.  This is a bit tiring, I would like to check for the implementation of the compile-time interface as follows: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    struct CInterface { string method1(); bool method2(); } //  / struct A {} static assert(isExpose!(A, CInterface));</span></span></code> </pre><br><br>  Here we will implement the <b>isExpose</b> function, simultaneously delving into template programming. <br><br><h4>  Warming up </h4><br>  To begin with, we will calculate the factorial on the templates: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//       template factorial(uint n) { // - private template inner(ulong acc, uint n) { //       static  if static if(n == 0) enum inner = acc; //  else enum inner = inner!(acc * n, n-1 ); //    } //       1 enum factorial = inner!(1, n); } static assert(factorial!5 == 120);</span></span></code> </pre><br><br>  The key point in writing templates is the declaration of a constant or an alias with the name identical to the name of the template; this is an analogue of <b>return</b> in ordinary functions.  This template uses another internal one to organize tail recursion (via battery). <br><br>  In templates, you can transfer the values ‚Äã‚Äãof the basic types, types, lists of types, and, most interestingly, the expression expressions.  Everything is quite clear with values ‚Äã‚Äãand types, this is in many languages, but expression lists need to be clarified: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T...)</span></span></span><span class="hljs-function"> </span></span>{} alias a1 = test!(ulong, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    alias a2 = test!("hi!", 23+42, [true, false], float); //   </span></span></code> </pre><br>  With the help of expression lists, anything can be transferred to templates that can be calculated at the compilation stage.  In total, we will continue to work with lists of expressions almost everywhere. <br><br><h4>  Character operations </h4><br>  Let's start collecting the required <b>isExpose</b> template: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//    ,      template isExpose(Type, Interfaces...) { //     ,     1  private template isExposeSingle(Interface) { } //  ,     1     enum isExpose = allSatisfy!(isExposeSingle, Interfaces); }</span></span></code> </pre><br><br>  Let's look at the <b>allSatisfy</b> template, it is <a href="http://dlang.org/phobos/std_typetuple.html">declared</a> in the standard library: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allSatisfy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alias F, T...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T.length == </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> allSatisfy = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (T.length == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> allSatisfy = F!(T[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> allSatisfy = allSatisfy!(F, T[ <span class="hljs-number"><span class="hljs-number">0</span></span> .. $/<span class="hljs-number"><span class="hljs-number">2</span></span>]) &amp;&amp; allSatisfy!(F, T[$/<span class="hljs-number"><span class="hljs-number">2</span></span> .. $ ]); <span class="hljs-comment"><span class="hljs-comment">//   // enum allSatisfy = F!(T[0]) &amp;&amp; allSatisfy!(F, T[1 .. $ ]); } }</span></span></code> </pre><br>  It takes another pattern as the first parameter, which is declared with the <b>alias</b> keyword, which means ‚Äúpass by name‚Äù.  Without this keyword, the compiler would have cursed that the <b>F</b> pattern was applied incorrectly, and with <b>alias</b> , an analogue of deferred computation in functional languages ‚Äã‚Äãis obtained.  <b>allSatisfy</b> applies <b>F</b> to each element of <b>T</b> and checks that the pattern <b>F</b> returns <b>true</b> every time.  It may also seem strange way of splitting the list of argument in the <b>else</b> branch.  This technique allows you to significantly delay the triggering of the compiler protection to endless recursion, since in this way we build a balanced ‚Äútree of calls‚Äù instead of a linear bite one element at a time from the list.  If it is still not clear, here is the scheme: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ad/f85/8d7/7adf858d7bfd9c33257a5e82e4b67197.png"><br><br>  Now you need to solve the type subtask for the presence of one compile-time interface.  To begin with, we need the ability to explicitly create new lists of expressions, this can be done using a tricky trick: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    template List(T...) { //     alias List = T; }</span></span></code> </pre><br><br>  Now we will use the help of the compiler and find out the list of interface members (methods and fields): <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMembers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     List alias getMembers = List!(__traits(allMembers, T)); }</span></span></code> </pre><br><br>  <b>__traits (allMembers, T)</b> will return a list of all internal elements of type <b>T</b> , you can read more about traits <a href="http://dlang.org/traits.html">here</a> .  Now we have the names of the methods and fields of the compile-time interface, but this is not enough, the names of the interface elements and the type being checked may be the same, but their types are not.  To attach element types to their names, we will organize a simple pipeline, but first we will need several auxiliary templates. <br><br>  A template that repeats its argument n times and returns this list of copies: <br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticReplicate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TS...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// is(T)  true,  T    static if(is(TS[0])) alias T = TS[0]; else //    enum T = TS[0]; enum n = TS[1]; static if(n &gt; 0) { alias staticReplicate = List!(T, staticReplicate!(T, n-1)); } else { alias staticReplicate = List!(); } } /// Example unittest { template isBool(T) { enum isBool = is(T == bool); } static assert(allSatisfy!(isBool, staticReplicate!(bool, 2))); static assert([staticReplicate!("42", 3)] == ["42", "42", "42"]); }</span></span></code> </pre><br></div></div><br><br>  A template that applies a template with two parameters to the list: <br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticMap2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alias F, T...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T.length % </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params"> == </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T.length &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ alias staticMap2 = List!(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (T.length == <span class="hljs-number"><span class="hljs-number">2</span></span>) { alias staticMap2 = List!(F!(T[<span class="hljs-number"><span class="hljs-number">0</span></span>], T[<span class="hljs-number"><span class="hljs-number">1</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { alias staticMap2 = List!(F!(T[<span class="hljs-number"><span class="hljs-number">0</span></span>], T[<span class="hljs-number"><span class="hljs-number">1</span></span>]), staticMap2!(F, T[<span class="hljs-number"><span class="hljs-number">2</span></span> .. $])); } } <span class="hljs-comment"><span class="hljs-comment">/// Example unittest { template Test(T...) { enum Test = T[0] &amp;&amp; T[1]; } static assert([staticMap2!(Test, true, true, true, false)] == [true, false]); }</span></span></code> </pre><br></div></div><br><br>  Analogous to <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%2591%25D1%2580%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2581%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0">fold</a> or reduce for templates: <br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticFold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alias F, T...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T.length == </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// invalid input { alias staticFold = List!(); } else static if(T.length == 1) { static if(is(T[0])) alias staticFold = T[0]; else enum staticFold = T[0]; } else { alias staticFold = staticFold!(F, F!(T[0], T[1]), T[2 .. $]); } }</span></span></span></span></code> </pre><br></div></div><br><br>  When transferring several <b>List</b> to any template, they are automatically opened and glued together, which often makes it difficult to implement operations on several lists, so we will also declare a ‚Äúhard‚Äù wrapper on the list, which is revealed when you explicitly call its sublab: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StrictList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T...)</span></span></span><span class="hljs-function"> </span></span>{ alias expand = T; }</code> </pre><br>  In this template, we did not declare an alias named <b>StrictList</b> , which does not allow this template to be automatically replaced by this alias when used.  You can also draw an analogy between the subpatterns and methods, when you call <b>StrictList! (T, U) .expand</b> we will be returned a list of T and U. <br><br>  Using the previous patterns, we implement the last auxiliary pattern.  It will take a list of lists (!) Of expressions and form a new list in which the elements of the arguments fall in order (analogous to the zip function in functional languages): <br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    StrictList,    template staticRobin(SF...) { //        private template minimum(T...) { enum length = T[1].expand.length; enum minimum = T[0] &gt; length ? length : T[0]; } //          enum minLength = staticFold!(minimum, size_t.max, SF); //  ,    ,       private template robin(ulong i) { //       i private template takeByIndex(alias T) { //   ,       static if(is(T.expand[i])) alias takeByIndex = T.expand[i]; else enum takeByIndex = T.expand[i]; } static if(i &gt;= minLength) { alias robin = List!(); } else { // staticMap!(takeByIndex, SF)    i-    alias robin = List!(staticMap!(takeByIndex, SF), robin!(i+1)); } } //   alias staticRobin = robin!0; } /// Example unittest { alias test = staticRobin!(StrictList!(int, int, int), StrictList!(float, float)); static assert(is(test == List!(int, float, int, float))); alias test2 = staticRobin!(StrictList!(1, 2), StrictList!(3, 4, 5), StrictList!(6, 7)); static assert([test2]== [1, 3, 6, 2, 4, 7]); }</span></span></code> </pre><br></div></div><br><br>  That's when we have all the necessary bricks of the assembly line, you can draw its scheme: <br><img src="https://habrastorage.org/getpro/habr/post_images/890/a0d/b65/890a0db65ed86b5d921397f005c6f89b.png"><br><br>  The first part of the conveyor is implemented as follows: <br><pre> <code class="cpp hljs"> alias intMembers = StrictList!(getMembers!Interface); alias intTypes = StrictList!(staticReplicate!(Interface, intMembers.expand.length)); alias pairs = staticMap2!(bindType, staticRobin!(intTypes, intMembers)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> </span></span>{ alias bindType = List!(typeof(mixin(Base.stringof ~ <span class="hljs-string"><span class="hljs-string">"."</span></span> ~ T)), T); }</code> </pre><br><br>  To obtain the type of an element of the interface, we used an <a href="http://dlang.org/mixin.html">admixture</a> that added an interface type through a dot to the name of the method.  And using the <b>typeof</b> operator, we get the type of expression generated in the impurity.  Next, we check whether the type-name pairs are present in the class / structure being checked: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkMember</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MemberType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MemberName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hasMember!(Type, MemberName))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> checkMember = is(typeof(mixin(Type.stringof ~ <span class="hljs-string"><span class="hljs-string">"."</span></span> ~ MemberName)) == MemberType); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> checkMember = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> isExposeSingle = allSatisfy2!(checkMember, pairs);</code> </pre><br><br>  All the pieces of the puzzle fell into place; the total template code was: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isExpose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type, Interfaces...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMembers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>{ alias getMembers = List!(__traits(allMembers, T)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isExposeSingle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Interface)</span></span></span><span class="hljs-function"> </span></span>{ alias intMembers = StrictList!(getMembers!Interface); alias intTypes = StrictList!(staticReplicate!(Interface, intMembers.expand.length)); alias pairs = staticMap2!(bindType, staticRobin!(intTypes, intMembers)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> </span></span>{ alias bindType = List!(typeof(mixin(Base.stringof ~ <span class="hljs-string"><span class="hljs-string">"."</span></span> ~ T)), T); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">template</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkMember</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MemberType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MemberName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hasMember!(Type, MemberName))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> checkMember = is(typeof(mixin(Type.stringof ~ <span class="hljs-string"><span class="hljs-string">"."</span></span> ~ MemberName)) == MemberType); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> checkMember = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> isExposeSingle = allSatisfy2!(checkMember, pairs); } <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> isExpose = allSatisfy!(isExposeSingle, Interfaces); }</code> </pre><br><br>  And examples of use: <br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CITest1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> a; <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meth1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meth2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CITest2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delegate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meth3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CITest3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meth1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meth1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meth2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;} <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> a; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delegate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meth3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;}; }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(isExpose!(Test1, CITest1, CITest2))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!isExpose!(Test1, CITest3))</span></span></span></span>;</code> </pre><br><br><h4>  Conclusion </h4><br>  Based on powerful metaprogramming, you can write handy DSL or templates that eliminate boilerplate code.  A perfect example of practical application of this approach is the compile-time parsers generator <a href="https://github.com/PhilippeSigaud/Pegged">pegged</a> . </div><p>Source: <a href="https://habr.com/ru/post/227015/">https://habr.com/ru/post/227015/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227001/index.html">User parameters and metrics in Universal Analytics</a></li>
<li><a href="../227003/index.html">Experiments with bit-reverse patterns in two-dimensional additive cellular automata</a></li>
<li><a href="../227009/index.html">Harley-Davidson Introduces LiveWire Electric Motorcycle</a></li>
<li><a href="../227011/index.html">3 reasons to steam in Startup Sauna</a></li>
<li><a href="../227013/index.html">Android 4.4.4 (KTU84P) became available for the Nexus line</a></li>
<li><a href="../227019/index.html">Working with false positives in PVS-Studio and CppCat</a></li>
<li><a href="../227021/index.html">Typical payment system API errors</a></li>
<li><a href="../227023/index.html">How we create the best service for the selection of credit cards in RuNet</a></li>
<li><a href="../227025/index.html">Show me an advertisement, I'm ready</a></li>
<li><a href="../227029/index.html">New Germany record: 50.6% of energy per day received from solar panels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>