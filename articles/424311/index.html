<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous business logic today</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In short: 


- Proof is already implemented in C ++ , JS and PHP , suitable for Java . 
- Faster than Coroutine and Promise, more features. 
- Does no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous business logic today</h1><div class="post__text post__text-html js-mediator-article"><p>  In short: </p><br><blockquote><ul><li>  Proof is already implemented in <strong>C ++</strong> , <strong>JS</strong> and <strong>PHP</strong> , suitable for <strong>Java</strong> . </li><li>  <strong>Faster</strong> than Coroutine and Promise, more features. </li><li>  Does not require the allocation of a separate software stack. </li><li>  Is friends with all the security and debugging tools. </li><li>  It works on any architecture and does not require special compiler flags. </li></ul><br></blockquote><a name="habracut"></a><br><hr><br><ul><li>  <a href="https://habr.com/ru/post/424311/">Look back</a> </li><li>  <a href="https://habr.com/ru/post/424311/">FutoIn AsyncSteps - alternative to coroutines</a> </li><li>  <a href="https://habr.com/ru/post/424311/">To numbers</a> </li></ul><br><h2 id="vzglyad-nazad">  Look back </h2><br><p>  At the dawn of the computer, there was a single control flow with I / O blocking.  Then interruptions of iron were added to it.  Now you can effectively use slow and unpredictable devices. </p><br><p>  With the increasing capabilities of iron and its low availability, there is a need to perform several tasks at the same time, which provided hardware support.  This is how isolated processes with abstracted from iron interruptions in the form of signals appeared. </p><br><p>  The next evolutionary stage was multithreading, which was implemented on the foundation of the same processes, but with shared access to memory and other resources.  This approach has its limitations and significant overhead for switching to a secure OS. </p><br><p>  To communicate between processes and even different machines, a Promise / Future abstraction was proposed 40+ years ago. </p><br><p>  User interfaces and the now ridiculous problem of 10K clients led to the heyday of Event Loop, Reactor and Proactor approaches, which are more event-oriented than clear, consistent business logic. </p><br><p>  Finally, we arrived at a modern coroutine (coroutine), which is essentially an emulation of threads on top of the abstractions described above with the corresponding technical limitations and deterministic transfer of control. </p><br><p>  For the transfer of events, results and exceptions all returned to the same concept of Promise / Future.  Some offices have decided to call a little differently - "Task". </p><br><p> Ultimately, everything was hidden in a beautiful <code>async/await</code> package, which requires support from the compiler or translator, depending on the technology. </p><br><h3 id="problemy-s-tekuschiy-situaciy-asinhronnoy-biznes-logiki">  Problems with current situations asynchronous business logic </h3><br><p>  Consider only coroutines and Promise, decorated with <code>async/await</code> , because  the existence of problems in older approaches confirms the evolution process itself. </p><br><p>  These two terms are not identical.  For example, in ECMAScript there are no coroutines, but there are syntactic facilitations for using <code>Promise</code> , which in turn only organizes work with the hell of callbacks (callback hell).  In fact, scripting engines like V8 go further and make special optimizations for pure <code>async/await</code> functions and calls. </p><br><p>  The experts' statements about <code>co_async/co_await</code> not included in C ++ 17 are <a href="https://habr.com/post/278267/">here on the resource</a> , but by the pressure of the software giant, coroutines can appear in the standard exactly in their form.  In the meantime, the traditional recognized solution is <a href="https://www.boost.org/doc/libs/1_68_0/libs/context/doc/html/index.html">Boost.Context</a> , <a href="https://www.boost.org/doc/libs/1_68_0/libs/coroutine2/doc/html/index.html">Boost.Fiber</a> and <a href="https://www.boost.org/doc/libs/1_68_0/libs/coroutine2/doc/html/index.html">Boost.Coroutine2</a> . </p><br><p>  In Java, there is still no <code>async/await</code> at the language level, but there are solutions like <a href="https://github.com/electronicarts/ea-async">EA Async</a> , which, like Boost.Context, need to be customized for each version of JVM and byte code. </p><br><p>  Go has its coroutines, but if you look carefully at the articles and bug reports of open projects, it turns out that everything is not so smooth.  Perhaps the loss of the coroutine interface as a managed entity is not the best idea. </p><br><h4 id="mnenie-avtora-soprogrammy-na-golom-zheleze-opasny">  Opinion of the author: coroutines on bare gland are dangerous </h4><br><p>  Personally, the author has very little against coroutines in dynamic languages, but he is extremely wary of any flirting with the machine code level stack. </p><br><p>  A few theses: </p><br><ol><li>  It is required to allocate a stack: <br><ul><li>  the stack on the heap has a number of flaws: problems of timely detection of overflow, damage by neighbors and other reliability / safety problems, </li><li>  a protected stack requires at least one page of physical memory, one conditional page, and additional overhead for each call to the <code>async</code> function: 4 + KB (minimum) + increased system limits, </li><li>  in the end, it may be that a significant part of the memory allocated for stacks is not used during the coroutine's idle time. </li></ul></li><li>  It is necessary to implement complex logic for saving, restoring and deleting the state of coroutines: <br><ul><li>  for each case of processor architecture (even models) and binary interface (ABI): <a href="https://github.com/boostorg/context/tree/develop/src/asm">an example</a> </li><li>  New or optional architecture features introduce potentially latent problems (for example, Intel TSX, ARM or MIPS co-processors), </li><li>  other potential problems due to proprietary systems proprietary documentation (Boost documentation refers to this). </li></ul></li><li>  Potential problems with dynamic analysis tools and security in general: <br><ul><li>  for example, integration with Valgrind is required due to the same skipping stacks, </li><li>  It's hard to speak for antiviruses, but they probably don't really like it using the example of problems with the JVM in the past, </li><li>  I am sure that new types of attacks will appear and vulnerabilities associated with the implementation of coroutines will be revealed. </li></ul></li></ol><br><h4 id="mnenie-avtora-generatory-i-yield-principialnoe-zlo">  Opinion of the author: generators and <code>yield</code> fundamental evil </h4><br><p>  This seemingly third-party topic is directly related to the concept of coroutines and the "continue" property. </p><br><p>  In short, for any collection there should be a full-fledged iterator.  Why create the problem of a truncated iterator generator is not clear.  For example, a case with <code>range()</code> in Python is more like an exclusive showcase than an excuse for technical complication. </p><br><p>  If the case of an infinite generator, then the logic of its implementation is elementary.  Why create additional technical difficulties to shove an infinite continuous cycle inside? </p><br><p>  The only efficient later appeared justification, which supporters of coroutines bring, is all kind of stream parsers with control inverting.  In fact, this is a narrow specialized case for solving single problems of the library level, and not the business logic of applications.  At the same time, there is an elegant, simple and more descriptive solution through finite automata.  The area of ‚Äã‚Äãthese technical problems is much smaller than the area of ‚Äã‚Äãbanal business logic. </p><br><p>  In fact, the solved problem turns out to be sucked from the finger and requires a relatively serious effort for initial implementation and long-term support.  To the extent that some projects may prohibit the use of computer-code coroutines, following the example of a ban on <code>goto</code> or the use of dynamic memory allocation in certain industries. </p><br><h4 id="mnenie-avtora-model-asyncawait-na-promise-iz-ecmascript-bolee-nadyozhna-no-trebuet-adaptacii">  Opinion of the author: <code>async/await</code> model on Promise from ECMAScript is more reliable, but requires adaptation </h4><br><p>  Unlike the continuing coroutines, in this model, pieces of code are secretly divided into uninterrupted blocks, decorated in the form of anonymous functions.  In C ++, this is not entirely appropriate due to the memory management features, for example: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Value = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcPromise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolved(value_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">()&gt; &amp;&amp;cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ somehow_call_later(cb); } Value value_; }; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([&amp;](SomeObject::value &amp;&amp;val){ return Promise([&amp;](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback(resolve, val); }); }); }</span></span></code> </pre> <br><p>  First, <code>some_obj</code> will be destroyed when exiting <code>example()</code> and before calling the lambda functions. </p><br><p>  Secondly, lambda functions with variable or reference capture are objects and secretly add copy / move, which can adversely affect performance with a large number of hooks and the need to allocate memory on the heap during type erasure in a regular <code>std::function</code> . </p><br><p>  Thirdly, the <code>Promise</code> interface itself is conceived on the concept of "promising" the result, rather than the consistent implementation of business logic. </p><br><p>  A schematic NOT optimal solution might look something like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalContext</span></span></span><span class="hljs-class"> {</span></span> SomeObject some_obj; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ctx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;LocalContext&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([ctx](SomeObject::Value &amp;&amp;val){ struct LocalContext2 { LocalContext2(std::shared_ptr&lt;LocalContext&gt; &amp;&amp;ctx, SomeObject::Value &amp;&amp;val) : ctx(ctx), val(val) {} std::shared_ptr&lt;LocalContext&gt; ctx; SomeObject::Value val; }; auto ctx2 = std::make_shared&lt;LocalContext2&gt;( std::move(ctx), std::forward&lt;SomeObject::Value&gt;(val) ); return Promise([ctx2](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ ctx2-&gt;ctx-&gt;some_obj.funcCallback([ctx2, resolve](){ resolve(); }, val); }); }); }</span></span></code> </pre> <br><p>  <em>Note: <code>std::move</code> instead of <code>std::shared_ptr</code> not suitable due to the impossibility of transferring to several lambdds at once and their size increasing.</em> </p><br><p>  With the addition of <code>async/await</code> asynchronous "horrors" come in a digestible state: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { SomeObject::Value val = await some_obj.func(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) ( <span class="hljs-comment"><span class="hljs-comment">// ... } // Capture "async context" return Promise([async](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback([async](){ resolve(); }, val); }); }</span></span></code> </pre> <br><h4 id="mnenie-avtora-planirovschik-soprogramm---eto-perebor">  Opinion of the author: the coroner planner is a bust </h4><br><p>  Some critics call the lack of a scheduler problem and the "dishonest" use of processor resources.  Perhaps a more serious problem is data locality and efficient use of the processor cache. </p><br><p>  On the first problem: prioritization at the level of individual coroutines looks like a big overhead.  Instead, they can be operated in common for a particular unified task.  So come with traffic flows. </p><br><p>  This is possible by creating separate instances of the Event Loop with its own ‚Äúiron‚Äù streams and planning at the OS level.  The second option is to synchronize the coroutines with respect to the primitive (Mutex, Throttle) that limits the competition and / or performance. </p><br><p>  Asynchronous programming does not make the processor resources rubber and requires absolutely normal restrictions on the number of simultaneously processed tasks and the limit on the total execution time. </p><br><p>  Protection against long-term blocking on one coroutine requires the same measures as with callbacks ‚Äî to avoid blocking system calls and long data processing cycles. </p><br><p>  The second problem requires research, but at a minimum the coroutine stacks themselves and the details of the Future / Promise implementation already violate the data locality.  It is possible to try to continue the execution of the same coroutine if Future already matters.  It requires some mechanism for counting the runtime or the number of such continuations to prevent one coroutine from capturing the entire processor time.  This may either not give a result, or give a very double result depending on the size of the processor cache and the number of threads. </p><br><p>  There is also a third point - many implementations of coroutine planners allow you to run them on different processor cores, which, on the contrary, adds problems due to the mandatory synchronization when accessing shared resources.  In the case of a single Event Loop stream, such synchronization is required only at the logic level, since  Each synchronous callback unit is guaranteed to work without a race with others. </p><br><h4 id="mnenie-avtora-vsyo-horosho-v-meru">  Opinion of the author: everything is good in moderation </h4><br><p>  The presence of threads in modern operating systems does not negate the use of separate processes.  Also, processing a large number of clients in the Event Loop does not cancel the use of separate "iron" streams for other needs. </p><br><p>  In any case, coroutines and various variants of Event Loops complicate the debugging process without the necessary support in the tools, and with local variables on the coroutine stack, everything becomes even more difficult - they can hardly be reached. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2p/pp/lb/2ppplbzrvm8c0yvbasdwrojknss.png" width="326" height="326"></div><br><h2 id="futoin-asyncsteps---alternativa-soprogrammam">  FutoIn AsyncSteps - alternative to coroutines </h2><br><p>  We take as a basis the already well-established Event Loop pattern and the organization of the ECMAScript (JavaScript) Promise callback scheme. </p><br><p>  From the point of view of planning the execution, we are interested in the following actions from the Event Loop: </p><br><ol><li>  Immediate callback <code>Handle immediate(callack)</code> with the requirement of a clean call stack. </li><li>  Deferred callback <code>Handle deferred(delay, callback)</code> . </li><li>  Cancel callback <code>handle.cancel()</code> . </li></ol><br><p>  So we get an interface called <code>AsyncTool</code> , which can be implemented in a variety of ways, including over existing proven developments.  He has no direct relation to writing business logic, so we will not go into further details. </p><br><h3 id="derevo-shagov">  Step tree: </h3><br><p>  In the concept of AsyncSteps, an abstract tree of synchronous steps is built and is executed by a depth passage in the creation sequence.  The steps of each deeper level are dynamically set as such a passage is completed. </p><br><p>  All interaction takes place through a single interface <code>AsyncSteps</code> , which is conventionally passed as the first parameter in each step.  According to the convention, the name of the parameter is <code>asi</code> or obsolete <code>as</code> .  Such an approach makes it possible to almost completely break the link between a specific implementation and the writing of business logic in plug-ins and libraries. </p><br><p>  In canonical implementations, each step receives its own copy of an object that implements <code>AsyncSteps</code> , which allows timely tracking of logical errors in the use of the interface. </p><br><p>  Abstract example: </p><br><pre> <code class="hljs lua"> asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func"</span></span> ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func"</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) } ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { asi.success( <span class="hljs-string"><span class="hljs-string">"Prm"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } } ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> func( asi, str_param, int_param, array_param ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func2: "</span></span> + param ) } )</code> </pre> <br><p>  Result of performance: </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: MyError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: NewError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">2</span></span>: Prm</code> </pre> <br><p>  In synchronous form it would look like this: </p><br><pre> <code class="hljs coffeescript"> str_res, int_res, array_res, bool_res <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( error strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { str_res = <span class="hljs-string"><span class="hljs-string">"Prm"</span></span> int_res = <span class="hljs-number"><span class="hljs-number">123</span></span> array_res = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] bool_res = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { re-<span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> } } { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 2: "</span></span> + str_res ) }</code> </pre> <br><p>  Immediately visible is the maximum mimicry of the traditional synchronous code, which should help in readability. </p><br><p>  From the point of view of business logic, a <a href="https://specs.futoin.org/final/preview/ftn12_async_api.html">large number of requirements are</a> growing over time, but we can divide it into easily understood parts.  Described below, the result of running in practice for four years. </p><br><h3 id="bazovye-api-vremeni-vypolneniya">  Base Runtime APIs: </h3><br><ol><li>  <code>add(func[, onerror])</code> is an imitation of <code>try-catch</code> . </li><li>  <code>success([args...])</code> is an explicit indication of successful completion: <br><ul><li>  implied by default </li><li>  can transfer the results to the next step. </li></ul></li><li>  <code>error(code[, reason)</code> - interrupt execution with an error: <br><ul><li>  <code>code</code> - has a string type to better integrate with network protocols in the microservice architecture, </li><li>  <code>reason</code> is an arbitrary explanation for a person. </li></ul></li><li>  <code>state()</code> is an analogue of Thread Local Storage.  Predefined associative keys: <br><ul><li>  <code>error_info</code> - an explanation of the last error for a person </li><li>  <code>last_exception</code> - a pointer to the object of the last exception, </li><li>  <code>async_stack</code> - how many asynchronous calls the technology allows, </li><li>  the rest is set by the user. </li></ul></li></ol><br><p>  The previous example already has real C ++ code and some additional features: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/iasyncsteps.hpp&gt; using namespace futoin; void some_api(IAsyncSteps&amp; asi) { asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 0 func 1" &lt;&lt; std::endl; asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 1 func 1" &lt;&lt; std::endl; asi.error("MyError"); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 1 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; asi.error("NewError", "Human-readable description"); } ); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 0 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; if (code == "NewError") { // Human-readable error info assert(asi.state().error_info == "Human-readable description"); // Last exception thrown is also available in state std::exception_ptr e = asi.state().last_exception; // NOTE: smart conversion of "const char*" asi.success("Prm", 123, std::vector&lt;int&gt;({1, 2, 3}, true)); } } ); asi.add( [](IAsyncSteps&amp; asi, const futoin::string&amp; str_res, int int_res, std::vector&lt;int&gt;&amp;&amp; arr_res) { std::cout &lt;&lt; "Level 0 func 2: " &lt;&lt; str_res &lt;&lt; std::endl; } ); }</span></span></span></span></code> </pre> <br><h3 id="api-dlya-sozdaniya-ciklov">  API for creating loops: </h3><br><ol><li>  <code>loop( func, [, label] )</code> is a step with an infinitely repeated body. </li><li>  <code>forEach( map|list, func [, label] )</code> - iteration step through the collection object. </li><li>  <code>repeat( count, func [, label] )</code> - step iteration the specified number of times. </li><li>  <code>break( [label] )</code> - analogue of the traditional cycle interruption. </li><li>  <code>continue( [label] )</code> is an analogue of the traditional loop continuation with a new iteration. </li></ol><br><p>  <em>The specification suggests alternative names for <code>breakLoop</code> , <code>continueLoop</code> and others in the event of a conflict with reserved words.</em> </p><br><p>  C ++ Example: </p><br><pre> <code class="cpp hljs"> asi.loop([](IAsyncSteps&amp; asi) { <span class="hljs-comment"><span class="hljs-comment">// infinite loop asi.breakLoop(); }); asi.repeat(10, [](IAsyncSteps&amp; asi, size_t i) { // range loop from i=0 till i=9 (inclusive) asi.continueLoop(); }); asi.forEach( std::vector&lt;int&gt;{1, 2, 3}, [](IAsyncSteps&amp; asi, size_t i, int v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::list&lt;futoin::string&gt;{"1", "2", "3"}, [](IAsyncSteps&amp; asi, size_t i, const futoin::string&amp; v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::map&lt;futoin::string, futoin::string&gt;(), [](IAsyncSteps&amp; asi, const futoin::string&amp; key, const futoin::string&amp; v) { // Iteration of map-like objects }); std::map&lt;std::string, futoin::string&gt; non_const_map; asi.forEach( non_const_map, [](IAsyncSteps&amp; asi, const std::string&amp; key, futoin::string&amp; v) { // Iteration of map-like objects, note the value reference type });</span></span></code> </pre> <br><h3 id="api-integracii-s-vneshnimi-sobytiyami">  API for integration with external events: </h3><br><ol><li>  <code>setTimeout( timeout_ms )</code> - causes a <code>setTimeout( timeout_ms )</code> error when the time has elapsed if the step and its subtree have not completed execution. </li><li>  <code>setCancel( handler )</code> - sets a cancel handler that is called when a general thread is canceled and the asynchronous steps stack expands during error handling. </li><li>  <code>waitExternal()</code> is a simple wait for an external event. <br><ul><li>  <em>Note: it is safe to use only in technologies with the garbage collector.</em> </li></ul></li></ol><br><p>  Calling any of these functions necessitates an explicit call to <code>success()</code> . </p><br><p>  C ++ Example: </p><br><pre> <code class="cpp hljs"> asi.add([](IAsyncSteps&amp; asi) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = schedule_external_callback([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { asi.error(<span class="hljs-string"><span class="hljs-string">"ExternalError"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">// pass } } else { asi.success(); } }); asi.setCancel([=](IAsyncSteps&amp; asi) { external_cancel(handle); }); }); asi.add( [](IAsyncSteps&amp; asi) { // Raises Timeout error after specified period asi.setTimeout(std::chrono::seconds{10}); asi.loop([](IAsyncSteps&amp; asi) { // infinite loop }); }, [](IAsyncSteps&amp; asi, ErrorCode code) { if (code == futoin::errors::Timeout) { asi(); } });</span></span></code> </pre> <br><p>  ECMAScript example: </p><br><pre> <code class="javascript hljs">asi.add( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">asi</span></span></span><span class="hljs-function">) =&gt;</span></span> { asi.waitExternal(); <span class="hljs-comment"><span class="hljs-comment">// disable implicit success() some_obj.read( (err, data) =&gt; { if (!asi.state) { // ignore as AsyncSteps execution got canceled } else if (err) { try { asi.error( 'IOError', err ); } catch (_) { // ignore error thrown as there are no // AsyncSteps frames on stack. } } else { asi.success( data ); } } ); } );</span></span></code> </pre> <br><h3 id="api-integracii-s-futurepromise">  Future / Promise integration API: </h3><br><ol><li>  <code>await(promise_future[, on_error])</code> - waiting for Future / Promise as a step. </li><li>  <code>promise()</code> - turns the entire execution thread into Future / Promise, used instead of <code>execute()</code> . </li></ol><br><p>  C ++ Example: </p><br><pre> <code class="hljs pgsql"> [](IAsyncSteps&amp; asi) { // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AsyncSteps instances // <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> hard dependency <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> implementation. auto new_steps = asi.newInstance(); new_steps-&gt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([](IAsyncSteps&amp; asi) {}); // Can be <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> outside <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AsyncSteps event <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> // new_steps.promise().wait(); // <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> // new_steps.promise&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> standard std::future asi.await(new_steps-&gt;promise()); // Ensure instance lifetime asi.state()["some_obj"] = std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(new_steps); };</code> </pre> <br><h3 id="api-kontrolya-potoka-vypolneniya-biznes-logiki">  Business Logic Flow Control API: </h3><br><ol><li>  <code>AsyncSteps(AsyncTool&amp;)</code> is a constructor that binds a thread of execution to a specific Event Loop. </li><li>  <code>execute()</code> - starts the execution thread. </li><li>  <code>cancel()</code> - cancels the thread of execution. </li></ol><br><p>  It already requires a specific implementation of the interface. </p><br><p>  C ++ Example: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/asyncsteps.hpp&gt; #include &lt;futoin/ri/asynctool.hpp&gt; void example() { futoin::ri::AsyncTool at; futoin::ri::AsyncSteps asi{at}; asi.loop([&amp;](futoin::IAsyncSteps &amp;asi){ // Some infinite loop logic }); asi.execute(); std::this_thread::sleep_for(std::chrono::seconds{10}); asi.cancel(); // called in d-tor by fact }</span></span></span></span></code> </pre> <br><h3 id="prochie-api">  other APIs: </h3><br><ol><li>  <code>newInstance()</code> - allows you to create a new thread of execution without direct dependence on the implementation. </li><li>  <code>sync(object, func, onerror)</code> - the same, but with synchronization relative to the object that implements the corresponding interface. </li><li>  <code>parallel([on_error])</code> is a special <code>add()</code> whose substeps are separate AsyncSteps streams: <br><ul><li>  all threads have a common <code>state()</code> , </li><li>  the parent thread continues to execute upon completion of all children, </li><li>  an uncaught error in any child immediately cancels all other child threads. </li></ul></li></ol><br><p>  C ++ Examples: </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/mutex.hpp&gt; using namespace futoin; ri::Mutex mtx_a; void sync_example(IAsyncSteps&amp; asi) { asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { // synchronized section asi.add([](IAsyncSteps&amp; asi) { // inner step in the section // This synchronization is NOOP for already // acquired Mutex. asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { }); }); }); } void parallel_example(IAsyncSteps&amp; asi) { using OrderVector = std::vector&lt;int&gt;; asi.state("order", OrderVector{}); auto&amp; p = asi.parallel([](IAsyncSteps&amp; asi, ErrorCode) { // Overall error handler asi.success(); }); p.add([](IAsyncSteps&amp; asi) { // regular flow asi.state&lt;OrderVector&gt;("order").push_back(1); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(4); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(2); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(5); asi.error("SomeError"); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(3); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(6); }); }); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order"); // 1, 2, 3, 4, 5 }); };</span></span></span></span></code> </pre> <br><h3 id="standartnye-primitivy-dlya-sinhronizacii">  Standard synchronization primitives </h3><br><ol><li>  <code>Mutex</code> - restricts simultaneous execution in <code>N</code> streams with a queue in <code>Q</code> , the default is <code>N=1, Q=unlimited</code> . </li><li>  <code>Throttle</code> - limits the number of inputs <code>N</code> in the period <code>P</code> with a queue in <code>Q</code> , the default is <code>N=1, P=1s, Q=0</code> . </li><li>  <code>Limiter</code> is a combination of <code>Mutex</code> and <code>Throttle</code> , which is typically used at the input of processing external requests and when calling external systems in order to work stably under load. </li></ol><br><p>  In case of <code>DefenseRejected</code> queue limits, the <code>DefenseRejected</code> error is <code>DefenseRejected</code> , the meaning of which is clear from the description of <code>Limiter</code> . </p><br><h3 id="klyuchevye-preimuschestva">  Key benefits </h3><br><p>  The concept of AsyncSteps was not an end in itself, but was born due to the need for more controlled asynchronous program execution in terms of time limit, cancellation and overall coherence of individual callbacks.  None of the universal solutions at the time and now does not provide the same functionality.  Therefore: </p><br><p> <strong> <a href="https://specs.futoin.org/final/preview/ftn12_async_api.html"> FTN12</a>   </strong> ‚Äî           . </p><br><p> <strong>  <code>setCancel()</code></strong> ‚Äî                    .       ,     .   RAII  <code>atexit()</code>   . </p><br><p> <strong>   <code>cancel()</code></strong> ‚Äî     ,         .   <code>SIGTERM</code>  <code>pthread_cancel()</code> ,       . </p><br><p> <strong>   <code>setTimeout()</code></strong> ‚Äî                 .    ,    "Timeout". </p><br><p> <strong>     </strong> ‚Äî  FutoIn AsyncSteps             . </p><br><p> <strong>      </strong> ‚Äî          ABI     ,    .    Embedded     MMU. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8x/wv/yj8xwvibm7tjsj30qhojwbleige.jpeg"></div><br><p> <a href="https://unsplash.com/%40chuttersnap%3Futm_medium%3Dreferral%26utm_campaign%3Dphotographer-credit%26utm_content%3DcreditBadge"><em> </em></a> </p><br><h2 id="k-cifram">   </h2><br><p>    Intel Xeon E3-1245v2/DDR1333  Debian Stretch    . </p><br><p>   : </p><br><ol><li> Boost.Fiber  <code>protected_fixedsize_stack</code> . </li><li> Boost.Fiber  <code>pooled_fixedsize_stack</code>     . </li><li> FutoIn AsyncSteps   . </li><li> FutoIn AsyncSteps      ( <code>FUTOIN_USE_MEMPOOL=false</code> ). <br><ul><li>      <code>futoin::IMemPool</code> . </li></ul></li><li> FutoIn NitroSteps&lt;&gt; ‚Äî           . <br><ul><li>         . </li></ul></li></ol><br><p>    Boost.Fiber    : </p><br><ol><li>     1 . . </li><li>       30 .   1 . . <br><ul><li>   30 .     <code>mmap()/mprotect()</code>  <code>boost::fiber::protected_fixedsize_stack</code> . </li><li>          . </li></ul></li><li>   30 .   10 .     . <br><ul><li>    ""          . </li></ul></li></ol><br><p>      "" , ..     ,       .        .   . </p><br><p>    GCC 6.3.0.   lang  tcmalloc  ,     . </p><br><p>      <a href="https://github.com/futoin/core-cpp-ri-asyncsteps/tree/v1.3.0/bench">GitHub</a>  <a href="https://gitlab.com/futoin/core/cpp/ri-asyncsteps/tree/v1.3.0/bench">GitLab</a> . </p><br><h3 id="1-posledovatelnoe-sozdanie"> 1.   </h3><br><table><thead><tr><th>  Technology </th><th>  Time </th><th>  Hz </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 4.8s </td><td> 208333.333Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 0.23s </td><td> 4347826.086Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>0.21s</strong> </td><td> <strong>4761904.761Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 0.31s </td><td> 3225806.451Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 0.255s </td><td> 3921568.627Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qm/ur/y6/qmury65-mbkth_om8smkfi7vamq.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>     Boost.Fiber -      ,     <code>pooled_fixedsize_stack</code>   ,    AsyncSteps. </p><br><h3 id="2-parallelnoe-sozdanie-i-ispolnenie"> 2.     </h3><br><table><thead><tr><th>  Technology </th><th>  Time </th><th>  Hz </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 6.31s </td><td> 158478.605Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 1.558s </td><td> 641848.523Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1.13s</strong> </td><td> <strong>884955.752Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 1.353s </td><td> 739098.300Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 1.43s </td><td> 699300.699Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0s/gz/lu/0sgzlur2xsrlf-wo4mrcynvzhxi.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>    ,          .    ,        ‚Äî            . </p><br><h3 id="3-parallelnye-cikly"> 3.   </h3><br><table><thead><tr><th>  Technology </th><th>  Time </th><th>  Hz </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 5.096s </td><td> 1962323.390Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 5.077s </td><td> 1969667.126Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> 5.361s </td><td> 1865323.633Hz </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 8.288s </td><td> 1206563.706Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> <strong>3.68s</strong> </td><td> <strong>2717391.304Hz</strong> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/c1/17/pbc117djqds0d4twh5fzcklsmfc.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>   ,        Boost.Fiber      AsyncSteps,    NitroSteps. </p><br><h3 id="ispolzovanie-pamyati-po-rss">   ( RSS) </h3><br><table><thead><tr><th>  Technology </th><th>  Memory </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 124M </td></tr><tr><td> Boost.Fiber pooled </td><td> 505M </td></tr><tr><td> FutoIn AsyncSteps </td><td> 124M </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> <strong>84M</strong> </td></tr><tr><td> FutoIn NitroSteps </td><td> 115M </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/w0/6n/olw06nef5wj3ah1lo9u-pby9sfg.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>  , Boost.Fiber  . </p><br><h3 id="bonus-testy-na-nodejs"> :   Node.js </h3><br><p>      -  <code>Promise</code> : +    10 . .   10 .          JIT  <code>NODE_ENV=production</code> ,   <a href="https://www.npmjs.com/package/%40futoin/optihelp"><code>@futoin/optihelp</code></a> . </p><br><p>      <a href="">GitHub</a>  <a href="">GitLab</a> .   Node.js v8.12.0  v10.11.0,   <a href="https://futoin.org/docs/cid/">FutoIn CID</a> . </p><br><table><thead><tr><th> Tech </th><th> Simple </th><th> Loop </th></tr></thead><tbody><tr><td> <strong>Node.js v10</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1342899.520Hz</strong> </td><td> 587.777Hz </td></tr><tr><td> async/await </td><td> 524983.234Hz </td><td> <strong>630.863Hz</strong> </td></tr><tr><td> <strong>Node.js v8</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>682420.735Hz</strong> </td><td> <strong>588.336Hz</strong> </td></tr><tr><td> async/await </td><td> 365050.395Hz </td><td> 400.575Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x7/-n/b5/x7-nb5v9dfkwn1lttyg67w2b_tk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/yj/9p/ghyj9pczw0smbfksq-aad_tltay.png"></div><br><p> <em> ‚Äî .</em> </p><br><p>   <code>async/await</code> ? ,   V8  Node.js v10       . </p><br><p>  ,   Promise  <code>async/await</code> <strong></strong> Node.js Event Loop.          ( <a href="https://gist.github.com/andvgal/14e745405c3cb7d14bd91ab0530ce8ca"></a> ),   FutoIn AsyncSteps   . </p><br><p> <em>   AsyncSteps  Node.js Event Loop      <code>async/await</code>  -  Node.js v10.</em> </p><br><p> <em>,      ++   ‚Äî    .  ,    Node.js    10 .</em> </p><br><h3 id="vyvody">  findings </h3><br><p>   C++, FutoIn AsyncSteps  Boost.Fiber       ,     Boost.Fiber         <code>mmap()/mprotect</code> . </p><br><p>       ,      -      ,   .     . </p><br><p> FutoIn AsyncSteps  JavaScript  <code>async/await</code>       Node.js v10. </p><br><p>   ,       -,       .        . </p><br><p>   -                        ""  .     ‚Äî   API. </p><br><hr><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p> ,  FutoIn AsyncSteps ,          "" <code>async/await</code> . ,         .      <code>Promise</code>  ECMAScript, AsyncSteps    ""           . </p><br><p>               .        AsyncSteps  NitroSteps   . </p><br><p>     <a href="https://specs.futoin.org/final/preview/ftn12_async_api.html"></a> ,    - <a href="https://futoin.org/docs/asyncsteps/"></a> . </p><br><p>       Java/JVM         ‚Äî    .    . </p><br><p>      ,       <a href="https://github.com/futoin%3Fq%3Dcore-cpp">GitHub</a> / <a href="https://gitlab.com/futoin/core/cpp">GitLab</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/424311/">https://habr.com/ru/post/424311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424297/index.html">MIT course "Computer Systems Security". Lecture 9: "Web Application Security", part 3</a></li>
<li><a href="../424301/index.html">Adaptive Neural Network Image Filter Algorithm</a></li>
<li><a href="../424305/index.html">Uber Cross-Platform Mobile Architecture RIBs</a></li>
<li><a href="../424307/index.html">GitLab 11.3 Released with Maven and Secure environments Repository</a></li>
<li><a href="../424309/index.html">DevCore: DevBoy software part</a></li>
<li><a href="../424313/index.html">EveryLang is a program that can do almost anything.</a></li>
<li><a href="../424315/index.html">New round of import substitution. Where to run and what to do?</a></li>
<li><a href="../424319/index.html">The structure of the online store. Part 2</a></li>
<li><a href="../424321/index.html">We collect NetFlow cheaply and angrily</a></li>
<li><a href="../424323/index.html">An example of working with the ICE method from a Google and Microsoft product manager</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>