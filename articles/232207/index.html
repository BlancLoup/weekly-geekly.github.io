<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We get system privileges using errors in NTVDM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Backward compatibility is a good thing, but it must be used reasonably. After all, you can still find code developed in the last century in the Window...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We get system privileges using errors in NTVDM</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/27e/bfb/bb5/27ebfbbb5c4a40419a5265d3673b89a1.jpg"><br><br>  <i>Backward compatibility is a good thing, but it must be used reasonably.</i>  <i>After all, you can still find code developed in the last century in the Windows kernel.</i>  <i>Talking about his high security would be stupid.</i>  <i>And we will prove it by the example of the three privilage escalation of vulnerabilities, rooted in the subsystem of the DOS virtual machine.</i> <br><br>  In 1978, Intel released the first x86 processor, the 8086, which provided a fairly limited environment for executing 16-bit code, known as Real mode.  Soon after, active development of software solutions began for the new hardware platform, both operating systems and the usual programs working in them.  Microsoft's Disk Operating System (DOS) has quickly established itself as the leading desktop environment for desktop PCs, and applications for this OS have been created and entered the market for more than ten years.  The most famous examples are Norton Commander, ChiWriter or Quattro Pro.  When developing in 1992 the NT architecture for the Windows operating system, which took advantage of the already more powerful and secure protected mode (Protected Mode), one of the key decisions was to maintain backward compatibility with DOS, that is, to ensure the possibility of safe launch of old programs in the new graphical environment . <br><a name="habracut"></a><br><blockquote><h5>  WARNING </h5><br>  All information is provided for informational purposes only.  Neither the editors nor the author are responsible for any possible harm caused by the materials of this article. <br></blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  NTVDM </h3><br>  The special compatibility mode created in Windows turned out to be very functional.  Due to the fact that it was a rather complex component both from the technical side and from the logic of work, its appearance opened up many new opportunities for local users to launch attacks aimed at enhancing their rights in the operating system.  NTVDM has already found and corrected security problems more than once, but there are still many interesting and unexplored features in the kernel.  In the next section, we will look at one of them in detail - the specific handling of exceptions that occur in the NTVDM.EXE host process.  Here, however, it is worth noting that any potential bug that may be found in the DOS compatibility subsystem will affect only 32-bit Windows platforms, since 64-bit versions of the system do not support VDM due to the implementation features of the Long Mode mode, in which 64-bit code on Intel processors.  In the new Windows 8 and 8.1 operating systems, the impact of potential kernel vulnerabilities is leveled by the fact that this subsystem is disabled by default and administrative rights are required to run it.  Nevertheless, these vulnerabilities can be successfully exploited without user involvement on systems from Windows XP to Windows 7 32-bit (and at the moment such systems presumably account for about 50% of the park of all desktop operating systems). <br><br><h3>  Real time </h3><br>  From the technical point of view, it is very difficult to maintain backward compatibility with 16-bit applications for modern 32-bit environments because of the fundamental differences in the operation between real and protected mode.  This includes the modes of the processor, the width of words and addresses, and the coding of instructions, and many other points.  In other words, standard tools of modern operating systems can not run outdated programs from the 80s.  On the other hand, switching the processor to real mode each time you start a 16-bit program is also not an option, since this deprives the basic settings of the protected mode, such as rights sharing.  Transferring control to a potentially untrusted code that runs in a virtually unlimited runtime environment and has direct access to all computer peripherals not only poses a potential security threat to the system, but also deprives the operating system of control over the computer, since the decision to return to the previous working context will be made it is this old application. <br><br><h3>  Virtual 8086 mode </h3><br>  Intel engineers, who perfectly understood these and many other problems related to backward compatibility, developed another completely new execution mode, calling it Virtual 8086 (V8086), which has become an important part of the protected mode.  The main feature of the V8086 mode is that for the code running in it, it is completely indistinguishable from the real mode, but is completely controlled by the main operating system.  This allows you to run old applications in a 32-bit environment while maintaining security and without negative side effects.  This technology can be considered as a virtualization mechanism for DOS software, in which the operating system plays the role of a virtual machine monitor (Virtual Machine Monitor - VMM).  VMM is responsible for creating the working environment and handling the critical and privileged instructions that the guest application uses, while the 16-bit code is executed in a special mode and at native speed.  A typical Intel-developed order of execution for an operating system using the V8086 is shown in Figure.  one. <br><br><img src="https://habrastorage.org/files/b0d/02e/b35/b0d02eb35eeb47a5bf293bb282c29279.jpg"><br>  Fig.  1. Transferring control of the operating system when running legacy 16-bit applications <br><br>  In the case of Microsoft Windows, the ‚Äúoperating system‚Äù entity further splits into two components: the kernel and the user-level process NTVDM.EXE.  Support for the described subsystem is available at both levels - some events occurring inside obsolete software are handled directly by the core, while others need some help at the ring 3 level (see Figure 2).  Due to the fact that the execution of the code of the old software is isolated in a special process, the kernel can easily determine whether a specific processor event needs separate processing, depending on whether it comes from the VDM host or not.  As a result, most ring 0 level procedures provide additional functionality when calling them from special processes;  As one of the vivid examples, you can mention the trap handlers for x86 (such as nt! KiTrap0c, nt! KiTrap0d, nt! KiTrap0e), NT system calls (for example, nt! NtVdmControl) and win32k.sys system calls ( for example, nt! NtUserInitTask).  It is important to note that, although the NTVDM.EXE process is handled by the system in a special way, it still inherits the local user security token;  This, in turn, allows an attacker to execute arbitrary code within the process, using only two documented API functions ‚Äî OpenProcess and CreateRemoteThread ‚Äî to exploit the hypothetical vulnerability in those parts of the kernel that are responsible for supporting VDM. <br><br><img src="https://habrastorage.org/files/e8e/29e/737/e8e29e737a234bf6868e19a140a072fa.jpg"><br><br>  Fig.  2. Example of execution execution execution time for outdated 16-bit applications in Microsoft Windows <br><br><h3>  DPMI </h3><br>  Finally, we must not forget that NTVDM supports most DOS Protected Mode Interface (DPMI) interface specifications, that is, in addition to implementing Virtual 8086, it can also provide a runtime environment (for example, create memory segments) and execute code protected mode.  Consequently, there may well be code with support for processing 32-bit instructions in the kernel in addition to simple 16-bit emulation. <br><br><h3>  CVE-2013-3196 (write-what-where in nt! PushInt) </h3><br><h4>  General Protection Fault </h4><br>  One of the most important features of Virtual 8086 mode, as well as the working environment created by NTVDM.EXE for executing obsolete 32-bit code with DPMI support, is that any attempt to perform a critical or elevated instruction (such as INT, OUT or STI) will immediately lead to the exclusion of the General Protection Fault in the kernel.  As noted above, after this the operating system must safely emulate the operation of the instruction and return to the execution of the interrupted guest code, ensuring that the execution continues.  As it turned out, the instruction emulation code for the 16-bit and 32-bit emulation modes is completely in the kernel space, which opens up interesting possibilities for an attack: programmatically reproduce the behavior of special x86 instructions.  In order to get into the emulator, the following conditions must be met: <br><ol><li> The <code>#GP</code> exception occurs inside Virtual 8086 mode (the EFlags.VM flag is set) <b>OR The</b> #GP exception occurs in user mode (ring 3) and </li><li>  The cs: segment selector is not equal to <code>KGDT_R3_CODE (0x1b)</code> at the time of the exception and </li><li>  The #GP exception occurs in the VDM host process. </li></ol><br><br><img src="https://habrastorage.org/files/085/b1e/0d1/085b1e0d1171433cbe7bd8060af292de.jpg"><br><br>  Fig.  3. Virtual 8086 instruction dispatch table used by the #GP handler <br><br>  If any of the options is fully implemented, the #GP handler passes control to the internal procedure <code>nt!VdmDispatchOpcode_try</code> , which performs basic decoding of the failed instruction and calls one or more handler functions applicable to this instruction.  Handler lists for emulation modes of 16 and 32 bits are shown in Fig.  3 and 4;  as you can see, the kernel issues a very long list of instructions and their prefixes.  In our opinion, until this year, this part of the code, most likely, had never before been checked for the presence of vulnerabilities, which made it a serious target for research.  After this ‚Äúdiscovery‚Äù we decided to carry out reverse engineering of all the handlers in search of potential flaws and got the first results in the next few hours.  The first vulnerability was in the INT instruction emulation layer for protected mode. <br><br><img src="https://habrastorage.org/files/5c4/a6f/b72/5c4a6fb7218c49779d1c2048c6cf2a83.jpg"><br><br>  Fig.  4. The table of dispatching protected-mode instructions used by the #GP processor <br><br><br><h3>  Where is the dog buried </h3><br>  The basic role of the nt! OpcodeINTnn handler function is that it extracts the imm8 operand of the instruction that caused the crash, and then calls another internal procedure nt! PushInt.  Its main task is to get the base address of the user ss: segment and put the address of the system interrupt handler on the stack (in the user address space) using the full address of the ss: esp stack pointer.  The C-code obtained by reverse engineering, responsible for placing three 16-bit or 32-bit words on the stack (depending on the guest execution mode), is shown below. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reginfo-&gt;ViFlags &amp; VDM_INT_32) { *(DWORD *)(reginfo-&gt;RiSsBase + NewVdmEsp + <span class="hljs-number"><span class="hljs-number">0</span></span>) = reginfo-&gt;RiEip; *(DWORD *)(reginfo-&gt;RiSsBase + NewVdmEsp + <span class="hljs-number"><span class="hljs-number">4</span></span>) = trap_frame-&gt;SegCs; *(DWORD *)(reginfo-&gt;RiSsBase + NewVdmEsp + <span class="hljs-number"><span class="hljs-number">8</span></span>) = GetVirtualBits(reginfo-&gt;RiEFlags); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *(WORD *)(reginfo-&gt;RiSsBase + NewVdmEsp + <span class="hljs-number"><span class="hljs-number">0</span></span>) = reginfo-&gt;RiEip; *(WORD *)(reginfo-&gt;RiSsBase + NewVdmEsp + <span class="hljs-number"><span class="hljs-number">2</span></span>) = trap_frame-&gt;SegCs; *(WORD *)(reginfo-&gt;RiSsBase + NewVdmEsp + <span class="hljs-number"><span class="hljs-number">4</span></span>) = GetVirtualBits(reginfo-&gt;RiEFlags); }</code> </pre><br><br>  The problem with the implementation was that the pointer to the user space stack (ring 3) is not checked for correctness in any way, probably due to the assumption that it will always point to the address space of the NTVDM.EXE process.  And this, of course, is not always the case, since the exploit can set the esp register to any arbitrary pointer, for example, to an address relative to the kernel.  Thus, to enable the vulnerability, it was enough to execute only two simple instructions in the context of a DOS virtual machine: <code>mov esp, 0xdeadbeef</code> and then <code>int 0</code> .  The only limitations were that both <code>cs:</code> and <code>ss:</code> should select code and data segments within the local descriptor table (LDT), and the argument of the int instruction should be a kernel level interrupt (any value between 0‚Äì 255, except for the sequence 0x2a ‚Äì 0x2e).  The result of running the two described instructions on unpatched Windows 7 SP1 is shown below: <br><br><pre> <code class="bash hljs">TRAP_FRAME: a2ea4c24 -- (.<span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> 0xffffffffa2ea4c24) ErrCode = 00000002 eax=024ef568 ebx=00000000 ecx=00000000 edx=6710140f esi=a2ea4cb8 edi=deadbee3 eip=82ab21a7 esp=a2ea4c98 ebp=a2ea4d34 iopl=0 nv up ei pl nz na po nc cs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010202 nt!PushInt+0xa5: 82ab21a7 89143b mov dword ptr [ebx+edi],edx ds:0023:deadbee3=???????? Resetting default scope</code> </pre><br>  Due to the fact that one of the 32-bit variables is stored by the kernel in a randomly selected eip exception, the situation turns into a simple write-what-where condition with minor restrictions that can be ignored (for example, that the immediate value cannot have the leading bit set).  Having such a convenient basic feature at its disposal, it becomes possible to ‚Äúhijack‚Äù the control flow of the kernel by rewriting one of the function pointers, for example, the well-known pointer nt! HalDispatchTable + 4, called from user space via the nt! NtQueryIntervalProfile system call. <br><br><img src="https://habrastorage.org/files/4a5/652/e5a/4a5652e5a4c94e71ace235e3faa866d8.jpg"><br><br>  Fig.  5. Successful implementation of write-what-where in nt! PushInt <br><br>  Fixing this vulnerability is fairly straightforward and consists of three additional instructions added to nt! PushInt.  They verify that the <code>ss:esp</code> address, which must be from user space, does point to the lower parts of the address space (see Figure 6). <br><br><img src="https://habrastorage.org/files/0b1/bc7/44d/0b1bc744d8274e21b3e4abf5f0d9ac12.jpg"><br>  Figure 6. Binary differences between the initial implementation of nt! PushInt and after the patch <br><br><h3>  CVE-2013-3197 (write-what-where in nt! PushException) </h3><br>  If you look closely at the Windows system interrupt handlers (besides <code>nt!KiTrap0d</code> ), it becomes obvious that most of them provide not only the #GP handler, but also the specific functionality for VDM.  In this regard, the General Protection Fault feature is that it has dedicated routines for handling specific types of exceptions (such as critical or privileged instructions);  other handlers do not use such complex functionality, but instead simply call the function <code>nt!Ki386VdmReflectException</code> if they encounter a VDM exception.  With this they are trying to emulate an event in a virtual environment, approximately along the same lines as the emulation of instructions in <code>nt!VdmDispatchOpcode_try</code> .  The control transfer graph illustrates that most handlers depend on this function (see Figure 7). <br><br><img src="https://habrastorage.org/files/b50/d56/12e/b50d5612e16f4d34929f2384398eb4f6.jpg"><br>  Fig.  7. Graph function nt! Ki386VdmReflectException <br><br><h3>  Headache cause </h3><br>  Under typical circumstances (that is, for any normal process), execution usually completes in one of the variants nt! CommonDispatchException, which sends an event to the user-space exception handler.  In the case of VDM, the kernel first tries using nt! PushException to create a frame trap in the user-space stack and redirect control to cs: eip, which is taken from the VfCsSelector and VfEip fields of the NtCurrentTeb () -&gt; Vdm-&gt; VdmIntDescriptor [trap_no] field (see . Fig. 8);  and only if this procedure does not work, the exception is processed in the usual way.  And, like in the previous case, when creating an emulated frame-trap, the kernel does not check that the stack pointer is indeed within the user's address space.  This again leads to the possibility to use the write-what-where condition, only 16 or 32 bytes instead of 6 or 12. It is also easy to exploit the vulnerability, for this it is enough to set esp to an arbitrary address in kernel space and raise an exception (for example, #DE through The div edx instruction with normal details of a fully initialized VDM environment and user segments cs: and ss: at the time of the error. <br><br><pre> <code class="bash hljs">TRAP_FRAME: 8dd97c28 -- (.<span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> 0xffffffff8dd97c28) ErrCode = 00000002 eax=000007f7 ebx=00000000 ecx=00000000 edx=deadbebf esi=8dd97ce4 edi=00000634 eip=82a874b5 esp=8dd97c9c ebp=8dd97d1c iopl=0 nv up ei ng nz na po nc cs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00010282 nt!PushException+0x150: 82a874b5 6689441a0e mov word ptr [edx+ebx+0Eh],ax ds:0023:deadbecd=???? Resetting default scope</code> </pre><br><br><img src="https://habrastorage.org/files/b7f/585/974/b7f585974fbe4fc18f22c56a544dae27.jpg"><br><br>  Fig.  8. Internal user-space structures that are used to resume the execution of NTVDM interrupted by an exception <br><br>  And this time due to the fact that one of the values ‚Äã‚Äãwritten to the monitored address is an eip error, the same method of using the function pointer (function pointer exploitation technique) can be used to gain complete control over the computer.  However, due to restrictions on the value of LDT, this vulnerability can be exploited only on systems starting with Windows Vista.  In the Microsoft security update, they simply inserted two simple blocks that are responsible for checking the pointer in the user-space stack for the trap frame creation branches for both 16 and 32 bits. <br><br><h3>  CVE-2013-3198 (write-what-where in nt! VdmCallStringIoHandlerPushException) </h3><br>  In addition to processing privileged VDM instructions, the kernel also emulates the execution of critical instructions, that is, such instructions that can be executed only if CPL &lt;= IOPL, which provides control over interrupts and communications over I / O ports.  In the end, all instructions for input / output strings (INSB, INSW, OUTSB, OUTSW in Virtual 8086 mode and protected mode) are executed by the nt! Ki386VdmDispatchStringIo internal function, which acts as an entry point to a large and complex mechanism called "port emulation" (port emulation).  Although its exact functionality is hardly known to someone outside the development team, this mechanism was disassembled by reverse engineering and <a href="http://bit.ly/1gas6Cy">described</a> in detail <a href="http://bit.ly/1gas6Cy">by</a> French researcher Ivanlef0u in 2009.  In short, any device driver running in the Windows kernel can register any I / O emulation handlers for specific processes, port ranges, and port access types using the undocumented ZwSetInformationProcess function (ProcessIoPortHandlers).  Thus, the components of the kernel space can in theory emulate physical devices for programs running within the VDM.  However, there is a more important question - are there any default handlers registered right after installing Windows? <br>  As far as we know, currently there is only one case of port emulation in Windows ‚Äî when an outdated program is running in full screen mode, the default VIDEOPRT.SYS graphics driver registers handlers for the VGA range (0x3b0‚Äì0x3df);  The stack trace for this registration is shown below: <br><br><pre> <code class="hljs go">ChildEBP RetAddr Args to Child <span class="hljs-number"><span class="hljs-number">807</span></span>b1738 <span class="hljs-number"><span class="hljs-number">82</span></span>a55023 <span class="hljs-number"><span class="hljs-number">85886680</span></span> <span class="hljs-number"><span class="hljs-number">00000001</span></span> b06b1bf3 nt!Psp386InstallIoHandler <span class="hljs-number"><span class="hljs-number">807</span></span>b1994 <span class="hljs-number"><span class="hljs-number">828588</span></span>a6 <span class="hljs-number"><span class="hljs-number">00000088</span></span> <span class="hljs-number"><span class="hljs-number">0000000d</span></span> <span class="hljs-number"><span class="hljs-number">807</span></span>b1a40 nt!NtSetInformationProcess+<span class="hljs-number"><span class="hljs-number">0x7ad</span></span> <span class="hljs-number"><span class="hljs-number">807</span></span>b1994 <span class="hljs-number"><span class="hljs-number">82857815</span></span> <span class="hljs-number"><span class="hljs-number">00000088</span></span> <span class="hljs-number"><span class="hljs-number">0000000d</span></span> <span class="hljs-number"><span class="hljs-number">807</span></span>b1a40 nt!KiSystemServicePostCall <span class="hljs-number"><span class="hljs-number">807</span></span>b1a1c <span class="hljs-number"><span class="hljs-number">91619f</span></span>84 <span class="hljs-number"><span class="hljs-number">00000088</span></span> <span class="hljs-number"><span class="hljs-number">0000000d</span></span> <span class="hljs-number"><span class="hljs-number">807</span></span>b1a40 nt!ZwSetInformationProcess+<span class="hljs-number"><span class="hljs-number">0x11</span></span> <span class="hljs-number"><span class="hljs-number">807</span></span>b1a60 <span class="hljs-number"><span class="hljs-number">91616467</span></span> <span class="hljs-number"><span class="hljs-number">86</span></span>a357f0 <span class="hljs-number"><span class="hljs-number">00000001</span></span> <span class="hljs-number"><span class="hljs-number">8597</span></span>ae80 VIDEOPRT!pVideoPortEnableVDM+<span class="hljs-number"><span class="hljs-number">0x82</span></span> <span class="hljs-number"><span class="hljs-number">807</span></span>b1ab4 <span class="hljs-number"><span class="hljs-number">82851</span></span>c1e <span class="hljs-number"><span class="hljs-number">86</span></span>a357f0 <span class="hljs-number"><span class="hljs-number">86f</span></span>32278 <span class="hljs-number"><span class="hljs-number">86f</span></span>32278 VIDEOPRT!pVideoPortDispatch+<span class="hljs-number"><span class="hljs-number">0x360</span></span> <span class="hljs-number"><span class="hljs-number">807</span></span>b1acc <span class="hljs-number"><span class="hljs-number">9</span></span>a5c45a2 fe915c48 fffffffe <span class="hljs-number"><span class="hljs-number">00000000</span></span> nt!IofCallDriver+<span class="hljs-number"><span class="hljs-number">0x63</span></span> <span class="hljs-number"><span class="hljs-number">807</span></span>b1af8 <span class="hljs-number"><span class="hljs-number">9</span></span>a733564 <span class="hljs-number"><span class="hljs-number">86</span></span>a35738 <span class="hljs-number"><span class="hljs-number">00230000</span></span> fe915c48 win32k!GreDeviceIoControlEx+<span class="hljs-number"><span class="hljs-number">0x97</span></span> <span class="hljs-number"><span class="hljs-number">807</span></span>b1d18 <span class="hljs-number"><span class="hljs-number">828588</span></span>a6 <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">0130f</span></span>294 <span class="hljs-number"><span class="hljs-number">00000004</span></span> win32k!NtGdiFullscreenControl+<span class="hljs-number"><span class="hljs-number">0x1100</span></span> <span class="hljs-number"><span class="hljs-number">807</span></span>b1d18 <span class="hljs-number"><span class="hljs-number">77</span></span>c77094 <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">0130f</span></span>294 <span class="hljs-number"><span class="hljs-number">00000004</span></span> nt!KiSystemServicePostCall <span class="hljs-number"><span class="hljs-number">0130f</span></span>25c <span class="hljs-number"><span class="hljs-number">77</span></span>ab6951 <span class="hljs-number"><span class="hljs-number">00670577</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">0130f</span></span>294 ntdll!KiFastSystemCallRet <span class="hljs-number"><span class="hljs-number">0130f</span></span>260 <span class="hljs-number"><span class="hljs-number">00670577</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">0130f</span></span>294 <span class="hljs-number"><span class="hljs-number">00000004</span></span> GDI32!NtGdiFullscreenControl+<span class="hljs-number"><span class="hljs-number">0xc</span></span> <span class="hljs-number"><span class="hljs-number">0130f</span></span>28c <span class="hljs-number"><span class="hljs-number">00672</span></span>c78 <span class="hljs-number"><span class="hljs-number">00000088</span></span> <span class="hljs-number"><span class="hljs-number">0000003</span></span>a <span class="hljs-number"><span class="hljs-number">003</span></span>bd0b0 conhost!ConnectToEmulator+<span class="hljs-number"><span class="hljs-number">0x6c</span></span> <span class="hljs-number"><span class="hljs-number">0130f</span></span>3c0 <span class="hljs-number"><span class="hljs-number">0065f</span></span>24d <span class="hljs-number"><span class="hljs-number">00000001</span></span> <span class="hljs-number"><span class="hljs-number">003</span></span>bd0b0 <span class="hljs-number"><span class="hljs-number">0130f</span></span>4d4 conhost!DisplayModeTransition+<span class="hljs-number"><span class="hljs-number">0x40e</span></span> <span class="hljs-number"><span class="hljs-number">0130f</span></span>458 <span class="hljs-number"><span class="hljs-number">7635</span></span>c4e7 <span class="hljs-number"><span class="hljs-number">000e001</span></span>c <span class="hljs-number"><span class="hljs-number">0000003</span></span>a <span class="hljs-number"><span class="hljs-number">00000001</span></span> conhost!ConsoleWindowProc+<span class="hljs-number"><span class="hljs-number">0x419</span></span></code> </pre><br>  In other words, this technique works only if alternative drivers for the video card are not installed in the system, and standard Microsoft is used.  Switching between fullscreen and windowed mode can be easily achieved using the documented SetConsoleDisplayMode API (CONSOLE_FULLSCREEN_MODE) and SetConsoleDisplayMode (CONSOLE_WINDOWED_MODE) calls. <br><br><h3>  Source of troubles </h3><br>  So, going back to instructions emulation, the nt! Ki386VdmDispatchStringIo function defines a handler for an emulated operation using nt! Ps386GetVdmIoHandler, reads user data from the memory at ds: si, if it is a ‚Äúread‚Äù operation, and calls the I / O handler and writes data to es: di if this is a ‚Äúwrite‚Äù operation.  As you probably already guessed, none of the two pointers (which seem to come from user space) are not validated before use.  Not the best idea, especially considering that in the protected mode, segments can have 32-bit base addresses, so, as a result, this vulnerability will allow us to read and write arbitrarily selected addresses in the kernel memory. <br>  To summarize: to successfully exploit the vulnerability, we need to force the VIDEOPRT.SYS driver to register VGA I / O handlers by switching the VDM console to full screen to create and load custom segments in <code>cs:</code> and <code>es:</code> (the base address of the last segment indicates the kernel memory for rewriting), initialize the di register with the value 0x0 and dx with the value 0x3b0, and then call the insb instruction;  Of course, all operations must be carried out within the NTVDM.EXE process.  If we install the base of the es segment: at 0xaaaaaaaa and launch the exploit on the unpatched system, the following should happen: <br><br><pre> <code class="bash hljs">TRAP_FRAME: 963889fc -- (.<span class="hljs-built_in"><span class="hljs-built_in">trap</span></span> 0xffffffff963889fc) ErrCode = 00000002 eax=aaaaaa00 ebx=00000001 ecx=fffffffd edx=00000003 esi=8297d260 edi=aaaaaaaa eip=82854fc6 esp=96388a70 ebp=96388a78 iopl=0 vif nv up ei ng nz ac po cy cs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00090293 nt!memcpy+0x166: 82854fc6 8807 mov byte ptr [edi],al ds:0023:aaaaaaaa=?? Resetting default scope</code> </pre><br>  By default, port 0x3b0 writes a single byte to memory - <code>0x00</code> , so this vulnerability can be used to reset any pointer to a kernel space function;  having done this, we can redirect the execution of the ring 0 code to a NULL page, which is already located in the NTVDM address space.  Thus, in this case, we can increase the security token of the local process or compromise the security of the system in any other way that is convenient for us. <br>  To fix this problem, Microsoft introduced an inline call to ProbeForRead before reading data from user space at ds: si, as well as a general call to ProbeForWrite before writing data back to es: di. <br><br><h3>  Thinking out loud </h3><br>  All three privilege elevation vulnerabilities discussed in this article were possible due to the write-what-where condition, which arises because the user-provided data does not undergo any validation.  In other situations, this type of vulnerability to the base NT kernel image (ntoskrnl.exe) is extremely rare.  And although Microsoft has been able to track down and fix most of these problems in recent years, they somehow missed the I / O emulation code, exceptions, and instructions in the VDM;  Most likely, due to the fact that static analysis tools that are very effective for high-level C and C ++ code do not currently support assembler or interact poorly with it.  It should be noted that the ability to use these vulnerabilities appeared only after a small unrelated change in the LDT input control code, which first appeared in Windows Vista.  Because of this change, the internal function nt! PspIsDescriptorValid was deprived of checks related to the base and input restrictions.  However, this is nothing more than a successful coincidence.  The real reason behind this vulnerability was not the differences in segment control, but the fact that the emulation code used the full ss: esp, ds: si and es: di addresses in memory operations, although one of the key security features for The Windows kernel says: privileged code should never trust any memory segments from the user. <br><br><h3>  Summarizing </h3><br>  Using the example of these three discoveries, we once again clearly see that many kernel vulnerabilities are due to the existence of code written almost in the early 1990s.  Then security was not considered as an important priority (unlike our time), which led to the creation of bad code, and no one has revised it from a security point of view since it was written twenty years ago.  At the same time, large portions of the code are used in the most recent versions of Windows, including the latest Windows 8.1 and Server 2012. Modern kernel source code, which is written in 2013, must comply with the guidelines for safe development and be thoroughly tested before release.  Therefore, we believe that instead of digging into new functional elements that were introduced in the latest versions of the system, it is much more effective to look for errors in those key components that were created a long time ago. <br>  And the last thing worth noting is that disabling the default backward compatibility with DOS applications in Windows 8 was a great Microsoft solution.  Thanks to him, most of the not yet detected errors are either impossible to use or there is no point in searching, because the attacker will not receive sufficient dividends from their use.  In addition, this solution allowed to completely disable any NULL pages (before their presence required the VDM host process), and due to this, errors like NULL pointer dereference, which are often found in the kernel and device drivers, either completely disappear.  According to the overall impact on future defenses, this is one of the most dramatic improvements by Microsoft in all time.  But now go ahead - find your own bug in the core! <br><br>  <i>Posted by: Mateusz "j00ru" Jurczyk.</i> <br><br><img src="https://habrastorage.org/files/696/53e/758/69653e7585a04dc598da1cd8430df6e6.png"><br><br>  <i>First published in the journal "Hacker" from 01/2014.</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://bit.ly/xakep_on_ipad">Hacker on iOS / iPad</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul><br><br> <a href="http://bit.ly/xakep_on_ipad"><img src="https://habrastorage.org/getpro/habr/post_images/6d3/e39/90b/6d3e3990b645b719835d84e9c02699ef.png"></a> <br><br> <a href="http://bit.ly/habr_android"><img src="https://habrastorage.org/getpro/habr/post_images/117/fc7/5d3/117fc75d3fe93b8601be69119c2ecd88.jpg"></a> </div><p>Source: <a href="https://habr.com/ru/post/232207/">https://habr.com/ru/post/232207/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../232199/index.html">What should be the search on the site?</a></li>
<li><a href="../2322/index.html">IM pagers drive a wedge between generations</a></li>
<li><a href="../23220/index.html">Analogies are helpful</a></li>
<li><a href="../232203/index.html">Nigerian performer offers to cut off pirates fingers</a></li>
<li><a href="../232205/index.html">Build a coworking in the Crimea. Part One: The Idea</a></li>
<li><a href="../232209/index.html">What is cheaper: new hardware or developers?</a></li>
<li><a href="../232213/index.html">Can big data analysis help save the lives of patients?</a></li>
<li><a href="../232217/index.html">D # is a programming language for Doge fans.</a></li>
<li><a href="../232219/index.html">AngularJS: we configure event of initialization</a></li>
<li><a href="../23222/index.html">Internet problems of the future. What awaits us?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>