<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>java-object-merger - more than just an object mapper</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! I would like to introduce you to a new java library for mapping / merging objects, which I ‚Äúmodestly‚Äù position as a possible alternative to doz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>java-object-merger - more than just an object mapper</h1><div class="post__text post__text-html js-mediator-article">  Hello!  I would like to introduce you to a new java library for mapping / merging objects, which I ‚Äúmodestly‚Äù position as a possible alternative to <a href="http://dozer.sourceforge.net/">dozer</a> .  If you are developing an enterprise application in java, you are not indifferent to the effectiveness of your work, and want to write less boring code, then I invite you to read more! <br><br>  <b>UPD.</b>  Posted in the central repository of maven <br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>net.sf.brunneng.jom<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>java-object-merger<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>0.8.5.1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><br>  <b>UPD2</b> .  <a href="https://sourceforge.net/projects/javaobjectmerger/files/0.8.4/">Version 0.8.4</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/1cd/052/c63/1cd052c63bbee2eafd2096c9ab185946.png"><br><br><a name="habracut"></a><br><br><h5>  What are object mappers for? </h5><br>  The simple answer is: to copy data automatically from one object to another.  But then you may ask: why is this copying necessary?  One can doubt that this is needed very often.  So you should give a more detailed answer. <br>  In the world of enterprise applications, it is customary to beat the internal structure into layers: a base access layer, a business, and a presentation / web service.  In the database access layer, as a rule, there are objects mapping on tables in the database.  We agree to call them DTO (from Data transfer object).  For good, they only transfer data from the tables and do not contain business logic.  On the presentation / web services layer, there are objects that deliver data to the client (browser / clients of web services).  Let's call them VO (from View object).  VOs may require only a fraction of the data that is in the DTO, or aggregate data from several DTOs.  They can additionally engage in localization or transformation of data into a convenient form for presentation.  So transmitting the DTO immediately to the presentation is not entirely correct.  Also, business objects (business object) are sometimes distinguished in the business layer.  They are wrappers over DTO and contain the business logic of working with them: saving, modifying, business operations.  Against this background, the problem arises of transferring data between objects from different layers.  Say, for example, part of the data from the DTO to VO.  Or from VO to BO and then save what happened. <br><br>  If you solve the problem in the forehead, you get something like this ‚Äústupid‚Äù code: <br><pre> <code class="java hljs">‚Ä¶ employeeVO.setPositionName(employee.getPositionName()); employeeVO.setPerson(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PersonVO()); PersionVO personVO = employeeVO.getPerson(); PersonDTD person = employee.getPerson(); personVO.setFirstName(person.getFirstName()); personVO.setMiddleName(person.getMiddleName()); personVO.setLastName(person.getLastName()); ...</code> </pre><br>  Familiar?  :) If yes, then I can please you.  For this problem has come up with a solution. <br><br><h5>  Object Mappers </h5><br>  Invented, of course, not by me.  There are a lot of java implementations.  You can read, for example <a href="http://stackoverflow.com/questions/1432764/any-tool-for-java-object-to-object-mapping">here</a> . <br>  In short, the mapper's task is to copy all the properties of one object into another, and also do the same recursively for all child objects, doing the necessary type conversion, if necessary. <br>  The mappers from the list above are all different, more or less primitive.  Perhaps the most powerful <a href="http://dozer.sourceforge.net/">dozer</a> , I worked with him for about 2 years, and some things in him ceased to work.  And the slow pace of further development of the doser prompted me to write my own ‚Äúbicycle‚Äù (yes, I got to know other mappers ‚Äî they are even worse for our customers). <br><br><h5>  What is bad dozer </h5><br><ol><li>  Poor annotation configuration support (there is only <code>@Mapping</code> ). </li><li>  It is impossible to draw from several fields into one (for example, to collect the full name from the name, surname and patronymic). </li><li>  Problems with mapping generic properties.  If the parent abstract class has a getter that returns a generic type T, where <code>,    T ,          T.    IEntity,   ,      ..</code> <br>  Property classes are stored as strings in the internal cache of the doser, and a special loader class is used to get the class.  Problems with this arise in the osgi environment, when the dozer is in one bundle, and the desired bin class in another, not accessible from the first.  We overcame the problem, even in a standard way - by slipping the required loader class, but the implementation itself: storing the class as a string - looks strange.  Perhaps this is in order not to create perm gen space of memory of faces.  But still not very clear. <br>  If something suddenly does not map, then it is very difficult to understand this.  If you debug a dozer, you will understand why.  There is some kind of ... just a crazy jumble of OOP patterns - everything is confusing and not explicit.  However, this is just for my taste. <br><br><h5>  What qualities should a mapper have? </h5><br><ol><li>  Broad configuration support via annotations. </li><li>  Full support for generics. </li><li>  Clean, understandable code that anyone can play without risking breaking the brain. </li><li>  By default, without any additional settings, it should map as the developer most likely would expect. </li><li>  It should be possible to fine tune (no worse than the dosage). </li></ol><br><br><h5>  Why merger and not mapper? </h5><br>  java-object-merger distinguishes from other mappers one feature.  The basic idea was to give an opportunity to create snapshots of objects ( <b>Snapshot</b> ) for a certain moment in time, and then, comparing them, find differences ( <b>Diff</b> ) just as we find a diff between two texts.  Moreover, it should be possible to view snapshots and diffs in a text that can be understood by humans.  So that once you look at the diff, all the differences are immediately clear, as well as the target object will be changed after applying the diff.  Thus we achieve full transparency of the process.  No magic and black boxes!  Creating snapshots opens another interesting scenario.  You can make a snapshot of the object, then somehow changing it, make a new snapshot - check what has changed, and, if desired, roll back the changes.  By the way, diff can be bypassed with a special visitor, and you can mark only those changes that you want to apply, and ignore the rest. <br>  So it can be said that merger is <i>more</i> than just a mapper. <br><br><h5>  Using </h5><br>  The ‚ÄúHello world‚Äù program looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> net.sf.brunneng.jom.IMergingContext; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> net.sf.brunneng.jom.MergingContext; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String field1; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getField1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> field1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setField1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String field1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field1 = field1; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A2</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String field1; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String field1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field1 = field1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getField1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> field1; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ IMergingContext context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MergingContext(); A2 a2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A2(<span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>); A1 a1 = context.map(a2, A1.class); System.out.println(a1.getField1()); } }</code> </pre><br><br>  First, we see that for mapping it is necessary that the property has a getter on both objects.  This is needed to compare values.  And the target setter has to record a new value.  The properties themselves must be named the same. <br><br>  Let's see how the map method is implemented.  This will help to understand many things about the library. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object source, Class&lt;T&gt; destinationClass)</span></span></span><span class="hljs-function"> </span></span>{ Snapshot sourceSnapshot = createSnapshot(source); Snapshot destSnapshot = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sourceSnapshot.getRoot().getType().equals(DataNodeType.BEAN)) { Object identifier = ((BeanDataNode)sourceSnapshot.getRoot()).getIdentifier(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (identifier != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { destSnapshot = createSnapshot(destinationClass, identifier); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destSnapshot == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { destSnapshot = createSnapshot(destinationClass); } Diff diff = destSnapshot.findDiffFrom(sourceSnapshot); diff.apply(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T)destSnapshot.getRoot().getObject(); }</code> </pre><br><br>  If the source snapshot is a bin, and if it has an identifier, then we try to find the target bin for the destinationClass class using IBeanFinder [here <code>createSnapshot(destinationClass, identifier);</code>  ].  We have not registered these, and identifier, no, it means we go further.  Otherwise, the bean is created using the appropriate IObjectCreator [here <code>createSnapshot(destinationClass)</code> ].  We also did not register these, but in the standard package there is a creator of objects by the default constructor - it is used.  Next, the target snapshot is taken diff from the source snapshot and is applied to the target object.  Everything. <br><br>  By the way, diff, for this simple case, will look like this: <br><pre> <code class="javascript hljs">MODIFY { dest object : Main$A1@<span class="hljs-number"><span class="hljs-number">28</span></span>a38b58 src object : Main$A2@<span class="hljs-number"><span class="hljs-number">76</span></span>f8d6a6 ADD { dest property : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> field1 = <span class="hljs-literal"><span class="hljs-literal">null</span></span> src property : <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> field1 = <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span> } }</code> </pre><br><br><h5>  Key annotations </h5><br>  Located in the <code>net.sf.brunneng.jom.annotations</code> package. <br><ul><li>  <code>@Mapping</code> - sets the path to the field for mapping at the other end of the association (for example, <code>‚Äúemployee.person.firstName‚Äù</code> ).  May be specified on the class of the target object or source object. </li><li>  <code>@Skip</code> - the field does not fall into snapshot, is not compared and is not mapped. </li><li>  <code>@Identifier</code> - marks a field that is considered a bean identifier.  Thus, when comparing collections, we will know which object should be compared with which one.  Namely, objects with matching identifiers will be compared.  Also, if in the process of applying defa there is a need to create a bin, and the identifier is known, then there will be an attempt to first find this bin using registered <code>IBeanFinder</code> .  Thus, an <code>IBeanFInder</code> implementation can search for <code>IBeanFInder</code> for example in the database. </li><li>  <code>@MapFromMany</code> - the same as @Mapping is only indicated on the class of the target object and allows you to specify an array of properties on the source object that will be mapped to the field in the target object. </li><li>  <code>@Converter</code> - allows you to set a class on the property that is the successor of <code>PropertyConverter</code> .  - it will perform the conversion between properties.  A property converter is required when mapping several fields into one, since  it will just have to collect all the values ‚Äã‚Äãfrom the source together and form one of them. </li><li>  <code>@OnPropertyChange, @OnBeanMappingStarted, @OnBeanMappingFinished</code> - allow you to mark the methods that listen for the corresponding events in the mapping life cycle that occur in this bin. </li><li>  Other. </li></ul><br><br><h5>  Type conversion </h5><br>  In IMergingContext, you can register custom type converters, from one type to another ( <code>TypeConverter</code> interface).  A standard set of converters includes conversions: <br><ul><li>  primitive types in wrappers, and vice versa </li><li>  date conversions </li><li>  objects in a row </li><li>  enums to enums, and strings to enums named enums constant </li></ul><br><br><h5>  Object categories </h5><br>  Mapper divides all objects into categories such as: <br><ol><li>  Value objects: primitive types, objects in the <code>java.lang</code> , dates, arrays of value objects.  The list of classes considered as values ‚Äã‚Äãcan be extended via <code>IMergingConext</code> . </li><li>  Collections are arrays that all derive from <code>java.util.Collection</code> . </li><li>  Mapy - all inherited from <code>java.util.Map</code> . </li><li>  Beans - all the rest. </li></ol><br><br><h5>  Performance </h5><br>  Honestly, while I was writing the library, I didn‚Äôt think much about performance.  Yes, and initially for high performance was not.  However, I decided to measure the mapping time N times per test object.  <a href="">The source code of the test</a> .  The object is quite complex, with fields of values, child bins, collections and maps.  For comparison, I took the latest dozer for the current version 5.4.0.  I expected that the doser would not leave any chances.  But it turned out quite the opposite!  dozer zampil 5000 test objects in 32 seconds, and java-object-merger 50,000 objects in 8 seconds.  Some kind of wild difference - 40 times ... <br><br><h5>  Application </h5><br>  The java-object-merger was tested on the current project from my main job (osgi, spring, hibernate, hundreds of mapping classes).  To replace them, the dose completely took less than 1 day.  Along the way there were some obvious jambs, but after the correction, all the main scenarios worked fine. <br><br><h5>  Lazy Snapshots </h5><br>  One of the obvious problems found while screwing a mapper to a real project was that if you do snapshots on a DTO that has lazy lists of other entities, and those others refer to third others, then you can create one snapshot inadvertently, deflate the floor of the base.  Therefore, it was decided to make all the properties in the snapshot lazy by default.  This means that they will not be pulled out of the objects until they are compared with the corresponding property when taking the diff.  Or until we explicitly call the <code>loadLazyProperties()</code> method on snapshot.  And when the property is pulled out, the automatic completion of the snapshot occurs - again with lazy properties that are waiting for them to be loaded. <br><br><h5>  Conclusion </h5><br>  If interested - the project, with the source code and documentation is <a href="https://sourceforge.net/projects/javaobjectmerger/">here</a> .  All the main functionality of the library is covered by unit tests, so you can be sure that you will not see any stupid trivial errors in it.  Practically all classes and methods are documented by javadoc. <br>  Download, try, write your feedback :).  I promise to respond quickly and listen to your wishes. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/196478/">https://habr.com/ru/post/196478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196468/index.html">Experiments with liquid nitrogen, plastic bottles and table tennis balls</a></li>
<li><a href="../196470/index.html">VIM, Windows, quickfix - struggle with compiler coding</a></li>
<li><a href="../196472/index.html">EFF accuses NSA of violating Creative Commons license</a></li>
<li><a href="../196474/index.html">What is the difference between Brackets / Adobe Edge and COLT?</a></li>
<li><a href="../196476/index.html">The Large Hadron Collider with my own eyes. Part 3</a></li>
<li><a href="../196480/index.html">60 games on sale Not On Steam</a></li>
<li><a href="../196484/index.html">Buying on Amazon, new details</a></li>
<li><a href="../196486/index.html">The digest of interesting materials from the world of web development and IT for the last week No. 77 (September 29 - October 5, 2013)</a></li>
<li><a href="../196488/index.html">Topology for the smallest. Part 2</a></li>
<li><a href="../196490/index.html">Electronics Circle: Lesson Program</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>