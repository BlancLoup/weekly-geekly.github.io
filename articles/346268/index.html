<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Physical simulation on the GPU using the compute shader in the Unity3D environment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this tutorial, I‚Äôll explain how to use the compute shader to implement computations on a video card - using the hair model as an example: 


 Here ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Physical simulation on the GPU using the compute shader in the Unity3D environment</h1><div class="post__text post__text-html js-mediator-article">  In this tutorial, I‚Äôll explain how to use the compute shader to implement computations on a video card - using the hair model as an example: <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed//pxfW7cC/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Here is a project for Unity3D, on the explanation of which the manual is built.  It needs to be downloaded and opened in Unity: <br><br>  <a href="https://drive.google.com/open%3Fid%3D1LTgdVaiOuGuXhb6Mhc_Z1gStP7muxZlO">link to project unity</a> <br><br>  Who will understand this manual?  Those who use Unity3D or at least know C # or C ++.  The shader is written in HLSL, a close syntax relative of C ++. <br>  Who will this guide be useful for?  Experienced programmers who want to learn how to use GPU for computing.  But even an inexperienced, but diligent programmer will easily understand everything. <br><cut></cut><br>  Why use a video card for computing?  For parallel tasks, its performance is 10-100 times higher than that of the processor.  That is, each computer has a small supercomputer with a convenient API, it makes sense to use it in suitable cases. <br>  Is this huge performance really needed?  Yes, often the processor speed is a limiting factor.  For example, when you need to perform the same operations on large data arrays.  But such tasks are easily parallelized.  In addition, developers often reject solutions because of their computational capacity, and entire areas in the algorithm space remain unexplored.  For example, you can do the coolest physics in games, if you carefully load the graphics processor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And what, with a video card, you can now just solve problems with brute force?  The demand for optimization does not depend on the performance of iron.  There is no such supercomputer, which could not be tightly loaded with inefficient code. <br><br>  Why compute shader?  Why not opencl or cuda?  Cuda only works on nvidia hardware, and I don't know opencl.  Unity can build into any API, including the opengl core.  On Macs and on Android, computer shaders work, like on Linux too (although I haven't tried it).  Although, each API has limitations that should be considered.  For example, on Metal it is impossible to make more than 256 streams along one axis (B DX10 - 1024).  And the android API will not be able to use more than 4 buffers per kernel (In DX10 - 8, in DX11 - even more). <br><br>  Why precisely physical simulation?  This is a computationally intensive task, and it is well suited for parallel computation.  In addition, the task is claimed.  Game devs can implement interesting physics in games, students can create experimental models for coursework, engineers and scientists can do the calculation on the model. <br><br>  And why exactly hair model?  I wanted to take a simple task, but at the same time covering the main issues. <br><br>  How to use this guide?  It is best to download the source code, open it and read as you move through the manual.  I will explain in detail all the main lines, although I will not explain every line at all, the meaning of most of them is obvious.  There are no complex algorithms in the text, there is only the use of an interface of classes that serve computations on the GPU.  And on the side of the shader code, there is nothing but reading data, performing simple math operations on them and writing results.  But if something is not clear - surely ask, I will answer everything in kamentah. <br><br>  And now for those who have absolutely no idea about using compute shaders, I propose to take a step aside and go to a <a href="https://habrahabr.ru/post/346260/">very simple guide</a> , which is devoted to the basics of using computer shaders.  I advise you to start with it in order to better understand the essence and adapt yourself to the practice of GPU computing using an extremely simple example.  And then come back here and continue.  And those with computer shaders at least somehow familiar, boldly read on. <br><br>  If you want to make a physical model calculated on a GPU from scratch, this task can be divided into 4 parts: <br><br>  - mathematical model of the phenomenon <br>  - algorithm for parallel calculation of the model <br>  - shader code <br>  - preparation and launch of the shader in a unit <br><br><h2>  Mathematical model </h2><br>  The strengths of the video cards are that they can apply a single operation simultaneously to multiple objects.  Therefore, a hair model can be made as a chain of points, each of which interacts with two neighbors.  The interaction between points is based on the spring principle: k * (S0-S) ^ n, where S0 is the equilibrium distance, S is the current distance.  In reality, the hair does not look like a spring; it is perceived as inextensible.  This means that the spring in the model must be made sufficiently rigid.  It is better to increase the stiffness of the spring by increasing n, because the degree increases the curvature of the curve in the vicinity of the equilibrium, which reduces the backlash and reduces the ‚Äúrubberiness‚Äù effect of the hair.  I took n = 2, and the value of the coefficient k will be discussed below. <br><br>  In addition to the elastic force between points, diffusion of relative velocities or one-dimensional viscosity will be realized.  The exchange of the tangential component of the velocity models the dynamic resistance to stretching, and the exchange of the normal velocity characteristic, the dynamic resistance to the bend.  All together it will speed up the transmission of disturbances along the hair, which will improve the dynamics, make the hair more visually coherent and less springy. <br><br>  In addition, there will be a static tendency to straightening.  Each point will tend to compensate for the fold of the hair.  If there is a bend at a point, a point will be affected by a force proportional to the bend and directed in the direction of decreasing the bend.  Two points adjacent to the bend point will experience twice as little force in the opposite direction. <br><br>  These interactions are enough to model the physics of the hair, but we will not limit ourselves with it.  It is necessary to add the interaction of the hair with solid objects.  This has a practical meaning.  The point is not only that physical models, as a rule, include interaction between differently simulated entities, for example, liquids and solids, between themselves.  But also in the fact that in practical tasks, for example, in games, a GPU simulation should interact in real time with objects calculated on the CPU side.  So I could not help but pay attention to this interaction.  Our hair will interact with solids, information about which will be transmitted to the video memory in each step. <br><br>  For simplicity, we will work only with round objects.  On the CPU side, we will have several circle colliders from the standard 2d physics of the unit.  And the rule of interaction will be this: if a hair point is inside a solid body, it is transferred outside, and the fraction directed towards the body is subtracted from the speed of such a point, and the same fraction is transferred to the body.  We will not take into account the absolute speed of the body, for simplicity. <br><br><h2>  Algorithm, code and shader preparation </h2><br>  These three points are too closely related to discuss them separately. <br><br>  To describe the points from which many hairs are made, we use the following structure: <br><br><pre><code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">struct</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNode</span></span>{ float x; //     float y; // float vx; //  float vy; // int dvx; //   -      int dvy; // int dummy1; //       128  int dummy2; // }</code> </pre> <br>  This structure is declared twice: on the CPU side and on the GPU side.  For comfort.  On the CPU side, we write the initial data, copy it to the GPU buffer, and then they are processed there.  But it was possible to explain this structure only on the side of the GPU, if we do not need to transfer the initial data. <br><br>  About the parameters dummy1 and dummy2.  In an article written by an engineer from nvidia, I read that the data of the video memory buffers should be kept multiple to 128 bits.  Because it reduces the number of operations needed to calculate the offset. <br><br>  The values ‚Äã‚Äãof the remaining parameters, I believe, are clear.  Although, an attentive reader may ask: Why is the speed of the type float, and the change in speed - int?  The short answer is: because the speed change is modified simultaneously by parallel threads, and to avoid computation errors, you need to use a secure entry.  And the secure write function works only with integer variables.  I will tell you more about this below. <br><br>  We have a lot of points with which we model our hair.  Data on all points are stored in video memory and are available through the buffer interface: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">RWStructuredBuffer</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNode</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span>;</code> </pre> <br>  In the shader code, we define only its name and data type, and its size is set outside, from the side of the code executed on the processor. <br><br>  How is the computer shader code structured, what is it all about?  The code consists of kernels.  This is the same as the methods, but each kernel is executed in parallel on a set of cores.  Therefore, for each, the number of flows is indicated in the form of a three-dimensional structure. <br>  This is how an empty kernel looks like, in which there is no code, only the necessary external information: <br><br><pre> <code class="css hljs"><span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">kernel</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">kernelName</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[numthreads(8,4,1)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">kernelName</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">uint3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">id</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">SV_DispatchThreadID</span></span>){ //     }</code> </pre> <br>  The kernel has an input parameter id, which stores the three-dimensional index of the stream.  This is very convenient, each thread knows its own index, which means it can work with its own separate data unit. <br><br>  From the side of the processor code, the kernel is called like this: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">shaderInstance</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Dispatch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">kernelIndex</span></span>, 2, 2, 1);</code> </pre> <br>  These three numbers ‚Äú2, 2, 1‚Äù are associated with the line that precedes the corresponding kernel: <br><br><pre> <code class="css hljs"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[numthreads(8,4,1)]</span></span></code> </pre> <br>  These two triples of digits determine the number of streams, that is, the number of parallel copies of the kernel.  You just need to multiply them: 8 * 4 * 1 * 2 * 2 * 1 = 128 threads. <br><br>  Addressing flows will be on each axis.  In this case, the x-axis will be 8 * 2 = 16 units.  On axis 4 * 2 = 8 units.  That is, if the kernel is called like this: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ComputeShader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Dispatch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">kernelIndex</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">X</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Y</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Z</span></span>);</code> </pre> <br>  And on the shader side, the number of threads is set as follows: <br><br><pre> <code class="css hljs"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[numthreads(x,y,z)]</span></span></code> </pre> <br>  So we will have (X * x) * (Y * y) * (Z * z) streams <br><br>  For example, suppose that we need to process each pixel of a texture of 256 x 256 in size, and we want a separate stream to deal with each pixel.  So, we can determine the number of threads as follows: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Dispatch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">kernelIndex</span></span>, 16, 16, 1);</code> </pre> <br>  and on the shader side: <br><br><pre> <code class="css hljs"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[numthreads(16,16,1)]</span></span></code> </pre> <br>  Inside the kernel, the id.x parameter takes values ‚Äã‚Äãin the range [0, 255], the same is the id.y parameter <br><br>  So, this is the line: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">texture</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[id.xy]</span></span>=<span class="hljs-selector-tag"><span class="hljs-selector-tag">float4</span></span>(1, 1, 1, 1);</code> </pre> <br>  paint each of 65536 pixels of texture in white <br><br>  id.xy is the same as uint2 (id.x, id.y) <br><br>  If this part, related to the number of threads, is incomprehensible to someone, I advise you to go to the easier guide I mentioned, and see how all this is used in practice to draw the Mandelbrot fractal using the simplest shader. <br><br>  The text of the shader in our model contains several kernels, which are in turn run on the CPU side in the Update () method.  I will then review the text of each kernel, and first I will briefly explain what each of them does. <br><br>  calc ‚Äî tangential and normal interaction forces between particles are calculated: the tension force of the ‚Äúsprings‚Äù pushes the particles along the line between them, and the ‚Äústiffness at the bend‚Äù force pushes the particles perpendicular to the line between adjacent particles;  calculated forces are stored for each particle <br><br>  velShare - particles exchange relative speeds.  Tangential and full standing - separately.  Why allocate a tangential, if then all the same there is an exchange of full speed?  The exchange of tangential speed should be much more intense than normal, with it should be a higher coefficient, so it had to be allocated.  Then why in the second case, I do not use the pure normal component, but use the full speed?  To save on calculations.  Changes in speed are recorded in the form of forces, as in the previous kernel. <br><br>  interactionWithColliders - each point interacts with colliders, information about which is contained in the buffer updated in each cycle <br><br>  calcApply - the forces calculated in the previous kernels are added to the speed, and the speeds change the coordinates of points <br><br>  visInternodeLines - lines are drawn between points in a special buffer 1024 x 1024 long (not yet on texture) <br><br>  pixelsToTexture - and here the values ‚Äã‚Äãfrom the above are already converted to pixel colors on the texture of size [1024, 1024] <br><br>  clearPixels - all values ‚Äã‚Äãof the intermediate buffer (in which we drew lines) are reset <br><br>  clearTexture - clear texture <br><br>  oneThreadAction - this kernel is executed in one single thread, it is needed to smoothly move the entire hair system to where we dragged it with a mouse.  Smoothness is needed so that the system does not peddle from abrupt movement (as you remember, in our model, the force between particles is proportional to the square of the distance between them). <br><br><h2>  On the side of the CPU code </h2><br>  Now I will show how these kernels are started by the CPU code.  But first, how to prepare the shader for launch. <br><br>  We declare a variable: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ComputeShader</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span>;</code> </pre> <br>  We initialize it by specifying the shader text file: <br><br><pre> <code class="css hljs">_<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Resources</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Load</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">ComputeShader</span></span>&gt;("<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span>");</code> </pre> <br>  Set the constants that will be useful to us on the side of the GPU <br><br><pre> <code class="css hljs">//  <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesPerHair</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">nHairs</span></span>   _<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetInt</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">nNodsPerHair</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesPerHair</span></span>); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetInt</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">nHairs</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">nHairs</span></span>);</code> </pre> <br>  We declare variables for the array, which will store the data of the simulated points, and for the buffer, through whose interface we can read and write data in the video memory <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNode</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesArray</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">ComputeBuffer</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span>;</code> </pre> <br>  Initialize the buffer and write the array data to the video memory. <br><br><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesArray</span></span>   <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ComputeBuffer</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesArray</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Length</span></span>, 4 * 8); <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetData</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesArray</span></span>);</code> </pre> <br>  For each kernel, set the used buffers so that the kernel can read and write data in this buffer. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">kiCalc</span></span> = _<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.FindKernel</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">calc</span></span>"); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetBuffer</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">kiCalc</span></span>, "<span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span>);</code> </pre> <br>  When all the necessary buffers are created and installed for all the shader kernels, you can run the kernels. <br><br>  All kernels run from Update ().  From FixedUpdate (), they should not be run (will be lagging heavily), because the graphics pipeline is synchronized with Update (). <br><br>  Kernels are launched in the following sequence (I quote the whole code of the ‚ÄúdoShaderStuff‚Äù method called in Update ()): <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">doShaderStuff</span></span>(){ int i, nHairThreadGroups, nNodesThreadGroups; nHairThreadGroups = (nHairs - 1) / 16 + 1; nNodesThreadGroups = (nodesPerHair - 1) / 8 + 1; _shader.SetFloats("pivotDestination", pivotPosition); circleCollidersBuffer.SetData(circleCollidersArray); i = 0; while (i &lt; 40) { _shader.Dispatch(kiVelShare, nHairThreadGroups, nNodesThreadGroups, 1); _shader.Dispatch(kiCalc, nHairThreadGroups, nNodesThreadGroups, 1); _shader.Dispatch(kiInteractionWithColliders, nHairThreadGroups, nNodesThreadGroups, 1); _shader.Dispatch(kiCalcApply, nHairThreadGroups, nNodesThreadGroups, 1); _shader.Dispatch(kiOneThreadAction, 1, 1, 1); i++; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">circleCollidersBuffer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.GetData</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">circleCollidersArray</span></span>); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Dispatch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">kiVisInternodeLines</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">nHairThreadGroups</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">nNodesThreadGroups</span></span>, 1); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Dispatch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">kiClearTexture</span></span>, 32, 32, 1); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Dispatch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">kiPixelsToTexture</span></span>, 32, 32, 1); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Dispatch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">kiClearPixels</span></span>, 32, 32, 1); }</code> </pre><br>  It immediately catches the eye that several Kernels are launched 40 times for an update.  What for?  So that with a small time step, the simulation works quickly in real time.  And why should the time step be small?  To reduce the sampling error, that is, for the stability of the system.  And how and why does instability arise?  If a step is large, and a large force acts on a point, then in one step the point flies away, the return force becomes even larger, and in the next step the point flies to the other side even further.  Result: the system goes astray, all points fly back and forth with increasing amplitude.  And with a small step, all the curves of forces and speeds are very smooth, because the errors are greatly reduced with a decrease in the time step. <br><br>  So instead of one big step, the system takes 40 small steps in each cycle, and because of this, it demonstrates a high accuracy of calculations.  Due to its high accuracy, it is possible to work with large interaction forces without losing stability.  But big forces mean that we do not have sluggish springy macaroni in the model dangle, trying to explode from a sudden movement, and strong hairs revolve cheerfully. <br><br>  The data about the points with which we model the hair is stored in the video memory in the form of a one-dimensional array, to which we access through the buffer interface. <br><br>  For the convenience of working with a one-dimensional buffer, we index the flows as follows: (x-axis: number of hair * y-axis: number of points in the hair).  That is, we will have a two-dimensional array of threads, each of which will know its point by the index of the stream. <br><br>  As you remember, the number of threads in which the kernel is executed is determined by the product of the parameters of the Dispatch () method and the parameters of the [numthreads ()] directive in the shader code. <br><br>  In our case, all kernels that work with hair dots are preceded by the directive [numthreads (16.8,1)].  Therefore, the parameters of the Dispatch () method must be such that the product gives the number of threads no less than we need to process the entire array of points.  In the code, we calculate the x and y parameters of the Dispatch () method: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">nHairThreadGroups</span></span> = (<span class="hljs-selector-tag"><span class="hljs-selector-tag">nHairs</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 1) / 16 + 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">nNodesThreadGroups</span></span> = (<span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesPerHair</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 1) / 8 + 1;</code> </pre> <br>  The relationship between the [numthreads ()] and Dispatch () parameters stems from the architecture of graphical solvers.  The first is the number of threads in the group.  The second is the number of thread groups.  Their ratio affects the speed of work.  If we need 1024 streams along the x axis, it is better to make 32 groups of 32 streams, than 1 group of 1024 streams.  Why?  To answer this question, you need to tell a lot about the GPU architecture, leaving this topic too deeply unaffected. <br><br><h2>  Details GPU-code </h2><br>  So, 40 times for the update, we launch in turn the kernels that calculate the change in the speed of points and change their speeds and coordinates.  Let's look at the code for each kernel.  Everything is quite simple there, you only need to learn a couple of specific features. <br><br>  Kernel "calc" calculates the change in the speed of points.  The points in the hairNodesBuffer buffer are arranged in turn, first the first point of the first hair, then the second, and so on until the last.  Then immediately the first point of the second hair, and so on for all the hair, until the end of the buffer.  We remember that the kernel has a parameter id, and in our case id.x indicates the number of the hair, and id.y indicates the number of the point.  And here is how we access the data points: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodeIndex</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodeIndex2</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNode</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">node</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">node2</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodeIndex</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">id</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">nNodesPerHair</span></span> + <span class="hljs-selector-tag"><span class="hljs-selector-tag">id</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodeIndex2</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodeIndex</span></span> + 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">node</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodeIndex]</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">node2</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodeIndex2]</span></span>;</code> </pre> <br>  Here, the value of nNodesPerHair is a constant that we set on the CPU side when the shader is initialized.  The data from the buffer is copied into the local variables node and node2 because accessing the buffer data may require more kernel cycles than accessing a local variable.  The algorithm itself is as follows: for each point, if it is not the last in the hair, we calculate the force acting between it and the next point.  On the basis of this force, we record the change in speed at each of the points. <br><br>  Here is an important feature of parallel computation: each stream modifies two points, the current and the next, which means that each point is modified by two parallel streams.  Unprotected writing to common for parallel streams is extremely fraught with data loss.  If you use the normal increment: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">variable</span></span> += <span class="hljs-selector-tag"><span class="hljs-selector-tag">value</span></span>;</code> </pre> <br>  then the recording can occur at the same time, like this: the first stream will copy the original value, add one to it, but before it writes the value back to the memory cell, the second stream will take the original value.  Then the first thread will write back the incremented value.  Then the second stream will add its unit and write the increased value back.  Result: although two streams were added one at a time, the variable increased only by one unit.  To avoid this situation, use a secure entry.  HLSL has several functions for protected modification of generalized variables.  They guarantee that the data will not be lost and the contribution of each stream will be taken into account. <br><br>  A minor problem is that these functions work only with integer variables.  And that is why in the structure describing the state of the point we use the dvx and dvy parameters of the int type.  That there was an opportunity to write in them by means of the protected functions and not to lose data.  But in order not to lose accuracy on rounding, we pre-determined the multipliers.  One translates float into int, the other back.  So we use the entire dianazon int-value, and do not lose exactly (we lose, of course, but negligible). <br><br>  The secure entry looks like this: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">InterlockedAdd</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodeIndex]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.dvx</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">F_TO_I</span></span> * (<span class="hljs-selector-tag"><span class="hljs-selector-tag">dv</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span> + 2 * <span class="hljs-selector-tag"><span class="hljs-selector-tag">dvFlex</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>))); <span class="hljs-selector-tag"><span class="hljs-selector-tag">InterlockedAdd</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodeIndex]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.dvy</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">F_TO_I</span></span> * (<span class="hljs-selector-tag"><span class="hljs-selector-tag">dv</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> + 2 * <span class="hljs-selector-tag"><span class="hljs-selector-tag">dvFlex</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span>))); <span class="hljs-selector-tag"><span class="hljs-selector-tag">InterlockedAdd</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodeIndex2]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.dvx</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">F_TO_I</span></span> * (<span class="hljs-selector-tag"><span class="hljs-selector-tag">-dv</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dvFlex</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>))); <span class="hljs-selector-tag"><span class="hljs-selector-tag">InterlockedAdd</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">hairNodesBuffer</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodeIndex2]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.dvy</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">F_TO_I</span></span> * (<span class="hljs-selector-tag"><span class="hljs-selector-tag">-dv</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dvFlex</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span>)));</code> </pre> <br>  Here F_TO_I is the aforementioned coefficient for the projection of float on int, dv is the force vector of the influence of the second particle on the first through the spring connection.  And dvFlex - straightening force.  "(int)" needs to be added because InterlockedAdd () is overloaded for int and uint types, and the float is interpreted as uint by default. <br><br>  VelShare Kernel is similar to the previous one, it also modifies the dvx and dvy parameters of two adjacent points, but instead of calculating the forces, the diffusion of the relative velocity is calculated. <br><br>  In the interactionWithColliders kernel, the points do not interact with each other, here each point runs through all colliders of the solid bodies buffer (which we update in each update).  That is, each stream writes only to one particle, there is no danger of simultaneous recording, and therefore instead of InterlockedAdd () we can directly change the speed of the particle.  But at the same time, our model implies that the points transfer momentum to the collider.  This means that parallel streams can simultaneously change the magnitude of the impulse of the same collider, which means that we use a protected version of the record. <br><br>  Only here it is necessary to understand: when we project a float on an int, the whole and fractional parts compete with us.  Accuracy competes with a range of magnitude.  For the case of the interaction of points, we chose a coefficient that allows for a sufficient variation of the magnitude for us, and let the rest be for accuracy.  But this coefficient is not suitable for the transfer of momentum to the collider, because at the same time hundreds of points can add their momentum in one direction, and therefore one must sacrifice accuracy in favor of the ability to hold a large number.  So with secure recording, we do not use the F_TO_I coefficient, but use a smaller coefficient. <br><br>  After all interactions of points are calculated, we in the ‚ÄúcalcApply‚Äù kernel add the impulse to the speed, and the speed to the coordinates.  In addition, in this kernel, each root (first in a row) point of the hair is fixed in a certain place relative to the current position of the entire hair system.  Even in this kernel, the contribution of gravity is added to the vertical component of the velocity.  Plus, ‚Äúbraking‚Äù on the air is realized, that is, the absolute value of the speed of each point is multiplied by a factor slightly less than one. <br><br>  Note that in the calcApply kernel, the speed affects the coordinates through the dPosRate coefficient.  It determines the size of the simulation step.  This factor is set on the CPU side and is stored in a variable, which I called ‚Äúsimulation Speed‚Äù.  The larger this parameter, the faster the system will evolve over time.  But the lower will be the accuracy of the calculation.  The accuracy of the calculation, I repeat, limits the magnitude of the forces, since with large forces and low accuracy the magnitude of the error is so great that it determines the behavior of the model.  We took the modeling speed rather low, it gives us greater accuracy, so we can afford more power, which means more realistic model behavior. <br><br>  The magnitude of the forces corresponds to the coefficient associating the effect of the pulse on speed - ‚ÄúdVelRate‚Äù.  This factor is large, it is set on the CPU side and is called ‚ÄústrengthOfForces‚Äù. <br><br>  I repeat that in all the mentioned kernels the number of threads is equal to the number of points, one stream is responsible for processing one point.  And this is a good practice.  We do not pay for the number of threads, there can be as many as you want (in shader model 5.0 - no more than 1024 on the x and y axes and no more than 64 on the z axis).  In the tradition of parallel computing, it is better to avoid using cycles to perform one operation in a single stream with respect to several data units; it‚Äôs better to make as many streams as is required to implement the principle ‚Äúone data unit - one stream‚Äù. <br><br>  Let's go back to the doShaderStuff () method on the CPU code side.  After completing the cycle of 40 steps of calculating the hair model, we read the data of the collider: <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">circleCollidersBuffer</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.GetData</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">circleCollidersArray</span></span>);</code> </pre> <br>  It may be recalled that on the GPU side, impulses from the hair side are written into the buffer with the collider data, and we use them on the CPU side to apply force to rigidbody.  Note that the force to the rigidbody is applied in the FixedUpdate () method, since it is synchronized with physics.  In this case, the pulse data is updated in Update ().  So, under the influence of various factors, during one Update () several FixedUpdate () can occur and vice versa.  That is, in the influence of hair on the collider there is no absolute accuracy, part of the data can be overwritten before it has an impact, and other data can have an impact twice.  Measures can be taken to prevent this from happening, but these measures are not taken in the program under consideration. <br><br>  It is worth noting here that the GetData () method suspends the work of the graphics pipeline, which causes a noticeable slowdown.  Unfortunately, the asynchronous version of this method in the unit has not yet been implemented, although it is rumored that it will appear in 2018.  In the meantime, you need to understand that if in your task you need to copy data from the GPU to the CPU, the program will run 20-30% slower.  At the same time, the SetData () method has no such effect, it works quickly. <br><br><h2>  Visualization </h2><br>  ,    doShaderStuff(),      . <br><br>  ,   . <br>   CPU    RenderTexture,    enableRandomWrite = true,      mainTexture   UI- Image. <br><br>     ,      ,    SetTexture(),     RenderTexture     : <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">RenderTexture</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">renderTexture</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">renderTexture</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">RenderTexture</span></span>(1024, 1024, 32); <span class="hljs-selector-tag"><span class="hljs-selector-tag">renderTexture</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.enableRandomWrite</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">renderTexture</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Create</span></span>(); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GameObject</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Find</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">canvas</span></span>/<span class="hljs-selector-tag"><span class="hljs-selector-tag">image</span></span>")<span class="hljs-selector-class"><span class="hljs-selector-class">.GetComponent</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">UnityEngine</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UI</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Image</span></span>&gt;()<span class="hljs-selector-class"><span class="hljs-selector-class">.material</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.mainTexture</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">renderTexture</span></span>; _<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetTexture</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">kiPixelsToTexture</span></span>, "<span class="hljs-selector-tag"><span class="hljs-selector-tag">renderTexture</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">renderTexture</span></span>);</code> </pre> <br>         RWTexture2D,        : <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">RWTexture2D</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">float4</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">renderTexture</span></span>;</code> </pre> <br>     ,        : <br><br><pre> <code class="css hljs"><span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">kernel</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">clearTexture</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[numthreads(32,32,1)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">clearTexture</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">uint3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">id</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">SV_DispatchThreadID</span></span>){ renderTexture[id.xy] = float4(0, 0, 0, 0); }</code> </pre> <br>    : <br><br><pre> <code class="css hljs">_<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Dispatch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">kiClearTexture</span></span>, 32, 32, 1);</code> </pre> <br>  ,    1024 x 1024 ,    .  :    id.xy   . <br><br>    ?     ,        ,       ,          , ,      ,          ,   .   :        .        ,  ,       :           . <br><br>    ,       ,    .  -  ,    . <br><br>  ,   ¬´visInternodeLines¬ª   ,       .     ,    .     ,    RWStructuredBuffer    RWStructuredBuffer      4     uint. <br><br> ,    RenderTexture    ,      ¬´¬ª     . <br><br>        compute shader,  , ,    . <br><br>  ,   ¬´pixelsToTexture¬ª  ,        . <br><br>      ,    GPU.     ,       .       ,       ,     .    .      . <br><br>     ,        .   CPU  ,     ,  ,       ,     . </div><p>Source: <a href="https://habr.com/ru/post/346268/">https://habr.com/ru/post/346268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346258/index.html">Writing a Python clicker bot for Lineage 2</a></li>
<li><a href="../346260/index.html">Calculations on the video card, manual, easy level</a></li>
<li><a href="../346262/index.html">Apache Ignite vs Oracle DBMS</a></li>
<li><a href="../346264/index.html">Technical Debt Management</a></li>
<li><a href="../346266/index.html">The effect of group polarization and its mathematical modeling</a></li>
<li><a href="../346270/index.html">We work with smart cards using Python (part 1)</a></li>
<li><a href="../346272/index.html">"Simple" python programming</a></li>
<li><a href="../346274/index.html">Web installer on pure WINAPI with Hi DPI support and vector logo</a></li>
<li><a href="../346276/index.html">Developing a cool GUI on esp8266 with the uGFX library</a></li>
<li><a href="../346284/index.html">We select passwords using Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>