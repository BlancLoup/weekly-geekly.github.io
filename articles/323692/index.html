<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Universal grammar analyzer of natural languages ‚Äã‚Äãfrom scratch. Release 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Compilers, interpreters ... How many books and projects are dedicated to them! Basta, tired! But sushussya in the analysis of natural languages, and n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Universal grammar analyzer of natural languages ‚Äã‚Äãfrom scratch. Release 1</h1><div class="post__text post__text-html js-mediator-article">  Compilers, interpreters ... How many books and projects are dedicated to them!  Basta, tired!  But sushussya in the analysis of natural languages, and no information!  And all that is somehow very difficult, incomprehensible and not universal.  I had the idea to create a medieval linguistic novel.  So that you can talk to the characters in some ancient natural or fictional language.  In Latin for example?  And on Quenya.  And so they understand.  Why not? <br><a name="habracut"></a><br>  For all this, you need: <br><br>  1) Develop a format for describing the grammar of an arbitrary language. <br>  2) Write grammar for Quenya and Latin. <br>  3) Develop a universal grammar analyzer and parser. <br>  4) Make the connection between the behavior of the characters and the parser. <br><br>  For example, the phrase ‚ÄúLegolas, go to the tree‚Äù would be interpreted as: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The verb script ‚Äúgo‚Äù is launched, the Legolas is transmitted as the action subject (by searching by tag we find the game object), the time (imperative) is indicated, which, without additional waiting conditions, causes the action subject to go to the position of the action object. <br><br>  In this series of articles, we will develop a grammar analyzer from scratch to a completely stable version already on the githab (link at the end of the article): <br><br>  1) Design the analyzer architecture <br>  2) Develop a language for describing grammar summaries (so that ordinary linguists could write on it) <br>  3) Let's teach our analyzer to read reports <br>  4) Teach the analyzer on the basis of grammar summaries to analyze the text <br><br>  The analyzer code will be: <br>  1) Quality <br>  2) Expandable <br>  3) Easily maintained <br>  4) Pleasant to read <br><br>  The analyzer can be used: <br>  1) From the command line <br>  2) Remotely or locally, via RPC <br><br>  You think it will be unreal a lot of code?  If we wrote it in C ++, we would really have had little, but in the next issue, in secret, I will tell you about a very pleasant, concise and concise language in which you can write such a project in 2 months (in the evenings). <br>  So, let's begin! <br><br>  First, let's think about what the grammar description language should look like?  Following the remarkable principles of SOLID, we fully move on to abstraction.  What abstractions can be distinguished in linguistics?  I selected a whole 'sheet': <br><br>  L) Alphabet L (character set) <br>  E) Essence E (verb, noun, etc.) <br>  A) Attributes A (time, mood, etc.) <br>  F) Comparison rule F (how to get its characteristics by a word) <br><br><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>F</mi><mo>:</mo><mi>L</mi><mo>&amp;#x2212;</mo><mo>&amp;gt;</mo><mi>E</mi><mo>&amp;#x2217;</mo><mi>A</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.881ex" height="2.178ex" viewBox="0 -780.1 6837.6 937.7" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/323692/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgDIlzfIo1iVBjrIvr_NV95HHZ_GA#MJMATHI-46" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/323692/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgDIlzfIo1iVBjrIvr_NV95HHZ_GA#MJMAIN-3A" x="1027" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/323692/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgDIlzfIo1iVBjrIvr_NV95HHZ_GA#MJMATHI-4C" x="1583" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/323692/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgDIlzfIo1iVBjrIvr_NV95HHZ_GA#MJMAIN-2212" x="2265" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/323692/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgDIlzfIo1iVBjrIvr_NV95HHZ_GA#MJMAIN-3E" x="3321" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/323692/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgDIlzfIo1iVBjrIvr_NV95HHZ_GA#MJMATHI-45" x="4377" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/323692/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgDIlzfIo1iVBjrIvr_NV95HHZ_GA#MJMAIN-2217" x="5364" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/323692/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgDIlzfIo1iVBjrIvr_NV95HHZ_GA#MJMATHI-41" x="6087" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mo>:</mo><mi>L</mi><mo>‚àí</mo><mo>&gt;</mo><mi>E</mi><mo>‚àó</mo><mi>A</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> F: L -> E * A </script><br><br>  Therefore, our analyzer will operate on these abstractions. <br><br><h3>  The specification of the language "Ololo". </h3><br>  In the repository there are summaries for the languages ‚Äã‚ÄãQuenya (well developed) and for Lingua Latina (very little).  But we will write a summary for the simple fictional alien language "Ololo".  You can find it in the same place.  Open the etc / al / tpl specification: <br><br>  0) Alphabet. <br>  0.1) Class (a, o, u). <br>  0.2) Consonants (l). <br><br><pre> <code class="hljs coffeescript"><b>etc<span class="hljs-regexp"><span class="hljs-regexp">/al/tpl/verb.tpl.txt</span></span></b><span class="hljs-regexp"><span class="hljs-regexp"> /</span></span>* * It<span class="hljs-string"><span class="hljs-string">'s time to introduce your experimental '</span></span>lol<span class="hljs-string"><span class="hljs-string">' language. * The '</span></span>lol<span class="hljs-string"><span class="hljs-string">' language has only two verb: '</span></span>ololoo<span class="hljs-string"><span class="hljs-string">' and '</span></span>olalaa<span class="hljs-string"><span class="hljs-string">'. * The infinitive coinsides to vocabular stem. * Present time of the verb forms by shorthening of the last vowel. * Past time forms by replacing of the first vowel '</span></span>o<span class="hljs-string"><span class="hljs-string">' to any other vowel. */</span></span></code> </pre><br>  1) We have two verbs (ololoo, olalaa). <br>  1.1) The present tense is formed by the contraction of the last vowel (ololo, olala). <br>  1.2) The past tense is formed by replacing the initial vowel with any other vowel (ulolloo, alallaa). <br><br><pre> <code class="hljs coffeescript"><b>etc<span class="hljs-regexp"><span class="hljs-regexp">/al/tpl/noun.tpl.txt</span></span></b><span class="hljs-regexp"><span class="hljs-regexp"> /</span></span>* * It<span class="hljs-string"><span class="hljs-string">'s time to introduce your experimental '</span></span>lol<span class="hljs-string"><span class="hljs-string">' language. * The '</span></span>lol<span class="hljs-string"><span class="hljs-string">' language has only one noun: '</span></span>ll<span class="hljs-string"><span class="hljs-string">'. * But there are small assumption: between two consonants can be places * arbitrary count of arbitrary vowels. */</span></span></code> </pre><br>  2) We have one noun (ll, lol, lool, luol, ...) without declensions. <br><br><pre> <code class="hljs coffeescript"><b>etc<span class="hljs-regexp"><span class="hljs-regexp">/al/tpl/prep.tpl.txt</span></span></b><span class="hljs-regexp"><span class="hljs-regexp"> /</span></span>* * It<span class="hljs-string"><span class="hljs-string">'s time to introduce your experimental '</span></span>lol<span class="hljs-string"><span class="hljs-string">' language. * The '</span></span>lol<span class="hljs-string"><span class="hljs-string">' language has only two preposition: '</span></span>ao<span class="hljs-string"><span class="hljs-string">' and '</span></span>oa<span class="hljs-string"><span class="hljs-string">'. * But there are small assumption: adjacent prepositions can be concatenated. */</span></span></code> </pre><br>  3) We have two prepositions (ao, oa). <br>  3.1) Related prepositions in the text are glued together (ao oa -&gt; aooa). <br><br><pre> <code class="hljs coffeescript"><b>etc<span class="hljs-regexp"><span class="hljs-regexp">/al/tpl/adj.tpl.txt</span></span></b><span class="hljs-regexp"><span class="hljs-regexp"> /</span></span>* * It<span class="hljs-string"><span class="hljs-string">'s time to introduce your experimental '</span></span>lol<span class="hljs-string"><span class="hljs-string">' language. * The '</span></span>lol<span class="hljs-string"><span class="hljs-string">' language has only two adjective: '</span></span>lo<span class="hljs-string"><span class="hljs-string">' and '</span></span>ol<span class="hljs-string"><span class="hljs-string">'. * If adjective ends with consonant - it is consonant declension AD.C (ol). * If adjective ends with vowel - it is vowel declension AD.V (lo). * If adjective has not additional endings - it has singular number. * Plural number forms like this: * For AD.C by adding vowel '</span></span>a<span class="hljs-string"><span class="hljs-string">' * For AD.V by adding suffix '</span></span>la<span class="hljs-string"><span class="hljs-string">' * Superlative A.sup. and comparative A.cmp. are formed like this: * A.sup. by prefix '</span></span>al<span class="hljs-string"><span class="hljs-string">' * A.cmp. exists only for adjective starts with consonant and * forms by appending any short vowel (wildcard @ from '</span></span>etc.tpl.txt<span class="hljs-string"><span class="hljs-string">') * at the beggining of the word. * Superlative and comparative forms plural number on it'</span></span>s own manner. * Only adjectives ends with vowel can form plural A.sup. <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> A.cmp. <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> * appending the <span class="hljs-string"><span class="hljs-string">'lolo'</span></span> suffix to the end <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the word. */</code> </pre><br>  4) We have two adjectives (lo, ol) of different declinations. <br>  4.1) The plural (lo -&gt; lola, ol -&gt; ola), respectively. <br>  4.2) Superlatives (lo -&gt; allo, ol -&gt; alol). <br>  4.3) Comparative for only one declination (lo -&gt; alo, ulo, olo). <br>  4.4) Plural for only one declension (lo -&gt; lololo). <br><br><h3>  Competition.  Learning poetry aliens. </h3><br>  <i>ll ololo</i> - Simple sentence (1 grammatical basis). <br>  <i>lol ulalaa oa lul olala allololo</i> - Complex sentence (2 grammatical bases). <br><br>  Competition: think up an initial translation of the above dictionary forms and write the most beautiful and sonorous eighth in the language of ‚ÄúOlolo‚Äù (observing all the rules of the grammar described above).  The offer is valid for 2 weeks from the date of publication of the article. <br>  Answers write in the comments and be sure to duplicate to the address apborezkiy@gmail.com, indicating the topic "ACC # 1". <br>  The winner will be announced in subsequent articles and will receive a free Skype consultation on any of the topics in which I can be something useful. <br><br><h3>  Development through testing. </h3><br>  Using the principle of TDD, we first prepare test material for our analyzer. <br><br><div class="spoiler">  <b class="spoiler_title">var / test.tpl / test.in</b> <div class="spoiler_text"><pre> oa / * preposition * /
 aooaaooa / * concatenated preposition * /

 loool / * noun * /
 ll / * noun * /

 ololoo / * verb infinitive * /
 olalaa / * verb infinitive * /
 ulalaa / * verb past time * /
 uloloo / * verb past time * /
 ololo / * verb present time * /
 olala / * verb present time * /

 lo / * singular adjective vowel declension * /
 ol / * singular adjective consonant declension * /
 lola / * plural adjective vowel declension * /
 ola / * plural adjective consonant declension * /
 allo / * singular superlative adjective vowel declension * /
 alol / * singular superlative adjective consonant declension * /
 ulo / * singular comparative adjective vowel declension * /
 allololo / * plural superlative adjective vowel declension * /
 ulololo / * plural comparative adjective vowel declension * /
</pre></div></div><br>  Looking ahead, I will say that we will teach our analyzer to issue at the output such a detailed analysis: <br><br><div class="spoiler">  <b class="spoiler_title">var / test.tpl / test.out</b> <div class="spoiler_text"><pre> oa {
   preposition {/ * 1.4.1.1.1.1.1.100.  * /
     pars_orationis = p.  / * preposition * /
     {
       mp_prep = oa / * voc_prepositions * /
     }
   }
 }
 aooaaooa {
   preposition {/ * 1.4.1.1.1.2.1.2.1.1.2.1.2.1.1.2.1.2.1.1.1.1.100.100.100.100.  * /
     pars_orationis = p.  / * preposition * /
     {
       mp_prep = oa / * voc_prepositions * /
       mp_prep = ao / * voc_prepositions * /
       mp_prep = oa / * voc_prepositions * /
       mp_prep = ao / * voc_prepositions * /
     }
   }
 }
 loool {
   noun {/ * 1.2.1.1.1.2.1.2.2.1.2.1.1.3.1.1.2.2.100.  * /
     pars_orationis = n.  / * noun * /
     {
       mn_stem = ll / * voc_nouns * /
       / * mn_vowel_left = ooo * /
       / * mn_vowel_left = o * /
       / * mn_vowel_left * /
       / * mn_vowel_right * /
     }
   }
 }
 ll {
   noun {/ * 1.2.1.1.1.1.1.3.1.1.2.100.  * /
     pars_orationis = n.  / * noun * /
     {
       mn_stem = ll / * voc_nouns * /
       / * mn_vowel_left * /
       / * mn_vowel_right * /
     }
   }
 }
 ololoo {
   verb {/ * 1.3.1.1.1.1.1.2.100.  * /
     pars_orationis = vb.  / * verb * /
     mvb_time = V.inf.  / * infinitive *
     {
       mvb_stem = ololoo / * voc_verbs * /
       / * mvb_time_past * /
     }
   }
 }
 olalaa {
   verb {/ * 1.3.1.2.2.1.1.1.100.  * /
     pars_orationis = vb.  / * verb * /
     mvb_time = V.inf.  / * infinitive *
     {
       mvb_stem = olalaa / * voc_verbs * /
       / * mvb_time_present * /
     }
   }
 }
 ulalaa {
   verb {/ * 1.3.1.1.1.2.1.2.100.  * /
     mvb_time = Vp / * past time * /
     pars_orationis = vb.  / * verb * /
     {
       mvb_stem = olalaa / * voc_verbs * /
       / * mvb_time_past = o * /
     }
   }
 }
 uloloo {
   verb {/ * 1.3.1.1.1.2.1.2.100.  * /
     mvb_time = Vp / * past time * /
     pars_orationis = vb.  / * verb * /
     {
       mvb_stem = ololoo / * voc_verbs * /
       / * mvb_time_past = o * /
     }
   }
 }
 ololo {
   verb {/ * 1.3.1.2.2.2.1.1.100.  * /
     mvb_time = V.pr.  / * present time * /
     pars_orationis = vb.  / * verb * /
     {
       mvb_stem = ololoo / * voc_verbs * /
       / * mvb_time_present = oo * /
     }
   }
 }
 olala {
   verb {/ * 1.3.1.2.2.2.1.1.100.  * /
     mvb_time = V.pr.  / * present time * /
     pars_orationis = vb.  / * verb * /
     {
       mvb_stem = olalaa / * voc_verbs * /
       / * mvb_time_present = aa * /
     }
   }
 }
 lo {
   adjective {/ * 1.1.1.1.1.3.1.3.2.1.2.100.  * /
     aa_number = A.sg.  / * singular number * /
     pars_orationis = adj.  / * adjective *
     {
       ma_stem = lo / * voc_adjectives * /
       / * ma_degree * /
       / * ma_number * /
     }
   }
 }
 ol {
   adjective {/ * 1.1.1.1.1.3.1.3.1.1.2.100.  * /
     aa_number = A.sg.  / * singular number * /
     pars_orationis = adj.  / * adjective *
     {
       ma_stem = ol / * voc_adjectives * /
       / * ma_degree * /
       / * ma_number * /
     }
   }
 }
 lola {
   adjective {/ * 1.1.1.1.1.3.1.3.4.1.2.100.  * /
     aa_degree = A.no.  / * no special degree * /
     aa_number = A.pl.  / * plural number * /
     pars_orationis = adj.  / * adjective *
     {
       ma_stem = lo / * voc_adjectives * /
       / * ma_degree * /
       / * ma_number = la * /
     }
   }
 }
 ola {
   adjective {/ * 1.1.1.1.1.3.1.3.3.1.2.100.  * /
     aa_number = A.pl.  / * plural number * /
     aa_degree = A.no.  / * no special degree * /
     pars_orationis = adj.  / * adjective *
     {
       ma_stem = ol / * voc_adjectives * /
       / * ma_degree * /
       / * ma_number = a * /
     }
   }
 }
 allo {
   adjective {/ * 1.1.1.1.1.1.1.3.2.2.2.100.  * /
     aa_number = A.sg.  / * singular number * /
     pars_orationis = adj.  / * adjective *
     aa_degree = A.sup.  / * superlative * /
     {
       ma_stem = lo / * voc_adjectives * /
       / * ma_degree = al * /
       / * ma_number * /
     }
   }
 }
 alol {
   adjective {/ * 1.1.1.1.1.1.1.3.1.1.2.100.  * /
     aa_number = A.sg.  / * singular number * /
     pars_orationis = adj.  / * adjective *
     aa_degree = A.sup.  / * superlative * /
     {
       ma_stem = ol / * voc_adjectives * /
       / * ma_degree = al * /
       / * ma_number * /
     }
   }
 }
 ulo {
   adjective {/ * 1.1.1.1.1.2.1.3.2.1.2.100.  * /
     aa_number = A.sg.  / * singular number * /
     aa_degree = A.cmp.  / * comparative * /
     pars_orationis = adj.  / * adjective *
     {
       ma_stem = lo / * voc_adjectives * /
       / * ma_degree = ul * /
       / * ma_number * /
     }
   }
 }
 allololo {
   adjective {/ * 1.1.1.1.1.1.1.3.5.1.2.100.  * /
     aa_number = A.pl.  / * plural number * /
     pars_orationis = adj.  / * adjective *
     aa_degree = A.sup.  / * superlative * /
     {
       ma_stem = lo / * voc_adjectives * /
       / * ma_degree = al * /
       / * ma_number = lolo * /
     }
   }
 }
 ulololo {
   adjective {/ * 1.1.1.1.1.2.1.3.5.1.2.100.  * /
     aa_degree = A.cmp.  / * comparative * /
     aa_number = A.pl.  / * plural number * /
     pars_orationis = adj.  / * adjective *
     {
       ma_stem = lo / * voc_adjectives * /
       / * ma_degree = ul * /
       / * ma_number = lolo * /
     }
   }
 }
</pre></div></div><br>  Numbers mean a chain of rules (horizontal and vertical).  It is very convenient to track the sequence of analysis. <br><br><h3>  We write our first summary. </h3><br><h4>  Alphabet </h4><br>  So what will the bulletin description language contain?  First, the alphabet in the style of OOP. <br>  Reserved lexemes are: <br>  1) .alphabet - Indicates the beginning of the alphabet description <br>  2) .base - Indicates the parent alphabet <br>  3) = "" {} <br><br><pre> <code class="hljs cs"><b>etc/al/tpl/etc.tpl.txt</b> .alphabet short_vowel { a = <span class="hljs-string"><span class="hljs-string">"vowel (a)"</span></span> o = <span class="hljs-string"><span class="hljs-string">"vowel (o)"</span></span> u = <span class="hljs-string"><span class="hljs-string">"vowel (u)"</span></span> } .alphabet long_vowel { aa = <span class="hljs-string"><span class="hljs-string">"long vowel (a)"</span></span> oo = <span class="hljs-string"><span class="hljs-string">"long vowel (o)"</span></span> } .alphabet vowel .<span class="hljs-keyword"><span class="hljs-keyword">base</span></span> short_vowel long_vowel { } .alphabet consonant { l = <span class="hljs-string"><span class="hljs-string">"consonant l"</span></span> } .alphabet phoneme .<span class="hljs-keyword"><span class="hljs-keyword">base</span></span> vowel consonant { }</code> </pre><br><h4>  Hierarchy of linguistic entities </h4><br>  Secondly, the description of entities (parts of speech) and their attributes. <br>  Reserved lexemes are: <br>  1) .attribute - Indicates the beginning of the attribute description. <br>  2) .class - Indicates the beginning of the description of the entity. <br>  3) = "" {} <br><br><pre> <code class="hljs pgsql"><b>etc/al/tpl/lang.tpl.txt</b> .<span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> pars_orationis <span class="hljs-number"><span class="hljs-number">0</span></span> { n. = "noun" adj. = "adjective" vb. = "verb" p. = "preposition" }</code> </pre><br><pre> <code class="hljs pgsql"><b>etc/al/tpl/verb.tpl.txt</b> .<span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> mvb_time <span class="hljs-number"><span class="hljs-number">1</span></span> { V.inf. = "infinitive" V.pr. = "present time" Vp = "past time" } .<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> verb { pars_orationis mvb_time }</code> </pre><br><pre> <code class="hljs swift"><b>etc/al/tpl/noun.tpl.txt</b> .<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> noun { pars_orationis }</code> </pre><br><pre> <code class="hljs swift"><b>etc/al/tpl/prep.tpl.txt</b> .<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> preposition { pars_orationis }</code> </pre><br><pre> <code class="hljs pgsql"><b>etc/al/tpl/adj.tpl.txt</b> .<span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> aa_declension <span class="hljs-number"><span class="hljs-number">1</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">verbose</span></span> { AD.C = "consonant declension" AD.V = "vovel declension" } .<span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> aa_number <span class="hljs-number"><span class="hljs-number">2</span></span> { A.sg. = "singular number" A.pl. = "plural number" } .<span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> aa_degree <span class="hljs-number"><span class="hljs-number">3</span></span> { A.<span class="hljs-keyword"><span class="hljs-keyword">no</span></span>. = "no special degree" A.sup. = "superlative" A.cmp. = "comparative" } .<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> adjective { pars_orationis aa_declension aa_number aa_degree }</code> </pre><br>  The number after the attribute name will indicate the order in which the attribute is displayed in the output file (for clarity). <br><br><h4>  Vocabulary </h4><br>  It's time to enter the dictionary: <br><br><pre> <code class="hljs"><b>etc/al/tpl/voc.tpl.txt</b> .vocabulary voc_adjectives { lo adj. AD.V ol adj. AD.C } .vocabulary voc_nouns { ll n. } .vocabulary voc_prepositions { ao p. oa p. } .vocabulary voc_verbs { ololoo vb. olalaa vb. }</code> </pre><br>  Reserved lexemes are: <br>  1) .vocabulary - Indicates the beginning of the description of the dictionary. <br>  2) {} <br><br>  Here, each dictionary entry is associated with an entity and a set of attributes.  Remember our magic formula? <br><br><h4>  Wildcard characters </h4><br>  You also need to enter the wildcard characters (aliases) that will be used in mutations and matching rules. <br><br><pre> <code class="hljs objectivec"><b>etc/al/tpl/etc.tpl.txt</b> .wildcard . phoneme .wildcard * vowel .wildcard <span class="hljs-meta"><span class="hljs-meta"># consonant .wildcard @ short_vowel</span></span></code> </pre><br>  Here we set the wildcards for our alphabets, which we described above. <br>  Now we need to describe the transformations (mutations) that occur in words. <br><br><pre> <code class="hljs delphi"><b>etc/al/tpl/etc.tpl.txt</b> .mutation longify_vowel <span class="hljs-comment"><span class="hljs-comment">{ a = aa o = oo }</span></span> .mutation change_vowel_to_o <span class="hljs-comment"><span class="hljs-comment">{ * = o }</span></span></code> </pre><br>  Reserved lexemes are: <br>  1) .mutation - Indicates the beginning of the description of the transformation. <br>  2) {} <br>  3) = <br><br>  On the left, in mutations, you can write both alphabet characters and wildcard characters. <br>  And now the wildcards themselves for our mutations: <br><br><pre> <code class="hljs"><b>etc/al/tpl/etc.tpl.txt</b> .wildcard (a&gt;aa,o&gt;oo) longify_vowel .wildcard (*&gt;o) change_vowel_to_o</code> </pre><br><h4>  Matching rules </h4><br>  It remains the most difficult.  Matching rules  The idea is similar to a dictionary, but instead of dictionary forms, a mask with wildcard and alphabet characters is used. <br>  Rules for matching nouns. <br><br><pre> <code class="hljs scala"><b>etc/al/tpl/voc.tpl.txt</b> .vocabular .inward mn_stem voc_nouns .<span class="hljs-keyword"><span class="hljs-keyword">match</span></span> .forward mn_vowel_left { =## =#+* mn_vowel_left } .<span class="hljs-keyword"><span class="hljs-keyword">match</span></span> .backward mn_vowel_right { =## mn_vowel_right +*=# } .<span class="hljs-keyword"><span class="hljs-keyword">match</span></span> .inward-void m_noun { mn_vowel_left mn_stem mn_vowel_right | n. noun }</code> </pre><br>  Reserved lexemes are: <br>  1) .match - Indicates the beginning of the description of the matching rule. <br>  2) .backward - The mask begins to match at the end of the word (convenient for suffixes and endings). <br>  2) .forward - The mask starts to match from the beginning of the word (convenient for prefixes). <br>  3) .inward-void - First from the end, then first, and so on to the vocabulary base. <br>  4) |  - After the vertical bar, the corresponding characteristics of the word, suitable under the mask, begin. <br>  five) {} <br>  6) + - = <br><br>  The mask of the word is indicated on the left, on the right - the attributes or entity to which this mask corresponds.  A mask consists of a sequence of rules, which can be either an independent rule, or a combination of wildcard characters with alphabet characters and with special signs "+", "-", "=". <br>  We write the collation rules specification: <br><br><pre> <code class="hljs ruby"><b>etc/al/tpl/adj.tpl.txt</b> /* * Match specification is the powerful easy mechanism <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> words recognision. * Each regular match expression has <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-symbol"><span class="hljs-symbol">mode:</span></span> * * <span class="hljs-string"><span class="hljs-string">'='</span></span> match <span class="hljs-symbol"><span class="hljs-symbol">mode:</span></span> * only comparation. * <span class="hljs-string"><span class="hljs-string">'+'</span></span> rift <span class="hljs-symbol"><span class="hljs-symbol">mode:</span></span> * comparation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rifting from subword copy, * appending detached part to rule <span class="hljs-string"><span class="hljs-string">'value'</span></span> field that could be * found <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the output generated files. * <span class="hljs-string"><span class="hljs-string">'-'</span></span> hold mode (comparation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> holding) * comparation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> holding (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> detaching), * appending holded part to rule <span class="hljs-string"><span class="hljs-string">'value'</span></span> field that could be * found <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the output generated files. * * Also regular expressions supports negotiation of the single <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> character * <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> wildcard (wildcard can has arbitrary name length) through the preceding * reserved symbol <span class="hljs-string"><span class="hljs-string">'~'</span></span>. * * <span class="hljs-symbol"><span class="hljs-symbol">Examples:</span></span> /* meaning *<span class="hljs-regexp"><span class="hljs-regexp">/ * =~a /</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span> *<span class="hljs-regexp"><span class="hljs-regexp">/ * =~ab /</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span> followed by <span class="hljs-string"><span class="hljs-string">'b'</span></span> *<span class="hljs-regexp"><span class="hljs-regexp">/ * =~a~b /</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span> followed by <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span> *<span class="hljs-regexp"><span class="hljs-regexp">/ * =~# /</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> any phoneme from wildcard <span class="hljs-string"><span class="hljs-string">'#'</span></span> consistent alphabet tree *<span class="hljs-regexp"><span class="hljs-regexp">/ */</span></span></code> </pre><br><h4>  Parse the rules for matching nouns </h4><br>  Now how it all works.  On the example of nouns. <br><br><pre> <code class="hljs objectivec">.match .inward-<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> m_noun { mn_vowel_left mn_stem mn_vowel_right | n. noun }</code> </pre><br>  First, from the end, the rule ‚Äúm_noun‚Äù is considered, which immediately passes into consideration of the matching rule ‚Äúfrom the end‚Äù - ‚Äúmn_vowel_right‚Äù, which looks like this: <br><br><pre> <code class="hljs objectivec">.match .backward mn_vowel_right { =<span class="hljs-meta"><span class="hljs-meta">## mn_vowel_right +*=# }</span></span></code> </pre><br>  The first mask is checked "= ##".  First there is a pointer to the banal character-by-character comparison mode "=".  Behind her are two of our above wildcard characters "#", meaning two consonants.  So, at the end of the word there should be two consonants, the rule ends here. <br>  Consider an alternative course of events ‚Äúmn_vowel_right + * = #‚Äù.  This rule is recursive.  It means that at the end there is a consonant.  After that, before this consonant, we must remove one vowel and write it as the result of this rule.  And do so until we stumble upon the only possible option "= ##".  Those.  all posts that we remove will be the result of ‚Äúmn_vowel_right‚Äù, which we should see in the analysis results. <br><br>  Step by step the rule "mn_vowel_right".  Take for example the word "loolool". <br><table><tbody><tr><td>  Word residue </td><td>  Pattern mapping </td><td>  Result </td></tr><tr><td>  loolool </td><td>  # in compare mode </td><td></td></tr><tr><td>  loolol </td><td>  * in split mode </td><td>  o </td></tr><tr><td>  loolol </td><td>  # in compare mode </td><td>  o </td></tr><tr><td>  looll </td><td>  * in split mode </td><td>  oo </td></tr><tr><td>  looll </td><td>  ## in compare mode </td><td>  oo </td></tr></tbody></table><br>  By the end we got a ‚Äúlooll‚Äù.  It will go further into mn_vowel_left.  Similarly, by the end we get ‚Äúlll‚Äù.  It will go further to mn_stem and will be searched in the dictionary. <br>  Since there is no such word in the dictionary, this chain of rules is considered inappropriate.  But if we took "looool", we would get our vocabulary form of the noun "ll". <br>  C noun figured out.  Fuuuh.  You are not tired yet?  A little rest and it's time to take on the verb. <br><br><h4>  Parse the verb matching rules </h4><br><pre> <code class="hljs scala"><b>etc/al/tpl/verb.tpl.txt</b> .vocabulary voc_verbs ; <span class="hljs-comment"><span class="hljs-comment">/* preemptive declaration, see 'voc.tpl.txt' */</span></span> .vocabular .inward mvb_stem voc_verbs .<span class="hljs-keyword"><span class="hljs-keyword">match</span></span> .backward mvb_time_present { <span class="hljs-comment"><span class="hljs-comment">/* eg */</span></span> =. | <span class="hljs-type"><span class="hljs-type">V</span></span>.inf. <span class="hljs-comment"><span class="hljs-comment">/* '.' is any phoneme ('etc.tpl.txt') */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 1 */</span></span> -(a&gt;aa,o&gt;oo) | <span class="hljs-type"><span class="hljs-type">V</span></span>.pr. <span class="hljs-comment"><span class="hljs-comment">/* ololo -&gt; ololoo, olala -&gt; olalaa */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 2 */</span></span> } .<span class="hljs-keyword"><span class="hljs-keyword">match</span></span> .forward mvb_time_past { <span class="hljs-comment"><span class="hljs-comment">/* eg */</span></span> =. | <span class="hljs-type"><span class="hljs-type">V</span></span>.inf. <span class="hljs-comment"><span class="hljs-comment">/* '.' is any phoneme ('etc.tpl.txt') */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 1 */</span></span> =~o-(*&gt;o) | <span class="hljs-type"><span class="hljs-type">Vp</span></span> <span class="hljs-comment"><span class="hljs-comment">/* eloloo -&gt; ololoo, ulalaa -&gt; olalaa */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 2 */</span></span> } .<span class="hljs-keyword"><span class="hljs-keyword">match</span></span> .inward-void m_verb { mvb_time_past mvb_stem | vb. verb <span class="hljs-comment"><span class="hljs-comment">/* 1 */</span></span> mvb_stem mvb_time_present | vb. verb <span class="hljs-comment"><span class="hljs-comment">/* 2 */</span></span> }</code> </pre><br>  It is much more interesting here, we use the mutations described above to restore the effects of fusions.  For the first time, the ‚Äú-‚Äù hold mode is used, which instead of ‚Äú+‚Äù splitting off keeps the character in place as ‚Äú=‚Äù, but writes it to the result of the rule as ‚Äú+‚Äù. <br>  Let's go from the beginning.  Take the word "ulolloo."  Let's analyze the rules of the past and present times. <br><br>  Rule "mvb_time_past". <br><table><tbody><tr><td>  Word residue </td><td>  Pattern mapping </td><td>  Result </td></tr><tr><td>  ulolloo </td><td></td><td></td></tr><tr><td>  ololloo </td><td>  (*&gt; o) on hold </td><td>  u </td></tr><tr><td>  ololloo </td><td>  not ‚Äúo‚Äù in compare mode </td><td>  u </td></tr></tbody></table><br>  The analyzer considers all possible chains of events, but if there are conflicting characteristics, for example V.inf.  and Vp then this scenario is terminated as impossible. <br><br>  Rule "mvb_time_present".  Take the word "olollo". <br><table><tbody><tr><td>  Word residue </td><td>  Pattern mapping </td><td>  Result </td></tr><tr><td>  olollo </td><td></td><td></td></tr><tr><td>  ololloo </td><td>  (a&gt; aa, o&gt; oo) on hold </td><td>  o </td></tr></tbody></table><br><h4>  Parse the rules for matching adjectives. </h4><br>  Tilde before the characteristic denies it.  "~ A.no."  then in the future, either A.sup. or A.cmp. or nothing is allowed. <br><br><pre> <code class="hljs pgsql">.match .backward ma_number { <span class="hljs-comment"><span class="hljs-comment">/* eg */</span></span> =# | A.sg. AD.C <span class="hljs-comment"><span class="hljs-comment">/* al -&gt; al */</span></span> =* | A.sg. AD.V <span class="hljs-comment"><span class="hljs-comment">/* lo -&gt; lo */</span></span> =#+a | A.pl. AD.C A.<span class="hljs-keyword"><span class="hljs-keyword">no</span></span>. <span class="hljs-comment"><span class="hljs-comment">/* ola -&gt; ol */</span></span> =*+la | A.pl. AD.V A.<span class="hljs-keyword"><span class="hljs-keyword">no</span></span>. <span class="hljs-comment"><span class="hljs-comment">/* lola -&gt; lo */</span></span> =*+lolo | A.pl. AD.V ~ A.<span class="hljs-keyword"><span class="hljs-keyword">no</span></span>. <span class="hljs-comment"><span class="hljs-comment">/* allololo -&gt; allo */</span></span> } .match .forward ma_degree { <span class="hljs-comment"><span class="hljs-comment">/* eg */</span></span> +al | A.sup. <span class="hljs-comment"><span class="hljs-comment">/* allo -&gt; lo, alol -&gt; ol */</span></span> +@-# | A.cmp. <span class="hljs-comment"><span class="hljs-comment">/* ulo -&gt; lo */</span></span> =. | ~ A.sup. ~ A.cmp. <span class="hljs-comment"><span class="hljs-comment">/* '.' is any phoneme wildcard ('etc.tpl.txt') */</span></span> } .match .inward-<span class="hljs-type"><span class="hljs-type">void</span></span> m_adjective { ma_degree ma_stem ma_number | adj. adjective }</code> </pre><br>  Take the word <i>allololo</i> .  Consider the larger steps. <br><table><tbody><tr><td>  Source word </td><td>  Rule </td><td>  Matching pattern matching </td><td>  Result </td><td>  Word residue </td></tr><tr><td>  <i>allololo</i> </td><td>  ma_number </td><td>  "= *" or "= * + lolo" </td><td>  no either "lolo" </td><td>  <i>allololo</i> either <i>allo</i> </td></tr><tr><td>  <i>allololo allo</i> </td><td>  ma_degree </td><td>  "+ al" or "+ @ - #" or "=." </td><td>  ‚ÄúAl‚Äù or ‚Äúal‚Äù or not </td><td>  <i>lololo, lo</i> either <i>llololo, llo</i> or <i>allololo, allo</i> </td></tr><tr><td>  <i>lololo, lo</i> either <i>llololo, llo</i> or <i>allololo, allo</i> </td><td>  ma_stem </td><td>  vocabulary </td><td>  not </td><td>  not </td></tr></tbody></table><br>  Fits only <i>lo</i> .  Thus, we have obtained the only suitable chain of comparisons of characteristics: ‚ÄúA.pl.  AD.V ~ A.no.  A.sup.  adj.  adjective.  Therefore, the word <i>allololo is</i> unambiguously a ‚Äúplural superlative adjective vowel declension‚Äù. <br>  If it is interesting, for the language of the description of grammars we will highlight a separate cycle of articles.  For now, bye! <br><br>  Universal grammar analyzer available at: <br>  <a href="https://github.com/ArseniyBorezkiy/arda_compiler_collection">github.com/ArseniyBorezkiy/arda_compiler_collection</a> <br><br>  In the next release we will proceed directly to the design and coding of our analyzer. </div><p>Source: <a href="https://habr.com/ru/post/323692/">https://habr.com/ru/post/323692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323680/index.html">Thief: creating a narrative with level design and mechanics</a></li>
<li><a href="../323682/index.html">The problem of saving context in asynchronous programming in scala</a></li>
<li><a href="../323684/index.html">Duke Nukem 3D Source Code Analysis: Part 2</a></li>
<li><a href="../323686/index.html">Great overview of the best designers of mobile applications in 2017</a></li>
<li><a href="../323688/index.html">LIFT: Learned Invariant Feature Transform</a></li>
<li><a href="../323694/index.html">How Discord stores billions of messages</a></li>
<li><a href="../323696/index.html">Lectures Technopark. The course "Algorithms and data structures" (autumn 2016)</a></li>
<li><a href="../323702/index.html">Find for spy: AAB-testing as the best option for split-test</a></li>
<li><a href="../323704/index.html">Product Design Digest February 2017</a></li>
<li><a href="../323706/index.html">Tips for a novice rocker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>