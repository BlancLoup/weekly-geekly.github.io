<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Boost.Asio Pinger and Unit Testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! In one of our previous articles, we talked about the implementation of the function of asynchronous ping as part of the task of creating a "pin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Boost.Asio Pinger and Unit Testing</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/pt/blog/166139/"><img src="https://habrastorage.org/storage2/911/38b/b30/91138bb305a4e889e17a99be4176eb16.jpg" align="left"></a>  Hello!  In one of our <a href="http://habrahabr.ru/company/pt/blog/156795/">previous articles,</a> we talked about the implementation of the function of asynchronous ping as part of the task of creating a "pinger" for its further use in pentest organizations with a large number of workstations.  Today we will talk about the coverage of our pinger (logic and network part) with unit tests. <br><br>  It is clear that the need to write code that will be tested, disciplines and helps to plan the architecture more intelligently.  However, the first thought about covering the asynchronous code on Boost.Asio with unit tests was something like this: ‚ÄúWhat ?!  It is absolutely impossible!  How can I write a test based on the node‚Äôs network accessibility? ‚Äù <a name="habracut"></a><br><br>  Then an idea appeared to somehow emulate a remote node and its responses to commands received from our pinger.  Further study of the implementation of asynchronous primitives from Boost.Asio gave rise to the idea of ‚Äã‚Äãparameterizing ready-made primitives with test implementations of services that will respond to our commands. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is what a simplified socket diagram in Boost.Asio looks like.  For simplicity, we will consider only the methods of connecting, sending and receiving data. <br><br><img src="https://habrastorage.org/storage2/446/77d/dcc/44677ddccd04bc066f4d81e88b80781d.png"><br><br>  In the library code, the implementation of this scheme is as follows: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Protocol, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> StreamSocketService = stream_socket_service&lt;Protocol&gt; &gt; class basic_stream_socket : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> basic_socket&lt;Protocol, StreamSocketService&gt; { }</code> </pre> <br>  In this case, all calls in boost :: asio :: basic_stream_socket are delegated to the class StreamSocketService.  Here is a part of the Boost.Asio library code that demonstrates this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ConnectHandler&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endpoint_type&amp; peer_endpoint, BOOST_ASIO_MOVE_ARG(ConnectHandler) handler)</span></span></span><span class="hljs-function"> </span></span>{ ..... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;get_service().async_connect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;get_implementation(), peer_endpoint, BOOST_ASIO_MOVE_CAST(ConnectHandler)(handler)); }</code> </pre><br>  In other words, the socket class itself is, in fact, just a wrapper that is parameterized by protocol and service types;  a good example of static polymorphism.  So, in order to ‚Äúreplace‚Äù the implementation of socket methods, we need to specify our service implementation as a parameter of the socket template.  This is what this socket hierarchy would look like when using dynamic polymorphism with the addition of a test service. <br><br><img src="https://habrastorage.org/storage2/8a8/ffe/c33/8a8ffec339695ace6d93428e0ba5bd52.png"><br><br>  In our case, which is nothing more than <a href="http://en.wikipedia.org/wiki/Dependency_injection">Compile time dependency injection</a> , the simplified diagram for the test socket will look like this. <br><br><img src="https://habrastorage.org/storage2/f8c/bb0/071/f8cbb00715a6f5d1911660d42f705504.png"><br><br>  In the code, test and working primitives are described as follows. <br><br><div class="spoiler">  <b class="spoiler_title">Standard primitives</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BoostPrimitives</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::asio::ip::tcp::socket TCPSocket; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::asio::ip::icmp::socket ICMPSocket; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::asio::ip::tcp::resolver Resolver; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::asio::deadline_timer Timer; };</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Test primitives</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitives</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ba::basic_stream_socket &lt; ba::ip::tcp, SocketService&lt;ba::ip::tcp&gt; &gt; TCPSocket; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ba::basic_raw_socket &lt; ba::ip::icmp, SocketService&lt;ba::ip::icmp&gt; &gt; ICMPSocket; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ba::basic_deadline_timer &lt; boost::posix_time::ptime, ba::time_traits&lt;boost::posix_time::ptime&gt;, TimerService &lt; boost::posix_time::ptime, ba::time_traits&lt;boost::posix_time::ptime&gt; &gt; &gt; Timer; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ba::ip::basic_resolver &lt; ba::ip::tcp, ResolverService&lt;ba::ip::tcp&gt; &gt; Resolver; };</code> </pre></div></div><br>  SocketService, TimerService and ResolverService are test service implementations. <br><br>  The primitives of the timer and resolver of names, as well as their services have a similar structure, so we limit ourselves to the description of sockets and their services. <br><br>  And this is how the working and test implementations of the pinger will be presented in a simplified form. <br><br><img src="https://habrastorage.org/storage2/4b6/965/7fb/4b69657fb02cedbb9ea5e62a95714f7a.png"><br><br>  In the code, it looks like this. <br><br><div class="spoiler">  <b class="spoiler_title">Pinger implementation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PingerImpl</span></span></span><span class="hljs-class"> {</span></span> ..... <span class="hljs-comment"><span class="hljs-comment">//! Socket type typedef typename Traits::TCPSocket TCPSocket; ..... }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pinger in the working version</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pinger</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//! Implementation type typedef PingerImpl&lt;BoostPrimitives&gt; Impl; .... private: //! Implementation std::auto_ptr&lt;Impl&gt; m_Impl; };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pinger in the test version</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseTest</span></span></span><span class="hljs-class"> :</span></span> boost::noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">//! Pinger implementation type typedef Net::PingerImpl&lt;Test::Primitives&gt; TestPinger; .... };</span></span></code> </pre><br></div></div><br>  So, we have access to individual operations of primitives.  Now you need to understand how to use them to organize a test case covering the ping process.  We can represent this process (ping a node) as a sequence of commands executed via the Boost.Asio library.  We need a certain queue of commands that will be filled in during the initialization of the test script and empty during the execution of the ping.  Here is a state diagram describing test performance. <br><br><img src="https://habrastorage.org/storage2/394/636/cc5/394636cc505b2cdd9d1331042345f1fc.png"><br><br>  We introduce the ICommand abstraction, which will provide methods similar to the methods of the Boost.Asio primitives, and create classes for the implementation of specific commands (the Connect class will implement connections to the node, the Receive class - receive data, etc.). <br><br>  UML-diagram of the tests is presented below. <br><br><img src="https://habrastorage.org/storage2/379/651/612/379651612ad55f50f4ec529cea77993a.png"><br><br><div class="spoiler">  <b class="spoiler_title">Team abstraction</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//! Pinger test command interface class ICommand : boost::noncopyable { public: //! Command pointer typedef boost::shared_ptr&lt;ICommand&gt; Ptr; //! Error callback type typedef boost::function&lt;void(const boost::system::error_code&amp;)&gt; ErrorCallback; //! Error and size callback typedef boost::function&lt;void(const boost::system::error_code&amp;, std::size_t)&gt; ErrorAndSizeCallback; //! Resolver callback typedef boost::function&lt;void(const boost::system::error_code&amp;, boost::asio::ip::tcp::resolver::iterator)&gt; ResolverCallback; public: ICommand(const Status::Enum status) : m_Status(status) {} //! Timer wait virtual void AsyncWait(ErrorCallback&amp; callback, boost::asio::io_service&amp; io); //! Async connect virtual void AsyncConnect(ErrorCallback&amp; callback, boost::asio::io_service&amp; io); //! Async receive virtual void AsyncReceive(ErrorAndSizeCallback&amp; callback, const std::vector&lt;char&gt;&amp; sended, const boost::asio::mutable_buffer&amp; buffer, boost::asio::io_service&amp; io); //! Async resolve virtual void AsyncResolve(ResolverCallback&amp; callback, boost::asio::io_service&amp; io); //! Dtor virtual ~ICommand() {} protected: Status::Enum m_Status; };</span></span></code> </pre><br></div></div><br>  At the same time, methods that are not provided by a specific command will contain test statements: this way we will be able to control the sequence of execution of commands. <br><br><div class="spoiler">  <b class="spoiler_title">Example implementation of the join command</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Connect::AsyncConnect(ErrorCallback&amp; callback, boost::asio::io_service&amp; io) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_Status != Status::Pending) { io.post(boost::bind(callback, m_Code)); callback = ErrorCallback(); } }</code> </pre><br></div></div><br>  The "default" implementation reports that the command is not extracted in turn: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ICommand::AsyncConnect(ErrorCallback&amp; <span class="hljs-comment"><span class="hljs-comment">/*callback*/</span></span>, boost::asio::io_service&amp; <span class="hljs-comment"><span class="hljs-comment">/*io*/</span></span>) { assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre><br>  We also need a class - a test case that provides methods for working with the command queue and verifies that there are no teams left in the queue after the test has been completed. <br><br><div class="spoiler">  <b class="spoiler_title">The implementation of the "test case" with a queue of commands</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//! Test fixture class Fixture { //! Commands list typedef std::list&lt;ICommand::Ptr&gt; Commands; public: Fixture(); ~Fixture(); static void Push(ICommand* cmd); static ICommand::Ptr Pop(); private: static Commands s_Commands; }; Fixture::Commands Fixture::s_Commands; Fixture::Fixture() { assert(s_Commands.empty()); // ,       - } Fixture::~Fixture() { assert(s_Commands.empty()); //      } void Fixture::Push(ICommand* cmd) { s_Commands.push_back(ICommand::Ptr(cmd)); } ICommand::Ptr Fixture::Pop() { assert(!s_Commands.empty()); const ICommand::Ptr result = s_Commands.front(); s_Commands.pop_front(); return result; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Part of the implementation of the test service</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(implementation_type&amp; </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*impl*/</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endpoint&amp; </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*ep*/</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; callback)</span></span></span><span class="hljs-function"> </span></span>{ m_ConnectCallback = callback; Fixture::Pop()-&gt;AsyncConnect(m_ConnectCallback, m_Service); <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br></div></div><br>  Unit tests are written on the <a href="http://ru.wikipedia.org/wiki/Google_C%252B%252B_Testing_Framework">Google framework</a> , here is an example of the implementation of a test for ICMP ping: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseTest</span></span></span><span class="hljs-class"> :</span></span> boost::noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">//! Pinger implementation type typedef Net::PingerImpl&lt;Test::Primitives&gt; TestPinger; BaseTest() { m_Pinger.reset(new TestPinger(boost::bind(&amp;BaseTest::Callback, this, _1, _2))); } virtual ~BaseTest() { m_Pinger-&gt;AddRequest(m_Command); while (m_Pinger-&gt;IsActive()) boost::this_thread::interruptible_wait(100); } template&lt;typename T&gt; void Cmd(const Status::Enum status) { m_Fixture.Push(new T(status)); } template&lt;typename T, typename A&gt; void Cmd(const Status::Enum status, const A&amp; arg) { m_Fixture.Push(new T(status, arg)); } void Callback(const Net::PingCommand&amp; /*cmd*/, const Net::PingResult&amp; /*rslt*/) { //     ,     } Fixture m_Fixture; std::auto_ptr&lt;TestPinger&gt; m_Pinger; Net::PingCommand m_Command; }; //        //   -   ,    . class ICMPTest : public testing::Test, public BaseTest { }; TEST(ICMPTest, ICMPSuccess) { m_Command.m_HostName = "ptsecurity.ru"; Cmd&lt;Resolve&gt;(Status::Success, m_Command.m_HostName); //  IP   Cmd&lt;Wait&gt;(Status::Pending); //   ,  Status::Pending ‚Äì ,      Cmd&lt;Receive&gt;(Status::Success); //        m_Command.m_Flags = SCANMGR_PING_ICMP; //        BaseTest } TEST(ICMPTest, ICMPFail) { m_Command.m_HostName = "ptsecurity.ru"; Cmd&lt;Resolve&gt;(Status::Success, m_Command.m_HostName); //  IP   Cmd&lt;Wait&gt;(Status::Success); //   ,  Status::Success ‚Äì ,     Cmd&lt;Receive&gt;(Status::Pending); //      m_Command.m_Flags = SCANMGR_PING_ICMP; //        BaseTest }</span></span></code> </pre><br>  So, with testing the network part of the pinger, everything is clear: you only need to describe the sequence of commands for each of the possible ping scenarios.  Recall that the pinger logic contains several virtual methods that are redefined in the PingerImpl class.  Thus, we managed to untie the logic from the network part. <br><br><img src="https://habrastorage.org/storage2/681/77b/098/68177b098e0f48336d2797aa29a56ae1.png"><br><br>  In the diagram, the TestLogic class is created using a <a href="http://code.google.com/p/googlemock/">google mock</a> .  In this case, logic tests determine the sequence of methods and arguments with which they will be invoked, with certain input parameters. <br><br><div class="spoiler">  <b class="spoiler_title">Implementing Test Logic</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestLogic</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Net::PingerLogic { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TestLogic(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Net::PingCommand&amp; cmd, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Net::Pinger::Callback&amp; callback) : Net::PingerLogic(cmd, callback) { } MOCK_METHOD1(InitPorts, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; ports)); MOCK_METHOD1(ResolveIP, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; name)); MOCK_METHOD1(StartResolveNameByIp, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ip)); MOCK_METHOD1(StartResolveIpByName, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; name)); MOCK_METHOD1(StartTCPPing, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> timeout)); MOCK_METHOD1(StartICMPPing, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> timeout)); MOCK_METHOD1(StartGetNetBiosName, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; name)); MOCK_METHOD0(Cancel, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ()); };</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">A couple of examples of unit tests</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TEST(Logic, Start) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> host = <span class="hljs-string"><span class="hljs-string">"ptsecurity.ru"</span></span>; EXPECT_CALL(*m_Logic, InitPorts(g_TargetPorts)).Times(Exactly(<span class="hljs-number"><span class="hljs-number">1</span></span>)); EXPECT_CALL(*m_Logic, ResolveIP(host)).Times(Exactly(<span class="hljs-number"><span class="hljs-number">1</span></span>)).WillOnce(Return(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); EXPECT_CALL(*m_Logic, StartResolveIpByName(host)).Times(Exactly(<span class="hljs-number"><span class="hljs-number">1</span></span>)); m_Logic-&gt;OnStart(); } TEST(Logic, ResolveIp) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ip = <span class="hljs-number"><span class="hljs-number">0x10101010</span></span>; EXPECT_CALL(*m_Logic, StartResolveNameByIp(ip)).Times(Exactly(<span class="hljs-number"><span class="hljs-number">1</span></span>)); EXPECT_CALL(*m_Logic, StartICMPPing(<span class="hljs-number"><span class="hljs-number">1</span></span>)).Times(Exactly(<span class="hljs-number"><span class="hljs-number">1</span></span>)); EXPECT_CALL(*m_Logic, StartTCPPing(<span class="hljs-number"><span class="hljs-number">1</span></span>)).Times(Exactly(<span class="hljs-number"><span class="hljs-number">1</span></span>)); m_Logic-&gt;OnIpResolved(ip); }</code> </pre><br></div></div><br>  As a result, the task was successfully solved, the benefit of Boost.Asio is an excellent framework, perfectly suited for such purposes.  In addition, as usual, in the process of covering with unit tests, several serious bugs were revealed :) Of course, we managed to save many hours of manual testing and debugging of the code.  From the moment the pinger code was introduced into the product, it revealed only one minor bug related to inattention when writing the code, which means that the time to develop and write unit tests was not wasted! <br><br>  From here we can draw conclusions: <br><br><ul><li>  Unit testing is a very useful thing, unit tests should ideally cover all the code. </li><li>  Practically any problem of covering a code with tests is solved!  It is only necessary to break the tested code into a sufficient number of abstractions. </li></ul><br>  Thank you all for your attention! <br><br>  Author: Sergey Karnaukhov ( <a href="https://habrahabr.ru/users/clrn/" class="user_link">CLRN</a> ). </div><p>Source: <a href="https://habr.com/ru/post/166139/">https://habr.com/ru/post/166139/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../166127/index.html">John Resig on the internationalization of JavaScript applications</a></li>
<li><a href="../166131/index.html">Site vulnerability yota.ru fixed</a></li>
<li><a href="../166133/index.html">Today, Yandex People service has been attached to Yandex Disk, let's see what happened.</a></li>
<li><a href="../166135/index.html">Introduction to NikaFramework (NKF). Part 2</a></li>
<li><a href="../166137/index.html">Rating of 50 companies that received the largest number of patents in 2012</a></li>
<li><a href="../166141/index.html">Smart stops or the capital of the 21st century</a></li>
<li><a href="../166145/index.html">Scala WAT: Processing Optional Values</a></li>
<li><a href="../166149/index.html">Prototype image processing software</a></li>
<li><a href="../166153/index.html">Review of the DVR Highscreen Black Box Full HD</a></li>
<li><a href="../166155/index.html">Writing a cross-platform C ++ library to work with named pipes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>