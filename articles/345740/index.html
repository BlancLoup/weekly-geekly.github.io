<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is Hashing? Under the hood of the blockchain</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many of you have probably already heard about blockchain technology, but it is important to know about how hashing works in this system. The Blockchai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is Hashing? Under the hood of the blockchain</h1><div class="post__text post__text-html js-mediator-article">  Many of you have probably already heard about blockchain technology, but it is important to know about how hashing works in this system.  The Blockchain technology is one of the most innovative discoveries of the last century.  We can say so without exaggeration, as we observe the influence it has had over the past few years and the influence it will have in the future.  In order to understand the structure and purpose of the blockchain technology itself, we first need to understand one of the basic principles of blockchain creation. <br><a name="habracut"></a><br><h3>  So what is hashing? </h3><br>  In simple words, hashing means entering information of any length and size in the source line and returning the result of a fixed length given by the algorithm of the hashing function.  In the context of cryptocurrency, such as Bitcoin, transactions after hashing at the output look like a set of characters defined by the length algorithm (Bitcoin uses SHA-256). <br><br><img src="https://habrastorage.org/webt/pc/ht/kn/pchtknz-bodlhi4daztdpfpdbcu.png" alt="image"><br>  <i>Input- input data, hash- hash</i> <br><br>  Let's see how the hashing process works.  We are going to enter certain data.  For this, we will use SHA-256 (a secure hash algorithm from the SHA-2 family, 256 bits in size). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As you can see, in the case of SHA-256, no matter how large your input data (input), the output will always have a fixed 256-bit length.  This is extremely necessary when you are dealing with a huge amount of data and transactions.  Thus, instead of remembering the input data, which can be huge, you can simply remember the hash and track it.  Before proceeding, it is necessary to get acquainted with the various properties of the hashing functions and how they are implemented in the blockchain. <br><br><h4>  Cryptographic Hash Functions </h4><br>  A cryptographic hash function is a special class of hash functions that has various properties necessary for cryptography.  There are certain properties that a cryptographic hash function must have in order to be considered secure.  Let's deal with them in turn. <br><br>  <b>Property 1: Deterministic</b> <br>  This means that no matter how many times you analyze a particular input through a hash function, you always get the same result.  This is important because if you receive different hashes every time, it will be impossible to track input. <br><br>  <b>Property 2: Fast Calculation</b> <br>  The hash function must be able to quickly return the hash input.  If the process is not fast enough, the system simply will not be effective. <br><br>  <b>Property 3: The complexity of the inverse calculation</b> <br>  The complexity of the inverse calculation means that given H (A), it is impossible to determine A, where A is the input data and H (A) is the hash.  Note the use of the word ‚Äúimpossible‚Äù instead of the word ‚Äúimpracticable.‚Äù  We already know that it is possible to determine the source data by their hash value.  Take an example. <br><br>  Suppose you are playing dice, and the final number is a hash of a number that appears from the dice.  How can you determine what the source number is?  Simply, all you have to do is find the hashes of all the numbers from 1 to 6 and compare.  Since the hash functions are deterministic, the hash of a particular number will always be the same, so you can simply compare the hashes and find out the source number. <br><br>  But this only works when this amount of data is very small.  What happens when you have a huge amount of data?  Suppose you are dealing with a 128-bit hash.  The only method by which you must find the source data is the ‚Äúbrute force‚Äù method.  The ‚Äúbrute force‚Äù method means that you need to select a random entry, hash it, then compare the result with the test hash and repeat until you find a match. <br><br>  <i><b>So what happens if you use this method?</b></i> <br><br><ul><li>  The best scenario: you get your answer at the first attempt.  You really have to be the happiest person in the world for this to happen.  The probability of such an event is negligible. </li><li>  Worst scenario: you get an answer after 2 ^ 128 - 1 time.  This means that you will find your answer at the end of all data calculations (one chance out of 340282366920938463463374607431768211456) </li><li>  The average scenario: you will find it somewhere in the middle, so basically after 2 ^ 128/2 = 2 ^ 127 attempts.  In other words, this is a huge amount. </li></ul><br>  Thus, it is possible to break through the function of the inverse calculation using the ‚Äúbrute force‚Äù method, but it will take a lot of time and computational resources, so it is useless. <br><br>  <b>Property 4: Small changes in input change the hash</b> <br>  Even if you make small changes to the source data, the changes that will be reflected in the hash will be huge.  Let's check with SHA-256: <br><br><img src="https://habrastorage.org/webt/no/yn/8l/noyn8l33msv9uftplq9sfqpl0ti.png" alt="image"><br><br>  Do you see?  Even if you just changed the case of the first letter, notice how much this affected the output hash.  This is a necessary function, since the hashing property leads to one of the main qualities of the blockchain - its immutability (more on this later). <br><br>  <b>Property 5: collision stability</b> <br>  Given the two different types of source data A and B, where H (A) and H (B) are their corresponding hashes, for H (A) it cannot be equal to H (B).  This means that, for the most part, each entry will have its own unique hash.  Why did we say ‚Äúfor the most part‚Äù?  Let's talk about an interesting concept called ‚ÄúThe Paradox of Birthday‚Äù. <br><br>  <i><b>What is the birthday paradox?</b></i> <br>  If you accidentally meet a stranger on the street, the chance that your dates of birthdays will match is very small.  In fact, if you assume that all days of the year have the same probability of a birthday, the chances of another person sharing your birthday are 1/365 or 0.27%.  In other words, it is really low. <br><br>  However, for example, if you gather 20-30 people in the same room, the chances of two people sharing the same day increase dramatically.  In fact, the chance for 2 people is 50-50, sharing the same birthday in this situation. <br><br>  <b><i>How does this apply to hashing?</i></b> <br>  Suppose you have a 128-bit hash that has 2 ^ 128 different probabilities.  Using the birthday paradox, you have a 50% chance to break the conflict resistance sqrt (2 ^ 128) = 2 ^ 64. <br><br>  As you have noticed, it is much easier to break the collision resistance than to find the inverse calculation of the hash.  This usually takes a long time.  So, if you use a function such as SHA-256, you can safely assume that if H (A) = H (B), then A = B. <br><br>  <b>Property 6: Puzzle</b> <br>  Properties The puzzle has the strongest effect on cryptocurrency topics (more on this later when we dive into crypto schemes).  First, let's define a property, after which we will look at each term in detail. <br><br>  For each ‚ÄúY‚Äù output, if k is chosen from a distribution with high min-entropy, it is impossible to find input data x such that H (k | x) = Y. <br><br>  This is probably beyond your comprehension!  But it's all right, now let's deal with this definition. <br><br>  <i><b>What is the meaning of "high mine entropy"?</b></i> <br>  This means that the distribution from which the value is chosen is scattered so that we choose a random value that has a negligible probability.  In principle, if you are told to choose a number from 1 to 5, this is a low distribution of min-entropy.  However, if you chose a number from 1 to infinity, this is a high distribution of min-entropy. <br><br>  <i><b>What does "k | x" mean?</b></i> <br>  "|" Denotes concatenation.  Concatenation means the union of two strings.  For example.  If I combined the "blue" and "sky", then the result would be "blue sky". <br>  So let's go back to the definition. <br><br>  Suppose you have an output value "Y".  If you choose a random ‚ÄúK‚Äù value, it is impossible to find the value of X, such that a concatenation hash from K and X will yield Y as a result. <br><br>  Once again pay attention to the word "impossible", but it is possible, because people do it all the time.  In fact, the whole process of mining works on this (more later). <br><br>  <i>Examples of cryptographic hash functions:</i> <br><br><ul><li>  MD 5: It produces a 128-bit hash.  The collision resistance was cracked after ~ 2 ^ 21 hash. </li><li>  SHA 1: creates a 160-bit hash.  The collision resistance was cracked after ~ 2 ^ 61 hash. </li><li>  SHA 256: creates a 256-bit hash.  Currently used in Bitcoin. </li><li>  Keccak-256: Creates a 256-bit hash and is currently used by Ethereum. </li></ul><br>  <b>Hashing and data structures.</b> <br>  The data structure is a specialized way to store data.  If you want to understand how the blockchain system works, then there are two basic properties of the data structure that can help you with this: <br><br>  1. Pointers <br>  2. Related listings <br><br>  <i><b>Pointers</b></i> <br>  In programming, pointers are variables that store the address of another variable, regardless of the programming language used. <br><br>  For example, the record int a = 10 means that there is a certain variable ‚Äúa‚Äù, which stores an integer value equal to 10. This is how a standard variable looks. <br><br>  However, instead of storing values, pointers store the addresses of other variables.  That is why they got their name, because they literally indicate the location of other variables. <br><br>  <i><b>Related Lists</b></i> <br>  The linked list is one of the most important elements in data structures.  The structure of the linked list is as follows: <br><br><img src="https://habrastorage.org/webt/yf/jv/eg/yfjvegimo6jt6oy17dvnuwgszvq.png" alt="image"><br>  <i>* Head - heading;</i>  <i>Data - data;</i>  <i>Pointer - pointer;</i>  <i>Record - record;</i>  <i>Null - zero</i> <br><br>  This is a sequence of blocks, each of which contains data associated with the next using a pointer.  The pointer variable in this case contains the address of the next node, thereby making the connection.  As shown in the diagram, the last node is marked with a null pointer, which means that it does not matter. <br><br>  It is important to note that the pointer inside each block contains the address of the previous one.  So the chain is formed.  The question arises, what does this mean for the first block in the list and where is its pointer located? <br><br>  The first block is called the ‚Äúgenesis block‚Äù, and its index is in the system itself.  It looks like this: <br><br><img src="https://habrastorage.org/webt/cw/5h/bs/cw5hbs1frsvd5oq16cfo5d2veju.png" alt="image"><br>  <i>* H () - Hash pointers are rendered this way.</i> <br><br>  If you are interested in what ‚Äúhash pointer‚Äù means, then we will be happy to explain. <br>  As you already understood, the blockchain structure is based on this.  A chain of blocks is a linked list.  Consider the structure of the blockchain: <br><br><img src="https://habrastorage.org/webt/sy/0t/r5/sy0tr5wr3a814bs81gp0xte4tmw.png" alt="image"><br>  <i>* Hash of previous block header - hash of the previous block header;</i>  <i>Merkle Root - Merkle Root;</i>  <i>Transactions - transactions;</i>  <i>Simplified Bitcoin Blockchain - Simplified Bitcoin blockchain.</i> <br><br>  A blockchain is a linked list containing data, as well as a hash pointer pointing to the previous block, thus creating a connected chain.  What is a hash pointer?  It looks like a regular pointer, but instead of simply containing the address of the previous block, it also contains the hash of the data inside the previous block.  It is this small setting that makes the blockchain so reliable.  Imagine for a second that a hacker attacks block 3 and is trying to change the data.  Because of the properties of the hash functions, even a small change in the data will greatly change the hash.  This means that any minor changes made in block 3 will change the hash stored in block 2, which in turn will change the data and hash of block 2, and this will lead to changes in block 1 and so on.  The chain will be completely changed, and this is impossible.  But what does the block header look like? <br><br><img src="https://habrastorage.org/webt/xb/l2/2b/xbl22b-2ieszwbeibjfrqqvjhhe.png" alt="image"><br>  <i>* Prev_Hash - previous hash;</i>  <i>Tx - transaction;</i>  <i>Tx_Root - transaction root;</i>  <i>Timestamp - time stamp;</i>  <i>Nonce is a unique symbol.</i> <br><br>  <b>The block header consists of the following components:</b> <br><br>  ¬∑ Version: block version number <br>  ¬∑ Time: current timestamp <br>  ¬∑ Current challenging goal (See below) <br>  ¬∑ Hash previous block <br>  ¬∑ Unique symbol (See below) <br>  ¬∑ Merkle root hash <br><br>  Right now, let's focus on what the Merkle root hash is.  But before that, we need to understand the concept of the Merkle Tree. <br><br><h4>  What is the Merkle Tree? </h4><br><img src="https://habrastorage.org/webt/9g/7u/p6/9g7up6hcowckfb1nce6nmezgpdi.png" alt="image"><br>  <i>Source: Wikipedia</i> <br><br>  The diagram above shows what a Merkle tree looks like.  In the Merkle tree, each non-leaf node is a hash of the values ‚Äã‚Äãof their child nodes. <br><br>  <b>Leaf knot:</b> Leaf knots are nodes in the lowest tier of the tree.  Therefore, following the above scheme, the nodes L1, L2, L3 and L4 will be considered leaf. <br><br>  <b>Child nodes:</b> For a node, all nodes that are below its level and that are part of it are its child nodes.  In the diagram, nodes with the words ‚ÄúHash 0-0‚Äù and ‚ÄúHash 0-1‚Äù are child nodes of the node with the words ‚ÄúHash 0‚Äù. <br><br>  <b>Root node: the</b> only node at the highest level, labeled "Top Hash" is the root. <br><br>  <b>So what does the Merkle Tree have to do with blockchain?</b> <br>  Each block contains a large number of transactions.  It will be very inefficient to store all the data inside each block as a series.  This will make the search for any particular operation extremely cumbersome and take a long time.  But the time required to ascertain whether a particular transaction belongs to this block or not is significantly reduced if you use the Merkle tree. <br><br>  Let's look at an example in the following Hash tree: <br><br><img src="https://habrastorage.org/webt/zd/ya/p8/zdyap8vseqbpvkupcs94jnidh-g.png" alt="image"><br>  <i>Image courtesy of the project: Coursera</i> <br><br>  Now suppose I want to know if this data belongs to a block or not: <br><br><img src="https://habrastorage.org/webt/mk/un/4i/mkun4ia-zbzoc9d29kbxxj8wagq.png" alt="image"><br><br>  Instead of going through the complex process of looking through each individual hash process, and also to see if it belongs to the data or not, I just can track the trace of the hash leading to the data: <br><br><img src="https://habrastorage.org/webt/yp/us/0k/ypus0k_fea3poav_nqr4fsij-e0.png" alt="image"><br>  <i>This significantly reduces the time.</i> <br><br>  Hashing in mining: crypto puzzles. <br>  When we say ‚Äúmining‚Äù, basically, it means finding a new block that will be added to the blockchain.  Miners around the world are constantly working to make sure that the chain continues to grow.  Previously, people found it easier to work using only their laptops for mining, but over time they began to form "pools", combining the power of computers and miners, which could be a problem.  There are restrictions for each cryptocurrency, for example, for Bitcoin, they are 21 million.  Between the creation of each block there must be a specific time interval specified by the protocol.  For bitcoin, the time between creating a block takes only 10 minutes.  If blocks were allowed to be created faster, this would result in: <br><br><ul><li>  A lot of collisions: more hash functions will be created that will inevitably cause more collisions. </li><li>  To a large number of abandoned blocks: If many miners go ahead of the protocol, they will at the same time randomly create new blocks without preserving the integrity of the main chain, which will lead to ‚Äúorphaned‚Äù blocks. </li></ul><br>  Thus, to limit the creation of blocks, a certain level of complexity is established.  Mining is a bit like a game: you solve a problem and you get a reward.  Increasing complexity makes solving a problem much more difficult and, consequently, it takes more time to complete. WRT, which starts with a set of zeros.  As the level of difficulty increases, the number of zeros increases.  The level of difficulty changes after every 2016 block. <br><br><h4>  Mining process </h4><br>  <i>Note: in this section we will talk about the development of bitcoins.</i> <br>  When the Bitcoin protocol wants to add a new block to the chain, mining is the procedure it follows.  Whenever a new block appears, all its contents are first hashed.  If the selected hash is greater than or equal to the complexity level set by the protocol, it is added to the blockchain, and everyone in the community recognizes the new block. <br><br>  However, it is not so simple.  You must be very lucky to get a new unit in this way.  Since, it is here that a unique symbol is assigned.  A unique character (nonce) is a one-time code that is combined with a block hash.  Then this line is again changed and compared with the level of complexity.  If it corresponds to the level of complexity, then the random code changes.  This is repeated a million times until the requirements are finally met.  When this happens, the block is added to the block chain. <br><br>  <b>Summing up:</b> <br><br>  ‚Ä¢ A hash of the contents of the new block is being executed. <br>  ‚Ä¢ A nonce (special character) is added to the hash. <br>  ‚Ä¢ The new line is hashed again. <br>  ‚Ä¢ The final hash is compared with the level of complexity to check whether it is less or not. <br>  ‚Ä¢ If not, the nonce changes, and the process repeats again. <br>  ‚Ä¢ If so, the block is added to the chain, and the publicly accessible book (blockchain) is updated and informs the nodes that a new block has been attached. <br>  ‚Ä¢ Miners responsible for this process are awarded Bitcoins. <br><br>  <b>Remember the property number 6 hash functions?</b>  <b>Ease of use of the task?</b> <br>  For each output "Y", if k is chosen from a distribution with high min-entropy, it is impossible to find the input x in this way, H (k | x) = Y. <br><br>  So, when it comes to bitcoin mining: <br><br>  ‚Ä¢ K = Unique character <br>  ‚Ä¢ x = block hash <br>  ‚Ä¢ Y = problem target <br><br>  The whole process is completely random, based on the generation of random numbers, following the Proof Of Work protocol and meaning: <br><br><ul><li>  Problem solving should be difficult. </li><li>  However, checking the answer should be easy for everyone.  This is done to ensure that unauthorized methods are not used to solve the problem. </li></ul><br>  <b>What is hash rate?</b> <br>  Hashing speed basically means how quickly these hashing operations occur during mining.  A high level of hashing means that more and more people and miners are involved in the mining process, and as a result, the system is functioning normally.  If the hash rate is too high, the level of complexity increases proportionally.  If the hash speed is too slow, then the complexity level decreases accordingly. <br><br><h4>  Conclusion </h4><br>  Hashing is indeed fundamental to the creation of blockchain technology.  If someone wants to understand what a blockchain is, he should start by understanding what hashing means. </div><p>Source: <a href="https://habr.com/ru/post/345740/">https://habr.com/ru/post/345740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345730/index.html">Useful to the designer - issue number 3. Needed community news to improve your workflow</a></li>
<li><a href="../345732/index.html">Git: Newbies Tips - Part 1</a></li>
<li><a href="../345734/index.html">Bloomberg: in search of new markets, high-frequency traders master cryptocurrency</a></li>
<li><a href="../345736/index.html">IL2CPP: generalized implementation</a></li>
<li><a href="../345738/index.html">The system for preparing video for streaming on the platform ivi</a></li>
<li><a href="../345742/index.html">How not to write on Habr: Antireyting 2017</a></li>
<li><a href="../345744/index.html">New release Oh, my code! How I became a VKontakte developer at 16</a></li>
<li><a href="../345746/index.html">Eat three donuts from UWP and not choke</a></li>
<li><a href="../345748/index.html">How to write in assembler in 2018</a></li>
<li><a href="../345750/index.html">Development of Wi-Fi network scanner for Sailfish OS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>