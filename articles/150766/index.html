<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Experience creating frameworks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I work in a company that has been developing custom accounting systems for quite a long time. About the same time there is a technology department - a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Experience creating frameworks</h1><div class="post__text post__text-html js-mediator-article">  I work in a company that has been developing custom accounting systems for quite a long time.  About the same time there is a technology department - a team of people who develop tools and frameworks for their comrades, and they, in turn, create systems for customers.  Briefly we can say that we (technologists) unify the process of writing business logic using our own ORM, combine designers and programmers using a UML editor with code generators, provide various UI controls that allow users of end applications to work productively. <br>  In this article I want to share my experience regarding the process of creating a technological layer. <br><a name="habracut"></a><br><br><h4>  Why do we need frameworks? </h4><br>  There are several reasons why the company contains several people who do not bring direct profit; in my opinion, the most important thing is: <br>  1. Reuse ideas and code.  The technology department collects best practices as you complete various projects and distributes them to all teams.  In this case, there is no need to arrange each connection with each in order to be aware of what is new and useful that a neighbor has.  After all, a neighbor can immediately share with technologists and not to bother much about universalization, while technologists have the opportunity to inform everyone else (a list of improvements is regularly made that have fallen into the next version of technological products). <br>  2. Unification of solutions.  Programmers sometimes change jobs.  To deal with the negative aspects of such situations, the technology provides some unified methods for solving typical problems.  This reduces the number of bicycles and reduces the time of entry of a new person into the project. <br><br><h4>  Growth points or maturing technology </h4><br>  A little bit about how a new technological direction is born.  From time to time, the applied platforms are modified and you have to create technology for these new items. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Kindergarten </h5><br>  Due to the fact that our product is not a complete application, to begin with, any subject area for the prototype project is selected (1-3 pieces).  This application serves only to test solutions and approaches that we plan to implement.  For fun, the last such system we used to account for domestic cats in the apartment.  A special feature of the prototypes is that the code is quite mixed up and it is not clear where the technological layer is, and where the applied logic begins.  On this "cat" project, all the necessary components, generators, user interface elements are worked out.  Only technologists work on the project. <br><br><h5>  School time </h5><br>  When it comes time to test the technology on something more serious, the ‚Äúsacrificial‚Äù project is chosen from the commercial one.  As a rule, it has a 1.5‚Äì2 times longer period that can be set aside for development than a typical project (everyone understands that there are risks, because the technology is used by us for the first time and the company itself pays for technological work, and not customer).  A feature of this project is that the technology code is initially in a solution, and as it is developed it is divided into technology projects and application code (which depends on the subject area).  The project work and technology and application programmers.  It should be understood that the main approaches are still being debugged and not everything in the technology is 100% ready, so the project will be with innate ‚Äúbikes‚Äù that complicate support.  Sometimes these ‚Äúbikes‚Äù are replaced with standard technological solutions, sometimes they remain until the end. <br><br><h5>  Higher education </h5><br>  At this stage, we believe that the technology is ready for widespread use.  Go to the normal "operating mode".  Application developers no longer need direct assistance from technologists.  Technological assemblies are delivered in compiled form.  Refinement tasks and error messages are transferred to the TFS technology project. <br><br><h5>  Professional Development </h5><br>  From time to time, serious improvements of the technology are required, as a rule, this is adding functionality, for example, the general reporting subsystem, the authorization subsystem, the logging subsystem, etc ... for users, it appears already in its finished form.  As a rule, such new products immediately become popular with all projects that are actively developing.  It's funny that sometimes, at the end of the development of a regular feature, an application programmer comes in and asks for it to be implemented. <br><br><h5>  Retirement </h5><br>  With the development of new directions, the old ones gradually disappear.  Projects are closed, there are units of projects that require support.  Together with them, the technology "retires", goes into Bug driven development.  New features are no longer added, only fixes old bugs that have been accumulating over the years.  Some bugs are fixed with crutches in the application project, since it is no longer advisable to make changes to the technology.  Changes in technology should always be made with an eye to all projects that depend on it.  One wrong move and problems are guaranteed both to the people on the applied project, and after them to the technologists. <br>  If something needs to be rewritten, then for a technology with multiple entries in projects: <br>  ‚Ä¢ We collect requirements that were satisfied by the old functionality (as a rule, after a series of improvements and minor fixes, there is no complete and up-to-date documentation for the programmer) <br>  ‚Ä¢ We plan work (once again we look at the budget and evaluate the feasibility) <br>  ‚Ä¢ We write tests to fix the state.  According to them we will determine that what has worked before will not break. <br>  ‚Ä¢ We write functionality <br>  ‚Ä¢ Check the quality and compliance with the stated requirements <br><br><h4>  The technical side of the issue </h4><br>  Now a little about techniques and techniques.  It's about the Microsoft .NET Framework, because our solutions are built on this platform. <br><br><h5>  Expansion points </h5><br>  The technology should not limit programmers, but give advantages over a solution from scratch, and sometimes completely ready-made solutions.  In order for a programmer to show his individuality where the technology is ‚Äútoo standard‚Äù we use the following approaches: <br>  ‚Ä¢ Inheritance.  There is a base class that implements the standard behavior and is located in the technological assembly.  The code generated for an application project is inherited from the base class and in special methods it assumes a change in the standard behavior. <br>  ‚Ä¢ Developments.  Technology classes contain a series of events whose processing allows you to change behavior.  It should be remembered that an event can be subscribed to many times. <br>  ‚Ä¢ Delegates.  Similar to events, but there can be only one implementation.  This prevents unwanted triggering several times. <br>  ‚Ä¢ App.config.  Various trifles fall into the configuration file.  As a rule, these are some flags and paths (do you need to write debugging information, connection strings to services, etc.). <br>  ‚Ä¢ DI.  This option implies redefinition of the whole module. <br><br><h5>  Event logging </h5><br>  From the technology layer, there is rarely normal access to the user interface.  As a rule, if something went wrong, it indicates that there is an error either in technology (yes, they are and we understand it), or in the application code (ideally, you can indicate to the application programmer clearly what he is doing wrong and in which place).  In any case, you need to somehow signal this.  We use Log4net.  To highlight technological messages, you can use either a separate logger, or fix the level of errors, for example, Warn, to the technology. <br><br><h5>  XML comments </h5><br>  XML comments in the technology code are extremely important.  It is necessary to prescribe them for public classes, methods and properties.  This will allow the generation of help (http://sandcastle.codeplex.com/) and provide hints in application projects thanks to IntelliSense.  Do not forget to specify in the project settings whether to generate an xml file with comments. <br><br><h5>  Breaking changes </h5><br>  It is extremely rare that such a change in technology occurs, which requires the intervention of an application programmer to update the technology layer.  If such an update can be predicted, then you need to warn in advance, for example, using the Obsolete attribute: <br>  [Obsolete (‚ÄúThis function will be removed in the next version, use the function‚Äù)] <br>  Sometimes you have to go on about and apply the rule: ‚Äúit‚Äôs better to add 1 time than to update 2 times‚Äù, i.e.  if the method signature is used in 1000 places in each application project, changing it in technology is not a good idea.  The most important rule: always a detailed description of possible problems with the update - forewarned, then armed. <br><br><h5>  Documenting </h5><br>  For process assemblies, documentation is essential.  To store information, we use the Wiki engine with the right to write to the technologists.  To keep information up to date, 2 rules apply: <br>  1. Made a deal - write it in the Wiki! <br>  2. Answered the question - write it in the Wiki! <br>  Description Levels: <br>  1. For yourself (as arranged) <br>  2. For programmers of applied projects (how to use methods and classes) <br>  3. For system users (how to use components) <br><br><h5>  Framework structure </h5><br>  Sometimes you want to minimize the number of assemblies issued for projects.  This allows you to deal with incorrect updates when you need to update several assemblies at once, otherwise something will not work and minimizes the risk that something will be forgotten to be installed by the customer.  However, different projects need slightly different functions.  What can be applied? <br>  1. Links to cs-files between projects (work with projects becomes a bit more complicated) <br>  2. ILMerge (this can be assigned to the Build server, but debugging is difficult) <br>  3. Assemblies in resources (with a separate assembly loading mechanism) <br><br><h5>  Signing assemblies or Strong name </h5><br>  Another iron rule: all process assemblies must be signed.  This gives us the following benefits: <br>  1. Signed assemblies are uniquely identified in the GAC. <br>  2. You can only sign if all dependent assemblies are signed (application assemblies will not be able to sign, if technological assemblies are not signed) <br>  3. Some degree of protection (to change the code, you will need to rebuild all application builds) <br>  If it so happens that the code from the assembly is lost, then signing can be done by rebuilding the assembly.  Rebuilding is done this way (to specify a file with a key, look for a special parameter): <br>  1. ildasm.exe sampleA.exe / source /out:sampleA.il <br>  2. ilasm.exe sampleA.il / exe /out:sampleA.exe <br><br><h5>  Release Strategy </h5><br>  The more often a product is released, the less it seems to users that programmers do nothing.  We tried 2 versions of the release of technological product versions: <br>  1. The latest builds are the best. <br>  Everything that is hosted in SourceControl is considered verified and application programmers can take any server build of technological assemblies.  At the same time, technologists before each Check-in must carefully check their changes. <br>  Pros: <br>  ‚Ä¢ Instant posting of changes <br>  Minuses: <br>  ‚Ä¢ Each Check-In requires an extended check with lots of different functionality that may suffer. <br>  ‚Ä¢ Errors can easily penetrate the version at the customer <br>  2. Periodic release of stable version <br>  Release of the version of technological assemblies on a periodic basis. <br>  Pros: <br>  ‚Ä¢ More reliable integration verification <br>  Minuses: <br>  ‚Ä¢ There is a risk of losing control of the code in the middle of the iteration. <br>  ‚Ä¢ It takes time to check everything again, no instant fixes <br>  During the release of the version for 1-2 days, all technologists are distracted by checking and correcting the errors found.  This is the option we now apply. <br><br><h5>  Assembly Versions </h5><br>  There are 2 strategies for naming build versions: <br>  1. Variable build versions <br>  ‚Ä¢ Updating of applied projects only with recompilation of the project (inability to send a patch to the technology directly to the customer) <br>  ‚Ä¢ Part of the problems will be visible when compiling (relevant for complex dependencies between assemblies) <br>  ‚Ä¢ Problem with type serialization (serialized data stored by the customer may cause problems when updating build versions) <br>  2. Fixed versions of builds <br>  ‚Ä¢ Update simple substitution of assemblies <br>  ‚Ä¢ Problems will be visible at startup because  no recompilation required during upgrade <br>  ‚Ä¢ You can only send the corrected assembly to the customer as a last resort <br>  ‚Ä¢ The release date of the assembly as a conditional version for identification <br>  Our team stopped at the second version because  Often it is necessary to check new technological assemblies on applied projects, and there is no desire or time to recompile them.  Server builds are configured in Team Foundation Server and only the server build can be transferred for deployment. <br><br><h5>  Branching: Pros and Cons </h5><br>  We considered 2 approaches to source code storage: <br>  Branches for adding features, branches for implementations <br>  A plus: <br>  ‚Ä¢ You can make a small change directly to the desired version. <br>  Minus: <br>  ‚Ä¢ Need to do a lot of code merges <br>  Single version without branches <br>  A plus: <br>  ‚Ä¢ No merger <br>  Minus: <br>  ‚Ä¢ The disassembled version cannot be fixed quickly. <br>  We stopped at a simpler second version.  We try not to make long-term changes without Check-In, but Check-in should not destroy the performance of our solutions. <br><br><h5>  External assembly </h5><br>  A few words about OpenSource in a commercial product: if you wish, you can find OpenSource solutions with a good license to solve any necessary problem.  However, when making such a decision, you should think hard about how changes will be made there: <br>  1. Edit everything yourself locally <br>  A plus: <br>  ‚Ä¢ You can do anything <br>  Minus: <br>  ‚Ä¢ When updating the official version, you will have to merge your changes yourself. <br>  2. Send updates to the project supporting team. <br>  A plus: <br>  ‚Ä¢ Additional check for quality patches <br>  Minuses: <br>  ‚Ä¢ Risk that support will cease. <br>  ‚Ä¢ M. b.  long term review and release fixes <br>  ‚Ä¢ Corrections may be rejected for one reason or another. <br>  Sometimes you have to make a choice in favor of a paid decision only because the policy of making changes (at least error correction) is fixed in the license for which money is paid. <br><br><h5>  Obfuscation </h5><br>  How to protect against disassembling code that is available is available from both application and technological assemblies? <br>  You can obfustsirovat before assembling the technological assembly, but then we get: <br>  A plus: <br>  ‚Ä¢ Application programmers will not pry into the process code and ask stupid questions about it <br>  Minuses: <br>  ‚Ä¢ Difficulty debugging for application developers <br>  ‚Ä¢ Possible instability during development <br>  ‚Ä¢ Obfuscation and verification will be performed twice. <br>  The second option is obfuscation of the complete application with all technological assemblies. <br>  Pros: <br>  ‚Ä¢ Obfuscation at the application assembly stage <br>  ‚Ä¢ Ability to debug an application by entering the framework code. Verification of the application operation is performed once <br>  Minus: <br>  ‚Ä¢ Protection of technological assemblies involved in application programmers <br>  We apply the last option. <br><br><h5>  Testing </h5><br>  I will not talk about unit tests - this is necessary for any layer, not just the technology.  However, always technological code must be written taking into account the performance requirements and work flawlessly in multi-threaded mode. <br>  Testing of technological projects, as a rule, is impossible without an end application in which the subject area is described.  In some cases, in order to understand exactly where the error is hidden, you have to create your own separate application and try to repeat the necessary conditions.  Only this option helps to separate the "pickups" from the application code. <br><br><h4>  Conclusion </h4><br>  I can note that working on technology is a very exciting and, in some places, fun activity.  The main thing - do not get carried away too much and sometimes communicate with end users, trying to understand their needs.  Thanks to everyone who read this long monologue to the end. </div><p>Source: <a href="https://habr.com/ru/post/150766/">https://habr.com/ru/post/150766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150759/index.html">An example of using macros in the mcedit editor</a></li>
<li><a href="../150760/index.html">Customizing radiobutton without js</a></li>
<li><a href="../150762/index.html">Zend Framework, subjective impressions</a></li>
<li><a href="../150763/index.html">Work in the style of Smart - or why we really love to work</a></li>
<li><a href="../150765/index.html">New data sources for Teiid, part 1: use DDL</a></li>
<li><a href="../150767/index.html">Recovery of unevenly lit images</a></li>
<li><a href="../150768/index.html">About shooting gigapixel panorama of Yekaterinburg</a></li>
<li><a href="../150769/index.html">Unmanned vehicles are going to legalize in California and another 4 US states</a></li>
<li><a href="../150770/index.html">Methods of dealing with loneliness on the example of DS112 +</a></li>
<li><a href="../150772/index.html">New data sources for Teiid, part 1: use DDL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>