<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A couple of words about floating point numbers in java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few days ago, I was struck by an interesting such question as to what the result of the execution of this code would be: 


double a = 2.0 - 1.1;  
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A couple of words about floating point numbers in java</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/959/489/743/959489743e5b5079ff8781fb5e6aba99.jpg"><br>  A few days ago, I was struck by an interesting such question as to what the result of the execution of this code would be: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a = <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.1</span></span>;</code> </pre> <br>  or such: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { f += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; }</code> </pre><br>  Contrary to all my expectations, the answer: <b>0.89999999999999991</b> in the first case and <b>0.99999999999999989</b> in the second. <br>  For those who want to know why, as well as some more interesting facts about this type of data, you are welcome. <br><br><a name="habracut"></a><br><br>  In general, the answer to the above question will sound something like this: ‚ÄúSuch errors are related to the internal binary (binary) representation of numbers.  Just as in the decimal system it is impossible to accurately represent the result of the 1/3 division, it is impossible to accurately represent the 1/10 in the binary system.  If you need to eliminate rounding errors, you should use the BigDecimal class. ‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There is an important distinction between abstract real numbers, such as œÄ or 0.2, and the double data type in Java.  First, the platonic-perfect representation of real numbers is infinite, while the representation in Java is limited to the number of bits.  However, the accuracy of calculations is an even more urgent problem than the limit on the size of numbers.  Even more "intrigues" a completely original way of rounding numbers, but first things first. <br><br>  It‚Äôs probably worth starting with the binary representation of integers.  This paragraph is useful to us later.  So.  The simplest way to represent integers is the so-called "Direct Code", in which the most significant bit is used to record the sign of a number (0 is positive, 1 is negative), and the remaining bits are used directly to record the value itself.  Thus, the number "-9" in the eight-bit representation will look like 10001001. The disadvantage of this approach is the presence of two zeros ("+0" and "-0") and the complication of arithmetic operations with negative numbers.  Another option that interests us is the "Shift Code", in which, in simple terms, we add to our number a certain constant for this type of representation number equal to 2 ^ (n-1), where n is the number of digits (bits) .  In our case, the example with the number "-9" in the eight-bit representation will look like this: <br>  -9 + 2 ^ (8-1) = -9 + 128 = 119. In binary form, we get 01110111. This option is convenient because we have only one zero, but we will need to take the offset into account when doing arithmetic operations. <br><br>  Here it is worth mentioning about this.  One of the stated goals of the Java language is machine independence.  Calculations must produce the same result, regardless of which virtual machine performs them.  For arithmetic calculations over floating point numbers, this unexpectedly proved to be a difficult task.  The double type uses 64 bits to store numeric values, however some processors use 80-bit floating point registers.  These registers provide additional accuracy at intermediate stages of the calculation, i.e.  the intermediate result of the calculations is stored in an 80-bit register, after which the answer is rounded to 64 bits.  However, this result may be different if in the process of all calculations a 64-bit processor is used.  For this reason, the original description of the JVM indicated that all intermediate calculations should be rounded off.  This caused a protest of many specialists, since such a rounding not only can lead to overflow, but the calculations themselves are slower.  This led to the fact that JDK 1.2 introduced support for the strictfp keyword, which guarantees the reproducibility of the results of all calculations performed within this method, class, or interface (or rather, its implementation).  In other words, the strictfp keyword ensures that floating-point computing on each platform will behave in the same way and with a certain accuracy, even if some platforms can perform calculations with greater accuracy.  Interestingly, for the x86 family of processors, the floating point unit was separated into a separate microcircuit, called a floating point unit (FPU).  Starting with MMX Pentium processors, the floating point module is integrated into the CPU.  <a href="http://en.wikipedia.org/wiki/Floating-point_unit">More details</a> . <br><br>  Further.  The IEEE 754 standard tells us that the representation of real numbers must be written exponentially.  This means that part of the bits encodes the so-called mantissa of the number, the other part is an indication of order (degree), and another bit is used to indicate the sign of the number (0 if the number is positive, 1 if the number is negative).  Mathematically, this is written like this: <br>  <b>(-1) ^ s √ó M √ó 2 ^ E</b> , where s is the sign, M is the mantissa, and E is the exponent.  The exponent is written with a shift that can be obtained by the formula given above. <br><br>  What is a mantissa and an exhibitor?  A mantissa is a fixed-length integer that represents the most significant bits of a real number.  Suppose our mantissa consists of four bits (| M | = 4).  Take, for example, the number "9", which in binary will be equal to 1001. <br>  The exponent (it is also called ‚Äúorder‚Äù or ‚Äúexponent‚Äù) is the degree of the base (two) of the most significant digit.  You can consider it as the number of digits before the point separating the fractional part of the number.  If the exponent is a variable written to the register and unknown when compiled, the number is called the "floating point number".  If the exponent is known in advance, then the number is called the "fixed-point number".  Numbers with a fixed point can be written to ordinary integer variables (registers) by saving only the mantissa.  In the case of writing floating point numbers, both the mantis and the exponent are recorded in the so-called standard form, for example, "1.001e + 3".  It is immediately evident that the mantissa consists of four characters, and the exponent is equal to three. <br><br>  Suppose we want to get a fractional number using the same 3 bits of mantissa.  We can do this if we take, say, E = 1.  Then our number will be equal to <br><br>  1.001e + 1 = 1 √ó 2 ^ 2 + 0 √ó 2 ^ 1 + 0 √ó 2 ^ 0 + 1 √ó 2 ^ (- 1) = 4 + 0.5 = 4.5 <br><br><img src="//habrastorage.org/files/155/d90/3be/155d903be9144b91b5a76ed6463e3065.jpg"><br><br>  One of the problems of this approach may be a different representation of the same number within the same mantissa length.  Our "9-ku", with the length of the mantissa equal to 5, can be represented as 1.00100e + 3 and as 0.10010e + 4 and as 0.01001e + 5.  This is not convenient for equipment, since  it is necessary to take into account the multiplicity of representations when comparing numbers and when performing arithmetic operations on them.  Moreover, it is not economical, since the number of representations is finite, and repetitions reduce the set of numbers that can be represented at all.  However, there is a little trick.  It turns out that the exponent can be used to calculate the value of the first bit.  If all bits of the exponent are 0, then the first bit of the mantissa is also considered to be zero, otherwise it is equal to one.  Floating-point numbers in which the first bit of the mantissa is one, are normalized.  Numbers with a floating point, the first bit of the mantissa in which is zero, are called denormalized.  With their help, much smaller values ‚Äã‚Äãcan be represented.  Since the first bit can always be calculated, there is no need to store it explicitly.  This saves one bit, since an implicit unit does not need to be stored in memory, and provides a unique representation of the number.  In our example with ‚Äú9‚Äù, the normalized representation will be 1.00100e + 3, and the mantissa will be stored in memory as ‚Äú00100‚Äù, since  senior unit implicitly implied.  The problem with this approach is the impossibility of representing zero, which I will talk about later.  You can read more about this and many other things <a href="http://habrahabr.ru/post/112953/">here</a> and <a href="http://habrahabr.ru/post/131171/">here</a> . <br><br>  By the way, in JDK 1.5 it is permissible to specify floating-point numbers in hexadecimal format.  For example, 0.125 can be represented as 0x1.0p-3.  In hexadecimal notation, the sign ‚Äúp‚Äù is used instead of ‚Äúe‚Äù to indicate the exponent. <br><br>  Things to remember when working with Double: <br><br><ol><li>  Integer division by 0 generates an exception, while the result of dividing floating-point numbers is infinity (or NaN in the case of 0.0 / 0 division).  By the way, I was interested to know that the JVM developers, according to the same IEEE 754 standard, also entered the values ‚Äã‚ÄãDouble.NEGATIVE_INFINITY and Double.POSITIVE_INFINITY, equal to -1.0 / 0.0 and 1.0 / 0.0, respectively. </li><li>  Double.MIN_VALUE is actually not the smallest number that can be written in double.  Remember, we said that according to the IEEE 754 standard, the highest mantissa unit is implicitly specified?  So here.  As already stated above, in the normalized form of a floating-point number, it is impossible to represent a zero, since there is no degree of two that would be equal to zero.  And the JVM developers have specifically introduced the Double.MIN_VALUE variable to solve this problem, which, in fact, is the closest possible value to zero.  The smallest value you can save in double is "-Double.MAX_VALUE". <br><pre> <code class="java hljs">System.out.println(<span class="hljs-number"><span class="hljs-number">0.0</span></span> &gt; Double.MIN_VALUE); <span class="hljs-comment"><span class="hljs-comment">//  false</span></span></code> </pre> </li><li>  Developing the previous topic, we can give another interesting example, showing us that not everything is as obvious as it may seem at first glance.  Double.MAX_VALUE returns us 1.7976931348623157E308, but what happens if we convert a string containing a floating-point number to double? <br><br><pre> <code class="java hljs">System.out.println(Double.parseDouble(<span class="hljs-string"><span class="hljs-string">"1.7976931348623157E308"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// (...7E308) = 1.7976931348623157E308 max value System.out.println(Double.parseDouble("1.7976931348623158E308")); // (...8E308) = 1.7976931348623157E308 same??? System.out.println(Double.parseDouble("1.7976931348623159E308")); // (...9E308) = Infinity</span></span></code> </pre><br><br>  It turns out that between Double.MAX_VALUE and Double.POSITIVE_INFINITY there are still some values ‚Äã‚Äãthat are rounded to one side or the other in the calculation.  It is worth staying in more detail. <br><br>  The set of real numbers is infinitely dense (dense).  There is no such thing as the following real number.  For any two real numbers, there is a real number between them.  This property does not hold for floating point numbers.  For each float or double number there is the following number.  In addition, there is a minimum final distance between two consecutive numbers of type float or double.  The Math.nextUp () method returns the next floating-point number that exceeds the specified parameter.  For example, this code prints all float numbers between 1.0 and 2.0 inclusive. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = <span class="hljs-number"><span class="hljs-number">1.0F</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numFloats = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &lt;= <span class="hljs-number"><span class="hljs-number">2.0</span></span>) { numFloats++; System.out.println(x); x = Math.nextUp(x); } System.out.println(numFloats);</code> </pre><br><br>  It turns out that in the interval from 1.0 to 2.0 inclusively there are exactly 8,388,609 float numbers.  This is a lot, but much smaller than an infinite number of real numbers that are in the same range.  Each pair of consecutive numbers of type float is at a distance of approximately 0.0000001 from each other.  This distance is called the unit of least precision (ULP).  For type double, the situation is completely identical, except for the fact that the number of decimal numbers is much higher. </li></ol><br><br>  Perhaps that's all.  Those who wish to "dig deeper" may need the following code: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//           IEEE 754 long lbits = Double.doubleToLongBits(-0.06); long lsign = lbits &gt;&gt;&gt; 63; //  long lexp = (lbits &gt;&gt;&gt; 52 &amp; ((1 &lt;&lt; 11) - 1)) - ((1 &lt;&lt; 10) - 1); //  long lmantissa = lbits &amp; ((1L &lt;&lt; 52) - 1); //  System.out.println(lsign + " " + lexp + " " + lmantissa); System.out.println(Double.longBitsToDouble((lsign &lt;&lt; 63) | (lexp + ((1 &lt;&lt; 10) - 1)) &lt;&lt; 52 | lmantissa));</span></span></code> </pre><br><br>  Thanks to all mastered.  I will be glad to constructive criticism and additions. <br><br>  Materials on the topic: <br>  <a href="http://www.ibm.com/developerworks/ru/library/j-math2/">New Java Math Features, Part 2: Floating Point Numbers</a> <br>  <a href="http://steve.hollasch.net/cgindex/coding/ieeefloat.html">IEEE Standard 754 Floating Point Numbers</a> <br>  <a href="http://docs.oracle.com/javase/specs/">Java Language and Virtual Machine Specifications</a> <br>  <a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B2%25D0%25B5%25D1%2589%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585_%25D1%2587%25D0%25B8%25D1%2581%25D0%25B5%25D0%25BB">Representation of real numbers</a> <br>  <a href="http://habrahabr.ru/post/112953/">What you need to know about floating-point arithmetic</a> <br>  <a href="http://habrahabr.ru/post/130272/">Float Arithmetic</a> </div><p>Source: <a href="https://habr.com/ru/post/219595/">https://habr.com/ru/post/219595/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219583/index.html">Business processes multiplied by efficiency</a></li>
<li><a href="../219585/index.html">Saving Russian electronics - entering foreign markets</a></li>
<li><a href="../219587/index.html">Microsoft: KB2919355 Required for Windows 8.1</a></li>
<li><a href="../219589/index.html">Honda's new Asimo Robot is the most humane of all</a></li>
<li><a href="../219593/index.html">Behavioral Ranking Factors: Big Data Technologies in SEO</a></li>
<li><a href="../219597/index.html">The participants of the Lingvo Cup 2014 will help with the transfer Coursera</a></li>
<li><a href="../219599/index.html">Cloud chat platform in mobile apps</a></li>
<li><a href="../219601/index.html">Suspend the CD, or a practical example of modeling based on OpenSCAD for 3D printing</a></li>
<li><a href="../219603/index.html">"Competition" continues! New competition from InfoTeKS Academy!</a></li>
<li><a href="../219605/index.html">Intricate creatures on your desk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>