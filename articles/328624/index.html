<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elements of functional programming in C ++: mapping compositions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The standard C ++ library is quite good. For many years, the standard algorithms faithfully serve the simple plus sign! 


 But the whole industry is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elements of functional programming in C ++: mapping compositions</h1><div class="post__text post__text-html js-mediator-article"><a name="introduction"></a><br><p>  The standard C ++ library is quite good.  For many years, the standard algorithms faithfully serve the simple plus sign! </p><br><p>  But the whole industry is booming, and the C ++ language with it.  For a long time, people began to realize that no matter how good the standard algorithms are, they have a big drawback: zero composability.  In other words, it is impossible to combine several transformation, filtering, convolution, etc. algorithms without additional difficulties.  etc. </p><br><p>  There are several solutions to this problem.  One of them - <a href="https://github.com/ericniebler/range-v3">lazy calculations and ranges</a> - is already on the way to the standard library. </p><br><p>  However, the good old algorithms are still too early to write off. </p><br><p>  In this article I want to consider one of the techniques, which, although not a complete solution to the composability of algorithms, is quite capable of simplifying work with the old standard algorithms, and will definitely come in handy for working with upcoming versions of the C ++ standard. </p><a name="habracut"></a><br><a name="contents"></a><br><h2>  Content </h2><br><ol><li>  <a href="https://habr.com/ru/post/328624/">Technique of functional objects</a> </li><li>  <a href="https://habr.com/ru/post/328624/">Simple composition</a> </li><li>  <a href="https://habr.com/ru/post/328624/">Multiposition composition</a> </li><li>  <a href="https://habr.com/ru/post/328624/">Addition</a> </li><li>  <a href="https://habr.com/ru/post/328624/">Conclusion</a> </li></ol><br><a name="functional-objects"></a><br><h2 id="tehnika-funkcionalnyh-obektovcontents">  <a href="https://habr.com/ru/post/328624/">Technique of functional objects</a> </h2><br><p>  Before proceeding directly to the point, I want to touch on the technique that is not yet very widely represented in the current standard library, but it seems to be quite common in STL2, at least in the part that lazy calculations will command and ranges. </p><br><p>  If you are an experienced positive, you can safely <a href="https://habr.com/ru/post/328624/">skip</a> this part. </p><br><p>  Are you still here?  Then imagine that we have a set of containers, and we face a difficult task: to write the dimensions of all these containers into another container. </p><br><p>  <abbr title="Overload with arrays for simplicity is omitted.">We write a function</abbr> that returns the size of the container: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container &amp; container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container.size(); }</code> </pre> <br><p>  Now, it would seem, nothing prevents to call the standard <code>std::transform</code> algorithm. </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; containers{...}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt; sizes; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(containers.begin(), containers.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(sizes), size);</code> </pre> <br><p>  But it was not there: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  : /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ couldn't deduce template parameter '_UnaryOperation' /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ std::transform(containers.begin(), containers.end(), std::back_inserter(sizes), size); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ^~~~</span></span></code> </pre> <br><p>  <code>size</code> is a template function.  The template function is specified either explicitly (in our case it will be <code>size&lt;std::vector&lt;int&gt;&gt;</code> ), or at the time of the call.  And just the <code>size</code> entry does not allow the compiler to understand with which arguments this function will be called. </p><br><p>  This problem can be circumvented by declaring <code>size</code> not as a function, but as a <abbr title="Every time a functional object is called a functor, some mathematician suffers. Pity the mathematicians.">functional object</abbr> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_fn</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Container &amp; container)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container.size(); } }; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size = size_fn{};</code> </pre> <br><p>  Now there are no more compilation errors: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(containers.begin(), containers.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(sizes), size);</code> </pre> <br><p>  Of course, the experienced positive positive will say that functional objects also have certain disadvantages in comparison with functions.  But we will not focus on this now. </p><br><a name="simple-composition"></a><br><h2 id="prostaya-kompoziciyacontents">  <a href="https://habr.com/ru/post/328624/">Simple composition</a> </h2><br><p>  So, the technique is mastered, we consider a more complex life example. </p><br><p>  Imagine that we need to get all associated values ‚Äã‚Äãfrom an associative array.  To do this, you can use the algorithm already familiar to us <code>std::transform</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; m{...}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; r; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(m.begin(), m.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(r), [] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; p) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.second;});</code> </pre> <br><p>  So far, everything is quite simple.  Short and clear lambda function, all is well.  But if the mapping logic becomes complicated, the situation will deteriorate dramatically. </p><br><p>  For example, you need to take not just the second element of the pair, but calculate the square root of it, and round the result to the nearest integer.  Lambda becomes too long, will have to format: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(m.begin(), m.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(r), [] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lround(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(p.second)); });</code> </pre> <br><p>  On the other hand, our intention could be expressed in a shorter and clearer way: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(m.begin(), m.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(r), get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; | <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span> | lround);</code> </pre> <br><p>  Attention draws record <code>get&lt;1&gt; | sqrt | lround</code> <code>get&lt;1&gt; | sqrt | lround</code>  <code>get&lt;1&gt; | sqrt | lround</code> .  This syntax should be understood as follows: take the element of a tuple with index 1, take the square root of it and round it to the nearest integer.  Exactly what was required. </p><br><p>  Schematically, this can be represented as: <br><img src="https://habrastorage.org/web/b6d/d9e/571/b6dd9e57143248329637f716f41d0e4d.png" alt="Simple mapping"></p><br><p>  You can implement the <code>get</code> functional object as follows: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Index&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_fn</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tuple&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Tuple &amp;&amp; t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get&lt;Index&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Tuple&gt;(t)); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Index&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> get = get_fn&lt;Index&gt;{};</code> </pre> <br><p>  <code>lround</code> propose to implement the functional objects <code>sqrt</code> and <code>lround</code> as an exercise for all who are interested. </p><br><p>  The very mechanism of the composition is implemented through an appropriate functional object: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">compose_fn</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ts &amp;&amp; ... ts)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l(r(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ts&gt;(ts)...)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ts &amp;&amp; ... ts)</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l(r(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ts&gt;(ts)...)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ts &amp;&amp; ... ts)</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(l)(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(r)(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ts&gt;(ts)...)); } L l; R r; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L &amp;&amp; l, R &amp;&amp; r)</span></span></span><span class="hljs-function"> -&gt; compose_fn&lt;</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::decay_t&lt;L&gt;, </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::decay_t&lt;R&gt;&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;L&gt;(l), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;R&gt;(r)}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> | (compose_fn&lt;Ts...&gt; l, R &amp;&amp; r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> compose(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;R&gt;(r), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(l)); }</code> </pre> <br><p>  It is important to note that in this implementation, the <code>compose</code> function applies the composition from right to left, as is customary in mathematics.  In other words, <code>compose(f, g)(x)</code> equivalent to <code>f(g(x))</code> . </p><br><p>  The operator changes the order of the composition.  That is, <code>(f | g)(x)</code> equivalent to <code>g(f(x))</code> . </p><br><p>  This is done in order not to mislead a programmer who is familiar with solutions such as <a href="http://www.boost.org/doc/libs/1_64_0/libs/range/doc/html/range/reference/adaptors/introduction.html">Boost Range Adapters</a> , <a href="https://github.com/ericniebler/range-v3">range-v3</a> , and console console. </p><br><a name="nary-composition"></a><br><h2 id="mnogopozicionnaya-kompoziciyacontents">  <a href="https://habr.com/ru/post/328624/">Multiposition composition</a> </h2><br><p>  So far everything was easy and understandable.  But we will not stop at this. </p><br><p>  Suppose we want to sort an array of pairs: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, type_with_no_ordering&gt;&gt; v{...};</code> </pre> <br><p>  For the second element of the pair, the order relation is not set (which is clear from its name), so it makes no sense to compare it, moreover, such a comparison simply does not compile.  Therefore, the sorting is written as: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(v.begin(), v.end(), [] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; l, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; r) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l.first &lt; r.first;});</code> </pre> <br><p>  Looks a bit long.  You can format for beauty. </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(v.begin(), v.end(), [] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; l, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l.first &lt; r.first; });</code> </pre> <br><p>  In my opinion, it is more convenient to read, but still quite verbose. </p><br><p>  Is it possible to simplify this expression?  Let's try to write pseudocode, in which we will express with words what we want to do: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(v.begin(), v.end(), ___);</code> </pre> <br><p>  The action we need ‚Äî a comparison by the first element ‚Äî can be divided into two logical steps: taking the first element from each pair and the comparison itself. </p><br><p>  To take the first element, create a functional object based on the existing <code>get</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> first = get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;;</code> </pre> <br><p>  For the actual comparison, SBSH already has a suitable tool: <code>std::less</code> . </p><br><p>  But how to put these functions together?  I will try to illustrate the problem. </p><br><p>  The <code>std::sort</code> algorithm <code>std::sort</code> expects two objects to be input. <br><img src="https://habrastorage.org/web/323/816/769/323816769f854d1cbb9599e4257378ec.png" alt="Comparer"></p><br><p>  And by itself, <code>std::less</code> satisfies this condition. </p><br><p>  At the same time, <code>first</code> is a single function.  It takes only one argument.  Does not fit: <br><img src="https://habrastorage.org/web/8db/1d6/f2a/8db1d6f2a4d44b70a9e29846dfae40cb.png" alt="Not fit"></p><br><p>  So we can't just write <code>first | std::less{}</code>  <code>first | std::less{}</code> . </p><br><p>  At the same time, the result we want to get should look something like this: <br><img src="https://habrastorage.org/web/200/6d3/21c/2006d321cc5443879326b03a635c4810.png" alt="Result"></p><br><p>  That is, we must link this whole block with the <code>std::less</code> function: <br><img src="https://habrastorage.org/web/99c/4c4/75b/99c4c475bfe443feb543b7b29334c9b2.png" alt="How to compose"></p><br><p>  If we translate thoughts into code, we want to get the following entry: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(v.begin(), v.end(), each(first) | <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::less&lt;&gt;{});</code> </pre> <br><p>  But it turns out that the function generated by writing <code>each(first)</code> must not only accept, but also return two values ‚Äã‚Äãat once, in order to submit them to the input <code>std::less</code> .  And in C ++, a function cannot return more than one value! </p><br><p>  However, there is a solution.  It is necessary to implement a special composition scheme for the functional object <code>each</code> . </p><br><p>  The functional object itself <code>each</code> is trivial: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> UnaryFunction&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">each_fn</span></span></span><span class="hljs-class"> {</span></span> UnaryFunction f; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> UnaryFunction&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnaryFunction &amp;&amp; f)</span></span></span><span class="hljs-function"> -&gt; each_fn&lt;</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::decay_t&lt;UnaryFunction&gt;&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;UnaryFunction&gt;(f)}; }</code> </pre> <br><p>  It is not even a fully functional object.  Rather, it is a special container tag, which, when compositing, will inform the composition engine that the composition of the function stored inside the container should not be performed as usual. </p><br><p>  And here are the composition mechanisms themselves: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">each_compose_fn</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ts &amp;&amp; ... ts)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l(r(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ts&gt;(ts))...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ts &amp;&amp; ... ts)</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l(r(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ts&gt;(ts))...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ts &amp;&amp; ... ts)</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(l)(r(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Ts&gt;(ts))...); } L l; R r; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> UnaryFunction1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> UnaryFunction2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(each_fn&lt;UnaryFunction1&gt; l, each_fn&lt;UnaryFunction2&gt; r)</span></span></span><span class="hljs-function"> -&gt; each_fn&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(compose(lf, rf))</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {compose(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(lf), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(rf))}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> UnaryFunction&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(L &amp;&amp; l, each_fn&lt;UnaryFunction&gt; r)</span></span></span><span class="hljs-function"> -&gt; each_compose_fn&lt;</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::decay_t&lt;L&gt;, UnaryFunction&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;L&gt;(l), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(rf)}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> UnaryFunction, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> | (each_fn&lt;UnaryFunction&gt; l, R &amp;&amp; r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> compose(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;R&gt;(r), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(l)); }</code> </pre> <br><p>  The main difference from the usual composition - in the disclosure of the list of arguments. <br>  In the <code>compose</code> function, the expansion is as follows: <code>l(r(args...))</code> , and in <code>each_compose</code> , otherwise: <code>l(r(args)...)</code> . </p><br><p>  In other words, in the first case, a single place function is applied to the result of a multi-place function, and in the second case, a multi-place function is applied to the results of applying a single place function to each of the input parameters. </p><br><p>  Now we can compose multi-seat functions with single: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(v.begin(), v.end(), each(first) | <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::less&lt;&gt;{}); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lower_bound(v.begin(), v.end(), x, each(second) | <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::greater&lt;&gt;{}); <span class="hljs-comment"><span class="hljs-comment">//  ..</span></span></code> </pre> <br><p>  This is victory. </p><br><a name="appendix"></a><br><h2 id="dopolneniecontents">  <a href="https://habr.com/ru/post/328624/">Addition</a> </h2><br><p>  Many will note that it is too expensive to implement for each function, each property of an object, etc.  separate functional object.  And this is impossible to disagree.  For example, in one of the examples above, it would be more convenient not to implement new functional objects for the <code>lround</code> and <code>sqrt</code> functions, but to use the existing library ones. </p><br><p>  There is even if imperfect, but the working solution to this problem - drumming - macros. </p><br><p>  For example, to call a member function of a class, a macro can be implemented like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEM_FN(f)\ [] (auto &amp;&amp; x, auto &amp;&amp; ... args)\ -&gt; decltype(auto)\ {\ return std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;decltype(x)&gt;(x).f(std::forward&lt;decltype(args)&gt;(args)...);\ }</span></span></span></span></code> </pre> <br><p>  It will be used as follows: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; containers{...}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::none_of(containers.begin(), containers.end(), MEM_FN(empty));</code> </pre> <br><p>  Similar macros can be implemented to call free functions: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FN(f)\ [] (auto &amp;&amp; ... args)\ -&gt; decltype(auto)\ {\ return f(std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;decltype(args)&gt;(args)...);\ }</span></span></span></span></code> </pre> <br><p>  And even for access to class members: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEMBER(m)\ [] (auto &amp;&amp; x)\ -&gt; decltype(auto)\ {\ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   ,      */</span></span></span><span class="hljs-meta">\ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta">\ return (std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;decltype(x)&gt;(x).m);\ } struct Class { int x; }; std::vector&lt;Class&gt; v{...}; std::remove_if(v.begin(), v.end(), MEMBER(x) | equal_to(5));</span></span></span></span></code> </pre> <br><p>  The code is prompted in places so as not to introduce too many new entities. </p><br><a name="conclusion"></a><br><h2 id="zaklyucheniecontents">  <a href="https://habr.com/ru/post/328624/">Conclusion</a> </h2><br><p>  What is all this for?  Why not just use lambdas? </p><br><p>  Ljubda can use and need.  But, unfortunately, lambdas often generate a lot of duplicate code.  It happens that the lambda completely repeat each other.  It happens that a few lambdas differ quite a bit, but they are not amenable to decomposition. </p><br><p>  The approach described in this article allows you to assemble simple lambda from the "cubes", reducing the amount of hand-written code and, consequently, reducing the chance of making a mistake when writing the next lambda. </p><br><p>  Although this approach can work independently, it is intended primarily to simplify work with algorithms and ranges. </p><br><p>  <a href="https://github.com/izvolov/burst/tree/master/burst/functional">Full code with all the details</a> . </p><br><a name="links"></a><br><h2 id="ssylkicontents">  <a href="https://habr.com/ru/post/328624/">Links</a> </h2><br><ol><li>  <a href="http://www.boost.org/doc/libs/1_64_0/libs/range/doc/html/range/reference/adaptors/introduction.html">Boost Range Adapters</a> </li><li>  <a href="https://ericniebler.github.io/std/wg21/D4128.html">Ranges for the Standard Library</a> </li><li>  <a href="https://github.com/Ableton/atria">atria :: xform</a> </li></ol><br><p>  <a href="https://habr.com/ru/post/328624/">To top</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/328624/">https://habr.com/ru/post/328624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328608/index.html">Python PID Controller Model</a></li>
<li><a href="../328610/index.html">Can Laravel be used for large enterprise solutions?</a></li>
<li><a href="../328612/index.html">Your bot for a few hours, or talk about beer with the machine</a></li>
<li><a href="../328616/index.html">Who needs calls when there are chats and bots?</a></li>
<li><a href="../328620/index.html">Soft Mocks for Go! (redefinition of functions and methods in runtime)</a></li>
<li><a href="../328628/index.html">How to make it happen</a></li>
<li><a href="../328630/index.html">Product design digest, April 2017</a></li>
<li><a href="../328632/index.html">PHP Digest number 108 - the latest news, materials and tools (April 24 - May 14, 2017)</a></li>
<li><a href="../328634/index.html">Kooboo CMS Licensing FAQ</a></li>
<li><a href="../328636/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ262 (May 8 - 14, 2017)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>