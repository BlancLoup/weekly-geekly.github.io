<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using std :: optional in C ++ 17</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's take a pair of two types of <YourType, bool> - what can you do with a composition of this kind? 


 In this article I will tell you about std::o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using std :: optional in C ++ 17</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/gf/3c/fi/gf3cfihtte8aw5t_jpk25d0osoe.png"></p><br><p> Let's take a pair of two types of <code>&lt;YourType, bool&gt;</code> - what can you do with a composition of this kind? </p><br><p>  In this article I will tell you about <code>std::optional</code> - a new auxiliary type added in C ++ 17.  This is a wrapper for your type and the flag indicates whether your value is initialized or not.  Let's see where this can be useful. </p><br><h2 id="vstuplenie">  Introduction </h2><br><p>  By adding logical flags to other types, you can achieve what is called "Nullable types".  As mentioned earlier, the flag is used to indicate whether a value is available or not.  Such a wrapper expressively represents an object that can be empty (not through comments :). </p><a name="habracut"></a><br><p>  You can reach the null value of an object by using unique identifiers (-1, infinity, <code>nullptr</code> ), but this is not as precisely a thought as a separate wrapper type.  You can even use <code>std::unique_ptr&lt;Type&gt;</code> and treat the null pointer as an uninitialized object - this will work, but at the same time you will have to accept the cost of allocating memory for the object where it is not necessary. </p><br><p>  Optional types are what came from the world of functional programming, bringing with them type safety and expressiveness.  Most other languages ‚Äã‚Äãhave something similar: for example <code>std::option</code> in <code>Rust</code> , <code>Optional&lt;T&gt;</code> in <code>Java</code> , <code>Data.Maybe</code> in <code>Haskell</code> . </p><br><p>  <code>std::optional</code> was added to C ++ 17 from <code>boost::optional</code> , where it has been available for many years.  Starting in C ++ 17, you can simply write <code>#include &lt;optional&gt;</code> to use this type. </p><br><p>  This type is a value-type (you can copy it this way).  Moreover, for <code>std::optional</code> not necessary to allocate memory separately. </p><br><p>  <code>std::optional</code> is part <strong>of C ++ dictionary types</strong> along with <code>std::any</code> , <code>std::variant</code> and <code>std::string_view</code> . </p><br><h2 id="ispolzovanie">  Using </h2><br><p>  Usually, an optional type can be used in the following scenarios: </p><br><ul><li>  If you want to beautifully present the nullable-type. <br><ul><li>  This is better than using unique values ‚Äã‚Äã(for example, <code>-1</code> , <code>nullptr</code> , <code>NO_VALUE</code> or something like that). </li><li>  For example, the middle username is optional.  You can assume that an empty line will be enough for this, but it may be important to understand that the user has entered something.  With <code>std::optional&lt;std::string&gt;</code> you can get more information. </li></ul></li><li>  Return the result of any calculations that could not give the final result, but this is not an error. <br><ul><li>  For example, searching for an element in the dictionary: if there is no element corresponding to a given key, then this is not an error, but we should handle this situation. </li></ul></li><li>  For receiving resources with delayed loading. <br><ul><li>  For example, if a resource does not have a default constructor and the construction of the object takes quite a long time.  Then you can declare <code>std::optional&lt;Resource&gt;</code> , and pass this object on to the system, and perform the download later if necessary. </li></ul></li><li>  To pass optional parameters to functions. </li></ul><br><p>  I like the definition of the optional type of <code>boost</code> , which sums up the situations when we should use it.  <a href="https://www.boost.org/doc/libs/1_67_0/libs/optional/doc/html/boost_optional/tutorial/when_to_use_optional.html">From the boost documentation</a> : </p><br><blockquote>  The template class std :: optional controls an optional value, i.e., a value that may or may not be represented. <br>  A common example of using an optional data type is the return value of a function, which may return an erroneous result during execution.  Unlike other approaches, such as std :: pair &lt;T, bool&gt;, the optional data type is well managed with heavy objects for construction and is more readable, since it clearly expresses the intentions of the developer. </blockquote><p>  Although it is sometimes difficult to decide whether to use an optional type, you definitely should not use it to handle errors.  It is best suited for cases where the lack of meaning is the normal behavior of the program. </p><br><h2 id="prostoy-primer">  Simple example </h2><br><p>  Below you can see a simple example of what can be done using the optional type: </p><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; UI::FindUserNick() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nick_available) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { mStrNickName }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt; <span class="hljs-comment"><span class="hljs-comment">//   ,     { }; } // : std::optional&lt;std::string&gt; UserNick = UI-&gt;FindUserNick(); if (UserNick) Show(*UserNick);</span></span></code> </pre> <br><p>  In the code above, we declared a function that returns an optional string.  If the username is available, it will return a string.  If not, it will return <code>std::nullopt</code> .  Later we can assign this value to an optional type and check it ( <code>std::optional</code> has a cast operator to type <code>bool</code> ) whether it contains a real value or not.  The <code>std::optional</code> also overloads <code>operator*()</code> for easier access to the contained value. </p><br><p>  In the following paragraphs, you can see how to create <code>std::optional</code> , work with it, pass it, and even its performance, which you are probably interested in seeing. </p><br><h2 id="seriya">  Series </h2><br><p>  This article is part of my C ++ 17 library utility series.  Here is a list of other topics that I‚Äôm talking about: </p><br><ul><li>  <a href="https://habr.com/post/369811/">Refactoring using C ++ 17 std :: optional</a> . </li><li>  Use std :: optional ( <strong>this post</strong> ). </li><li>  Error handling when using std :: optional. </li><li>  Using std :: variant. </li><li>  Using std :: any. </li><li>  In place constructors for std :: optional, std :: variant and std :: any. </li><li>  Use std :: string_view. </li><li>  C ++ 17 utilities for searching and converting strings. </li><li>  Work with std :: filesystem. </li><li>  Something else?  :) </li></ul><br><p>  C ++ 17 STL Resources: </p><br><ul><li>  <a href="https://leanpub.com/cpp17">The complete guide to C ++ 17 by Nikolai Josuttis (English language)</a> . </li><li>  <a href="https%253A%252F%252Fwww.pluralsight.com%252Fcourses%252Fcplusplus-fundamentals-c17">Basics of C ++, including C ++ 17 by Keith Gregory (English)</a> . </li><li>  <a href="http://amzn.to/2v6KkmV">The recipe book of C ++ 17 STL from Jacek Galovitsza (English language)</a> . </li></ul><br><p>  OK, now let's work with <code>std::optional</code> . </p><br><h2 id="sozdanie-stdoptional">  Creating <code>std::optional</code> </h2><br><p>  There are several options for creating <code>std::optional</code> : </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ : std::optional&lt;int&gt; oEmpty; std::optional&lt;float&gt; oFloat = std::nullopt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ : std::optional&lt;int&gt; oInt(10); std::optional oIntDeduced(10); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ deduction guides /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ make_optional auto oDouble = std::make_optional(3.0); auto oComplex = make_optional&lt;std::complex&lt;double&gt;&gt;(3.0, 4.0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ in_place std::optional&lt;std::complex&lt;double&gt;&gt; o7{std::in_place, 3.0, 4.0}; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  vector    {1, 2, 3} std::optional&lt;std::vector&lt;int&gt;&gt; oVec(std::in_place, {1, 2, 3}); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span>: auto oIntCopy = oInt;</code> </pre> <br><p>  As you can see in the example above, you have the amazing flexibility to create an object.  Creating an object is very simple for both primitive types and more complex ones. </p><br><p>  Creating <code>in place</code> especially interesting and the <code>std::in_place</code> also supported in other types, such as <code>std::any</code> and <code>std::variant</code> . </p><br><p>  For example, you can write: </p><br><pre> <code class="hljs perl">// https:<span class="hljs-regexp"><span class="hljs-regexp">//godbolt</span></span>.org/g/FPBSak struct Point { Point(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b) : <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>(a), <span class="hljs-keyword"><span class="hljs-keyword">y</span></span>(b) { } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">y</span></span>; }; std::optional&lt;Point&gt; opt{std::in_place, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> vs std::optional&lt;Point&gt; opt{{<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}};</code> </pre> <br><p>  This saves the creation of a temporary <code>Point</code> object. </p><br><p>  I'll tell you about <code>std::in_place</code> later, do not switch the channel and stay with us. </p><br><h2 id="vozvrat-stdoptional-iz-funkcii">  Return <code>std::optional</code> from function </h2><br><p>  If you return an optional value from a function, then it is very convenient to return either <code>std::nullopt</code> , or the resulting value: </p><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; TryParse(Input input) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input.valid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.asString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt; }</code> </pre> <br><p>  In the example above, you can see that I am returning a <code>std::string</code> , obtained from <code>input.asString()</code> and wrapping it in <code>std::optional</code> .  If the value is not available, the function will simply return <code>std::nullopt</code> . </p><br><p>  Of course, you can also simply declare an empty optional object at the beginning of your function and assign it a calculated value if it is correct.  Thus, we can rewrite the code above as follows: </p><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; TryParse(Input input) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; oOut; <span class="hljs-comment"><span class="hljs-comment">// empty if (input.valid()) oOut = input.asString(); return oOut; }</span></span></code> </pre> <br><p>  Which version is better depends on the context.  I prefer short functions, so my choice is version number 1 (with multiple <code>return</code> ). </p><br><h2 id="poluchenie-znacheniya">  Getting the value </h2><br><p>  Perhaps the most important operation for an optional type (other than creating it) is how you can get the stored value. </p><br><p>  There are several options for this: </p><br><ul><li>  Use <code>operator*()</code> and <code>operator-&gt;()</code> in the same way as in iterators.  If the object does not contain a real value, then the <strong>behavior is undefined</strong> ! </li><li>  <code>value()</code> - returns the value or throws an exception <a href="http://en.cppreference.com/w/cpp/utility/optional/bad_optional_access"><code>std::bad_optional_access</code></a> . </li><li>  <code>value_or(default)</code> - returns the value if available, or returns <code>default</code> . </li></ul><br><p>  To check if there is a real value in the object, you can use the <code>has_value()</code> method or simply check the object with <code>if (optional) {...}</code> , since the optional type is overloaded with the cast operator to <code>bool</code> . </p><br><p>  For example: </p><br><pre> <code class="hljs pgsql">//   <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() std::optional&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; oint = <span class="hljs-number"><span class="hljs-number">10</span></span>; std::cout&lt;&lt; "oint " &lt;&lt; *opt1 &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>() std::optional&lt;std::string&gt; ostr("hello"); try { std::cout &lt;&lt; "ostr " &lt;&lt; ostr.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } catch (const std::bad_optional_access&amp; e) { std::cout &lt;&lt; e.what() &lt;&lt; "\n"; } //   value_or() std::optional&lt;<span class="hljs-type"><span class="hljs-type">double</span></span>&gt; odouble; //  std::cout&lt;&lt; "odouble " &lt;&lt; odouble.value_or(<span class="hljs-number"><span class="hljs-number">10.0</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre> <br><p>  Thus, it will be most convenient to check if there is a real value in an optional object, and then use it: </p><br><pre> <code class="hljs lua">//   : std::optional&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; maybe_create_hello(); // ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (auto ostr = maybe_create_hello(); ostr) std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ostr "</span></span> &lt;&lt; *ostr &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ostr is null\n"</span></span>;</code> </pre> <br><h2 id="vozmozhnosti-stdoptional">  Features <code>std::optional</code> </h2><br><p>  Let's see what other options the optional type has: </p><br><h3 id="izmenenie-znacheniya">  Change value </h3><br><p>  If you already have an optional object, you can easily change its value using the <code>emplace</code> , <code>reset</code> , <code>swap</code> and <code>assign</code> methods.  If you assign (or nullify) the object <code>std::nullopt</code> , then a real object that is stored in an optional one will have a destructor called. </p><br><p>  Here is a small example: </p><br><pre> <code class="hljs rust">#include &lt;optional&gt; #include &lt;iostream&gt; #include &lt;string&gt; class UserName { public: explicit UserName(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string&amp; <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) : mName(<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"UserName::UserName(\'"</span></span>; std::cout &lt;&lt; mName &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\')\n"</span></span>; } ~UserName() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"UserName::~UserName(\'"</span></span>; std::cout &lt;&lt; mName &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\')\n"</span></span>; } private: std::string mName; }; int main() { std::optional&lt;UserName&gt; oEmpty; <span class="hljs-comment"><span class="hljs-comment">// emplace: oEmpty.emplace("Steve"); //  ~Steve   Mark: oEmpty.emplace("Mark"); //   oEmpty.reset(); //  ~Mark //   : //oEmpty = std::nullopt; //   : oEmpty.emplace("Fred"); oEmpty = UserName("Joe"); }</span></span></code> </pre> <br><p>  This code is available here: <a href="http://coliru.stacked-crooked.com/a/bea3f18a89cdbc3f">@Coliru</a> . </p><br><h3 id="sravneniya">  Comparisons </h3><br><p>  <code>std::optional</code> allows you to compare the objects contained in it almost "normally", but with a few exceptions, when the operands are <code>std::nullopt</code> .  See below: </p><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">optional</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">iostream</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>() { <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::optional&lt;int&gt; oEmpty; <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::optional&lt;int&gt; <span class="hljs-built_in"><span class="hljs-built_in">oTwo</span></span>(2); <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::optional&lt;int&gt; <span class="hljs-built_in"><span class="hljs-built_in">oTen</span></span>(10); <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::cout &lt;&lt; std::boolalpha; <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::cout &lt;&lt; (oTen &gt; oTwo) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::cout &lt;&lt; (oTen &lt; oTwo) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::cout &lt;&lt; (oEmpty &lt; oTwo) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::cout &lt;&lt; (oEmpty == std::nullopt) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">std</span></span>::cout &lt;&lt; (oTen == <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre> <br><p>  When executing the code above, it will display: </p><br><pre> <code class="hljs lisp">true // (<span class="hljs-name"><span class="hljs-name">oTen</span></span> &gt; oTwo) false // (<span class="hljs-name"><span class="hljs-name">oTen</span></span> &lt; oTwo) true // (<span class="hljs-name"><span class="hljs-name">oEmpty</span></span> &lt; oTwo) true // (<span class="hljs-name"><span class="hljs-name">oEmpty</span></span> == std:<span class="hljs-symbol"><span class="hljs-symbol">:nullopt</span></span>) true // (<span class="hljs-name"><span class="hljs-name">oTen</span></span> == <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><p>  This code is available here: <a href="http://coliru.stacked-crooked.com/a/f77422dc68f3cb09">@Coliru</a> . </p><br><h2 id="primery-s-stdoptional">  Examples with <code>std::optional</code> </h2><br><p>  Below you will find two examples where <code>std::optional</code> fits perfectly. </p><br><h3 id="imya-polzovatelya-s-neobyazatelnym-nikneymom-i-vozrastom">  Username with optional nickname and age </h3><br><pre> <code class="hljs rust">#include &lt;optional&gt; #include &lt;iostream&gt; class UserRecord { public: UserRecord (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::string&amp; name, std::optional&lt;std::string&gt; nick, std::optional&lt;int&gt; age) : mName{name}, mNick{nick}, mAge{age} { } friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; stream, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserRecord&amp; user); private: std::string mName; std::optional&lt;std::string&gt; mNick; std::optional&lt;int&gt; mAge; }; std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserRecord&amp; user) { os &lt;&lt; user.mName &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.mNick) { os &lt;&lt; *user.mNick &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.mAge) os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"age of "</span></span> &lt;&lt; *user.mAge; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os; } int main() { UserRecord tim { <span class="hljs-string"><span class="hljs-string">"Tim"</span></span>, <span class="hljs-string"><span class="hljs-string">"SuperTim"</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span> }; UserRecord nano { <span class="hljs-string"><span class="hljs-string">"Nathan"</span></span>, std::nullopt, std::nullopt }; std::cout &lt;&lt; tim &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; std::cout &lt;&lt; nano &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre> <br><p>  This code is available here: <a href="http://coliru.stacked-crooked.com/a/f02d37fc4319bcd8">@Coliru</a> . </p><br><h3 id="parsing-celyh-chisel-iz-komandnoy-stroki">  Parsing integers from the command line </h3><br><pre> <code class="hljs rust">#include &lt;optional&gt; #include &lt;iostream&gt; #include &lt;string&gt; std::optional&lt;int&gt; ParseInt(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>*arg) { try { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { std::stoi(std::string(arg)) }; } catch (...) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"cannot convert \'"</span></span> &lt;&lt; arg &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\' to int!\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { }; } int main(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>* argv[]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) { auto oFirst = ParseInt(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); auto oSecond = ParseInt(argv[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oFirst &amp;&amp; oSecond) { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"sum of "</span></span> &lt;&lt; *oFirst &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and "</span></span> &lt;&lt; *oSecond; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">" is "</span></span> &lt;&lt; *oFirst + *oSecond &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } } }</code> </pre> <br><p>  This code is available here: <a href="http://coliru.stacked-crooked.com/a/76118c6062bad7c4">@Coliru</a> . </p><br><p>  The code above uses an optional data type to indicate whether the conversion was successful.  Note that we actually wrapped the exceptions that C ++ might throw into the optional data type, so we will skip all the errors associated with this.  This moment is quite controversial, since we usually have to report errors to the user. </p><br><h3 id="drugie-primery">  Other examples </h3><br><ul><li>  Submission of other optional entries for your types.  As in the example with the user account.  It is better to use <code>std::optional&lt;Key&gt;</code> than to leave comments like: <code>//    0xDEADBEEF,   </code> or something like that. </li><li>  The return values ‚Äã‚Äãare for the search functions (assuming that you do not care about the errors that occur, for example: dropping the connection, database errors, etc.). </li></ul><br><h2 id="proizvoditelnost-i-analiz-ispolzovaniya-pamyati">  Performance and memory analysis </h2><br><p>  When you use <code>std::optional</code> , you pay for it with increased memory usage.  At least one additional byte. </p><br><p>  In the abstract, your version of STL may implement the optional data type as: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _initialized; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">aligned_storage_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt; _storage; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//  };</span></span></code> </pre> <br><p>  In short, <code>std::optional</code> simply wraps your type, prepares a place for it, and adds one boolean parameter.  This means that it will increase the size of your type according to the alignment rules. </p><br><p>  There is one comment for <a href="https://www.reddit.com/r/cpp/comments/8hlo01/using_c17_stdoptional/dykvlcg">this construction</a> : "No standard library can implement <code>std::optional</code> like this (it must use <code>union</code> because of <code>constexpr</code> )".  Therefore, the code above simply demonstrates an example, not a real implementation. </p><br><p>  Alignment rules are important, as the standard says: </p><br><blockquote>  Template class optional [optional.optional]: <br>  The contained value must be located in the memory region, appropriately aligned for type <code>T</code> </blockquote><p>  For example: </p><br><pre> <code class="hljs pgsql">// sizeof(<span class="hljs-type"><span class="hljs-type">double</span></span>) = <span class="hljs-number"><span class="hljs-number">8</span></span> // sizeof(<span class="hljs-type"><span class="hljs-type">int</span></span>) = <span class="hljs-number"><span class="hljs-number">4</span></span> std::optional&lt;<span class="hljs-type"><span class="hljs-type">double</span></span>&gt; od; // sizeof = <span class="hljs-number"><span class="hljs-number">16</span></span> bytes std::optional&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; oi; // sizeof = <span class="hljs-number"><span class="hljs-number">8</span></span> bytes</code> </pre> <br><p>  While <code>bool</code> usually takes one byte, the optional data type is forced to follow the alignment rules.  Thus, the size of <code>std::optional&lt;T&gt;</code> larger than <code>sizeof(T) + 1</code> . </p><br><p>  For example, if you have this type: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; mMin; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; mMax; };</code> </pre> <br><p>  It will take more space than if you used your type instead of <code>std::optional</code> : </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mMinAvailable; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mMaxAvailable; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mMin; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mMax; };</code> </pre> <br><p>  In the first case, the size of the structure is 32 bytes!  In the second case, only 24. </p><br><p>  <a href="https://godbolt.org/g/XUJZKL">Test case for Compiler Explorer</a> . </p><br><p>  The link is a great explanation about performance and memory usage, taken from the boost documentation: <a href="https://www.boost.org/doc/libs/1_67_0/libs/optional/doc/html/boost_optional/tutorial/performance_considerations.html">performance issues</a> . </p><br><p>  And in the article <a href="https://akrzemi1.wordpress.com/2015/07/15/efficient-optional-values/">"Effective optional values" the</a> author discusses how to write a wrapper for an optional type, which can be a little faster. </p><br><p>  I wonder if there is a chance to use at least some magic of the compiler and reuse some space to put this additional object initialization flag inside an optional type. Then no additional space would be necessary. </p><br><h2 id="osobennyy-sluchay-stdoptionalbool-i-stdoptionalt">  Special case: <code>std::optional&lt;bool&gt;</code> and <code>std::optional&lt;T*&gt;</code> </h2><br><p>  While you can use <code>std::optional</code> for any type you want, you need to take special care when using an optional type with logical type and pointers. </p><br><p>  <code>std::optional&lt;bool&gt; ob</code> - what does it say?  With this construct, you have a three-state boolean type.  Therefore, if you really need it, it is probably better to use a real triple type - <del>  <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/tribool.html">std :: tribool</a> </del>  <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/tribool.html">boost :: tribool ( <strong>edit</strong> : Antervis)</a> . </p><br><p>  Moreover, the use of this type can be confusing, because <code>ob</code> converted to <code>bool</code> if there is a value inside it and <code>*ob</code> returns a stored value (if available). </p><br><p>  A similar situation may occur with pointers: </p><br><pre> <code class="hljs pgsql">//   !   ! std::optional&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>*&gt; opi { <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opi &amp;&amp; *opi) { std::cout &lt;&lt; **opi &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> *opi; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opi) std::cout &lt;&lt; "opi is still not empty!";</code> </pre> <br><p>  A pointer to an <code>int</code> is actually a <code>nullable</code> type, so wrapping it in an optional type will only complicate its use. </p><br><h2 id="itog">  Total </h2><br><p>  Whew!  Yes, it was a lot of text about the optional type, but that's not all. </p><br><p>  Nevertheless, we considered the main use, creation and operation of these with a convenient type.  I believe that we have many cases where the optional type fits much better than using some predefined values ‚Äã‚Äãto represent <code>nullable</code> types. </p><br><p>  I would like to remind the following things about the optional type: </p><br><ul><li>  <code>std::optional</code> is a wrapper for expressing the <code>nullable</code> type. </li><li>  <code>std::optional</code> does not use dynamic memory allocation. </li><li>  <code>std::optional</code> may contain a value or be empty. <br><ul><li>  Use <code>operator*()</code> , <code>operator-&gt;()</code> , <code>value()</code> , <code>value_or()</code> to get the real value. </li></ul></li><li>  <code>std::optional</code> implicitly cast to <code>bool</code> , so you can easily check if it contains any value or not. </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/372103/">https://habr.com/ru/post/372103/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../372093/index.html">iRidium pro: new visualization and automation platform for IoT</a></li>
<li><a href="../372095/index.html">Project "Eye" Part 18</a></li>
<li><a href="../372097/index.html">Microsoft filed a lawsuit against the US Justice Department, not wanting to secretly listen to users</a></li>
<li><a href="../372099/index.html">How do bank transfers actually work?</a></li>
<li><a href="../372101/index.html">Space time. The age of the universe. Friday</a></li>
<li><a href="../372105/index.html">Eight-Bit Jokes 2</a></li>
<li><a href="../372107/index.html">QuickTime farewell: Apple stops QT support for Windows</a></li>
<li><a href="../372109/index.html">Scientists managed to reproduce the sound of the Tsar Bell</a></li>
<li><a href="../372111/index.html">Homemade ultrasound scanner received the first images</a></li>
<li><a href="../372113/index.html">Rights holders for the first time will require ‚ÄúYandex‚Äù to remove the link from the search results</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>