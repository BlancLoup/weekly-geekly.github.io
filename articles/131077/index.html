<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ZF2 EventManager</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A slightly free translation of the EventManager in Zend Framework 2 from the Matthew Weier O'Phinney blog . 
 The article in the examples tells about ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ZF2 EventManager</h1><div class="post__text post__text-html js-mediator-article"> A slightly free translation of the <code>EventManager</code> in Zend Framework 2 from the <a href="http://weierophinney.net/matthew/archives/266-Using-the-ZF2-EventManager.html">Matthew Weier O'Phinney blog</a> . <br>  The article in the examples tells about what <code>Zend\EventManager</code> , how to use it, what advantages are provided by the event method of solving programmer tasks in PHP.  About what's waiting for us in ZF2. <br>  The original and the translation was written with the release of zf2.dev4, before .beta1, no significant changes occurred.  But still, the article should be used for review, no more. <br><a name="habracut"></a><br><h4>  Terminology </h4><br><ul><li>  <b>Event Manager (Event Manager)</b> <br>  an object that aggregates event handlers (Listener) for one or more named events (Event), and also initiates the processing of these events. <br></li><li>  <b>Listener (Event Handler)</b> <br>  callback function / method. </li><li>  <b>Event (Event)</b> <br>  an action that initiates the execution of certain event handlers </li></ul><br>  An event is an object containing data, when and how it was triggered: what object caused it, passed parameters, etc.  The event also has a name, which allows you to bind handlers to a specific event, referring to the name of this event. <br><br><h4>  Let's start </h4><br>  The minimum things you need to work with all this: <br><ul><li>  an instance of the <code>EventManager</code> class. </li><li>  One or more event handlers associated with one or more events. </li><li>  Call <code>EventManager::trigger()</code> to initiate event handling. </li></ul><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">EventManager</span></span>\<span class="hljs-title"><span class="hljs-title">EventManager</span></span>; $events = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventManager(); $events-&gt;attach(<span class="hljs-string"><span class="hljs-string">'do'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($e)</span></span></span><span class="hljs-function"> </span></span>{ $event = $e-&gt;getName(); $params = $e-&gt;getParams(); printf( <span class="hljs-string"><span class="hljs-string">'Handled event "%s", with parameters %s'</span></span>, $event, json_encode($params) ); }); $params = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'foo'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'bat'</span></span>); $events-&gt;trigger(<span class="hljs-string"><span class="hljs-string">'do'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, $params);</code> </pre> <br><br>  At the output we get: <br><pre>  Handled event "do", with parameters {"foo": "bar", "baz": "bat"} </pre><br>  Nothing complicated! <br><blockquote>  Note: The examples use an anonymous function, but you can use the name of a function, a static class method, or an object method. </blockquote><br>  But what about the second ‚Äúnull‚Äù argument in the <code>$events-&gt;trigger()</code> method? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Typically, an <code>EventManager</code> object <code>EventManager</code> used within a class, and an event is triggered within a method of this class.  And this second argument is the "context", or the "target", and in the described case, would be an instance of this class.  This provides access for event handlers to the request object, which can sometimes be useful / necessary. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">EventManager</span></span>\<span class="hljs-title"><span class="hljs-title">EventCollection</span></span>, <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">EventManager</span></span>\<span class="hljs-title"><span class="hljs-title">EventManager</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $events; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setEventManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventCollection $events)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;events = $events; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">events</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;events) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;setEventManager(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventManager( <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">__CLASS__</span></span>, get_called_class()) ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;events; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($foo, $baz)</span></span></span><span class="hljs-function"> </span></span>{ $params = compact(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;events()-&gt;trigger(<span class="hljs-keyword"><span class="hljs-keyword">__FUNCTION__</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>, $params); } } $example = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Example(); $example-&gt;events()-&gt;attach(<span class="hljs-string"><span class="hljs-string">'do'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($e)</span></span></span><span class="hljs-function"> </span></span>{ $event = $e-&gt;getName(); $target = get_class($e-&gt;getTarget()); <span class="hljs-comment"><span class="hljs-comment">// "Example" $params = $e-&gt;getParams(); printf( 'Handled event "%s" on target "%s", with parameters %s', $event, $target, json_encode($params) ); }); $example-&gt;do('bar', 'bat');</span></span></code> </pre> <br><br>  This example essentially does the same thing as the first.  The main difference is that the second argument of the <code>trigger()</code> method we pass to the handler context (the object - which started the processing of this event), and the handler receives it through the <code>$e-&gt;getTarget()</code> method - and can do something with it (within a reasonable :)). <br><br>  You may have 2 questions: <br><ul><li>  What is an <code>EventCollection</code> ? </li><li>  And what arguments do we pass to the <code>EventManager</code> constructor? </li></ul><br>  Answer further. <br><br><h4>  EventCollection vs EventManager </h4><br>  One of the principles that ZF2 is trying to follow is the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BF%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8_%25D0%259B%25D0%25B8%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B2">Liskov substitution principle</a> .  The interpretation of this principle may be the following: For any class that in the future may need to be redefined by another class, a ‚Äúbasic‚Äù interface must be defined.  And it allows developers to use another implementation of a class by defining the methods of this interface. <br><br>  Therefore, an <code>EventCollection</code> interface was developed that describes an object capable of aggregating listeners into events and initiating these events.  <code>EventManager</code> is a standard implementation that will go into ZF2. <br><br><h4>  StaticEventManager </h4><br>  One aspect that the EventManager implementation provides is the ability to interact with the <code>StaticEventCollection</code> .  This class allows you to attach handlers not only to named events, but also to events initiated by a specific context or purpose.  <code>EventManager</code> , when processing events, also takes event handlers (subscribed to the current context) from the <code>StaticEventCollection</code> object and executes them. <br><br>  How it works? <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">EventManager</span></span>\<span class="hljs-title"><span class="hljs-title">StaticEventManager</span></span>; $events = StaticEventManager::getInstance(); $events-&gt;attach(<span class="hljs-string"><span class="hljs-string">'Example'</span></span>, <span class="hljs-string"><span class="hljs-string">'do'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($e)</span></span></span><span class="hljs-function"> </span></span>{ $event = $e-&gt;getName(); $target = get_class($e-&gt;getTarget()); <span class="hljs-comment"><span class="hljs-comment">// "Example" $params = $e-&gt;getParams(); printf( 'Handled event "%s" on target "%s", with parameters %s', $event, $target, json_encode($params) ); });</span></span></code> </pre> <br><br>  This example is almost identical to the previous one.  The only difference is that the first argument in the <code>attach()</code> method, we pass the context - 'Example', to which we want to attach our handler.  In other words, when processing the 'do' event, if this event is triggered by the context of 'Example', then we call our handler. <br><br>  This is where the <code>EventManager</code> constructor <code>EventManager</code> play a role.  The constructor allows you to pass a string, or an array of strings, specifying the name / names of contexts for which you need to take event handlers from the <code>StaticEventManager</code> .  If an array of contexts is passed, then all event handlers from these contexts will be executed.  Event handlers attached directly to the <code>EventManager</code> will be executed before the handlers defined in the <code>StaticEventManager</code> . <br><br>  Let us combine the definition of the class Example and the static event handler from the last 2 examples, and add the following: <br><br><pre> <code class="php hljs">$example = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Example(); $example-&gt;do(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'bat'</span></span>);</code> </pre> <br><br>  At the output we get: <br><pre>  Handled event "do" on target "Example", with parameters {"foo": "bar", "baz": "bat"} </pre><br>  And now let's expand the class Example: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubExample</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><br>  Notice which parameters we pass to the <code>EventManager</code> constructor - this is an array of <code>__CLASS__</code> and <code>get_called_class()</code> .  This means that when you call the <code>do()</code> method of the <code>SubExample</code> class, our event handler will also execute.  If we specified only 'SubExample' in the constructor, then our handler will be executed only with <code>SubExample::do()</code> , but not with <code>Example::do()</code> . <br><br>  Names used as contexts or goals need not be class names;  you can use arbitrary names.  For example, if you have a set of classes responsible for Caching or Logging, you can name the contexts as ‚Äúlog‚Äù and ‚Äúcache‚Äù, and use these names, rather than class names. <br><br>  If you do not want Event Manager to handle static events, you can pass the <code>null</code> parameter to the <code>setStaticConnections()</code> method: <br><br><pre> <code class="php hljs">$events-&gt;setStaticConnections(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre> <br><br>  In order to connect back the handling of static events: <br><br><pre> <code class="php hljs">$events-&gt;setStaticConnections(StaticEventManager::getInstance());</code> </pre> <br><br><h4>  Listener Aggregates </h4><br>  You may need to sign an entire class to handle several events, and in this ‚Äúclass handler‚Äù define methods for handling some events.  To do this, you can implement the <code>HandlerAggregate</code> interface in your handler class.  This interface defines 2 methods of <code>attach(EventCollection $events)</code> and <code>detach(EventCollection $events)</code> . <br><br>  (I did not understand what I translated, the example below is more understandable). <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">EventManager</span></span>\<span class="hljs-title"><span class="hljs-title">Event</span></span>, <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">EventManager</span></span>\<span class="hljs-title"><span class="hljs-title">EventCollection</span></span>, <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">EventManager</span></span>\<span class="hljs-title"><span class="hljs-title">HandlerAggregate</span></span>, <span class="hljs-title"><span class="hljs-title">Zend</span></span>\<span class="hljs-title"><span class="hljs-title">Log</span></span>\<span class="hljs-title"><span class="hljs-title">Logger</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogEvents</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerAggregate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $handlers = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $log; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Logger $log)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;log = $log; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventCollection $events)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handlers[] = $events-&gt;attach(<span class="hljs-string"><span class="hljs-string">'do'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>, <span class="hljs-string"><span class="hljs-string">'log'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handlers[] = $events-&gt;attach(<span class="hljs-string"><span class="hljs-string">'doSomethingElse'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>, <span class="hljs-string"><span class="hljs-string">'log'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventCollection $events)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handlers <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $handler) { $events-&gt;detach($handler); <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handlers[$key]; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;handlers = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Event $e)</span></span></span><span class="hljs-function"> </span></span>{ $event = $e-&gt;getName(); $params = $e-&gt;getParams(); $log-&gt;info(sprintf(<span class="hljs-string"><span class="hljs-string">'%s: %s'</span></span>, $event, json_encode($params))); } }</code> </pre> <br><br>  To add such a handler to the event manager, use: <br><br><pre> <code class="php hljs">$doLog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogEvents($logger); $events-&gt;attachAggregate($doLog);</code> </pre> <br><br>  and any event that our handler ( <code>LogEvents</code> ) has to handle will be processed by the corresponding class method.  This allows you to define ‚Äúcomplex‚Äù event handlers in one place (stateful handlers). <br><br>  Pay attention to the <code>detach()</code> method.  Just like <code>attach()</code> , it takes an <code>EventManager</code> object as an argument, and ‚Äúdetaches‚Äù all handlers (from our array of handlers - <code>$this-&gt;handlers[]</code> ) from the event manager.  This is possible because <code>EventManager::attach()</code> returns an object representing the handler - which we 'attached' earlier in the <code>LogEvents::attach()</code> method. <br><br><h4>  Handler Result </h4><br>  You may need to get the result of executing the event handlers.  It should be borne in mind that several event handlers may be signed for one event.  And the result of each handler should not conflict with the results of other handlers. <br><br>  <code>EventManager</code> returns a <code>ResponseCollection</code> object.  This class is inherited from the <code>SplStack</code> class, and gives you access to the results of all handlers (the result of the last handler will be at the beginning of the result stack). <br><br>  <code>ResponseCollection</code> addition to the <code>SplStack</code> methods, <code>SplStack</code> has additional methods: <br><ul><li>  <code>first()</code> is the result of the first handler </li><li>  <code>last()</code> - the result of the execution of the last handler </li><li>  <code>contains($value)</code> - checking for the presence of a result in the result stack, returns <code>true</code> / <code>false</code> . </li></ul><br>  As a rule, when initiating event handling, you should not be strongly dependent on the output of the handlers.  Moreover, when initiating an event, you cannot always be sure which event handlers will be subscribed to this event (perhaps there will not be a single handler at all, and you will not get any result).  However, you have the ability to interrupt the execution of handlers if the desired result is already obtained in one of the handlers. <br><br><h4>  Interrupt event handling </h4><br>  If one of the handlers received a result that the initiator of the event expected;  or the handler suddenly decides that something is going wrong;  or one of the handlers, for some reason, decides that no further handlers are needed - you have a mechanism to interrupt the execution of the 'stack' of event handlers. <br><br>  An example of where this might be needed is a caching mechanism built on the basis of an <code>EventManager</code> .  At the beginning of your method, you initiate a ‚Äúsearch data in cache‚Äù event, and if one of the handlers finds the necessary data in the responsible cache, the rest of the handlers are interrupted, and you return the data obtained from the cache.  If it does not, then you generate the data, and trigger the ‚Äúwrite to cache‚Äù event. <br><br>  <code>EventManager</code> provides two ways to do this.  The first way is to use a special method <code>triggerUntil()</code> , which checks the result of each handler executed, and if the result meets certain requirements, then the execution of subsequent handlers is interrupted. <br><br>  Example: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someExpensiveCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($criteria1, $criteria2)</span></span></span><span class="hljs-function"> </span></span>{ $params = compact(<span class="hljs-string"><span class="hljs-string">'criteria1'</span></span>, <span class="hljs-string"><span class="hljs-string">'criteria2'</span></span>); $results = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;events()-&gt;triggerUntil(<span class="hljs-keyword"><span class="hljs-keyword">__FUNCTION__</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>, $params, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($r <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> SomeResultClass); }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($results-&gt;stopped()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $results-&gt;last(); } <span class="hljs-comment"><span class="hljs-comment">// ... do some work ... }</span></span></code> </pre> <br><br>  The arguments to the <code>triggerUntil()</code> method are similar to the arguments to the <code>trigger()</code> method, with the exception of the optional argument at the end - the callback function, which checks the result of each handler, and if it returns <code>true</code> , then the subsequent handlers are interrupted. <br><br>  Following this method, we know that the probable cause of the interruption of event processing is that the result of the work of the last executed handler satisfies our criteria. <br><br>  Another way to interrupt event handling is to use the <code>stopPropagation(true)</code> method in the body of the handler itself.  What will cause the event manager to stop the execution of subsequent handlers. <br><br><pre> <code class="php hljs">$events-&gt;attach(<span class="hljs-string"><span class="hljs-string">'do'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($e)</span></span></span><span class="hljs-function"> </span></span>{ $e-&gt;stopPropagation(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeResultClass(); });</code> </pre> <br><br>  With this approach, you can no longer be sure that event handling was interrupted due to the fact that the handler‚Äôs last result matches our criteria. <br><br><h4>  Handler execution order </h4><br>  You may want to specify the order of execution of the handlers.  For example, you want the handler who maintains records in Log to execute guaranteedly, despite the fact that other handlers can interrupt the processing of this event at any time.  Or when implementing Caching: a handler that searches in the cache was executed earlier than others;  and the cache handler, on the contrary, was executed later. <br><br>  <code>EventManager::attach()</code> and <code>StaticEventManager::attach()</code> have an optional <code>priority</code> argument (it defaults to 1) with which you can control the priority of the execution of handlers.  A handler with a higher priority is executed before handlers with a lower priority. <br><br><pre> <code class="php hljs">$priority = <span class="hljs-number"><span class="hljs-number">100</span></span>; $events-&gt;attach(<span class="hljs-string"><span class="hljs-string">'Example'</span></span>, <span class="hljs-string"><span class="hljs-string">'do'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($e)</span></span></span><span class="hljs-function"> </span></span>{ $event = $e-&gt;getName(); $target = get_class($e-&gt;getTarget()); <span class="hljs-comment"><span class="hljs-comment">// "Example" $params = $e-&gt;getParams(); printf( 'Handled event "%s" on target "%s", with parameters %s', $event, $target, json_encode($params) ); }, $priority);</span></span></code> </pre> <br><br>  Matthew Weier O'Phinney recommends using priorities only when absolutely necessary.  And I probably agree with him. <br><br><h4>  Putting it all together: A simple caching mechanism </h4><br>  In the previous sections, it was written that using events and interrupting the processing of these is an interesting way to implement a caching mechanism in an application.  Let's create a complete example of this. <br><br>  First we define a method that could use caching. <br><br>  Matthew Weier O'Phinney often uses <code>__FUNCTION__</code> as an event name in his examples, and considers it a good practice because it allows you to easily write a macro to trigger events, and also allows you to uniquely determine the uniqueness of these names (especially as the context is usually the event).  And for the separation of events caused by one method, use the postfixes like ‚Äúdo.pre‚Äù, ‚Äúdo.post‚Äù, ‚Äúdo.error‚Äù, etc. <br><br>  In addition, <code>$params</code> passed to the event is a list of arguments passed to the method.  This is because the arguments may not be stored in the object, and handlers may not get the parameters they need from the context.  But the question remains, what is the name of the result parameter for the event that writes to the cache?  The example uses <code>__RESULT__</code> , which is convenient, since double underlining on both sides is usually reserved by the system. <br><br>  Our method might look something like this: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someExpensiveCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($criteria1, $criteria2)</span></span></span><span class="hljs-function"> </span></span>{ $params = compact(<span class="hljs-string"><span class="hljs-string">'criteria1'</span></span>, <span class="hljs-string"><span class="hljs-string">'criteria1'</span></span>); $results = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;events()-&gt;triggerUntil(<span class="hljs-keyword"><span class="hljs-keyword">__FUNCTION__</span></span> . <span class="hljs-string"><span class="hljs-string">'.pre'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>, $params, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($r <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> SomeResultClass); }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($results-&gt;stopped()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $results-&gt;last(); } <span class="hljs-comment"><span class="hljs-comment">// ... do some work ... $params['__RESULT__'] = $calculatedResult; $this-&gt;events()-&gt;trigger(__FUNCTION__ . '.post', $this, $params); return $calculatedResult; }</span></span></code> </pre> <br><br>  Now we define event handlers that work with the cache.  We need to attach handlers to the 'someExpensiveCall.pre' and 'someExpensiveCall.post' events.  In the first case, if the data is found in the cache, we return it.  In the latter, we save the data to the cache. <br><br>  We also assume that the <code>$cache</code> variable is defined earlier, and is similar to the Zend_Cache object.  For the 'someExpensiveCall.pre' handler, we set the priority to 100 to ensure that the handler is faster than others, and for 'someExpensiveCall.post', the priority is -100, in case other handlers want to modify the data before writing to the cache. <br><br><pre> <code class="php hljs">$events-&gt;attach(<span class="hljs-string"><span class="hljs-string">'someExpensiveCall.pre'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($e)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($cache)</span></span></span><span class="hljs-function"> </span></span>{ $params = $e-&gt;getParams(); $key = md5(json_encode($params)); $hit = $cache-&gt;load($key); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $hit; }, <span class="hljs-number"><span class="hljs-number">100</span></span>); $events-&gt;attach(<span class="hljs-string"><span class="hljs-string">'someExpensiveCall.post'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($e)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($cache)</span></span></span><span class="hljs-function"> </span></span>{ $params = $e-&gt;getParams(); $result = $params[<span class="hljs-string"><span class="hljs-string">'__RESULT__'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($params[<span class="hljs-string"><span class="hljs-string">'__RESULT__'</span></span>]); $key = md5(json_encode($params)); $cache-&gt;save($result, $key); }, <span class="hljs-number"><span class="hljs-number">-100</span></span>);</code> </pre> <br><blockquote>  Note: we could define <code>HandlerAggregate</code> , and store <code>$cache</code> in a class property, and not import it into an anonymous function. </blockquote><br><br>  Of course, we could implement a caching mechanism in the object itself, and not put it into an event handler.  But this approach gives us the ability to connect caching handlers to other events (implement a caching mechanism for other classes, storing the sampling logic from the cache and saving to the cache in one place), or attach other handlers to these events (which would deal with for example logging, or validation).  The fact is that if you design your class using events, you make it more flexible and extensible. <br><br><h4>  Conclusion </h4><br>  <code>EventManager</code> is a new and powerful addition to the Zend Framework.  It is already being used with the new MVC prototype to expand the capabilities of some of its aspects.  After the release of ZF2 event model, I am sure, will be very much in demand. <br><br>  Of course, there are some rough edges, which the people are working to eliminate. <br><br>  From myself I will add - there is nothing cardinally new, it is nice that such a thing will appear in Zende - I will definitely use it. <br>  I think the text is saturated with terms and hard to read (partly due to the lack of experience in translating articles). <br>  I have nothing against criticism. <br><br>  Original: <a href="http://weierophinney.net/matthew/archives/266-Using-the-ZF2-EventManager.html">http://weierophinney.net/matthew</a> . </div><p>Source: <a href="https://habr.com/ru/post/131077/">https://habr.com/ru/post/131077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../131071/index.html">Rules of ant battles</a></li>
<li><a href="../131072/index.html">Two-dimensional segment tree (with group modification of elements)</a></li>
<li><a href="../131073/index.html">Interaction of managed and unmanaged code</a></li>
<li><a href="../131074/index.html">PhpBB3 trap system</a></li>
<li><a href="../131076/index.html">New app - Friday - another step towards Siri</a></li>
<li><a href="../131078/index.html">CAD consolidation. Remote work on professional graphic stations</a></li>
<li><a href="../131079/index.html">Digest Wanted.VC # 19</a></li>
<li><a href="../131080/index.html">Free webinar and competition for all WebMatrix</a></li>
<li><a href="../131081/index.html">DELL Streak 7 - preparation of the tablet on camera</a></li>
<li><a href="../131082/index.html">PHP extension for asynchronous POSIX I / O</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>