<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Decorators and reflection in TypeScript: from beginner to expert (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: TypeScript is a rather young and actively developing language. Unfortunately, there is quite a bit of information about him in th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Decorators and reflection in TypeScript: from beginner to expert (Part 1)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/15d/2a0/6ce/15d2a06ceeac47c4b8e31b3ca7f6b44a.jpeg"><br><br>  <em>From the translator: TypeScript is a rather young and actively developing language.</em>  <em>Unfortunately, there is quite a bit of information about him in the Russian part of the Internet, which does not contribute to its popularity.</em> <br><br>  <em>Many of the features that are now implemented in ES6, appeared much earlier in TypeScript.</em>  <em>Moreover, some of the capabilities and proposed ES7 standards also have experimental implementations in this language.</em>  <em>About one of them, which appeared relatively recently - decorators - and will be discussed.</em> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <em>I bring to your attention a translation of the article (or rather, a series of articles) about decorators in TypeScript under the authorship of <a href="http://www.remojansen.com/">Remo H.Jansen</a></em> <br><br><a name="habracut"></a><br><br>  Not so long ago, Microsoft and Google <a href="http://blogs.msdn.com/b/somasegar/archive/2015/03/05/typescript-lt-3-angular.aspx">announced a joint work</a> on TypeScript and Angular 2.0. <br><br><blockquote>  We are pleased to announce that we are combining TypeScript and AtScript languages, and also that Angular 2, the next version of the popular JavaScript library for creating websites and web applications, will be developed in TypeScript <br><br></blockquote><br><br><img src="https://habrastorage.org/files/f22/19d/2c9/f2219d2c93284224ba279be3bbd4af14.jpg"><br><br><h2>  <font color="#fd004c">Annotations and decorators</font> </h2><br><br>  This collaboration helped TypeScript to develop new language features, among which we will highlight <strong>annotations</strong> . <br><br><blockquote>  Annotations are a way to add metadata to a class declaration for use in dependency injection or compiler directives. <br><br></blockquote><br><br>  Annotations were suggested by the AtScript team from Google, but they are not standard.  In the meantime, decorators have been proposed as a standard in ECMAScript 7 for changing classes and properties at the design stage. <br><br>  Annotations and decorators are very similar: <br><br><blockquote>  Annotations and decorators are about the same.  From the user's point of view, they have exactly the same syntax.  The difference is that we do not control how annotations add metadata to our code.  We can view decorators as an interface for building something that behaves like annotations. <br><br>  In the long term, however, we will focus on decorators, since they are the existing proposed standard.  AtScript is TypeScript, and TypeScript implements decorators. <br><br></blockquote><br><br>  Let's take a look at the TypeScript decorator syntax. <br><br><h2>  <font color="#fd004c">TypeScript Decorators</font> </h2><br><br>  In the TypeScript source code, you can find the signatures of the available types of decorators: <br><br><pre><code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ClassDecorator = &lt;TFunction extends <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>&gt;(target: TFunction) =&gt; TFunction | <span class="hljs-built_in"><span class="hljs-built_in">void</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> PropertyDecorator = (target: <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>, propertyKey: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> | symbol) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">void</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MethodDecorator = &lt;T&gt;(target: <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>, propertyKey: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> | symbol, <span class="hljs-keyword"><span class="hljs-keyword">descriptor</span></span>: TypedPropertyDescriptor&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | <span class="hljs-built_in"><span class="hljs-built_in">void</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ParameterDecorator = (target: <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>, propertyKey: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> | symbol, parameterIndex: <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">void</span></span>;</code> </pre> <br>  As you can see, they can be used to annotate a <strong>class</strong> , <strong>property</strong> , <strong>method,</strong> or <strong>parameter</strong> .  Let's take a closer look at each of these types. <br><br><h2>  <font color="#fd004c">Method Decorators</font> </h2><br><br>  Now that we know what the decorators signature looks like, we can try to implement them.  Let's start with the <strong>method decorator</strong> .  Let's create a method decorator called "log". <br><br>  To call the decorator before declaring a method, you need to write the character "@", and then the name of the decorator used.  In case the decorator is called "log", this syntax looks like this: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@log</span></span> foo(n: number) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br>  Before using <code>@log</code> , you must declare the decorator itself somewhere in our application.  Let's look at its implementation: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target: Function, key: string, value: any)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { value: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">: any[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = args.map(a =&gt; JSON.stringify(a)).join(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = value.value.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, args); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = JSON.stringify(result); console.log(`Call: ${key}(${a}) =&gt; ${r}`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }; }</code> </pre> <br>  The method decorator takes 3 arguments: <br><br><ul><li>  target - the method for which the decorator is used; </li><li>  key - the name of this method; </li><li>  value - the descriptor of this property (property descriptor), if it exists within the object, otherwise undefined.  You can get the handle using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor ()</a> method. </li></ul><br><br>  A bit strange, yes?  We did not pass any of these parameters when we used the <code>@log</code> decorator in the class <code>C</code> declaration.  In this regard, two questions arise: <strong>who is passing these arguments?</strong>  and <strong>where exactly is the log method called?</strong> <br><br>  Answers to them can be found by looking at the code that generates TypeScript for the example above. <br><br><pre> <code class="hljs javascript"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> C = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ } C.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(C.prototype, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, __decorate([ log ], C.prototype, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(C.prototype, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> C; })();</code> </pre> <br>  Without the <code>@log</code> decorator <code>@log</code> generated Javascript code for class <code>C</code> would look like this: <br><br><pre> <code class="hljs actionscript"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> C = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } C.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> C; })();</code> </pre> <br>  As you can see, adding <code>@log</code> following code to the class definition with the TypeScript compiler: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.defineProperty(C.prototype, "foo", __decorate( [<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>], // decorators C.prototype, // target "foo", // key <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.getOwnPropertyDescriptor(C.prototype, "foo") // <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> ); );</code> </pre> <br>  If we refer to the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">documentation</a> , we will learn the following about the defineProperty method: <br><br><blockquote>  The <code>Object.defineProperty()</code> method detects a new or changes an existing property directly on an object and returns this object. <br><br></blockquote><br><br>  The TypeScript compiler passes the prototype <code>C</code> , the name of the method to be decorated ('foo'), and the result of the <code>__decorate</code> function to the <code>__decorate</code> method. <br><br>  <code>defineProperty</code> used to override the method being decorated.  The new implementation of the method is the result of the function <code>__decorate</code> .  A new question arises: <strong>where is the <code>__decorate</code> function <code>__decorate</code> ?</strong> <br><br>  If you previously worked with TypeScript, you might notice that when we use the <code>extends</code> , a function called <code>__extends</code> generated by the compiler. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> __extends = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__extends || <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b.hasOwnProperty(p)) d[p] = b[p]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor = d; } __.prototype = b.prototype; d.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> __(); };</code> </pre> <br>  Similarly, when we use a decorator, a function called <code>__decorate</code> generated by the TypeScript compiler.  Let's take a look at it. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> __decorate = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__decorate || <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">decorators, target, key, desc</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span> === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.decorate === <span class="hljs-string"><span class="hljs-string">"function"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.decorate(decorators, target, key, desc); } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> decorators.reduceRight(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o, d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (d &amp;&amp; d(o)) || o; }, target); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> decorators.reduceRight(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o, d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (d &amp;&amp; d(target, key)), <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> decorators.reduceRight(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o, d</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (d &amp;&amp; d(target, key, o)) || o; }, desc); } };</code> </pre> <br>  The first line in this listing uses the <code>OR</code> operator to make sure that the <code>__decorate</code> function generated more than once will not be overwritten again and again.  In the second line we can notice the condition: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span> === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.decorate === <span class="hljs-string"><span class="hljs-string">"function"</span></span>)</code> </pre> <br>  This condition is used to detect the future possibility of the JavaScript <a href="">metadata reflection API</a> .  We will take a closer look at it closer to the end of this series of articles. <br><br>  Let's stop for a second and remember how we came to this point.  The <code>foo</code> method is overridden by the result of the <code>__decorate</code> function, which is called with the following parameters: <br><br><pre> <code class="hljs pgsql">__decorate( [<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>], // decorators C.prototype, // target "foo", // key <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.getOwnPropertyDescriptor(C.prototype, "foo") // <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> );</code> </pre> <br>  Now we are inside the <code>__decorate</code> function and, since the metadata reflection API is not available, the version generated by the compiler will be executed <br><br><pre> <code class="hljs pgsql">// arguments.length ===  ,   __decorate() switch (arguments.length) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> decorators.reduceRight(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(o, d) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (d &amp;&amp; d(o)) || o; }, target); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> decorators.reduceRight(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(o, d) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (d &amp;&amp; d(target, key)), <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }, <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> decorators.reduceRight(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(o, d) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (d &amp;&amp; d(target, key, o)) || o; }, <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>); }</code> </pre> <br>  Since in our case 4 arguments were passed to the <code>__decorate</code> method, the last option will be selected.  Dealing with this code is not so easy because of the meaningless names of variables, but we are not afraid, are we? <br><br>  Let's first learn what the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">reduceRight</a> method <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">does.</a> <br><br><blockquote>  <code>reduceRight</code> applies the accumulating function to each element of the array (in order from right to left) and returns a single value. <br><br></blockquote><br><br>  The code below performs exactly the same operation, but is rewritten for ease of understanding: <br><br><pre> <code class="hljs pgsql"> [<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>].reduceRight(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> log(C.prototype, "foo", <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>; } }, <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.getOwnPropertyDescriptor(C.prototype, "foo"));</code> </pre> <br>  When this code is executed, the <code>log</code> decorator is called and we see the parameters passed to it: <code>C.prototype</code> , <code>"foo"</code> and <code>previousValue</code> .  That is, now we know the answers to our questions: <br><br><ul><li>  Where do these arguments come from? </li><li>  Where exactly is the <code>log</code> function called? <br><br>  If we go back to the implementation of the <code>log</code> decorator, we can understand much better what happens when we call it. <br><br>  function log (target: Function, key: string, value: any) { <br><br><pre> <code class="hljs cmake"> // <span class="hljs-keyword"><span class="hljs-keyword">target</span></span> === C.prototype // key === <span class="hljs-string"><span class="hljs-string">"foo"</span></span> // value === Object.getOwnPropertyDescriptor(C.prototype, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { value: <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (...args: any[]) { //   ,    foo,   var a = args.map(a =&gt; JSON.stringify(a)).join(); //  foo()     var result = value.value.apply(this, args); //     var r = JSON.stringify(result); //        console.log(`Call: <span class="hljs-variable"><span class="hljs-variable">${key}</span></span>(<span class="hljs-variable"><span class="hljs-variable">${a}</span></span>) =&gt; <span class="hljs-variable"><span class="hljs-variable">${r}</span></span>`); //    foo <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } };</code> </pre> <br>  } <br><br></li></ul><br><br>  After decorating, the <code>foo</code> method will continue to work as usual, but its calls will also run additional logging functionality added in the <code>log</code> decorator. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = new <span class="hljs-type"><span class="hljs-type">C</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.foo(<span class="hljs-number"><span class="hljs-number">23</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Call: foo(23) =&gt; 46" console.log(r); // 46</span></span></code> </pre> <br><br><h2>  <font color="#fd004c">findings</font> </h2><br><br>  Not a bad adventure, huh?  I hope you enjoyed it as much as I did.  We‚Äôve just started, and we‚Äôve already learned how to do some really cool things. <br><br>  Method decorators can be used for various interesting "chips".  For example, if you worked with <a href="http://sinonjs.org/docs/"><code>"" (spy</code> ) in test frameworks like SinonJS</a> , you might be <a href="http://sinonjs.org/docs/">delighted</a> to use decorators to create "spies" simply by adding the <code>@spy</code> decorator. <br><br>  In the next part, we will learn how to work with <strong>property decorators</strong> . </div><p>Source: <a href="https://habr.com/ru/post/275003/">https://habr.com/ru/post/275003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274997/index.html">We write a simple RESTful service on kotlin and spring boot</a></li>
<li><a href="../274999/index.html">Photo Encryption on Google Drive</a></li>
<li><a href="../275/index.html">Habrakompanii - Release</a></li>
<li><a href="../2750/index.html">WTF? Logos of two Russian banks. Will you find 10 differences?</a></li>
<li><a href="../275001/index.html">How to design for people with color blindness</a></li>
<li><a href="../275005/index.html">Initialization of flight data in the AIRCOM Server system</a></li>
<li><a href="../275009/index.html">Server in your pocket: deploy ONLYOFFICE on Intel NUCs</a></li>
<li><a href="../27501/index.html">Vladimir Vladimirovich will teach you to knock</a></li>
<li><a href="../275011/index.html">Module loader for node js with support for local modules and load modules on demand</a></li>
<li><a href="../275013/index.html">Who are you writing on Gherkin? Or gherkin in search of the target audience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>