<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>When to use Parallel.ForEach, and when to use PLINQ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Usually, when optimizing a program for multi-core computers, the first step is to ascertain the possibility of dividing the algorithm i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>When to use Parallel.ForEach, and when to use PLINQ</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  Usually, when optimizing a program for multi-core computers, the first step is to ascertain the possibility of dividing the algorithm into parts running in parallel.  If, to solve the problem, it is necessary to parallelly process individual elements from a large data set, then the first candidates will be new parallelism possibilities in the .NET Framework 4: <b>Parallel.ForEach</b> and Parallel LINQ ( <b>PLINQ</b> ) <br><br><h3>  Parallel.ForEach </h3><br>  The Parallel class contains the <b>ForEach</b> method, which is a multi-threaded version of the usual foreach loop in C #.  Like regular foreach, Parallel.ForEach iterates over enumerable data, but using multiple threads.  One of the more frequently used <b>Parallel.ForEach</b> overloads is as follows: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ParallelLoopResult ForEach&lt;TSource&gt;( IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body)</code> </pre> <br>  Ienumerable indicates the sequence in which to iterate, and the Action body specifies the delegate that is called for each element.  A full list of Parallel.ForEach overloads can be found <a href="http://msdn.microsoft.com/en-us/library/dd321840(VS.100).aspx">here</a> . <br><br><h3>  PLINQ </h3><br>  Related to Parallel.ForEach <b>PLINQ</b> is a programming model for parallel data operations.  The user defines an operation from a standard set of operators, including projections, filters, aggregation, etc.  Like Parallel.ForEach <b>PLINQ</b> achieves parallelism by breaking the input sequence into parts and processing elements in different streams. <br>  The article highlights the differences between these two approaches to parallelism.  Understand the use cases in which Parallel.ForEach is best used instead of PLINQ and vice versa. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Perform independent operations </h2><br><a name="habracut"></a><br>  If you need to perform lengthy calculations on the elements of the sequence and the results are independent, then it is preferable to use Parallel.ForEach.  PLinq in turn will be too heavy for such operations.  In addition, the maximum number of streams is specified for <b>Parallel.ForEach</b> , that is, if <b>ThreadPool has</b> few resources and there are fewer streams available than specified in <b>ParallelOptions.MaxDegreeOfParallelism</b> , the optimal number of streams will be used, which can be increased as it runs.  For <b>PLINQ, the</b> number of threads executed is strictly specified. <br><br><h2>  Parallel operations with data ordering </h2><br><h3>  PLINQ to keep order </h3><br>  If your transformations require you to preserve the order of the input data, then you will most likely find that it is simpler to use <b>PLINQ</b> than <b>Parallel.ForEach</b> .  For example, if we want to convert color RGB-frames of a video into black and white, on the output, the frame order, naturally, should be preserved.  In this case, it is better to use <b>PLINQ</b> and the <b>AsOrdered ()</b> function, which plinq splits the input sequence, performs transformations, and then puts the result in the correct order. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrayscaleTransformation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;Frame&gt; Movie</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ProcessedMovie = Movie .AsParallel() .AsOrdered() .Select(frame =&gt; ConvertToGrayscale(frame)); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grayscaleFrame <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ProcessedMovie) { <span class="hljs-comment"><span class="hljs-comment">// Movie frames will be evaluated lazily } }</span></span></code> </pre><br><br>  <b>Why not use Parallel.ForEach here?</b> <br><habracut><br>  With the exception of trivial cases, the implementation of parallel operations on serial data using <b>Parallel.ForEach</b> requires a significant amount of code.  In our case, we can use the overload of the <b>Foreach</b> function to repeat the effect of the AsOrdered () operator: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ParallelLoopResult ForEach&lt;TSource &gt;( IEnumerable&lt;TSource&gt; source, Action&lt;TSource, ParallelLoopState,Int64&gt;body)</code> </pre><br><br>  In the overloaded version of <b>Foreach,</b> the index parameter of the current element was added to the delegate of action on data.  Now we can write the result to the output collection using the same index, perform costly computations in parallel, and finally get the output sequence in the correct order.  The following example illustrates one way to preserve order using <b>Parallel.ForEach</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> [] PairwiseMultiply( <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] v1, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] v2) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = Math.Min(v1.Length, v2.Lenth); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[length]; Parallel.ForEach(v1, (element, loopstate, elementIndex) =&gt; result[elementIndex] = element * v2[elementIndex]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  However, the shortcomings of this approach are immediately detected.  If the input sequence is an IEnumerable type, not an array, then there are 4 ways to implement order preservation: <br><ul><li>  The first option is to call IEnumerable.Count (), which will cost O (n).  If the number of elements is known, you can create an output array to store the results at a given index </li><li>  The second option is to materialize the collection, (turning it, for example, into an array).  If there is a lot of data, then this method is not very suitable. </li><li>  The third option is to think carefully about the output collection.  The output collection can be a hash, then the amount of memory needed for storing the output value will be at least 2 times the input memory in order to avoid collisions during hashing;  if there is a lot of data, the data structure for the hash will be prohibitively large, besides, you can get a performance drop due to false sharing and the garbage collector. </li><li>  And the last option is to save the results with their original indexes, and then apply your own algorithm for sorting the output collection. </li></ul><br><br>  In PLINQ, the user simply requests order conservation, and the query engine manages all the routine details to ensure the correct order of results.  The PLINQ infrastructure allows <b>AsOrdered () to</b> handle streaming data, in other words, PLINQ supports lazy materialization.  In PLINQ, the materialization of the entire sequence is the worst solution, you can easily avoid the above problems and perform parallel operations on data simply by using the <b>AsOrdered ()</b> operator. <br><br><h2>  Parallel streaming processing </h2><br><h3>  Using PLINQ for stream processing </h3><br>  PLINQ offers the ability to process a query as a query over a stream.  This feature is extremely valuable for the following reasons: <br><ul><li>  1. The results do not materialize in the array, so there is no redundancy in storing data in memory. </li><li>  2. You can get (enumerate) the results in a single stream of calculations as you receive new data. </li></ul><br>  Continuing with an example of analyzing securities, let us imagine that you want to calculate the risk of each paper from a portfolio of papers, issuing only papers that meet the criterion of risk analysis, and then perform some calculations on the filtered results.  In <b>PLINQ, the</b> code will look something like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnalyzeStocks</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;Stock&gt; Stocks</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> StockRiskPortfolio = Stocks .AsParallel() .AsOrdered() .Select(stock =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Stock = stock, Risk = ComputeRisk(stock)}) .Where(stockRisk =&gt; ExpensiveRiskAnalysis(stockRisk.Risk)); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stockRisk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> StockRiskPortfolio) { SomeStockComputation(stockRisk.Risk); <span class="hljs-comment"><span class="hljs-comment">// StockRiskPortfolio will be a stream of results } }</span></span></code> </pre><br><br>  In this example, the elements are divided into parts ( <a href="http://blogs.msdn.com/b/pfxteam/archive/2009/05/28/9648672.aspx">partitions</a> ), processed by several threads, then reordered;  This is important for understanding that these steps are performed in parallel, as filtering results appear, a single-threaded consumer in a <b>foreach loop</b> can perform calculations.  PLINQ is optimized for performance, not latency, and uses buffers internally;  it may happen that although a partial result has already been obtained, it will be in the output buffer as long as the output buffer is completely saturated and does not allow further processing.  The situation can be corrected using the PLINQ <b>WithMergeOptions</b> extension method, which allows you to specify output buffering.  The <b>WithMergeOptions</b> method accepts the <b>ParallelMergeOptions</b> enumeration as a parameter; you can specify how the query returns the final result that will be used by a single stream.  The following options are offered: <br><br><ul><li>  <b>ParallelMergeOptions.NotBuffered</b> - indicates that each processed element is returned from each stream as soon as it is processed </li><li>  <b>ParallelMergeOptions.AutoBuffered</b> - indicates that the elements are going to the buffer, the buffer is periodically returned to the thread-consumer </li><li>  <b>ParallelMergeOptions.FullyBuffered</b> - indicates that the output sequence is completely buffered, it allows you to get results faster than using other options, but then the consumer will have to wait for a long time to receive the first element for processing. </li></ul><br><br>  An example of using WithMergeOptions is available on <a href="http://msdn.microsoft.com/en-us/library/dd547137(VS.100).aspx">MSDN.</a> <br><br><h3>  Why not Parallel.ForEach? </h3><br>  Let's throw aside the shortcomings of Parallel.ForEach to preserve the order of the sequence.  For unordered calculations over a stream using Parallel.ForEach, the code will look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnalyzeStocks</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;Stock&gt; Stocks</span></span></span><span class="hljs-function">)</span></span> { Parallel.ForEach(Stocks, stock =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> risk = ComputeRisk(stock); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ExpensiveRiskAnalysis(risk) { <span class="hljs-comment"><span class="hljs-comment">// stream processing lock(myLock) { SomeStockComputation(risk) }; // store results } }</span></span></code> </pre><br><br>  This code is almost identical to the PLINQ example, with the exception of explicit blocking and less elegant code.  Note that in this situation, <b>Parallel.ForeEach</b> implies saving the results in a stream-safe style, while PLINQ does it for you. <br>  To save the results, we have 3 ways: the first is to save the values ‚Äã‚Äãin the thread-unsafe collection and require blocking with each record.  The second is to save to a thread-safe collection, since the .NET Framework 4 provides a set of such collections in the <b>System.Collections.Concurrent</b> namespace and you don‚Äôt have to implement it yourself.  The third way is to use Parallel.ForEach with a <b>thread-local</b> storage, which will be discussed later.  Each of these methods requires the explicit management of third-party write effects to the collection, while PLINQ allows us to abstract away from these operations. <br><br><br><h2>  Operations on two collections </h2><br><h3>  Using <b>PLINQ</b> for operations on two collections </h3><br>  The PLINQ <b>ZIP</b> operator performs parallel computations on two different collections in a special way.  Since it can be combined with other requests, you can simultaneously perform complex operations on each collection before combining the two collections.  For example: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IEnumerable&lt;T&gt; Zipping&lt;T&gt;(IEnumerable&lt;T&gt; a, IEnumerable&lt;T&gt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a .AsParallel() .AsOrdered() .Select(element =&gt; ExpensiveComputation(element)) .Zip( b .AsParallel() .AsOrdered() .Select(element =&gt; DifferentExpensiveComputation(element)), (a_element, b_element) =&gt; Combine(a_element,b_element)); }</code> </pre><br>  The example above demonstrates how each data source is processed in parallel by different operations, then the results from both sources are combined by the Zip operator. <br><br><h3>  Why not Parallel.ForEach? </h3><br>  A similar operation can be performed with a Parallel.ForEach overload using indexes, for example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IEnumerable&lt;T&gt; Zipping&lt;T&gt;(IEnumerable&lt;T&gt; a, IEnumerable&lt;T&gt; b) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numElements = Math.Min(a.Count(), b.Count()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[numElements]; Parallel.ForEach(a, (element, loopstate, index) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a_element = ExpensiveComputation(element); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b_element = DifferentExpensiveComputation(b.ElementAt(index)); result[index] = Combine(a_element, b_element); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  However, there are potential pitfalls and flaws, described in the application of Parallel.ForEach while preserving the data order, one of the drawbacks includes viewing the entire collection to the end and explicitly managing the indexes. <br><br><h2>  Local <b>Thread State</b> ( <b>Thread-Local State</b> ) </h2><br><h3>  Using <b>Parallel.ForEach</b> to access local stream state </h3><br>  Although PLINQ provides more concise means for parallel operations on data, some processing scenarios are better suited for using <b>Parallel.ForEach</b> , for example, operations that support the local stream state.  The signature of the corresponding <b>Parallel.ForEach</b> method looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ParallelLoopResult ForEach&lt;TSource,TLocal&gt;( IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource, ParallelLoopState, TLocal, TLocal&gt; body, Action&lt;TLocal&gt; localFinally)</code> </pre><br><br>  It should be noted that there is an overload of the <b>Aggregate</b> operator, which allows access to the local stream state and can be used if the data processing template can be described as a reduction in dimension.  The following example illustrates how to exclude numbers that are not simple from the sequence: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;R&gt; Filtering&lt;T,R&gt;(IEnumerable&lt;T&gt; source) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;R&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (SemaphoreSlim sem = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { Parallel.ForEach(source, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;R&gt;(), (element, loopstate, localStorage) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> filter = filterFunction(element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filter) localStorage.Add(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> localStorage; }, (finalStorage) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(myLock) { results.AddRange(finalStorage) }; }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; }</code> </pre><br>  This functionality could be achieved much more easily with PLINQ, the purpose of the example is to show that using <b>Parallel.ForEach</b> and the local state of a stream can greatly reduce the cost of synchronization.  However, in other scenarios, local stream states become absolutely necessary, the following example demonstrates this scenario. <br><br>  Imagine that you, as a brilliant computer scientist and mathematician, have developed a statistical model for analyzing the risks of securities;  This model, in your opinion, will break all other risk models to pieces.  In order to prove this, you need data from sites with information on stock markets.  But the data loading sequence will be very long and is a bottleneck for an eight-core computer.  Although using <b>Parallel.ForEach</b> is an easy way to parallelly load data using a <b>WebClient</b> , each stream will be blocked at each download, which can be improved using asynchronous I / O;  more information is available <a href="http://blogs.msdn.com/b/pfxteam/archive/2009/08/04/9857477.aspx">here</a> .  For performance reasons, you decided to use <b>Parallel.ForEach</b> to iterate through the collection of URLs and upload data in parallel.  The code looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnsafeDownloadUrls</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { WebClient webclient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient(); Parallel.ForEach(urls, (url,loopstate,index) =&gt; { webclient.DownloadFile(url, filenames[index] + <span class="hljs-string"><span class="hljs-string">".dat"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0}:{1}"</span></span>, Thread.CurrentThread.ManagedThreadId, url); }); }</code> </pre><br>  Surprisingly, we will get an exception at runtime: <b>‚ÄúSystem.NotSupportedException -&gt; WebClient does not support concurrent I / O operations.‚Äù</b> Realizing that multiple threads cannot access one <b>WebClient</b> at the same time, you decide to create a <b>WebClient</b> for each download. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BAD_DownloadUrls</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Parallel.ForEach(urls, (url,loopstate,index) =&gt; { WebClient webclient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient(); webclient.DownloadFile(url, filenames[index] + <span class="hljs-string"><span class="hljs-string">".dat"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0}:{1}"</span></span>, Thread.CurrentThread.ManagedThreadId, url); }); }</code> </pre><br>  This code allows the program to create more than a hundred web clients, the program will throw an exception about the timeout in WebClient.  You will understand that the computer is not running a server operating system, so the maximum number of connections is limited.  Then you can guess that using Parallel.ForEach with the local state of the stream will solve the problem: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadUrlsSafe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Parallel.ForEach(urls, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient(), (url, loopstate, index, webclient) =&gt; { webclient.DownloadFile(url, filenames[index]+<span class="hljs-string"><span class="hljs-string">".dat"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0}:{1}"</span></span>, Thread.CurrentThread.ManagedThreadId, url); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> webclient; }, (webclient) =&gt; { }); } }</code> </pre><br><br>  In this implementation, each data access operation is independent of the other.  At the same time, the access point is neither independent nor thread-safe.  Using the local storage of the stream allows us to be sure that the number of created <b>WebClient</b> instances is as long as required, and each instance of the <b>WebClient</b> belongs to the stream that created it. <br><br><h3>  What is bad PLINQ here? </h3><br>  If we implement the previous example using ThreadLocal and PLINQ objects, the code will be as follows: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadUrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webclient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadLocal&lt;WebClient&gt;(()=&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient ()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = urls .AsParallel() .ForAll( url =&gt; { webclient.Value.DownloadFile(url, host[url] +<span class="hljs-string"><span class="hljs-string">".dat"</span></span>)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0}:{1}"</span></span>, Thread.CurrentThread.ManagedThreadId, url); }); }</code> </pre><br><br>  While the implementation achieves the same goals, it is important to understand that in any scenario, using <b>ThreadLocal &lt;&gt; is</b> significantly more expensive than the corresponding <b>Parallel.ForEach</b> overload.  Note that in this scenario, the cost of instantiating <b>ThreadLocal &lt;&gt; is</b> insignificant compared to the time it takes to download a file from the Internet. <br><br><h2>  Exit operations </h2><br><h3>  Using <b>Parallel.ForEach</b> to quit operations </h3><br>  In a situation where control over the execution of operations is essential, it is important to understand that exiting the <b>Parallel.ForEach</b> cycle allows achieving the same effect as checking the condition for the need to continue calculations inside the loop body.  One of the <b>Parallel.ForEach</b> overloads that allow you to monitor <b>ParallelLoopState</b> looks like this: <br><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ParallelLoopResult ForEach&lt;TSource &gt;( IEnumerable&lt;TSource&gt; source, Action&lt;TSource, ParallelLoopState&gt; body)</code> </pre><br>  ParallelLoopState provides support for interrupting loop execution with two different methods, described below. <br><br><h3>  ParallelLoopState.Stop () </h3><br>  <b>Stop ()</b> informs the loop about the need to stop executing iterations;  The <b>ParallelLoopState.IsStopped</b> property allows each iteration to determine if any other iteration caused the <b>Stop ()</b> method.  The <b>Stop ()</b> method is usually useful if the loop performs an unordered search and should be exited as soon as the search element is found.  For example, if we want to find out if an object is in the collection, the code would be something like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> boolean FindAny&lt;T,T&gt;(IEnumerable&lt;T&gt; TSpace, T match) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: IEqualityComparer&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchFound = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Parallel.ForEach(TSpace, (curValue, loopstate) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curValue.Equals(match) ) { matchFound = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; loopstate.Stop(); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> matchFound; }</code> </pre><br>  Functionality can also be achieved using PLINQ, this example demonstrates how to use ParallelLoopState.Stop () to control the flow of execution. <br><br><h3>  ParallelLoopState.Break () </h3><br>  <b>Break ()</b> informs the loop that the elements preceding the current element should be processed, but for subsequent elements, the iteration should be stopped.  The value of the lower iteration can be obtained from the <b>ParallelLoopState.LowestBreakIteration</b> property.  <b>Break () is</b> usually useful if you are searching through ordered data.  In other words, there is a certain criterion of the need for data processing.  For example, for a sequence containing non-unique elements in which you need to find the subscript of the matching object, the code would look like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FindLowestIndex&lt;T,T&gt;(IEnumerable&lt;T&gt; TSpace, T match) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: IEqualityComparer&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loopResult = Parallel.ForEach(source, (curValue, loopState, curIndex) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curValue.Equals(match)) { loopState.Break(); } }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchedIndex = loopResult.LowestBreakIteration; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> matchedIndex.HasValue ? matchedIndex : <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br><br>  In this example, the loop is executed until an object is found, the Break () signal means that only elements with a smaller index than the object found should be processed;  if another matching instance is found, the Break () signal will be received again, this is repeated as long as there are elements, if the object was found, the LowestBreakIteration field points to the first index of the matching object. <br><br><br><h3>  Why not PLINQ? </h3><br>  Although <b>PLINQ</b> provides support for quitting the query, the differences in PLINQ and Parallel.ForEach exit mechanisms are significant.       PLINQ,       (cancellation token),   <a href="http://msdn.microsoft.com/en-us/library/dd460707(VS.100).aspx"></a> . C <b>Parallel.ForEach</b>      .    <b>PLINQ</b>      ,     . <br><br><h2>  Conclusion </h2><br> <b>Parallel.ForEach</b>  <b>PLINQ</b> ‚Äî                 .             ,    . <br><br><h3>  <i>Useful links:</i> <i><br></i> </h3><br> <a href="http://www.albahari.com/threading/">Threading in C#</a> <br> <a href="">RSDN:     C#.  </a> <br> <a href="http://code.msdn.microsoft.com/ParExtSamples">Microsoft Samples for Parallel Programming with the .NET Framework</a> </habracut></div><p>Source: <a href="https://habr.com/ru/post/135942/">https://habr.com/ru/post/135942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135937/index.html">Future icons</a></li>
<li><a href="../135938/index.html">What is iNum, and how can we help the development of this project</a></li>
<li><a href="../135939/index.html">Opera TV Store: a catalog of HTML5 TV applications</a></li>
<li><a href="../135940/index.html">"Not a single conversion ..." or tips on analyzing large contextual campaigns</a></li>
<li><a href="../135941/index.html">Embedded JavaFX</a></li>
<li><a href="../135943/index.html">Sony Xperia S - the new flagship under the new name. Hands-on video</a></li>
<li><a href="../135945/index.html">New BlackBerry PlayBook features with OS 2.0</a></li>
<li><a href="../135948/index.html">Simulation of a large number of interacting particles</a></li>
<li><a href="../135949/index.html">Extend collectd functionality by adding your own bindings</a></li>
<li><a href="../135950/index.html">Driving a stepper motor with a driver</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>