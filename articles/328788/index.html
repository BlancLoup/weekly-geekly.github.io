<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The best way to upload files to Ruby is with Shrine. Part 2. Loader</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second part of the Shrine series of posts. The purpose of this series of articles is to show the advantages of Shrine over existing file l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The best way to upload files to Ruby is with Shrine. Part 2. Loader</h1><div class="post__text post__text-html js-mediator-article">  <i>This is the second part of the <a href="https://github.com/janko-m/shrine">Shrine</a> series of posts.</i>  <i>The purpose of this series of articles is to show the advantages of Shrine over existing file loaders.</i> <br><br><hr><br>  In a <a href="https://habrahabr.ru/post/328558">previous post,</a> I talked about what motivated me to create a Shrine.  In this article I want to show you the foundation on which Shrine is based - the repository, the loader and the uploaded files. <br><a name="habracut"></a><br><h2>  Storage </h2><br><hr><br>  Shrine ‚Äústorage‚Äù is a plain Ruby object that encapsulates file management in a specific storage service (file system, S3, etc.).  The repository should contain the following 5 methods: <br><br><pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyStorage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">upload</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, **</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">options</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#  `io`   `id` end def url(id) #  URL-   `id` end def open(id) #     `id`     IO end def exists?(id) # ,     end def delete(id) #      end end</span></span></span></span></code> </pre> <br>  Shrine storages are configured directly by passing options to the constructor (borrowed from Refile) and must be registered with <code>Shrine.storages</code> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="ruby hljs">Shrine.storages[<span class="hljs-symbol"><span class="hljs-symbol">:s3</span></span>] = Shrine::Storage::S3.new( <span class="hljs-symbol"><span class="hljs-symbol">access_key_id:</span></span> <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">secret_access_key:</span></span> <span class="hljs-string"><span class="hljs-string">"xyz"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">region:</span></span> <span class="hljs-string"><span class="hljs-string">"eu-west-1"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">bucket:</span></span> <span class="hljs-string"><span class="hljs-string">"my-bucket"</span></span>, )</code> </pre><br>  Currently, Shrine has <a href="">file system</a> support, <a href="">S3</a> , <a href="https://github.com/janko-m/shrine-fog">Fog</a> , <a href="https://github.com/janko-m/shrine-flickr">Flickr</a> , <a href="https://github.com/janko-m/shrine-cloudinary">Cloudary</a> , <a href="https://github.com/janko-m/shrine-transloadit">Transloadit</a> , <a href="https://github.com/janko-m/shrine-uploadcare">Uploadcare</a> , <a href="https://github.com/janko-m/shrine-imgix">Imgix</a> , <a href="https://github.com/janko-m/shrine-gridfs">GridFS,</a> and <a href="https://github.com/janko-m/shrine-sql">SQL</a> , so choose. <br><br>  You can also easily write your own repository, for this there is a <a href="http://shrinerb.com/rdoc/files/doc/creating_storages_md.html">manual</a> and a <a href="">linter</a> that will automatically check whether everything works correctly. <br><br><h2>  Loader </h2><br><hr><br>  Loaders are subclasses of Shrine, they encapsulate the logic of unloading a specific attachment (as in CarrierWave). <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageUploader</span></span></span><span class="hljs-class"> &lt; Shrine </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># image uploading logic goes here end</span></span></span></span></code> </pre><br>  Uploader objects act as wrappers around the repository, they run all the logic for loading, which is common to any repository: <br><br><ul><li>  Treatment </li><li>  Extract Metadata </li><li>  Generating location for file </li><li>  Download (at this stage the storage is accessed) </li><li>  Close the downloaded file </li></ul><br>  Creating a boot loader instance with the storage option set: <br><br><pre> <code class="ruby hljs">Shrine.storages[<span class="hljs-symbol"><span class="hljs-symbol">:disk</span></span>] = Shrine::Storage::FileSystem.new(...) uploader = ImageUploader.new(<span class="hljs-symbol"><span class="hljs-symbol">:disk</span></span>) uploader.upload(image) <span class="hljs-comment"><span class="hljs-comment">#=&gt; #&lt;Shrine::UploadedFile&gt;</span></span></code> </pre><br>  Loaders do not know about the models;  They only work on the file that will be uploaded to the input, and return a view of the uploaded file on the output.  Since this assumes that the loaders are stateless, this makes their behavior very predictable. <br><br><h2>  Uploaded files </h2><br><hr><br>  When the file is uploaded through the loader, the <code>#upload</code> method returns a <code>Shrine::UploadedFile</code> object.  This object is a complete representation of the file that was uploaded to the repository. <br><br><pre> <code class="ruby hljs">uploaded_file = uploader.upload(image) <span class="hljs-comment"><span class="hljs-comment">#=&gt; #&lt;Shrine::UploadedFile&gt; uploaded_file.id #=&gt; "43ksd9gkafg0dsl.jpg" uploaded_file.storage #=&gt; #&lt;Shrine::Storage::FileSystem&gt; uploaded_file.metadata #=&gt; {...}</span></span></code> </pre><br>  Since this object knows where it was loaded, it can provide many useful methods: <br><br><pre> <code class="ruby hljs">uploaded_file.url <span class="hljs-comment"><span class="hljs-comment"># generates the URL uploaded_file.download # downloads the file to the disk uploaded_file.exists? # asks the storage if file exists uploaded_file.open { |io| ... } # opens the file for reading uploaded_file.delete # deletes the file from the storage</span></span></code> </pre><br>  This object is determined only by the hash.  Since the repository can be referenced by its set parameter, this hash can now be serialized into JSON and stored in a database column. <br><br><pre> <code class="ruby hljs">uploaded_file.data <span class="hljs-comment"><span class="hljs-comment">#=&gt; # { # "id" =&gt; "df9fk48saflg.jpg", # "storage" =&gt; "disk", # "metadata" =&gt; {...} # } uploaded_file.to_json #=&gt; '{"id":"df9fk48saflg.jpg","storage":"disk","metadata":{...}}'</span></span></code> </pre><br>  <code>Shrine::UploadedFile</code> objects <code>Shrine::UploadedFile</code> do not depend on loaders.  This is a significant difference from CarrierWave and Paperclip, which have this dependency on the classes <code>CarrierWave::Uploader::Base</code> and <code>Paperclip::Attachment</code> . <br><br><h2>  Abstraction io </h2><br><hr><br>  Shrine can load any <code>IO</code> object that responds to <code>#read</code> , <code>#size</code> , <code>#rewind</code> , <code>#eof?</code>  And <code>#close</code> (like Refile).  Defining this strict interface, each Shrine function now knows that they can only rely on these methods, which means that they will work correctly regardless of whether you load the <code>File</code> , <code>StringIO</code> , <code>ActionDispatch::Http::UploadedFile</code> , <code>Rack</code> types. or deleted files that are <a href="https://github.com/janko-m/down">downloaded by stream</a> . <br><br>  In addition, <code>Shrine::UploadedFile</code> is itself an <code>IO</code> object, wrapping any downloaded file under the same unified interface.  This makes moving a file from one repository to another really convenient.  In addition, it allows you to optimize some downloads by skipping the download process and re-downloading, for example, to use a copy of S3 if both files are from S3, or just send a URL request if the repository supports it. <br><br><pre> <code class="ruby hljs">cache = ImageUploader.new(<span class="hljs-symbol"><span class="hljs-symbol">:s3_temporary</span></span>) cached_file = cache.upload(image) store = ImageUploader.new(<span class="hljs-symbol"><span class="hljs-symbol">:s3_permanent</span></span>) store.upload(cached_file) <span class="hljs-comment"><span class="hljs-comment">#=&gt; performs an S3 COPY request</span></span></code> </pre><br><h2>  Plugin system </h2><br><hr><br>  Shrine comes with a small <a href="">kernel</a> (&lt;500 lines of code) that provides the necessary functionality.  Any additional features can be downloaded via <a href="http://shrinerb.com/">plugins</a> .  This gives you the flexibility to choose exactly what the Shrine should do for you, and download the code only for the functionality that you use. <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># Loads the processing feature from "shrine/plugins/logging.rb" Shrine.plugin :logging, logger: Rails.logger</span></span></code> </pre><br>  Shrine comes with over 35 plugins, and you can easily write your own.  The Shrine plugin system is an adaptation of <a href="https://github.com/jeremyevans/roda">Roda</a> that I <a href="https://twin.github.io/the-plugin-system-of-sequel-and-roda/">wrote about</a> in the past. <br><br>  In addition, Shrine loaders can be inherited ( <a href="https://jbhannah.net/articles/carrierwave-concerns/">unlike CarrierWave</a> ). <br><br><pre> <code class="ruby hljs">Shrine.plugin <span class="hljs-symbol"><span class="hljs-symbol">:logging</span></span> <span class="hljs-comment"><span class="hljs-comment"># enables logging for all uploaders class ImageUploader &lt; Shrine plugin :backup # stores backups only for this uploader (and its descendants) end</span></span></code> </pre><br><h2>  Dependencies </h2><br><hr><br>  Most libraries for downloading files have pretty monstrous dependencies. <br><br><h3>  CarrierWave </h3><br><ul><li>  ActiveSupport - I really don‚Äôt want all those monkey patches </li><li>  ActiveModel - Why not perform validation <a href="">without libraries</a> ? </li><li>  MIME :: Types - It is better to determine the MIME type from the file contents </li></ul><br><h3>  Paperclip </h3><br><ul><li>  ActiveSupport - Again, I want to be able to not have any monkey patches </li><li>  ActiveModel - Okay, anyway, both ActiveModel and ActiveSupport are required for ActiveRecord </li><li>  Cocaine - <a href="http://ruby-doc.org/stdlib-2.3.0/libdoc/open3/rdoc/Open3.html">Open3</a> monstrous library to run the command shell </li><li>  MIME :: Types - MIME type substitution detection <a href="https://github.com/thoughtbot/paperclip/issues%3Futf8%3D%25E2%259C%2593%26q%3Dlabel%253A%2522Spoof%2520related%2520or%2520Mime%2520types%2522%2520">has problems</a> </li><li>  MimeMagic - enough <a href="http://linux.die.net/man/1/file">file</a> utility </li></ul><br><h3>  Refile </h3><br><ul><li>  RestClient - A monstrous solution for easy file uploading. </li><li>  Sinatra - This is normal, although <a href="https://github.com/jeremyevans/roda">Roda</a> is a lighter alternative. </li><li>  MIME :: Types - It is better to determine the MIME type from the file contents </li></ul><br>  Shrine, on the other hand, has only one mandatory but light dependency - <a href="https://github.com/janko-m/down">Down</a> .  Down is a net / http wrapper for downloading files, which <a href="https://twin.github.io/improving-open-uri">improves open-uri</a> and supports streaming, and is used by almost all Shrine repositories. <br><br>  In addition, Shrine as a whole loads very quickly, because you load the code only for the functionality that you use.  For other downloaders, you need to download the code for all the functionality that you may not need.  For example, Shrine loads 35 times faster than CarrierWave without loaded plug-ins and 7 times faster with all loaded ( <a href="https://gist.github.com/janko-m/0d4269b9c7195b5e65cc947acf1cc028">source</a> ) plug-ins. <br><br><h2>  Results </h2><br>  Every high-level interface should have a good foundation.  Thus, no matter what level of abstraction you are working on, you can always understand what is happening.  The basis of Shrine consists of the classes <code>Storage</code> , <code>Shrine</code> and <code>Shrine::UploadedFile</code> , each of which has a well-defined interface and duty. <br><br><hr><br>  <i>Original: <a href="https://twin.github.io/better-file-uploads-with-shrine-uploader/">https://twin.github.io/better-file-uploads-with-shrine-uploader/</a></i> <i><br><br></i>  <i>Articles from the original series in the blog of the author of the library:</i> <i><br><br></i> <ul><li>  <i><a href="https://twin.github.io/better-file-uploads-with-shrine-attachment">Better File Uploads with Shrine: Attachment</a></i> </li><li>  <i><a href="https://twin.github.io/better-file-uploads-with-shrine-processing">Better File Uploads with Shrine: Processing</a></i> </li><li>  <i><a href="https://twin.github.io/better-file-uploads-with-shrine-metadata">Better File Uploads with Shrine: Metadata</a></i> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/328788/">https://habr.com/ru/post/328788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328776/index.html">Nature has no bad laws. Generation 5, or what will work after LTE?</a></li>
<li><a href="../328778/index.html">Avito Picture Store History</a></li>
<li><a href="../328780/index.html">PDUG section on PHDays VII: how to develop applications that hackers do not hack</a></li>
<li><a href="../328782/index.html">[PHDays HackQuest 2017] Anonymizer: SSRF or what can be dangerous curl</a></li>
<li><a href="../328786/index.html">GitLab Values</a></li>
<li><a href="../328790/index.html">Staff hunger is also not an aunt, or how to grow an IT specialist from a student</a></li>
<li><a href="../328792/index.html">Everything you didn't know about the CAP theorem</a></li>
<li><a href="../328794/index.html">How to protect a modern data center</a></li>
<li><a href="../328796/index.html">WannaCry 2.0: visual confirmation that you definitely need the right solution for a reliable backup</a></li>
<li><a href="../328798/index.html">CRM and telephony integration, complex product development lessons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>