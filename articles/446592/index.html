<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Checking the source code of Roslyn</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From time to time we return to projects that have already been tested with PVS-Studio and wrote articles about it. It is interesting to do this for tw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Checking the source code of Roslyn</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio vs Roslyn"></div><br>  From time to time we return to projects that have already been tested with PVS-Studio and wrote articles about it.  It is interesting to do this for two reasons.  First, to understand how much better our analyzer has become.  Secondly, in order to track whether the project authors paid attention to our article, as well as to the error report that we usually give them.  Of course, errors can be corrected without our participation.  But it is always nice when exactly our efforts help to make a project better.  Roslyn was no exception.  The previous article on the verification of this project dates back to December 23, 2015.  This is quite a long time, taking into account the path that our analyzer has done in its development during this time.  Roslyn is of additional interest to us personally because it is based on the C # kernel of the PVS-Studio analyzer.  Thus, we are very interested in the quality of the code of this project.  We will arrange for him to re-check and find out what is new and interesting (but let's hope that nothing substantial) will be able to find PVS-Studio there. <br><a name="habracut"></a><br>  Roslyn (or the .NET Compiler Platform) is probably familiar to many of our readers.  In short, this is a set of open source compilers and an API for analyzing code for C # and Visual Basic .NET from Microsoft.  The source code for the project is available on <a href="https://github.com/dotnet/roslyn">GitHub</a> . <br><br>  I will not give a detailed description of this platform, and I recommend everyone interested in an article by my colleague Sergey Vasiliev " <a href="https://www.viva64.com/ru/b/0399/">Introduction to Roslyn. Use for developing static analysis tools</a> ."  From this article, you can learn not only about the features of the Roslyn architecture, but also how exactly we use this platform. <br><br>  As I mentioned earlier, since the writing of the last article by my colleague Andrei Karpov about checking Roslyn " <a href="https://www.viva64.com/ru/b/0363/">PVS-Studio 6.00 New Year Release: checking Roslyn</a> " more than three years have passed.  During this time, the C # PVS-Studio analyzer has acquired many new features.  In general, Andrei‚Äôs article was a kind of ‚Äútrial ball‚Äù, because the C # analyzer was only added to PVS-Studio at that time.  Despite this, even then, in an unconditionally qualitative project, Roslyn managed to find interesting errors.  What has changed in the analyzer for C # code so far, which will potentially allow for a deeper analysis? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since then, both the analyzer core and the infrastructure have evolved.  Support for Visual Studio 2017 and Roslyn 2.0 has been added, as well as deep integration with MSBuild.  You can read more about our approach to integration with MSBuild and about the reasons that prompted us to adopt it, see my colleague Pavel Yeremeyev‚Äôs article " <a href="https://www.viva64.com/ru/b/0503/">Visual Studio 2017 and Roslyn 2.0 support in PVS-Studio: sometimes using ready-made solutions is not as easy as it seems at first glance</a> . " <br><br>  Now we are actively working on the transition to Roslyn 3.0 in the same way that we originally supported Visual Studio 2017, that is, through our own toolset, which comes in the PVS-Studio distribution with a ‚Äústub‚Äù in the form of an empty MSBuild.exe file.  Despite the fact that it looks like a ‚Äúcrutch‚Äù (the MSBuild API is not very friendly to be reused in third-patry projects due to the low portability of the libraries), this approach has already helped us to survive several Roslyn updates relatively painlessly during the life of Visual Studio 2017, and now, albeit with a large number of overlays, survive the upgrade to Visual Studio 2019, and also maintain full backward compatibility and performance on systems with older versions of MSBuild. <br><br>  The analyzer core has also undergone a number of improvements.  One of the main innovations is a full-fledged interprocedural analysis taking into account the input and output values ‚Äã‚Äãof the methods, with a calculation, depending on these parameters, on the reachability of the execution branches and cusps. <br><br>  The task of tracking parameters inside methods is already close to completion, while auto-annotations are preserved for what happens to these parameters (for example, potentially dangerous dereference).  This will allow for any diagnostics using the data-flow mechanism to take into account dangerous situations that occur when a parameter is passed to a method.  Previously, when analyzing such dangerous places, a warning was not generated, since we could not know all the possible input values ‚Äã‚Äãto such a method.  Now we can detect danger, since in all places of the call of this method these input parameters will be taken into account. <br><br>  Note: you can familiarize yourself with the basic analyzer mechanisms, such as data-flow and others, from the article " <a href="https://www.viva64.com/ru/b/0592/">Technologies used in the PVS-Studio code analyzer for searching errors and potential vulnerabilities</a> ." <br><br>  Interprocedural analysis in PVS-Studio C # is not limited by either input parameters or depth.  The only limitation is virtual methods in the classes that are not closed for inheritance and falling into recursion (we‚Äôll stop when we saw on the stack the repeated call of the calculated method).  In this case, the recursive method itself will ultimately be calculated assuming that the return value of its self-recursion is unknown. <br><br>  Another major innovation in the C # analyzer was the consideration of the dereferencing of the potentially null pointer.  Previously, the analyzer swore at a possible null reference exception if it was certain that in all execution branches the value of the variable would accept null.  Of course, he was sometimes mistaken, so the <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> diagnostics had previously been called the potential null reference. <br><br>  Now the analyzer remembers that the variable could be null in one of the execution branches (for example, under a certain condition in if).  If he sees access to such a variable without checking, he will display a message V3080, but at a lower level of importance than if he sees null in all branches.  In combination with an improved interprocedural analysis, this mechanism allows finding very difficult to detect errors.  An example is a long chain of method calls, the last of which is not familiar to you, and which, for example, in certain circumstances returns null in catch, but you did not protect against this, because you simply did not know.  In this case, the analyzer swears only when it accurately sees the destination null.  In our opinion, this qualitatively distinguishes our approach from such an innovation of C # 8.0 as the nullable reference type, which, in fact, boils down to setting null checks in each method.  We offer an alternative - to do checks only where null can really come, and our analyzer is now able to look for such situations. <br><br>  So, without delaying a debt, let's move on to the ‚Äúdebriefing‚Äù ‚Äîanalyzing the results of the Roslyn check.  First, consider the errors found due to the innovations described above.  In general, quite a lot of warnings were issued for the Roslyn code this time.  I think this is due to the fact that the platform is actively developing (the volume of the code base at the moment is about 2,770,000 lines of code excluding empty ones), and we have not done an analysis of this project for a long time.  Nevertheless, there are not so many critical errors, namely, they are of interest for the article.  And yes, Roslyn has quite a lot of tests that I, as usual, excluded from checking. <br><br>  I‚Äôll start with the errors V3080, with the criticality level Medium, in which the analyzer found possible access via the zero reference, but not in all possible cases (code branches). <br><br>  <b>Possible null dereference - Medium</b> <br><br>  V3080 Possible null dereference.  Consider inspecting 'current'.  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Consider the <i>GetNode</i> method.  The analyzer considers that it is possible to access by zero reference in the condition of the <i>while</i> block.  In the body of the <i>while</i> block, the <i>current</i> variable will be assigned a value - the result of the <i>AsNode</i> method.  And this value in some cases will be <i>null</i> .  A good example of interprocedural analysis in action. <br><br>  Now consider a similar case in which the interprocedural analysis was performed through two method calls. <br><br>  V3080 Possible null dereference.  Consider inspecting the 'directory'.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  The variable <i>directory</i> in the body of the <i>ExpandFileNamePattern</i> method gets the value from the <i>GetDirectoryName (string)</i> method.  That, in turn, will return the result of the overloaded <i>GetDirectoryName (string, bool)</i> method, the value of which can be <i>null</i> .  Since the variable <i>directory is</i> used in the body of the <i>ExpandFileNamePattern</i> method without first checking for <i>null</i> equality, we can talk about the validity of issuing a warning by the analyzer.  This is a potentially unsafe design. <br><br>  Another piece of code with error V3080, more precisely, immediately with two errors issued for one line of code.  Here an interprocedural analysis is not needed. <br><br>  V3080 Possible null dereference.  Consider inspecting 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 Possible null dereference.  Consider inspecting 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  The variables <i>spanStartLocation</i> and <i>spanEndLocationExclusive</i> are of type <i>nullable int</i> and initialized to <i>null</i> .  Further, in the code, they can be assigned values, but only under certain conditions.  In some cases, their value will remain <i>null</i> .  Further, in the code, these variables are accessed by reference without first checking for <i>null</i> equality, as indicated by the analyzer. <br><br>  The Roslyn code contains quite a few such errors, more than 100. Often, the pattern of these errors is the same.  There is some general method that potentially returns <i>null</i> .  The result of this method is used in a large number of places, sometimes through dozens of intermediate method calls or additional checks.  It is important to understand that these errors are not fatal, but they can potentially lead to access via a null link.  And to detect such errors is very difficult.  Therefore, in some cases, you should think about refactoring the code, in which an exception would be thrown if the <i>null were</i> returned.  Otherwise, you can only secure your code with total checks, which is quite tedious and unreliable.  Of course, in each specific case, the decision must be made on the basis of the project specifics. <br><br>  Note.  It happens that at the moment there are no situations (input data) in which the method returns <i>null</i> and there is no real error.  However, this code is still not reliable, because everything can change when you make changes to the code. <br><br>  To close the topic with the <a href="https://www.viva64.com/ru/w/v3080/">V3080</a> , let's take a look at the obvious errors with the High confidence level when access via the zero link is more likely or even unavoidable. <br><br>  <b>Possible null dereference - High</b> <br><br>  V3080 Possible null dereference.  Consider inspecting 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Due to a typo in the condition (instead of the operator <i>||</i> used <i>&amp;&amp;</i> ), the code does not work as intended, and access to the <i>collectionType.Type</i> variable will be executed if it is <i>null</i> .  The condition needs to be corrected as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  By the way, the second scenario is possible: in the first part of the condition, the operators <i>==</i> and <i>! =</i> Were confused.  Then the corrected code would look like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  This version of the code is less logical, but also corrects the error.  The final decision for the authors of the project. <br><br>  Another similar error. <br><br>  V3080 Possible null dereference.  Consider inspecting 'action'.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  An error was made when generating a message for an exception.  This attempts to access the <i>action.DisplayText</i> property via the <i>action</i> variable, which is obviously <i>null</i> . <br><br>  And the last error V3080 level High. <br><br>  V3080 Possible null dereference.  Consider inspecting 'type'.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  The method is small, so I cite its entire code.  The condition in the <i>return</i> block is incorrect.  In some cases, <i>NullReferenceException</i> may be <i>thrown</i> when accessing <i>type.FullName</i> .  I use brackets (here they will not change behavior) to clarify the situation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  That is, in accordance with the priority of operations, this code will work.  If the <i>type</i> variable is equal to <i>null</i> , we will end up in an else-check, where, after verifying that the targetTypeName variable is <i>null</i> , we use the null reference <i>type</i> .  You can fix the code, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  I think this is where you can complete the study of the errors of V3080 and see what else was interesting in finding the PVS-Studio analyzer in Roslyn code. <br><br>  <b>Typo</b> <br><br>  <a href="https://www.viva64.com/ru/w/v3005/">V3005</a> The 'SourceCodeKind' variable is assigned to itself.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Due to unsuccessful variable names, a typo was made in the constructor of the <i>DynamicFileInfo</i> class.  The <i>SourceCodeKind field is</i> assigned its own value, instead of using the <i>sourceCodeKind</i> parameter.  To minimize the likelihood of such errors, it is recommended to use an underscore prefix for parameter names in such cases.  I will give an example of a revised version of the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Inattention</b> <br><br>  <a href="https://www.viva64.com/ru/w/v3006/">V3006</a> The object was not used.  The 'throw' keyword could be missing: new InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Under certain conditions, the destructor should throw an exception, but this does not happen, and the exception object is simply created.  The <i>throw</i> keyword was missing.  Corrected code: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  The issue of working with destructors in C # and throwing exceptions out of them is a topic for a separate discussion that is beyond the scope of this article. <br><br>  <b>When the result is not important</b> <br><br>  A number of <a href="https://www.viva64.com/ru/w/v3009/">V3009</a> warnings were received for methods that in all cases return the same value.  Sometimes this is not critical, or in the calling code the return value is simply not checked.  I missed such warnings.  But a few code snippets seemed suspicious to me.  I will give one of them: <br><br>  V3009 It's one of those true values.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  The <i>TryExecuteCommand</i> method returns only <i>true</i> , and nothing but <i>true</i> .  In this case, in the calling code, the return value is involved in some checks: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  It is difficult to say how dangerous this behavior is.  But if the result is not needed, it may be worth replacing the return type with void and make minimal edits to the calling method.  This will make the code more understandable and safer. <br><br>  Other similar warnings: <br><br><ul><li>  V3009 It's one of those true values.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 It's one of those true values.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 It's one of those true values.  JsonRpcClient.cs 138 </li><li>  V3009 It's one of those true values.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 It‚Äôs odd that this method returns one.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 It's one of those true values.  ObjectList.cs 173 </li><li>  V3009 It's one of those true values.  ObjectList.cs 249 </li></ul><br>  <b>Not checked</b> <br><br>  <a href="https://www.viva64.com/ru/w/v3019/">V3019</a> Possibly is not variable after type conversion using 'as' keyword.  Check variables 'value', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  The <i>value</i> variable is <i>cast</i> to the <i>NamingStylePreferences</i> type.  The problem is the next test.  Even if the <i>value</i> variable is not null, it does not guarantee that the type conversion was successful and the <i>valueToSerialize</i> is not <i>null</i> .  A <i>NullReferenceException</i> exception <i>may be thrown</i> .  The code needs to be corrected as follows: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  And one more similar error. <br><br>  V3019 Possibly is not variable after type conversion using 'as' keyword.  Check variables 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  The variable <i>columnState is called</i> <i>ColumnState2</i> .  However, the result of the operation, the variable <i>columnState2</i> , is no longer checked for <i>null</i> equality.  Instead, the <i>columnState</i> variable is <i>checked</i> with the conditional <i>null</i> operator.  Why is this code dangerous?  As in the previous example, type casting with the <i>as</i> operator can fail, and the variable <i>columnState2</i> will be <i>null</i> , which will result in a further exception being thrown.  By the way, there may be a typo.  Pay attention to the condition in the <i>if</i> block.  Perhaps instead of <i>columnState? .Name,</i> they wanted to write <i>columnState2? .Name</i> .  This is very likely if you take into account the rather unsuccessful variable names <i>columnState and columnState2.</i> <br><br>  <b>Redundant checks</b> <br><br>  Quite a large number of warnings (over 100) were issued for non-critical, but potentially unsafe constructions associated with redundant checks.  For example, give one of them. <br><br>  <a href="https://www.viva64.com/ru/w/v3022/">V3022</a> Expression 'navInfo == null' is always false.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Perhaps there is no real error here.  Just a good reason to demonstrate a bunch of technologies "interprocedural analysis + data flow analysis" in action.  The analyzer considers that the second check <i>navInfo == null is</i> redundant.  Indeed, before this, the value for the assignment of <i>navInfo</i> will be obtained from the <i>libraryService.NavInfoFactory.CreateForProject</i> method, which constructs and returns a new object of the <i>NavInfo</i> class.  But not <i>null</i> .  The question arises, why didn't the analyzer issue a warning for the first check <i>navInfo == null</i> ?  There is an explanation.  Firstly, if the variable <i>symbol</i> turns out to be <i>null</i> , then the value of <i>navInfo</i> will remain a null reference.  Secondly, even if <i>navInfo</i> gets a value from the <i>libraryService.NavInfoFactory.CreateForSymbol</i> method, this value can be <i>null</i> .  Thus, the first check <i>navInfo == null is</i> really necessary. <br><br>  <b>Not enough checks</b> <br><br>  And now the situation is the reverse of the above.  Several warnings <a href="https://www.viva64.com/ru/w/v3042/">V3042</a> was received for the code, which can be accessed by zero link.  In this case, only one or two small checks could fix everything. <br><br>  Consider one interesting code snippet that contains two similar errors. <br><br>  V3042 Possible NullReferenceException.  The '?.'  and '.'  binder_Expressions.cs 7770 <br><br>  V3042 Possible NullReferenceException.  The '?.'  and '.'  binder_Expressions.cs 7776 operators are used <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  The variable <i>receiver</i> may be <i>null</i> .  The author of the code knows this because it uses the conditional <i>null</i> operator in the if block condition to access the <i>receiver? .Syntax</i> .  Further, in the code, the variable <i>receiver is</i> used without any checks to access <i>receiver.Type</i> , <i>receiver.Syntax</i> and <i>receiver.HasErrors</i> .  These errors need to be corrected: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  You also need to make sure that the <i>BoundConditionalReceiver</i> constructor supports getting <i>null</i> values ‚Äã‚Äãfor its parameters, or perform additional refactoring. <br><br>  Other similar errors: <br><br><ul><li>  V3042 Possible NullReferenceException.  The '?.'  and '.'  SyntaxGeneratorExtensions_Negate.cs 240 operators are used for accessing members of the 'containingType' object </li><li>  V3042 Possible NullReferenceException.  The '?.'  and '.'  ExpressionSyntaxExtensions.cs 349 </li><li>  V3042 Possible NullReferenceException.  The '?.'  and '.'  ExpressionSyntaxExtensions.cs 349 </li></ul><br>  <b>Error in condition</b> <br><br>  <a href="https://www.viva64.com/ru/w/v3057/">V3057</a> The 'Substring' function could receive the '-1' value while non-negative value is expected.  Inspect the second argument.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  If the <i>colon</i> variable is 0, which is conditional in the code, the <i>Substring</i> method <i>will</i> throw an <i>ArgumentOutOfRangeException</i> .  Correction required: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>A typo is possible</b> <br><br>  <a href="https://www.viva64.com/ru/w/v3065/">V3065</a> Parameter 't2' is not utilized inside method's body.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  Two parameters are passed to the lambda expression: t1 and t2.  However, only t1 is used.  It looks suspicious, considering how easy it is to make mistakes when using variables with such names. <br><br>  <b>Inattention</b> <br><br>  <a href="https://www.viva64.com/ru/w/v3083/">V3083</a> Unsafe invocation of event 'TagsChanged', NullReferenceException is possible.  Consider assigning an event to a local variable before invoking it.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  The <i>TagsChanged</i> event <i>is</i> called insecure.  Between checking for equality of <i>null</i> and calling the event, it can be unsubscribed, then an exception will be thrown.  Moreover, in the body of the <i>if</i> block, some other operations are <i>performed</i> immediately before the event is called.  I called this error ‚ÄúInattention‚Äù because in other places in the code with this event they work more accurately, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  Using the optional <i>handler</i> variable eliminates the problem.  In the <i>OnTextBufferChanged</i> method, <i>you</i> need to make edits for the same safe work with the event. <br><br>  <b>Intersecting ranges</b> <br><br>  <a href="https://www.viva64.com/ru/w/v3092/">V3092</a> Range intersections are possible within conditional expressions.  Example: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  For better understanding, I will rewrite this code snippet, replacing the names of constants with their actual values: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Probably there is no real error here, but the condition looks strange.  The second part ( <i>else if</i> ) will be executed only for the value range from 2147483648 + 1 to 4294967295. <br><br>  A couple of similar warnings: <br><br><ul><li>  V3092 Range intersections are possible within conditional expressions.  Example: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Range intersections are possible within conditional expressions.  Example: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>More about tests for equality of null (or their absence)</b> <br><br>  Several errors <a href="https://www.viva64.com/ru/w/v3095/">V3095</a> about checking the variable for equality of <i>null</i> after use.  The first is ambiguous, consider the code. <br><br>  V3095 The 'displayName' object was used before it was verified against null.  Check lines: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  It is assumed that the <i>displayName</i> reference may be null.  To do this, check <i>Debug.Assert</i> .  It is not clear why it comes after the use of the line.  It should also be <i>noted</i> that for other configurations other than Debug, the compiler will <i>remove Debug.Assert</i> from the code altogether.  Does this mean that only for Debug is it possible to get a null link?  And if this is not the case, then why wasn‚Äôt a <i>string.IsNullOrEmpty (string)</i> check <i>done</i> , for example.  These are questions to the authors of the code. <br><br>  The following error is more obvious. <br><br>  V3095 The 'scriptArgsOpt' object was used before it was verified against null.  Check lines: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  I think this code snippet does not require explanations.  I will give a corrected version: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  In the Roslyn code there were 15 more similar errors: <br><br><ul><li>  V3095 The 'LocalFunctions' object was used before it was verified against null.  Check lines: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 The 'resolution.OverloadResolutionResult' object was used against null.  Check lines: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 The 'resolution.MethodGroup' object was verified against it.  Check lines: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 The 'touchedFilesLogger' object was verified against null.  Check lines: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 The 'newExceptionRegionsOpt' object was verified against it.  Check lines: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 The 'symbol' object was used against it.  Check lines: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 The '_state.BaseTypeOrInterfaceOpt' object was verified against null.  Check lines: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  It was verified against null.  Check lines: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 The 'languages' object was verified against null.  Check lines: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 The 'memberType' object was used before it was verified against null.  Check lines: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 The 'validTypeDeclarations' object was used before it was verified against null.  Check lines: 223, 228. SyntaxTreeExtensions.cs 223 </li><li> V3095 The 'text' object was used before it was verified against null. Check lines: 376, 385. MSBuildWorkspace.cs 376 </li><li> V3095 The 'nameOrMemberAccessExpression' object was used before it was verified against null. Check lines: 206, 223. CSharpGenerateTypeService.cs 206 </li><li> V3095 The 'simpleName' object was used before it was verified against null. Check lines: 83, 85. CSharpGenerateMethodService.cs 83 </li><li> V3095 The 'option' object was used before it was verified against null. Check lines: 23, 28. OptionKey.cs 23 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the error </font></font><a href="https://www.viva64.com/ru/w/v3105/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Here, the conditional </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operator is used </font><font style="vertical-align: inherit;">to initialize the variable, but later in the code the variable is used without checking for equality of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two warnings signal the next error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 The 'documentId' variable was used after it was assigned through the null-conditional operator. NullReferenceException is possible. CodeLensReferencesService.cs 138 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 The 'documentId' variable was used through the null-conditional operator. NullReferenceException is possible. CodeLensReferencesService.cs 139</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentId</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variable </font><font style="vertical-align: inherit;">can be initialized to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">As a result, the creation of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReferenceLocationDescriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">will result in an exception being thrown. </font><font style="vertical-align: inherit;">The code needs to be fixed:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also further in the code it is necessary to provide the possibility of equality of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variables passed to the constructor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other similar code errors:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 The 'symbol' variable was used after it was assigned through the null-conditional operator. </font><font style="vertical-align: inherit;">NullReferenceException is possible. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 44</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 The 'symbol' variable was used after it was assigned through the null-conditional operator. </font><font style="vertical-align: inherit;">NullReferenceException is possible. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 51</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Priorities and brackets </font></font></b> <br><br> <a href="https://www.viva64.com/ru/w/v3123/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3123</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perhaps the '?:' Operator works in a different way than it was expected. It is a priority. Edit.cs 70</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The condition in the return block is not calculated exactly as the developer thought. </font><font style="vertical-align: inherit;">It was assumed that the first condition would be </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d (therefore after this condition a line </font><i><font style="vertical-align: inherit;">break</font></i><font style="vertical-align: inherit;"> is made), and then blocks of conditions with the operator " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">Will be calculated sequentially </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In fact, the first condition is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kind &amp;&amp; (_oldNode == null)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is due to the fact that the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operator </font><font style="vertical-align: inherit;">has a higher priority than the " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">Operator </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To correct the error, you need to bracket all the expressions of the operator " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ":</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This concludes the description of the errors found. </font></font><br><br>  <b>findings</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite the significant number of errors that I was able to detect, in terms of the size of the Roslyn project code (2,770,000 lines), this would be a rather insignificant amount. Like Andrew in the previous article, I am also ready to recognize the high quality of this project. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I want to note that such episodic checks of the code have nothing to do with the methodology of static analysis and practically do not bring any benefit. Static analysis should be applied regularly, not occasionally. Then many errors will be corrected at the earliest stages, and, therefore, the cost of correcting them will be ten times lower. In more detail, this idea is presented in this small </font></font><a href="https://www.viva64.com/ru/b/0534/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">note</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which I beg you to read.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can search for any other errors yourself, either in the considered project or in any other. </font><font style="vertical-align: inherit;">For this you just need to </font></font><a href="https://www.viva64.com/ru/pvs-studio-download/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">download</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and try our analyzer.</font></font><br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/446588/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to share this article with an English-speaking audience, then please use the link to the translation: Sergey Khrenov. </font></font><a href="https://habr.com/en/company/pvs-studio/blog/446588/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checking the Roslyn Source Code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/446592/">https://habr.com/ru/post/446592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446576/index.html">Import substitution, or how Russian Helicopters did something wrong</a></li>
<li><a href="../446578/index.html">A programming language that fits on a postcard</a></li>
<li><a href="../446582/index.html">Reflections on solar hosting for bees</a></li>
<li><a href="../446586/index.html">Network settings from FreeRadius via DHCP</a></li>
<li><a href="../446590/index.html">39 new features that will be available in Java 12</a></li>
<li><a href="../446598/index.html">Recreating fonts from a CRT screen</a></li>
<li><a href="../446602/index.html">Maximum direct current through field effect transistor</a></li>
<li><a href="../446604/index.html">ESET: new delivery schemes for OceanLotus cyber group backdoor</a></li>
<li><a href="../446606/index.html">Check how well you know about additive technologies.</a></li>
<li><a href="../446608/index.html">Overcoming the third law of organizational gravity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>