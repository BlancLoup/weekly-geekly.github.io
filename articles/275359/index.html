<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Office lighting control over Wi-Fi. Part 1: Atmel WINC1500 Wi-Fi Module</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In this series of articles we will not focus on DIY development a la "Smart Office" or "boxed" product that we offer to buy. The purpos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Office lighting control over Wi-Fi. Part 1: Atmel WINC1500 Wi-Fi Module</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In this series of articles we will not focus on DIY development a la "Smart Office" or "boxed" product that we offer to buy.  The purpose of the cycle is to familiarize readers with the basics of working on three products of the notorious Atmel company: <br><ul><li>  SAMD21 Series Microcontroller with Cortex-M0 + Core </li><li>  Wi-Fi module WINC1500 </li><li>  Q-touch touch key technology </li></ul><br>  But instead of the usual blinking of the LED on debugging, we decided to blink lights at our office through a Wi-Fi network using the industrial ModBus TCP protocol for greater scale, and we will manage it using touch buttons and sliders.  We will already use the <a href="http://www.atmel.com/tools/ATSAMD21-XPRO.aspx%3Ftab%3Doverview">SAMD21 Xplained Pro</a> debug card for our readers, with 2 <a href="http://www.atmel.com/tools/ATWINC1500-XPRO.aspx">ATWINC1500-XPRO</a> and <a href="http://www.atmel.com/tools/ATQT1-XPRO.aspx">ATQT1-XPRO</a> expansion modules connected to it.  Having connected expansion modules to debugging we get the following construction: <br><br><img src="https://habrastorage.org/files/7c0/3f0/e42/7c03f0e429e84612b75612854e617a95.png"><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">A bit about debugging a series of Xplained Pro</b> <div class="spoiler_text">  <a href="http://www.atmel.com/products/microcontrollers/avr/xplained.aspx">Xplained Pro Kits</a> is a series of mid-priced debugging boards (the cheapest are the Xplained mini whales) for various Atmel microcontroller families and a set of expansion modules for them.  Moreover, due to the unified edge connectors on the debugs, the expansion modules fit any board.  Those.  implemented the concept a la Arduino.  All boards have an EDBG debugger installed.  The rest of the peripherals on the board depends on the controller installed on it. <br></div></div><br><h4>  Formulation of the problem </h4><br>  In our office, we installed LED controlled (read dimmable) lamps using the DALI protocol.  For communication with the outside world, the lighting system uses the ModBus-DALI gateway of our design.  The gateway can be controlled both via RS485 interface (ModBus RTU) and via Ethernet (ModBus TCP).  To solve our problem we will use the latter.  Thus, our design connects to the local network via Wi-Fi, the microcontroller analyzes the state of the touch buttons and slider and converts them into ModBus TCP protocol commands.  Those, in turn, are converted into DALI commands and are sent to the performance of lamps. <br>  <i>Note: ModBus DALI gateway is not an object of description in this series of articles, but is taken as a given and the only way to integrate into the lighting control system (SLA).</i> <br><br><h4>  Connecting Wi-Fi module WINC1500 </h4><br>  Atmel, like many other manufacturers of semiconductor technology, is trying to find a cushy place in the incomprehensible, but gaining strength and popularity of the financial ‚Äúbubble‚Äù called Internet Of Things.  Therefore, Atmel positions its Wi-Fi solutions as low-consuming and designed for use in Internet of things devices.  The WINC1500 module considered in today's article is designed to work with a host controller via a serial interface UART / SPI / I2C.  The module has a chip antenna on board. <br><div class="spoiler">  <b class="spoiler_title">Summary of datasheet</b> <div class="spoiler_text"><ul><li>  IEEE802.11 b / g / n 20MHz (1x1) solution </li><li>  2.4 GHz ISM band </li><li>  Integrated PA and T / R Switch </li><li>  Integrated PCB antenna </li><li>  PHY signal processing </li><li>  Advanced Equalization and Channel Estimation </li><li>  Advanced Carrier and Timing Synchronization </li><li>  Wi-Fi Direct and Soft-AP support </li><li>  Supports IEEE 802.11 WEP, WPA, WPA2 Security </li><li>  Supports China WAPI security </li><li>  Superior MAC throughput hardware frame two-level A-MSDU / A-MPDU frame aggregation and block acknowledgment </li><li>  On-chip memory management engine to reduce host load </li><li>  SPI, UART, and I2C host interfaces </li><li>  2- or 3-wire Bluetooth coexistence interface </li><li>  Operating temperature range -40 ¬∞ C to + 85 ¬∞ C </li><li>  I / O operating voltage of 2.7V to 3.6V </li><li>  Integrated Flash memory for system software </li><li>  Power Save Modes </li><li>  Integrated Network IP stack to minimize host CPU requirements </li><li>  Network features TCP, UDP, DHCP, ARP, HTTP, SSL, and DNS </li><li>  Small footprint host driver (4KB flash - less than 1KB RAM) </li></ul><br></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Connection of the expansion module to debugging and pre-setting </h4><br>  Debugging SAMD21 Xplained has 3 external connectors for connecting expansion cards.  By default, the project is created on the assumption that the expansion card with the WINC1500 is connected to the debugging connector EXT1.  If you need to connect it to another connector, you need to change ports in the conf_winc.h file: <br><div class="spoiler">  <b class="spoiler_title">Defaults for using EXT3</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ---------- PIN settings --------- #define CONF_WINC_PIN_RESET PIN_PA27 #define CONF_WINC_PIN_CHIP_ENABLE PIN_PA28 #define CONF_WINC_PIN_WAKE PIN_PB08 // ---------- SPI settings --------- #define CONF_WINC_USE_SPI (1) /** SPI pin and instance settings. */ #define CONF_WINC_SPI_MODULE SERCOM2 #define CONF_WINC_SPI_SERCOM_MUX SPI_SIGNAL_MUX_SETTING_D #define CONF_WINC_SPI_PINMUX_PAD0 PINMUX_PA12C_SERCOM2_PAD0 /* out */ #define CONF_WINC_SPI_PINMUX_PAD1 PINMUX_PA13C_SERCOM2_PAD1 /* sck */ #define CONF_WINC_SPI_PINMUX_PAD2 PINMUX_UNUSED /* cs driven from software */ #define CONF_WINC_SPI_PINMUX_PAD3 PINMUX_PA15C_SERCOM2_PAD3 /* in */ #define CONF_WINC_SPI_CS_PIN PIN_PA14 /** SPI interrupt pin. */ #define CONF_WINC_SPI_INT_PIN PIN_PB09A_EIC_EXTINT9 #define CONF_WINC_SPI_INT_MUX MUX_PB09A_EIC_EXTINT9 #define CONF_WINC_SPI_INT_EIC (9)</span></span></code> </pre> <br></div></div><br>  The module is connected to the host controller at SPI debugging, in addition to the module there is an input / output port, which the module ‚Äúpulls‚Äù at any event (receiving / sending a packet).  In the code, a hardware interrupt is configured when the level on this pin changes.  When an interrupt occurs in the handler, the event counter increases. <br><br><h4>  Setting debazh output to COM port </h4><br>  The built-in EDBG debugger is defined in the device manager as a debugger and as a virtual COM-port, to which you can configure one of the microcontroller SERCOMs.  Thus, you can output debugging messages to the COM port through the same USB-micro connector, through which programming and debugging takes place: <br><div class="spoiler">  <b class="spoiler_title">Initialization function code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure_console</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usart_config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">usart_conf</span></span></span><span class="hljs-class">;</span></span> usart_get_config_defaults(&amp;usart_conf); usart_conf.mux_setting = EDBG_CDC_SERCOM_MUX_SETTING; usart_conf.pinmux_pad0 = EDBG_CDC_SERCOM_PINMUX_PAD0; usart_conf.pinmux_pad1 = EDBG_CDC_SERCOM_PINMUX_PAD1; usart_conf.pinmux_pad2 = EDBG_CDC_SERCOM_PINMUX_PAD2; usart_conf.pinmux_pad3 = EDBG_CDC_SERCOM_PINMUX_PAD3; usart_conf.baudrate = <span class="hljs-number"><span class="hljs-number">115200</span></span>; stdio_serial_init(&amp;cdc_uart_module, EDBG_CDC_MODULE, &amp;usart_conf); usart_enable(&amp;cdc_uart_module); }</code> </pre><br></div></div><br><br><h4>  Callback'and our all </h4><br>  The library for working with the WINC1500 module is built on the principle of Callbacks, i.e.  if we want something from the module (for example, to get the number of available Wi-Fi networks on the radio), then we call the corresponding function (which sends the necessary request to the module) and the module leaves to ‚Äúthink‚Äù.  When the module generates the result, it will change the state of the INT pin, thereby triggering an external interrupt in the microcontroller, the handler of which increases the event counter.  When you call the function m2m_wifi_handle_events (NULL);  the number of events and parameters (type, required data) of each event (in our example, the termination of the air scan and the readiness to return the number of found networks) are read, and the corresponding function (Callback) is called if it is initialized and registered in advance. <br><br><img src="https://habrastorage.org/files/698/6e0/698/6986e06989f44865ab136add166bb7b0.png"><br><br><h4>  Verify connectivity with WINC1500 over SPI </h4><br>  To get started, you need to initialize the module, configure and register the necessary Callbacks.  To read the parameters of the module callback is not needed, so as long as we do not register and do not. <br><div class="spoiler">  <b class="spoiler_title">Initializing the module and getting its parameters</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ tstrWifiInitParam settings; <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> ret; <span class="hljs-comment"><span class="hljs-comment">// Initialize the board. system_init(); // Initialize the UART console. configure_console(); printf(STRING_HEADER); // Initialize the BSP. nm_bsp_init(); // Initialize Wi-Fi parameters structure. memset((uint8_t *)&amp;settings, 0, sizeof(tstrWifiInitParam)); //Initialize Wi-Fi driver with data and status callbacks. ret = m2m_wifi_init(&amp;settings); if (M2M_SUCCESS != ret) { printf("main: m2m_wifi_init call error!(%d)\r\n", ret); while (1); } // Display WINC1500 chip information. printf("Chip ID : \r\t\t\t%x\r\n", (unsigned int)nmi_get_chipid()); printf("RF Revision ID : \r\t\t\t%x\r\n", (unsigned int)nmi_get_rfrevid()); printf("Done.\r\n\r\n"); while (1); return 0; }</span></span></code> </pre><br></div></div><br><br><h4>  Creating an access point </h4><br>  WINC1500 allows you to create an access point and distribute IP addresses to connected subscribers via DHCP.  The beginning of main is the same as in the previous example, but it adds initialization of the structure containing the parameters of the access point and the creation of an access point, as well as registering the callback before initializing the module: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Initialize Wi-Fi parameters structure. memset((uint8_t *)&amp;settings, 0, sizeof(tstrWifiInitParam)); // Initialize Wi-Fi driver with data and status callbacks. settings.pfAppWifiCb = wifi_cb; ret = m2m_wifi_init(&amp;settings); if (M2M_SUCCESS != ret) { printf("main: m2m_wifi_init call error!(%d)\r\n", ret); while (1); }</span></span></code> </pre><br>  In access point mode, the WINC1500 supports only WEP encryption (WPA is not supported) or an open Wi-Fi network.  Also only 1 client is supported. <br><div class="spoiler">  <b class="spoiler_title">Creating an access point.</b>  <b class="spoiler_title">Additional code</b> <div class="spoiler_text">  Main function code: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Initialize AP mode parameters structure with SSID, channel and OPEN security type. memset(&amp;strM2MAPConfig, 0x00, sizeof(tstrM2MAPConfig)); strcpy((char *)&amp;strM2MAPConfig.au8SSID, MAIN_WLAN_SSID); strM2MAPConfig.u8ListenChannel = MAIN_WLAN_CHANNEL; strM2MAPConfig.u8SecType = MAIN_WLAN_AUTH; strM2MAPConfig.au8DHCPServerIP[0] = 192; strM2MAPConfig.au8DHCPServerIP[1] = 168; strM2MAPConfig.au8DHCPServerIP[2] = 1; strM2MAPConfig.au8DHCPServerIP[3] = 1; #if USE_WEP strcpy((char *)&amp;strM2MAPConfig.au8WepKey, MAIN_WLAN_WEP_KEY); strM2MAPConfig.u8KeySz = strlen(MAIN_WLAN_WEP_KEY); strM2MAPConfig.u8KeyIndx = MAIN_WLAN_WEP_KEY_INDEX; #endif /* Bring up AP mode with parameters structure. */ ret = m2m_wifi_enable_ap(&amp;strM2MAPConfig); if (M2M_SUCCESS != ret) { printf("main: m2m_wifi_enable_ap call error!\r\n"); while (1); } printf("AP mode started. You can connect to %s.\r\n", (char *)MAIN_WLAN_SSID); while (1) { while (m2m_wifi_handle_events(NULL) != M2M_SUCCESS); // Handle pending events from network controller. } //  callback static void wifi_cb(uint8_t u8MsgType, void *pvMsg) { switch (u8MsgType) { case M2M_WIFI_RESP_CON_STATE_CHANGED: { tstrM2mWifiStateChanged *pstrWifiState = (tstrM2mWifiStateChanged *)pvMsg; if (pstrWifiState-&gt;u8CurrState == M2M_WIFI_CONNECTED) { } else if (pstrWifiState-&gt;u8CurrState == M2M_WIFI_DISCONNECTED) { printf("Station disconnected\r\n"); } break; } case M2M_WIFI_REQ_DHCP_CONF: { uint8_t *pu8IPAddress = (uint8_t *)pvMsg; printf("Station connected\r\n"); printf("Station IP is %u.%u.%u.%u\r\n", pu8IPAddress[0], pu8IPAddress[1], pu8IPAddress[2], pu8IPAddress[3]); break; } default: { break; } } }  main.h: /** Security mode */ #define USE_WEP (1) /*&lt; Set to (1) to use WEP, and (0) to use OPEN */ /** AP mode Settings */ #define MAIN_WLAN_SSID "WINC1500_AP" /* &lt; SSID */ #if USE_WEP #define MAIN_WLAN_AUTH M2M_WIFI_SEC_WEP /* &lt; Security manner */ #define MAIN_WLAN_WEP_KEY "1234567890" /* &lt; Security Key in WEP Mode */ #define MAIN_WLAN_WEP_KEY_INDEX (1) #else #define MAIN_WLAN_AUTH M2M_WIFI_SEC_OPEN /* &lt; Security manner */ #endif #define MAIN_WLAN_CHANNEL (6) /* &lt; Channel number */</span></span></code> </pre><br></div></div><br>  Work in the access point mode, due to the voiced restrictions, is not the main mode of operation of the WINC1500, but serves mainly to implement a mechanism for connecting to a third-party access point.  For example, if your device does not have an interface in order to set the network parameters (SSID and password) to which you want to connect, you can first create your own access point and connect to it in some way to transfer data about the target network. <br>  By the way, this mechanism is already implemented in the module: by a special command, in addition to starting your own access point, you can start the WEB server built into the module and connect to it with a browser to set the connection parameters to the target network. <br><br><h4>  Get a list of available networks </h4><br>  Now let's scan the air for Wi-Fi networks and list them in the debug port. <br>  To start scanning, it is enough to call the function m2m_wifi_request_scan (M2M_WIFI_CH_ALL) immediately after the module initialization <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Initialize Wi-Fi parameters structure. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)&amp;settings, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tstrWifiInitParam)); <span class="hljs-comment"><span class="hljs-comment">/* Initialize Wi-Fi driver with data and status callbacks. */</span></span> settings.pfAppWifiCb = wifi_cb; ret = m2m_wifi_init(&amp;settings); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (M2M_SUCCESS != ret) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"main: m2m_wifi_init call error!(%d)\r\n"</span></span>, ret); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* Request scan. */</span></span> m2m_wifi_request_scan(M2M_WIFI_CH_ALL);</code> </pre><br><br>  But at the same time, it is necessary to provide for the appropriate processing of scan events in the callback wifi_cb <br><div class="spoiler">  <b class="spoiler_title">Wifi_cb code to scan</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wifi_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u8MsgType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvMsg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (u8MsgType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> M2M_WIFI_RESP_SCAN_DONE: { tstrM2mScanDone *pstrInfo = (tstrM2mScanDone *)pvMsg; scan_request_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pstrInfo-&gt;u8NumofCh &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { m2m_wifi_req_scan_result(scan_request_index); scan_request_index++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m2m_wifi_request_scan(M2M_WIFI_CH_ALL); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> M2M_WIFI_RESP_SCAN_RESULT: { tstrM2mWifiscanResult *pstrScanResult = (tstrM2mWifiscanResult *)pvMsg; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> demo_ssid_len; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> scan_ssid_len = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)pstrScanResult-&gt;au8SSID); <span class="hljs-comment"><span class="hljs-comment">/* display founded AP. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"[%d] SSID:%s\r\n"</span></span>, scan_request_index, pstrScanResult-&gt;au8SSID); num_founded_ap = m2m_wifi_get_num_ap_found(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scan_ssid_len) { <span class="hljs-comment"><span class="hljs-comment">/* check same SSID. */</span></span> demo_ssid_len = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)MAIN_WLAN_SSID); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( (demo_ssid_len == scan_ssid_len) &amp;&amp; (!<span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(pstrScanResult-&gt;au8SSID, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)MAIN_WLAN_SSID, demo_ssid_len))) { <span class="hljs-comment"><span class="hljs-comment">/* A scan result matches an entry in the preferred AP List. * Initiate a connection request. */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Found %s \r\n"</span></span>, MAIN_WLAN_SSID); m2m_wifi_connect((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)MAIN_WLAN_SSID,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MAIN_WLAN_SSID), MAIN_WLAN_AUTH,(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)MAIN_WLAN_PSK,M2M_WIFI_CH_ALL); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scan_request_index &lt; num_founded_ap) { m2m_wifi_req_scan_result(scan_request_index); scan_request_index++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"can not find AP %s\r\n"</span></span>, MAIN_WLAN_SSID); m2m_wifi_request_scan(M2M_WIFI_CH_ALL); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> M2M_WIFI_RESP_CON_STATE_CHANGED: { tstrM2mWifiStateChanged *pstrWifiState = (tstrM2mWifiStateChanged *)pvMsg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pstrWifiState-&gt;u8CurrState == M2M_WIFI_CONNECTED) { m2m_wifi_request_dhcp_client(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pstrWifiState-&gt;u8CurrState == M2M_WIFI_DISCONNECTED) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Wi-Fi disconnected\r\n"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Request scan. */</span></span> m2m_wifi_request_scan(M2M_WIFI_CH_ALL); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> M2M_WIFI_REQ_DHCP_CONF: { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pu8IPAddress = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)pvMsg; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Wi-Fi connected\r\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Wi-Fi IP is %u.%u.%u.%u\r\n"</span></span>, pu8IPAddress[<span class="hljs-number"><span class="hljs-number">0</span></span>], pu8IPAddress[<span class="hljs-number"><span class="hljs-number">1</span></span>], pu8IPAddress[<span class="hljs-number"><span class="hljs-number">2</span></span>], pu8IPAddress[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br></div></div><br>  To debug connection and data transfer via UDP / TCP and debug in general is very convenient with Hercules) <br>  The debug output of the scan result is: <br><img src="https://habrastorage.org/files/c7e/39d/45c/c7e39d45c2a34d36ac27897f2f1e3248.png"><br><br><h4>  DHCP connection </h4><br>  By default, WINC connects via DHCP, and by hints in various Atmel comments and documents, they want to shut off the ability to connect with a static IP. <br><br>  When connected via DHCP, the callback code must handle the corresponding event. <br><div class="spoiler">  <b class="spoiler_title">Wifi_cb code when using DHCP</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wifi_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u8MsgType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvMsg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (u8MsgType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> M2M_WIFI_RESP_CON_STATE_CHANGED: { tstrM2mWifiStateChanged *pstrWifiState = (tstrM2mWifiStateChanged *)pvMsg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pstrWifiState-&gt;u8CurrState == M2M_WIFI_CONNECTED) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: CONNECTED\r\n"</span></span>); m2m_wifi_request_dhcp_client(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pstrWifiState-&gt;u8CurrState == M2M_WIFI_DISCONNECTED) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: DISCONNECTED\r\n"</span></span>); wifi_connected = <span class="hljs-number"><span class="hljs-number">0</span></span>; m2m_wifi_connect((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)MAIN_WLAN_SSID, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> M2M_WIFI_REQ_DHCP_CONF: { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *pu8IPAddress = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)pvMsg; wifi_connected = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"wifi_cb: M2M_WIFI_REQ_DHCP_CONF: IP is %u.%u.%u.%u\r\n"</span></span>,pu8IPAddress[<span class="hljs-number"><span class="hljs-number">0</span></span>], pu8IPAddress[<span class="hljs-number"><span class="hljs-number">1</span></span>], pu8IPAddress[<span class="hljs-number"><span class="hljs-number">2</span></span>], pu8IPAddress[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br></div></div><br><br><h4>  Connection with a static address </h4><br>  To connect with a static address, you must first disable the automatic dhcp connection in main after the module is initialized: <br><pre> <code class="cpp hljs"> m2m_wifi_enable_dhcp(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  And change the callback accordingly: <br><div class="spoiler">  <b class="spoiler_title">Wifi_cb code when using static IP</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wifi_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u8MsgType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvMsg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"wifi_cb: u8MsgType= %d\n"</span></span>,u8MsgType); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (u8MsgType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> M2M_WIFI_RESP_CON_STATE_CHANGED: { tstrM2mWifiStateChanged *pstrWifiState = (tstrM2mWifiStateChanged *)pvMsg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pstrWifiState-&gt;u8CurrState == M2M_WIFI_CONNECTED) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: CONNECTED\r\n"</span></span>); tstrM2MIPConfig ip_client; ip_client.u32StaticIP = _htonl(<span class="hljs-number"><span class="hljs-number">0xc0a8142d</span></span>); <span class="hljs-comment"><span class="hljs-comment">//corresponds to 192.168.20.45 ip_client.u32DNS = _htonl(0xc0a80266); //corresponds to 192.168.2.102 ip_client.u32SubnetMask =_htonl(0xFFFFFF00); //corresponds to 255.255.255.0 ip_client.u32Gateway = _htonl(0xc0a81401); //corresponds to 192.168.20.1 m2m_wifi_set_static_ip(&amp;ip_client); wifi_connected = 1; } else { if (pstrWifiState-&gt;u8CurrState == M2M_WIFI_DISCONNECTED) { printf("wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: DISCONNECTED\r\n"); wifi_connected = 0; m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL); } } break; } default: break; } }</span></span></code> </pre><br></div></div><br><h4>  Work with TCP / IP stack </h4><br>  Most APIs for working with the TCP / IP stack through the WINC1500 are implemented by analogy with Berkeley sockets. <br><table><tbody><tr><th>  Berkeley API </th><th>  WINC API </th><th>  Server / Client </th><th>  TCP / UDP </th><th>  Description </th></tr><tr><td>  socket </td><td>  socket </td><td>  Both </td><td>  Both </td><td>  Creates a new socket </td></tr><tr><td>  connect </td><td>  connect </td><td>  Client </td><td>  Tcp </td><td>  Establishes a TCP connection to a remote server. </td></tr><tr><td>  bind </td><td>  bind </td><td>  Server </td><td>  Both </td><td>  Bindit socket with IP address and port </td></tr><tr><td>  listen </td><td>  listen </td><td>  Server </td><td>  Tcp </td><td>  Creates a TCP server </td></tr><tr><td>  send </td><td>  send </td><td>  Both </td><td>  Both </td><td>  Send data to socket </td></tr><tr><td>  sendto </td><td>  sendto </td><td>  Both </td><td>  UDP </td><td>  Sends packet over UDP </td></tr><tr><td>  recv </td><td>  recv </td><td>  Both </td><td>  Both </td><td>  Receives a packet </td></tr><tr><td>  recvfrom </td><td>  recvfrom </td><td>  Both </td><td>  Both </td><td>  Receives a packet </td></tr><tr><td>  close </td><td>  close </td><td>  Both </td><td>  Both </td><td>  Closes connection and frees up resources. </td></tr><tr><td>  gethostbyname </td><td>  gethostbyname </td><td>  Both </td><td>  Both </td><td>  Gets the IP address by host name </td></tr><tr><td>  setsockopt </td><td>  setsockopt </td><td>  Both </td><td>  Both </td><td>  Sets socket options </td></tr><tr><td>  htons / ntohs </td><td>  htons / ntohs </td><td>  Both </td><td>  Both </td><td>  Changes the byte order in 2-byte integers from the host representation to the network and vice versa. </td></tr><tr><td>  htonl / ntohl </td><td>  htonl / ntohl </td><td>  Both </td><td>  Both </td><td>  Changes the byte order in 4-byte integers from the host representation to the network and vice versa. </td></tr></tbody></table>  <i>Note: The Berkeley API functions write, read, gethostbyaddr, select, poll, getsockopt are not supported in WINC1500.</i> <br><br><h4>  UDP and TCP </h4><br>  To work on UDP and TCP, it is necessary to create the corresponding sockets, initialize them, open, write and register a callback for processing the reception / transmission of data.  We will not dwell on each case in detail (UDP sending / receiving, TCP client / server), consider the main points. <br>  The initialization of socket parameters is accomplished using an appropriate structure.  It is necessary to specify the type of connection, port, server IP (in the form of 0xc0a814ff, for example, for 192.168.20.255) <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">src_addr</span></span></span><span class="hljs-class">;</span></span> addr.sin_family = AF_INET; addr.sin_port = _htons(MAIN_WIFI_M2M_SERVER_PORT); addr.sin_addr.s_addr = _htonl(MAIN_WIFI_M2M_SERVER_IP);</code> </pre><br>  We initialize the socket and callback to it, and also connect to the network with the previously specified parameters in the addr structure: <br><pre> <code class="cpp hljs"> socketInit(); registerSocketCallback(socket_cb, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Connect to router. m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL); printf("m2m_wifi_connect!\r\n");</span></span></code> </pre><br>  In the main loop, we create a socket and bind it and implement connection support (in case of disconnection, reconnection).  Both for UDP and TCP, the procedures are the same except for the connection type (SOCK_DGRAM UDP, SOCK_STREAM TCP). <br><pre> <code class="cpp hljs">SOCKET rx_socket = <span class="hljs-number"><span class="hljs-number">-1</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rx_socket &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((rx_socket = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number"><span class="hljs-number">0</span></span>)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"main: failed to create RX UDP Client socket error!\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Socket bind bind(rx_socket, (struct sockaddr *)&amp;src_addr, sizeof(struct sockaddr_in)); } if (wifi_connected == M2M_WIFI_CONNECTED) { // Open client socket. if (rx_socket &lt; 0) { if ((rx_socket = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { printf("main: failed to create TCP client socket error!\r\n"); continue; } // Connect server printf("socket_number new connection: %d\r\n", rx_socket); ret=connect(rx_socket, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_in)); printf("ret value: %d\r\n", ret); connected = FALSE; if (ret &lt; 0) { close(rx_socket); rx_socket = -1; } } }</span></span></code> </pre><br>  The callback should handle the connection / bind, receive, and transfer events for the TCP server: listen, accept. <br>  An example callback for simultaneous operation of UDP (rx_socket) and TCP (tcp_client_socket): <br><div class="spoiler">  <b class="spoiler_title">socket_cb for UDP and TCP</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socket_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SOCKET sock, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u8Msg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvMsg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Check for socket event on RX socket. if (sock == rx_socket) { if (u8Msg == SOCKET_MSG_BIND) { tstrSocketBindMsg *pstrBind = (tstrSocketBindMsg *)pvMsg; if (pstrBind &amp;&amp; pstrBind-&gt;status == 0) { // Prepare next buffer reception. sock_bind_state = 1; recv(sock, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, 0); } else { printf("socket_cb: bind error!\r\n"); } } else if (u8Msg == SOCKET_MSG_RECVFROM) { tstrSocketRecvMsg *pstrRx = (tstrSocketRecvMsg *)pvMsg; if (pstrRx-&gt;pu8Buffer &amp;&amp; pstrRx-&gt;s16BufferSize) { delay = 0; sock_rx_state = pstrRx-&gt;s16BufferSize; printf("socket_cb udp recv!\r\n"); printf("rx packet length= %d\n",pstrRx-&gt;s16BufferSize); } else { if (pstrRx-&gt;s16BufferSize == SOCK_ERR_TIMEOUT) { // Prepare next buffer reception. recv(sock, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, 0); } } } if (u8Msg == SOCKET_MSG_SENDTO) { recv(sock, udp_data_rx, MAIN_WIFI_M2M_BUFFER_SIZE, 0); sock_tx_state = 1; } } if (sock == tcp_client_socket) { switch (u8Msg) { // Socket connected case SOCKET_MSG_CONNECT: { tstrSocketConnectMsg *pstrConnect = (tstrSocketConnectMsg *)pvMsg; if (pstrConnect &amp;&amp; pstrConnect-&gt;s8Error &gt;= 0) { printf("socket_cb tcp connect!\r\n"); tcp_ready_to_send=1; } else { close(tcp_client_socket); tcp_client_socket = -1; } } break; // Message send case SOCKET_MSG_SEND: { printf("socket_cb tcp send!\r\n"); recv(tcp_client_socket, tcp_data_rx, sizeof(tcp_data_rx), 0); tcp_tx_ready=1; } break; // Message receive case SOCKET_MSG_RECV: { tstrSocketRecvMsg *pstrRecv = (tstrSocketRecvMsg *)pvMsg; if (pstrRecv &amp;&amp; pstrRecv-&gt;s16BufferSize &gt; 0) { tcp_rx_ready=pstrRecv-&gt;s16BufferSize; } else { close(tcp_client_socket); tcp_client_socket = -1; } } break; default: break; } } }</span></span></code> </pre><br></div></div><br>  It is important not to forget to call the event handling function from the module in while (1): <br><pre> <code class="cpp hljs">m2m_wifi_handle_events(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Conclusion <br><br>  Now, using the knowledge gained, we can already connect over the local network to our ModBus-DALI gateway.  The gateway is a TCP server on port 502.  But about this in the third part of the cycle, which we devote to the implementation of the ModBus TCP protocol on top of our local network.  In the second part, we will consider connecting and using touch buttons as a control interface.  Until new meetings. </div><p>Source: <a href="https://habr.com/ru/post/275359/">https://habr.com/ru/post/275359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275343/index.html">3rd place in 11 steps in the Hola JavaScript contest</a></li>
<li><a href="../275347/index.html">Purple Encryption Machine</a></li>
<li><a href="../275351/index.html">Dynamic Interrupt Management in ARM</a></li>
<li><a href="../275353/index.html">HTML5 analog clock with JavaScript logic</a></li>
<li><a href="../275355/index.html">Anonymous Father Frost 2015-2016 - Post boasting New Year's gifts</a></li>
<li><a href="../275361/index.html">Office lighting control over Wi-Fi. Part 2: Q-touch sensor technology</a></li>
<li><a href="../275369/index.html">USB bootloader on the microcontroller: firmware update from a flash drive</a></li>
<li><a href="../275371/index.html">Atmel Software Framework (ASF): how does it work?</a></li>
<li><a href="../275373/index.html">1-Wire slave on MK. Part 1: Iron</a></li>
<li><a href="../275375/index.html">Clocking Atmel microcontrollers SAMD20 / 21</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>