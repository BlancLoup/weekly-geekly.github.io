<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Finding simple on hard: tips & tricks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I got here a rather interesting project: on radiographs of welds to find wire samples of standard sizes. It would seem, how much has already been writ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Finding simple on hard: tips & tricks</h1><div class="post__text post__text-html js-mediator-article">  I got here a rather interesting project: on radiographs of welds to find wire samples of standard sizes.  It would seem, how much has already been written about the search patterns in the image, developed standard approaches and techniques, but when it comes to real-world problems, academic methods are not as effective as expected from them.  For starters, try finding all seven wires here: <br><br><img src="https://habrastorage.org/files/e2a/a5d/2ed/e2aa5d2edd3e407883424f7d096f003b.png" alt="image"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In fact, this is not the easiest shot, but in the end even everything was found on it: <br><br><img src="https://habrastorage.org/files/369/fe0/abe/369fe0abe2c0475e91c24d469f48e6a4.png" alt="image"><br><br>  So, what conditions were announced to me: <br>  - files will be tiff and can be quite large - more than 200 MB <br>  - images can be both positive and negative <br>  - on one picture there can be several standards, it is necessary to find everything <br>  - samples lie either almost vertically (+ -10 degrees) or almost horizontally <br>  - frames may have other standards and other elements <br>  - seams can be both straight and elliptical, horizontal and vertical <br>  - the sample may lie on or near the seam <br>  Maximum time to search for standards in the picture: <br>  - 3 seconds for a picture smaller than 100 MB <br>  - 5 seconds for a snapshot more than 100 MB and less than 200 MB <br>  - 10 seconds, for a picture larger than 200 MB. <br><br>  I was also given GOST standards of two types of standards that looked something like this: <br><br><img src="https://habrastorage.org/files/85f/7dd/bf6/85f7ddbf6a204b168875fd7ad86587a1.png" alt="image"><br><br>  Those.  Each standard consists of 7 wires of a certain length and a decreasing diameter located at predetermined distances. <br>  Lengths are different: 10, 20, 25, 50 mm. <br>  For each length there is a set of standards with different wire thicknesses, for example, one standard with 25 mm wire length has wire diameters of 3.2mm, 2.5mm, 2mm, 1.6mm, 1.25mm, 1.0mm, 0.8mm, 0.63mm, and the other - 1.0 mm, 0.8mm, 0.63mm, 0.5mm, 0.4mm, 0.32mm, 0.25mm. <br>  In total, there were about 16 standards. <br><br>  Thus, I had to localize fully deterministic objects in images of different quality. <br><br><h4>  Choosing a path </h4><br><br>  I immediately thought about using trained classifiers, but I was embarrassed by the fact that I had only 82 files with different standards, and for normal training of the classifier, we still need thousands of images.  So this way had to be swept away immediately. <br><br>  The task of searching for linear segments is itself well reflected in the literature. <br>  The very first thing that comes to mind is to look for segments of the <a href="http://ru.wikipedia.org/wiki/%25CF%25F0%25E5%25EE%25E1%25F0%25E0%25E7%25EE%25E2%25E0%25ED%25E8%25E5_%25D5%25E0%25F4%25E0">Hough</a> transformation, but, firstly, it is very resource-intensive, and secondly, weak signals among the stronger ones after the transformation will not look any easier.  Even if you take a pretty good framing: <br><br><img src="https://habrastorage.org/files/f2c/c6a/127/f2cc6a127b05408491ba0c05b20aa928.png"><br><br>  it is still rather difficult to find delays: <br><br><img src="https://habrastorage.org/files/fd5/c00/a99/fd5c00a9988a4342bbddfe048fc87826.png"><br><br>  (this is how it should look like: <img src="https://habrastorage.org/files/051/722/6b4/0517226b493a4ed2bf8d8e9528913d32.png" alt="image">  -&gt; <img src="https://habrastorage.org/files/4fb/466/b03/4fb466b03be043a3bf1fd7fd4e1cf11c.png" alt="image">  ) <br><br>  Another option would be to use filtering circuits, but the problem arises: how to choose the binarization threshold in automatic mode? <br>  Yes, and what to do with the contours, which mainly choose the weld or something else? <br><br><img src="https://habrastorage.org/files/f2c/c6a/127/f2cc6a127b05408491ba0c05b20aa928.png">  -&gt; <img src="https://habrastorage.org/files/cc9/035/c0b/cc9035c0b9ed4ec69ddc7c2b2d162534.png"><img src="https://habrastorage.org/files/3a2/5b0/39c/3a25b039c2b14d338c9fa24c77105ae2.png"><img src="https://habrastorage.org/files/def/236/eac/def236eacfd747ddaca881c44dd6b649.png"><br>  Loop detector with different binarization levels <br><br>  The same applies to other beamlet type <a href="http://www.wizpia.com/files/paper/10-09-2001/BeamletMSIP051101.pdf">detectors</a> . <br><br><h4>  What can be done to improve the situation? </h4><br><br>  As it turned out, a very productive step was the simple calculation of the gradient map, i.e.  just calculating the difference between two adjacent pixels.  Such a step sharply highlights the sharp edges and almost erases all the slow transitions.  Here's what, for example, happened after applying gradients twice: <br><br>  It was: <br><img src="https://habrastorage.org/files/dc4/4e1/d81/dc44e1d814a7453c8e549d6f21d68725.png"><br><br>  has become: <br><img src="https://habrastorage.org/files/e19/bd6/a60/e19bd6a6030a44e39800a0671bc03875.png"><br><br>  Contrast is enhanced on the bottom image for clarity. <br><br>  Agree, even with the naked eye it became much easier to find the wires. <br>  Immediately, another problem became visible - noise. And the noise level is uneven in the picture. <br><br>  How can we highlight areas of interest for a more detailed study?  Some method is needed that would take into account the local noise level and detect emissions that significantly exceed the average deviation. <br>  Since all the geometry of the standards is known to us in advance, we can choose the size of the window in which the local statistics will be collected, thus we will be able to automate the choice of the binarization threshold.  Moreover, since we know in advance that the wires will be approximately vertically, I decided to make an additional filter: if in the selected window significant emissions are more than 1/2 of the vertical size of the window, then we select the entire vertical bar as an area of ‚Äã‚Äãinterest for further analysis ( looking ahead, I‚Äôll say that I also added an additional statistical detector for emissions, which are several times higher than the standard deviation - it was necessary that all letters and numbers on the frame also fall entirely into the field of further analysis  and where they could be filtered out. Without it, a lot of false positives were due to partial areas to find letters and numbers). <br><br>  Here is what happened at this stage: <br><br><img src="https://habrastorage.org/files/fc2/acc/cb1/fc2acccb1aee4ae4b806daa79d734b7d.png" alt="image"><br><br>  Here, the resulting areas of interest are indicated in blue, pink, and black.  The current cluster for which recognition is performed is highlighted in pink. <br><br>  We coped with the preprocessing, we must go directly to the recognition of standards. <br><br>  The first step is clustering.  It is necessary to somehow break all the found points into clusters in order to work with them later. <br>  Here, the option to add all new points to the current cluster came up pretty well, if they are located + -2 pixels vertically / horizontally. <br>  In principle, this method can fail if the weld breaks the wire into two separated regions, so a second clustering option was provided, when +15 points were viewed vertically. <br><br><h4>  Pattern Recognition </h4><br><br>  Here again, different options are possible. <br>  Since the clusters are already allocated, it would be possible to take them and try to enter the calculated versions of the standards with different angles, scales, shifts into the original picture ... But as it turned out, this is again quite laborious and you can invent a bicycle. <br>  Namely: since we have almost vertical stripes, let's just make a projection along them, not even of the original picture or gradient maps, but of the clusters found.  This turned out to be enough to determine which particular reference is on the image, if there are clusters that correspond to at least three wires. <br>  Actually, I tried to make projections both on the original picture and on the gradient map, but there the noise was quite strong, and since we had already successfully dealt with it when searching for clusters, we can simply use the results obtained. <br><br>  All this led to the following algorithm: <br>  1. for each reference, we check that the cluster length approximately corresponds to the length of the reference wires. <br>  2. we take a cluster, we consider the projection along it + -100-150 pixels on the right and on the left, we have one-dimensional!  array with peaks in places of the found clusters. <br>  The fact that the one-dimensional array immediately gives us a performance gain, plus there is no need to look for corners (parallel wires). <br>  3. for several close scales (we know the scale only approximately), we calculate how the similar projection of each reference will look and make a convolution of the obtained projection of the reference and projections along the cluster + we consider how many peaks in the projection along the cluster are. <br>  4. if there are other clusters on both sides of the cluster - we are in the middle of the standard, go to the next cluster <br>  5. if nothing is detected from both sides - we most likely stumbled upon a false cluster formed by ‚Äúartifacts‚Äù <br>  6. If there is nothing on one side, and less than two peaks on the other, these are either artifacts or the wires are too thin, in any case, we will not be able to establish exactly where our standard is rotated only by two wires. <br>  7. if on the one hand there are more than 2 peaks, we check that the convolution with the reference projection gives a tangible contribution. <br><br>  convolution itself was considered so: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WSKernel[i] == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// punish more if there is no line: convlft += WSKernel[i] * (ltrtr[lngth - i] - k * tracemax); //ltrtr is always positive as a sum of presences of clusters convrgt += WSKernel[i] * (ltrtr[lngth + i] - k * tracemax); } else // WSKernel[[i]]==-1 { convlft += WSKernel[i] * ltrtr[lngth - i]; convrgt += WSKernel[i] * ltrtr[lngth + i]; }</span></span></code> </pre> <br>  where WSKernel is the reference projection, which has 1 in places where there is a wire and -1 where it does not exist (that is, it looks like 1,1,1,1,1,1, -1, -1, -1, -1 1,1,1, ...) <br>  ltrtr is the projection itself along the cluster <br>  tracemax is the maximum intensity of the projection along the cluster <br><br>  All this works so that in places where there is a peak and it coincides with the standard to make a positive contribution (-k * tracemax is needed to penalize not finding a wire in the right place, k = 0.1 turned out to be the most productive), and where it is, but not matches - negative. <br><br>  After passing through several scales and standards, the maximum contribution is selected and it is considered that this cluster corresponds to this standard with the calculated scale factor. <br><br>  Further - only drawing and delivery of results. <br><br>  Well, a couple of examples: <br><br><img src="https://habrastorage.org/files/ff9/faa/d48/ff9faad4891140b88713aaf6efe37c1f.png"><br><img src="https://habrastorage.org/files/127/f87/f91/127f87f9135145d2b0a883e5ab78c653.png"><br><br><img src="https://habrastorage.org/files/f1e/186/786/f1e18678626d40b49e6fad95dff4002f.png"><br><img src="https://habrastorage.org/files/1a5/020/611/1a5020611dbb4a9bb78981eef1becb2c.png"><br><br><img src="https://habrastorage.org/files/4a2/2fe/fa2/4a22fefa27704926a54f4048aded6569.png"><br><img src="https://habrastorage.org/files/13d/0e6/cf2/13d0e6cf217f41079f52e158ac85e14e.png"></div><p>Source: <a href="https://habr.com/ru/post/236309/">https://habr.com/ru/post/236309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../236295/index.html">New service from IBM Watson will help scientists work more efficiently</a></li>
<li><a href="../236297/index.html">3G modem - less does not happen</a></li>
<li><a href="../236299/index.html">Review of the "hybrid" DVR with touch control</a></li>
<li><a href="../236301/index.html">Smart Watch Moto 360: a full analysis of iFixit (and 3 out of 10 scale of repairability)</a></li>
<li><a href="../236307/index.html">HTC One firmware in fastboot</a></li>
<li><a href="../236313/index.html">Microsoft buys development company Minecraft for $ 2 billion</a></li>
<li><a href="../236315/index.html">Bookmarklet: analysis of essential points, part two, loadable</a></li>
<li><a href="../236317/index.html">Zenfone 4 Review</a></li>
<li><a href="../236319/index.html">New features of Google Search in site links</a></li>
<li><a href="../236321/index.html">Formula E: Electric Car Racing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>