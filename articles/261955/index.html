<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qt Framework: streams, hierarchical finite state machine, work with USB devices = QThread + QStateMachine + libUSB</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Almost all software developers sooner or later come to the stage when it is necessary to apply technology to distribute tasks to individual threads. N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qt Framework: streams, hierarchical finite state machine, work with USB devices = QThread + QStateMachine + libUSB</h1><div class="post__text post__text-html js-mediator-article">  Almost all software developers sooner or later come to the stage when it is necessary to apply technology to distribute tasks to individual threads.  Now it is difficult to imagine development without the use of one or another framework. <br>  Many of them contain the necessary tools to create multi-threaded applications.  Not an exception and <a href="http://www.qt.io/qt-framework/">Qt Framework</a> . <br><br>  Let's talk about Qt methods of multithreaded development in more detail. <br><br>  The Qt Framework software community is huge.  People eagerly share the skills and techniques of creating multi-threaded applications.  There are many wonderful books and articles on elegant and not very tackling the task of working with multiple threads. <br>  It would seem that everything has already been decided.  What else can I add? <br>  I will try to describe the work flow on the basis of the functioning of the finite state machine.  I admit, did not find materials with a similar solution on the network. <br>  If the article helps you with the idea that, in my opinion, is much more valuable than the written code, I will be very happy. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Special thanks to A. N. Borovsky for the book <a href="http://www.ozon.ru/context/detail/id/7449666/">"Qt4.7 +. Practical C ++ programming"</a> . <br>  I recommend for mandatory reading! <br><a name="habracut"></a><br><h3>  I feel so comfortable. </h3><br><div class="spoiler">  <b class="spoiler_title">In my codes, I define several macros that may seem redundant:</b> <div class="spoiler_text"><pre><code class="hljs lisp">#define IS_ZERRO(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) (<span class="hljs-number"><span class="hljs-number">0</span></span> == (<span class="hljs-name"><span class="hljs-name">VALUE</span></span>)) #define MORE_ZERRO(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; (<span class="hljs-name"><span class="hljs-name">VALUE</span></span>)) #define LESS_ZERRO(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) (<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; (<span class="hljs-name"><span class="hljs-name">VALUE</span></span>)) #define NOT_ZERRO(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) (!IS_ZERRO(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>)) #define IS_NULL(<span class="hljs-name"><span class="hljs-name">PTR</span></span>) (<span class="hljs-name"><span class="hljs-name">Q_NULLPTR</span></span> == (<span class="hljs-name"><span class="hljs-name">PTR</span></span>)) #define NOT_NULL(<span class="hljs-name"><span class="hljs-name">PTR</span></span>) (!IS_NULL(<span class="hljs-name"><span class="hljs-name">PTR</span></span>)) #define BETWEEN(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>,LOW,HIGH) ( ((<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) &gt; (<span class="hljs-name"><span class="hljs-name">LOW</span></span>)) <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> ((<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) &lt; (<span class="hljs-name"><span class="hljs-name">HIGH</span></span>)) ) #define BETWEEN_L(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>,LOW,HIGH) (((<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) &gt;= (<span class="hljs-name"><span class="hljs-name">LOW</span></span>)) <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> ((<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) &lt; (<span class="hljs-name"><span class="hljs-name">HIGH</span></span>))) #define BETWEEN_H(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>,LOW,HIGH) (((<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) &gt; (<span class="hljs-name"><span class="hljs-name">LOW</span></span>)) <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> ((<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) &lt;= (<span class="hljs-name"><span class="hljs-name">HIGH</span></span>))) #define BETWEEN_ALL(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>,LOW,HIGH) (((<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) &gt;= (<span class="hljs-name"><span class="hljs-name">LOW</span></span>)) <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> ((<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) &lt;= (<span class="hljs-name"><span class="hljs-name">HIGH</span></span>))) #define EQUAL(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>,EXPR) ((<span class="hljs-name"><span class="hljs-name">VALUE</span></span>) == (<span class="hljs-name"><span class="hljs-name">EXPR</span></span>)) #define NOT_EQUAL(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>,EXPR) (!EQUAL(<span class="hljs-name"><span class="hljs-name">VALUE</span></span>,EXPR))</code> </pre> <br></div></div><br><br>  I will not argue about the feasibility of their use.  It seems to me that mnemonics do not overload the code and contain, say, a ‚Äúgood tone‚Äù for checking pointers. <br>  It's just that it's convenient for me. <br><br>  Let's start. <br><br><h2>  Step 1. A bit about the threads "on the fingers." </h2><br>  If you put the stress on the last word correctly, continue.  :) <br>  As is known, the Qt thread model consists of two parts: <br><ul><li>  Main application flow; </li><li>  Auxiliary flows. </li></ul><br>  <a href="http://doc.qt.io/qt-5/qthread.html">When</a> implementing objects inherited from the <a href="http://doc.qt.io/qt-5/qthread.html">QThread</a> class ( <a href="http://doc.crossplatform.ru/qt/4.7.x/html-qt/qthread.html">Russian</a> ), we are dealing with the creation of the next auxiliary threads. <br>  Each <a href="http://doc.qt.io/qt-5/qthread.html">QThread</a> object contains its own event loop.  The loop is started by the protected <i>QThread :: exec ()</i> method.  A thread is <i>launched</i> for execution by calling the <i>QThread :: start ()</i> method.  The start method launches the protected <i>QThread :: run ()</i> method.  In turn, the <i>run ()</i> method runs <i>exec ()</i> and, accordingly, its own event handler for an object of the QThread class. <br>  The <i>run ()</i> method runs in the address space of a separate (let's call it, worker) thread.  The address space of the workflow is different from the address space of an object of the QThread class. <br><br>  How is the workflow implemented? <br>  For this, for example, in UNIX-like systems, the <i>pthread</i> library is <i>used</i> .  In the network a lot of material about it. <br>  The <i>QThread :: start ()</i> method creates a separate workflow by calling <i>pthread_create ()</i> , passing the <i>QThreadPrivate :: start ()</i> method as a thread function, and the pointer to the object itself as the last parameter <i>arg</i> . <br><br>  Interesting code inside the method <pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">QThreadPrivate</span></span>::start () { . . . <span class="hljs-type"><span class="hljs-type">QThreadData</span></span> *<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QThreadData</span></span></span><span class="hljs-class">::get2(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thr</span></span></span><span class="hljs-class">); . . . }</span></span></code> </pre><br><br>  Having traced the chain of connections, one can understand that all objects moved by the <i>QObject :: moveToThread method (QObject *)</i> will be placed in this data pool of the <i>QThreadData</i> class of the <i>workflow</i> address space. <br>  Quite a lot of discussions in the Qt developer community are conducted on what is better: move objects with <i>QObject :: moveToThread ()</i> or overload the protected <i>QThread :: run ()</i> method? <br>  <i>Having</i> redefined the <i>QThread :: run ()</i> method, know that all objects created in it will be inaccessible from outside, since  created on the <i>run ()</i> method stack (although this can be bypassed). <br>  The objects being moved are stored in the data pool and pull all their <i><a href="http://doc.qt.io/qt-5/qmetaobject.html">QMetaObject</a> :: Connection</i> for themselves. <br><br>  Remember this and everything will be fine. <br><br>  A simplified diagram of the foregoing can be represented by the picture: <br><br><img src="https://habrastorage.org/files/828/b0f/222/828b0f2220b34de88e8e30acf3e9a095.png"><br><br><h3>  It is a little about expediency of use QThread. </h3><br>  In addition to <i>QThread</i> , Qt provides the developer with a set of higher-level classes. <br>  They are located in the <a href="http://doc.qt.io/qt-5/qtconcurrent-index.html">QtConcurrent</a> namespace.  Classes of this interface take full control of the flow, optimize performance and distribute the load between threads.  You can write down methods in them and not worry about correct completion and cleaning of memory.  But there are costs.  For example, the <a href="http://doc.qt.io/qt-5/qrunnable.html">QRunnable</a> class <a href="http://doc.qt.io/qt-5/qrunnable.html">is</a> not a descendant of <a href="http://doc.qt.io/qt-5/qobject.html">QObject</a> , which means it cannot send or receive signals and cannot process events. <br>  I think they are well suited for simple methods, for example, any mathematical calculations, where there exists a predefined set of input data and a strict processing algorithm. <br>  Often it is necessary to create constant waiting cycles for something or to constantly scan and check various conditions.  The developer places them in separate threads so that the main event loop or application GUI does not ‚Äúslow down‚Äù.  For example, using <a href="http://libusb.sourceforge.net/api-1.0/api.html">libUSB</a> library <a href="http://libusb.sourceforge.net/api-1.0/api.html">functions</a> , you can constantly update the list of connected devices.  In this case, there may be several possible exit points from the stream as a reaction to external events, signals, or the occurrence of exceptional situations.  The main thing is that we must manage the algorithm that is enclosed in the workflow cycle.  For this, I think, the use of an object of the class derived from the <i>QThread</i> class <i>is</i> most justified. <br><br><h4>  Comment. </h4><br>  Quite often in the network there is a certain ‚Äútrick with ears‚Äù in moving the stream object to the work flow, namely <br><pre> <code class="hljs kotlin">MyThread:: MyThread () : QThread() { moveToThread(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Do not do this!  At least because the basic concept of the QThread class as a thread management add-in is violated.  This is similar to the fact that you went fishing, abandoned the bait, and the bait itself was also thrown into the river ... <br><br>  When creating flow objects, you probably noticed that the value of a pointer to an object moved by the <i>QObject :: moveToThread ()</i> method to the address space of the workflow correctly <i>handles an</i> out-of-flow reference.  We can safely use the object according to, so to speak, the moved pointer for <i>QMetaObject :: Connection</i> links. <br>  It would seem that they were moved to another address space, but it turns out that there was no movement: the address of the object did not change according to the pointer value. <br>  Consider one of the differences in process and flow.  The OS allocates its own memory pool to each process, but each new thread uses shared memory with the parent thread and the process that created it.  This means that everything is normal - the address of the object being moved from stream to stream does not change relative to the main process. <br>  It can be said that a pointer to an object relative to the address spaces of threads is somewhat akin to a ‚Äúsmart‚Äù pointer of type <a href="http://www.cplusplus.com/reference/memory/auto_ptr/">std :: auto_ptr</a> , which assigns the object to the owner. <br><div class="spoiler">  <b class="spoiler_title">I will cite a lyrical analogy.</b> <div class="spoiler_text"><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   (  main())       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . City/</span></span>*<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:QObject*/*</span></span> city = City(); city-&gt;setObjectName(‚Äú‚Äù); std::out &lt;&lt; qPrintable(city) &lt;&lt; std::endl; . . . /<span class="hljs-regexp"><span class="hljs-regexp">/       ,      , QThread* Girey = new QThread(); city-&gt;setParent(Q_NULLPTR); city-&gt;moveToThread(Girey); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . std::out &lt;&lt; qPrintable(city) &lt;&lt; std::endl; . . . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     city-&gt;setParent(Q_NULLPTR); city-&gt;moveToThread(RussionImperia); . . . city-&gt;setParent(Q_NULLPTR); city-&gt;moveToThread(USSR); . . . city-&gt;setObjectName(‚Äú‚Äù); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ..</span></span></code> </pre><br>  The geographical coordinates of the city ( <i>city</i> ) relative to the Earth ( <i>main ()</i> ) do not change, but the infrastructure ( <i>* city</i> ) is variable. <br></div></div><br>  For the time being, we <i>‚Äôll</i> suspend a cursory description of the <i>QThread</i> class and proceed to the description of a useful trick to correctly terminate the thread when the latter has reached any exit point, including a reaction to possible exceptional situations. <br><br><h2>  Step 2. Correct completion of the stream. </h2><br>  As you know, streams can exchange information, use common data, analyze the state of this data and send each other various notifications. <br>  One stream may indirectly or directly ask another to temporarily suspend work or, in general, to cease to exist. <br>  I will not describe all possible methods and options for properly separating access to data: there is more than enough material on this subject.  Simply, imagine a situation that we do not know in advance when the exit from the stream will occur, and by what condition this will happen.  Of course, the exit points from the stream must be activated upon completion of a certain final section of the stream operation. <br>  A situation may arise when the algorithm itself will cause an exception.  For example, a pointer to a pointer with a nonexistent value.  Often this leads to a complete hang of the stream.  Even the <i>QThread :: terminate ()</i> method cannot remove it from the execution pool.  So there are zombie streams.  In the case of processes, the OS itself will try to destroy the process, but this number will not work with threads, because  the main thread is responsible for their lives, not the core of the OS. <br>  In a word, we will assume that we do not know in advance the total number and places of exit points from the stream and the termination code. <br>  Some helper is needed here - the ‚Äúhelper‚Äù wrapping around the stream object.  Such tricks are often found in Qt. <br><br>  I will give an example of the code and briefly explain: <br>  The stream class <i>FWThread</i> is <i>defined</i> : <br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FWThread</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public QThread { }</span></span></span></span></code> </pre><br>  Assistant class defined <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWThread_helper</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QPointer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWThread</span></span></span><span class="hljs-class">&gt; m_ext_thread; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Public</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWThread_helper</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWThread</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aThread</span></span></span><span class="hljs-class">) : m_ext_thread(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aThread</span></span></span><span class="hljs-class">) { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_ASSERT</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NOT_NULL(m_ext_thread)</span></span></span><span class="hljs-class">); } ~</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWThread_helper</span></span></span><span class="hljs-class">() { if(!</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_ext_thread</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">isNull</span></span></span><span class="hljs-class">()) m_ext_thread-&gt;deleteLater(); } }</span></span></code> </pre><br>  Define a destructor of class <i>FWThread</i> <br><pre> <code class="hljs perl">FWThread::~FWThread() { quit (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">wait</span></span> (FW_THREAD_WAIT_TIMEOUT)) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,   ... terminate (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">wait</span></span>(FW_THREAD_WAIT_TIMEOUT)) <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(EXIT_FAILURE); } }</code> </pre><br>  QThread :: run () method overridden <br>  (Thanks <a href="https://habrahabr.ru/users/arteme/" class="user_link">ArtemE</a> for noticing the blot) <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FWThread::run() { m_helper = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FWThread_helper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   m_helper.clear (); }</span></span></code> </pre><br>  What happens, for example, when an exception occurs in the body of the <i>run ()</i> method?  Whatever happens, the <i>v_helper</i> pointer <i>will</i> always call its own destructor either by <i>m_helper.clear ()</i> , or by clearing the <i>run ()</i> method call stack when an exception occurs. <br>  The destructor will destroy the <i>FWThread</i> thread <i>object.</i>  Upon the completion of the latter, an attempt to exit the stream or your own certain algorithm for closing the stream will occur.  For example, all objects passed to the stream can be destroyed using the <i>QObject :: deleteLater ()</i> method. <br><br>  Pay attention to the line <br><pre> <code class="hljs lisp">Q_ASSERT(<span class="hljs-name"><span class="hljs-name">NOT_NULL</span></span>(<span class="hljs-name"><span class="hljs-name">m_ext_thread</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  in the body of the constructor of the class <i>FWThread_helper</i> .  The class was created specifically for a non-empty pointer to a stream.  This code informs the developer about a flow control error at the debugging stage. <br><br>  Try to identify <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FWThread::run() { FWThread_helper* v_helper = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FWThread_helper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); QException e; QT_TRY { e.raise(); } QT_CATCH(QException&amp; e) { qDebug() &lt;&lt; qPrintable(e.what ()); } m_helper.clear (); }</code> </pre><br>  I hope everything is clear here. <br><br><h2>  Step 3. Apply hierarchical finite state machine. </h2><br>  One of the most useful, in my opinion, implementations in the Qt Framework is represented by a section of a hierarchical finite state machine (hereinafter referred to as the KA).  KA is implemented in the boost library, but it will be a question of Qt. <br><br>  You can familiarize yourself with the Qt KA theory on the Qt documentation page or the <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/statemachine-api.html">crossplatform.ru</a> website <br>  <b>So how and, most importantly, why do we connect the spacecraft and the flow?</b> <br>  Looking ahead a little bit, here‚Äôs an example of the <i>QThread :: run ()</i> method overload code that I use: <br><pre> <code class="hljs ruby">void FWThread::run() { FWThread_helper* v_helper = new FWThread_helper(this); m_helper = v_helper; InternalRun (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsValid ()) { BeforeMachineStart (); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     @sa Machine (). Machine ()-&gt;start (); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  a   . =&gt;   . BaseClass::exec (); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!IsError ()) SetError (); exit (FW_ERR_THREAD_INCOMPLETE); } m_helper.clear (); }</code> </pre><br>  In all classes derived from the <i>FWThread</i> class <i>(:: QThread)</i> , I override only the single self-added method <i>FWThread :: BeforeMachineStart ()</i> .  No method of working directly with the stream is overloaded anymore! <br>  Each BeforeMachineStart () method of the FWThread descendant class adds <i>QA</i> states and transitions between them.  Thus, a change in the algorithm of the <i>QThread :: run ()</i> method <i>occurs</i> only in one class implementation file, and the thread itself can serve different behaviors of the finite state machine.  Moreover, when stopping the flow, you can prohibit <i>QObject :: deleteLater ()</i> for an object of the <i>FWThread</i> class, dynamically change the behavior of the spacecraft and start the same instance of the flow using the <i>FWThread :: start ()</i> method again with a completely different behavior model of the spacecraft! <br><br>  I'll tell you in more detail about the model of a finite state machine used as a mechanism for controlling the workflow. <br><br>  In the Qt implementation, the state machine is represented by the <a href="http://doc.qt.io/qt-5/qstatemachine.html">QStateMachine</a> class ( <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/qstatemachine.html">rus.</a> ), The states are described by the <a href="http://doc.qt.io/qt-5/qstate.html">QState</a> ( <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/qstate.html">rus.</a> ), <a href="http://doc.qt.io/qt-5/qhistorystate.html">QHistoryState</a> ( <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/qhistorystate.html">rus.</a> ), <a href="http://doc.qt.io/qt-5/qfinalstate.html">QFinalState</a> ( <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/qfinalstate.html">rus.</a> ) <a href="http://doc.qt.io/qt-5/qfinalstate.html">Classes</a> .  Transitions are represented by the <a href="http://doc.qt.io/qt-5/qeventtransition.html">QEventTransition</a> ( <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/qeventtransition.html">rus.</a> ) And <a href="http://doc.qt.io/qt-5/qsignaltransition.html">QSignalTransition</a> ( <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/qsignaltransition.html">rus.</a> ) <a href="http://doc.qt.io/qt-5/qsignaltransition.html">Classes</a> . <br>  All listed classes are based on a set of abstract classes.  So QState extends the abstract class <a href="http://doc.qt.io/qt-5/qabstractstate.html">QAbstractState</a> ( <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/qabstractstate.html">rus.</a> ).  The <i>QStateMachine</i> SC <i>class</i> is a derivative of QState.  Transition classes originate from the <a href="http://doc.qt.io/qt-5/qabstracttransition.html">QAbstractTransition</a> class ( <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/qabstracttransition.html">rus.</a> ). <br>  The Qt documentation contains a very detailed description of the spacecraft, classes of states and transitions, a sufficient number of simple examples and tricks in the design and implementation of spacecraft. <br>  There is <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/statemachine-api.html">an excellent and complete translation of the Qt QA description in Russian.</a> <br>  Read it.  It is, simply, interesting. <br><br>  From the examples and recommendations of the Qt documentation for the work on the basis of the spacecraft, I chose a scheme similar to the figure of the <a href="http://doc.crossplatform.ru/qt/4.8.x/html-qt/statemachine-api.html">example documentation</a> . <br><img src="https://habrastorage.org/files/9cb/87f/068/9cb87f06862e4c2ebf2672fec76e86ae.png"><br><br>  <i>By overriding the</i> classes of the automaton, states, and transitions, I for a while refused to use the <i>QSignalTransition</i> class.  Any signal can be duplicated as sending an event to a stream event handler. <br>  Imagine a picture when you have an event receiver object hidden as an attribute of a certain class.  The object of the latter is also an attribute of a class, etc.  In order to broadcast a signal, the developer will not have to forget about reassigning <i>QObject :: connect ()</i> connections to the depth of the object until the signal reaches the target.  And vice versa, to relay the signals of deeply nested objects as class attributes to the upper level. <br>  It is much easier to define your own message format based on the <a href="http://doc.qt.io/qt-5/qevent.html">QEvent</a> class with some additional attributes and use the <i>QStateMachine :: postEvent ()</i> or <i>QCoreApplication :: postEvent () method</i> . <br><br>  Additionally, I use my own class model based on the <i>QObject</i> class. <br>  So, my base class sounds like <i>class FWIterm: public QObject</i> . <br>  By declaring new classes, I inherit them only from the <i>FWItem</i> class.  This allows you to enter some flags and signs that are common to all.  In addition, the heirs of <i>FWItem</i> can supplement and extend the sets of flags, sets, and other attributes of the types of the <i>FWItem</i> class. <br><div class="spoiler">  <b class="spoiler_title">The most important thing is that the base class FWItem contains methods for assigning, checking and references to the state machine:</b> <div class="spoiler_text"><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FW_LIBRARY</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FWItem</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public QObject { private: QPointer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWStateMachine</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_machine</span></span></span><span class="hljs-class">; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protected</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">/** * @brief  MachineExists       *   @sa FWStateMachine. * @return  : * @value TRUE     ; * @value FALSE    . */ virtual bool MachineExists </span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !m_machine.isNull (); } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  Machine      *   ()  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">    . * *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QStateMachine. * *        ,  *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWItem,  ,     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine. */</span></span> virtual FWStateMachine* Machine () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  SetMachine     . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aMachine    . */</span></span> void SetMachine (FWStateMachine* aMachine); }</code> </pre><br></div></div><br>  Thus, if there is a spacecraft for the <i>FWItem object</i> , you can control the sending of messages for states and transitions directly: <br><pre> <code class="hljs lisp">if(<span class="hljs-name"><span class="hljs-name">item-&gt;</span></span> MachineExists()) Machine()-&gt;PostEvent(<span class="hljs-name"><span class="hljs-name">FWEvent</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:OEI_Open</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  Where <i>FWEvent :: OEI_Open is</i> a certain, defined message identifier of the <i>FWEvent</i> class. <br><br>  The state and transition diagram for the automaton for controlling the operation of the flow takes the form <br><img src="https://habrastorage.org/files/763/929/c04/763929c048d44a349e782a025e2248bc.png"><br>  where <b>T</b> <sub>(FWEvent :: Event :: Type signal)</sub> is a transition from one state to another. <br><br>  For ease of understanding state <i>transitions</i> , a set of virtual methods <i>FWStateMachine :: AddBranch (&lt;event or event constructor&gt; &lt;initial state&gt; &lt;assignment state&gt; == Q_NULLPTR) has been added to the FWStateMachine class;</i> <br>  For many solutions of problems based on the Qt spacecraft of this scheme and the number of states is quite sufficient.  Therefore, I implemented it in the implementation body of the <i>FWMachineState</i> class, creating a protected virtual method <i>Initialisation ()</i> . <br><div class="spoiler">  <b class="spoiler_title">Consider it:</b> <div class="spoiler_text"><br><pre> <code class="hljs ruby">void FWStateMachine::Initialisation() { bool v_active = IsActive (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(v_active) stop (); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ @name     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!StateGroupExists ()) m_state_group.reset (new FWState(this)); FWState* sIdle = new FWState(StateGroup ()); StateGroup ()-&gt;setInitialState (sIdle); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ @} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @name       /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!StateHistoryExists ()) /<span class="hljs-regexp"><span class="hljs-regexp">/    ,   ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   - @sa m_state_group (@sa QHistoryState::DeepHistory), /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,    . m_state_history.reset (new QHistoryState(QHistoryState::DeepHistory,StateGroup ())); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @} /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @name  z    /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!StateFinalExists ()) m_state_final.reset (new QFinalState(this)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ @} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @name     /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!StateErrorExists ()) m_state_error.reset (new FWState(this)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ @} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @name       /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @{ AddBranch(FWEvent::ET_INTERNAL,FWInternalEvent::OEI_Stop, StateGroup (), StateFinal ()); AddBranch(FWEvent::ET_INTERNAL,FWInternalEvent::OEI_Error, StateGroup (), StateError ()); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ @} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @name       /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @{ FWState* sPause = new FWState(this); AddBranch(FWEvent::ET_INTERNAL,FWInternalEvent::OEI_Pause, StateGroup (), sPause); AddBranch(FWEvent::ET_INTERNAL,FWInternalEvent::OEI_Resume, sPause, StateHistory ()); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ @} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @name      /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @{ AddBranch(StateError (), StateFinal ()); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ @} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @name       /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @{ connect( sPause,&amp;FWState:: entered, this, &amp;FWStateMachine:: slot_OnPaused, Qt::ConnectionType(Qt::DirectConnection <span class="hljs-params"><span class="hljs-params">| Qt::UniqueConnection)); connect( sPause,&amp;FWState:: exited, this, &amp;FWStateMachine:: slot_OnResume, Qt::ConnectionType(Qt::DirectConnection |</span></span> Qt::UniqueConnection)); connect( StateFinal (),&amp;QFinalState:: entered, this, &amp;FWStateMachine:: slot_OnStop, Qt::ConnectionType(Qt::DirectConnection <span class="hljs-params"><span class="hljs-params">| Qt::UniqueConnection)); connect( StateError (),&amp;FWErrorState:: entered, this, &amp;FWStateMachine:: slot_OnError, Qt::ConnectionType(Qt::DirectConnection |</span></span> Qt::UniqueConnection)); connect( StateHistory(),&amp;QHistoryState::defaultStateChanged, this, &amp;FWStateMachine::slot_OnDefaultHistoryChanged, Qt::ConnectionType(Qt::DirectConnection <span class="hljs-params"><span class="hljs-params">| Qt::UniqueConnection)); /// @} </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params">(NOT_EQUAL(initialState (),StateGroup ())) setInitialState (StateGroup ()); StateGroup ()-&gt; setObjectName("State GROUP"); StateHistory ()-&gt; setObjectName("State HISTORY"); StateError()-&gt; setObjectName("State ERROR"); StateFinal()-&gt; setObjectName("State FINAL"); sPause-&gt; setObjectName("State PAUSE"); sIdle-&gt; setObjectName("State IDLE"); </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params">(v_active) start (); }</span></span></code> </pre><br></div></div><br><br>  In the heirs of the class <i>FWStateMachine</i> <div class="spoiler">  <b class="spoiler_title">slots can be overloaded</b> <div class="spoiler_text"><br><pre> <code class="hljs cs"> . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Q_SLOTS: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slot_OnLoging</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { qDebug() &lt;&lt; qPrintable(Q_FUNC_INFO); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slot_OnError</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { qDebug() &lt;&lt; qPrintable(Q_FUNC_INFO); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slot_OnPaused</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { qDebug() &lt;&lt; qPrintable(Q_FUNC_INFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(thread ()) thread ()-&gt;yieldCurrentThread (); <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sign_Paused</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slot_OnResume</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { qDebug() &lt;&lt; qPrintable(Q_FUNC_INFO); <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sign_Resumed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slot_OnStop</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { qDebug() &lt;&lt; qPrintable(Q_FUNC_INFO); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slot_OnDefaultHistoryChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(StateHistoryExists ()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(NOT_NULL(StateHistory()-&gt;defaultState())) qDebug() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"-H-"</span></span> &lt;&lt; StateHistory()-&gt;defaultState()-&gt;objectName(); } };</code> </pre><br></div></div><br><br>  Let's <i>go</i> back to the <i>FWThread</i> class and look at the <i>Reconnect ()</i> method called in the body of the <i>run ()</i> method <br><div class="spoiler">  <b class="spoiler_title">FWThread :: Reconnect ()</b> <div class="spoiler_text"><br><pre> <code class="hljs ruby">void FWThread::Reconnect() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsAutoDeleted ()) /<span class="hljs-regexp"><span class="hljs-regexp">/       connect( this, &amp;QThread::finished, this, &amp;QThread::deleteLater, Qt::ConnectionType(Qt::QueuedConnection | Qt::UniqueConnection)); if(MachineExists ()) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     connect( Machine (),&amp;FWStateMachine:: finished, this, &amp;QThread:: quit, Qt::ConnectionType(Qt::AutoConnection | Qt::UniqueConnection)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . connect( this, &amp;QThread:: finished, Machine (),&amp;FWStateMachine:: stop, Qt::ConnectionType(Qt::AutoConnection | Qt::UniqueConnection)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @name       @sa FWThread /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> @{ connect (Machine (),&amp;FWStateMachine:: started, this, &amp;FWThread:: sign_MachineStarted, Qt::ConnectionType(Qt::DirectConnection <span class="hljs-params"><span class="hljs-params">| Qt::UniqueConnection)); connect (Machine (),&amp;FWStateMachine:: stopped, this, &amp;FWThread:: sign_MachineStopped, Qt::ConnectionType(Qt::DirectConnection |</span></span> Qt::UniqueConnection)); connect (Machine (),&amp;FWStateMachine:: sign_Paused, this, &amp;FWThread:: sign_MachinePaused, Qt::ConnectionType(Qt::DirectConnection <span class="hljs-params"><span class="hljs-params">| Qt::UniqueConnection)); connect (Machine (),&amp;FWStateMachine:: sign_Resumed, this, &amp;FWThread:: sign_MachineResumed, Qt::ConnectionType(Qt::DirectConnection |</span></span> Qt::UniqueConnection)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ @} /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    connect (Machine (),&amp;FWStateMachine:: started, this, &amp;FWThread:: slot_AfterMachineStart, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); } }</span></span></code> </pre><br></div></div><br>        .     . <br><br>  :   - <i>FWThread_helper</i>   <i>FWThread</i>     .   ,   <anchor>  </anchor>  . <br><div class="spoiler"> <b class="spoiler_title">FWThread.h</b> <div class="spoiler_text"><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> \language Russian /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-comment"><span class="hljs-comment">#ifndef FW_THREAD_H #define FW_THREAD_H #include &lt;FWTypes&gt; FW_BEGIN_NAMESPACE //------------------------------------------------------------------------------ /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">   FW_THREAD_WAIT_TIMEOUT   *     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread::wait. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QThread */ extern unsigned long FW_THREAD_WAIT_TIMEOUT; //------------------------------------------------------------------------------ class FWThread_helper; class FWStateMachine; //------------------------------------------------------------------------------ class #ifdef FW_LIBRARY FW_SHARED_EXPORT #else Q_DECL_EXPORT #endif FWThread : public QThread { friend class FWThread_helper; Q_OBJECT Q_CLASSINFO("brief", "Framework Thread Class with QStateMashine") Q_CLASSINFO("created", "03-JUN-2015") Q_CLASSINFO("modified", "23-JUN-2015") // Q_CLASSINFO("project", "Common Qt-based Framework") // Q_CLASSINFO("info_ru", "http://doc.crossplatform.ru/qt/4.7.x/qthread.html#") // Q_DISABLE_COPY(FWThread) /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment">   . /// @{ ///        typedef QThread BaseClass; /// @} public: enum FWThreadFlag { THF_Empty = 0x00, THF_Ready = 0x01, THF_Working = 0x02, THF_Paused = 0x04, THF_AutoDelete = 0x08, THF_Error = 0x80, }; Q_DECLARE_FLAGS(FWThreadFlags, FWThreadFlag) private: QPointer&lt;FWThread_helper&gt; m_helper; /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_flags     . /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> FWThreadFlags. /// QAtomicInt m_flags; /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment">  ()      /// @{ void SetEmpty () { m_flags.fetchAndStoreOrdered (THF_Empty); } void SetReady () { FWThreadFlags v_flags = Flags () | THF_Ready; m_flags.fetchAndStoreOrdered (v_flags); } void UnsetReady () { FWThreadFlags v_flags = Flags () &amp; (~THF_Ready); m_flags.fetchAndStoreOrdered (v_flags); } void SetWorking () { FWThreadFlags v_flags = Flags () | THF_Working; m_flags.fetchAndStoreOrdered (v_flags); } void SetStop () { FWThreadFlags v_flags = Flags () &amp; (~THF_Working); m_flags.fetchAndStoreOrdered (v_flags); } void SetPause () { FWThreadFlags v_flags = Flags () | THF_Paused; m_flags.fetchAndStoreOrdered (v_flags); } void SetResume () { FWThreadFlags v_flags = Flags () &amp; (~THF_Paused); m_flags.fetchAndStoreOrdered (v_flags); } void SetAutoDelete () { FWThreadFlags v_flags = Flags () | THF_AutoDelete; m_flags.fetchAndStoreOrdered (v_flags); Reconnect(); } void UnsetAutoDelete () { FWThreadFlags v_flags = Flags () &amp; (~THF_AutoDelete); m_flags.fetchAndStoreOrdered (v_flags); } void SetError () { FWThreadFlags v_flags = Flags () | THF_Error; m_flags.fetchAndStoreOrdered (v_flags); } void UnsetError () { FWThreadFlags v_flags = Flags () &amp; (~THF_Error); m_flags.fetchAndStoreOrdered (v_flags); } /// @} /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  InternalRun     *         . */ void InternalRun(); public: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@static</span></span></span><span class="hljs-comment"> * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  SetThreaWaitTimeout    *     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread::wait. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aValue       </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread::wait. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QThread */ static void SetThreaWaitTimeout( unsigned long aValue) { if(NOT_EQUAL(FW_THREAD_WAIT_TIMEOUT,aValue)) FW_THREAD_WAIT_TIMEOUT = aValue; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aAutoDelete       *   . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aParent   - . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> aParent  -   , *   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> aAutoDelete ,     *      . */ explicit FWThread(const bool aAutoDelete = true, QObject* aParent = Q_NULLPTR); ~FWThread(); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  AsBaseClass     () *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread    . */ BaseClass* AsBaseClass () { return qobject_cast&lt;BaseClass*&gt;(this); } /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  setParent    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QObject::setParent. /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aParent    "" ///          ///         </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> aAutoDelete ///   TRUE. /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> FWThread::FWThread /// virtual void setParent(QObject* aParent); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  Flags      FWThread. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread::FWThreadFlags */ inline FWThreadFlags Flags () const { return FWThreadFlags(m_flags.loadAcquire ()); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  Machine    ,   * . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">      . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment">        * ,        * . */ FWStateMachine* Machine (); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  MachineExists     . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE    ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE   ,     . */ inline bool MachineExists () { return NOT_NULL(Machine ()); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  IsValid       *        . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE       ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE       . */ virtual bool IsValid (); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  IsReady       . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE       ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE       . */ inline bool IsReady () const { return Flags ().testFlag (THF_Ready); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  IsAutoDeleted     *         . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE ,       ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE ,        . * * , * @&lt;code&gt; * void foo () * { * FWTread* v_thread = new FWTread(true); * bool v_with_timeout = &lt;&gt;; * ... * thread.quit (); * * if(v_with_timeout) * { * if(!thread.wait (FW_THREAD_WAIT_TIMEOUT) ) * { * // , * // terminate (); * // wait(1000);, * * //  terminate()  ,     * //   quit() ;) * ... * } * } * else * v_thread-&gt;Machine()-&gt;stop (); * //    FWTread::quit, FWTread::finished * // FWTread::deleteLater,   v_thread,  * //   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread_helper  FWTread::m_helper. * } * @&lt;/code&gt; */ inline bool IsAutoDeleted () const { return Flags ().testFlag (THF_AutoDelete); } inline bool IsError () const { return Flags ().testFlag (THF_Error); } inline bool IsWorking () const { return Flags ().testFlag (THF_Working); } inline bool IsPaused () const { return Flags ().testFlag (THF_Paused); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  AttachObject      *  . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aObject   . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE ,    ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE ,     . */ bool AttachObject (QObject* aObject); /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread /// @{ /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread::terminate. *       ,   . */ void terminate(); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread::quit. *       ,   . */ void quit(); /// @} protected: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  Reconnect     *   . * *             *       .   *      . */ void Reconnect (); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  run    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread::run. *     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_helper    *   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> InternalRun * *        </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> exec()   *       . *     ,   ,    *     . *         </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> exec(). * *           * . *     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> BeforeMachineStart. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> BeforeMachineStart   *     . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment">        *        </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> AttachObject. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QThreadPrivate::start, QThread::start, QThread::exec, QThread::exit. */ void run() Q_DECL_OVERRIDE; public: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  BeforeMachineStart     *          . * * ,         *  . *    , ,     *          * . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">        *        .   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine *         * .         *  Machine ()-&gt;StateGroup ().      *   ,      * .         *  Machine ()-&gt;StateIdle (). * *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> BeforeMachineStart   FWUsbScanner *  / USB-: * @&lt;code&gt; * * @&lt;code&gt; * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> FWStateMachine, FWState * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QStateMachine, QState, QAbstractTransition */ virtual void BeforeMachineStart () {} /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  BeforeThreadDone     *       . * *      ,     *     ,      . * *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> BeforeThreadDone()     . * *        . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">  :       *  ,       *   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread! * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">  :       *  ,       *   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread! * *          *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread::run. */ virtual void BeforeThreadDone() {} /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  AfterThreadDone      *      . * *      ,     *     ,      . * *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> AfterThreadDone,    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> BeforeThreadDone(),  *    . * *        . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">  :    ,  ,  *  ,       *   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread! * *          *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread::run. */ virtual void AfterThreadDone() {} /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  ThreadDone  ,    *  . * *     ,      *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> IsBreak (,    ). *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> IsBreak ,  ,    . */ void ThreadDone (); Q_SIGNALS: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  sign_MachineChanged      *         (). * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aPointer      (). */ void sign_MachineChanged(const FWStateMachine* aPointer); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  sign_MachineStarted      . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QStateMachine::started; */ void sign_MachineStarted(); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  sign_MachineStopped     . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QStateMachine::finished; */ void sign_MachineStopped(); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  sign_MachinePaused     . */ void sign_MachinePaused (); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  sign_MachineResumed     . */ void sign_MachineResumed (); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  sign_ObjectAddress   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWItem::sign_ObjectAddress *  ,     . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aMyAddress    ( ) */ void sign_ObjectAddress (QObject* aMyAddress); public Q_SLOTS: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  slot_AfterMachineStart     *     . * * ,   ,      *     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread::exec.  ,  * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine::start        *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread::exec. * *      QThread::run    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine::start,    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QThread::exec. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">  :       *  ,       *   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread! */ virtual void slot_AfterMachineStart () { if(!IsError ()) SetWorking (); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  slot_Pause    *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine::slot_Pause. */ void slot_Pause (); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  slot_Resume    *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine::slot_Resume */ void slot_Resume (); }; //------------------------------------------------------------------------------ FW_END_NAMESPACE Q_DECLARE_OPERATORS_FOR_FLAGS(FW_NAMESPACE::FWThread::FWThreadFlags) #endif // FW_THREAD_H</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">FWThread.cpp</b> <div class="spoiler_text"><br><pre> <code class="hljs ruby"><span class="hljs-comment"><span class="hljs-comment">#include "FWThread.h" #include "FWStateMachine.h" #include &lt;FWItem&gt; #include &lt;QException&gt; FW_BEGIN_NAMESPACE //------------------------------------------------------------------------------ unsigned long FW_THREAD_WAIT_TIMEOUT = 7000; //------------------------------------------------------------------------------ /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWThread_helper     *      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FQThread. * *          *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FQThread.     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> Qthread::run : * @&lt;code&gt; * FWThread::run() * { * QScopedPointer&lt;FWThread_helper&gt; v_helper(new FWThread_helper(this)); * * } * @&lt;/code&gt; * * ""  v_helper    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread_helper  *          *   . * *   -  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_ext_thread. * *     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_fsm,   *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QStateMachine. * *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> ~FWThread_helper     *          * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread_helper::m_objects_container. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment">  ,   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread_helper::m_ext_thread *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread  .  - *     .     . */ class #ifdef FW_LIBRARY FW_SHARED_EXPORT #else Q_DECL_EXPORT #endif FWThread_helper : public QObject { // Q_OBJECT /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  TSharedObject      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QObject *   "" . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QSharedPointer, QObject */ typedef QSharedPointer&lt;QObject&gt; TSharedObject; /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  TObjectsList    ,  *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_ext_thread. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TObjectsList::at(&lt;i&gt;)   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> TSharedObject  *  ,     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_ext_thread. */ typedef QList&lt;TSharedObject&gt; TObjectsList; private: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_ext_thread     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread. */ QPointer&lt;FWThread&gt; m_ext_thread; /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_fsm    , *        * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_ext_thread. */ QPointer&lt;FWStateMachine&gt; m_fsm; /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_objects_container     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> TSharedObject   ,    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_ext_thread. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">    e     * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_ext_thread. */ TObjectsList m_objects_container; /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@static</span></span></span><span class="hljs-comment"> * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">   OnDeleteLater    *     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_objects_container,  *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_ext_thread. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aObject   . */ static void OnDeleteLater(QObject* aObject) { if(NOT_NULL(aObject)) aObject-&gt;deleteLater(); } public: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  ClearObjects   ,  *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_ext_thread. */ void ClearObjects () { Q_FOREACH(TSharedObject v_obj, m_objects_container) v_obj.reset(); m_objects_container.clear (); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  LocateObject     . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aObject    . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE     ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE       . */ bool LocateObject (const QObject* aObject) const { Q_FOREACH(TSharedObject v_obj, m_objects_container) if(EQUAL(v_obj.data (),aObject)) return true; return false; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWThread_helper  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread_helper. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aThread     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread_helper *   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> aThread    NULL, ..   *    . */ explicit FWThread_helper(FWThread* aThread) : QObject (Q_NULLPTR) , m_ext_thread(aThread) , m_fsm (new FWStateMachine) { Q_ASSERT(NOT_NULL(m_ext_thread)); m_objects_container.clear (); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread_helper. * *       </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread::run. *     ,  *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_ext_thread. * *      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread  - *     (,  ,   *   ) */ ~FWThread_helper() { if(NOT_NULL(m_ext_thread)) { m_ext_thread-&gt;BeforeThreadDone (); m_ext_thread-&gt;ThreadDone (); m_ext_thread-&gt;AfterThreadDone (); } ClearObjects (); m_fsm-&gt;deleteLater (); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  Machine      *  (). * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">     . * *        ,   *   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread. */ FWStateMachine* Machine () const { return m_fsm; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  InsertObject    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QObject   * . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aObject   . * *       </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWItem ,  *       . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">         *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWItem::SF_Active  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWItem::IsActive,  *     - . C </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWItem::slot_BreakProcess *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine::finished,    *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWItem::SF_Active    *     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread::quit *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread::terminate. */ void InsertObject (QObject* aObject) { if(NOT_NULL(aObject) &amp;&amp; (!LocateObject(aObject)) ) { aObject-&gt;setParent (Q_NULLPTR); aObject-&gt;moveToThread (m_ext_thread); if( aObject-&gt;inherits (FW_CLASS_STR(FWItem).toLatin1 ()) ) { //      QObject::connect (qobject_cast&lt;FWItem*&gt;(aObject), &amp;FWItem:: sign_ObjectAddress, m_ext_thread, &amp;FWThread:: sign_ObjectAddress, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); } m_objects_container.append (TSharedObject(aObject,OnDeleteLater)); } } }; //------------------------------------------------------------------------------ FWThread::FWThread(const bool aAutoDelete, QObject* aParent) : BaseClass (aParent) , m_helper (Q_NULLPTR) { SetEmpty (); if(aAutoDelete &amp;&amp; IS_NULL(aParent)) SetAutoDelete (); } //------------------------------------------------------------------------------ FWThread::~FWThread() { quit (); if(!wait (FW_THREAD_WAIT_TIMEOUT)) { // ,   ... terminate (); if(!wait(FW_THREAD_WAIT_TIMEOUT)) exit(EXIT_FAILURE); } } //------------------------------------------------------------------------------ void FWThread::setParent(QObject* aParent) { BaseClass::setParent (aParent); bool is_autodelete = bool(Flags () | THF_AutoDelete); if(IS_NULL(aParent) &amp;&amp; (!is_autodelete)) SetAutoDelete (); else if(NOT_NULL(aParent) &amp;&amp; (is_autodelete)) UnsetAutoDelete (); if(!IsAutoDeleted ()) disconnect( this, &amp;QThread::finished, this, &amp;QThread::deleteLater); } //------------------------------------------------------------------------------ FWStateMachine* FWThread::Machine() { return m_helper.isNull () ? Q_NULLPTR : m_helper-&gt;Machine (); } //------------------------------------------------------------------------------ bool FWThread::IsValid() { return (!IsError()) &amp;&amp; (MachineExists () ? Machine ()-&gt;IsValid () : false); } //------------------------------------------------------------------------------ bool FWThread::AttachObject(QObject* aObject) { bool v_retval = !m_helper.isNull (); if(v_retval) m_helper-&gt;InsertObject (aObject); return v_retval; } //------------------------------------------------------------------------------ void FWThread::terminate() { ThreadDone (); BaseClass::terminate (); } //------------------------------------------------------------------------------ void FWThread::quit() { ThreadDone (); BaseClass::quit (); } //------------------------------------------------------------------------------ void FWThread::Reconnect() { if(IsAutoDeleted ()) //       connect( this, &amp;QThread::finished, this, &amp;QThread::deleteLater, Qt::ConnectionType(Qt::QueuedConnection | Qt::UniqueConnection)); if(MachineExists ()) { //         //     connect( Machine (),&amp;FWStateMachine:: finished, this, &amp;QThread:: quit, Qt::ConnectionType(Qt::AutoConnection | Qt::UniqueConnection)); //         //  . connect( this, &amp;QThread:: finished, Machine (),&amp;FWStateMachine:: stop, Qt::ConnectionType(Qt::AutoConnection | Qt::UniqueConnection)); /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment">       </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWThread /// @{ connect (Machine (),&amp;FWStateMachine:: started, this, &amp;FWThread:: sign_MachineStarted, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); connect (Machine (),&amp;FWStateMachine:: stopped, this, &amp;FWThread:: sign_MachineStopped, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); connect (Machine (),&amp;FWStateMachine:: sign_Paused, this, &amp;FWThread:: sign_MachinePaused, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); connect (Machine (),&amp;FWStateMachine:: sign_Resumed, this, &amp;FWThread:: sign_MachineResumed, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); /// @} //         //  r  connect (Machine (),&amp;FWStateMachine:: started, this, &amp;FWThread:: slot_AfterMachineStart, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); } } //------------------------------------------------------------------------------ void FWThread::InternalRun() { QException _e; QT_TRY { if(IsValid ()) { ///         Reconnect (); SetReady (); emit sign_MachineChanged(Machine ()); } else _e.raise (); } QT_CATCH(QException &amp;e) { UnsetAutoDelete (); SetError (); qDebug() &lt;&lt; qPrintable(e.what ()); } } //------------------------------------------------------------------------------ void FWThread::run() { FWThread_helper* v_helper = new FWThread_helper(this); m_helper = v_helper; InternalRun (); if(IsValid ()) { BeforeMachineStart (); ///     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> Machine (). Machine ()-&gt;start (); ///  a   . =&gt;   . BaseClass::exec (); } else { if(!IsError ()) SetError (); exit (FW_ERR_THREAD_INCOMPLETE); } m_helper.clear (); } //------------------------------------------------------------------------------ void FWThread::ThreadDone() { SetStop (); if(MachineExists ()) { if(Machine ()-&gt;IsActive ()) Machine ()-&gt;stop (); // QObject::disconnect (Machine ()); } } //------------------------------------------------------------------------------ void FWThread::slot_Pause() { if(MachineExists()) Machine ()-&gt;slot_Pause(); } //------------------------------------------------------------------------------ void FWThread::slot_Resume() { if(MachineExists()) Machine ()-&gt;slot_Resume(); } //------------------------------------------------------------------------------ FW_END_NAMESPACE</span></span></code> </pre><br></div></div><br><br>       FWThread ::BeforeMachineStart ().    <i>doxygen</i>    FWThread.h. <br><br> ,       <i>FWThread::run()</i> ! <br>        <i>FWStateMachine::BeforeMachineStart ()</i> ,     ,   . <br><br> - <i>FWThread_helper</i>    . <br>          ,      . <br>    <i>FWThread_helper</i>     , ,   ,          . <br><br><h2>  4. . </h2><br>  Everything is simple here.        <a href="http://doc.qt.io/qt-5/qevent.html">QEvent</a> Qt,     ¬´¬ª.   <i>QEvent::User</i>   ,      (  )   ,     ‚Ä¶ . <br><div class="spoiler"> <b class="spoiler_title">   FWEvent          .</b> <div class="spoiler_text"><br><pre> <code class="hljs ruby"><span class="hljs-comment"><span class="hljs-comment">#ifndef FW_EVENT_H #define FW_EVENT_H #include &lt;FWConstants&gt; FW_BEGIN_NAMESPACE //------------------------------------------------------------------------------ class FWStateMachine; //------------------------------------------------------------------------------ /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWEvent   ,    *  . * *      ()  *    ( -- )  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine. *  -  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWItem     * . *  -  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine     *   . *    -      * .  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent::IsSystem    . * *   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWTransition    *  .   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWTransition::testEvent  * ,      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent::Machine . */ class #ifdef FW_LIBRARY FW_SHARED_EXPORT #else Q_DECL_EXPORT #endif FWEvent : public QEvent { Q_GADGET Q_ENUMS(FWEventType) //---------------------------------------------------------------------------- private: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_id     . */ FWIdentificator m_id; /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_params       *  (  ),   . */ QVariantList m_params; //---------------------------------------------------------------------------- public: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWEvent::FWEvents     *   . */ enum FWEventType { ET_SYSTEM, ///&lt;    /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent   /// @{ ET_GLOBAL = QEvent::User + 1, ///&lt;   (  )  ET_INTERNAL = ET_GLOBAL + 1, ///&lt;    //</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">    ... // ET_SIGNAL = ET_INTERNAL + 1, ///&lt;   "" ET_TASK = ET_INTERNAL + 1, ///&lt;     /// @} ET_MAX = ET_TASK + 1, ///&lt;     ///&lt;    }; //-------------------------------------------------------------------------- /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment">    . /// @{ /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWEvent     . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID  .      *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> EMPTY_ID. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aParams    . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">     ,   *   -:     *     -.      *  . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QEvent, QEvent::Type, FWIdentificator, QVariantList. */ explicit FWEvent(QEvent::Type aEvent, FWIdentificator aID = EMPTY_ID, const QVariantList&amp; aParams = QVariantList()) : QEvent(aEvent) , m_id (aID) { SetParams (aParams); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWEvent     * . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent  ,    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent::FWEventType; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aParams    . */ explicit FWEvent(FWEvent::FWEventType aEvent, FWIdentificator aID, const QVariantList&amp; aParams = QVariantList()) :FWEvent(static_cast&lt;QEvent::Type&gt;(aEvent), aID, aParams) {} /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWEvent     . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent C  - . */ explicit FWEvent(const FWEvent&amp; aEvent) : FWEvent (aEvent.type (), aEvent.Identificator (), aEvent.Params ()) {} /// @} //-------------------------------------------------------------------------- /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  AsBaseClass        *   . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">        QEvent. */ QEvent* AsBaseClass () { return static_cast&lt;QEvent*&gt;(this); } static bool IsValidType (QEvent::Type aType) { return BETWEEN(int(aType),QEvent::None, ET_MAX); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  IsValid      , *  . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE    ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE     . */ static bool IsValid (QEvent* aEvent) { if(NOT_NULL(aEvent)) return IsValidType(aEvent-&gt;type()); return false; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@static</span></span></span><span class="hljs-comment"> * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  IsType        *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent::FWEventType. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aType     . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE      ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE       ; */ static bool IsType (QEvent* aEvent, FWEvent::FWEventType aType) { bool v_retval = IsValid (aEvent); if(v_retval) { v_retval = BETWEEN (int(aEvent-&gt;type ()),QEvent::None,ET_GLOBAL) || EQUAL (aType,ET_SYSTEM); if(!v_retval) v_retval = EQUAL(static_cast&lt;FWEvent::FWEventType&gt;(aEvent-&gt;type ()), aType); } return v_retval; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  IsSystem        *  (   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QEvent::Type  QEvent::User) * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent  . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE   . */ static bool IsSystem (QEvent* aEvent) { return IsType (aEvent, ET_SYSTEM); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  IsGlobal        * ,   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEventType::ET_GLOBAL * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent  . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE   ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE    . */ static bool IsGlobal (QEvent* aEvent) { return IsType (aEvent, ET_GLOBAL); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  IsGlobal        * ,   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEventType::ET_INTERNAL * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent  . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE   . */ static bool IsInternal (QEvent* aEvent) { return IsType (aEvent, ET_INTERNAL); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  IsGlobal       *   ,   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEventType::ET_TASK * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent  . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">  : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE    ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE     . */ static bool IsTask (QEvent* aEvent) { return IsType (aEvent, ET_TASK); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  Identificator    *   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent::FWEventType * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">   . */ inline FWIdentificator Identificator () const { return m_id; } inline QVariantList Params () const { return m_params; } inline void SetIdentificator (const FWIdentificator aID) { if(NOT_EQUAL(Identificator (), aID) ) m_id = aID; } inline void SetParams (const QVariantList&amp; aParams) { m_params.clear (); m_params.append (aParams); } inline virtual bool IsValid () { return IsValid (AsBaseClass ()) &amp;&amp; NOT_EQUAL(Identificator (),EMPTY_ID); } virtual FWEvent&amp; operator = (const FWEvent&amp; aFrom) { AsBaseClass ()-&gt;operator = (aFrom); SetIdentificator(aFrom.Identificator ()); SetParams (aFrom.Params ()); return (*this); } inline virtual bool operator == (const FWEvent&amp; aFrom) { return EQUAL(type (), aFrom.type () ) &amp;&amp; EQUAL(Identificator (), aFrom.Identificator ()); } inline virtual bool operator == (const QEvent&amp; aFrom) { return EQUAL(type (), aFrom.type ()); } inline virtual bool operator != (const FWEvent&amp; aFrom) { return NOT_EQUAL(*this, aFrom); } inline virtual bool operator != (const QEvent&amp; aFrom) { return NOT_EQUAL(*this, aFrom); } }; //------------------------------------------------------------------------------ //------------------------------------------------------------------------------ class #ifdef FW_LIBRARY FW_SHARED_EXPORT #else Q_DECL_EXPORT #endif FWSystemEvent : public FWEvent { Q_GADGET public: explicit FWSystemEvent(FWIdentificator aID, const QVariantList&amp; aParams = QVariantList()) : FWEvent(FWEvent::ET_SYSTEM, aID, aParams) { Q_ASSERT(IsSystem (AsBaseClass ())); } }; //------------------------------------------------------------------------------ //------------------------------------------------------------------------------ class #ifdef FW_LIBRARY FW_SHARED_EXPORT #else Q_DECL_EXPORT #endif FWGlobalEvent : public FWEvent { Q_GADGET public: explicit FWGlobalEvent(FWIdentificator aID, const QVariantList&amp; aParams = QVariantList()) : FWEvent(FWEventType::ET_GLOBAL, aID, aParams) {} }; //------------------------------------------------------------------------------ //------------------------------------------------------------------------------ class #ifdef FW_LIBRARY FW_SHARED_EXPORT #else Q_DECL_EXPORT #endif FWInternalEvent : public FWEvent { Q_GADGET Q_ENUMS(FWInternalIdentificators) public: enum FWInternalIdentificators { OEI_None = FWIdentificator(0x00), OEI_Start = FWIdentificator(0x01), OEI_Stop = FWIdentificator(0x02), OEI_Pause = FWIdentificator(0x04), OEI_Resume= FWIdentificator(0x08), OEI_Log = FWIdentificator(0x10), OEI_Error = FWIdentificator(0x20), }; explicit FWInternalEvent(FWIdentificator aID = OEI_None, const QVariantList&amp; aParams = QVariantList()) : FWEvent(FWEventType::ET_INTERNAL, aID, aParams) {} bool IsValid () Q_DECL_OVERRIDE { return FWEvent::IsValid () &amp;&amp; NOT_EQUAL(Identificator (),OEI_None); } }; //------------------------------------------------------------------------------ //------------------------------------------------------------------------------ class #ifdef FW_LIBRARY FW_SHARED_EXPORT #else Q_DECL_EXPORT #endif FWTaskEvent : public FWEvent { Q_GADGET public: enum FWUsbTask { TEI_None = FWIdentificator(0), TEI_Open, TEI_Opened, TEI_Close, TEI_Closed, TEI_NewStatus, TEI_NewFileName, TEI_Write, TEI_Writed, TEI_Read, TEI_Readed, TEI_Log, TEI_Error, }; explicit FWTaskEvent(FWIdentificator aID = EMPTY_ID, const QVariantList&amp; aParams = QVariantList()) : FWEvent(FWEventType::ET_TASK, aID, aParams) {} bool IsValid () Q_DECL_OVERRIDE { return FWEvent::IsValid () &amp;&amp; NOT_EQUAL(Identificator (),EMPTY_ID); } }; //------------------------------------------------------------------------------ //------------------------------------------------------------------------------ class #ifdef FW_LIBRARY FW_SHARED_EXPORT #else Q_DECL_EXPORT #endif FWUsbEvent : public FWTaskEvent { Q_GADGET private: quint16 m_VID; quint16 m_PID; quint8 m_BusNumber; quint8 m_Address; quint8 m_Port; public: enum FWUsbTask { UEI_None = FWIdentificator(0), UEI_Attached, UEI_Detached, UEI_ContextChanged, UEI_Open, UEI_Opened, UEI_Close, UEI_Closed, UEI_WriteBulk, UEI_WriteBulkComplete, UEI_ReadBulk, UEI_ReadBulkComplete, UEI_Log, UEI_Warning, UEI_Error, }; explicit FWUsbEvent(quint16 aVendorID, quint16 aProductID, quint8 aBusNumber, quint8 aAddress, quint8 aPort, FWIdentificator aID = FWUsbEvent::UEI_None, const QVariantList&amp; aParams = QVariantList()) : FWTaskEvent (FWIdentificator(aID), aParams) , m_VID (aVendorID) , m_PID (aProductID) , m_BusNumber (aBusNumber) , m_Address (aAddress) , m_Port (aPort) {} explicit FWUsbEvent(FWIdentificator aID, const QVariantList&amp; aParams = QVariantList()) : FWUsbEvent(0,0,0,0,0,aID,aParams) {} inline quint16 VID () const { return m_VID; } inline quint16 PID () const { return m_PID; } inline quint8 BusNumner () const { return m_BusNumber; } inline quint8 Address () const { return m_Address; } inline quint8 Port () const { return m_Port; } FWUsbEvent&amp; operator = (const FWUsbEvent&amp; aFrom) { FWEvent::operator = (static_cast&lt;FWEvent&gt;(aFrom)); m_VID = aFrom.VID (); m_PID = aFrom.PID (); m_BusNumber = aFrom.BusNumner (); m_Address = aFrom.Address (); m_Port = aFrom.Port (); return (*this); } bool operator == (const FWUsbEvent&amp; aFrom) { return FWEvent::operator == (static_cast&lt;FWEvent&gt;(aFrom)) &amp;&amp; EQUAL(VID (), aFrom.VID ()) &amp;&amp; EQUAL(PID (), aFrom.PID ()) &amp;&amp; EQUAL(BusNumner (), aFrom.BusNumner ()) &amp;&amp; EQUAL(Address (), aFrom.Address ()) &amp;&amp; EQUAL(Port (), aFrom.Port ()); } }; //------------------------------------------------------------------------------ //------------------------------------------------------------------------------ /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> FWEventTypeMap /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> FWEvent, QEvent, QEvent::Type /// typedef QMap&lt;FWEvent::FWEventType, FWEvent*&gt; FWEventTypeMap; typedef QMapIterator&lt;FWEvent::FWEventType, FWEvent*&gt; FWEventTypeMap_I1; typedef FWEventTypeMap::Iterator FWEventTypeMap_I2; typedef FWEventTypeMap::ConstIterator FWEventTypeMap_CI; /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> FWEventMap /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> FWEvent, QEvent, QEvent::Type, FWIdentificator /// typedef QMap&lt;FWIdentificator, FWEvent*&gt; FWEventMap; typedef QMapIterator&lt;FWIdentificator, FWEvent*&gt; FWEventMap_I1; typedef FWEventMap::Iterator FWEventMap_I2; typedef FWEventMap::ConstIterator FWEventMap_CI; //------------------------------------------------------------------------------ FW_END_NAMESPACE //------------------------------------------------------------------------------ Q_DECLARE_METATYPE(FW_NAMESPACE::FWEventTypeMap) Q_DECLARE_METATYPE(FW_NAMESPACE::FWEventMap) //------------------------------------------------------------------------------ #endif // FW_EVENT_H</span></span></code> </pre><br></div></div><br> ,      ,     <i>FWStateMashine</i> ,    <i>FWInternalEvent</i> ,  ()    <i>FWTskEvent</i> . <br><br>    <a href="https://ru.wikipedia.org/wiki/%25CA%25EB%25E0%25F1%25F1%25E8%25F4%25E8%25EA%25E0%25F6%25E8%25FF_%25E0%25E1%25F1%25F2%25F0%25E0%25EA%25F2%25ED%25FB%25F5_%25E0%25E2%25F2%25EE%25EC%25E0%25F2%25EE%25E2">  </a> ,        .    . .  <a href="http://www.ozon.ru/context/detail/id/7449666/">¬´Qt4.7+.   C++¬ª</a> ,   <a href="https://ru.wikipedia.org/wiki/%25CA%25EB%25E0%25F1%25F1%25E8%25F4%25E8%25EA%25E0%25F6%25E8%25FF_%25E0%25E1%25F1%25F2%25F0%25E0%25EA%25F2%25ED%25FB%25F5_%25E0%25E2%25F2%25EE%25EC%25E0%25F2%25EE%25E2">  </a> ,    ,  ,                . <br><br>    <a href="http://doc.qt.io/qt-5/qabstracttransition.html">QAbstractTransition::eventTest(QEvent* aEvent)</a>     , <div class="spoiler"> <b class="spoiler_title"> :</b> <div class="spoiler_text"><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FWTransition::eventTest(QEvent* aEvent) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> v_retval = FWEvent::IsValid (aEvent); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(v_retval) v_retval = EQUAL(aEvent-&gt;type (),EventType ()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(v_retval) { FWEvent* v_e = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;FWEvent*&gt;(aEvent); v_retval = EQUAL(v_e-&gt;type (), EventType ()) &amp;&amp; EQUAL(v_e-&gt;Identificator (),EventID ()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v_retval; }</code> </pre><br></div></div><br>                ,       <i>FWTransition</i> . <br><br><h3>  . </h3><br><ul><li>     QThread,          . </li><li>              ,  . </li><li>      FWThread     .    ,    ,       . </li><li>                . </li><li>      . </li></ul><br><br><h2>  5. .   USB-    libUSB. </h2><br>       ¬´ +  ¬ª. <br>        USB-. <br>           API  <a href="http://libusb.info/">libUSBx</a> .              ,        USB-   . <br><br>       <i>libUSB</i>  <a href="http://libusb.sourceforge.net/api-1.0/contexts.html">libusb_context</a> .  ,         . <br><br>           USB-   .            USB-,         .            <i>libusb_init(NULL)</i>       .         .   ,         . <br><br>          <i>libusb_init()</i>  <i>NULL</i> ,     .        <i>libusb_init ()</i> ,     . <br>  <i>libUSB</i>  ,       .  ¬´¬ª <i>libUSB</i> ,         :  <i>libusb_open ()</i> ,                 . <br>       <i>libusb_exit ()</i> ,       API <i>libUSB</i> ,       <i>libusb_exit ()</i> . <br><br>      ,   <i>libusb_get_device_list()</i> . <br>  ,  ,          <a href="http://libusb.sourceforge.net/api-1.0/group__dev.html">libusb_device</a>      ,   . <br>  USB-     : <br><ol><li> VID: </li><li> PID; </li><li>  ; </li><li>  ; </li><li>  . </li></ol><br><br>  VID  PID      <a href="http://libusb.sourceforge.net/api-1.0/structlibusb__device__descriptor.html">libusb_device_descriptor</a> ,     <a href="http://libusb.sourceforge.net/api-1.0/group__dev.html">libusb_get_bus_number()</a> , <a href="http://libusb.sourceforge.net/api-1.0/group__dev.html">libusb_get_device_address()</a>  <a href="http://libusb.sourceforge.net/api-1.0/group__dev.html">libusb_get_port_number()</a> . <br>     ,   <i>QEvent</i> ,       . <br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> #ifdef </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FW_LIBRARY</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FW_SHARED_EXPORT</span></span></span><span class="hljs-class"> #else </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_DECL_EXPORT</span></span></span><span class="hljs-class"> #endif </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbEvent</span></span></span><span class="hljs-class"> : public </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWTaskEvent</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_GADGET</span></span></span><span class="hljs-class"> private: quint16 m_VID; quint16 m_PID; quint8 m_BusNumber; quint8 m_Address; quint8 m_Port; public: enum </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbTask</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_None</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWIdentificator</span></span></span><span class="hljs-class">(0), </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_Attached</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_Detached</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_ContextChanged</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_Open</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_Opened</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_Close</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_Closed</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_WriteBulk</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_WriteBulkComplete</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_ReadBulk</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_ReadBulkComplete</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_Log</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_Warning</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_Error</span></span></span><span class="hljs-class">, }; explicit </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbEvent</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quint16</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aVendorID</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quint16</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aProductID</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quint8</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aBusNumber</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quint8</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aAddress</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quint8</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aPort</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWIdentificator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aID</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbEvent</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UEI_None</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QVariantList</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aParams</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QVariantList</span></span></span><span class="hljs-class">()) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWTaskEvent</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWIdentificator(aID)</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aParams</span></span></span><span class="hljs-class">) , m_VID (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aVendorID</span></span></span><span class="hljs-class">) , m_PID (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aProductID</span></span></span><span class="hljs-class">) , m_BusNumber (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aBusNumber</span></span></span><span class="hljs-class">) , m_Address (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aAddress</span></span></span><span class="hljs-class">) , m_Port (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aPort</span></span></span><span class="hljs-class">) {} explicit </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbEvent</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWIdentificator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aID</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QVariantList</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aParams</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QVariantList</span></span></span><span class="hljs-class">()) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbEvent</span></span></span><span class="hljs-class">(0,0,0,0,0,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aID</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aParams</span></span></span><span class="hljs-class">) {} inline quint16 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VID</span></span></span><span class="hljs-class"> () const { return m_VID; } inline quint16 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PID</span></span></span><span class="hljs-class"> () const { return m_PID; } inline quint8 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BusNumner</span></span></span><span class="hljs-class"> () const { return m_BusNumber; } inline quint8 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Address</span></span></span><span class="hljs-class"> () const { return m_Address; } inline quint8 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Port</span></span></span><span class="hljs-class"> () const { return m_Port; } </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbEvent</span></span></span><span class="hljs-class">&amp; operator = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbEvent</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aFrom</span></span></span><span class="hljs-class">) { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWEvent</span></span></span><span class="hljs-class">::operator = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static_cast</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWEvent</span></span></span><span class="hljs-class">&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aFrom</span></span></span><span class="hljs-class">)); m_VID = aFrom.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VID</span></span></span><span class="hljs-class"> (); m_PID = aFrom.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PID</span></span></span><span class="hljs-class"> (); m_BusNumber = aFrom.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BusNumner</span></span></span><span class="hljs-class"> (); m_Address = aFrom.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Address</span></span></span><span class="hljs-class"> (); m_Port = aFrom.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Port</span></span></span><span class="hljs-class"> (); return (*</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">); } bool operator == (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbEvent</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aFrom</span></span></span><span class="hljs-class">) { return </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWEvent</span></span></span><span class="hljs-class">::operator == (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static_cast</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWEvent</span></span></span><span class="hljs-class">&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aFrom</span></span></span><span class="hljs-class">)) &amp;&amp; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EQUAL</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VID</span></span></span><span class="hljs-class"> (), aFrom.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VID</span></span></span><span class="hljs-class"> ()) &amp;&amp; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EQUAL</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PID</span></span></span><span class="hljs-class"> (), aFrom.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PID</span></span></span><span class="hljs-class"> ()) &amp;&amp; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EQUAL</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BusNumner</span></span></span><span class="hljs-class"> (), aFrom.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BusNumner</span></span></span><span class="hljs-class"> ()) &amp;&amp; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EQUAL</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Address</span></span></span><span class="hljs-class"> (), aFrom.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Address</span></span></span><span class="hljs-class"> ()) &amp;&amp; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EQUAL</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Port</span></span></span><span class="hljs-class"> (), aFrom.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Port</span></span></span><span class="hljs-class"> ()); } };</span></span></code> </pre><br></div></div><br><br>       FWUscbInstance    FWExecuteInstance.  FWExecuteInstance  FWDocument &lt; ‚Äî FWItem. <br><div class="spoiler"> <b class="spoiler_title">FWExecuteInstance.h</b> <div class="spoiler_text"><br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#ifndef</span></span> <span class="hljs-type"><span class="hljs-type">FW_EXECUTE_INSTANCE_H</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">FW_EXECUTE_INSTANCE_H</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> &lt;<span class="hljs-type"><span class="hljs-type">FWDocument</span></span>&gt; <span class="hljs-type"><span class="hljs-type">FW_BEGIN_NAMESPACE</span></span> //------------------------------------------------------------------------------ class <span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> <span class="hljs-type"><span class="hljs-type">FW_LIBRARY</span></span> <span class="hljs-type"><span class="hljs-type">FW_SHARED_EXPORT</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#else</span></span> <span class="hljs-type"><span class="hljs-type">Q_DECL_EXPORT</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> <span class="hljs-type"><span class="hljs-type">FWExecuteInstance</span></span> : public <span class="hljs-type"><span class="hljs-type">FWDocument</span></span> { <span class="hljs-type"><span class="hljs-type">Q_OBJECT</span></span> <span class="hljs-type"><span class="hljs-type">Q_CLASSINFO</span></span>(<span class="hljs-comment"><span class="hljs-comment">"brief"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"FW Execute Instance Class"</span></span>) <span class="hljs-type"><span class="hljs-type">Q_CLASSINFO</span></span>(<span class="hljs-comment"><span class="hljs-comment">"created"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"12-MAY-2015"</span></span>) <span class="hljs-type"><span class="hljs-type">Q_CLASSINFO</span></span>(<span class="hljs-comment"><span class="hljs-comment">"modified"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"12-MAY-2015"</span></span>) // <span class="hljs-type"><span class="hljs-type">Q_CLASSINFO</span></span>(<span class="hljs-comment"><span class="hljs-comment">"project"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"Common Qt-based Framework"</span></span>) /// @name   . /// @{ typedef <span class="hljs-type"><span class="hljs-type">FWDocument</span></span> <span class="hljs-type"><span class="hljs-type">BaseClass</span></span>; /// @} private: /// /// @brief m_timer /// <span class="hljs-type"><span class="hljs-type">QTimer</span></span> m_timer; /// /// @brief m_timer_mode /// bool m_timer_mode; public: <span class="hljs-type"><span class="hljs-type">Q_INVOKABLE</span></span> explicit <span class="hljs-type"><span class="hljs-type">FWExecuteInstance</span></span>(bool aTimerMode = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-type"><span class="hljs-type">QObject</span></span>* aParent = <span class="hljs-type"><span class="hljs-type">Q_NULLPTR</span></span>); bool <span class="hljs-type"><span class="hljs-type">IsTimerMode</span></span>() const { return m_timer_mode; } void <span class="hljs-type"><span class="hljs-type">Open</span></span> () <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span>; void <span class="hljs-type"><span class="hljs-type">Close</span></span> () <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span>; inline void <span class="hljs-type"><span class="hljs-type">StartTimer</span></span> (int aMSec = <span class="hljs-number"><span class="hljs-number">10</span></span>) { if((!m_timer.isActive ()) &amp;&amp; <span class="hljs-type"><span class="hljs-type">IsTimerMode</span></span> ()) m_timer.start (aMSec); } inline void <span class="hljs-type"><span class="hljs-type">StopTimer</span></span> () { if(m_timer.isActive ()) m_timer.stop (); } inline bool <span class="hljs-type"><span class="hljs-type">IsTiming</span></span> () const { return m_timer.isActive () &amp;&amp; <span class="hljs-type"><span class="hljs-type">IsTimerMode</span></span> (); } void <span class="hljs-type"><span class="hljs-type">SetTimerMode</span></span> (bool aTimerMode) { if(<span class="hljs-type"><span class="hljs-type">EQUAL</span></span>(m_timer_mode, aTimerMode)) return; bool is_timing = <span class="hljs-type"><span class="hljs-type">IsTiming</span></span> (); if(is_timing) <span class="hljs-type"><span class="hljs-type">StopTimer</span></span> (); m_timer_mode = aTimerMode; if(is_timing || <span class="hljs-type"><span class="hljs-type">IsTimerMode</span></span> ()) <span class="hljs-type"><span class="hljs-type">StartTimer</span></span> (); } public slots: virtual void slot_OnExecute () {} void slot_BreakProcess () <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span>; virtual void slot_ResumeProcess () { <span class="hljs-type"><span class="hljs-type">Open</span></span> ();//<span class="hljs-type"><span class="hljs-type">SetStatus</span></span> (<span class="hljs-type"><span class="hljs-type">SF_Active</span></span>); if(<span class="hljs-type"><span class="hljs-type">IsTimerMode</span></span> ()) <span class="hljs-type"><span class="hljs-type">StartTimer</span></span> (); } }; //------------------------------------------------------------------------------ <span class="hljs-type"><span class="hljs-type">FW_END_NAMESPACE</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> // <span class="hljs-type"><span class="hljs-type">FW_EXECUTE_INSTANCE_H</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">FWUscbInstance.h</b> <div class="spoiler_text"><br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#ifndef</span></span> <span class="hljs-type"><span class="hljs-type">FW_USB_INSTANCE_H</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">FW_USB_INSTANCE_H</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"FWUsbTypes.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"FWExecuteInstance.h"</span></span> <span class="hljs-type"><span class="hljs-type">FW_BEGIN_NAMESPACE</span></span> //------------------------------------------------------------------------------ class <span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span>; class <span class="hljs-type"><span class="hljs-type">FWUsbConnection</span></span>; //------------------------------------------------------------------------------ /// /// \language <span class="hljs-type"><span class="hljs-type">Russian</span></span> /// @brief  <span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span>      ///  libusb /// ///     libusb   libusb . ///   libusb      ///    libusb (    ) ///        /// libusb - , libusb_set_debug ()       /// ,  libusb_exit ()    ,   ///  - . /// ///   libusb_init ()    libusb_exit (). /// class <span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> <span class="hljs-type"><span class="hljs-type">FW_LIBRARY</span></span> <span class="hljs-type"><span class="hljs-type">FW_SHARED_EXPORT</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#else</span></span> <span class="hljs-type"><span class="hljs-type">Q_DECL_EXPORT</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> <span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span> : public <span class="hljs-type"><span class="hljs-type">FWExecuteInstance</span></span> { <span class="hljs-type"><span class="hljs-type">Q_OBJECT</span></span> <span class="hljs-type"><span class="hljs-type">Q_CLASSINFO</span></span>(<span class="hljs-comment"><span class="hljs-comment">"brief"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"FW LibUSB Instance Class"</span></span>) <span class="hljs-type"><span class="hljs-type">Q_CLASSINFO</span></span>(<span class="hljs-comment"><span class="hljs-comment">"created"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"27-MAR-2015"</span></span>) <span class="hljs-type"><span class="hljs-type">Q_CLASSINFO</span></span>(<span class="hljs-comment"><span class="hljs-comment">"modified"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"12-MAY-2015"</span></span>) // <span class="hljs-type"><span class="hljs-type">Q_CLASSINFO</span></span>(<span class="hljs-comment"><span class="hljs-comment">"project"</span></span>, <span class="hljs-comment"><span class="hljs-comment">"Common Qt-based Framework"</span></span>) /// @name   . /// @{ typedef <span class="hljs-type"><span class="hljs-type">FWExecuteInstance</span></span> <span class="hljs-type"><span class="hljs-type">BaseClass</span></span>; /// @} private: /// @name     /// @{ /// /// @brief m_context    libusb /// @see libusb_context, <span class="hljs-type"><span class="hljs-type">TUsbContext</span></span>* /// <span class="hljs-type"><span class="hljs-type">TUsbContext</span></span>* m_context; /// /// @brief m_log_level    /// @see libusb_log_level <span class="hljs-type"><span class="hljs-type">TUsbLogLevel</span></span> /// <span class="hljs-type"><span class="hljs-type">TUsbLogLevel</span></span> m_log_level; <span class="hljs-type"><span class="hljs-type">QList</span></span>&lt;<span class="hljs-type"><span class="hljs-type">QVector</span></span>&lt;int&gt; &gt; m_attached_list; /// @} public: /// @name    . /// @{ <span class="hljs-type"><span class="hljs-type">Q_INVOKABLE</span></span> explicit <span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span>(bool aTimerMode = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> /* <span class="hljs-type"><span class="hljs-type">Thread</span></span> or <span class="hljs-type"><span class="hljs-type">Manual</span></span>*/, <span class="hljs-type"><span class="hljs-type">TUsbLogLevel</span></span> aLogLevel = <span class="hljs-type"><span class="hljs-type">LIBUSB_LOG_LEVEL_ERROR</span></span> /*<span class="hljs-type"><span class="hljs-type">LIBUSB_LOG_LEVEL_DEBUG</span></span>*/, <span class="hljs-type"><span class="hljs-type">QObject</span></span>* aParent = <span class="hljs-type"><span class="hljs-type">Q_NULLPTR</span></span>); /// @} <span class="hljs-type"><span class="hljs-type">BaseClass</span></span>* <span class="hljs-type"><span class="hljs-type">AsBaseClass</span></span> () <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span> { return <span class="hljs-type"><span class="hljs-type">AsClass</span></span>&lt;<span class="hljs-type"><span class="hljs-type">BaseClass</span></span>&gt;(); } bool <span class="hljs-type"><span class="hljs-type">IsValid</span></span> () const <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span> { return <span class="hljs-type"><span class="hljs-type">BaseClass</span></span>::<span class="hljs-type"><span class="hljs-type">IsValid</span></span>() &amp;&amp; <span class="hljs-type"><span class="hljs-type">ContextExists</span></span> (); } bool <span class="hljs-type"><span class="hljs-type">IsActive</span></span> () const <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span> { return <span class="hljs-type"><span class="hljs-type">IsValid</span></span>() &amp;&amp; <span class="hljs-type"><span class="hljs-type">BaseClass</span></span>::<span class="hljs-type"><span class="hljs-type">IsActive</span></span>(); } virtual void <span class="hljs-type"><span class="hljs-type">OpenUsbContext</span></span> (bool aCloseOldContext = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); virtual void <span class="hljs-type"><span class="hljs-type">CloseUsbContext</span></span> (); void <span class="hljs-type"><span class="hljs-type">SetContext</span></span> (<span class="hljs-type"><span class="hljs-type">TUsbContext</span></span>* aContext); virtual bool <span class="hljs-type"><span class="hljs-type">ContextExists</span></span> () const { return <span class="hljs-type"><span class="hljs-type">NOT_ZERRO</span></span>(<span class="hljs-type"><span class="hljs-type">UsbContextAsID</span></span> ()); } <span class="hljs-type"><span class="hljs-type">TUsbContext</span></span>* <span class="hljs-type"><span class="hljs-type">UsbContext</span></span> () const { return m_context; } void <span class="hljs-type"><span class="hljs-type">MakeUsbDeviceList</span></span>(); void <span class="hljs-type"><span class="hljs-type">Open</span></span> () <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span>; void <span class="hljs-type"><span class="hljs-type">Close</span></span> () <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span>; void <span class="hljs-type"><span class="hljs-type">Reload</span></span> (); protected: void <span class="hljs-type"><span class="hljs-type">Initialisation</span></span> () <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span>; inline <span class="hljs-type"><span class="hljs-type">FWIdentificator</span></span> <span class="hljs-type"><span class="hljs-type">UsbContextAsID</span></span> () const { return <span class="hljs-type"><span class="hljs-type">FWIdentificator</span></span>(<span class="hljs-type"><span class="hljs-type">UsbContext</span></span>()); } void <span class="hljs-type"><span class="hljs-type">ClearUsbDeviceList</span></span> (); <span class="hljs-type"><span class="hljs-type">Q_SIGNALS</span></span>: void sign_ContextChanged (const <span class="hljs-type"><span class="hljs-type">QObject</span></span>*); /// void sign_UsbDeviceAttached (quint8 aBus, quint8 aAddr, quint8 aPort, quint16 aVendorID, quint16 aProductID); /// /// @brief sign_UsbDeviceDeleted /// @param aDevice /// void sign_UsbDeviceDetached(quint8 aBus, quint8 aAddr, quint8 aPort, quint16 aVendorID, quint16 aProductID); // void // sign_DeviceListChanged (const <span class="hljs-type"><span class="hljs-type">TUsbDeviceList</span></span>&amp; aList, // const <span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span>* aInstance); // void // sign_UsbDeviceStarted (const <span class="hljs-type"><span class="hljs-type">FWThreadController</span></span>* aController); public <span class="hljs-type"><span class="hljs-type">Q_SLOTS</span></span>: void slot_OnExecute () <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span>; void slot_OnPause (); void slot_OnResume (); bool slot_ApplyFilter () <span class="hljs-type"><span class="hljs-type">Q_DECL_OVERRIDE</span></span>; void slot_OnLoop (); }; //------------------------------------------------------------------------------ /// /// @brief <span class="hljs-type"><span class="hljs-type">FWSharedUsbInstance</span></span>  @a <span class="hljs-type"><span class="hljs-type">QSharedPointer</span></span>   ///  @a <span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span> /// typedef <span class="hljs-type"><span class="hljs-type">QSharedPointer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span>&gt; <span class="hljs-type"><span class="hljs-type">FWSharedUsbInstance</span></span>; //------------------------------------------------------------------------------ <span class="hljs-type"><span class="hljs-type">FW_END_NAMESPACE</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> // <span class="hljs-type"><span class="hljs-type">FW_USB_INSTANCE_H</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"> FWUsbInstance::Reload()  FWUsbInstance        USB-.</b> <div class="spoiler_text"><br><pre> <code class="hljs dos">void FWUsbInstance::Reload() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!IsActive()) return; libusb_set_debug (m_context, LIBUSB_LOG_LEVEL_NONE); //     QList&lt;QVector&lt;int&gt; &gt; _list_prev = m_attached_list; //     ... MakeUsbDeviceList(); // ...     QList&lt;QVector&lt;int&gt; &gt; _list_now = m_attached_list; //    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!_list_prev.isEmpty ()) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(register int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _list_prev.size (); ++i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_list_now.indexOf (_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { slot_OnMachineEvent( new FWUsbEvent( quint16(_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i).<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>)),//VID quint16(_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i).<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>)),//PID quint8 (_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i).<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>)),//Bus Number quint8 (_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i).<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)),//Address quint8 (_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i).<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>)),//Port Number FWUsbEvent::UEI_Detached,));//   } //     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!_list_now.isEmpty ()) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(register int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _list_now.size (); ++i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!_list_prev.contains (_list_now.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i))) { slot_OnMachineEvent( new FWUsbEvent( quint16(_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i).<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>)),//VID quint16(_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i).<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>)),//PID quint8 (_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i).<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>)),//Bus Number quint8 (_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i).<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)),//Address quint8 (_list_prev.<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (i).<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>)),//Port Number FWUsbEvent::UEI_Attached));//   } libusb_set_debug (m_context, m_log_level); }</code> </pre><br></div></div><br><br> ,  ‚Ä¶ <br>    ,     <i>QObject</i> -    <i>FWItem</i> ( QObject),     <i>slot_OnMachineEvent()</i> <br><pre> <code class="hljs php">void FWItem::slot_OnMachineEvent(FWEvent* aEvent) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(MachineExists()) Machine()-&gt;PostEvent(aEvent); }</code> </pre><br><br><h3>        . </h3><br>              . <br>    <i>FWThread::BeforeMachineStart()</i> <br>  - <i>FWThread</i>    <i>FWUsbScanner</i> . <br><div class="spoiler"> <b class="spoiler_title">  FWUsbScanner:: BeforeMachineStart()</b> <div class="spoiler_text"><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">void</span></span> <span class="hljs-type"><span class="hljs-type">FWUsbScanner</span></span>::<span class="hljs-type"><span class="hljs-type">BeforeMachineStart</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-type"><span class="hljs-type">IsValid</span></span> ()) return; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_usb.isNull()) m_usb = new <span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span>(m_timer_mode); m_usb-&gt;<span class="hljs-type"><span class="hljs-type">SetMachine</span></span>(<span class="hljs-type"><span class="hljs-type">Machine</span></span>()); /// @name      <span class="hljs-type"><span class="hljs-type">USB</span></span>- /// @{ <span class="hljs-type"><span class="hljs-type">QObject</span></span>::connect(m_usb,&amp;<span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span>::sign_UsbDeviceAttached, this, &amp;<span class="hljs-type"><span class="hljs-type">FWUsbScanner</span></span>:: sign_UsbDeviceAttached, <span class="hljs-type"><span class="hljs-type">Qt</span></span>::<span class="hljs-type"><span class="hljs-type">ConnectionType</span></span>(<span class="hljs-type"><span class="hljs-type">Qt</span></span>::<span class="hljs-type"><span class="hljs-type">DirectConnection</span></span> | <span class="hljs-type"><span class="hljs-type">Qt</span></span>::<span class="hljs-type"><span class="hljs-type">UniqueConnection</span></span>)); <span class="hljs-type"><span class="hljs-type">QObject</span></span>::connect(m_usb,&amp;<span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span>::sign_UsbDeviceDetached, this, &amp;<span class="hljs-type"><span class="hljs-type">FWUsbScanner</span></span>:: sign_UsbDeviceDetached, <span class="hljs-type"><span class="hljs-type">Qt</span></span>::<span class="hljs-type"><span class="hljs-type">ConnectionType</span></span>(<span class="hljs-type"><span class="hljs-type">Qt</span></span>::<span class="hljs-type"><span class="hljs-type">DirectConnection</span></span> | <span class="hljs-type"><span class="hljs-type">Qt</span></span>::<span class="hljs-type"><span class="hljs-type">UniqueConnection</span></span>)); <span class="hljs-type"><span class="hljs-type">QObject</span></span>::connect(m_usb,&amp;<span class="hljs-type"><span class="hljs-type">FWUsbInstance</span></span>::sign_ContextChanged, this, &amp;<span class="hljs-type"><span class="hljs-type">FWUsbScanner</span></span>:: sign_ContextChanged, <span class="hljs-type"><span class="hljs-type">Qt</span></span>::<span class="hljs-type"><span class="hljs-type">ConnectionType</span></span>(<span class="hljs-type"><span class="hljs-type">Qt</span></span>::<span class="hljs-type"><span class="hljs-type">DirectConnection</span></span> | <span class="hljs-type"><span class="hljs-type">Qt</span></span>::<span class="hljs-type"><span class="hljs-type">UniqueConnection</span></span>)); /// @} //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-type"><span class="hljs-type">AttachObject</span></span> (m_usb.<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">())) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QT_TRY</span></span></span><span class="hljs-class"> { /// @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">      </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">USB</span></span></span><span class="hljs-class">- /// @{ </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QState</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sIdle</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Machine</span></span></span><span class="hljs-class"> ()-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateIdle</span></span></span><span class="hljs-class"> (); //    " " </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWState</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sOpen</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWState</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Machine</span></span></span><span class="hljs-class"> ()-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateGroup</span></span></span><span class="hljs-class"> ()); //    "" </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWState</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sScan</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWState</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Machine</span></span></span><span class="hljs-class"> ()-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateGroup</span></span></span><span class="hljs-class"> ()); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sScan</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setObjectName</span></span></span><span class="hljs-class">("</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">USB</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Scan</span></span></span><span class="hljs-class">"); //   " "    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Machine</span></span></span><span class="hljs-class">()-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddBranch</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sIdle</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sOpen</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QObject</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connect</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sOpen</span></span></span><span class="hljs-class">, &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWState</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entered</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_usb</span></span></span><span class="hljs-class">, &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbInstance</span></span></span><span class="hljs-class">:: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slot_Open</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConnectionType</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DirectConnection</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UniqueConnection</span></span></span><span class="hljs-class">)); //   ""    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Machine</span></span></span><span class="hljs-class">()-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddBranch</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWTaskEvent</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ET_TASK</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWTaskEvent</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TEI_Opened</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sOpen</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sScan</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(!</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_usb</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IsTimerMode</span></span></span><span class="hljs-class">()) { //    :      //    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWState</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sLoop</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWState</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Machine</span></span></span><span class="hljs-class"> ()-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateGroup</span></span></span><span class="hljs-class"> ()); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Machine</span></span></span><span class="hljs-class">()-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddBranch</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sScan</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sLoop</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Machine</span></span></span><span class="hljs-class">()-&gt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddBranch</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWEvent</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ET_TASK</span></span></span><span class="hljs-class">,</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWTaskEvent</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TEI_Read</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sLoop</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sScan</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QObject</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connect</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sLoop</span></span></span><span class="hljs-class">, &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWState</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entered</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_usb</span></span></span><span class="hljs-class">, &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbInstance</span></span></span><span class="hljs-class">:: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slot_OnLoop</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConnectionType</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DirectConnection</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UniqueConnection</span></span></span><span class="hljs-class">)); } //     "" </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QObject</span></span></span><span class="hljs-class">::connect(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sScan</span></span></span><span class="hljs-class">, &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWState</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entered</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_usb</span></span></span><span class="hljs-class">, &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbInstance</span></span></span><span class="hljs-class">:: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slot_OnExecute</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConnectionType</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DirectConnection</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UniqueConnection</span></span></span><span class="hljs-class">)); //   ""  ""   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QObject</span></span></span><span class="hljs-class">::connect(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Machine</span></span></span><span class="hljs-class">(),&amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWStateMachine</span></span></span><span class="hljs-class">::sign_Paused, m_usb, &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbInstance</span></span></span><span class="hljs-class">:: slot_OnPause, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DirectConnection</span></span></span><span class="hljs-class">); //    ""    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QObject</span></span></span><span class="hljs-class">::connect(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Machine</span></span></span><span class="hljs-class">(),&amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWStateMachine</span></span></span><span class="hljs-class">::sign_Resumed, m_usb, &amp;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FWUsbInstance</span></span></span><span class="hljs-class">:: slot_OnResume, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qt</span></span></span><span class="hljs-class">::</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DirectConnection</span></span></span><span class="hljs-class">); /// @} return; //    } </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QT_CATCH</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QException</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">what</span></span></span><span class="hljs-class"> (); } //     ,    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SetAutoDelete</span></span></span><span class="hljs-class">(); //    exit() m_usb-&gt;deleteLater (); //    m_usb = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_NULLPTR</span></span></span><span class="hljs-class">; exit (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EXIT_FAILURE</span></span></span><span class="hljs-class">); //     }</span></span></code> </pre><br></div></div><br>      ‚Äì   . <br>    : <br>  <i>FWUsbInstance:: slot_OnExecute()</i>   . <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> FWUsbInstance::slot_OnExecute() { // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsTimerMode()) // { <span class="hljs-type"><span class="hljs-type">bool</span></span> _tm = IsTiming (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_tm) StopTimer (); Reload (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_tm) StartTimer (<span class="hljs-number"><span class="hljs-number">10</span></span>); // } // <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(IsActive()) // Reload (); }</code> </pre><br>    ‚Äì  .   ,    <i>FWUsbScanner::BeforeMachineStart()</i>   <i>Machine()-&gt;AddBranch(sScan, sLoop)</i> ,    ,    <i>while()</i>        .       <i>Reload()</i>   . <br><br>  Consider this in more detail. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsActive ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">checks the class activity flag. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The slot </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slot_BreakProcess () of the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> base class </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FWItem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clears the flag, the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator</font></font><br><pre> <code class="hljs ruby"> QObject::connect(Machine(),&amp;FWStateMachine::sign_Paused, m_usb, &amp;FWUsbInstance:: slot_OnPause, Qt::DirectConnection);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Slots </font></font><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FWUsbInstance::slot_OnPause() { slot_BreakProcess(); }</code> </pre><br>  AND <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FWUsbInstance::slot_OnResume() { slot_ResumeProcess(); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should manage the suspension and resumption of work flow. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything should work out. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But there will be no pause, the cycle will not end.</font></font><br>  What's the matter? <br>   ,   <i>Machine()</i>     <i>postEvent()</i> , ..      .  <i>slot_OnExecute()</i>    ,  ,     . <br>  ,        <i>slot_OnExecute()</i> :  <i>while()</i>   .  ¬´¬ª    <i>QCoreApplication::processEvents()</i>   ! <br><br>     , ,        . <br>       (sLoop)       . <br><pre> <code class="hljs php">void FWUsbInstance::slot_OnLoop() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(MachineExists()) Machine()-&gt;PostEvent(FWEvent::ET_TASK,FWTaskEvent::TEI_Read); }</code> </pre><br>  ,    ¬´¬ª    . ,    ,      .   ,            .   ,  ‚Äì  . <br><br> , ,  ,    . <br><br><h1>  Total </h1><br><ul><li>              <i>QThread</i> . </li><li>      Qt    . </li><li>   ¬´¬ª    <i>QThread</i>    <i>QThread</i>  (protected)  . </li><li>        <i>QThread_helper</i>     . </li><li>           . </li><li>       <i>libUSB</i> . </li><li>       <i>QEvent</i> ,        . </li></ul><br><br><h2>  Notes </h2><br> <b>          .</b> <br>   <b>   ()</b> .         .      ,      . <br><br>       .     ¬´¬ª . <br><br>        ‚Äì - . :)  ,    . <br><br><h3>   </h3><br><br><div class="spoiler"> <b class="spoiler_title">FWStateMachine.h</b> <div class="spoiler_text"><br><pre> <code class="hljs ruby"><span class="hljs-comment"><span class="hljs-comment">#ifndef FWSTATEMACHINE_H #define FWSTATEMACHINE_H #ifndef QSTATEMACHINE_DEBUG # define QSTATEMACHINE_DEBUG #endif #include "FWState.h" FW_BEGIN_NAMESPACE //------------------------------------------------------------------------------ /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWStateMachine   " ". /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QStateMachine /// class #ifdef FW_LIBRARY FW_SHARED_EXPORT #else Q_DECL_EXPORT #endif FWStateMachine : public QStateMachine { friend class FWThread; Q_OBJECT Q_CLASSINFO("brief", "Finite-state machine Class") Q_CLASSINFO("created", "03-JUN-2015") Q_CLASSINFO("modified", "03-JUN-2015") // Q_CLASSINFO("project", "Common Qt-based Framework") // Q_CLASSINFO("info_en", "https://en.wikipedia.org/wiki/Finite-state_machine") Q_CLASSINFO("info_ru", "https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82") /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment">   . /// @{ ///        typedef QStateMachine BaseClass; /// @} //---------------------------------------------------------------------------- private: /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_final_signals      ///    ,     ( /// )    . /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FWFinalSignalsMap::key()  .   , ///         ///   ; /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FWFinalSignalsMap::value ()    .  ///        , ///  - . /// QScopedPointer&lt;FWState&gt; m_state_group; /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_history_state      ///     . ///    ""  .    , ///         , ///        ,    ///  (..    , ,   , ///  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_state_main) /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">      ,  ///       ;   ///       /// ,     ()  /// ,      . ///     - ,   ,   ///  ,      ; /// ,  ""     /// . (\a http://doc.crossplatform.ru/qt/4.7.x/statemachine-api.html) /// QScopedPointer&lt;QHistoryState&gt; m_state_history; /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_final_state     ///         ///     . /// QScopedPointer&lt;QFinalState&gt; m_state_final; /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_state_error     ///      . /// QScopedPointer&lt;FWState&gt; m_state_error; //---------------------------------------------------------------------------- public: explicit FWStateMachine(QObject* aParent = Q_NULLPTR); explicit FWStateMachine(QState::ChildMode aChildMode, QObject* aParent = Q_NULLPTR); BaseClass* AsBaseClass() { return qobject_cast&lt;BaseClass*&gt;(this); } bool StateGroupExists () const { return !m_state_group.isNull (); } FWState* StateGroup () const { return StateGroupExists () ? m_state_group.data () : Q_NULLPTR; } inline FWState* StateIdle () const { return StateGroupExists () ? qobject_cast&lt;FWState*&gt;(StateGroup()-&gt;initialState ()): Q_NULLPTR; } inline bool StateHistoryExists () const { return !m_state_history.isNull (); } inline QHistoryState* StateHistory () const { return StateHistoryExists () ? m_state_history.data () : Q_NULLPTR; } inline bool StateFinalExists () const { return !m_state_final.isNull (); } inline QFinalState* StateFinal () const { return StateFinalExists () ? m_state_final.data () : Q_NULLPTR; } inline bool StateErrorExists () const { return !m_state_error.isNull (); } inline FWState* StateError () const { return StateErrorExists () ? m_state_error.data () : Q_NULLPTR; } /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  IsValid       ///    . /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@note</span></span></span><span class="hljs-comment">       ,      ///     . /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">      : /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE    ; /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE     :     ///     c   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> SubscribeFinalSignal; /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> SubscribeFinalSignal /// virtual bool IsValid () const { return NOT_NULL(initialState ()); } virtual bool IsActive () const { return isRunning (); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  PostEvent    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent   *   . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> priority   . */ inline void PostEvent(FWEvent* aEvent, EventPriority priority = NormalPriority) { if(NOT_NULL(aEvent)) BaseClass::postEvent (aEvent-&gt;AsBaseClass (), priority) ; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  PostEvent    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEventType    *       . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEventType * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> priority */ inline void PostEvent(FWEvent::FWEventType aEventType, FWIdentificator aID, EventPriority priority = NormalPriority) { PostEvent (new FWEvent(aEventType,aID), priority) ; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  postDelayedEvent   *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QStateMachine::postDelayedEvent    *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent      c  *  . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aDelay    . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ,   ,  -1   *   . */ inline int PostDelayedEvent(FWEvent* aEvent, int aDelay) { if(NOT_NULL(aEvent)) return BaseClass::postDelayedEvent (aEvent-&gt;AsBaseClass (), aDelay) ; return -1; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> PostDelayedEvent * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEventType * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aDelay */ inline void PostDelayedEvent(FWEvent::FWEventType aEventType, FWIdentificator aID, int aDelay) { PostDelayedEvent(new FWEvent(aEventType,aID), aDelay) ; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  Configuration   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QStateMachine::configuration *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWState   . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWState . */ QSet&lt;FWState*&gt; Configuration() const; /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment">        /// @{ /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> AddBranch * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aSource * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aTarget * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> */ virtual bool AddBranch ( QState* aSource, QAbstractState* aTarget ) { if(NOT_NULL(aSource)) return aSource-&gt;addTransition(aTarget); return false; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> AddBranch * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEventType * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aSource * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aTarget * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> */ virtual bool AddBranch ( QEvent::Type aEventType, FWIdentificator aID, QState* aSource, QAbstractState* aTarget = Q_NULLPTR ); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> AddBranch * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEventType * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aSource * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aTarget * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> */ virtual bool AddBranch ( FWEvent::FWEventType aEventType, FWIdentificator aID, QState* aSource, QAbstractState* aTarget = Q_NULLPTR ); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> AddBranch * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aSource * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aTarget * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> */ virtual bool AddBranch ( FWEvent* aEvent, QState* aSource, QAbstractState* aTarget = Q_NULLPTR ); /// @} //---------------------------------------------------------------------------- protected: /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  Initialisation /// virtual void Initialisation (); //---------------------------------------------------------------------------- Q_SIGNALS: /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  sign_Paused       . /// void sign_Paused (); /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  sign_Resumed       . /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QStateMachine::started, QStateMachine::stopped /// void sign_Resumed (); //---------------------------------------------------------------------------- public Q_SLOTS: /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  slot_Pause       . /// void slot_Pause () { postEvent (new FWInternalEvent(FWInternalEvent::OEI_Pause)); } /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  slot_Resume       . /// void slot_Resume () { postEvent (new FWInternalEvent(FWInternalEvent::OEI_Resume)); } //---------------------------------------------------------------------------- protected Q_SLOTS: /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> slot_OnLoging /// virtual void slot_OnLoging () { qDebug() &lt;&lt; qPrintable(Q_FUNC_INFO); } /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> slot_OnError /// virtual void slot_OnError () { qDebug() &lt;&lt; qPrintable(Q_FUNC_INFO); } /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> slot_OnPaused /// virtual void slot_OnPaused () { qDebug() &lt;&lt; qPrintable(Q_FUNC_INFO); if(thread ()) thread ()-&gt;yieldCurrentThread (); emit sign_Paused(); } /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> slot_OnResume /// virtual void slot_OnResume () { qDebug() &lt;&lt; qPrintable(Q_FUNC_INFO); emit sign_Resumed(); } /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> slot_OnStop /// virtual void slot_OnStop () { qDebug() &lt;&lt; qPrintable(Q_FUNC_INFO); } /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> slot_OnDefaultHistoryChanged /// virtual void slot_OnDefaultHistoryChanged() { if(StateHistoryExists ()) if(NOT_NULL(StateHistory()-&gt;defaultState())) qDebug() &lt;&lt; "-H-" &lt;&lt; StateHistory()-&gt;defaultState()-&gt;objectName(); } }; //------------------------------------------------------------------------------ FW_END_NAMESPACE #endif // FWSTATEMACHINE_H</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">FWStateMachine.cpp</b> <div class="spoiler_text"><br><pre> <code class="hljs erlang-repl">#include <span class="hljs-string"><span class="hljs-string">"FWStateMachine.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"FWTransition.h"</span></span> #include &lt;QDebug&gt; FW_USING_NAMESPACE //------------------------------------------------------------------------------ FWStateMachine::FWStateMachine(QObject* aParent) : BaseClass (aParent) , m_state_group (Q_NULLPTR) , m_state_history (Q_NULLPTR) , m_state_final (Q_NULLPTR) , m_state_error (Q_NULLPTR) { Initialisation (); } //------------------------------------------------------------------------------ FWStateMachine::FWStateMachine(QState::ChildMode aChildMode, QObject* aParent) : FWStateMachine(aParent) { BaseClass::setChildMode (aChildMode); } //------------------------------------------------------------------------------ QSet&lt;FWState*&gt; FWStateMachine::Configuration() const { QSet&lt;FWState*&gt; _retval; QSet&lt;QAbstractState*&gt; _as = BaseClass::configuration (); Q_FOREACH(QAbstractState* _s, _as) _retval.operator += (qobject_cast&lt;FWState*&gt;(_s)); return _retval; } bool FWStateMachine::AddBranch(QEvent::Type aEventType, FWIdentificator aID, QState* aSource, QAbstractState* aTarget) { if(NOT_NULL(aSource)) if(aSource-&gt;inherits(FW_CLASS_STR(FWState).toLatin1 ())) return qobject_cast&lt;FWState*&gt;(aSource)-&gt;addTransition(aEventType, aID, aTarget); return false; } bool FWStateMachine::AddBranch(FWEvent::FWEventType aEventType, FWIdentificator aID, QState* aSource, QAbstractState* aTarget) { if(NOT_NULL(aSource)) { if(aSource-&gt;inherits(FW_CLASS_STR(FWState).toLatin1 ())) return qobject_cast&lt;FWState*&gt;(aSource)-&gt;addTransition(aEventType, aID, aTarget); else { QEventTransition* t = new QEventTransition( (QObject*)aID, static_cast&lt;QEvent::Type&gt;(aEventType), aSource); if(NOT_NULL(aTarget)) t-&gt;setTargetState(aTarget); return true; } } return false; } bool FWStateMachine::AddBranch(FWEvent* aEvent, QState* aSource, QAbstractState* aTarget) { if(NOT_NULL(aSource)) { if(aSource-&gt;inherits(FW_CLASS_STR(FWState).toLatin1 ())) return qobject_cast&lt;FWState*&gt;(aSource)-&gt;addTransition(aEvent, aTarget); else { QEventTransition* t = new QEventTransition( (QObject*)(aEvent-&gt;Identificator()), aEvent-&gt;type(), aSource); if(NOT_NULL(aTarget)) t-&gt;setTargetState(aTarget); return true; } } return false; } //------------------------------------------------------------------------------ void FWStateMachine::Initialisation() { bool v_active = IsActive (); if(v_active) stop (); /// @name     /// @{ if(!StateGroupExists ()) m_state_group.reset (new FWState(this)); FWState* sIdle = new FWState(StateGroup ()); StateGroup ()-&gt;setInitialState (sIdle); /// @} /// @name       /// @{ if(!StateHistoryExists ()) m_state_history.reset (new QHistoryState(QHistoryState::DeepHistory,StateGroup ())); ///    ,   ,    ///   - @sa m_state_group,    ///    ,    . StateHistory ()-&gt;setHistoryType (QHistoryState::DeepHistory); /// @} /// @name  z    /// @{ if(!StateFinalExists ()) m_state_final.reset (new QFinalState(this)); StateFinal()-&gt;setObjectName(<span class="hljs-string"><span class="hljs-string">"State FINAL"</span></span>); /// @} /// @name     /// @{ if(!StateErrorExists ()) m_state_error.reset (new FWState(this)); /// @} /// @name       /// @{ AddBranch(FWEvent::ET_INTERNAL,FWInternalEvent::OEI_Stop, StateGroup (), StateFinal ()); AddBranch(FWEvent::ET_INTERNAL,FWInternalEvent::OEI_Error, StateGroup (), StateError ()); /// @} /// @name       /// @{ FWState* sPause = new FWState(this); AddBranch(FWEvent::ET_INTERNAL,FWInternalEvent::OEI_Pause, StateGroup (), sPause); AddBranch(FWEvent::ET_INTERNAL,FWInternalEvent::OEI_Resume, sPause, StateHistory ()); /// @} /// @name      /// @{ AddBranch(StateError (), StateFinal ()); /// @} /// @name       /// @{ connect( sPause,&amp;FWState:: entered, this, &amp;FWStateMachine:: slot_OnPaused, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); connect( sPause,&amp;FWState:: exited, this, &amp;FWStateMachine:: slot_OnResume, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); connect( StateFinal (),&amp;QFinalState:: entered, this, &amp;FWStateMachine:: slot_OnStop, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); connect( StateError (),&amp;FWErrorState:: entered, this, &amp;FWStateMachine:: slot_OnError, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); connect( StateHistory(),&amp;QHistoryState::defaultStateChanged, this, &amp;FWStateMachine::slot_OnDefaultHistoryChanged, Qt::ConnectionType(Qt::DirectConnection | Qt::UniqueConnection)); /// @} if(NOT_EQUAL(initialState (),StateGroup ())) setInitialState (StateGroup ()); StateGroup ()-&gt; setObjectName(<span class="hljs-string"><span class="hljs-string">"State GROUP"</span></span>); StateHistory ()-&gt; setObjectName(<span class="hljs-string"><span class="hljs-string">"State HISTORY"</span></span>); StateError()-&gt; setObjectName(<span class="hljs-string"><span class="hljs-string">"State ERROR"</span></span>); StateFinal()-&gt; setObjectName(<span class="hljs-string"><span class="hljs-string">"State FINAL"</span></span>); sPause-&gt; setObjectName(<span class="hljs-string"><span class="hljs-string">"State PAUSE"</span></span>); sIdle-&gt; setObjectName(<span class="hljs-string"><span class="hljs-string">"State IDLE"</span></span>); if(v_active) start (); } //------------------------------------------------------------------------------</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">FWTransition.h</b> <div class="spoiler_text"><br><pre> <code class="hljs ruby"><span class="hljs-comment"><span class="hljs-comment">#ifndef FW_TRANSITION_H #define FW_TRANSITION_H #include &lt;FWEvent&gt; #include &lt;QSignalTransition&gt; FW_BEGIN_NAMESPACE //------------------------------------------------------------------------------ class FWState; class FWStateMachine; //------------------------------------------------------------------------------ /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWTransition      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWState ///    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWStateMachine. ///    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QEventTransition. /// class #ifdef FW_LIBRARY FW_SHARED_EXPORT #else Q_DECL_EXPORT #endif FWTransition : public QAbstractTransition { Q_OBJECT Q_CLASSINFO("brief", "Exlusive Finite-state Class") Q_CLASSINFO("created", "03-JUN-2015") Q_CLASSINFO("modified", "24-JUN-2015") // Q_CLASSINFO("project", "Common Qt-based Framework") Q_PROPERTY(FWIdentificator eventID READ EventID WRITE SetEventID NOTIFY sign_EventIDChanged) Q_PROPERTY(QEvent::Type eventType READ EventType WRITE SetEventType NOTIFY sign_EventTypeChanged) //---------------------------------------------------------------------------- /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment">   . /// @{ ///        /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QEventTransition typedef QAbstractTransition BaseClass; /// @} Q_ENUMS(TransitionState) //---------------------------------------------------------------------------- public: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  TransitionState    . */ enum TransitionState { UndefinedState, ///&lt;    SignalState, ///&lt;     EventState, ///&lt;     ErrorState ///&lt;    }; //---------------------------------------------------------------------------- private: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_event     *  . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> FWIdentificator, QEvent, QEvent::Type. */ QEvent::Type m_event_type; /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_event_id c    *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent.      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWSignalEvent, *       ,   *  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWIdentificator  FWIdentificator(&lt;QObject*&gt;). * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> FWTransition::Object, FWTransition::ObjectExists. */ FWIdentificator m_event_id; /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  m_state    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> TransitionState */ TransitionState m_state; //---------------------------------------------------------------------------- public: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWTransition    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QAbstractTransition::QAbstractTransition. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aSourceState      . */ explicit FWTransition(FWState* aSourceState = Q_NULLPTR); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWTransition     *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent::FWEvent * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent   ,  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aSourceState      . * * "see FWIdentificator, FWEvent, FWState. */ explicit FWTransition(QEvent* aEvent, FWState* aSourceState = Q_NULLPTR); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWTransition     *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QEvent::Type. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEventType  ,  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID  ,  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aSourceState      . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QEvent, FWEvent, FWState, QState. */ explicit FWTransition(QEvent::Type aEventType, FWIdentificator aID, FWState* aSourceState = Q_NULLPTR); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWTransition     *    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent::FWEventType. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEventType  ,  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID  ,  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aSourceState      . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QEvent, FWEvent, FWState, QState. */ explicit FWTransition(FWEvent::FWEventType aEventType, FWIdentificator aID, FWState* aSourceState = Q_NULLPTR) : FWTransition(static_cast&lt;QEvent::Type&gt;(aEventType), aID, aSourceState) {} /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWTransition     *   (   )  * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent::ET_INTERNAL. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID  ,  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aSourceState      . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QEvent, FWEvent, FWState, QState. */ explicit FWTransition(FWInternalEvent::FWInternalIdentificators aID, FWState* aSourceState = Q_NULLPTR) : FWTransition(static_cast&lt;QEvent::Type&gt;(FWEvent::ET_INTERNAL),aID, aSourceState) {} // explicit // FWTransition(QObject* aSender, // const char* aSignalName, // QObject* aRessiver, // const char* aSlotName, // FWState* aSourceState = Q_NULLPTR); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  AsBaseClass       . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">         . */ inline BaseClass* AsBaseClass () { return qobject_cast&lt;BaseClass*&gt;(this); } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  EventType     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QEvent::Type. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">   . */ inline QEvent::Type EventType () const { return m_event_type; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  SetEventType     . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aType    . */ inline void SetEventType (const QEvent::Type aType) { if(NOT_EQUAL(EventType (),aType)) { m_event_type = aType; emit sign_EventTypeChanged (EventType ()); } } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  Identificator   ,  *   . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWIdentificator. */ inline FWIdentificator EventID () const { return m_event_id; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  setEventID    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_id  *  . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID       . */ inline void SetEventID (const FWIdentificator aID) { if(NOT_EQUAL(EventID (),aID)) { m_event_id = aID; emit sign_EventIDChanged (EventID ()); } } FWStateMachine* Machine () const; inline bool operator == (const FWTransition&amp; aOther) { return EQUAL(EventType (), aOther.EventType ()) &amp;&amp; EQUAL(EventID (), aOther.EventID ()) &amp;&amp; EQUAL(sourceState (), aOther.sourceState()) &amp;&amp; EQUAL(targetState (), aOther.targetState()); } //---------------------------------------------------------------------------- protected: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  SetState      . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aState        * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> TransitionState */ virtual void SetState (TransitionState aState) { if(m_state != aState) m_state = aState; } /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  FWTransition::eventTest    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> QEventTransition::eventTest     *     . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent    . * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment">   : * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> TRUE  ,  ; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@value</span></span></span><span class="hljs-comment"> FALSE  ,   . * *     - . ,    *   ,      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWEvent. *  :  ,   "" * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> StateMachine::WrappedEvent  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> StateMachine::SignalEvent; * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QEvent, QEvent::Type. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> QStateMachine, QStateMachine::WrappedEvent QStateMachine::SignalEvent. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> FWEvent, FWEvent::Machine */ bool eventTest(QEvent* aEvent) Q_DECL_OVERRIDE; /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  onTransition * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aEvent */ void onTransition(QEvent* aEvent) Q_DECL_OVERRIDE; //---------------------------------------------------------------------------- Q_SIGNALS: /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment"> sign_EventTypeChanged * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aType */ void sign_EventTypeChanged (const QEvent::Type aType); /** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  sign_eventIDChanged     *     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_id. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aID    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> m_id. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> FWIdentificator */ void sign_EventIDChanged (const FWIdentificator aID); /// /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@brief</span></span></span><span class="hljs-comment">  sign_Transiting     /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aSource   -,    /// ; /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aTarget    - ; /// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> aTransition     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@sa</span></span></span><span class="hljs-comment"> FWTransition,  ///   . /// void sign_Transiting (QState* aSource, QAbstractState* aTarget, QAbstractTransition* aTransition); }; //------------------------------------------------------------------------------ FW_END_NAMESPACE #endif // FWTRANSITION_H</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">FWTransition.cpp</b> <div class="spoiler_text"><br><pre> <code class="hljs erlang-repl">#include <span class="hljs-string"><span class="hljs-string">"FWTransition.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"FWState.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"FWStateMachine.h"</span></span> FW_USING_NAMESPACE //------------------------------------------------------------------------------ FWTransition::FWTransition(FWState* aSourceState) : BaseClass (aSourceState) { SetState(UndefinedState); SetEventID (EMPTY_ID); SetEventType (static_cast&lt;QEvent::Type&gt;(QEvent::None)); } //------------------------------------------------------------------------------ FWTransition::FWTransition(QEvent* aEvent, FWState* aSourceState) : FWTransition(aSourceState) { if(NOT_NULL(aEvent)) { if(!FWEvent::IsSystem (aEvent)) { SetState(EventState); SetEventID (static_cast&lt;FWEvent*&gt;(aEvent)-&gt;Identificator ()); SetEventType (aEvent-&gt;type ()); } } else SetState(ErrorState); } //------------------------------------------------------------------------------ FWTransition::FWTransition(QEvent::Type aEventType, FWIdentificator aID, FWState* aSourceState) : FWTransition(aSourceState) { SetState (EventState); SetEventID (aID); SetEventType(aEventType); } //------------------------------------------------------------------------------ //FWTransition::FWTransition(QObject* aSender, // const char* aSignalName, // QObject* aRessiver, // const char* aSlotName, // FWState* aSourceState) // : FWTransition (aSourceState) //{ // SetState(SignalState); // SetEventID (FWIdentificator (aSender)); // SetEventType (static_cast&lt;QEvent::Type&gt;(FWEvent::ET_GLOBAL)); // if(NOT_NULL(aSender) &amp;&amp; NOT_NULL(aRessiver)) // { // int v_offset = *aSignalName == <span class="hljs-string"><span class="hljs-string">'0'</span></span>+QSIGNAL_CODE ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; // int v_signal_index = // aSender-&gt;metaObject ()-&gt;indexOfSignal ( // QMetaObject::normalizedSignature (aSignalName+v_offset)); // v_offset = *aSlotName == <span class="hljs-string"><span class="hljs-string">'0'</span></span>+QSLOT_CODE ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; // int v_slot_idx = // aRessiver-&gt;metaObject ()-&gt;indexOfSlot ( // QMetaObject::normalizedSignature (aSlotName+v_offset)); // if(QMetaObject::connect (aSender, v_signal_index, // aRessiver, v_slot_idx, // Qt::DirectConnection)) // { // aRessiver-&gt;setParent (Q_NULLPTR); // aRessiver-&gt;moveToThread (thread ()); // } // else // SetState(ErrorState); // } //} //------------------------------------------------------------------------------ FWStateMachine* FWTransition::Machine() const { return qobject_cast&lt;FWStateMachine*&gt;(machine ()); } //------------------------------------------------------------------------------ bool FWTransition::eventTest(QEvent* aEvent) { bool v_retval = FWEvent::IsValid (aEvent); if(v_retval) v_retval = EQUAL(aEvent-&gt;type (),EventType ()); if(v_retval) { FWEvent* v_e = static_cast&lt;FWEvent*&gt;(aEvent); v_retval = EQUAL(v_e-&gt;type (), EventType ()) &amp;&amp; EQUAL(v_e-&gt;Identificator (),EventID ()); } return v_retval; } //------------------------------------------------------------------------------ void FWTransition::onTransition(QEvent* aEvent) { aEvent-&gt;accept(); // qDebug() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"-T- "</span></span> + // sourceState ()-&gt;objectName() + // <span class="hljs-string"><span class="hljs-string">" --&gt;&gt; "</span></span> + // targetState()-&gt;objectName(); emit sign_Transiting (sourceState (),targetState (), this-&gt;AsBaseClass()); } //------------------------------------------------------------------------------</code> </pre><br></div></div><br><br>  ,            ‚Ä¶ - . <br><br>  Thank. </div><p>Source: <a href="https://habr.com/ru/post/261955/">https://habr.com/ru/post/261955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261941/index.html">Beginner site optimization guide. Part 2</a></li>
<li><a href="../261943/index.html">We pononet a bit: it became clearer what will happen to personal data after September 1, 2015</a></li>
<li><a href="../261945/index.html">Comparative test of popular antivirus software from the developer of cyber weapons Hacking Team</a></li>
<li><a href="../261951/index.html">We are pumping JavaScript using TurboFan</a></li>
<li><a href="../261953/index.html">Vundervaflya with one button</a></li>
<li><a href="../261957/index.html">Remote control via Ethernet: M2M technology using a combination of KBX-3D and Laurent-2 modules</a></li>
<li><a href="../261959/index.html">TEST Labs 2015. Online conference for testers and test managers. July 25</a></li>
<li><a href="../261961/index.html">How are converged infrastructure and online trading connected: New Juniper project</a></li>
<li><a href="../261963/index.html">Biomasterskaya: A new look at the biological sciences as an engineering discipline</a></li>
<li><a href="../261967/index.html">Exam 70-485 Advanced Windows Store App Development Using C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>