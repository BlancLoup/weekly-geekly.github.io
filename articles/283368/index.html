<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Komonada, she is like a monad, only komonad</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I mean the reader knows Haskell, at least before the monads. 


 Monad is a type class that allows (informally speaking) of functions that return some...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Komonada, she is like a monad, only komonad</h1><div class="post__text post__text-html js-mediator-article"><p>  I mean the reader knows Haskell, at least before the monads. </p><br><p>  <b>Monad</b> is a type class that allows (informally speaking) of functions that return something like <b>MyMonad Something</b> to perform certain functions that interact with a monad.  Functions that use monads need to be linked together by special functions <b>(&gt;&gt;)</b> , <b>(&gt;&gt; =)</b> , <b>(= &lt;&lt;)</b> . <br>  So, <b>Comonad</b> is also a type class that allows functions to interact with the effects of a comonad, only for these functions the comonad is not specified in the returned type, but in the argument. <a name="habracut"></a>  It does not interfere with specifying the same or different comonads in each argument, and even the monad in the return value. </p><br><p>  For a bunch of comonad expressions, special functions are also used - <b>(= &gt;&gt;)</b> , <b>(&lt;&lt; =)</b> , <b>(=&gt; =)</b> , <b>(= &lt;=)</b> with their own nuances. </p><br><p>  In general, there is a similarity between monads and comonads, and their application can be combined. </p><br><p>  In order that it becomes clear we solve a practical example, we will write a mini library to calculate and display the histogram. <br>  Although the task is not very large, we will divide it into parts: </p><br><ul><li>  the main part (histogram engine), i.e.  payment; </li><li>  The implementation of the storage and accumulation of histogram data; </li><li>  histogram display (terminal output). </li></ul><br><h2>  Histogram engine </h2><br><p>  And so, the calculation.  There will be neither monads, nor komonads, but it is important.  As a result of the preliminary calculation, a function of the type will be formed </p><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CalcPos</span></span></span><span class="hljs-class"> x = x -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span></span></code> </pre> <br><p>  For a given initial value, it is the determining number of the histogram pocket, to which one should be added (how the histogram is calculated, and that, it is actually easy to <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0">navigate</a> ).  If the original number is out of the specified range, the function returns <b>Nothing</b> . </p><br><p>  The entire result of the preliminary calculation for the given source data will be stored in the structure </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HistoEngine</span></span></span><span class="hljs-class"> x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HistoEngine</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">low</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--    , step :: x --   , size :: Int -- -   , calcPos :: CalcPos x }</span></span></span></span></code> </pre><br><p>  The remaining fields of the record do not need the functions of <strong>calcPos</strong> , it will receive all the data it needs when creating through closures, but other fields may be required in other cases. </p><br><p>  The <strong>mkHistoEngine</strong> function is where the construction of the histogram begins.  We take the lower and upper limits of the analyzed range and the number of histogram pockets as the initial data.  The <strong>mkHistoEngine</strong> function fills in and returns <strong>HistoEngine</strong> , including <strong>calcPos</strong> given by lambda. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mkHistoEngine</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> x, <span class="hljs-type"><span class="hljs-type">Ord</span></span> x, <span class="hljs-type"><span class="hljs-type">RealFrac</span></span> x) =&gt; x -&gt; x -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">HistoEngine</span></span> x</code> </pre> <br><p>  (the definition of the function is trivial and will be given below, in full code). </p><br><p>  Based on the principle of encapsulation ( <strong><em>Gabriel Gonzalez</em></strong> , for example, assumes that <a href="http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html">comonads are objects</a> , so we don‚Äôt disregard one of the principles of the PLO).  It would be possible to bring all the above code into a separate module, providing outside access to <strong>HistoEngine</strong> without its internal content.  But then we have to provide functions to get the values ‚Äã‚Äãof some of the <strong>HistoEngine</strong> fields. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">histoEngPosFn</span></span>:: <span class="hljs-type"><span class="hljs-type">HistoEngine</span></span> x -&gt; <span class="hljs-type"><span class="hljs-type">CalcPos</span></span> x histoEngPosFn = calcPos histoEngSize:: <span class="hljs-type"><span class="hljs-type">HistoEngine</span></span> x -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> histoEngSize = size</code> </pre> <br><p>  In the future, you will need to display the histogram scale.  Instead of creating access functions for a couple of fields, it is advisable to form the scale values ‚Äã‚Äãimmediately. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">gistoXList</span></span>:: (<span class="hljs-type"><span class="hljs-type">RealFrac</span></span> x, <span class="hljs-type"><span class="hljs-type">Enum</span></span> x) =&gt; <span class="hljs-type"><span class="hljs-type">HistoEngine</span></span> x -&gt; [x] gistoXList <span class="hljs-type"><span class="hljs-type">HistoEngine</span></span>{..} = take size [low+ step*<span class="hljs-number"><span class="hljs-number">0.5</span></span>,(low + step*<span class="hljs-number"><span class="hljs-number">1.5</span></span>)..]</code> </pre><br><p>  (I used the <strong>RecordWildCards</strong> extension for this {..}). <br>  However, where is the komonad?  It's time to go to them. </p><br><h2>  Bar graph as comonad </h2><br><p>  Komonada will be in the example of the role of a link between the calculation, storage and display.  The type of her data I made </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Histogram</span></span></span><span class="hljs-class"> xa = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Histogram</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HistoEngine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HistoEngine</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span></span></code> </pre><br><p>  Not every type is suitable for creating a comonad.  Not necessarily the same as above: the value and function of this value in an arbitrary type.  But the type must allow some recursion with it.  In this case, you can recursively call the function <strong>HistoEngine x -&gt; a</strong> .  In other cases, they use recursive data types - lists, trees. </p><br><p>  And so, we make <strong>Histogram</strong> type comonad </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Comonad</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Histogram</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract (<span class="hljs-type"><span class="hljs-type">Histogram</span></span> fx) = fx duplicate (<span class="hljs-type"><span class="hljs-type">Histogram</span></span> fx) = <span class="hljs-type"><span class="hljs-type">Histogram</span></span> (<span class="hljs-type"><span class="hljs-type">Histogram</span></span> f) x</code> </pre> <br><p>  It's all. </p><br><p>  The function <strong>extract :: wa -&gt; a</strong> (where <strong>w</strong> is a comonad, the letter <strong>w</strong> , the accepted notation for comonads is <strong>m</strong> upside down) corresponds to <strong>return</strong> in the monad, but does the opposite, returns a value from the comonade.  In some articles, it was called <strong>coreturn</strong> (to call it <strong>nruter</strong> , it seems, no one thought of it). <br>  This feature will continue to be used directly.  Unlike the function <strong>duplicate :: wa -&gt; w (wa)</strong> , which corresponds to the monads <strong>join :: (Monad m) =&gt; m (ma) -&gt; ma</strong> , only, again, with the opposite meaning.  <strong>Join</strong> deletes one monad layer, and <strong>duplicate</strong> duplicates the comonade layer.  Calling it directly further will not be encountered, but <strong>duplicate</strong> is called inside other functions of the <strong>comonad</strong> package, in particular, in <strong>extend :: (wa -&gt; b) -&gt; wa -&gt; wb</strong> .  Actually, a comonad can be defined both through <strong>extract</strong> , <strong>duplicate</strong> (and <strong>Functor</strong> ), and through <strong>extract</strong> , <strong>extend</strong> , depending on how convenient it is. </p><br><p>  And so, the komonad itself is ready.  Go to the next step. </p><br><h2>  What to store </h2><br><p>  We will store the accumulated values ‚Äã‚Äã(cells or histogram pockets) in an unbutable vector.  Connect </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> VU <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed.Mutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> VUM</code> </pre><br><p>  And write </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HistoCounter</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VU</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vector</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Histo</span></span></span><span class="hljs-class"> x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Histogram</span></span></span><span class="hljs-class"> x </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HistoCounter</span></span></span></span></code> </pre> <br><p>  It's time to write a function that creates the original comonad-histogram with empty cells. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mkHisto</span></span>:: (<span class="hljs-type"><span class="hljs-type">Show</span></span> x, <span class="hljs-type"><span class="hljs-type">Ord</span></span> x, <span class="hljs-type"><span class="hljs-type">RealFrac</span></span> x) =&gt; x -&gt; x -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Histo</span></span> x mkHisto lo hi sz = <span class="hljs-type"><span class="hljs-type">Histogram</span></span> (\e -&gt; <span class="hljs-type"><span class="hljs-type">VU</span></span>.replicate (histoEngSize e) <span class="hljs-number"><span class="hljs-number">0</span></span>) $ mkHistoEngine lo hi sz</code> </pre><br><p>  It's simple.  We describe a lambda function that <strong>selects a</strong> vector of a given size filled with zeros and use the previously created <strong>mkHistoEngine</strong> to create a <strong>HistoEngine</strong> .  The <strong>mkHisto</strong> parameters <strong>are</strong> simply passed to <strong>mkHistoEngine</strong> . </p><br><p>  Now we will write the function of accumulation of readings in the histogram. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">histoAdd</span></span>:: x -&gt; <span class="hljs-type"><span class="hljs-type">Histo</span></span> x -&gt; <span class="hljs-type"><span class="hljs-type">HistoCounter</span></span> histoAdd xh@(<span class="hljs-type"><span class="hljs-type">Histogram</span></span> _ e) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> histoEngPosFn ex <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> i -&gt; <span class="hljs-type"><span class="hljs-type">VU</span></span>.modify (\v -&gt; <span class="hljs-type"><span class="hljs-type">VUM</span></span>.modify v (+<span class="hljs-number"><span class="hljs-number">1</span></span>) i) (extract h) <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; extract h</code> </pre><br><p>  Let me remind you that if a monad function has a monad indicated in the type of result of the function, then in the comonad function it is indicated in the argument.  With the help of <strong>histoEngPosFn,</strong> we get a function of type <strong>CalcPos</strong> created in <strong>mkHistoEngine</strong> .  Depending on its result, we increase by one the corresponding cell of the vector or return the vector unchanged.  The vector itself is obtained by <strong>extract h</strong> . </p><br><p>  In order not to attach the histogram display algorithm to its storage and accumulation, let us assume that for display it must be represented by a list.  This is valid, because the list will be processed fewer times and always sequentially to display.  (The method of storing the histogram during accumulation can be changed, for example, to a more efficient mutable vector, but this should not lead to changes in the display functions of the histogram). </p><br><p>  And so, the komonadnaya function to convert the representation of the data of the histogram from the vector to the list.  She is also trivial. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">histoToList</span></span>:: <span class="hljs-type"><span class="hljs-type">Histo</span></span> x -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] histoToList = <span class="hljs-type"><span class="hljs-type">VU</span></span>.toList . extract</code> </pre> <br><h2>  Display the result in the terminal </h2><br><p>  I used the histogram output horizontally, when its bars are on its side. <br>  The function definition is given below, in full code.  Note that the function uses both a komonad (in the argument, of course), and a monad (of course, in the output value). </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">histoHorizPrint</span></span>:: (<span class="hljs-type"><span class="hljs-type">RealFloat</span></span> x, <span class="hljs-type"><span class="hljs-type">Enum</span></span> x) =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Histogram</span></span> x [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> ()</code> </pre> <br><p>  Its arguments are: the width of the output field, the width of the field for displaying the values ‚Äã‚Äãof the scale of the initial value and, of course, the comonade.  Now with data in the form of <strong>[Int]</strong> instead of <strong>VU.Vector Int</strong> . </p><br><h2>  Putting it all together </h2><br><p>  As test data, we will simply generate a sequence of sinusoidal samples. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">map</span></span> sin [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0.01</span></span> .. <span class="hljs-number"><span class="hljs-number">314.15</span></span>]</code> </pre> <br><p>  The histogram will be accumulated in the usual list <strong>foldl</strong> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldl</span></span> f (mkHisto (<span class="hljs-number"><span class="hljs-number">-1</span></span>::<span class="hljs-type"><span class="hljs-type">Double</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>) (map sin [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0.01</span></span> .. <span class="hljs-number"><span class="hljs-number">314.16</span></span>])</code> </pre><br><p>  (The initial parameters of the histogram - range from -1 to +1, 20 pockets). </p><br><p>  But what will be the function <strong>f</strong> , which, for <strong>foldl,</strong> has the form <strong>(b -&gt; a -&gt; b)</strong> , where, in this case, <strong>b</strong> is a comonade, <strong>and</strong> is the next, accumulated count.  It turns out nothing complicated.  After all, we have already written the function <strong>histoAdd</strong> .  Just as for monads, you need auxiliary functions that look like arrows. <br>  And so, the whole test is in the function <strong>main</strong> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = histoHorizPrint <span class="hljs-number"><span class="hljs-number">65</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> $ histoToList &lt;&lt;= foldl (\ba -&gt; b =&gt;&gt; histoAdd a) (mkHisto (<span class="hljs-number"><span class="hljs-number">-1</span></span>::<span class="hljs-type"><span class="hljs-type">Double</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>) (map sin [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0.01</span></span> .. <span class="hljs-number"><span class="hljs-number">314.16</span></span>])</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Full code (need comonad and vector packages)</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DeriveFunctor, RecordWildCards #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Comonad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> VU <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed.Mutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> VUM <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Numeric type CalcPos x = x -&gt; Maybe Int data HistoEngine x = HistoEngine { low :: x <span class="hljs-comment"><span class="hljs-comment">--    , step :: x --   , size :: Int -- -   , calcPos :: CalcPos x } mkHistoEngine :: (Show x, Ord x, RealFrac x) =&gt; x -&gt; x -&gt; Int -&gt; HistoEngine x mkHistoEngine lo hi sz | sz &lt; 2 = error "mkHistoEngine : histogram size must be &gt;1" | lo&gt;=hi = error $ "mkHistoEngine : illegal diapazone " ++ show lo ++ " - " ++ show hi | otherwise = let stp = (hi-lo) / fromIntegral sz in HistoEngine lo stp sz (\x -&gt; let pos = truncate $ (x - lo) / stp in if pos&lt;0 || pos &gt;= sz then Nothing else Just pos) histoEngPosFn:: HistoEngine x -&gt; CalcPos x histoEngPosFn = calcPos histoEngSize:: HistoEngine x -&gt; Int histoEngSize = size gistoXList:: (RealFrac x, Enum x) =&gt; HistoEngine x -&gt; [x] gistoXList HistoEngine{..} = take size [low+ step*0.5,(low + step*1.5)..] -------------    ------------------------ data Histogram xa = Histogram (HistoEngine x -&gt; a) (HistoEngine x) deriving Functor instance Comonad (Histogram x) where extract (Histogram fx) = fx duplicate (Histogram fx) = Histogram (Histogram f) x ----------- -      histoHorizPrint:: (RealFloat x, Enum x) =&gt; Int -&gt; Int -&gt; Histogram x [Int] -&gt; IO () histoHorizPrint width numWidth h@(Histogram _ e) = let l = extract h mx = maximum l width' = width - numWidth - 1 k = fromIntegral width' / fromIntegral mx ::Double kPercent = (100 :: Double) / fromIntegral (sum l) showF w prec v = let s = showFFloat (Just prec) v "" in replicate (w - length s) ' ' ++ s in mapM_ (\(x,y)-&gt; do putStr $ showF numWidth 2 x putStr " " let w = truncate $ fromIntegral y * k putStr $ replicate w 'X' putStr $ replicate (width'-w+2) ' ' putStrLn $ showFFloat (Just 2) (fromIntegral y * kPercent) " %") $ zip (gistoXList e) l -------------       ---- type HistoCounter = VU.Vector Int type Histo x = Histogram x HistoCounter mkHisto:: (Show x, Ord x, RealFrac x) =&gt; x -&gt; x -&gt; Int -&gt; Histo x mkHisto lo hi sz = Histogram (\e -&gt; VU.replicate (histoEngSize e) 0) $ mkHistoEngine lo hi sz histoAdd:: x -&gt; Histo x -&gt; HistoCounter histoAdd xh@(Histogram _ e) = case histoEngPosFn ex of Just i -&gt; VU.modify (\v -&gt; VUM.modify v (+1) i) (extract h) Nothing -&gt; extract h histoToList:: Histo x -&gt; [Int] histoToList = VU.toList . extract -------------  main :: IO () main = histoHorizPrint 65 5 $ histoToList &lt;&lt;= foldl (\ba -&gt; b =&gt;&gt; histoAdd a) (mkHisto (-1::Double) 1 20) (map sin [0,0.01 .. 314.16])</span></span></code> </pre> </div></div><br><h2>  Komonadnye transformers </h2><br><p>  Just as for monads, for komonad there are transformers (although there are very few of them, but who prevents us from writing our own).  That is, komonads can be nested. </p><br><p>  Suppose we want to set the width of the field for outputting numbers at the very beginning, when we have just created an empty histogram. <br>  Connect another module </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Comonad.Env</code> </pre><br><p>  which implements a komonad within the meaning of the corresponding monad <strong>Reader</strong> . <br>  The example in the <strong>main</strong> function will now look like this. </p><br><pre> <code class="haskell hljs"> (\h-&gt; histoHorizPrint <span class="hljs-number"><span class="hljs-number">65</span></span> (ask h) (lower h)) $ (histoToList . lower) &lt;&lt;= foldl (\ba -&gt; b =&gt;&gt; (histoAdd a . lower)) (<span class="hljs-type"><span class="hljs-type">EnvT</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> (mkHisto (<span class="hljs-number"><span class="hljs-number">-1</span></span>::<span class="hljs-type"><span class="hljs-type">Double</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>)) (map sin [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0.01</span></span> .. <span class="hljs-number"><span class="hljs-number">314.16</span></span>])</code> </pre><br><p>  With the help of <strong>(EnvT 5 (...))</strong> we create another comonad layer and store the value 5 in it (the desired width for the field of numbers).  Since the comonadal expression is now a two-layer one, the use of our functions using the <strong>Histogram</strong> comonad requires the auxiliary function <strong>lower</strong> , just as in the monad transformers, <strong>lift is</strong> used to go to the previous layer. <br>  Also pay attention to extracting the value - <strong>(ask h)</strong> .  Well, what is not <strong>Reader</strong> ! <br>  The last example can also be written differently by disassembling two layers of comonads at the end (value, internal comonade) using the <strong>runEnvT</strong> function, the name of which boldly hints at the <strong>runReaderT</strong> used with <strong>ReaderT</strong> . </p><br><pre> <code class="haskell hljs"> (\(nw,h)-&gt; histoHorizPrint <span class="hljs-number"><span class="hljs-number">65</span></span> nw h) $ runEnvT $ (histoToList . lower) &lt;&lt;= foldl (\ba -&gt; b =&gt;&gt; (histoAdd a . lower)) (<span class="hljs-type"><span class="hljs-type">EnvT</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> (mkHisto (<span class="hljs-number"><span class="hljs-number">-1</span></span>::<span class="hljs-type"><span class="hljs-type">Double</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>)) (map sin [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0.01</span></span> .. <span class="hljs-number"><span class="hljs-number">314.16</span></span>])</code> </pre> <br><p>  Successes in komonadostroenii! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/283368/">https://habr.com/ru/post/283368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283358/index.html">CDN - New Video Broadcast Standard</a></li>
<li><a href="../283360/index.html">Update fixes security issues for all tools based on IntelliJ platform</a></li>
<li><a href="../283362/index.html">Film lover's best friend: rework CBS application for Android</a></li>
<li><a href="../283364/index.html">Using python Exscript library to work with Cisco and Huawei equipment over SSH</a></li>
<li><a href="../283366/index.html">7 deadly sins of a software project</a></li>
<li><a href="../283370/index.html">Mathematical model of perception (Part 3)</a></li>
<li><a href="../283376/index.html">Akamai Content Delivery Network made available to Azure users</a></li>
<li><a href="../283378/index.html">django-pkgconf</a></li>
<li><a href="../283380/index.html">Facebook has laid out its CTF platform on Github - Facebook CTF</a></li>
<li><a href="../283382/index.html">Big Jackpot: Why hackers attack SWIFT financial transfer system</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>