<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Counts for the smallest: BFS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous post, it was told about traversing the graph in depth. Today I would like to tell you about a no less important algorithm of graph the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Counts for the smallest: BFS</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/200074/">previous post, it was</a> told about traversing the graph in depth.  Today I would like to tell you about a no less important algorithm of graph theory - about a wide bypass. <br>  Last time, we learned to look for <u>some</u> way through the maze.  Anyone wishing to find the <u>shortest</u> path please under the cat. <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4>  It is required to find a path from one vertex of the graph to another, and the path must be minimal in the number of edges. <br><br><h4>  Algorithm Description </h4><img src="https://habrastorage.org/getpro/habr/post_images/58d/44c/98c/58d44c98c62f9c5107bd2da0d1850b9a.gif" align="right">  Intuitively, we would like to consider the graph vertices in the order of increasing the distance from the original one, as shown in the figure. <br>  Divide all vertices into three sets: <br><ul><li>  Fully machined vertices (initially the set is empty, shown in black in the figure) </li><li>  Vertices to which the distance is known (initially there is only one vertex in the set ‚Äî the initial one, shown in gray in the figure) </li><li>  Vertices, about which nothing is known (initially - all vertices, except the initial one, are marked in white in the figure) </li></ul><br>  Obviously, as soon as all the vertices are black, the work of the algorithm is completed.  We will store all gray vertices in the queue and maintain the following property: the distances to all gray vertices in the order in which they lie in the queue do not monotonously decrease. <br>  We get the first vertex from the queue (we denote it by v).  For each of its neighbors, w, one of two options is possible: <br><ol><li>  w - black or gray top.  In this case, we do not receive any new information. </li><li>  w - white top.  Then the distance to it is d (w) = d (v) + 1. And, since we learned the distance, w becomes a gray vertex </li></ol><br>  Repeat as long as there is at least one gray vertex. <br><br><h4>  Implementation </h4>  It is assumed that the graph is stored in an array of vector &lt;vector &lt;int &gt;&gt; edges, and edges [v] contains the numbers of all the vertices to which there is an edge from v.  It is also assumed that the global variable start contains the number of the initial vertex. <br><div class="spoiler">  <b class="spoiler_title">Bfs</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BFS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; q; <span class="hljs-comment"><span class="hljs-comment">// :      q.push(start); d[start] = 0; mark[start] = 1; //   -     while (!q.empty()) { //     int v = q.front(); q.pop(); //      for (int i = 0; i &lt; (int)edges[v].size(); ++i) { //    if (mark[edges[v][i]] == 0) { //    d[edges[v][i]] = d[v] + 1; //     mark[edges[v][i]] = 1; q.push(edges[v][i]); } } } }</span></span></code> </pre> <br></div></div><br><h4>  Why does this work? </h4>  Consider any vertex v reachable from the initial one.  Let p [0] = start, p [1], ..., p [k] = v be the shortest path from the initial vertex to the vertex v.  Then the resulting value of the algorithm d [v] = k. <br>  Evidence: <br><ol><li>  d [v] ‚â§ k <ul><li>  Base: vertex p [0] = start is visited by the algorithm, and d [p [0]] = 0 </li><li>  Assumption: the vertex p [i - 1] is visited by the algorithm, with d [p [i]] ‚â§ i </li><li>  Step: when considering the vertex p [i - 1] (and perhaps earlier), the edge leading to the vertex p [i] will be considered.  Thus, d [p [i]] ‚â§ i </li></ul></li><li>  d [v] ‚â• k <br>  Suppose that d [v] &lt;k.  Consider the vertex v;  that vertex, when considering which the vertex v was colored gray (we denote it by w);  that vertex, on consideration of which vertex w was colored gray; ...;  start start.  Every two adjacent vertices in this sequence are connected by an edge according to the construction of the algorithm.  Thus, we found a path from the start vertex to the vertex v of length less than k ‚Äî a contradiction, therefore, d [v] ‚â• k </li></ol><br><h4>  Algorithm complexity </h4>  For each edge and each vertex, the algorithm performs a constant number of actions, therefore, the time complexity is O (V + E). <br>  The maximum number of vertices simultaneously stored in the queue is V, that is, the maximum amount of memory used is O (V). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Instead of conclusion </h4>  In this article, we found the shortest path through the maze using one of the most well-known graph theory algorithms - BFS. <br>  Next time I will try to consider a more complex task based on our favorite maze and, in her example, tell Dijkstra's algorithm. </div><p>Source: <a href="https://habr.com/ru/post/200252/">https://habr.com/ru/post/200252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../200236/index.html">Children's launcher and parental control</a></li>
<li><a href="../200238/index.html">We use the tablet as a second monitor to develop</a></li>
<li><a href="../200244/index.html">Using Docker Containers as Jenkins Nod</a></li>
<li><a href="../200246/index.html">Serialization of Judy integer arrays in PHP</a></li>
<li><a href="../200248/index.html">Designing a secure messaging application together.</a></li>
<li><a href="../200254/index.html">Vertica again on HighLoad ++</a></li>
<li><a href="../200256/index.html">Candid photos of Jennifer Lawrence and dozens of other celebrities leaked through iCloud</a></li>
<li><a href="../200260/index.html">We extend security updates for Windows XP for another 5 years.</a></li>
<li><a href="../200262/index.html">5-year-old kid hacked Xbox Live authorization</a></li>
<li><a href="../200264/index.html">Canadian special services monitor travelers using Wi-Fi hotspots at airports and cafes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>