<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to stop being afraid and fall in love with mbed [Part 4]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue a series of publications devoted to the use of the ARM mbed environment for creating a prototype measuring device. Today we are talking ab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to stop being afraid and fall in love with mbed [Part 4]</h1><div class="post__text post__text-html js-mediator-article">  We continue a series of publications devoted to the use of the ARM mbed environment for creating a prototype measuring device.  Today we are talking about the basics of working with touch input. <br><br><img src="https://habrastorage.org/files/55e/c71/273/55ec712733fd42be86172aef4b09690f.gif" width="500"><br><br>  Content of the publication cycle: <br><ol><li>  <a href="https://habrahabr.ru/company/efo/blog/308440/">[Part 1] Overview of the used software and hardware solutions.</a> </li><li>  <a href="https://habrahabr.ru/company/efo/blog/309918/">[Part 2] Getting Started with the FT800 Graphics Controller.</a>  <a href="https://habrahabr.ru/company/efo/blog/309918/">Use of ready mbed-libraries for peripheral devices.</a> </li><li>  <a href="https://habrahabr.ru/company/efo/blog/310058/">[Part 3] Connecting the sensor HYT-271.</a>  <a href="https://habrahabr.ru/company/efo/blog/310058/">Create and publish in mbed your own library for peripherals.</a> </li><li>  <b>[Part 4] Application development: Program structure, working with a touch screen.</b> </li><li>  <a href="https://habrahabr.ru/company/efo/blog/311816/">[Part 5] Application development: Display images, Russification problems.</a> </li><li>  <a href="https://habrahabr.ru/company/efo/blog/312484/">[Part 6] Printing Body Parts</a> </li></ol><a name="habracut"></a><br>  Following the results of the previous three articles, we received an mbed-project - a program that can be compiled into a working firmware for any <a href="https://developer.mbed.org/platforms/">debugging board</a> with SPI and I2C interfaces and support in ARM mbed.  The test subjects were debug boards from SLSTK3400A from Silicon Labs, ATSAMD21-XPRO from Atmel and WIZwiki-W7500P from Wiznet. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/40d/536/4d5/40d5364d5c544c05906b68c5459faafe.png"><br><br>  The implemented program performs two tasks so far - polling the temperature and relative humidity sensor HYT and outputting the measurement results to a Riverdi TFT-display.  The project is available <a href="">at developer.mbed.org</a> . <br><br>  Today we are starting to expand the base project - instead of a single working screen, a menu and several subsections will appear, between which you can switch using the touch interface. <br><br><h1>  1. The structure of the TFT module </h1><hr><br>  So, the Riverdi TFT module used consists of the actual display, the FT8xx series graphic controller from FTDI and additional components - the touch controller, the audio controller, etc.  <a href="https://riverdi.com/product-category/displays/">On the manufacturer‚Äôs website</a> you can find a full list of available TFT modules, and <a href="http://www.efo.ru/doc/Riverdi/Riverdi.pl%3F10020">on the EFO</a> <a href="https://riverdi.com/product-category/displays/">website</a> you can find positions available from stock and current prices. <br><br>  Displays differ in diagonal, resolution, brightness, type of backlight, the presence of a mounting or decorative frame, as well as the type of touch screen - capacitive TFT and resistive TFT are available, as well as displays without support for touch input.  The on-board graphics controller matches the display capabilities: the FT800 controller is designed for resistive displays, the FT801 is for capacitive displays, and the older FT81x models feature support for relatively high resolution and other additional features. <br><br>  I use the cutest module RVT43ULFNWC00 uxTouch series with a diagonal of 4.3 ", made in a black decorative frame.  The module has a capacitive touch screen and, accordingly, an integrated graphics controller FT801. <br><br>  <a href="https://habrahabr.ru/company/efo/blog/309918/">We have already talked</a> about the order of control of the Riverdi TFT module - the control controller is connected to the FT801 chip and exchanges simple commands with the graphics controller, that is, it reads and writes certain FT801 registers.  In accordance with the commands received from the controlling controller, the graphic controller interacts with the display ‚Äî it draws and displays images, realizes touch input and audio channel operation. <br><br><img src="https://habrastorage.org/files/c2a/56b/d83/c2a56bd8319e413c87485362058548e9.png"><br><br>  In capacitive TFT-modules, in contrast to models with a resistive screen, a separate touch panel controller is installed.  However, the presence of this additional hardware block does not affect the TFT management process from the point of view of the programmer. <br><br><h1>  2. Retrieving touch data </h1><hr><br>  The FT801 graphics controller supports standard and advanced touch input modes.  In the first case, only single touches can be detected, and in advanced mode multitouch is supported.  The operating mode used is determined by the value in the register REG_CTOUCH_EXTENDED: <br><br><ul><li>  0: extended mode - extended mode, </li><li>  1: FT800 compatibility mode - standard single-touch mode, is the default mode. </li></ul><br>  I will use only single-touch mode.  Firstly, for my application, its capabilities are quite enough, and secondly, the program will be compatible with modules based on FT800. <br><br>  When you touch the TFT display, the touch panel controller transmits raw data about the touch area to the FT801.  This data is written to the REG_CTOUCH_RAW_XY register of the graphics controller, after which the FT801 calculates the touch coordinates (x, y) and places the result in the REG_TOUCH_TAG_XY register.  Coordinate calculation is a matrix transformation, in which data from REG_CTOUCH_RAW_XY and a coordinate matrix, which is stored in registers with REG_CTOUCH_TRANSFORM_A by REG_CTOUCH_TRANSFORM_F, participate.  We still have to return to the registers REG_CTOUCH_TRANSFORM. <br><br><img src="https://habrastorage.org/files/4d8/70c/fd1/4d870cfd1a9f4722b695e4f766cf76a2.png"><br><br>  In principle, you can use data from REG_TOUCH_TAG_XY to detect a touch, but more convenient tools are provided for the programmer. <br><br>  The simplest of these tools is tags (TAG).  A label is a number from 1 to 255, which can be assigned to a graphic object, i.e.  rectangle, point, line, button, text, and so on.  While touching in the area of ‚Äã‚Äãthe marked graphic object, the value of the corresponding label will be set in the register REG_TOUCH_TAG.  Thus, in order to detect a touch of an object, the host controller must periodically poll the REG_TOUCH_TAG register and compare the obtained value with the label assigned to the object of interest. <br><br>  The FT801 controllers also support pushing tracking ‚Äî automatically calculating the angle or linear distance between a touch point and a point with given coordinates.  In this case, in addition to setting the label, you will need to set its tracking parameters (the Track () command), and to detect pressing, check the REG_TRACKER register instead of REG_TOUCH_TAG. <br><br>  However, it's time to move on to examples. <br><br><h3>  2.1.  Work with ready-made widgets </h3><br>  First, we consider widgets ‚Äî graphic objects that are hardware implemented on a graphics controller.  The three most simple widgets for the touch interface are the button, the row of buttons, and the slider. <br><br>  To render widgets, use simple commands that are part of the FT800_2 library, which we discussed in the <a href="https://habrahabr.ru/company/efo/blog/309918/">second article of the cycle</a> .  To draw the elements shown in the figure, these simple functions are: <br><br><pre><code class="cpp hljs">TFT.FgColor(<span class="hljs-number"><span class="hljs-number">0xC1004D</span></span>); TFT.Keys(<span class="hljs-number"><span class="hljs-number">27</span></span>, <span class="hljs-number"><span class="hljs-number">127</span></span>, <span class="hljs-number"><span class="hljs-number">271</span></span>, <span class="hljs-number"><span class="hljs-number">41</span></span>, <span class="hljs-number"><span class="hljs-number">29</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"123"</span></span>); TFT.Button(<span class="hljs-number"><span class="hljs-number">26</span></span>, <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-number"><span class="hljs-number">27</span></span>, OPT_FLAT, <span class="hljs-string"><span class="hljs-string">"Button"</span></span>); TFT.Slider(<span class="hljs-number"><span class="hljs-number">244</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>, <span class="hljs-number"><span class="hljs-number">161</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br><img src="https://habrastorage.org/files/b58/f43/985/b58f43985be04061a55c745f6aa522a6"><br>  In order for the elements not only to be displayed, but also to react to a touch, you need to add tags to the created objects and poll the register storing the label. <br><br>  The elements of the object A series of buttons (Keys) tags are assigned automatically, therefore, to detect the pressing of buttons "1", "2" and "3" it is enough to simply poll the register REG_TOUCH_TAG: <br><br><pre> <code class="cpp hljs"> TFT.Keys(<span class="hljs-number"><span class="hljs-number">27</span></span>, <span class="hljs-number"><span class="hljs-number">127</span></span>, <span class="hljs-number"><span class="hljs-number">271</span></span>, <span class="hljs-number"><span class="hljs-number">41</span></span>, <span class="hljs-number"><span class="hljs-number">29</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"123"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pressedButton = TFT.Rd8(REG_TOUCH_TAG);</code> </pre><br>  Button type elements must be assigned manually: <br><br><pre> <code class="cpp hljs"> TFT.DL(TAG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); TFT.Button(<span class="hljs-number"><span class="hljs-number">26</span></span>, <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-number"><span class="hljs-number">27</span></span>, OPT_FLAT, <span class="hljs-string"><span class="hljs-string">"Button"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pressedButton = TFT.Rd8(REG_TOUCH_TAG);</code> </pre><br>  When working with the slider, tracking is used - in addition to setting the label, you need to execute the Track command, which sets the tracking parameters, and you should poll the 32-bit register REG_TRACKER, and not the 8-bit REG_TOUCH_TAG: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> sliderVal = <span class="hljs-number"><span class="hljs-number">0</span></span>; TFT.Track(<span class="hljs-number"><span class="hljs-number">244</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>, <span class="hljs-number"><span class="hljs-number">161</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { TFT.DL(TAG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); TFT.Slider(<span class="hljs-number"><span class="hljs-number">244</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>, <span class="hljs-number"><span class="hljs-number">161</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sliderVal, <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pressedSlider = TFT.Rd32(REG_TRACKER); sliderVal = (pressedSlider &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">65536</span></span>; }</code> </pre><br>  The above code will allow you to register the position of the slider (in this case, it changes from 0 to 255) and redraw the slider in accordance with the current position of the slider. <br><br><h2>  2.2.  Screen calibration </h2><br>  In fact, it is not enough for the operation of the sensory elements to create a display list with a description of graphic elements and poll the corresponding register. <br><br>  The fact is that after switching on and initializing the TFT module, all the registers of the graphics controller are reset to default values.  Just above, we said that the matrix stored in REG_CTOUCH_TRANSFORM registers is used to calculate the pressure coordinates.  So, these registers after initialization are also ‚Äúempty‚Äù, and in order to write the correct values ‚Äã‚Äãthere, you need to calibrate the touch screen. <br><br>  For calibration, use the instruction of the graphic coprocessor CMD_CALIBRATE.  Roughly speaking, on the arrival of this instruction, the FT8xx graphics controller displays three points one after another on which you need to click.  In accordance with the coordinates of the three contacts in the registers REG_CTOUCH_TRANSFORM enter the desired values. <br><br><div class="spoiler">  <b class="spoiler_title">The library FT800_2 provides a standard function for calibration</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> DLstart(); DL(CLEAR_COLOR_RGB(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">64</span></span>)); DL(CLEAR(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)); DL(COLOR_RGB(<span class="hljs-number"><span class="hljs-number">0xff</span></span>,<span class="hljs-number"><span class="hljs-number">0xff</span></span>,<span class="hljs-number"><span class="hljs-number">0xff</span></span>)); Text((DispWidth/<span class="hljs-number"><span class="hljs-number">2</span></span>), (DispHeight/<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">27</span></span>, OPT_CENTER, <span class="hljs-string"><span class="hljs-string">"Please Tap on the dot"</span></span>); Calibrate(<span class="hljs-number"><span class="hljs-number">0</span></span>); Flush_Co_Buffer(); WaitCmdfifo_empty();</code> </pre><br></div></div><br>  The calibration function should be called up after the initialization of the TFT display.  It all looks like this: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AF4ZTKigcSM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A project running on video can be viewed <a href="">on developer.mbed.org</a> . <br><br>  Of course, it would be strange to force the user to calibrate the screen after each power up.  Therefore, it makes sense to calibrate once, read the contents of registers REG_CTOUCH_TRANSFORM_A ... REG_CTOUCH_TRANSFORM_F, save the data, and then programmatically enter them into registers REG_CTOUCH_TRANSFORM after initializing the TFT module. <br><br>  Calibration data can be stored in some EEPROM, and if conscience allows you to act completely clumsy, then you can ‚Äúcalibrate‚Äù something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Display::Calibration() { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> calibration[<span class="hljs-number"><span class="hljs-number">25</span></span>] = {<span class="hljs-number"><span class="hljs-number">98</span></span>, <span class="hljs-number"><span class="hljs-number">99</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">182</span></span>, <span class="hljs-number"><span class="hljs-number">254</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">245</span></span>, <span class="hljs-number"><span class="hljs-number">142</span></span>, <span class="hljs-number"><span class="hljs-number">248</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">117</span></span>, <span class="hljs-number"><span class="hljs-number">254</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">98</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">154</span></span>, <span class="hljs-number"><span class="hljs-number">248</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">24</span></span>; i++) { (*_TFT).Wr8(REG_TOUCH_TRANSFORM_A + i, calibration[i]); } }</code> </pre><br><h1>  3. Using the touch interface in your own project </h1><hr><br>  My final application is the main menu, which displays current data on temperature and relative humidity, as well as several subsections: <br><br><img src="https://habrastorage.org/files/fda/a55/936/fdaa5593678745f38dcb952798dd98ce.png"><br><br>  Since we will only deal with the issues of image rendering and Russification in the following article, today we will analyze the semi-finished product: <br><br><img src="https://habrastorage.org/files/866/f1a/2a7/866f1a2a76be4c7baa7b38b24d665c5e.png"><br><br>  To navigate between the sections are two listings.  The first is all the labels assigned to graphic objects: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { NONE_PRESS, CURR_TEMP_PRESS, CURR_HUM_PRESS, MENU_PRESS, } pressValues;</code> </pre><br>  The second is a list of screens between which we switch. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { MENU_SCREEN, CURR_HUM_SCREEN, CURR_TEMP_SCREEN, } screenValues;</code> </pre><br>  The logic of the application is described as follows: <br><br><pre> <code class="cpp hljs"> disp.activeScreen = MENU_SCREEN; disp.pressedButton = NONE_PRESS; <span class="hljs-comment"><span class="hljs-comment">// change active screen depending on pressed area while(1) { dataUpdate(); disp.pressedButton = disp.GetTouch(); // Main menu screen if (disp.activeScreen == MENU_SCREEN) { disp.MainMenu(SENSOR.humidity, SENSOR.temperature); if (disp.pressedButton) { wait_ms(150); if (disp.pressedButton == CURR_TEMP_PRESS) { disp.activeScreen = CURR_TEMP_SCREEN; } else if (disp.pressedButton == CURR_HUM_PRESS) { disp.activeScreen = CURR_HUM_SCREEN; } disp.pressedButton = NONE_PRESS; } // Any other screen } else { // You can back to main menu from any screen if (disp.pressedButton == MENU_PRESS) { disp.pressedButton = NONE_PRESS; disp.activeScreen = MENU_SCREEN; } else { // Screen with current temperature / humidity if (disp.activeScreen == CURR_TEMP_SCREEN) { disp.CurrentTemperature(SENSOR.temperature); } else if (disp.activeScreen == CURR_HUM_SCREEN) { disp.CurrentHumidity(SENSOR.humidity); } } } }</span></span></code> </pre><br>  To draw all three screens, only simple graphic primitives (LINES, POINTS, EDGE_STRIP_B and RECTS) and widgets for text and numbers are used.  I suppose that after reading the article <a href="https://habrahabr.ru/company/efo/blog/309918/">How to stop being afraid and fall in love with mbed [Part 2]</a> and viewing the source code there shouldn't be any questions about drawing menu elements and graphs, so I‚Äôll only focus on the implementation of touch input elements. <br><br>  I do not use ready-made widgets from FTDI, since some buttons of the main menu will contain images and lines of different sizes <s>, and also because the rounded corners of the buttons bother me</s> .  Therefore, my buttons are not button widgets, but rectangles on top of which text lines and other elements are displayed. <br><br>  Labels (TAG) for "ordinary" graphic objects, such as rectangles, are set the same way as when using widgets.  All graphic objects described after calling the TAG (CURR_HUM_PRESS) command are assigned the CURR_HUM_PRESS label.  You can end the list of marked objects either by calling TAG () with a new argument, or by using the TAG_MASK (0) command, which prohibits label assignment.  When using TAG_MASK (0), you need to remember to allow label assignment (TAG_MASK (1)) before the next call to TAG (). <br><br>  Also it is necessary to provide some visualization of pressing.  In my case, this is what is done: <br><br>  a) If, after the previous frame is displayed on the TFT display, the button is fixed, on the new frame the button color changes from dark blue to blue (see code below), <br>  b) After displaying the frame with the blue button, a delay of 150 milliseconds is performed (see the code above). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Display::MainMenu(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> humidity, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature) { ... (*_TFT).DL(TAG_MASK(<span class="hljs-number"><span class="hljs-number">1</span></span>)); (*_TFT).DL(TAG(CURR_HUM_PRESS)); (*_TFT).DL(COLOR_RGB(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">63</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//     ,       if (pressedButton == CURR_HUM_PRESS) { (*_TFT).DL(COLOR_RGB(75, 70, 108)); } (*_TFT).DL(BEGIN(RECTS)); (*_TFT).DL(VERTEX2II(12, 62, 0, 0)); (*_TFT).DL(VERTEX2II(12 + 400, 62 + 93, 0, 0)); (*_TFT).DL(COLOR_RGB(255, 255, 255)); (*_TFT).Text(12 + 10, 62 + 5, 30, 0, "Current humidity (rH)"); //      (32 -&gt; "32%") CreateStringTempHum(humidityStr, humidity, 0); (*_TFT).Text(12 + 10, 62 + 45, 31, 0, humidityStr); (*_TFT).DL(TAG_MASK(0)); ... }</span></span></code> </pre><br>  All buttons of the main menu are formed in the same way.  By clicking on the Current temperature button, we go to the screen with a graph of temperature changes, by clicking on Current humidity - on the screen with a graph of changes in relative humidity. <br><br>  From the screens with graphs, you can return to the main menu by clicking on the Back to main menu link.  To create such a link, the same tools are used - the TAG (MENU_PRESS) tag, after which graphic objects are described - a text line and a line (underline). <br><br><pre> <code class="cpp hljs"> (*_TFT).DL(TAG_MASK(<span class="hljs-number"><span class="hljs-number">1</span></span>)); (*_TFT).DL(TAG(MENU_PRESS)); (*_TFT).DL(COLOR_RGB(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); (*_TFT).Text(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Back to main menu"</span></span>); (*_TFT).DL(BEGIN(LINES)); (*_TFT).DL(LINE_WIDTH(<span class="hljs-number"><span class="hljs-number">8</span></span>)); (*_TFT).DL(VERTEX2F(<span class="hljs-number"><span class="hljs-number">15</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">260</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>)); (*_TFT).DL(VERTEX2F(<span class="hljs-number"><span class="hljs-number">155</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">260</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>)); (*_TFT).DL(TAG_MASK(<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><br>  It looks like this: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ulVZhLxmp5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The source code for the project is available at <a href="https://developer.mbed.org/users/Ksenia/code/Temp__RH_at_TFT_with_touchscreen/">developer.mbed.org</a> . <br><br>  Both this project and the demo project with pink widgets, and the programs reviewed in previous articles are successfully launched on the SLSTK3400A boards by Silicon Labs, ATSAMD21-XPRO by Atmel and WIZwiki-W7500P by Wiznet.  You only need to change the names of the used GPIO and replace the target board before compiling.  How can you not love mbed? <br><br><h1>  Conclusion </h1><hr><br>  In conclusion, I traditionally thank the reader for his attention and remind you that questions about the use of products, about which we write on Habr√©, can also be asked by email, specified in my profile. </div><p>Source: <a href="https://habr.com/ru/post/310720/">https://habr.com/ru/post/310720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310708/index.html">Debugging php in Visual Studio Code (Xdebug, Windows)</a></li>
<li><a href="../310710/index.html">PostCSS. Future after Sass and Less</a></li>
<li><a href="../310712/index.html">Lecture "Monetization promotions: how to double the income of your game" - a brief summary</a></li>
<li><a href="../310716/index.html">Idea Platform - a designer for creating complex web applications (almost) without programming</a></li>
<li><a href="../310718/index.html">Nikita Ivanov (GridGain): "We make spaceships"</a></li>
<li><a href="../310722/index.html">Testing filter and setting changes in Google Analytics</a></li>
<li><a href="../310724/index.html">Collaborate on documents: SharePoint 2016. Part 2. Configure external access.</a></li>
<li><a href="../310726/index.html">The book "How to survive the full end of the dinner, or security in PHP." Part 1</a></li>
<li><a href="../310728/index.html">Gartner Quadrant for Wireless and Wired Networks 2016</a></li>
<li><a href="../310730/index.html">We work in the cloud based on Hyper-V, part 1: familiarity with the control panel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>