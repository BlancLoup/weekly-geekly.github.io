<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET wrappers for native C ++ / CLI libraries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's Preface 
 This article is a translation of Chapter 10 from the book of Expert C ++ / CLI: .NET for Visual C ++ Programmers by Marcus Heeg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET wrappers for native C ++ / CLI libraries</h1><div class="post__text post__text-html js-mediator-article"><h1>  Translator's Preface </h1><br>  This article is a translation of Chapter 10 from the book of Expert C ++ / CLI: .NET for Visual C ++ Programmers by Marcus Heege.  This chapter discusses the creation of wrapper classes for native C ++ classes, ranging from trivial cases to support for hierarchies and virtual methods of native classes. <br><br>  The idea of ‚Äã‚Äãthis translation appeared after the article <a href="https://habrahabr.ru/company/simbirsoft/blog/276011/">‚ÄúUnmanaged C ++ library in .NET.</a>  <a href="https://habrahabr.ru/company/simbirsoft/blog/276011/">Full integration</a> .  The translation took longer than expected, but perhaps the approach shown here will also benefit the community. <br><a name="habracut"></a><br><h1>  Content </h1><br><ol><li>  <a href="https://habr.com/ru/post/318224/">Creating wrappers for native libraries</a> <br><ol><li>  <a href="https://habr.com/ru/post/318224/">Before you start</a> <br><ol><li>  <a href="https://habr.com/ru/post/318224/">Separate DLL or integration into a native library project?</a> </li><li>  <a href="https://habr.com/ru/post/318224/">What part of the native library should be accessible through the wrapper?</a> </li></ol></li><li>  <a href="https://habr.com/ru/post/318224/">Language interaction</a> </li><li>  <a href="https://habr.com/ru/post/318224/">Creating wrappers for classes</a> <br><ol><li>  <a href="https://habr.com/ru/post/318224/">Mapping native types to CLS compliant types</a> </li><li>  <a href="https://habr.com/ru/post/318224/">Mapping C ++ Exceptions to Managed Exceptions</a> </li><li>  <a href="https://habr.com/ru/post/318224/">Mapping of managed arrays to native types</a> </li><li>  <a href="https://habr.com/ru/post/318224/">Display of other non-primitive types</a> </li><li>  <a href="https://habr.com/ru/post/318224/">Support inheritance and virtual methods</a> </li></ol></li><li>  <a href="https://habr.com/ru/post/318224/">General recommendations</a> <br><ol><li>  <a href="https://habr.com/ru/post/318224/">Simplify wrappers from the start</a> </li><li>  <a href="https://habr.com/ru/post/318224/">Consider the .NET philosophy</a> </li></ol></li><li>  <a href="https://habr.com/ru/post/318224/">Conclusion</a> </li></ol></li></ol><br><a name="begin"></a><br><h1>  Creating wrappers for native libraries </h1><br>  There are many situations that require writing a wrapper over a native library.  You can create a wrapper for a library whose code you can modify.  You can wrap a part of the Win32 API, the wrapper for which is missing in the FCL.  Perhaps you are creating a wrapper for a third-party library.  The library can be both static and dynamic (DLL).  Moreover, it can be both C and C ++ library.  This chapter contains practical advice, general tips, and solutions for several specific problems. <br><a name="up-front-considerations"></a><br><h2>  Before you start </h2><br>  Before writing code, you should consider the different approaches to writing wrappers and their advantages and disadvantages from the point of view of both creating and using your library. <br><a name="separate-or-integrate"></a><br><h3>  Separate DLL or integration into a native library project? </h3><br>  Visual C ++ projects may contain files compiled into managed code [for more information, see Chapter 7 of the book].  Integration of wrappers into the native library may seem like a good idea, because then you will have one less library.  In addition, if you are integrating wrappers into a DLL, then the client application will not have to load an extra dynamic library.  The smaller the DLL is loaded, the shorter the load time, the less virtual memory is required, the less likely it is that the library will be moved to memory due to the inability to load it at the original base address. <br><br>  However, the inclusion of wrappers in the library being wrapped is generally not beneficial.  To better understand why, you should separately consider building a static library and DLL. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Strange as it may sound, managed types can be included in a static library.  However, this can easily lead to problems of type identity.  An assembly in which a type is defined is part of its identifier.  Thus, the CLR can distinguish between two types from different assemblies, even if the type names are the same.  If two different projects use the same managed type from a static library, then this type will be arranged in both assemblies.  Since the assembly is part of a type identifier, we get two types with different identifiers, although they were defined in the same static library. <br><br>  Integration of managed types into the native DLL is also not recommended, since loading the library will require CLR 2.0 in load time.  Even if an application using the library refers only to native code, to load the library, it is required that CLR 2.0 is installed on the computer and that the application does not download an earlier version of the CLR. <br><a name="which-features"></a><br><h3>  What part of the native library should be accessible through the wrapper? </h3><br>  As is often the case, it is very useful to clearly define the tasks of a developer before starting to write code.  I know that this sounds like a quotation from a second-rate book on software development from the early 90s, but for the wrappers of native libraries, the statement of the problem is especially important. <br><br>  When you start creating a wrapper for the native library, the task seems obvious - you already have an existing library and the managed API should bring its functionality to the world of managed code. <br><br>  For most projects, such a general description is completely inadequate.  Without a clearer understanding of the problem, you will probably write a wrapper for each native class of the C ++ library.  If the library contains more than one single central abstraction, then it is often not worth creating one-to-one wrappers with native code.  This will force you to solve problems that are not related to your specific task, as well as generate a lot of unused code. <br><br>  To better describe the problem, think about the problem as a whole.  To formulate the task more clearly, you need to answer two questions: <br><br><ul><li>  What subset of the native API do you need managed code? </li><li>  How will managed code use different parts of the native API? </li></ul><br>  As a rule, by answering these questions, you can simplify your task by cutting back unnecessary parts and adding abstractions-wrappers based on usage scenarios.  For example, take the following native API: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> NativeLib { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CryptoAlgorithm</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* ...      ... */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* ...      ... */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleCipher</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CryptoAlgorithm { <span class="hljs-comment"><span class="hljs-comment">/* ...      ... */</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnotherCipherAlgorithm</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CryptoAlgorithm { <span class="hljs-comment"><span class="hljs-comment">/* ...      ... */</span></span> }; }</code> </pre> <br>  This API gives the programmer the following features: <br><br><ul><li>  create and use an instance of SampleCipher; </li><li>  create and use an instance of AnotherCipherAlgorithm; </li><li>  inherit from CryptoAlgorithm, SampleCipher or AnotherCipherAlgorithm classes and override Encrypt or Decrypt. </li></ul><br>  Implementing all these features in a managed wrapper is much more complicated than it might seem.  Especially difficult to implement support for inheritance.  As will be shown later, supporting virtual methods requires additional proxy classes, which leads to overhead during execution and takes time to write code. <br><br>  However, it is very likely that the wrapper is only needed for one or two algorithms.  If the wrapper for this API does not support inheritance, then its creation is simplified.  With this simplification, you don‚Äôt have to create a wrapper for the abstract CryptoAlgorithm class.  With virtual methods Encrypt and Decrypt it will be possible to work the same way as with any other.  To make it clear that you do not want to support inheritance, it suffices to declare wrappers for SampleCipher and AnotherCipherAlgorithm as sealed classes. <br><a name="language-interoperability"></a><br><h2>  Language interaction </h2><br>  One of the main goals in creating .NET was to ensure the interaction of different languages.  If you create a wrapper for a native library, the ability to interact with different languages ‚Äã‚Äãbecomes particularly important, as developers using the library are more likely to use C # or other .NET languages.  Common Language Infrastructure (CLI) is the basis of the .NET specification [for more information, see Chapter 1 of the book].  An important part of this specification is the Common Type System (CTS).  Although all .NET languages ‚Äã‚Äãare based on a common type system, not all languages ‚Äã‚Äãsupport all features of this system. <br><br>  To clearly determine whether languages ‚Äã‚Äãcan communicate with each other, the CLI contains the Common Language Specification (CLS).  CLS is a contract between developers using .NET languages ‚Äã‚Äãand developers of libraries that can be used from different languages.  CLS sets the minimum feature set that each .NET language must support.  In order for the library to be used from any .NET language corresponding to the CLS, the language features used in the library's public interface should be limited to the CLS capabilities.  The public interface of the library refers to all types with public visibility defined in the assembly, and all members of such types with public, public protected or protected visibility. <br><br>  You can use the CLSCompliantAttribute attribute to designate a type or its member as the corresponding CLS.  By default, types not marked with this attribute are considered non-compliant with CLS.  If you apply this attribute at the assembly level, by default all types will be considered compliant with CLS.  The following example shows how to apply this attribute to assemblies and types: <br><br><pre> <code class="cpp hljs">[assembly: CLSCompliant(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)]; <span class="hljs-comment"><span class="hljs-comment">//    public  CLS,     namespace ManagedWrapper { public ref class SampleCipher sealed { // ... }; [CLSCompliant(false)] //        CLS public ref class AnotherCipherAlgorithm sealed { // ... }; }</span></span></code> </pre><br>  According to CLS Rule 11, all types that are present in the signatures of class members (methods, properties, fields, and events) visible outside the assembly must comply with CLS.  To properly use the [CLSCompliant] attribute, you need to know if the parameter types of the CLS method match.  To determine the compliance of CLS, you need to check the attributes of the assembly in which the type is declared, as well as the attributes of the type itself. <br><br>  The CLSCompliant attribute is also used in the Framework Class Library (FCL).  mscorlib and most other FCL libraries use the [CLSCompliant (true)] attribute at the assembly level and mark non-CLS types with the [CLSCompliant (false)] attribute. <br><br>  Note that the following primitive types in mscorlib are marked as inappropriate with CLS: System :: SByte, System :: UInt16, System :: UInt32, and System :: UInt64.  These types (or their equivalent type names char, unsigned short, unsigned int, unsigned long, and unsigned long long in C ++) cannot be used in type member signatures that are considered to be CLS compliant. <br><br>  If a type is considered to conform to CLS, then all its members are also considered as such, unless explicitly stated otherwise.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> System; [assembly: CLSCompliant(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)]; <span class="hljs-comment"><span class="hljs-comment">//    public  CLS,     namespace ManagedWrapper { public ref class SampleCipher sealed // SampleCipher  CLS -   { public: void M1(int); // M2    CLS,          CLS [CLSCompliant(false)] void M2(unsigned int); }; }</span></span></code> </pre><br>  Unfortunately, the C ++ / CLI compiler does not show warnings when the type marked as the corresponding CLS violates the CLS rules.  To understand whether to mark a type as an appropriate CLS or not, you need to know the following important CLS rules: <br><br><ul><li>  Type names and their members must be distinguishable in languages ‚Äã‚Äãwith case-insensitive identifiers (rule 4). </li><li>  Global static fields and methods are incompatible with CLS (rule 36). </li><li>  Custom attributes must contain only the following field types: System :: Type, System :: String, System :: Char, System :: Boolean, System :: Int [16 | 32 | 64], System :: Single and System :: Double (rule 34). </li><li>  Exception objects must be of the System :: Exception type or a type inherited from it (rule 40). </li><li>  All property accessors must be either virtual or non-virtual at the same time, that is, virtual and non-virtual accessors cannot be mixed (rule 26). </li><li>  <abbr title="boxed">Packed</abbr> values ‚Äã‚Äãdo not comply with CLS (rule 3).  For example, the following method does not match CLS: void f (int ^ boxedInt) ;.  [cm.  note below] </li><li>  Unmanaged pointers do not comply with CLS (rule 17).  This rule also includes references in C ++.  Access to native classes, structures and <abbr title="union">associations is</abbr> also carried out under the index [for more details see chapter 8 of the book].  From this it follows that these native types also do not correspond to CLS. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Translator's note - what is int ^</b> <div class="spoiler_text">  Unlike C #, explicitly specifying the type of the packed value is allowed in C ++ / CLI.  For example: <br><pre> <code class="cpp hljs"> System::Int32 value = <span class="hljs-number"><span class="hljs-number">1</span></span>; System::Object ^boxedObject = value; <span class="hljs-comment"><span class="hljs-comment">//   value;  object boxedObject = value;  C# System::Int32 ^boxedInt = value; //    value,     C#    </span></span></code> </pre><br></div></div><br><a name="wrapping-cpp-classes"></a><br><h2>  Creating wrappers for C ++ classes </h2><br>  Despite some similarity of the type system in C ++ and CTS in .NET, the creation of managed wrapper types for C ++ classes often presents unpleasant surprises.  Obviously, if you use the features of C ++, which have no analogues in managed code, then creating a wrapper can be difficult.  For example, if the library actively uses multiple inheritance.  But even if there are similar constructions in all managed C ++ features used in managed code, the reflection of the native API in the wrapper API may not be obvious.  Let's look at possible problems. <br><br>  You cannot declare a managed class with a field of type NativeLib :: SampleCipher [for more information, see Chapter 8 of the book].  Since the fields of managed classes can only be pointers to native types, you should use a field of type NativeLib :: SampleCipher *.  An instance of the native class must be created in the wrapper constructor and destroyed in the destructor. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ManagedWrapper { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleCipher</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> {</span></span> NativeLib::SampleCipher* pWrappedObject; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SampleCipher(<span class="hljs-comment"><span class="hljs-comment">/*      */</span></span>) { pWrappedObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeLib::SampleCipher(<span class="hljs-comment"><span class="hljs-comment">/*      */</span></span>); } ~SampleCipher() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pWrappedObject; } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }; }</code> </pre><br>  In addition to the destructor, it is also worth implementing the finalizer [more details can be found in chapter 11 of the book]. <br><a name="cls-compliant-types"></a><br><h3>  Mapping native types to CLS compliant types </h3><br>  After you have created a wrapper class, you need to add methods, properties, and events to it, which allow client code in .NET to access members of the wrapped object.  In order for a wrapper to be used from any .NET language, all types in signatures of members of a wrapper class must conform to CLS.  Instead of unsigned integers in signatures of the native API, you can usually use signed numbers of the same size.  The choice of equivalents for native pointers and links is not always as simple.  Sometimes, you can use System :: IntPtr instead of a native pointer.  In this case, the managed code can receive the native pointer and pass it as an input parameter for further call.  This is possible because on the binary level, System :: IntPtr is structured in the same way as a native pointer.  In other cases, one or more parameters must be converted manually.  This may take a long time, but it cannot be avoided.  Consider the various options for wrappers. <br><br>  If a C ++ reference or a pointer with the transfer semantics by reference is passed to the native function, then the monitored reference is recommended in the function wrapper [see  note below].  Suppose a native function has the following form: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; i)</span></span></span></span>;      : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">% i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i; f(j); i = j; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Translator's note - what is a tracking link</b> <div class="spoiler_text">  The tracking reference or tracking reference in C ++ / CLI is similar to the ref and out parameters in C #. <br></div></div><br>  To call a native function, you must pass a native reference to an int.  For this argument, it is necessary to perform marshalling manually, since the type conversion from the tracking link to the native link does not exist.  Since there is a standard type conversion from int to int &amp;, a local variable of type int is used, which serves as a buffer for the argument passed by reference.  Before calling the native function, the buffer is initialized with the value passed as parameter i.  After returning from the native function to the wrapper, the value of the parameter i is updated in accordance with changes in buffer j. <br><br>  As can be seen from this example, in addition to the cost of the transition between managed and native code, wrappers are often forced to spend processor time on marshalling types.  As will be shown later, for more complex types, these costs can be significantly higher. <br><br>  It should be noted that some other .NET languages, including C #, distinguish between arguments passed by reference and arguments used only to return a value.  The value of the argument passed by reference must be initialized before the call.  The called method can change its value, but it is not obliged to do so.  If the argument is used only for return, then it is passed uninitialized and the method must change or initialize its value. <br><br>  By default, it is considered that the tracking link means passing by reference.  If you want the argument to be used only to return a value, you must apply the OutAttribute attribute from the System :: Runtime :: InteropServices namespace, as shown in the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([Out] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">% i)</span></span></span></span>;</code> </pre><br>  Argument types for native functions often contain a const modifier, as in the example below: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; i1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; i2)</span></span></span></span>;</code> </pre><br>  The const modifier is translated into an optional method signature modifier [for more details, see Chapter 8 of the book].  The fWrapper method can still be called from managed code, even if the caller does not accept the const modifier: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">% i1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">% i2)</span></span></span></span>;</code> </pre><br>  To pass a pointer to an array as a parameter of a native function, it is not enough just to use the tracking link.  To disassemble this case, suppose that the native SampleCipher class has a constructor that accepts an encryption key: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> NativeLib { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleCipher</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CryptoAlgorithm { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SampleCipher(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pKey, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nKeySizeInBytes); <span class="hljs-comment"><span class="hljs-comment">/* ...       ... */</span></span> }; }</code> </pre><br>  In this case, it is not enough to simply display const unsigned char * in const unsigned char%, because the encryption key passed to the native type constructor contains more than one byte.  Best to use the following approach: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ManagedWrapper { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleCipher</span></span></span><span class="hljs-class"> {</span></span> NativeLib::SampleCipher* pWrappedObject; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SampleCipher(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Byte&gt;^ key); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }; }</code> </pre><br>  In this constructor, both arguments of the native constructor (pKey and nKeySizeInBytes) are mapped to a single type argument of the managed array.  This can be done because the size of the managed array can be determined at run time. <br><br>  How to implement this constructor depends on the implementation of the native SampleCipher class.  If the constructor creates an internal copy of the key passed as an argument to pKey, then you can pass a docking pointer to the key: <br><br><pre> <code class="cpp hljs">SampleCipher::SampleCipher(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Byte&gt;^ key) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!key) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"key"</span></span>); pin_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; pp = &amp;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]; pWrappedObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeLib::SampleCipher(pp, key-&gt;Length); }</code> </pre><br>  However, the docking pointer cannot be used if the native SampleCipher class is implemented as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> NativeLib { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleCipher</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CryptoAlgorithm { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pKey; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nKeySizeInBytes; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SampleCipher(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pKey, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nKeySizeInBytes) : pKey(pKey), nKeySizeInBytes(nKeySizeInBytes) {} <span class="hljs-comment"><span class="hljs-comment">/* ...         ... */</span></span> }; }</code> </pre><br>  This constructor requires the client not to release the memory containing the key, and the pointer to the key remains valid until an instance of the SampleCipher class is destroyed.  The wrapper constructor does not fulfill any of these requirements.  Since the wrapper does not contain a handle to the managed array, the garbage collector can collect the array before the instance of the native class is destroyed.  Even if you save the object handle so that the memory is not freed, the array can be moved during garbage collection.  In this case, the native pointer will no longer point to the managed array.  In order for the memory containing the key not to be released and not moved when garbage is collected, the key must be copied to the native heap. <br><br>  To do this, you need to make changes to both the constructor and the managed wrapper destructor.  The following code shows a possible implementation of the constructor and destructor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleCipher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pKey; NativeLib::SampleCipher* pWrappedObject; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SampleCipher(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Byte&gt;^ key) : pKey(<span class="hljs-number"><span class="hljs-number">0</span></span>), pWrappedObject(<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!key) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"key"</span></span>); pKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[key-&gt;Length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pKey) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew OutOfMemoryException(<span class="hljs-string"><span class="hljs-string">"Allocation on C++ free store failed"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal::Copy(key, <span class="hljs-number"><span class="hljs-number">0</span></span>, IntPtr(pKey), key-&gt;Length); pWrappedObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeLib::SampleCipher(pKey, key-&gt;Length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pWrappedObject) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew OutOfMemoryException(<span class="hljs-string"><span class="hljs-string">"Allocation on C++ free store failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Object^) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] pKey; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } } ~SampleCipher() { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pWrappedObject; } finally { <span class="hljs-comment"><span class="hljs-comment">//  pKey,    pWrappedObject   delete[] pKey; } } /*       */ };</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Translator's note - what is a descriptor</b> <div class="spoiler_text">  The handle is a reference to an object in the managed heap.  In C # terms, this is just an object reference. <br></div></div><br>  If you do not take into account some esoteric problems [discussed in Chapter 11 of the book], the code provided here ensures the correct allocation and release of resources, even when exceptions occur.  If an error occurs during the creation of an instance of ManagedWrapper :: SampleCipher, all allocated resources will be freed.  The destructor is implemented in such a way as to free the native array containing the key, even if the destructor of the object being wrapped throws an exception. <br><br>  This code also shows the characteristic overhead of the managed wrappers.  In addition to the overhead of calling the wrapped native functions from the managed code, the overhead of the mapping between native and managed types is often added. <br><a name="mapping-exceptions"></a><br><h3>  Mapping C ++ Exceptions to Managed Exceptions </h3><br>  In addition to resource management that is resistant to exceptions, the managed wrapper must also take care of mapping the C ++ exceptions thrown by the native library into managed exceptions.  For example, suppose the SampleCipher algorithm supports only 128 and 256-bit keys.  The constructor NativeLib :: SampleCipher could throw a NativeLib :: CipherException exception if a key of the wrong size is passed to it.  C ++ exceptions are mapped to System :: Runtime :: InteropServices :: SEHException exceptions, which is not very convenient for the library user [discussed in Chapter 9 of the book].  Therefore, it is necessary to intercept native exceptions and to throw managed exceptions containing equivalent data. <br><br>  To display constructor exceptions, you can use a try block at the function level, as shown in the following example.  This will allow to catch exceptions thrown both during initialization of class members and in the body of the constructor. <br><br><pre> <code class="cpp hljs">SampleCipher::SampleCipher(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Byte&gt;^ key) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> : pKey(<span class="hljs-number"><span class="hljs-number">0</span></span>), pWrappedObject(<span class="hljs-number"><span class="hljs-number">0</span></span>) { ..<span class="hljs-comment"><span class="hljs-comment">//       } catch(NativeLib::CipherException&amp; ex) { throw gcnew CipherException(gcnew String(ex.what())); }</span></span></code> </pre><br>  Here, a try block is used at the function level, although the initialization of class members in this example should not result in throwing exceptions.  This way, exceptions will be intercepted even if you add new members to the class or add SampleCipher inheritance from another class. <br><a name="mapping-array"></a><br><h3>  Mapping of managed arrays to native types </h3><br>  Now, having understood the constructor implementation, let's look at the Encrypt and Decrypt methods.  Earlier, the indication of the signatures of these methods was postponed, now we give them in full: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CryptoAlgorithm</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nDataLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nBufferLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; nNumEncryptedBytes)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nDataLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nBufferLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; nNumEncryptedBytes)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Data that must be encrypted or decrypted is transmitted using the pData and nDataLength parameters.  Before calling Encrypt or Decrypt, allocate a memory buffer.  The value of the pBuffer parameter must be a pointer to this buffer, and its size must be passed as the value of the nBufferLength parameter.  The size of the output data is returned using the nNumEncryptedBytes parameter. <br><br>  To display the Encrypt and Decrypt, you can add the following method to ManagedWrapper :: SampleCipher: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ManagedWrapper { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleCipher</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... void Encrypt( array&lt;Byte&gt;^ data, array&lt;Byte&gt;^ buffer, int% nNumOutBytes) { if (!data) throw gcnew ArgumentException("data"); if (!buffer) throw gcnew ArgumentException("buffer"); pin_ptr&lt;unsigned char&gt; ppData = &amp;data[0]; pin_ptr&lt;unsigned char&gt; ppBuffer = &amp;buffer[0]; int temp = nNumOutBytes; pWrappedObject-&gt;Encrypt(ppData, data-&gt;Length, ppBuffer, buffer-&gt;Length, temp); nNumOutBytes = temp; } }</span></span></code> </pre><br>  In this implementation, it is assumed that NativeLib :: SampleCipher :: Encrypt is a non-blocking operation and that it completes execution in a reasonable amount of time.  If you cannot make such assumptions, you should avoid <abbr title="pinning">pinning</abbr> managed objects for the duration of running the native Encrypt method.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, you can copy the managed array to native memory before transferring the array to Encrypt and then copying the encrypted data from the native memory to the managed buffer. </font><font style="vertical-align: inherit;">On the one hand, this entails additional costs for marshalling types, on the other hand, it prevents long-term </font></font><abbr title="pinning"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consolidation</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><a name="mapping-other-arguments"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Display of other non-primitive types </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, all types of parameters of displayed functions were either primitive types, or pointers or references to primitive types. If you need to display functions that take C ++ classes as parameters, or pointers or references to C ++ classes, additional actions are often required. Depending on the specific situation, the solutions may be different. To show different solutions with a specific example, consider another native class for which a wrapper is required:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EncryptingSender</span></span></span><span class="hljs-class"> {</span></span> CryptoAlgorithm&amp; cryptoAlg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EncryptingSender(CryptoAlgorithm&amp; cryptoAlg) : cryptoAlg(cryptoAlg) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nDataLength)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pEncryptedData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[nDataLength]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nEncryptedDataLength = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    cryptoAlg.Encrypt(pData, nDataLength, pEncryptedData, nDataLength, nEncryptedDataLength); SendEncryptedData(pEncryptedData, nEncryptedDataLength); } private: void SendEncryptedData(const unsigned char* pEncryptedData, int nDataLength) { /*     ,   */ } };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can guess about the name of this class, its purpose is to send encrypted data. In the framework of the discussion, it does not matter where the data is sent and which protocol is used. For encryption, you can use classes that are inherited from CryptoAlgorithm (for example, SampleCipher). The encryption algorithm can be specified using the CryptoAlgorithm &amp; type constructor parameter. An instance of the CryptoAlgorithm class that is passed to the constructor is used in the SendData method when calling the virtual method Encrypt. The following example shows how EncryptingSender can be used in native code:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> NativeLib; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> key[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>}; <span class="hljs-function"><span class="hljs-function">SampleCipher </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">EncryptingSender </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sc)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pData[] = { <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3'</span></span> }; sender.SendData(pData, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a wrapper over NativeLib :: EncryptingSender, you can define the managed class ManagedWrapper :: EncryptingSender. Like the wrapper of the SampleCipher class, it must store a pointer to the wrapped object in the field. To create an instance of the wrapped class EncryptingSender requires an instance of the class NativeLib :: CryptoAlgorithm. Suppose the only encryption algorithm you want to support is SampleCipher. Then you can define a constructor that takes a value of type array &lt;unsigned char&gt; ^ as the encryption key. As well as the constructor for the class ManagedWrapper :: SampleCipher, the constructor of the EncryptingSender can use this array to create an instance of the native class NativeLib :: SampleCipher. Then, a link to this object can be passed to the NativeLib :: EncryptingSender constructor:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EncryptingSender</span></span></span><span class="hljs-class"> {</span></span> NativeLib::SampleCipher* pSampleCipher; NativeLib::EncryptingSender* pEncryptingSender; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EncryptingSender(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Byte&gt;^ key) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> : pSampleCipher(<span class="hljs-number"><span class="hljs-number">0</span></span>), pEncryptingSender(<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!key) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"key"</span></span>); pin_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; ppKey = &amp;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]; pSampleCipher = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeLib::SampleCipher(ppKey, key-&gt;Length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pSampleCipher) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew OutOfMemoryException(<span class="hljs-string"><span class="hljs-string">"Allocation on C++ free store failed"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { pEncryptingSender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeLib::EncryptingSender(*pSampleCipher); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pEncryptingSender) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew OutOfMemoryException(<span class="hljs-string"><span class="hljs-string">"Allocation on C++ free store failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Object^) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pSampleCipher; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(NativeLib::CipherException&amp; ex) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew CipherException(gcnew String(ex.what())); } <span class="hljs-comment"><span class="hljs-comment">// ..           };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this approach, you don‚Äôt have to map the CryptoAlgorithm &amp; type parameter to the managed type. </font><font style="vertical-align: inherit;">However, sometimes this approach is too limited. </font><font style="vertical-align: inherit;">For example, you want to give the opportunity to transfer an existing instance of SampleCipher, rather than creating a new one. </font><font style="vertical-align: inherit;">To do this, the ManagedWrapper :: EncryptingSender constructor must have a parameter of type SampleCipher ^. </font><font style="vertical-align: inherit;">To create an instance of the NativeLib :: EncryptingSender class inside the constructor, you need to get an object of the NativeLib :: SampleCipher class, which is wrapped in ManagedWrapper :: SampleCipher. </font><font style="vertical-align: inherit;">To get the wrapped object, you need to add a new method:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleCipher</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pKey; NativeLib::SampleCipher* pWrappedObject; internal: [CLSCompliant(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)] NativeLib::<span class="hljs-function"><span class="hljs-function">SampleCipher&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWrappedObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *pWrappedObject; } ...   SampleCipher    ... };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The following code shows a possible implementation of such a constructor: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EncryptingSender</span></span></span><span class="hljs-class"> {</span></span> NativeLib::EncryptingSender* pEncryptingSender; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EncryptingSender(SampleCipher^ cipher) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cipher) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew ArgumentException(<span class="hljs-string"><span class="hljs-string">"cipher"</span></span>); pEncryptingSender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeLib::EncryptingSender(cipher-&gt;GetWrappedObject()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pEncryptingSender) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew OutOfMemoryException(<span class="hljs-string"><span class="hljs-string">"Allocation on C++ free store failed"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// ...    EncryptingSender    ... };</span></span></code> </pre><br>          ManagedWrapper::SampleCipher.   EncryptingSender      CryptoAlgorithm,     ,   GetWrappedObject    .       : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> interface <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INativeCryptoAlgorithm</span></span></span><span class="hljs-class"> {</span></span> [CLSCompliant(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)] NativeLib::<span class="hljs-function"><span class="hljs-function">CryptoAlgorithm&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWrappedObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br>        SampleCipher  : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleCipher</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> :</span></span> INativeCryptoAlgorithm { <span class="hljs-comment"><span class="hljs-comment">// ... internal: [CLSCompliant(false)] virtual NativeLib::CryptoAlgorithm&amp; GetWrappedObject() = INativeCryptoAlgorithm::GetWrappedObject { return *pWrappedObject; } };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method is implemented as internal, because code using the wrapper library should not directly call methods of the wrapped object. </font><font style="vertical-align: inherit;">If you want to give the client access directly to the wrapped object, you should pass a pointer to it using System :: IntPtr, because the type System :: IntPtr corresponds to CLS. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the constructor for the class ManagedWrapper :: EncryptingSender takes a parameter of type INativeCryptoAlgorithm ^. </font><font style="vertical-align: inherit;">To get an object of class NativeLib :: CryptoAlgorithm, necessary for creating an instance of EncryptingSender to be wrapped, you can call the GetWrappedObject method on the parameter of type INativeCryptoAlgorithm ^:</font></font><br><br><pre> <code class="cpp hljs">EncryptingSender::EncryptingSender(INativeCryptoAlgorithm^ cipher) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cipher) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew ArgumentException(<span class="hljs-string"><span class="hljs-string">"cipher"</span></span>); pEncryptingSender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeLib::EncryptingSender(cipher-&gt;GetWrappedObject()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pEncryptingSender) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew OutOfMemoryException(<span class="hljs-string"><span class="hljs-string">"Allocation on C++ free store failed"</span></span>); }</code> </pre><br><a name="supporting-inheritance"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Support inheritance and virtual methods </font></font></h3><br>              INativeCryptoAlgorithm,         ManagedWrapper::EncryptingSender.             EncryptingSender   .     ,            .        -. <br><br>       ,   NativeLib::CryptoAlgorithm.   GetWrappedObject,  -     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CryptoAlgorithm</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">abstract</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Byte&gt;^ data, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Byte&gt;^ buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">% nNumOutBytes)</span></span></span><span class="hljs-function"> abstract</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Byte&gt;^ data, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Byte&gt;^ buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">% nNumOutBytes)</span></span></span><span class="hljs-function"> abstract</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To implement your own cryptographic algorithm, you need to create a managed class-successor ManagedWrapper :: CryptoAlgorithm and override the virtual methods Encrypt and Decrypt. However, these abstract methods are not enough to override the virtual methods NativeLib :: CryptoAlgorithm Encrypt and Decrypt. Virtual methods of the native class, in our case, NativeLib :: CryptoAlgorithm, can be redefined only in the native class descendant. Therefore, you need to create a native class that inherits from NativeLib :: CryptoAlgorithm and overrides the required virtual methods:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CryptoAlgorithmProxy</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeLib::CryptoAlgorithm { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumInBytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nBufferLen, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; nNumOutBytes)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumInBytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nBufferLen, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; nNumOutBytes)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//        };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This class is called CryptoAlgorithmProxy because it serves as an intermediary for the managed class that implements Encrypt and Decrypt. </font><font style="vertical-align: inherit;">Its implementation of virtual methods should call equivalent virtual methods of the class ManagedWrapper :: CryptoAlgorithm. </font><font style="vertical-align: inherit;">For this, CryptoAlgorithmProxy needs an instance handle of the class ManagedWrapper :: CryptoAlgorithm. </font><font style="vertical-align: inherit;">It can be passed as a constructor parameter. </font><font style="vertical-align: inherit;">To save a handle, you need a gcroot template. </font><font style="vertical-align: inherit;">(Since CryptoAlgorithmProxy is a native class, it cannot contain descriptor type fields.)</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CryptoAlgorithmProxy</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeLib::CryptoAlgorithm { gcroot&lt;CryptoAlgorithm^&gt; target; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CryptoAlgorithmProxy(CryptoAlgorithm^ target) : target(target) {} <span class="hljs-comment"><span class="hljs-comment">// Encrypt  Decrypt    };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of serving as a wrapper for the native abstract class CryptoAlgorithm, the managed class serves as a wrapper for a particular inheritor of CryptoAlgorithmProxy. </font><font style="vertical-align: inherit;">The following code shows how to do this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CryptoAlgorithm</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">abstract</span></span></span><span class="hljs-class"> :</span></span> INativeCryptoAlgorithm { CryptoAlgorithmProxy* pWrappedObject; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CryptoAlgorithm() { pWrappedObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CryptoAlgorithmProxy(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pWrappedObject) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> gcnew OutOfMemoryException(<span class="hljs-string"><span class="hljs-string">"Allocation on C++ free store failed"</span></span>); } ~CryptoAlgorithm() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pWrappedObject; } internal: [CLSCompliant(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> NativeLib::<span class="hljs-function"><span class="hljs-function">CryptoAlgorithm&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWrappedObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= INativeCryptoAlgorithm::GetWrappedObject { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *pWrappedObject; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Byte&gt;^ data, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Byte&gt;^ buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">% nNumEncryptedBytes)</span></span></span><span class="hljs-function"> abstract</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Byte&gt;^ data, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Byte&gt;^ buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">% nNumEncryptedBytes)</span></span></span><span class="hljs-function"> abstract</span></span>; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned earlier, the CryptoAlgorithmProxy class must implement virtual methods in such a way that the control is passed to equivalent ManagedWrapper :: CryptoAlgorithm methods. </font><font style="vertical-align: inherit;">The following code shows how CryptoAlgorithmProxy :: Encrypt calls ManagedWrapper :: CryptoAlgorithm :: Encrypt:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CryptoAlgorithmProxy::Encrypt( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pData, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nDataLength, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pBuffer, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nBufferLength, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; nNumOutBytes) { <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;^ data = gcnew <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(nDataLength); Marshal::Copy(IntPtr(<span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(pData)), data, <span class="hljs-number"><span class="hljs-number">0</span></span>, nDataLength); <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;^ buffer = gcnew <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(nBufferLength); target-&gt;Encrypt(data, buffer, nNumOutBytes); Marshal::Copy(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, IntPtr(pBuffer), nBufferLength); }</code> </pre><br><a name="general-recommendations"></a><br><h2>  General recommendations </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition to the specific steps outlined earlier, you should also consider the general recommendations for creating managed wrappers. </font></font><br><a name="simplify-wrappers"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simplify wrappers from the start </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As can be seen from the previous sections, creating wrappers for class hierarchies can be very time-consuming. </font><font style="vertical-align: inherit;">Sometimes you need to create wrappers for C ++ classes in such a way that managed classes can override their virtual methods, but often such an implementation does not have practical meaning. </font><font style="vertical-align: inherit;">Determining the required functionality is the key to simplifying the task.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No need to reinvent the wheel. </font><font style="vertical-align: inherit;">Before creating a wrapper for some library, make sure that the FCL does not contain a ready-made class with the required methods. </font><font style="vertical-align: inherit;">FCL has more to offer than it seems at first glance. </font><font style="vertical-align: inherit;">For example, BCL already contains quite a lot of encryption algorithms. </font><font style="vertical-align: inherit;">They are in the System :: Security :: Cryptography namespace. </font><font style="vertical-align: inherit;">If the encryption algorithm you need is already in FCL, you do not need to re-create a wrapper for it. </font><font style="vertical-align: inherit;">If FCL does not contain the implementation of the algorithm for which you want to create a wrapper, but the application is not tied to the algorithm implemented in the native API, then it is usually preferable to use one of the standard FCL algorithms.</font></font><br><a name="dot-net-mentality"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider the .NET philosophy </font></font></h3><br>        CLS,  ,  ,    .NET. [          5 .] : <br><br><ul><li>   C++        .NET,      ; </li><li>     Get  Set; </li><li>   FCL    --; </li><li>    enum    #define. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the capabilities of the type system, also consider the capabilities of FCL. Given that FCL implements security-related algorithms, consider the interchangeability of your algorithms and FCL algorithms. To do this, you have to accept the design adopted in FCL and inherit your classes from the abstract base class SymmetricAlgorithm and implement the ICryptoTransform interface from the System :: Security :: Cryptography namespace.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adapting to FCL design generally simplifies the wrapper library from the point of view of the library consumer. The complexity of this approach depends on the design of the native API and the design of the FCL types that you want to support. Whether or not this additional effort is acceptable is determined separately in each case. In this example, it can be assumed that the security algorithm is used only in one specific case and, therefore, it is not worth it to integrate it with FCL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the library for which you are creating a mapping manages tabular data, consider the System :: Data :: DataTable and System :: Data :: DataSet classes from the FCL part called ADO.NET. Although the consideration of these types is beyond the scope of this text, they deserve mention because of their applicability in the creation of wrappers.</font></font><br><br>     DataTable  DataSet     ,           .NET.       XML    ,     .NET Remoting   -,           Windows Forms, Windows Presentation Foundation (WPF)    ADO.NET.         diffgram, ,     ,  . <br><a name="summary"></a><br><h2>  Conclusion </h2><br>             .  ,      .    --    .  ,     ,    .         CLS,  FCL     .NET . <br><br>   ,        C++.    ,         ,       .            .NET,     ‚Äî         ,  CLS.        ,      . <br><br>           (,  ,     ).    ‚Äî      [   11 ]. <br><br><div class="spoiler"> <b class="spoiler_title">  -    11</b> <div class="spoiler_text">   11    IDisposable, ,   (ThreadAbortException, StackOverflowException  ..)   SafeHandle.           ,       , ,  . <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/318224/">https://habr.com/ru/post/318224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318214/index.html">5 really free non-linear video editors for Windows</a></li>
<li><a href="../318216/index.html">DevOps - speed? Yes speed</a></li>
<li><a href="../318218/index.html">From Intranet to Digital Workplace</a></li>
<li><a href="../318220/index.html">SetGoroutineName</a></li>
<li><a href="../318222/index.html">Parsing: how and why to use PureComponent in React</a></li>
<li><a href="../318226/index.html">NetApp SnapLock ‚Ñ¢ - Licensed Data Protection Feature (WORM)</a></li>
<li><a href="../318228/index.html">Hacking on board the aircraft</a></li>
<li><a href="../318230/index.html">Information hygiene in a country with non-free Internet</a></li>
<li><a href="../318232/index.html">What is enterprise architecture, and why was Zachman wrong?</a></li>
<li><a href="../318234/index.html">Oracle Database History ‚Äî First Commercially Successful Relational DBMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>