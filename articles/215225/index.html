<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Break me down completely (ZeroNightsCrackme, Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="And hello again! Last time, I uncovered the ZeroNightsCrackMe solution. All those who managed to solve it in time could receive an invitation to a tou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Break me down completely (ZeroNightsCrackme, Part 2)</h1><div class="post__text post__text-html js-mediator-article">  And hello again!  Last time, I uncovered the <b><a href="http://habrahabr.ru/post/204432/">ZeroNightsCrackMe</a></b> solution.  All those who managed to solve it in time could receive an invitation to a tour to one of the offices of Kaspersky Lab, as well as a gift, in the form of a license key for three devices.  But, among other things, Kaspersky reported that the crack was lightened, i.e.  there is a more complicated version of it and it will be sent out to those who wish to see it (but without gifts, for their own pleasure, so to speak).  Of course, I could not deny myself not to twist this version, so I confirmed my desire to participate. <br><br>  On February 17, a letter arrived with a new quack.  It is about his decision (and not only) that I will tell in this article. <a name="habracut"></a><br><br>  Crack options are the same: <br><ul><li>  <b>File:</b> ZeroNightsCrackMe.exe </li><li>  <b>Platform:</b> Windows 7 (64 bit) </li><li>  <b>Packer:</b> None </li><li>  <b>Anti-debugging:</b> Do not stumble </li><li>  <b>Solution:</b> Valid Mail / Serial Pair </li></ul><br>  Instruments: <br><ul><li>  OllyDbg 2.01 </li><li>  Some gray matter </li></ul><br>  Let's get down to solving ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  We go hunting </h4><br>  As usual, we run the test subject and perform a surface analysis.  The reaction is similar to past quacks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf8/384/2bf/bf83842bfa1aa9e0a327f299a3798a9b.png" alt="image"><br>  Fig.  one <br><br>  Knowing the principle of past quack work, let's start searching for key points and find: <br><ol><li>  The function involved in processing the entered data. </li><li>  Algorithm validation table validation. </li><li>  Validation table </li><li>  Algorithm for filling the validation table. </li><li>  Data for the validation table filling algorithm. </li><li>  Algorithm of turning the serial code into an internal representation. </li><li>  Conversion table </li><li>  Valid range of characters. </li></ol><br>  After that, we will compare all key points with the previous version and find differences. <br><br><h4>  On animal tracks </h4><br><h5>  Input processing function </h5><br>  First we find the function of processing the entered data.  This is done quite simply.  Click the right mouse button in the disassembler window and select <b>‚ÄúSearch for =&gt; All referenced strings‚Äù</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/089/89c/e15/08989ce156216e7b002aeb34be3b303a.png" alt="image"><br>  Fig.  2 <br><br>  Next, click on the line <b>"Good work, Serial is valid !!!"</b> and get here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73d/400/220/73d400220b7a238e67703a2e9e062a77.png" alt="image"><br>  Fig.  3 <br><br>  The above will be the desired function (in my case it is <b>CALL 0x9b12b0</b> ).  It is passed three parameters.  In <b>Arg2</b> , <b>Arg1</b> , the size of the serial code and the pointer to the serial code are transmitted, respectively, and in the <b>ECX</b> register, the <b>pointer</b> is sent to the email. <br><br><h5>  Algorithm validation table validation </h5><br>  Go inside the function and turn to the bottom, there is an algorithm for checking the validation table (identical to the old version): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce5/5ba/78d/ce55ba78dd10e1fdb3f78ec70994fcda.png" alt="image"><br>  Fig.  four <br><br><h5>  Validation Table Address </h5><br>  We set a breakpoint at the beginning of the algorithm and run cracks for execution (of course, first enter any data and click the <b>Check</b> button). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9f/00b/3c4/d9f00b3c4c042ead2c7186443b29b6a0.png" alt="image"><br>  Fig.  5. Enter the test data <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59c/42d/23c/59c42d23c0f63b19ad99267f93f21fef.png" alt="image"><br>  Fig.  6. Stop at the validation table <br><br>  Now we define the address of the table itself.  You can do this by going to the line <b>‚ÄúCMP DWORD PTR SS: [ECX * 4 + EBP-28], 1‚Äù</b> and looking at the target address. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d6/a0e/4e8/4d6a0e4e853f96c019e4b98ac30f0edc.png" alt="image"><br>  Fig.  7. Determining the address of the validation table <br><br>  In my case, the table address is <b>0x36f308</b> (highlighted in red). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/891/7fc/9b3/8917fc9b32b595f52f89b590fba01651.png" alt="image"><br>  Fig.  8. Dump validation table <br><br><h5>  Algorithm for filling the validation table </h5><br>  The search for the algorithm is performed in the same way that was demonstrated when solving the past of the crack, namely: <br><ul><li>  We continue the implementation of quacks (click F9 in Olka); </li><li>  We put bryak on the function of processing the entered data, in my case it is CALL 9b12b0 (Fig. 3); </li><li>  Switch to quacks and in the pop-up window (indicating success or non-success), click "OK" (thus continuing the work of the quacks); </li><li>  Next, click the "Check" button to start the recalculation of the serial, after which you should stop at the call CALL 0x9b12b0; </li><li>  Standing on the call CALL 0x9b12b0, put bryak on the record, at the address 0x36f308; </li><li>  And again press F9. </li></ul><br>  If everything was done correctly, you will find yourself here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/311/b7d/64c/311b7d64ce97b30ac3ca9da13ab220f1.png" alt="image"><br>  Fig.  9. Algorithm for filling the validation table <br><br>  If you compare the new algorithm with the old one, you will notice that they differ: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16f/757/e2c/16f757e2c3581e86e686437aeb7076dd.png" alt="image"><br>  Fig.  10. Old algorithm (screenshot from <a href="http://habrahabr.ru/post/204432/">previous article</a> ) <br><br>  The presentation of the <b>"new algorithm"</b> on Python is as follows: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_table</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first_part, second_part)</span></span></span><span class="hljs-function">:</span></span> result = [] curr_second = <span class="hljs-number"><span class="hljs-number">0</span></span> out_index = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(out_index &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>): inner_index = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(inner_index &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>): curr_first = <span class="hljs-number"><span class="hljs-number">0</span></span> accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(index &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>): first = first_part[inner_index + curr_first] second = second_part[index + curr_second] hash = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first != <span class="hljs-number"><span class="hljs-number">0</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (first != <span class="hljs-number"><span class="hljs-number">0</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>): hash ^= second second += second first = first &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> accumulator ^= hash index += <span class="hljs-number"><span class="hljs-number">1</span></span> curr_first += <span class="hljs-number"><span class="hljs-number">3</span></span> result.append(accumulator &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) inner_index += <span class="hljs-number"><span class="hljs-number">1</span></span> out_index += <span class="hljs-number"><span class="hljs-number">1</span></span> curr_second += <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre> <br>  Let us turn to the search for data used by this algorithm. <br><br><h5>  Data for the validation table fill algorithm </h5><br>  After analyzing the algorithm code, two places were found from which the data for its operation are taken: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/261/af0/52c/261af052c412e507de833d1a7302a209.png" alt="image"><br>  Fig.  11. Arrays with which the new algorithm operates <br><br>  Above, they are highlighted by a gray rectangle.  In my case, at addresses <b>0x9b11b0</b> and <b>0x9b11b2</b> , the following arrays are addressed: <br><ul><li>  0x00758628 (Fig. 12) </li><li>  0x00758908 (Fig. 13) </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/bf7/dff/c5b/bf7dffc5b799ff6d9346afeb9a2fe050.png" alt="image"><br>  Fig.  12 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/afa/c86/e58/afac86e5891b1d26d05497e3404930f4.png" alt="image"><br>  Fig.  13 <br><br>  Each array contains <b>9 elements</b> one byte. <br><br>  If we solved the old cracks, we would now go on to look for an algorithm for turning the serial code into an internal representation, but the new crack revealed a significant difference from the behavior of the old crack, so below is information about the differences that lie here. <br><br><h5>  The difference between the old version and the new one </h5><br>  In the old version of cracks, the work with the serial code was as follows: <br><ol><li>  The serial code was broken into two parts. </li><li>  Each part was translated into an internal representation. </li><li>  Then each part was mixed (mixed). </li><li>  After that, both parts were transferred to the algorithm for filling the validation table. </li></ol><br>  In the end, we did something like this: <br><br><pre> <code class="python hljs">Serial |- part_1 |- part_2 part_1 = intermediate_view(part_1) part_2 = intermediate_view(part_2) part_1 = mix(part_1) part_2 = mix(part_2) valid_table = algo(part_1, part_2)</code> </pre> <br>  In the new version, everything is a little more complicated: <br><ol><li>  The serial code is divided into two parts. </li><li>  Each part of it is translated into an internal representation. </li><li>  The first part + fixed array (3, 5, 7, 5, 7, 3, 7, 3, 5) is passed to the algorithm. </li><li>  The second part + fixed array (3, 5, 7, 5, 7, 3, 7, 3, 5) is transferred to the algorithm. </li><li>  The result of points 3-4 is passed to the algorithm for filling the validation table. </li></ol><br>  As a result, we get something like this: <br><br><pre> <code class="python hljs">Serial |- part_1 |- part_2 part_1 = intermediate_view(part_1) part_2 = intermediate_view(part_2) part_1 = mix(part_1) part_2 = mix(part_2) salt = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] part_a = algo(part_1, salt) part_b = algo(part_2, salt) valid_table = algo(part_a, part_b)</code> </pre> <br>  From which it follows that we have a <b>dependence on a fixed array</b> . <br><br><h5>  Algorithm for turning the serial code into an internal representation </h5><br>  I will leave the search for the serial code converter for you and I will not give it here.  You can search in the same way as in the old version. <br><br><h5>  Conversion table and valid range </h5><br>  The table and the valid range are identical to the old version. <br><br><h4>  Preparing a rookery for an ambush </h4><br>  Now that all the necessary elements have been collected, you can proceed to the solution. <br><br>  The algorithm of our actions is as follows: <br><ol><li>  For <b>algo (part_a, part_b)</b> , find such <b>part_a</b> and <b>part_b</b> , which give the result <b>[1, 0, 0, 0, 1, 0, 0, 0, 1]</b> </li><li>  For <b>part_a = algo (part_1, salt)</b> , find a <b>part_1</b> that gives a result equal to <b>part_a</b> . </li><li>  For <b>part_b = algo (part_2, salt)</b> , find a <b>part_2</b> that gives a result equal to <b>part_b</b> . </li></ol><br><h5>  Let's start with algo (part_a, part_b) </h5><br>  If you read the <a href="http://habrahabr.ru/post/204432/">first article</a> , you probably remember that in order to compile the required table <b>[1, 0, 0, 0, 1, 0, 0, 0, 1]</b> , you need to have such bytes that when interacting with each other would give either <b>" zeros "</b> or <b>" ones "</b> . <br><br>  In the old version of quacks, finding these bytes was very simple.  All that had to be done was to go through the entire available alphabet and apply several simple operations to it. <br><br>  In the new version it is much more difficult to do this (but this is only at first glance and I will explain why below).  In the old version, we could iterate one item at a time.  In the new version we have to sort through three elements, since all of them are interconnected. <br><br><h5>  And so, why does the new version seem complicated, but only at first glance? </h5><br>  Because in the first article I did not reveal that ‚Äúmagic‚Äù, which in reality was hidden behind the search for ‚Äúzeros‚Äù and ‚Äúones‚Äù (in this article, it will have to be revealed, although it was possible not to do this).  In my keygen, I used a function that looks for the required ‚Äúzeros‚Äù and ‚Äúones‚Äù, but not in an entirely obvious way.  This helped to successfully distract the most inquisitive and put them on the way of a single incident (which was the first crack).  if they were given (like now) another crack, but with a different algorithm, they would have to invent a new way of searching for ‚Äúzeros‚Äù and ‚Äúones‚Äù, which seems to happen to many;) <br><br>  Well, okay, less words are more deeds. <br><br>  Here is a magic ‚Äúspell‚Äù that will help you find all null and single characters: <br><br><pre> <code class="python hljs">data_zero, data_ones = [], [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>): part_a = [a, a, a, a, a, a, a, a, a] part_b = [a, a, a, a, a, a, a, a, a] result = create_table(part_a, part_b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result == [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]: data_zero.append(a) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> result == [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]: data_ones.append(a) print(<span class="hljs-string"><span class="hljs-string">"ZERO:"</span></span>, data_zero) print(<span class="hljs-string"><span class="hljs-string">"ONES:"</span></span>, data_ones)</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/064/394/c77/064394c77d38106fd46151e56897cecb.png" alt="image"><br>  Fig.  14 <br><br>  Well, we have a group of elements giving "zeros" and "ones."  How to get the desired table [1, 0, 0, 0, 1, 0, 0, 0, 1]? <br><br>  The most attentive / shrewd ones might have noticed (for example, according to the comments to the <a href="http://habrahabr.ru/post/204432/">previous article</a> ) that we are dealing with matrices that, when multiplied by each other, should give the identity matrix [1, 0, 0, 0, 1, 0, 0, 0, one].  Therefore, to obtain the identity matrix, we need either two identity matrices, or two inverse ones. <br><br>  To get the required unit matrix, you can use the following pattern: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  part_a = [y, x, x, x, y, x, x, x, y] part_b = [y, x, x, x, y, x, x, x, y] result = algo(part_a, part_b)</span></span></code> </pre> <br>  Where in the place of <b>y</b> - substitute any single character, and instead of <b>x</b> - any zero. <br><br>  You can use other patterns, you can find them using the following "spells": <br><br><pre> <code class="python hljs">happy = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> happy: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> happy: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> happy: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_4 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> happy: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_5 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> happy: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_6 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> happy: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_7 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> happy: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_8 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> happy: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_9 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> happy: part_1 = [byte_1, byte_2, byte_3, byte_4, byte_5, byte_6, byte_7, byte_8, byte_9] part_2 = [byte_1, byte_2, byte_3, byte_4, byte_5, byte_6, byte_7, byte_8, byte_9] result = create_table(part_1, part_2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result == [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]: print(<span class="hljs-string"><span class="hljs-string">"%s | %s "</span></span> % (part_2, part_1))</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/5fc/c08/794/5fcc087942ece32ef9a34fa46bcf044d.png" alt="image"><br>  Fig.  15 <br><br>  Having made a replacement, you can get, for example, such patterns: <br><br><pre> <code class="python hljs">patterns = [ <span class="hljs-comment"><span class="hljs-comment"># Pattern 0 [ [y1, x1, x1, x1, y2, x1, x1, x1, y3], [y1, x1, x1, x1, y2, x1, x1, x1, y3] ], # Pattern 1a [ [y1, x1, x1, x1, x1, y1, x1, y1, x1], [y1, x1, x1, x1, x1, y1, x1, y1, x1] ], # Pattern 1b [ [y1, x1, x2, x3, x4, y1, x5, y1, x6], [y1, x2, x1, x5, x6, y1, x3, y1, x4] ], # Pattern 2a [ [y1, x1, x1, x1, y1, x1, x1, x1, y1], [y1, x1, x1, x1, y1, x1, x1, x1, y1] ], # Pattern 2b [ [y1, x1, x2, x3, y2, x4, x5, x6, y3], [y1, x1, x2, x3, y2, x4, x5, x6, y3] ], # Pattern 3a [ [x1, x1, y1, x1, y1, x1, y1, x1, x1], [x1, x1, y1, x1, y1, x1, y1, x1, x1] ], # Pattern 3b [ [x1, x2, y1, x3, y2, x4, y3, x5, x6], [x6, x5, y3, x4, y2, x3, y1, x2, x1] ], # Pattern 4a [ [x1, y1, x1, y1, x1, x1, x1, x1, y1], [x1, y1, x1, y1, x1, x1, x1, x1, y1] ], # Pattern 4b [ [x1, y1, x2, y2, x3, x4, x5, x6, y3], [x3, y2, x4, y1, x1, x2, x6, x5, y3] ], # Pattern 5 [ [x1, x2, y1, y2, x3, x4, x5, y3, x6], [x4, y2, x3, x6, x5, y3, y1, x1, x2] ] ]</span></span></code> </pre> <br>  Now, when we have dealt with obtaining the desired identity matrix (i.e. validation table), let's move on to other problems. <br><br><h5>  How to choose the appropriate part_a and part_b? </h5><br>  We know the following: <br><br><pre> <code class="python hljs">part_a = algo(part_1, salt) part_b = algo(part_2, salt) valid_table = algo(part_a, part_b)</code> </pre> <br>  From which it follows that, for example, <b>part_a</b> depends on <b>part_1</b> and <b>salt</b> .  Which in turn narrows down the possible combinations for <b>part_a</b> .  A natural question arises. <br><br><h5>  What combinations can we use? </h5><br>  I think many have guessed what to do?  That's right, use the next "spell"! <br><br>  Here is one of them: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># serial_data  email ‚Äúsupport@reverse4you.org‚Äù serial_data = [52, 233, 91, 105, 65, 15, 50, 176, 90, 40, 225, 81, 207, 79, 34, 19] def get_items(first_part, second_part): result = [] inner_index = 0 while(inner_index &lt; 3): curr_first = 0 accumulator = 0 index = 0 while(index &lt; 3): first = first_part[inner_index + curr_first] second = second_part[index] hash = 0 if (first != 0): while (first != 0): if (first &amp; 1): hash ^= second second += second first = first &gt;&gt; 1 accumulator ^= hash index += 1 curr_first += 3 result.append(accumulator &amp; 0xff) inner_index += 1 return result a = 0x3 b = 0x5 c = 0x7 first_part = [a, b, c, b, c, a, c, a, b] second_part_new = [0, 0, 0] count = 0 result_table = [] for byte_1 in serial_data: second_part_new[0] = byte_1 for byte_2 in serial_data: second_part_new[1] = byte_2 for byte_3 in serial_data: second_part_new[2] = byte_3 res = get_items(first_part, second_part_new) print("index: %s, table: %s" % (count, res)) count += 1 print("Count: %s" % count)</span></span></code> </pre> <br>  If your ‚Äúspell‚Äù succeeds, you will see that only <b>4096 options are</b> available for <b>part_a</b> and <b>part_b</b> (more precisely, ‚Äúunder options‚Äù). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/21f/765/5f1/21f7655f1b4e355e3ffada5c24d66316.png" alt="image"><br>  Fig.  sixteen <br><br>  So now we have all the data to generate the first valid key.  Of course, we should not forget that we work with bytes that have an internal representation, which means that before entering them into the window of a crack, they will still have to be reduced to a normal appearance. <br><br><h4>  First victim (first valid key) </h4><br>  If you were attentive, you probably noticed that all 4096 variants can be divided into two groups, those with <b>‚Äúall elements are even‚Äù</b> and those with <b>‚Äúall elements are not even‚Äù</b> . <br><br>  index: 0035, table: <b>[116, 222, 172]</b> &lt;= All elements are even <br>  index: 0560, table: <b>[172, 116, 222]</b> &lt;= All elements are even <br>  index: 0770, table: <b>[222, 172, 116]</b> &lt;= All elements are even <br><br>  index: 0117, table: <b>[1, 229, 111]</b> &lt;= All elements are not even <br>  index: 1287, table: <b>[229, 111, 1]</b> &lt;= All elements are not even <br>  index: 1872, table: <b>[111, 1, 229]</b> &lt;= All elements are not even <br><br>  However, if you look at the ‚Äúpatterns‚Äù available to us, you will see that all of them require that each of the ‚Äúoptions‚Äù have both ‚Äúeven‚Äù and ‚Äúnot even‚Äù elements, that is: <br><br>  Here are two matrices that give us the identity: <br><br>  <b>part_a</b> <br>  [176, 176, 65] &lt;= There are even and not even <br>  [176, 65, 176] &lt;= There are even and even <br>  [65, 176, 176] &lt;= There are even and even <br><br>  <b>part_b</b> <br>  [176, 176, 65] &lt;= There are even and not even <br>  [176, 65, 176] &lt;= There are even and even <br>  [65, 176, 176] &lt;= There are even and even <br><br>  <b>valid_table = part_a * part_a</b> <br>  [ 100 ] <br>  [0, 1, 0] <br>  [0, 0, 1] <br><br>  Since there are no ‚Äúoptions‚Äù with ‚Äúeven‚Äù and ‚Äúnot even‚Äù elements, we conclude that there is an error in the quacks.  There is a logical question. <br><br><h5>  What is the mistake? </h5><br>  After a quick reflection, we conclude that the error lies in the fixed matrix <b>[0x3, 0x5, 0x7, 0x5, 0x7, 0x3, 0x7, 0x3, 0x5]</b> .  To get even and odd "options", you must replace <b>"0x3"</b> , <b>"0x5"</b> and <b>"0x7"</b> with <b>"0x2"</b> , <b>"0x3"</b> and <b>"0x8",</b> respectively, or with another variant, where there will be two even and one odd element, for example, on such <b>"0x4"</b> , <b>"0x7"</b> and <b>"0x8"</b> (as an option). <br><br>  This error was reported to Kaspersky Lab.  They said that the version (which we are currently exploring) is a draft.  After that, on the same day, everyone was sent a version without error.  True, in the new version, there were no fixed tables anymore and it was solved even easier than this one, but I will tell about this later in the bonus section :) <br><br>  To make sure that you have performed the correct replacement (for example, if you decide to insert other characters other than <b>"0x2"</b> , <b>"0x3"</b> and <b>"0x8"</b> ), you should use the following "spell": <br><br><pre> <code class="python hljs">serial_data = [<span class="hljs-number"><span class="hljs-number">52</span></span>, <span class="hljs-number"><span class="hljs-number">233</span></span>, <span class="hljs-number"><span class="hljs-number">91</span></span>, <span class="hljs-number"><span class="hljs-number">105</span></span>, <span class="hljs-number"><span class="hljs-number">65</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">176</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">225</span></span>, <span class="hljs-number"><span class="hljs-number">81</span></span>, <span class="hljs-number"><span class="hljs-number">207</span></span>, <span class="hljs-number"><span class="hljs-number">79</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>] a = <span class="hljs-number"><span class="hljs-number">0x2</span></span> b = <span class="hljs-number"><span class="hljs-number">0x3</span></span> c = <span class="hljs-number"><span class="hljs-number">0x8</span></span> first_part = [a, b, c, b, c, a, c, a, b] second_part_new = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] count = <span class="hljs-number"><span class="hljs-number">0</span></span> result_table = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> serial_data: second_part_new[<span class="hljs-number"><span class="hljs-number">0</span></span>] = byte_1 <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> serial_data: second_part_new[<span class="hljs-number"><span class="hljs-number">1</span></span>] = byte_2 <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> serial_data: second_part_new[<span class="hljs-number"><span class="hljs-number">2</span></span>] = byte_3 res = get_items(first_part, second_part_new) print(<span class="hljs-string"><span class="hljs-string">"index: %s, table: %s"</span></span> % (count, res)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res[<span class="hljs-number"><span class="hljs-number">0</span></span>] % <span class="hljs-number"><span class="hljs-number">16</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> res[<span class="hljs-number"><span class="hljs-number">1</span></span>] % <span class="hljs-number"><span class="hljs-number">16</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> res[<span class="hljs-number"><span class="hljs-number">2</span></span>] % <span class="hljs-number"><span class="hljs-number">16</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span>\ (res[<span class="hljs-number"><span class="hljs-number">0</span></span>] % <span class="hljs-number"><span class="hljs-number">16</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> res[<span class="hljs-number"><span class="hljs-number">1</span></span>] % <span class="hljs-number"><span class="hljs-number">16</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> res[<span class="hljs-number"><span class="hljs-number">2</span></span>] % <span class="hljs-number"><span class="hljs-number">16</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span>\ (res[<span class="hljs-number"><span class="hljs-number">0</span></span>] % <span class="hljs-number"><span class="hljs-number">16</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> res[<span class="hljs-number"><span class="hljs-number">1</span></span>] % <span class="hljs-number"><span class="hljs-number">16</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> res[<span class="hljs-number"><span class="hljs-number">2</span></span>] % <span class="hljs-number"><span class="hljs-number">16</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>): result_table.append(res) count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">"Count:"</span></span>, count) print(<span class="hljs-string"><span class="hljs-string">"Good:"</span></span>, result_table)</code> </pre> <br>  If the bait was chosen correctly (as in our case, ‚Äú0x2, 0x3, 0x8‚Äù), then at least one beast (a group of three arrays) will appear in your traps (in the ‚ÄúGood‚Äù field).  An example output for a fixed matrix (with the elements "0x2", "0x3" and "0x8") is shown below: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe2/8c6/2db/fe28c62dbfb616ff5c3665c2b186998f.png" alt="image"><br>  Fig.  17 <br><br>  As you can see, luck has smiled on us, so as many as three wild beasts fell into our traps, which of course will contribute to the setting of the holiday table (that is, it can be used to form <b>part_a</b> and <b>part_b</b> ). <br><br>  The most attentive ones have already noticed that the output in the <b>‚ÄúGood‚Äù line</b> can be divided into groups, each of which will have three lines. <br><br>  [0, 144, 81] <br>  [81, 0, 144] <br>  [144, 81, 0] <br><br>  [144, 145, 0] <br>  [0, 144, 145] <br>  [145, 0, 144] <br><br>  [0, 144, 209] <br>  [209, 0, 144] <br>  [144, 209, 0] <br><br>  Even more attentive probably noticed that all these characters are included in the sets of "zero" and "single" characters;) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/394/c77/064394c77d38106fd46151e56897cecb.png" alt="image"><br>  Fig.  18 <br><br>  Well, the shrewd ones (I hope) are already feasting at the big table, as they were able to hunt down a big beast, luring it with such a ‚Äúspell‚Äù: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   # [0, 144, 209] # [209, 0, 144] # [144, 209, 0] a = 144 b = 209 c = 0 #      part_a = [c, a, b, b, c, a, a, b, c] part_b = [a, b, c, c, a, b, b, c, a] # part_a1 = [0, 144, 209] # part_a2 = [209, 0, 144] # part_a3 = [144, 209, 0] # part_a = part_a1 + part_a2 + part_a3 # part_b1 = [144, 209, 0] # part_b2 = [0, 144, 209] # part_b3 = [209, 0, 144] # part_b = part_b1 + part_b2 + part_b3 result = create_table(part_a, part_b) print(result)</span></span></code> </pre> <br>  At this point, we will finish solving this quack ... How to translate the internal bytes into a normal form, so that they can be entered into the window of the quack, I think you will understand. <br><br>  For now you understand we will pass to consideration new (corrected) kryakmi.  I just want to say that everything that we have considered for this quack is also relevant for the new, so we confine ourselves to a superficial description of the principle of its work and give a link to keygen (for the more curious or, on the contrary, lazy). <br><br><h4>  Bonus (keygen + new crack job description) </h4><br>  In order not to get confused with the available versions - we will introduce some clarity in their numbering: <br><ul><li>  <b>ZeroNightsCrackMe_v1</b> - reviewed <a href="http://habrahabr.ru/post/204432/">here</a> . </li><li>  <b>ZeroNightsCrackMe_v2</b> - is a draft version and is described earlier in this article. </li><li>  <b>ZeroNightsCrackMe_v3</b> - superficially discussed below + given keygen. </li></ul><br><h5>  The validation table check algorithm and the validation table itself </h5><br>  As in all previous versions of <b>v1</b> and <b>v2</b> . <br><br><h5>  Algorithm for filling the validation table </h5><br>  As in the draft version of <b>v2</b> (discussed earlier in this article). <br><br><h5>  Data for algortim filling validation table </h5><br>  The principle of operation is the same as in the very first version of <b>v1</b> , but other mixers are used. <br><br><h5>  Algorithm for converting a serial code into an internal representation, a conversion table and an allowable range </h5><br>  As in all previous versions of <b>v1</b> and <b>v2</b> . <br><br><h5>  Keygen for the new version </h5><br>  Cracks versions <b>v2</b> and <b>v3</b> can be found <a href="http://forum.reverse4you.org/showthread.php%3Ft%3D1653">in this thread</a> .  There you will find the keygen for the new version <b>v3</b> from me <b>Darwin</b> . <br><br>  <b>Password for archive from keygen:</b> Darwin_1iOi7q7IQ1wqWiiIIw <br><br>  Check keygen for the third version of crack: <br><br>  &gt; keygen_v3.py habrahabr.ru&gt; result.txt <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0c/797/c61/a0c797c61323293bdd8249bd9776f684.png" alt="image"><br>  Fig.  nineteen <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a06/e31/3ca/a06e313ca889e0110323a20c78380e55.png" alt="image"><br>  Fig.  20 <br><br>  Thanks to all who read to the end!  See you soon! </div><p>Source: <a href="https://habr.com/ru/post/215225/">https://habr.com/ru/post/215225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215207/index.html">IBM Watson supercomputer has learned to create its own recipes</a></li>
<li><a href="../215211/index.html">Monkeyrunner. Pixel-perfect testing web pages on Android</a></li>
<li><a href="../215213/index.html">Image Catalyst 2.5</a></li>
<li><a href="../215215/index.html">Is the smart home controller (with Ethernet, WiFi, USB, blackjack and buns) for $ 20?</a></li>
<li><a href="../215223/index.html">Stanford University developed a paper microscope worth less than a dollar</a></li>
<li><a href="../215227/index.html">Simple monitoring of server load in real time with a web interface</a></li>
<li><a href="../215229/index.html">‚ÄúStolen‚Äù money found on MtGox accounts</a></li>
<li><a href="../215233/index.html">DDOS of any site using Google Spreadsheet</a></li>
<li><a href="../215235/index.html">LUA in nginx: a slightly intelligent firewall</a></li>
<li><a href="../215237/index.html">LUA in nginx: hot cache in memory</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>