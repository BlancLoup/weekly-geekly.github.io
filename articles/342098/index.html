<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing through the eyes of the developer: tools, myths, situations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Evgeny Safronov, Senior Developer, DataArt 

 ‚ÄúTesting can be used to prove the presence of errors in the program, and never to prove their absence!‚Äù ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing through the eyes of the developer: tools, myths, situations</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/na/2i/a0/na2ia0qrxjeejmctkg0qoeyx878.jpeg"><br><br>  <i>Evgeny Safronov, Senior Developer, DataArt</i> <br><br>  <i>‚ÄúTesting can be used to prove the presence of errors in the program, and never to prove their absence!‚Äù</i> <i><br></i>  <i>Edsger Dijkstra</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Testing is an applied, standardized, engineering practice that is applicable in most branches of human life.  Testing, like philosophy, metrics or practice, exists much longer than programming.  For example, we forged a sword.  To check whether it is sharp enough, it turned out, it is tested.  In some epochs even on a live person, say, a slave. <br><br>  Testing is a test of the functionality of a program, item or any industrial development.  As in any business, there are subtleties and a philosophy here.  It is probably closer to testers who look destructively at things we produce - from the very beginning they are thinking about how to break a product offered by developers.  This is not very typical for users who are more predictable and usually find errors, accidentally trying to do something atypical with our program.  Developers have a different approach to software, but we must remember: testers must break what we have created - this is their bread. <a name="habracut"></a><br><br><h3>  Why is testing programs so important? </h3><br>  Developers do not think through testing, we think creatively - and this can be a source of problems.  When we are asked to write a program, we first of all think about concepts, data structures, their description and interaction.  As a result, we present a solution - ready, albeit crowded with bugs.  Usually we have little idea what will happen if the input data changes, if the user performs a large number of atypical operations. <br><br>  At the same time, practice shows that the most costly mistakes occur as a result of small changes.  Because if you have written a bad piece of code, a more experienced colleague will ask you to redo it.  With experience, you yourself will notice the unfortunate fragments almost immediately.  But when errors are minimal - a separate symbol, a point, a sign of a financial transaction, a rounding error - it is very difficult to find them, and at any stage. <br><br><img src="https://habrastorage.org/webt/0o/wf/s1/0owfs1scow6odrxp_xirtisyno0.png"><br>  <i>Fig.</i>  <i>1. Authorization form and the number of options to fill it out.</i> <br><br>  Let's see why there is such difficulty in testing.  In the figure we see a simple form of three fields.  In the first two fields, you can enter from 1 to 255 letters, in the third from 1 to 20 characters.  You can also leave the lines blank.  Below we see the number of possible combinations, which is significantly higher than the number of elementary particles in the universe.  I think this is convincing evidence that it is unrealistic to check all possible cases.  Yes, and try to do it, probably inappropriate. <br><br><h3>  Types of project errors </h3><br><img src="https://habrastorage.org/webt/my/tu/up/mytuupzhrh2bju5hklqy2uzhsxa.png"><br>  <i>Fig.</i>  <i>2. The scheme of the distribution of errors by type, according to the data of Steve McConnell‚Äôs ‚ÄúPerfect Code‚Äù.</i> <br><br>  Approximately 25% of the total amount accounted for structural errors.  They arise at the design stage, when you create data structures and write implementations of manipulations with them, that is, you create some kind of ‚Äúglue‚Äù that holds these structures together.  This is a huge layer of fundamental mistakes. <br><br>  Next are the data errors associated with the implementation of functionality, etc. It is interesting that the architecture is in last place.  This can be explained by the fact that, creating the wrong architecture, it is very difficult in principle to produce the final product. <br><br><img src="https://habrastorage.org/webt/at/ph/wd/atphwdl6oimajmlz2c7nqseexfu.png"><br>  <i>Fig.</i>  <i>3. Distribution of errors by development stages.</i>  <i>Scheme of Steve McConnell.</i> <br><br>  At the design and design stage, there is a major layer of errors and defects.  The well-known Pareto rule works here: 80% of defects are localized only in 20% of your code.  As a rule, these are some kind of corner cases.  If you write operations with mathematical, for example, financial logic, a lot of errors can be within the boundary values, when rounding numbers, etc. Most of your cases will work, but most of the defects will be localized in a small section of code. <br><br>  Regardless of whether you use manual or unit testing, you cannot argue that by covering 50% of the code with tests, you managed to prevent 50% of possible defects.  If you wrote 100 unit tests, you cannot say that the final quality of your product has improved, for example, twice.  Because the developer who does not think through the prism of testing, checks the easiest cases.  The required forms are filled with the standard name, surname and login - the developer goes further.  He most likely will not check for cases when one of the fields remains empty, or when a name of 255 characters is actually inserted into it.  He will not experiment with non-standard characters, combinations of lowercase and uppercase letters. <br><br>  Testing is the most popular quality management technique.  If you recall our example with a sword, then before using it in a real battle, you will definitely ask to experience it longer.  It is even better if, at the production stage, you agree with the blacksmith to also test the metal from which he will forge the weapon.  To improve the quality of the program, we, respectively, want to increase the amount of testing and at the same time use the best practices.  In proportion to our efforts, the quality of our product will increase. <br><br>  Anyone can test a product: developer, tester, manager, customer.  Sometimes in small projects, the role of a tester can be performed by a manager or developer.  But all the four roles here are very important - each participant in the process looks at the object from his own point of view.  Developer - through the prism of how the code works.  From the very beginning he has most of the information on how to break the interface.  For a tester, finding bugs and breaking a product is a direct task.  The customer looks at the tests in a completely different way: he is interested in how to write fewer tests and pay less money, still getting a quality product in the end.  But the most interesting role of the manager, who can usually rely on cases from his own practice.  However, as a rule, it serves as a bridge between developers, testers and customers, and its main task comes down to product presentation.  But it is the manager who is responsible for the quality of the product at the outlet. <br><br><h3>  Testing black and white boxes </h3><br>  The classification of testing in the form of analysis of white, gray and black boxes is interesting to us because the developer looks at his own code as a white box.  And the tester and the customer view the program as a black box - they do not fully understand how the program works, they only know which features are important and must work. <br><br>  The bug on the website of the online store, because of which some product does not fall into the basket, for the developer - a minor problem.  It is enough to commit and uncommit, change variables in one place - and everything will work fine.  For the tester, and especially the customer, such a bug turns out to be critical, since it does not allow the client to buy the right product. <br><br>  But the most interesting box is gray.  Those who I call clever testers, who delve deeply into the code and how the product works, work with it.  They are interested in how it is deployed and communicating with databases. <br><br><h3>  What tests do the developers write? </h3><br><ul><li>  Unit Tests.  Most developers use manual testing.  If you have done something, first of all, you need to make sure that it really works, check the input data and variables and get some feedback.  Unit tests are a kind of unit testing, that is, we need to check whether each piece of code works correctly. </li><li>  Functional tests.  With their help, we check individual features, bundles of our modules, and so on. </li><li>  Integration tests.  They allow you to check whether our two modules can work together. </li><li>  End-to-end testing.  Check of any feature from the point of view of the client and from beginning to end.  Suppose we can not be responsible for the work of the courier service.  But you can make sure that the customer can choose and pay for the product in an online store written by you.  And in that the goods will be ready for shipment. </li></ul><br><br><img src="https://habrastorage.org/webt/ko/hn/lz/kohnlz9wkmgegbfnwfhj1fmxqes.png"><br>  <i>Fig.</i>  <i>4. The unit test pyramid.</i> <br><br>  The basis of the pyramid - unit testing - it is desirable that the unit tests in the project was a lot.  This is followed by integration testing of our modules, Acceptance Tests and direct UI testing of specific features. <br><br><h3>  FIRST </h3><br>  FIRST is a methodology for describing requirements that tests must meet.  First of all, modular, but in principle, these characteristics can be extrapolated to automatic tests.  Its creator, the famous Uncle Bob, is the author of many programming practices. <br><br><ul><li>  Speed ‚Äã‚Äã(Fast).  Tests should be fast, no one will run slow tests.  Even a team of 30 testers does not have enough time to conduct them. </li><li>  Independence (Independent).  Tests must be independent: no element can depend on the performance of the previous one. </li><li>  Repeatability.  You should be able to run any test at any time, and its behavior should be predictable. </li><li>  Evidence (Self-Validating).  The behavior of the test should be obvious, especially for those who create the program. </li><li>  Timely.  Tests should be written when they are really needed. </li></ul><br><br><img src="https://habrastorage.org/webt/x0/cj/bf/x0cjbfx_k94agxqjfvgcoeckpek.png"><br>  <i>Fig.</i>  <i>5. Scheme of the TDD process.</i> <br><br>  The two basic unit testing methodologies are similar TDD and BDD concepts.  The BDD approach is based on TDD and aims to eliminate the small flaws that are present in TDD.  The syntax of BDD tests is more business-oriented and understandable to the customer and generally less technically savvy person.  TDD - how to do things right.  BDD - how to do the right thing. <br><br><h3>  What does the TDD process look like? </h3><br>  First of all, you are writing a test for code that has not yet been written.  Accordingly, see that it does not work.  To make it work, the code still needs to be written.  Then you still write the code, run the test and make sure that the test works.  Then you modify your test (specify the requirements, add the check of boundary conditions, etc.).  After that, your test stops working, and again you come to the need to modify your code.  This process is looped through until your test clearly meets the final criteria and meets the tasks you are facing.  Suppose if you solve a quadratic equation, your task is to write a function that finds the roots of a quadratic equation.  Suppose you wrote a test, and it works well based on real numbers.  But if the user wants to find a comprehensive solution, then it will not work, the test will fill up and require modification.  Therefore, this scheme should be in the blood of the developers: you need to act on it until your feature meets all the requirements. <br><br><h3>  What does TDD look like? </h3><br><pre><code class="javascript hljs">suite(<span class="hljs-string"><span class="hljs-string">'#factorial()'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ test(<span class="hljs-string"><span class="hljs-string">'equals 1 for sets of zero length'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ assert.equal(<span class="hljs-number"><span class="hljs-number">1</span></span>, factorial(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }); test(<span class="hljs-string"><span class="hljs-string">'equals 1 for sets of length one'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ assert.equal(<span class="hljs-number"><span class="hljs-number">1</span></span>, factorial(<span class="hljs-number"><span class="hljs-number">1</span></span>)); }); test(<span class="hljs-string"><span class="hljs-string">'equals 2 for sets of length two'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ assert.equal(<span class="hljs-number"><span class="hljs-number">2</span></span>, factorial(<span class="hljs-number"><span class="hljs-number">2</span></span>)); }); test(<span class="hljs-string"><span class="hljs-string">'equals 6 for sets of length three'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ assert.equal(<span class="hljs-number"><span class="hljs-number">6</span></span>, factorial(<span class="hljs-number"><span class="hljs-number">3</span></span>)); }); });</code> </pre> <br>  The example is written in JavaScript, but I think, in syntactical terms, it will also look something like for PHP or Java.  It's pretty obvious.  By opening the test, you can easily tell which points were not tested.  You can add something quickly and easily.  And thus check whether your function works correctly. <br><br>  BDD is very similar to TDD, but differs in that the wording in the description is slightly better adapted for people less closely associated with the development: managers or business analysts. <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'#factorial()'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ it(<span class="hljs-string"><span class="hljs-string">'should return 1 when given 0'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ factorial(<span class="hljs-number"><span class="hljs-number">0</span></span>).should.equal(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'should return 1 when given 1'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ factorial(<span class="hljs-number"><span class="hljs-number">1</span></span>).should.equal(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'should return 2 when given 2'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ factorial(<span class="hljs-number"><span class="hljs-number">2</span></span>).should.equal(<span class="hljs-number"><span class="hljs-number">2</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'should return 6 when given 3'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ factorial(<span class="hljs-number"><span class="hljs-number">3</span></span>).should.equal(<span class="hljs-number"><span class="hljs-number">6</span></span>); }); });</code> </pre> <br><h3>  Features of unit testing </h3><br><ul><li>  Because of its atomicity and simplicity, unit testing allows the developer to write a lot of tests, and quite quickly. </li><li>  Parts of your code (mocks, stubs, spies) have to be isolated.  Modularity involves testing individual small areas, respectively, if these areas are related to others, then they should be tested separately. </li><li>  The important point is that you can write a test only when you understand how the code should work (testing the white box).  In many languages ‚Äã‚Äãthere are tools for unit testing, but in JavaScript there are just a huge amount.  Basically, they are sharpened to test the description of the BDD-style.  Although there are, for example, QUnit and other services, created at an early stage of development, JS and jQuery, to the TDD approach.  Everyone can choose what they like best, in the English-speaking community, Karma and Jasmine are common.  I like Mocha more, very productive piece, effective directly at the development stage. </li></ul><br><br><img src="https://habrastorage.org/webt/u6/hi/ua/u6hiuak3omsxsytcvzz2mdjghi8.png"><br>  <i>Fig.</i>  <i>6. Unit testing tools.</i> <br><br>  <b>QUnit</b> is a library from jQuery developers that allows you to write unit tests in TDD style, with the assert mechanism.  You write qunit.test, the name of the test, and what you want to test. Then run it in a separate file that your code should see, and you can make sure that the code works. <br><br>  <b>Mocha</b> is a testing framework that allows you to write tests in TDD and BDD format.  As a rule, it is used in conjunction with other tools in order to fully implement the TDD approach in work.  That is, it allows you to run and describe tests in the correct format, and for example, another library (most often Chai) is responsible for processing assertion check (asserts). <br><br>  <b>Sinon</b> is a tool for creating Mocks, stubs and spies, which is very often used in modern successful projects.  It contains a set of functions and modules that are great help and solve a large number of typical problems that arise from the developer during the creation of unit tests. <br><br>  <b>Jasmine</b> is a popular BDD library that has actually become a standard in the most common Angular Javascript framework ecosystem. <br><br><h3>  Myths </h3><br><ul><li>  Testing is long and expensive.  In fact, you need to find a balance and explain to the customer why it is needed.  If we do not cover the library that works with financial data with tests, then, of course, we will release our service three days earlier.  But the customer must understand and accept the risks that may arise as a result of failure to test.  How important is the smooth operation of a module, as a rule, the customer understands very well. </li><li>  Writing tests is boring and tedious.  But brushing your teeth is also not very exciting, and we do it every day.  Just because they are used to this ritual.  Exactly the same position should take tests in the life of the developer.  Maybe it is worth rebuilding your thinking a bit and looking at your programs, including through the prism of testing. </li><li>  It is possible to cover with tests 100% of the code.  Even if you did not find any errors, it does not mean that in the end some bugs will not pop up.  But writing tests significantly increases the chances that the final product will work.  If you brush your teeth, it does not mean that they will never fall out.  But no one doubts the benefits of this hygienic procedure. </li></ul><br><h3>  Project Situations </h3><br><ul><li>  The customer does not support the idea of ‚Äã‚Äãwriting unit tests in the project.  In such situations, it is worth finding a balance and negotiating so that the product being created meets the required level of quality.  There are also conscious customers who ask themselves to write tests. </li><li>  The second point is that tests are written only for the presence of metrics, and due attention is not paid to the ‚Äúpurity‚Äù of tests.  "When there is nothing to do - this is rare, but it also happens - write tests," says the manager.  The developer agrees, but he writes tests without considering the root cases, but simply duplicates the previous ones.  No one needs these tests, but the coverage is growing, money is dripping.  Only at the end there is every chance of getting a failed product. </li><li>  You write the tests much later than the creation of the code - in fact, this is also bad.  I don‚Äôt think that it‚Äôs real to write tests on your own code of, say, three years ago in the principle.  Understanding how the code worked, what are the main conditions in the work of individual modules is not at all easy. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/342098/">https://habr.com/ru/post/342098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342080/index.html">Run / debug Python scripts in LXC / LXD containers from under VS Code</a></li>
<li><a href="../342088/index.html">How to increase the level of service and increase the profits of companies using communication solutions</a></li>
<li><a href="../342090/index.html">Java nested classes</a></li>
<li><a href="../342094/index.html">Export data in any format: what IDE can do on IntelliJ platform</a></li>
<li><a href="../342096/index.html">How to discover a million dollars in your AWS account</a></li>
<li><a href="../342100/index.html">Universal smart multi-signature contract in Ethereum</a></li>
<li><a href="../342102/index.html">Technical features of the ICO. Start</a></li>
<li><a href="../342104/index.html">In five days I was interviewed at five Silicon Valley companies and received five job offers</a></li>
<li><a href="../342106/index.html">Just about D3.js</a></li>
<li><a href="../342108/index.html">Guide to creating your own cohort recurrence report</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>