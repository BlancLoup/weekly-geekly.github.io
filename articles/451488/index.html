<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Calculation of cannibalization based on the classic A / B test and the bootstrap method</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article describes a method for calculating cannibalization for a mobile application based on the classic A / B test. In this case, the target act...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Calculation of cannibalization based on the classic A / B test and the bootstrap method</h1><div class="post__text post__text-html js-mediator-article">  This article describes a method for calculating cannibalization for a mobile application based on the classic A / B test.  In this case, the target actions within the re-attribution process from the advertising source (Direct, Criteo, AdWords UAC and others) are considered and evaluated in comparison with the target actions in the group to which the advertisement was turned off. <br><br>  The article provides an overview of the classical methods of comparing independent samples with a brief theoretical basis and a description of the libraries used, including  briefly describes the essence of the bootstrap method and its implementation in the FaceBook Bootstrapped library, as well as the problems encountered in practice when using these techniques, and how to solve them. <br><a name="habracut"></a><br>  Actual data is either obfuscated or not presented in order to preserve the none-disclosure agreement. <br><br>  In the future, I plan to complement and slightly modify this article as new facts appear, so this version can be considered the first release.  I would be grateful for comments and reviews. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Introduction </h3><br>  Cannibalization is the process of flowing traffic, full and targeted, from one channel to another. <br><br>  Marketers usually use this indicator as an additional K factor when calculating the CPA: the pre-calculated CPA is multiplied by 1 + K.  In this case, CPA means total spending on attracting traffic / number of targeted actions that are monetized directly, that is, brought actual profit - for example, a target call, and / or monetized indirectly - for example, an increase in the volume of the ad database, audience growth, and so on. <br><br>  When free channels (for example, calls from organic SERPs, links to links on sites that are free for us) cannibalize for money (Direct, Adwords instead of organic, advertising in social networks feeds instead of clicks on ads, free placed in groups, and so on), this carries with it risks of financial loss, so it is important to know the cannibalization rate. <br><br>  In our case, there was the task of calculating the cannibalization of "organic" transitions into the application by transitions from the Criteo advertising network.  Observation is considered a device or user-uid (GAID / ADVID and IDFA). <br><br><h3>  Preparing the experiment </h3><br>  You can prepare an audience for the experiment by dividing users into groups in the interface of the AdJust analytical system to isolate those who will see ads from a certain advertising network (control sample) and those who will not be shown ads using GAID or ADVID and IDFA, respectively. (AdJust provides API Audience Builder).  Further, on the control sample, you can include an advertising campaign in the advertising network studied in the experiment. <br><br>  I note from myself that, as it seems intuitively, the following implementation of the experiment would be more competent in this case: choose four groups - those who have disabled retargeting from all channels (1), as an experimental group, and those who have Only retargeting with Criteo (2) is enabled;  those who only had to disable retargeting with Criteo (3), those who had enabled all retargeting (4).  Then it would be possible to calculate (1) / (2), having obtained the actual value of cannibalization of ‚Äúorganic‚Äù transitions to the application in the Criteo network by advertising campaigns, and (3) / (4), having obtained the cannibalization of Criteo in a ‚Äúnatural‚Äù environment (after all, Criteo is obviously , can cannibalize other paid channels).  The same experiment should be repeated for other advertising networks to determine the impact of each of them;  in an ideal world, it would be good to explore also cross-cannibalization between all key paid sources that make up the largest share of total traffic, but it would take so long (both to prepare experiments in terms of development and to evaluate the results), which would cause criticism for unwarranted meticulousness. <br><br>  In fact, our experiment was carried out under conditions (3) and (4), the samples were broken down in a ratio of 10% to 90%, the experiment was carried out for 2 weeks. <br><br><h3>  Preliminary preparation and verification of data </h3><br>  Before the start of any research, an important stage is the competent preparation and cleaning of data. <br><br>  It should be noted that the actual active devices for the period of the experiment were 2 times less (42.5% and 50% of the control and experimental groups, respectively) than the devices in the full initial samples, which is explained by the nature of the data: <br><br><ol><li>  firstly (and this is the key reason), the sample for retargeting from Adjust contains identifiers of all devices that have ever installed the application, that is, those devices that are no longer used, and those from which the application was already deleted </li><li>  secondly, it is not necessary that from all devices during the experiment was entered into the application. </li></ol><br>  However, the calculation of cannibalization, we carried out on the basis of data from the full sample.  For me personally, the correctness of such a calculation still seems to be a controversial issue - in general, in my opinion, it is more correct to clean everyone who deleted the application and did not install it any more with the appropriate tags, as well as those who did not enter the application for more than a year - for this period of time the user could change the device;  minus - in this way, for the experiment, those users who did not go to the application could be removed from the sample, but could do this, we show them advertising on the Criteo network.  I want to note that in a good world, all these forced neglects and assumptions should be investigated and verified separately, but we live in a world of do it fast and furry. <br><br>  In our case, it is important to check the following points: <br><br><ol><li>  We check for the presence of intersection in our initial samples - experimental and control.  In a properly implemented experiment, there should be no such intersections, but in our case there were several duplicates from the experimental sample in the control.  In our case, the share of these duplicates in the total volume of devices involved in the experiment was small, so we neglected this condition.  If duplicates were&gt; 1%, it would be necessary to consider the experiment as incorrect and to re-examine, after having cleaned the duplicates. </li><li>  We check that the data in the experiment were really affected - in the experimental sample retargeting should have been disabled (at least with Criteo, in a correctly set experiment - from all channels), therefore it is necessary to check for the absence of DeviceID from the experiment in retargeting with Criteo.  In our case, the DeviceID from the experimental group did fall into retargeting, but there were less than 1% of them, which is negligible. </li></ol><br><h3>  Direct evaluation of the experiment </h3><br>  We will consider the change of the following target metrics: absolute - the number of calls, and relative - the number of calls per user in the control (seen advertising on the Criteo network) and experimental (the advertisement was turned off) groups.  In the code below, the variable data means the structure pandas.DataFrame, which is formed from the results of an experimental or control sample. <br><br>  There are parametric and non-parametric methods for assessing the statistical significance of differences in values ‚Äã‚Äãin unrelated samples.  Parametric evaluation criteria provide greater accuracy, but have limitations in their application - in particular, one of the basic conditions is that the measured values ‚Äã‚Äãfor the observations in the sample should be distributed normally. <br><br><h4>  1. The study of the distribution of values ‚Äã‚Äãin the samples for normality </h4><br>  The first step is to examine the existing samples for the type of distribution of values ‚Äã‚Äãand the equality of sample variances using standard tests - the Kolmogorov-Smirnov and Shapiro-Wilks criteria and the Bartlett criteria implemented in the sklearn.stats library, taking p-value = 0.05: <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    : def norm_test(df, pvalue = 0.05, test_name = 'kstest'): if test_name == 'kstest': st = stats.kstest(df, 'norm') if test_name == 'shapiro': st = stats.shapiro(df) sys.stdout.write('According to {} {} is {}normal\n'.format(test_name, df.name, {True:'NOT ', False:''}[st[1] &lt; pvalue])) #    : def barlett_test(df1, df2, pvalue = 0.05): st = stats.bartlett(df1, df2) sys.stdout.write('Variances of {} and {} is {}equals\n'.format(df1.name, df2.name, {True:'NOT ', False:''}[st[1] &lt; pvalue]))</span></span></code> </pre> <br>  Additionally, for visual assessment of the results, you can use the histogram function. <br><br><pre> <code class="python hljs">data_agg = data.groupby([<span class="hljs-string"><span class="hljs-string">'bucket'</span></span>]).aggregate({<span class="hljs-string"><span class="hljs-string">'device_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'nunique'</span></span>, <span class="hljs-string"><span class="hljs-string">'calls'</span></span>: <span class="hljs-string"><span class="hljs-string">'sum'</span></span>}).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) data_conv = data_agg[<span class="hljs-string"><span class="hljs-string">'calls_auto'</span></span>]/data_agg[<span class="hljs-string"><span class="hljs-string">'device_id'</span></span>] data_conv.hist(bins=<span class="hljs-number"><span class="hljs-number">20</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/8m/zc/u4/8mzcu4-emautrimdpvczuttfkf8.png" alt="image"><br><br>  You can read the histogram like this: 10 times in the sample, a conversion rate of 0.08 was found, 1 - 0.14.  On the number of devices as observations for any of the conversion indicators it says nothing. <br><br>  In our case, the distribution of the parameter value both in absolute values ‚Äã‚Äãand in relative values ‚Äã‚Äã(the number of calls per device) in the samples is not normal. <br>  In this case, you can apply either the non-parametric Wilcoxon criterion, implemented in the standard library sklearn.stats, or try to reduce the distribution of values ‚Äã‚Äãin the samples to a normal form and apply one of the parametric criteria - Student's aka t-test or Shapiro-Wilks. <br><br><h4>  2. Methods of reducing the distribution of values ‚Äã‚Äãin samples to normal </h4><br>  <b>2.1.</b>  <b>Sub-buckets</b> <br><br>  One approach to reducing distribution to a normal view is the sub-bucket method.  Its essence is simple, and the theoretical basis is the following mathematical thesis: according to the classical central limit theorem, the distribution of averages tends to normal - the sum of n independent identically distributed random variables has a distribution close to normal, and, equivalently, the distribution of sample averages of the first n independent identically distributed random variables values ‚Äã‚Äãtends to normal.  Therefore, it is possible to break existing buckets into sub-buckets and, accordingly, taking average values ‚Äã‚Äãfor sub-buckets for each of the buckets, we can get a distribution close to normal: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   subbucket' data['subbucket'] = data['device_id'].apply(lambda x: randint(0,1000)) # Variant 1 data['subbucket'] = data['device_id'].apply(lambda x: hash(x)%1000) # Variant 2</span></span></code> </pre> <br>  There can be many options for partitioning, it all depends on the imagination and moral principles of the developer - you can take an honest random or use hash from the original bucket, thereby taking into account in the scheme the mechanism of its issuance. <br><br>  However, in practice, out of several dozen code launches, we received a normal distribution only once, that is, this method is neither guaranteed nor stable. <br><br>  In addition, the ratio of target actions and users to the total number of actions and users in sub-buckets may not be consistent with the original backet, so you must first check that the relationship is maintained. <br><br><pre> <code class="python hljs">data[data[<span class="hljs-string"><span class="hljs-string">'calls'</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>].device_id.nunique()/data.device_id.nunique() <span class="hljs-comment"><span class="hljs-comment"># Total buckets = data.groupby(['bucket']).aggregate({'device_id': 'nunique', 'calls': 'sum'}) buckets[buckets['calls'] &gt; 0].device_id.nunique()/buckets.device_id.nunique() # Buckets subbuckets = data.groupby(['subbucket']).aggregate({'device_id': 'nunique', 'calls': 'sum'}) subbuckets[subbuckets['calls'] &gt; 0].device_id.nunique()/subbuckets.device_id.nunique() # Subbuckets</span></span></code> </pre> <br>  In the course of such a test, we found that the conversion ratios for subbuckets relative to the original sample are not preserved.  Since we need to additionally guarantee the consistency of the ratio of the proportion of calls in the output and initial samples, we apply class balancing, adding weighting - so that the data are separately selected by subgroups: separately from observations with target actions and separately from observations without target actions in the right proportion.  In addition, in our case, the samples were not evenly distributed;  it seems intuitively that the mean should not change, but how the unevenness of the samples affects the variance is not obvious from the dispersion formula.  In order to clarify whether the difference in sample sizes affects the result, the Xi-square test is used - if a statistically significant difference is detected, then a larger data frame will be sampled to a smaller one: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class_balancer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df1, df2, target = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'calls'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, pvalue=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.05</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> df1_target_size = len(df1[df1[target] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>]) print(df1.columns.to_list()) df2_target_size = len(df2[df2[target] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>]) total_target_size = df1_target_size + df2_target_size chi2_target, pvalue_target, dof_target, expected_target = chi2_contingency([[df1_target_size, total_target_size], [df2_target_size, total_target_size]]) df1_other_size = len(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>]) df2_other_size = len(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>]) total_other_size = df1_other_size + df2_other_size chi2_other, pvalue_other, dof_other, expected_other = chi2_contingency([[df1_other_size, total_other_size], [df2_other_size, total_other_size]]) df1_target, df2_target, df1_other, df2_other = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pvalue_target &lt; pvalue: sample_size = min([df1_target_size, df2_target_size]) df1_rnd_indx = np.random.choice(df1_target_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df2_rnd_indx = np.random.choice(df2_target_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df1_target = pd.DataFrame((np.asarray(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">1</span></span>])[df1_rnd_indx]).tolist(), columns = df1.columns.tolist()) df2_target = pd.DataFrame((np.asarray(df2[df2[target] == <span class="hljs-number"><span class="hljs-number">1</span></span>])[df2_rnd_indx]).tolist(), columns = df2.columns.tolist()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p_value_other &lt; pvalue: sample_size = min([df1_other_size, df2_other_size]) df1_rnd_indx = np.random.choice(df1_other_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df2_rnd_indx = np.random.choice(df2_other_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df1_other = pd.DataFrame((np.asarray(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>])[df1_rnd_indx]).tolist(), columns = df1.columns.tolist()) df2_other = pd.DataFrame((np.asarray(df2[df2[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>])[df2_rnd_indx]).tolist(), columns = df2.columns.tolist()) df1 = pd.concat([df1_target, df1_other]) df2 = pd.concat([df2_target, df2_other]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df1, df2 exp_classes, control_classes = balance_arrays_classes(data_exp, data_control)</code> </pre> <br>  At the output, we obtain data balanced by size and consistent on the basis of conversion ratios, the metrics under study (calculated for the average values ‚Äã‚Äãfor sub-buckets) in which are already normally distributed, which can be seen both visually and by the results of applying the test criteria already known to us for normality (with p-value&gt; = 0.05).  For example, for relative indicators: <br><br><pre> <code class="python hljs">data_conv = (data[data[<span class="hljs-string"><span class="hljs-string">'calls'</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>].groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.sum()*<span class="hljs-number"><span class="hljs-number">1.0</span></span>/data.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).device_id.nunique()) data_conv.hist(bins = <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Now, t-test can be applied to the average over sub-buckets (thus, not the device_id, not the device, but the sub-bucket acts as observation). <br><br>  Making sure that the changes are statistically significant, you can carry out with a clear conscience something for which we started all this - the calculation of cannibalization: <br><br><pre> <code class="python hljs">(data_exp.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.avg() - data_cntrl.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.avg() )/ data_exp.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.avg()</code> </pre> <br>  The denominator should be ad-free traffic, that is, experimental. <br><br><h4>  3. Bootstrap method </h4><br>  The bootstrap method is an extension of the sub-bucket method and is a more advanced and improved version;  A software implementation of this method in Python can be found in the Facebook Bootstrapped library. <br>  Briefly, the idea of ‚Äã‚Äãbootstrap can be described as follows: the method is nothing but the constructor of samples that are formed in a similar way to the sub-bucket method in a random way, but with possible repetitions.  It can be said that the placements from the general population (if one can be called the original sample) are returned.  At the output, the average (medians, sums, etc.) of the average for each of the sub-samples formed. <br><br>  <i>The main methods of the library FaceBook Bootstrap</i> : <br><pre> <code class="python hljs">bootstrap()</code> </pre>  - implements the mechanism for the formation of subsamples;  by default returns lower bound (5 percentile) and upper bound (95 percentile);  To return a discrete distribution in this range, you must set the parameter <i>return_distribution = True</i> (it is generated by the auxiliary function <i>generate_distributions ()</i> ). <br><br>  You can specify the number of iterations using the <i>num_iterations</i> parameter, in which subsampling will be formed, and the number of <i>iteration_batch_size</i> subsamples for each iteration.  At the output of <i>generate_distributions ()</i> , a sample will be formed with a size equal to the number of iterations <i>num_iterations</i> , the elements of which will be an average of the values ‚Äã‚Äãof the <i>iteration_batch_size</i> samples calculated at each iteration.  With large sample sizes, the data may stop getting into memory, therefore in such cases it is desirable to reduce the <i>iteration_batch_size</i> value. <br><br>  <i>Example</i> : Let the original sample be 2,000,000;  <i>num_iterations</i> = 10,000, <i>iteration_batch_size</i> = 300. Then on each of 10,000 iterations, 300 lists of 2,000,000 items will be stored in memory. <br><br>  The function also allows parallel computations on several processor cores, on several threads, setting the required number using the <i>num_threads</i> parameter. <br><br><pre> <code class="python hljs">bootstrap_ab()</code> </pre> <br>  performs all the same actions as the <i>bootstrap ()</i> function described above, but additionally also aggregates the average values ‚Äã‚Äãusing the method specified in <i>stat_func</i> - from the <i>num_iterations</i> values.  Next, the metric specified in the compare_func parameter is calculated and the statistical significance is evaluated. <br><br><pre> <code class="python hljs">compare_functions</code> </pre> <br>  - a class of functions that provides tools for the formation of metrics for evaluation: <br><pre> <code class="python hljs">compare_functions.difference() compare_functions.percent_change() compare_functions.ratio() compare_functions.percent_difference() <span class="hljs-comment"><span class="hljs-comment"># difference = (test_stat - ctrl_stat) # percent_change = (test_stat - ctrl_stat) * 100.0 / ctrl_stat # ratio = test_stat / ctrl_stat # percent_difference = (test_stat - ctrl_stat) / ((test_stat + ctrl_stat) / 2.0) * 100.0</span></span></code> </pre> <br><pre> <code class="python hljs">stats_functions</code> </pre>  - the class of functions from which the method of aggregation of the studied metric is selected: <br><pre> <code class="python hljs">stats_functions.mean stats_functions.sum stats_functions.median stats_functions.std</code> </pre> <br>  As a <i>stat_func,</i> you can use a custom custom function, for example: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test_stat, ctrl_stat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (test_stat - ctrl_stat)/test_stat bs.bootstrap_ab(test.values, control.values, stats_functions.mean, test_func, num_iterations=<span class="hljs-number"><span class="hljs-number">5000</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.05</span></span>, iteration_batch_size=<span class="hljs-number"><span class="hljs-number">100</span></span>, scale_test_by=<span class="hljs-number"><span class="hljs-number">1</span></span>, num_threads=<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br>  In fact, <i>(test_stat - ctrl_stat) / test_stat</i> is the formula for calculating our cannibalization. <br><br>  Alternatively or for practical experimentation, you can initially get distributions using <i>bootstrap ()</i> , check the statistical significance of the differences in the target metrics using t-test and then apply the necessary manipulations to them. <br>  An example of how ‚Äúqualitative‚Äù normal distribution can be obtained using this method: <br><br><img src="https://habrastorage.org/webt/pc/is/ws/pciswsulv_wuinbcqkn-hgmluwe.png"><br><br>  More detailed documentation can be found on <a href="https://github.com/facebookincubator/bootstrapped/">the repository page</a> . <br><br>  At the moment, this is all that I wanted (or managed to) to tell.  I tried to briefly but clearly describe the methods used and the process of their implementation.  It is possible that the methodologies require adjustments, so I will be grateful for the feedback and reviews. <br><br>  I also want to thank my colleagues for their help in preparing this work.  In case the article receives mostly positive feedback, I will indicate here their names or nicknames (by prior agreement). <br><br>  Best wishes to everyone!  :) <br><br>  PS <a href="https://t.me/mlbootcamp">Dear Championship channel</a> , the task of evaluating the results of A / B testing is one of the most important in Data Science, because more than one launch of a new ML model in production is not complete without A / B.  Maybe it is time to organize a competition to develop a system for evaluating the results of A / B testing?  :) </div><p>Source: <a href="https://habr.com/ru/post/451488/">https://habr.com/ru/post/451488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451462/index.html">We write less duplicate code using Binding in Laravel</a></li>
<li><a href="../451466/index.html">graphql - pitfalls</a></li>
<li><a href="../451468/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ 364 (May 6 - 12, 2019)</a></li>
<li><a href="../45147/index.html">Down with the language barrier!</a></li>
<li><a href="../451480/index.html">Why does the Ministry of Industry and Trade prohibit the storage of data on foreign equipment?</a></li>
<li><a href="../45149/index.html">666</a></li>
<li><a href="../451490/index.html">Which programming language to choose</a></li>
<li><a href="../451492/index.html">Seven Unexpected Bash Variables</a></li>
<li><a href="../451498/index.html">Product Design Digest April 2019</a></li>
<li><a href="../4515/index.html">Opinions of bloggers will be announced in ‚ÄúVesti.net‚Äù on TV</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>