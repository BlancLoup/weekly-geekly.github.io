<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ 11 and 64-bit errors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We decided to make a short pause in the subject of static code analysis. After all, the C ++ blog is also read by those who are not yet using this tec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ 11 and 64-bit errors</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/034/947/5c8/0349475c8bf4008cc4b16c2e432f69ec.png" alt="CryEngine 3 SDK and PVS-Studio" align="left"><br>  We decided to make a short pause in the subject of static code analysis.  After all, the C ++ blog is also read by those who are not yet using this technology.  In the meantime, phenomena occur in the C ++ world that affect such an ‚Äúestablished‚Äù theme as the 64-bit world.  It is about how the C ++ 11 standard affects and helps (if there is something) in developing the correct 64-bit programs.  Today‚Äôs article is about that. <br><a name="habracut"></a><br>  64-bit computers have long been successfully used.  Most applications have become 64-bit.  This allows them to use a larger amount of memory, as well as to obtain a performance boost due to the architectural capabilities of 64-bit processors.  Creating 64-bit C / C ++ programs requires attentiveness from the programmer.  There are a lot of reasons because of which the code of a 32-bit program refuses to work correctly after recompiling for a 64-bit system.  Many articles have been written about this.  But now we are interested in another question.  Let's see if the use of new features that appeared in C ++ 11 makes it easier to make programmers who create 64-bit programs easier. <br><br><h2>  The world of 64-bit errors </h2><br>  There are many traps that a programmer can fall into when creating 64-bit C / C ++ applications.  A large number of articles have been written about this, so we will not repeat.  Those who are not familiar with the nuances of developing 64-bit programs, or those who want to refresh their memory, can recommend the following resources: <ul><li>  <a href="http://www.viva64.com/ru/a/0065/">A collection of examples of 64-bit errors in real programs</a> ; </li><li>  <a href="http://www.viva64.com/ru/l/">Lessons learned from developing 64-bit C / C ++ applications</a> ; </li><li>  <a href="http://www.viva64.com/go.php%3Furl%3D1357">All about 64-bit programming in one place</a> . </li></ul>  Time does not stand still, and now programmers use an updated version of the C ++ language, called C ++ 11.  At the moment, most of the innovations described in the C ++ 11 standard are supported by modern compilers.  Let's see if these innovations can somehow help the programmer to avoid 64-bit errors. <br><br>  The article will be structured as follows.  A brief description of a typical 64-bit error will be given, and ways to avoid it using C ++ 11 will be proposed.  Immediately, we note that C ++ 11 is not always able to help anything.  Only accurate programming can protect against errors.  A new standard only helps in this, but does not solve all the problems for the programmer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Magic numbers </h2><br>  We are talking about the use of numbers such as 4, 32, 0x7FFFFFFF, 0xFFFFFFFF ( <a href="http://www.viva64.com/ru/l/0009/">more</a> ).  It‚Äôs bad if the programmer suggested that the pointer size is always 4 bytes and wrote the following code: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(n * <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Here the C ++ 11 standard cannot help us.  Magic numbers, this is evil and the only way to avoid mistakes is to try not to use them. <br><br>  <b><i>Note.</i></b>  <i>Yes, malloc () is not C ++, but good old C. It is much better to use the operator new or the container std :: vector.</i>  <i>But now it is irrelevant.</i>  <i>Talk about magic numbers.</i> <br><br>  However, C ++ 11 sometimes helps to reduce the number of magic numbers.  Some magic numbers in the program appear because of the fear (often unreasonable) that the compiler poorly optimizes the code.  In this case, you should pay attention to the generalized constant expressions (onstexpr). <br><br>  The <b>constexpr</b> mechanism guarantees the initialization of expressions at compile time.  In this case, you can declare functions that are guaranteed to unfold into a constant at the compilation stage.  Example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Formula</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp = a * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp + <span class="hljs-number"><span class="hljs-number">55</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = Formula(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  The call to Formula (1) will turn into a number.  The explanation is of course too short.  More information about "constexpr" and other innovations can be read by clicking on the links at the end of the article. <br><br><h2>  Functions with variable number of arguments </h2><br>  We are talking about the misuse of functions such as printf, scanf ( <a href="http://www.viva64.com/ru/l/0010/">more</a> ).  Example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> value = ....; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%u"</span></span>, value);</code> </pre> <br>  This code works correctly in a 32-bit program, but it can print out incorrect values ‚Äã‚Äãwhen the program turns into a 64-bit one. <br><br>  Functions with a variable number of arguments - a relic of the C language.  Their disadvantage is the lack of control over the types of actual arguments.  In C ++, it's time to abandon them.  There are lots of other ways to format strings.  For example, you can replace printf with cout, and sprintf with boost :: format or std :: stringstream. <br><br>  With C ++ 11, life has become even better.  In C ++ 11, templates with a variable number of parameters (Variadic Templates) appeared.  This allows you to implement such a safe version of the printf function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s &amp;&amp; *s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*s==<span class="hljs-string"><span class="hljs-string">'%'</span></span> &amp;&amp; *++s!=<span class="hljs-string"><span class="hljs-string">'%'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> runtime_error(<span class="hljs-string"><span class="hljs-string">"invalid format: missing arguments"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *s++; } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* s, T value, Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s &amp;&amp; *s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*s==<span class="hljs-string"><span class="hljs-string">'%'</span></span> &amp;&amp; *++s!=<span class="hljs-string"><span class="hljs-string">'%'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(++s, args...); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *s++; } }</code> </pre> <br>  This code simply ‚Äúgets‚Äù the first argument, which is not a format string, and then calls itself recursively.  When there are no such arguments, the first (simpler) version of the printf () method will be called. <br><br>  Type Args ... defines the so-called "parameter group" ("parameter pack").  In essence, this is a sequence of type / value pairs, from which you can ‚Äúget‚Äù the arguments, starting with the first one.  When the printf () function is called with one argument, the first method (printf (const char *)) will be selected.  When calling the printf () function with two or more arguments, the second method will be selected (printf (const char *, T value, Args ... args)), with the first parameter s, the second one - value, and the remaining parameters (if any) will be Packed in a group of parameters args, for later use.  When calling: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(++s, args...);</code> </pre> <br>  The parameter group args is shifted by one, and the next parameter can be processed as value.  And so it goes until args is empty (and the first version of the printf () method will be called). <br><br><h2>  Incorrect shift operations </h2><br>  Numeric literal 1 is of type int.  It means that it cannot be shifted by more than 31 bits ( <a href="http://www.viva64.com/ru/l/0011/">more</a> ).  This is often forgotten, and in programs you can find this code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bitNum;</code> </pre> <br>  If the bitNum value is equal, say 40, the result will be unpredictable.  Formally, this will result in an undefined behavior ( <a href="http://www.viva64.com/ru/b/0142/">more</a> ). <br><br>  Can C ++ 11 help us?  Unfortunately, nothing. <br><br><h2>  Desynchronization of virtual functions </h2><br>  Let the virtual class be declared in the base class: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD_PTR x)</span></span></span></span>;</code> </pre> <br>  And in the class of the heir there is a function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD x)</span></span></span></span>;</code> </pre> <br>  In a 32-bit program, the DWORD_PTR and DWORD types are the same.  However, in a 64-bit program, these are already two different types ( <a href="http://www.viva64.com/ru/l/0012/">more</a> ).  As a result, calling the function A from the base class will produce different results in a 32-bit and 64-bit program. <br><br>  To deal with such errors can help new keywords, which appeared in C ++ 11. <br><br>  Now we have the <b>override</b> keyword, which allows the programmer to explicitly express his intentions about redefining functions.  The declaration of a function with the override keyword is valid only if there is a function to override. <br><br>  This code will not compile in 64-bit mode and thus the error will be cleared: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD_PTR)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> X { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD x)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } };</code> </pre> <br><h2>  Mixed arithmetic </h2><br>  This is quite an important and extensive topic.  I propose to get acquainted with the corresponding groundwork of "64-bit lessons": <a href="http://www.viva64.com/ru/l/0017/">Mixed arithmetic</a> . <br><br>  Quite briefly: <ol><li>  Programmers often forget that the result of multiplying and adding two variables of the 'int' type is also of the 'int' type.  An overflow may occur.  And it does not matter how the result of multiplication and addition is used. </li><li>  It is dangerous to mix 32-bit and 64-bit data types.  Consequences: abnormal conditions, eternal cycles. </li></ol><br><h3>  Let's look at some simple examples of overflow. </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  The programmer is trying to allocate an array of 5 gigabytes of memory, but allocates much less.  The fact is that the expression "1024 * 1024 * 1024 * 5" is of type int.  As a result, an overflow will occur, and the expression will be 1073741824 (1 gigabyte).  Then, when passing to the 'new' operator, the number 1073741824 will be expanded to the size_t type, but that does not matter (it's too late). <br><br>  If the problem is not clear, then here is another similar example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> a = <span class="hljs-number"><span class="hljs-number">1024</span></span>, b = <span class="hljs-number"><span class="hljs-number">1024</span></span>, c = <span class="hljs-number"><span class="hljs-number">1024</span></span>, d = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = a * b * c * d;</code> </pre> <br>  The result of the expression is placed in a variable of type 'size_t'.  It is capable of storing values ‚Äã‚Äãlarger than UINT_MAX.  But when multiplying variables of the 'unsigned' type, an overflow occurs and the result will be incorrect. <br><br>  Why do we call all this 64-bit errors?  The fact is that in a 32-bit program it is impossible to allocate an array of more than 2 GB in size.  So, overflows simply do not arise.  Such errors manifest themselves only in 64-bit programs when they start working with large amounts of memory. <br><br><h3>  Now a couple of examples about the comparison </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Count = BigValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Index &lt; Count; ++Index) { ... }</code> </pre> <br>  This is an example of an eternal loop if Count&gt; UINT_MAX.  Suppose that on 32-bit systems this code performed less repetition, less than UINT_MAX times.  But the 64-bit version of the program can process more data, and it may need more iterations.  Since the values ‚Äã‚Äãof the Index variable lie in the range [0..UINT_MAX], the condition "Index &lt;Count" is always satisfied, which leads to an infinite loop. <br><br>  One more example: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = .....; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> n = str.find(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n != <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos)</code> </pre> <br>  This code is incorrect.  The find () function returns a value of type string :: size_type.  Everything will work fine in a 32-bit system.  But let's see what happens in the 64-bit program. <br><br>  In the 64-bit program, string :: size_type and unsigned stop coinciding.  If the substring is not found, the find () function returns the value string :: npos, which is 0xFFFFFFFFFFFFFFFFui64.  This value is trimmed to a value of 0xFFFFFFFFu and placed in a 32-bit variable.  The expression is calculated: 0xFFFFFFFFu! = 0xFFFFFFFFFFFFFFFFui64.  It turns out that the condition (n! = String :: npos) is always true! <br><br><h3>  C ++ 11 can somehow help here? </h3><br>  The answer is yes and no. <br><br>  In some cases, the new <b>auto</b> keyword can help.  And in some it can only confuse the programmer.  Therefore, let's carefully consider. <br><br>  If you declare "auto a = .....", then its type will be automatically calculated.  It is very important not to get confused and not to write such a <b>wrong code</b> : "auto n = 1024 * 1024 * 1024 * 5;". <br><br>  Talk about the <b>auto</b> keyword.  Consider the following example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-number"><span class="hljs-number">7</span></span>;</code> </pre> <br>  In this case, the type of the variable 'x' will be 'int', because it is this type of initializer that has this type.  In general, we can write: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = expression;</code> </pre> <br>  And the type of the variable 'x' will be equal to the type of the value obtained by evaluating the expression. <br><br>  The keyword 'auto' to infer the type of a variable from its initializer is most useful when the exact type of the expression is not known or difficult to write.  Consider an example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">printall</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class">&lt;T&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = v.begin(); p!=v.end(); ++p) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *p &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre> <br>  In C ++ 98, you would have to write a much longer code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">printall</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class">&lt;T&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;::const_iterator p = v.begin(); p!=v.end(); ++p) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *p &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre> <br>  Very useful innovation in C ++ 11. <br><br>  Let's return to our problem.  The expression "1024 * 1024 * 1024 * 5" has type 'int'.  So for now, 'auto' will not help us. <br><br>  Do not help us 'auto' and in the case of a cycle: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Count = BigValue; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Index &lt; Count; ++Index)</code> </pre> <br>  Got better?  Not.  The number 0 is of type 'int'.  So the Index variable will now have the type not 'unsigned', but ‚Äúint '.  It probably got worse. <br><br>  <b>So is there any use for us from 'auto'?</b>  Yes there is.  For example, here: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = .....; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> n = str.find(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n != <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos)</code> </pre> <br>  The variable 'n' will be of type string :: size_type.  Now everything is fine. <br><br>  So finally, the new keyword 'auto' came in handy.  However, be careful.  You need to understand what you are doing and why.  No need to hope to overcome all the errors associated with mixed arithmetic, using everywhere 'auto'.  This is just one of the tools, not a panacea. <br><br>  By the way, there is another way to protect against type clipping in the example discussed earlier: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> n = str.find(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>);</code> </pre> <br>  You can use the new variable initialization format, which prevents narrowing of types.  The problem is that C and C ++ languages ‚Äã‚Äãimplicitly truncate some types: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">7.3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ! void f(int); f(7.3); // !</span></span></code> </pre> <br>  However, C ++ 11 initialization lists do not allow narrowing of types: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x0 {<span class="hljs-number"><span class="hljs-number">7.3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//compilation error int x1 = {7.3}; //compilation error double d = 7; int x2{d}; //compilation error</span></span></code> </pre> <br>  These examples are more interesting for us now: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> A = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> X = A; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Y</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Q = { A }; <span class="hljs-comment"><span class="hljs-comment">//compilation error unsigned W { A }; //compilation error</span></span></code> </pre> <br>  Imagine that the code is written like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> n = { str.find(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>) };   <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> n{str.find(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>)};</code> </pre> <br>  This code will be compiled in 32-bit mode and will cease to compile in 64-bit mode. <br><br>  Again, this is not a panacea for all errors.  Just another way to write more reliable programs. <br><br><h2>  Address arithmetic </h2><br>  The problem is in many ways similar to what we considered in the section ‚ÄúMixed arithmetic‚Äù.  The only difference is that overflow occurs when working with pointers ( <a href="http://www.viva64.com/ru/l/0013/">more</a> ). <br><br>  Consider an example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Region::GetCell(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[x + y * Width + z * Width * Height]; }</code> </pre> <br>  This code is taken from a real program of mathematical modeling, in which an important resource is the amount of RAM.  In programs of this class, one-dimensional arrays are often used to save memory, while working with them as with three-dimensional arrays.  To do this, there are functions similar to GetCell that provide access to the necessary elements.  But the above code will only work correctly with arrays containing less than INT_MAX elements.  The reason is the use of 32-bit int types to calculate the element index. <br><br>  C ++ 11 can somehow help here?  Not. <br><br><h2>  Changing the type of array and packing pointers. </h2><br>  Sometimes in programs it is necessary (or simply convenient) to represent the elements of an array as elements of another type ( <a href="http://www.viva64.com/ru/l/0014/">more</a> ).  It is also convenient to store pointers in variables of integer type ( <a href="http://www.viva64.com/ru/l/0015/">more</a> ). <br><br>  Errors occur due to incorrect explicit type conversions.  With the new standard C ++ 11 there is no relationship here.  Explicit type conversions were always done at your own peril and risk. <br><br>  It should also be mentioned about working with data that is in associations (union).  Such work with data is low-level and also depends only on the skills and knowledge of the programmer ( <a href="http://www.viva64.com/ru/l/0016/">more</a> ). <br><br><h2>  Serialization and data exchange </h2><br>  A project may need to create a compatible data format.  That is, one data set should be processed with both a 32-bit and 64-bit version of the program.  The difficulty lies in the fact that changing the size of some data types ( <a href="http://www.viva64.com/ru/l/0019/">more</a> ). <br><br>  The C ++ 11 standard made life a little easier by entering fixed-size types.  Previously, programmers declared such types independently or used types declared in one of the system libraries. <br><br>  Now there are the following types of fixed size: <ul><li>  int8_t </li><li>  int16_t </li><li>  int32_t </li><li>  int64_t </li><li>  uint8_t </li><li>  uint16_t </li><li>  uint32_t </li><li>  uint64_t </li></ul><br>  In addition to the size, the alignment of the data in memory is changed (data alignment).  This can also provide certain difficulties ( <a href="http://www.viva64.com/ru/l/0021/">more</a> ). <br><br>  Regarding this topic, it is worth mentioning the appearance in C ++ 11 of the new keyword 'alignment'.  Now you can write this code: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,     double alignas(double) unsigned char c[1024]; //   16   alignas(16) char[100];</span></span></code> </pre> <br>  There is also an 'alignof' operator, which returns the alignment for the specified argument (the argument must be a type).  Example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre> <br><h2>  Overloaded functions </h2><br>  When porting 32-bit programs to a 64-bit platform, there may be a change in the logic of its operation associated with the use of overloaded functions.  If the function is overridden for 32-bit and 64-bit values, then a call to it with an argument, for example, such as size_t, will be translated into various calls on different systems ( <a href="http://www.viva64.com/ru/l/0022/">more</a> ). <br><br>  I find it difficult to answer whether it is possible to use some of the new properties of the language to combat such errors. <br><br><h2>  Type Size Checks </h2><br>  There are cases when it is necessary to check the sizes of data types.  This is necessary not to get the buggy program after recompiling the code for the new system. <br><br>  This is often done in the wrong way.  For example: <br><pre> <code class="cpp hljs">assert(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>) &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)); assert(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>) == <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Bad way.  First, the program still compiles.  Secondly, these checks will only manifest themselves in the debug version. <br><br>  It is much better to stop compiling if the necessary conditions are not met.  There are many solutions for this.  For example, you can use the _STATIC_ASSERT macro, which is available to developers using Visual Studio.  Usage example: <br><pre> <code class="cpp hljs">_STATIC_ASSERT(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>));</code> </pre> <br>  C ++ 11 standardized the way how to stop the compilation if something went wrong.  Introduced compile-time statements (static assertions). <br><br>  Static statements (compile-time statements) contain a constant expression and a string literal: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(expression, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>);</code> </pre> <br>  The compiler evaluates the expression, and if the result of the calculation is false (ie, the statement is violated), displays the string as an error message.  Examples: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)&gt;=<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"64-bit code generation required for this library."</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> X m1; Y m2; }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(S)==<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(X)+<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Y), <span class="hljs-string"><span class="hljs-string">"unexpected padding in S"</span></span>);</code> </pre> <br><h2>  Conclusion </h2><br>  Writing code with the maximum use of new constructions of the C ++ 11 language does not guarantee the absence of 64-bit errors.  However, the language presents several new features that will make the code shorter and more reliable. <br><br><h2>  Additional resources </h2><br>  The article did not attempt to acquaint the reader with as many innovations as possible in the C ++ 11 language.  For the first acquaintance with the new standards, we can recommend the following resources: <ol><li>  Bjarne Stroustrup.  <a href="http://www.viva64.com/go.php%3Furl%3D1359">C ++ 11 - the new ISO C ++ standard</a> ( <a href="http://sergeyteplyakov.blogspot.com/2012/05/c-11-faq.html">Remarkable translation</a> ). </li><li>  Wikipedia.  <a href="http://www.viva64.com/go.php%3Furl%3D1360">C ++ 11</a> . </li><li>  Scott Meyers.  <a href="http://www.viva64.com/go.php%3Furl%3D1361">An Effective C ++ 11/14 Sampler</a> . </li></ol></div><p>Source: <a href="https://habr.com/ru/post/215939/">https://habr.com/ru/post/215939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215929/index.html">Holland approved operator-independent SIM cards</a></li>
<li><a href="../215931/index.html">Algorithms about the choice of roads and networks. Steiner networks. Lecture by Vladimir Protasov in Yandex</a></li>
<li><a href="../215933/index.html">Overview of IP Phones for Lync Server</a></li>
<li><a href="../215935/index.html">BB-Mobile Techno 9.0 3G Tablet Review</a></li>
<li><a href="../215937/index.html">Some interesting and useful things for web developer # 13</a></li>
<li><a href="../215943/index.html">Overview of the Russian Help Desk system vsDesk</a></li>
<li><a href="../215945/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ100 (March 9 - 15, 2014)</a></li>
<li><a href="../215949/index.html">In Holland, a giant 3D printer is used to build a house</a></li>
<li><a href="../215951/index.html">Jiayu G4 - once Chinese flagship</a></li>
<li><a href="../215953/index.html">NATO site "laid" by CyberBerkut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>