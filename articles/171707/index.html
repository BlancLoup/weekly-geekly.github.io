<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Story about participating in the contest Intel Accelerate Your Code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In November 2012, the parallel programming competition from Intel was launched, and even a separate post on Habr√© was devoted to this. We learned abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Story about participating in the contest Intel Accelerate Your Code</h1><div class="post__text post__text-html js-mediator-article">  In November 2012, the parallel programming competition from Intel was launched, and even a separate <a href="http://habrahabr.ru/company/intel/blog/157561/">post</a> on Habr√© was devoted to this.  We learned about the competition from our teacher, Evgeny Kalishenko.  He reads a <a href="http://mit.spbau.ru/courses/parallel">course</a> on "high-performance and parallel computing" at St. Petersburg Academic University and became the head of our team. <br><br>  The aim of the competition was to write and optimize the solution of one algorithmic problem within a few weeks.  Before describing her condition, we note several features of the competition. <br><a name="habracut"></a><br><h5>  Features of the competition </h5><br>  First, the solutions were tested on a computer with several dozen cores.  This was different from the competition of well-known student ACM format competitions, where it is useless to parallelize the code: the total time spent by the cores is considered to be the runtime.  The type of the proposed task was very similar to the tasks proposed at these Olympiads. <br><br>  Secondly, a reference solution was given for the problem.  This is the code that solves the problem guaranteed correctly, but very slowly.  One possible strategy was to optimize and parallelize this solution.  It was possible to completely rewrite the algorithm, but in this case it was necessary to preserve its semantics.  The correctness of the participant's decision was determined by a simple diff between the answers given by the competitive and reference decisions on several tests.  Looking ahead, I will say that we have chosen something between these two options: we borrowed the code responsible for input and output of the results from the reference solution, and completely rewritten the algorithm ourselves.  With this we have secured ourselves from the stupid errors associated with the inconsistency of the format of the output of floating-point numbers, extra spaces and spelling errors in the output.  Now about the proposed task. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Condition </h5><br>  In the input files are given: a list of flights with an indication of the companies that organize them;  list of groups of airlines forming "alliances".  To output to the output file you need the cheapest routes that meet several requirements.  The ‚Äúlegend‚Äù is this: we fly from our hometown to the conference, and then we return back.  At the same time, we may want to relax on the way to one of these cities, looking there before or after attending the conference.  There are restrictions on the time of our arrival at the conference, at the time of departure from there and on the desired time of rest.  Calculate the need for the best route for each of the cities that we want to visit, as well as for the option that we will not rest.  Another condition: to fly in succession with two flights of one airline turns out to be 30% cheaper, and two flights of airlines from the alliance - by 20%.  In addition, we do not want to wait for a transplant for too long, and the maximum waiting time is limited. <br><br>  The reference solution launches an almost exhaustive search of various ways, and the option to optimize it immediately disappeared.  Naturally, I wanted to use standard algorithms on graphs, but it was necessary to overcome several difficulties.  The main one was that the algorithm took into account that the price of a flight depends on the previous one and the next.  Known algorithms for finding the shortest path (Dijkstra, Floyd, Bellman-Ford) require that the edge weights be constant. <br><br><h5>  Algorithm </h5><br>  To begin with, we note that making cities - tops, and flights - with ribs - is a bad idea.  Each flight departs at a certain time, and you need to consider that you can fly out of the airport only after we have arrived at it.  Therefore, the peaks will be flights, and the edges will connect those that can fly sequentially. <br><br>  Next you need to take into account discounts.  Divide each vertex into five.  Each of these five vertices will have a so-called ‚Äútype‚Äù.  If we want to take some flight, and before it we flew the flight of the same airline, then we agree that our path passes through the top of the first type.  If the sequence of flights from one airline begins with this one, then we agree to go through the top of the second type.  We will do the same with alliances, adding two more types of vertices.  The fifth type will correspond to the fact that our discount on this flight is zero: the previous and the next flights are served by a company that is different from the current one and is not in the alliance with it.  In the code, the numbering order is different. <br><br><div class="spoiler">  <b class="spoiler_title">Enumeration of vertex types</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { FROM_ANY = <span class="hljs-number"><span class="hljs-number">0</span></span>, FROM_THIS = <span class="hljs-number"><span class="hljs-number">1</span></span>, FIRST_THIS = <span class="hljs-number"><span class="hljs-number">2</span></span>, FROM_ALLIANCE = <span class="hljs-number"><span class="hljs-number">3</span></span>, FIRST_ALLIANCE = <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br></div></div><br>  Connecting vertices with edges is simple: for each city we consider all arriving and departing flights.  For each pair of flights, we determine whether we can fly first and fly second (given that we have a limit on the transfer time).  If we can, then we iterate over all types of vertices corresponding to these flights, and we connect with edges the ones that are matched by type.  For example, if the airlines that organized these flights are different, then the edges to the top corresponding to the first type (‚Äúthe previous flight of the same company‚Äù) should not go.  But at the top of the second type (‚Äúthe first flight in a sequence from one company‚Äù), you just need to empty the ribs, since the next flight can be anything.  Carefully sort out 25 pairs of types, we understand which pairs require connections, and which ones do not.  We consider the price, taking into account the discounts for this flight and each type, we assign it to the edges entering the vertices, and the graph is almost ready. <br><br><div class="spoiler">  <b class="spoiler_title">Code linking vertices for a pair of flights</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wire_two_flights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Graph &amp;g, Flight* f1, Flight* f2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> P_B(t) push_back(make_pair(getCostWithDiscount(f2, t), i2 + t)) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(f1-&gt;company == f2-&gt;company) { g[i1 + FIRST_THIS].P_B(FROM_THIS); g[i1 + FROM_THIS].P_B(FROM_THIS); g[i1 + FROM_ALLIANCE].P_B(FROM_THIS); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(alliances[f1-&gt;company][f2-&gt;company]) { g[i1 + FIRST_ALLIANCE].P_B(FROM_ALLIANCE); g[i1 + FIRST_ALLIANCE].P_B(FIRST_THIS); g[i1 + FROM_ALLIANCE].P_B(FROM_ALLIANCE); g[i1 + FROM_ALLIANCE].P_B(FIRST_THIS); g[i1 + FROM_THIS].P_B(FROM_ALLIANCE); g[i1 + FROM_THIS].P_B(FIRST_THIS); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { g[i1 + FROM_ANY].P_B(FROM_ANY); g[i1 + FROM_ANY].P_B(FIRST_THIS); g[i1 + FROM_ANY].P_B(FIRST_ALLIANCE); g[i1 + FROM_ALLIANCE].P_B(FROM_ANY); g[i1 + FROM_ALLIANCE].P_B(FIRST_THIS); g[i1 + FROM_ALLIANCE].P_B(FIRST_ALLIANCE); g[i1 + FROM_THIS].P_B(FROM_ANY); g[i1 + FROM_THIS].P_B(FIRST_THIS); g[i1 + FROM_THIS].P_B(FIRST_ALLIANCE); } }</span></span></code> </pre><br></div></div><br>  However, it is still necessary to take into account that our path must go through the conference and place of rest.  Let's first solve the task of finding the shortest path in the graph between two vertices A and B and passing through vertex C. This can be done as follows: copy the graph G, getting two copies of it G and G '(let's call them layers).  Connect the vertex C with the vertex C '(copy C) of the graph G'.  After that, you can look for a path between the vertices A and B '- it is guaranteed to pass through C, since there are simply no other ways to jump from one layer to another. <br><br>  You can say that it is easier just to find a path from A to C, and then from C to B. But our approach can be generalized to the case when the path must pass through at least one of the many vertices, flights that can take us to the conference .  In addition, more layers will be needed to take into account the place of rest.  It will also be necessary to take into account two possible procedures for attending a conference and a place of rest.  But these are details.  The main thing is that the graph has increased as a result of such operations no more than a constant times. <br><br>  Adding a pair of fictitious vertices to the beginning and end of the path and connecting them with all the candidates for the initial and final flight, we get a ready graph on which we can run the Dijkstra algorithm.  To solve each of the subtasks corresponding to different places of rest, there will be a graph, which will increase the cost of its construction.  With this and other factors that slow down our algorithm, still had to fight. <br><br><h5>  Optimization </h5><br>  How can you feel by reading the name of the competition, its condition and the recommendations of Intel, the competition was dedicated to optimization, and not the ability to find an asymptotically quick solution.  If you studied at the university the theory of complexity, or at least the basic algorithms, you can remember how, when evaluating the effectiveness of algorithms, constants, and sometimes even logarithms and polynomials, are discarded (if the problem is complex and the solutions that are now exponential).  In practice, the situation is sometimes different.  A fast algorithm is only half the success. <br><br>  We mention only some of the optimizations we used.  First, the problem with multiple copying of the graph was solved.  The count was stored as adjacency lists, and it was possible to prepare a ‚Äúframe‚Äù, after which it was possible to add edges to it separately for each subtask (each city of rest).  After solving the next subtask, the edges added during its solution were effectively removed from the adjacency lists, and the graph was ready for new use. <br><br>  Secondly, it turned out that the built-in function for obtaining absolute time from its calendar representation (mktime) is very slow, and the time in the input data was given just in the calendar format.  Three hundred thousand calls of such a function - and the operation time is increased by ten seconds.  Fortunately, the time inside one month on the calendar is linear.  Therefore, it is possible to cache the absolute value of the first second of each month at the first demand, after which within this month the transfer of time from one format to another requires only a few arithmetic operations. <br><br><div class="spoiler">  <b class="spoiler_title">Fast time conversion</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span>&gt; tc(<span class="hljs-number"><span class="hljs-number">100000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> get_time(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> year, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> month) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> key = <span class="hljs-number"><span class="hljs-number">13</span></span> * year + month; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(key &gt;= tc.size()){ tc.resize(key * <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tc[key] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { tm time; time.tm_year = year - <span class="hljs-number"><span class="hljs-number">1900</span></span>; time.tm_mon = month - <span class="hljs-number"><span class="hljs-number">1</span></span>; time.tm_mday = <span class="hljs-number"><span class="hljs-number">0</span></span>; time.tm_hour = time.tm_min = time.tm_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> res = mktime(&amp;time); tc[key] = res; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tc[key]; } <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> convert_to_timestamp(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> day, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> month, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> year, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hour, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minute, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seconde) { <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> res = get_time(year, month); res += (day) * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">24</span></span>; res += hour * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span>; res += minute * <span class="hljs-number"><span class="hljs-number">60</span></span>; res += seconde; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br></div></div><br>  The third significant optimization was related to reading data.  This stage took much more time than the stages of building the graph and finding the path in it, and we used memory mapped IO - this quickly - and wrote our memory manager who is able to malloc, but not free.  He asks the OS for a huge chunk of memory, and then distributes it in parts to the string reading functions that need memory. <br><br><h5>  Parallelism </h5><br>  Our solution was not completely parallel.  Any attempt to run at least some subtasks in several threads led to either slowing down or not accelerating, even if these subtasks did not use shared data at all and did not require locks.  We have convinced ourselves that our solution is computationally easy, but it constantly requires a lot of calls to different memory areas, so the RAM bandwidth was a bottleneck.  Whether this is so, we did not have time to reliably find out, since the last days were spent on optimizing more important details.  Although there are a couple of OpenMP directives in the code below, we even deleted them at the last moment before sending the final version. <br><br><h5>  Code </h5><br>  The code of our solution is a completely unreadable confusion with macros in C ++, but we still give a <a href="http://pastebin.com/H8y5jpWz">link</a> to it.  In such tasks, this is a completely natural state of the code, but we, of course, do not call for writing large projects in the same style. <br><br><h5>  Findings. </h5><br>  We managed to take third place in this competition in Russia, and the speed of our decision was third throughout Europe.  A file with a hundred megabytes of flight data was processed by our program in a few seconds.  The final assessment was influenced not only by this speed, but also by the documentation provided, as well as social activity aimed at instilling a love of optimizations in general and popularizing this competition in particular.  As you can see from our story, we didn‚Äôt use any complex optimizations, we didn‚Äôt have to pick up compilation keys or fight for every bit.  We hope that our story has convinced you that the excellent speed of the code can be achieved by careful development of the algorithm and optimization of the most critical parts of it, and no fanaticism is required for this. <br><br>  We wish you all interesting tasks and effective solutions! <br><br>  PS <br>  The entire list of winners is on <a href="http://software.intel.com/fr-fr/articles/contest-winners-are-announced">the Intel website</a> . </div><p>Source: <a href="https://habr.com/ru/post/171707/">https://habr.com/ru/post/171707/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171697/index.html">Use GYP to build a C / C ++ project.</a></li>
<li><a href="../171699/index.html">Useful HTML, CSS and JavaScript techniques</a></li>
<li><a href="../171701/index.html">Search for the user's blocking source in Active Ditectory</a></li>
<li><a href="../171703/index.html">Selenium 2.0 - WebDriver. Impressions, problems and tips on using</a></li>
<li><a href="../171705/index.html">Fujitsu LIFEBOOK UH572 Ultrabook Review</a></li>
<li><a href="../171709/index.html">Combining responsive layout and templates for mobile</a></li>
<li><a href="../171711/index.html">Introduction to libuniset - library for creating ACS</a></li>
<li><a href="../171713/index.html">Review of Ubuntu Touch for tablets</a></li>
<li><a href="../171719/index.html">How to increase the IQ of the network button without interfering with the operator‚Äôs brain</a></li>
<li><a href="../171721/index.html">Russian startups at the 2013 London Web Summit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>