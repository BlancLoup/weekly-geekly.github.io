<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic Angular or manipulate correctly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Any project created is not complete without the dynamic creation of elements. Sooner or later you will need to either create a tooltip for the item, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic Angular or manipulate correctly</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/a1f/e99/eb3/a1fe99eb3d384844931416b4fffd38b0.jpg" alt="image"><br><p>  Any project created is not complete without the dynamic creation of elements.  Sooner or later you will need to either create a tooltip for the item, show a modal window, or even form some blocks dynamically loading them from the server.  When solving such problems, I often determine the maturity of the framework I use: how simple I can create dynamic content in it, and what opportunities it offers me for this.  In this article we will talk about dynamic content creation in the new Angular and consider the various approaches that it provides us. <a name="habracut"></a></p><br><p>  Before we proceed to creating content, we need to consider a number of abstractions that exist in Angular - what they are and what they are used for.  Since Angular is designed as a solution that can work on various platforms ‚Äî in the browser, on a mobile device, and on the server ‚Äî then direct work with the DOM is not very welcome in it, although it is possible.  For example, the following example will work well in a browser, but it may stop working if you are using Web Worker or your code runs on a mobile device. </p><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component, AfterComponentInit, ViewChild } from <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'some-component'</span></span></span><span class="hljs-meta">, template: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'&lt;input type="text" #input&gt;'</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AfterContentInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ViewChild(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'input'</span></span></span><span class="hljs-meta">)</span></span> input; ngAfterContentInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.input.nativeElement.focus(); } }</code> </pre> <br><p>  Instead of working directly with the DOM element, Angular provides us with the following abstractions ‚Äî Renderer, TemplateRef, ElementRef, and ViewContainerRef.  Let's look at them in order and see how we can use them to create dynamic content. </p><br><h3>  Renderer </h3><br><p>  I will talk about Renderer2 (hereinafter simply Renderer), since the first version is already marked as deprecated.  Renderer is mainly used to manipulate already existing elements, for example, to change the element styles, attributes and parameters of an element.  Most often its use can be found when creating directives.  But it also allows you to create new elements and insert them into the DOM, which is suitable for our task. </p><br><p>  Let's take a look at the methods Renderer provides: </p><br><ul><li>  <em>createElement (name: string, namespace ?: string): any</em> <br>  Allows you to create a DOM element and optionally specify a namespace for it.  The namespace is used, for example, to insert SVG elements.  The element after creation will not be displayed in the DOM until we add it there. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inputElement = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.createElement(<span class="hljs-string"><span class="hljs-string">'input'</span></span>);</code> </pre> </li><li><p>  <em>appendChild (parent: any, newChild: any): void</em> <em><br></em>  <em>insertBefore (parent: any, newChild: any, refChild: any): void</em> <em><br></em>  <em>removeChild (parent: any, oldChild: any): void</em> </p><br><p>  Used to insert / delete created or existing elements in the DOM. </p><br><pre> <code class="hljs kotlin">let inputElement = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.createElement(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.appendChild(parent, inputElement);</code> </pre> <br></li><li><p>  <em>setAttribute (el: any, name: string, value: string, namespace ?: string): void</em> <em><br></em>  <em>removeAttribute (el: any, name: string, namespace ?: string): void</em> <em><br></em>  <em>setProperty (el: any, name: string, value: any): void</em> </p><br><p>  Used to change the attributes or parameters of a DOM element, for example, to set the checkbox value. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.setAttribute(inputElement, <span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello from renderer'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.setProperty(inputElement, <span class="hljs-string"><span class="hljs-string">'checked'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br></li><li>  <em>createText (value: string): any</em> <br>  Creates a text DOM element that can be added as a child to the desired element. <br><pre> <code class="hljs kotlin">let buttonElement = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.createElement(<span class="hljs-string"><span class="hljs-string">'button'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.createText(<span class="hljs-string"><span class="hljs-string">'Text'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.appendChild(buttonElement, text);</code> </pre> </li><li>  <em>addClass (el: any, name: string): void</em> <em><br></em>  <em>removeClass (el: any, name: string): void</em> <br>  Set or remove a class for a DOM element. <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.addClass(buttonElement, <span class="hljs-string"><span class="hljs-string">'btn-large'</span></span>);</code> </pre> </li></ul><br><p>  This is not all that Renderer provides, but even using these methods, you can dynamically create and modify DOM elements. </p><br><p>  But before using the features of Renderer, we need to consider one more thing - how to find DOM elements-containers in an angular and add dynamic content to it.  To do this, we have two ways: use Dependency Injector or use a set of decorators - @ ViewChild / @ ViewChildren and&gt; @ ViewChildren / @ ContentChildren.  Let's look at both options and start with the simplest. </p><br><h3 id="dostup-k-elementu-cherez-di">  Element access via DI </h3><br><p>  This method is often used when creating your own directives.  In order to get access to an element (container) of a directive, you need to add a private variable with the type ElementRef to the directive constructor.  Let's take a look at how adding items will look like using the Renderer service in this case: </p><br><pre> <code class="hljs kotlin">input { Directive, Renderer2, ElementRef, Input} from <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Directive({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'someDirective'</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeDirective</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> renderer: Renderer2, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> elementRef: ElementRef ) {} <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> content(value: string) { let buttonElement = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.createElement(<span class="hljs-string"><span class="hljs-string">'button'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.createText(<span class="hljs-string"><span class="hljs-string">'Text'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.appendChild(buttonElement, text); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.appendChild(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementRef.nativeElement, buttonElement); } }</code> </pre> <br><p>  In this example, we create a new button and insert it into the DOM.  An example, of course, contrived, but allows us to see the main points for working with the DOM.  The ElementRef reference points to the element to which our directive was applied.  Everything is quite simple, but, unfortunately, this method is convenient only for directives and is not very convenient when you create components with dynamic content.  Let us now consider a more universal method. </p><br><h3 id="viewchildviewchildren-i-contentchildcontentchildren" @viewchild="" @viewchildren="" ="">  @ ViewChildren / @ ContentChildren </h3><br><p>  To search for items in the DOM, the angular provides a set of decorators - @ ViewChild / @ ViewChildren and&gt; @ ViewChildren / @ ContentChildren.  The @ViewChild directive differs from @ViewChildren in that the first one will always return only one element to you, while the second one allows you to find several elements, returning an object of type QueryList to you. </p><br><p>  QueryList is an iterative interface, and also allows you to subscribe to change items through the Observable mechanism.  The @ViewChildren and @ContentChildren decorators must be used in the ngAfterViewInit handler of the component's life cycle, since earlier QuryList will simply not be defined. </p><br><p>  The pair of directives&gt; @ ViewChildren / @ ContentChildren behaves in a similar way and differs from the bundle @ ViewChild / @ ViewChildren only in that&gt; @ViewChildren looks for elements in the DOM tree, while @ViewChild looks for elements in ShadowDom.  In this article, for simplicity, we will not consider a bunch of&gt; @ ViewChildren / @ ContentChildren, and also confine ourselves to @ ViewChild-decorator, since we will not use several elements.  To search for items, we will use the following syntax @ViewChild: </p><br><pre> <code class="hljs pgsql">@ViewChild(<span class="hljs-string"><span class="hljs-string">'[query params]'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">read</span></span>: [referenceType], descendants: <span class="hljs-type"><span class="hljs-type">boolean</span></span> });</code> </pre> <br><p>  Where </p><br><ul><li>  query params - the item we are looking for.  Maybe as a template name, html element or component / directive. </li><li>  descendants - defines to search for an element only among direct descendants or look deeper. </li><li>  read - specifies the type of the returned item.  Usually, specifying this parameter is not necessary, since the angular is pretty quick and if you are looking for a template, it will return you a TemplateRef, if you are looking for an html element, the angular will return you an ElementRef.  But in some cases, for example, when you need to get a ViewContainerRef, you have to specify the type of the returned item. </li></ul><br><p>  When searching for elements, the specified decorators return a variable of type ElementRef ‚Äî a top-level abstraction that contains a reference to the ‚Äúnative‚Äù DOM element: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ElementRef { constructor(nativeElement: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>) nativeElement: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> }</code> </pre> <br><p>  So, let's see how we can find an element in a component and, using Renderer, change its contents: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'some-component'</span></span></span><span class="hljs-meta">, template: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'&lt;div #elem&gt;Element text&lt;/div&gt;'</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AfterViewInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ViewChild(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'elem'</span></span></span><span class="hljs-meta">)</span></span> _elem: ElementRef; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> _renderer: Renderer2) {} ngAfterViewInit() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buttonElement = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._renderer.createElement(<span class="hljs-string"><span class="hljs-string">'button'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._renderer.createText(<span class="hljs-string"><span class="hljs-string">'Text'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._renderer.appendChild(buttonElement, text); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._renderer.appendChild(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._elem.nativeElement, buttonElement); } }</code> </pre> <br><p>  As in the example above, we create a button with the given text and add it to the DOM.  Only this time we insert the button into the container we need inside the component.  This approach is too low-level and is used quite rarely, so let's go ahead and consider what else Angular gives us. </p><br><h3 id="templateref">  TemplateRef </h3><br><p>  The idea of ‚Äã‚Äãusing templates to insert new elements is not new and has been used for a long time by JS developers.  When using the template tag from HTML5, the browser will create a DOM tree for the contents of the tag, but will not insert it into the DOM.  Here is an example of using the template tag in the classic, ‚Äúnative‚Äù JS: </p><br><pre> <code class="javascript hljs">&lt;template id=<span class="hljs-string"><span class="hljs-string">"some_template"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Template contrent text</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/template&gt; &lt;div id="container"&gt;&lt;/</span></span>div&gt;  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="xml"><span class="javascript"> </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">let</span></span></span></span><span class="xml"><span class="javascript"> tpl = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.querySelector(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'#some_template'</span></span></span></span><span class="xml"><span class="javascript">); </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">let</span></span></span></span><span class="xml"><span class="javascript"> container = </span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">document</span></span></span></span><span class="xml"><span class="javascript">.querySelector(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'#container'</span></span></span></span><span class="xml"><span class="javascript">); insertAfter(container, tpl.content); </span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  Angulyar provides its own template description notation, and also allows you to manipulate the template and its contents.  You could get acquainted with this abstraction if you created your own structural directives like ngIf and ngFor.  To access the template, we will use the TemplateRef type - this is a link to the ng-template element in your component or directive.  You have two ways to access the template ‚Äî using the ng-template and Dependency Injection tags or using the search for elements through the Query decorators, which we described above.  Let's look at both ways and start with the simplest: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Directive({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'[isAdmin]'</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsAdminDirective</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> isAdmin(value: boolean) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewContainerRef.createEmbeddedView(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.templateRef); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewContainerRef.clear(); } } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> templateRef: TemplateRef&lt;any&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> viewContainerRef: ViewContainerRef ) {} }</code> </pre> <br><p>  In the example above, we used Dependency Injection to access the template of our directive and dynamically insert it into the DOM using the ViewContainerRef.  We'll talk about ViewContainerRef later, until you pay attention to it, but now let's look at how we can dynamically create DOM elements using the @ViewChild decorator: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'some-component'</span></span></span><span class="hljs-meta">, template: ` &lt;ng-template #tpl1&gt;&lt;span&gt;Some template content 1&lt;/span&gt;&lt;/ng-template&gt; &lt;ng-template #tpl2&gt;&lt;span&gt;Some template content 2&lt;/span&gt;&lt;/ng-template&gt; &lt;div #container&gt;&lt;/div&gt; ` })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input()</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> isAdmin(value: boolean) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.viewContainerRef.createEmbeddedView(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._tpl); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view.destroy(); } } <span class="hljs-meta"><span class="hljs-meta">@ViewChild(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'tpl1'</span></span></span><span class="hljs-meta">)</span></span> _tpl: TemplateRef; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> view: EmbeddedViewRef&lt;Object&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> viewContainerRef: ViewContainerRef) {} }</code> </pre> <br><p>  In this example, using the @ViewChild decorator, we find the template we need as a variable of type TemplateRef and insert it into the DOM in the same way as in the example with the designer. </p><br><p>  By the way, the angular will remove the ng-template tag and its contents from the DOM and post a comment instead of it &lt;! - ng-template bindings = {} -&gt;.  This method allows you to create simple dynamic content based on ready-made templates.  But let's go ahead and see what else is available to us. </p><br><h3 id="viewcontainerref">  ViewContainerRef </h3><br><p>  It's time to talk about ViewContainerRef, which we have repeatedly seen in the examples above.  ViewContainerRef is a link to a component container or directive and, in addition to accessing an element, allows you to create two types of View - Host Views (View elements created on the basis of components) and Embedded Views (View elements created on the basis of ready-made templates).  All created elements have a base View type, which is the main building block for Angular applications and represents grouped DOM elements with which the angular is working as a whole and allows you to bind this group to the Change Detection mechanism.  ViewContainerRef contains quite a few methods, let's consider them: </p><br><ul><li><p>  <em>createEmbeddedView (templateRef: TemplateRef, context ?: C, index ?: number): EmbeddedViewRef</em> <br>  We used this method in our examples.  It allows you to create new View-elements on the basis of ready-made templates and inserts the result into the DOM container.  As parameters, you can also pass a context, data from which can be used in a template, and an index on which the created item can be placed. </p><br></li><li><p>  <em>createComponent (componentFactory: ComponentFactory, index ?: number, injector ?: Injector, projectableNodes ?: any [] [], ngModule ?: NgModuleRef): ComponentRef</em> <br>  Creates a View element based on the component instance and inserts it into the DOM, returning us a pointer to the created component.  To create an element, you must first obtain a component factory and an injector. </p><br></li><li><p>  <em>clear (): void</em> <br>  Removes all View items in the container. </p><br></li><li><p>  <em>insert (viewRef: ViewRef, index ?: number): ViewRef</em> <br>  Inserts the View element at the given position of the container. </p><br></li><li><p>  <em>remove (index ?: number): void</em> <br>  Removes the View element at the specified index.  If the index is not specified, the last View element will be deleted. </p><br></li><li>  <em>destroy (index ?: number): ViewRef</em> <br>  Removes the View element from the DOM </li></ul><br><p>  How createEmbeddedView works we have already seen in the examples above, now let's look at how to create View elements using the createComponent method.  This method allows you to dynamically create elements based on finished components.  But first, we need to learn how to find the factory of the component we need and the ComponentFactoryResolver will help us with this.  I will not describe here the entire code for creating the entire component, but I will make a number of assumptions. </p><br><p>  First, suppose that we have a Popover component in the project, which looks like this, for example: </p><br><pre> <code class="hljs scala"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>({ selector: <span class="hljs-symbol"><span class="hljs-symbol">'iw</span></span>-popover', template: ` &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"popover popover-{{placement}}"</span></span>&gt; &lt;h3 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"popover-title"</span></span>&gt;{{title}}&lt;/h3&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"popover-content"</span></span>&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/div&gt; &lt;/div&gt; ` }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Popover</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Input</span></span>() placement: string; <span class="hljs-meta"><span class="hljs-meta">@Input</span></span>() title: string; }</code> </pre> <br><p>  and it is added to the entryComponents attribute of our module.  The latter, by the way, is important, since without adding a component to entryComponents nothing will work, the angular will simply not know about the component, because it will not meet it in the templates. </p><br><p>  Also suppose that the call to our directive will look like this: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag"> #</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">popoverContent</span></span></span><span class="hljs-tag">&gt;</span></span> Popover content <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">popover</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"popoverContent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">title</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Popover title"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">placement</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"right"</span></span></span><span class="hljs-tag">&gt;</span></span> Show popover <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  That is, our directive receives three parameters as input - a reference to a TemplateRef type template, the header value and the position where popover should be shown. </p><br><p>  Based on these assumptions, the code of our directive showing popover will look like this: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@HostListener(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'mouseover'</span></span></span><span class="hljs-meta">)</span></span> show() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._componentRef) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._componentRef.destroy(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._contentViewRef = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.popover.createEmbeddedView(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cfResolver.resolveComponentFactory(Popover); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._componentRef = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._vcRef.createComponent( componentFactory, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._injector, <span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._contentViewRef.rootNodes] ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._componentRef.instance.placement = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.placement; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._componentRef.instance.title = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._contentViewRef.detectChanges(); } <span class="hljs-meta"><span class="hljs-meta">@HostListener(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'mouseleave'</span></span></span><span class="hljs-meta">)</span></span> hide() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._componentRef) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._componentRef.destroy(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._componentRef = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> _injector: Injector, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> _cfResolver: ComponentFactoryResolver ) {}</code> </pre> <br><p>  As you can see, there are two mouse event handlers on the component ‚Äî one showing component and one removing it from the DOM.  In the code showing the component, we first create a View based on the template passed to us, find the factory of our Popover component and then create it by passing the component factory, injector, position and embedded content to be inserted in place of ng-content in the Popover component. .  Also, since our component is dynamic, we need to transfer the necessary parameters to it and tell the Change Detector mechanism that the data has changed. </p><br><p>  Everything is quite simple and, having understood this once, you will easily create components.  It would seem that we have learned how to create dynamic content based on templates and components.  And it seems we have everything to solve our problems, but there are a couple of points that I would like to draw attention to. </p><br><p>  First, an interesting fact is that the angular does not insert the View-element inside the specified container, but adds it immediately after the container.  Therefore, to insert elements into the DOM it is convenient to use the ng-container element, which will save us from the unnecessary element in the DOM.  For me personally, this was an amazing revelation when I started debugging DOM markup and spent a lot of time to figure out where I was mistaken that my element was not inserted inside. </p><br><p>  Secondly, dynamically added components do not support Input- and Output-Decorators and this is the most sad thing.  For us, this translates into the fact that the component's ngOnChanges method will not be called when we assign a new Input value to the component variables.  There are two ways out of this situation - to use the setter method for a component variable or to control the component redrawing manually from the parent component.  You can also use ngDoCheck and compare attributes by yourself. </p><br><p>  But let's complicate the task and suppose that we want to dynamically create a component that is in a module that lies in a separate file on the server.  Straight "hare in a duck, duck in shock."  But that's not all, we also want to create our component from the service, and not from the existing component.  So, let's understand in order how this can be done. </p><br><p>  The first thing we need is to get the factory of the desired component from the module and create an instance of the component.  To download the js file from the server, I will use the SystemJS bootloader.  Also, let the desired module be exported to the variable module from our JS file.  Below is the code that solves the first part of our problem: </p><br><pre> <code class="hljs coffeescript">(&lt;any&gt;<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>).System.<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'module.js'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">module</span></span></span></span><span class="hljs-function"><span class="hljs-params">: any)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exportedModule: any)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.compiler.compileModuleAndAllComponentsAsync(exportedModule)) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(moduleWithFactories: ModuleWithComponentFactories&lt;any&gt;)</span></span></span><span class="hljs-function"> =&gt;</span></span> { const factory = moduleWithFactories.componentFactories.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(component)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> component.componentType.name === componentName }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.componentRef = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content.createComponent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.componentFactory, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.injector); })</code> </pre> <br><p>  In this code, we used an Angular's JIT compiler to compile the loaded module, and this approach has one feature.  So, if you use the AOT build of your project, the compiler will not be available at runtime and the specified code will not work.  To solve this problem, you can create a separate module with a service where you will need to manually add a compiler, for example, as follows: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { NgModule, ModuleWithProviders, Compiler, COMPILER_OPTIONS, CompilerOptions, Optional } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { JitCompilerFactory } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/compiler'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createJitCompiler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options?: CompilerOptions[]</span></span></span><span class="hljs-function">) </span></span>{ options = options || []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JitCompilerFactory([{ <span class="hljs-attr"><span class="hljs-attr">useDebug</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">useJit</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }]).createCompiler(options); } @NgModule({ ... }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicComponentModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> forRoot(metadata: NgModule): ModuleWithProviders { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">ngModule</span></span>: DynamicComponentModule, <span class="hljs-attr"><span class="hljs-attr">providers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">provide</span></span>: Compiler, <span class="hljs-attr"><span class="hljs-attr">useFactory</span></span>: createJitCompiler, <span class="hljs-attr"><span class="hljs-attr">deps</span></span>: [Optional(), COMPILER_OPTIONS] } ] } } }</code> </pre> <br><p>  Now we have a component and it remains for us to understand how to insert it into the DOM from the service.  After all, here we do not have ViewContainerRef, which we used earlier.  To insert a component into the DOM, we need to do two things - find the root element of our application and insert the created View component into it.  And here we will use the link to our angular-application which is accessible by means of DI through a variable with type ApplicationRef.  To do this, we need to add the ApplicationRef to our class constructor </p><br><pre> <code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">private</span></span></span></span><span class="hljs-function"><span class="hljs-params"> applicationRef: ApplicationRef, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">private</span></span></span></span><span class="hljs-function"><span class="hljs-params"> injector: Injector )</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{}</span></span></span></span></code> </pre> <br><p>  So, to insert our component, you need to find a place to insert the View, and also do not forget to copy the necessary parameters into our component as we did before.  Let's write a series of auxiliary functions to solve these problems: </p><br><pre> <code class="hljs pgsql">private getRootViewContainer(): ComponentRef&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt; { const rootComponents = this.applicationRef[<span class="hljs-string"><span class="hljs-string">'_rootComponents'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rootComponents.length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rootComponents[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'View Container not found!'</span></span>); } getComponentRootNode(componentRef: ComponentRef&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;): HTMLElement { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (componentRef.hostView <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> EmbeddedViewRef&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;).rootNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> HTMLElement; } projectComponentInputs(component: ComponentRef&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>): ComponentRef&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>) { const props = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.getOwnPropertyNames(<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const prop <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> props) { component.instance[prop] = <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>[prop]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> component; }</code> </pre> <br><p>  Now let's put it all together and get the following code that adds our component to the DOM: </p><br><pre> <code class="hljs kotlin">let location: Element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getComponentRootNode(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getRootViewContainer()); let componentFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.componentFactoryResolver.resolveComponentFactory(SomeComponent); let componentRef = componentFactory.create(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.injector); let appRef: any = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.applicationRef; let componentRootNode = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getComponentRootNode(componentRef); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> injector = ReflectiveInjector.resolveAndCreate([{ provide: <span class="hljs-string"><span class="hljs-string">'dialog'</span></span>, useValue: componentRef }], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.injector); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.projectComponentInputs(componentRef, { options: { ... }, injector: injector }); appRef.attachView(componentRef.hostView); componentRef.onDestroy(() =&gt; { appRef.detachView(componentRef.hostView); componentRef = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }); location.appendChild(componentRootNode);</code> </pre> <br><p>  In this code there are a couple of points that need to be clarified.  In addition to creating our component and finding a place to insert it into the DOM, we also created our own Injector and added our View component to the angular application by calling the attachView method so that it knows about us and runs the ChangeDetector.  In addition, we hung a handler to destroy the component in which we remove the component from the application. </p><br><p>  So, we have made a code that allows you to create a dynamic component that lies in an external file, and also insert it into the DOM from our service.  I use this code in our product to create modal dialogs. </p><br><p>  By the way, it is not necessary to pull the entire module from the outside.  This technique is applicable in situations where you want to create components, having only a file with the contents of the template.  For example, you can have the contents of a template on a server, and you want to create a View based on it.  To do this, you will need to do the following: </p><br><ul><li>           . </li><li>      . </li><li>   ,       ‚Äî   ,         DOM </li></ul><br><p>   ,    : </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> createComponentFromTemplateString(template: string) { <span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'some-selector'</span></span></span><span class="hljs-meta">, template: template })</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimeComponent</span></span></span><span class="hljs-class"> </span></span>{} NgModule({ imports: [imports], providers: [providers], declarations: [RuntimeComponent] }) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuntimeComponentModule</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.compiler.compileModuleAndAllComponentsAsync(RuntimeComponentModule) .then((moduleWithFactories: ModuleWithComponentFactories&lt;any&gt;) =&gt; { ... }) }</code> </pre> <br><h3 id="vstroennye-resheniya">  Embedded Solutions </h3><br><p>       ,      ‚Äî ngTemplateOutlet  ngComponentOutlet.      DOM-    ,        .       .    ngTemplateOutlet: </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">@Component({ selector: 'some-component', template: ` </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngTemplateOutlet</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"greet"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngTemplateOutlet</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"eng; context: myContect"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span></span><span class="xml"><span class="hljs-tag"> *</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ngTemplateOutlet</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"svk; context: myContect"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">hr</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">greet</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">eng</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">let-name</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{name}}</span></span><span class="xml"><span class="xml">!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span></span><span class="xml"><span class="hljs-tag"> #</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">svk</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">let-person</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"localSk"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Ahoj </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{person}}</span></span><span class="xml"><span class="xml">!</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ng-template</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ` }) class NgTemplateOutletExample { myContext = {$implicit: 'World', localSk: 'Svet'} }</span></span></code> </pre> <br><p>       ,    ,   .   $implicit          .  ,        createEmbeddedView,    .    ngComponentOutlet. </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'some-component'</span></span></span><span class="hljs-meta">, template: ` Hello World! ` })</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorldComponent</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'component-outlet-example'</span></span></span><span class="hljs-meta">, template: ` &lt;ng-container *ngComponentOutlet=</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"HelloWorld"</span></span></span><span class="hljs-meta">&gt;&lt;/ng-container&gt; ` })</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentOutletExample</span></span></span><span class="hljs-class"> </span></span>{ HelloWorld = HelloWorldComponent }</code> </pre> <br><p>               createComponent-,   . </p><br><p> ,   .          :    DOM-       .  - ,        ,      ,          .    ,         , ,  ,            ,     . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330030/">https://habr.com/ru/post/330030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330016/index.html">QEMU-KVM under LXC</a></li>
<li><a href="../330018/index.html">Writing a Babel plugin</a></li>
<li><a href="../330024/index.html">Oracle SystemTap</a></li>
<li><a href="../330026/index.html">Amazon Alexa Skill Smart Home with Open Source ioBroker Home Automation Platform</a></li>
<li><a href="../330028/index.html">Integration SaltStack and Telegram</a></li>
<li><a href="../330032/index.html">OpenTl.Server - server implementation of the messenger</a></li>
<li><a href="../330034/index.html">Named tuples. Writing Python Code Cleaner</a></li>
<li><a href="../330036/index.html">GitLab 9.2 released: Multiple task executors, pipelines on schedule, localization, disaster recovery alpha</a></li>
<li><a href="../330038/index.html">Cisco CSR 1000v: Reliability - the key to success. Part 2</a></li>
<li><a href="../330040/index.html">Flashcache - cheap and angry or alternative to HW RAID 10 SAS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>