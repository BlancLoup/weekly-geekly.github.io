<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unity 3d Tank Tutorial: Chassis (Lesson 2. Tracked chassis)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lesson 1 << 



 Introduction 
 I continue the lesson on assembling a tank at home. In the previous lesson you learned about the basics of driving a v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unity 3d Tank Tutorial: Chassis (Lesson 2. Tracked chassis)</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/blogs/gdev/115557/">Lesson 1 &lt;&lt;</a> <br><br><img src="https://habrastorage.org/storage/habraeffect/fe/c9/fec96410ca04f4aa98107fee31581579.jpg" alt="image"><br><br><h4>  Introduction </h4><br>  I continue the lesson on assembling a tank at home.  In the previous lesson you learned about the basics of driving a vehicle on Unity, in this lesson we will do what you could see in this <a href="https://dl.dropbox.com/u/23068733/TankDemo/index.xhtml">demo</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Namely: I will talk about how to better model the tracked chassis in the 3d editor so that it can adequately move and respond to uneven terrain, also give you a finished model that you can see in the demo, then you will learn how to revive the whole thing and lead in motion with Wheel Colliders. <br><a name="habracut"></a><br>  So before we proceed to addressing the priority issues, we must first formulate them, from the previous lesson we already know how to make the wheels turn and react to uneven terrain, but the problem is that the tank, in addition to wheels (track rollers), also has a track parts (tracks), which move at the same speed with which the track rollers rotate, especially the track along with the wheels must react to the unevenness of the landscape.  How do we realize all this?  Before you implement it you need to model it. <br><br><h4>  1. Caterpillar simulation methods </h4><br>  It is not strange, but these methods are inextricably linked with the methods of movement of the caterpillar, but of course everything also depends on what opportunities the engine can offer us on which we want to realize its movement.  In the case of Unity 3d, I see two scenarios: <br><ol><li>  We model a caterpillar from a variety of individual objects as for example in this case: <br>  (3ds max) <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/f8/e0/f8e0b1311ee5da7943c95e7c28dc1167.jpg" alt="image"></a> <br><br>  Set each track in motion by obtaining the position of the next one and gradually interpolate the position of the current track to the position of the next one, calculate the track deformation based on landscape irregularities using the <a href="http://unity3d.com/support/documentation/ScriptReference/Collider.html">Collider</a> class <a href="http://unity3d.com/support/documentation/ScriptReference/Collider.Raycast.html">Raycast ()</a> method, this method projects a ray of a certain length in a certain direction and returns true if it intersects with any collider. <br>  The advantages of this method are: high detail of the caterpillar, high realism of the caterpillar movement. <br>  Disadvantages: implementation complexity, load on computing power depending on the number of tracks because  it is necessary to calculate Raycast () for each, if there are too many of them, a drop in performance is inevitable. <br>  Honestly, I didn‚Äôt try to implement this method, because  Climbing on gamedev'ovskim <a href="http://www.gamedev.ru/code/forum/%3Fid%3D74960">forums</a> found the second. <br></li><li>  We model a caterpillar with a continuous tape: <br>  (3ds max) <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/43/6c/436c431bcfe15bf4f5a1f9acb3664a1d.jpg"></a> <br><br>  Then we impose a repeating texture of one or more tracks. <br><br>  Indeed, look, everything is simpler here; the illusion of track movement can be created by moving the texture by changing its texture coordinates.  And the deformation in accordance with the unevenness of the landscape can be done by tying bones in the tape where the rollers are located, because from the first lesson we already know how to calculate the position of the wheels based on the <a href="http://unity3d.com/support/documentation/ScriptReference/WheelCollider.GetGroundHit.html">GetGroundHit ()</a> method tied to the WheelCollider wheel, then calculate the position of the bones to which the tape is tied is not difficult.  Or you can use the same Raycast (for anyone as you like, personally I am quite happy with the binding to the suspension WheelCollider'a). <br>  Advantages of this method: ease of implementation, a small load on the calculations. <br>  Disadvantages: Not so high detail of the caterpillar compared to the first method (although there is a relative question, look at how the same was done in World of Tanks, Crysis, Battlefield: Bad Company, yes, yes, there is always used tape with a transparent texture superimposed on it, and it looks quite realistic). <br></li></ol><br>  So we choose the second method, and bind the bones to the caterpillar so that it can be deformed as follows: <br>  (3ds max) <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/5c/a9/5ca9974f95a2401a6164cf7832c7f537.jpg"></a> <br><br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/e0/05/e005e4154123f61bca218f109357288a.jpg"></a> <br><br>  As you can see in the screenshot, the wheels are also tied to the same bones as the caterpillar.  Let's experiment, create some kind of primitive, tie it to a bone, or several, then export it to Unity (you can read about export from various 3d modeling packages <a href="http://unity3d.com/support/documentation/Manual/HOWTO-importObject.html">here</a> , personally I advise you to export everything to FBX format, and then copy the resulting file into the folder Assets of your project, after that you can see the name of this file in the Project tab of your project, and it is enough to drag it onto the stage for further manipulations with it).  After that, select the model itself and try to move it, rotate, stretch it.  It turns out?  That's right, it does not work!  The fact is that in Unity, any Skinned Mesh tied to the bone (bones) becomes a slave to its transformations, try doing the same operations with the bone to which it is tied and you will succeed. <br><br>  Accordingly, we do not need the wheels to be tied to the bone as they must rotate.  We untie them, now it should look like this: <br>  (3ds max) <br> <a title="Habraffe.ru" href=""><img src="https://habrastorage.org/storage/habraeffect/ab/07/ab07af62d19bb23c19871aa8572712c0.jpg"></a> <br><br>  Well, that's basically all, the preparation of the model is completed, and as I promised I give a link to my <a href="">model</a> , and the <a href="">texture of the tracks</a> .  The model is in FBX format, so you can import it into your 3d editor supporting this format (as far as I know all popular editors support it), and consider in more detail how it is made and how the bones are attached, or you can immediately import into Unity and see in practice, what we actually do next. <br><br><h4>  2. Import the model and prepare the script </h4><br>  So, as I wrote above, copy the model and texture into the Assets folder of your project, or you can simply drag them directly from your explorer to the Project tab, the main thing is that the model and texture are in the same folder so that the texture overlaps automatically if for any reason you don‚Äôt see the textures on the tracks (before you see, you naturally pull the model onto the stage), or you want to throw it in another folder, it‚Äôs okay, just choose one of the tracks (they are called Track_line_left and Track_line_right ), then in the inspector on  Go to the texture setting, press the Select button and select the track texture. <br><img src="https://habrastorage.org/storage/habraeffect/16/a1/16a11a7666dc54436ed84933605432c5.jpg" alt="image"><br>  Also set the Tiling on y to 2, as in the image, in order to increase the number of tracks. <br><br>  Now create a new C # script (Assets -&gt; Create -&gt; C Sharp Script), call it TankTrackController, open it and declare the variables we need with which we will work further: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Collections.Generic; //<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TankTrackController : MonoBehaviour { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> GameObject wheelCollider; //<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> wheelRadius = <span class="hljs-number"><span class="hljs-number">0.15</span></span>f; //<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> suspensionOffset = <span class="hljs-number"><span class="hljs-number">0.05</span></span>f; //<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> trackTextureSpeed = <span class="hljs-number"><span class="hljs-number">2.5</span></span>f; //<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> GameObject leftTrack; //<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span>[] leftTrackUpperWheels; //<span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span>[] leftTrackWheels; //<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span>[] leftTrackBones; //<span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> GameObject rightTrack; //<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span>[] rightTrackUpperWheels; //<span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span>[] rightTrackWheels; //<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span>[] rightTrackBones; //<span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> WheelData { //<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span> wheelTransform; //<span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span> boneTransform; //<span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> WheelCollider col; //<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Vector3 wheelStartPos; //<span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Vector3 boneStartPos; //<span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> rotation = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; //<span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Quaternion startWheelAngle; //<span class="hljs-number"><span class="hljs-number">17</span></span> } protected WheelData[] leftTrackWheelData; //<span class="hljs-number"><span class="hljs-number">18</span></span> protected WheelData[] rightTrackWheelData; //<span class="hljs-number"><span class="hljs-number">18</span></span> protected <span class="hljs-type"><span class="hljs-type">float</span></span> leftTrackTextureOffset = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; //<span class="hljs-number"><span class="hljs-number">19</span></span> protected <span class="hljs-type"><span class="hljs-type">float</span></span> rightTrackTextureOffset = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; //<span class="hljs-number"><span class="hljs-number">19</span></span> }</code> </pre> <br><ol><li>  We allow the namespace needed to use dynamic lists, they will be useful to us later. </li><li>  We declare a variable in which the prefab of our Wheel Collider will be stored (recall item 2 of the previous lesson). </li><li>  The radius of our wheels. </li><li>  Offset wheel relative to the initial position when it does not touch the surface </li><li>  The speed of the caterpillar (in fact, the speed of displacement of texture coordinates). </li><li>  Left and right tracks. </li><li>  Left and right upper wheels to which Wheel Colliders will not be added. </li><li>  Wheels to which Wheel Colliders will be added (as you can see here I, unlike the previous lesson, did not declare arrays for Wheel Colliders, they will be added to our wheels directly from the script using the position of the wheels, so do not move the wheels before pressing on the Play button, they must be aligned relative to each other). </li><li>  Bones tied to the left and right caterpillar. </li><li>  Let's declare a class in which we will store the information we need about each wheel (except UpperWheels), namely: </li><li>  Transform wheels; </li><li>  Transform a bone tied to a caterpillar; </li><li>  WheelCollider wheels; </li><li>  The starting position of the wheel; </li><li>  The initial position of the bone; </li><li>  Angle of rotation of the wheel; </li><li>  The initial angles of rotation of the wheel. </li><li>  We declare arrays storing data about the left and right wheels, as you can see here the access modifier is used protected, so that we can not change this data outside the class. </li><li>  Finally, we declare the variables that will store the current offset of the texture coordinates on the tracks. </li></ol><br>  So the main variables are declared, it remains to associate them with our model, save the script, go to the editor, drag our script to the tank object (if you did not rename it of course). <br><br>  Go to the tank object itself, as you can see, in addition to the script just attached, there is an Animation object there; you can safely delete it there. <br><img src="https://habrastorage.org/storage/habraeffect/7d/8c/7d8c9184a181d169f905d604be66d460.jpg" alt="image"><br><br>  Next, create an object prefab with a WheelCollider (recall item 2 of the previous lesson), I called it tank_collider, it will have the following parameters. <br><img src="https://habrastorage.org/storage/habraeffect/a2/a1/a2a1a77450389cad5a76eb3073522089.jpg" alt="image"><br><br>  We start dragging objects into our script, first of all you can drag the newly created prefab into the Wheel Collider field inside our script.  Next, drag the tracks (they are called Track_line_left and Track_line_right) to the Left Track and Right Track fields.  Then the upper wheels (Upper_wheel [number] _left, Upper_wheel [number] _right), into the arrays of Left Track Upper Wheels and Right Track Upper Wheels.  Well, I think you understand the rest of the wheels and bones (the wheels are called rowheel_ [number] _right and rowheel_ [number] _left, and the bones Suspension_bone [number] _left and Suspension_bone [number] _right), the main thing is that all the wheels and bones are transferred to the same In order to make it easier, I specifically numbered them, and do not touch the bones called Chain_bone [number] _left and Chain_bone [number] _right, the static part of the track is attached to them. <br><br>  Here‚Äôs how all this should look like in the end: <br><img src="https://habrastorage.org/storage/habraeffect/bd/dc/bddc64b20358d4d6afdf226d67f66a0d.jpg" alt="image"><br><br>  Next, select the tank object and add to it a Rigidbody with the following parameters: <br><img src="https://habrastorage.org/storage/habraeffect/fa/cc/faccb11a6c28d989ff82b9f66461acb6.jpg" alt="image"><br><br>  Then find the hull (tank body) child object, add Mesh Collider (Component -&gt; Physics -&gt; Mesh Collider) to it, and tick Convex (this tick means that this Mesh Collider will calculate collisions not of all triangles contained in the tank body, but create your Mesh which will contain a maximum of 255 triangles). <br><br><h4>  3. Install Wheel Colliders and wheel parameters </h4><br>  So now our variables are declared and initialized, move on, and start by saving the wheel parameters in the WheelData [] leftTrackWheelData and WheelData [] rightTrackWheelData arrays.  We will do this inside the Awake () function and declare the WheelData SetupWheels () helper function, which, as you can see, should return a value of the WheelData type, having performed all operations with it before.  It all looks like this: <br><pre> <code class="hljs ruby">void Awake() { leftTrackWheelData = new WheelData[leftTrackWheels.Length]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> rightTrackWheelData = new WheelData[rightTrackWheels.Length]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;leftTrackWheels.Length;i++){ leftTrackWheelData[i] = SetupWheels(leftTrackWheels[i],leftTrackBones[i]); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;rightTrackWheels.Length;i++){ rightTrackWheelData[i] = SetupWheels(rightTrackWheels[i],rightTrackBones[i]); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">2</span></span> } Vector3 offset = transform.position; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">3</span></span> offset.z +=<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">01</span></span>f; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">3</span></span> transform.position = offset; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">3</span></span> } WheelData SetupWheels(Transform wheel, Transform bone){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">2</span></span> WheelData result = new WheelData(); GameObject go = new GameObject(<span class="hljs-string"><span class="hljs-string">"Collider_"</span></span>+wheel.name); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">4</span></span> go.transform.parent = transform; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">5</span></span> go.transform.position = wheel.position; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">6</span></span> go.transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0</span></span>,wheel.localRotation.y,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">7</span></span> WheelCollider col = (WheelCollider) go.AddComponent(typeof(WheelCollider));<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">8</span></span> WheelCollider colPref = wheelCollider.GetComponent&lt;WheelCollider&gt;();<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">9</span></span> col.mass = colPref.mass;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">10</span></span> col.center = colPref.center;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">10</span></span> col.radius = colPref.radius;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">10</span></span> col.suspensionDistance = colPref.suspensionDistance;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">10</span></span> col.suspensionSpring = colPref.suspensionSpring;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">10</span></span> col.forwardFriction = colPref.forwardFriction;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">10</span></span> col.sidewaysFriction = colPref.sidewaysFriction;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">10</span></span> result.wheelTransform = wheel; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">11</span></span> result.boneTransform = bone; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">11</span></span> result.col = col; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">11</span></span> result.wheelStartPos = wheel.transform.localPosition; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">11</span></span> result.boneStartPos = bone.transform.localPosition; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">11</span></span> result.startWheelAngle = wheel.transform.localRotation; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">12</span></span> }</code> </pre><br><ol><li>  We declare the dimension of the arrays that will contain information about our wheels. </li><li>  Filling these arrays, for this we, as I wrote above, created the SetupWheels () function with the first argument to which we pass the Transform wheels, and the second with Transform bones. </li><li>  Strange, but when I entered Play mode, the colliders constantly collapsed underground, fortunately it is treated by simply moving the tank object forward a bit, which is what these operations do. </li><li>  Create a new empty GameObject whose name will consist of the name of the wheel with the prefix Collider_. </li><li>  We make the newly created object as a child of the object to which the script is attached (in our case, children of the tank object). </li><li>  Move the newly created object to the place where we have the wheel. </li><li>  We rotate the object locally around the Y axis at the same angle at which the current wheel is rotated. </li><li>  Add the Wheel Collider component to our empty GO. </li><li>  We get the Wheel Collider settings from our prefab. </li><li>  We assign the settings obtained from the prefab to the newly created Wheel Collider (as you can see, we had to assign each setting separately, in this case, you cannot simply write the col = colPref compiler though it skips this design, but the collider settings remain by default). </li><li>  We assign the rest of the information we need. </li><li>  Return the result. </li></ol><br>  Feel free to click Play and make sure that Wheel Colliders are added to the lower wheels automatically, rather than as in the first lesson where we added each collider to each wheel manually, I think you shouldn‚Äôt talk about the advantages of this approach. <br><br><h4>  4. ‚ÄúLiven up‚Äù the wheels and the track </h4><br>  From the first lesson you should already know how to teach our wheels to rotate and react to uneven terrain, here we will use the same principle, except that the front and rear wheels of a car can rotate at different speeds, the same wheels on a separate vehicle the caterpillar rotates at the same speed, therefore we need to find a certain average wheel speed.  And naturally, to this speed, we still need to link the speed of movement of the caterpillar texture.  Let's more about everything: <br><pre> <code class="hljs ruby">void FixedUpdate(){ UpdateWheels(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> } public void UpdateWheels(){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> float delta = Time.fixedDeltaTime; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">2</span></span> float trackRpm = CalculateSmoothRpm(leftTrackWheelData); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">3</span></span> foreach (WheelData w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> leftTrackWheelData){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">4</span></span> w.wheelTransform.localPosition = CalculateWheelPosition(w.wheelTransform,w.col,w.wheelStartPos); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">5</span></span> w.boneTransform.localPosition = CalculateWheelPosition(w.boneTransform,w.col,w.boneStartPos); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">6</span></span> w.rotation = Mathf.Repeat(w.rotation + delta * trackRpm * <span class="hljs-number"><span class="hljs-number">360.0</span></span>f / <span class="hljs-number"><span class="hljs-number">60.0</span></span>f, <span class="hljs-number"><span class="hljs-number">360.0</span></span>f); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">7</span></span> w.wheelTransform.localRotation = Quaternion.Euler(w.rotation, w.startWheelAngle.y, w.startWheelAngle.z); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">8</span></span> } leftTrackTextureOffset = Mathf.Repeat(leftTrackTextureOffset + delta*trackRpm*trackTextureSpeed/<span class="hljs-number"><span class="hljs-number">60.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">9</span></span> leftTrack.renderer.material.SetTextureOffset(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>,new Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>,-leftTrackTextureOffset)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">10</span></span> trackRpm = CalculateSmoothRpm(rightTrackWheelData); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">3</span></span> foreach (WheelData w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rightTrackWheelData){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">4</span></span> w.wheelTransform.localPosition = CalculateWheelPosition(w.wheelTransform,w.col,w.wheelStartPos); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">5</span></span> w.boneTransform.localPosition = CalculateWheelPosition(w.boneTransform,w.col,w.boneStartPos); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">6</span></span> w.rotation = Mathf.Repeat(w.rotation + delta * trackRpm * <span class="hljs-number"><span class="hljs-number">360.0</span></span>f / <span class="hljs-number"><span class="hljs-number">60.0</span></span>f, <span class="hljs-number"><span class="hljs-number">360.0</span></span>f); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">7</span></span> w.wheelTransform.localRotation = Quaternion.Euler(w.rotation, w.startWheelAngle.y, w.startWheelAngle.z); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">8</span></span> } rightTrackTextureOffset = Mathf.Repeat(rightTrackTextureOffset + delta*trackRpm*trackTextureSpeed/<span class="hljs-number"><span class="hljs-number">60.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/9 rightTrack.renderer.material.SetTextureOffset("_MainTex",new Vector2(0,-rightTrackTextureOffset)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/10 for(int i=0;i&lt;leftTrackUpperWheels.Length;i++){ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/11 leftTrackUpperWheels[i].localRotation = Quaternion.Euler(leftTrackWheelData[0].rotation, leftTrackWheelData[0].startWheelAngle.y, leftTrackWheelData[0].startWheelAngle.z); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/11 } for(int i=0;i&lt;rightTrackUpperWheels.Length;i++){ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/11 rightTrackUpperWheels[i].localRotation = Quaternion.Euler(rightTrackWheelData[0].rotation, rightTrackWheelData[0].startWheelAngle.y, rightTrackWheelData[0].startWheelAngle.z); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/11 } } private float CalculateSmoothRpm(WheelData[] w){ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/12 float rpm = 0.0f; List&lt;int&gt; grWheelsInd = new List&lt;int&gt;(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/13 for(int i = 0;i&lt;w.Length;i++){ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/14 if(w[i].col.isGrounded){ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/14 grWheelsInd.Add(i); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/14 } } if(grWheelsInd.Count == 0){ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/15 foreach(WheelData wd in w){ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/15 rpm +=wd.col.rpm; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/15 } rpm /</span></span>= w.Length; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">15</span></span> }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;grWheelsInd.Count;i++){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">16</span></span> rpm +=w[grWheelsInd[i]].col.rpm; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">16</span></span> } rpm /= grWheelsInd.Count; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">16</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rpm; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">17</span></span> } private Vector3 CalculateWheelPosition(Transform w,WheelCollider col,Vector3 startPos){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">18</span></span> WheelHit hit; Vector3 lp = w.localPosition; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (col.GetGroundHit(out hit)) { lp.y -= Vector3.Dot(w.position - hit.point, transform.up) - wheelRadius; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lp.y = startPos.y - suspensionOffset; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lp; }</code> </pre><br><ol><li>  We will call our UpdateWheels () function inside the FixedUpdate () function, which will calculate the position and rotation angle of the wheels. </li><li>  See lesson 1. </li><li>  The CalculateSmoothRpm () function will calculate the average rotational speed of the wheels (I‚Äôll tell you more) that they rotate at the same speed into it, we pass the entire array to the leftTrackWheelData [], and then the array rightTrackWheelData []. </li><li>  For all elements of the arrays containing data on the left and right wheels perform the following operations: </li><li>  We calculate the local position of the wheel on the Y axis, in which the CalculateWheelPosition () function will help us (details below), into which we transfer the wheel's Transform, its WheelCollider, and its initial local position; </li><li>  The same operations, only this time to calculate the local position of the bone to which this part of the caterpillar is tied; </li><li>  We calculate the angle of rotation of the wheel (see lesson 1), only this time we use not the rpm of the collider, but the average rotational speed which we calculated earlier; </li><li>  We apply the calculated angle of rotation to the local angle of rotation of the wheel (see lesson 1). </li><li>  Calculate the caterpillar texture offset.  Unfortunately, I did not find a universal formula that would allow the wheel to rotate at the same speed and move the caterpillar, so I had to introduce an additional trackTextureSpeed ‚Äã‚Äãvariable (see above), which would later have to be manually adjusted so that the wheel and caterpillar would move at a uniform speed. </li><li>  We apply the track offset to the Y coordinate (new Vector2 (0, -leftTrackTextureOffset)), the main texture ("_MainTex") of the material used by the GO leftTrack and the rightTrack. </li><li>  We calculate the rotation of the upper wheels to which WheelColliders are not attached to us, we can borrow the angle of rotation from some other wheel, all the same, they all now move at the same speed. </li><li>  Well, finally we got to the CalculateSmoothRpm () function, which takes as its first argument an array of type WheelData, which in turn has the original name w. </li><li>  We create a new dynamic list which will contain the indices of those elements of the array w, within which the WheelCollider col is currently touching the surface (terrane). </li><li>  Run through the array and find the indices of the elements in which the colliders touch the surface. </li><li>  If the number of elements in the list is zero, that is, if none of the colliders touch the ground, then we add all the rpm colliders inside the array w, then divide the resulting value by the number of elements in the array w, thus finding the average value. </li><li>  If we have one or more elements of the list, ie if one or more colliders touch the ground, then we add the speeds of only these colliders and divide by the number of elements of the list. </li><li>  We return the resulting value.  (You should have a question: why do all these operations for calculating colliders that touch the ground, and why can't we just constantly find the average speed of rotation of all the wheels? The answer is homework: think (or better experiment) how then the wheels will rotate in this situations: <br><img src="https://habrastorage.org/storage/habraeffect/4a/97/4a975a686a742d2eddd33bbd9b0db057.jpg" alt="image"></li><li>  The CalculateWheelPosition () function that takes the first argument of the Transform wheel (or bone), the second WheelCollider, and the third starting local position of the wheel (or bone).  As I said above, this function calculates the local position of the wheel (or bone), and carries absolutely nothing new in itself, since we have analyzed this algorithm in the first lesson. </li></ol><br>  So now you can safely click on Play, and make sure that the wheels are set in motion, but since our tank is not able to drive yet, simply move it to an uneven surface.  Also, you most likely noticed that the wheels went underground, it does not matter, remember, we also have the wheelRadius variable, adjust its value without exiting the Play mode so that the wheels with the track are on the ground, as well as the value of the trackTextureSpeed ‚Äã‚Äãvariable, to synchronize the movement of the track with the movement of the wheels.  I got these values ‚Äã‚Äãas follows: <br><img src="https://habrastorage.org/storage/habraeffect/71/30/713089365b429272b620a92aeedd3fe5.jpg" alt="image"><br><br><h4>  5. Learning to ride </h4><br>  What is probably the most important feature of the movement of tracked vehicles that distinguishes it from a regular car?  I think this is a turn in place.  Do not believe?  <a href="http://www.youtube.com/watch%3Fv%3D7iiN-VzJuug">See it</a> .  Had an ordinary car the opportunity to turn around on the spot looking blondes leaving the parking lot would not have so often crashed into a car standing in front of them. <br><br>  So in what way can a tank turn in place, or turn at all without turning steering wheels?  Everything is just plain ugly, as you can see from the video above, one caterpillar moves forward, the other moves backward, so the tank turns around its axis.  Almost the same turns the tank during movement, except that the caterpillar located on the side in which we want to turn does not move in the other direction, but slows down a little. <br><br>  I propose to start with the simplest and, to begin with, teach our tank to turn in place.  It would seem that everything is clear.  And we can do this: <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> rotateOnStandTorque = <span class="hljs-number"><span class="hljs-number">1500.0</span></span>f; //<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> rotateOnStandBrakeTorque = <span class="hljs-number"><span class="hljs-number">500.0</span></span>f; //<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> maxBrakeTorque = <span class="hljs-number"><span class="hljs-number">1000.0</span></span>f; //<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> FixedUpdate(){ <span class="hljs-type"><span class="hljs-type">float</span></span> accelerate = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> steer = <span class="hljs-number"><span class="hljs-number">0</span></span>; accelerate = <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.GetAxis("Vertical"); //<span class="hljs-number"><span class="hljs-number">4</span></span> steer = <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>.GetAxis("Horizontal"); //<span class="hljs-number"><span class="hljs-number">4</span></span> UpdateWheels(accelerate,steer); //<span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> UpdateWheels(<span class="hljs-type"><span class="hljs-type">float</span></span> accel,<span class="hljs-type"><span class="hljs-type">float</span></span> steer){ //<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> delta = <span class="hljs-type"><span class="hljs-type">Time</span></span>.fixedDeltaTime; <span class="hljs-type"><span class="hljs-type">float</span></span> trackRpm = CalculateSmoothRpm(leftTrackWheelData); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (WheelData w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> leftTrackWheelData){ w.wheelTransform.localPosition = CalculateWheelPosition(w.wheelTransform,w.col,w.wheelStartPos); w.boneTransform.localPosition = CalculateWheelPosition(w.boneTransform,w.col,w.boneStartPos); w.rotation = Mathf.Repeat(w.rotation + delta * trackRpm * <span class="hljs-number"><span class="hljs-number">360.0</span></span>f / <span class="hljs-number"><span class="hljs-number">60.0</span></span>f, <span class="hljs-number"><span class="hljs-number">360.0</span></span>f); w.wheelTransform.localRotation = Quaternion.Euler(w.rotation, w.startWheelAngle.y, w.startWheelAngle.z); CalculateMotorForce(w.col,accel,steer); //<span class="hljs-number"><span class="hljs-number">6</span></span> } leftTrackTextureOffset = Mathf.Repeat(leftTrackTextureOffset + delta*trackRpm*trackTextureSpeed/<span class="hljs-number"><span class="hljs-number">60.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); leftTrack.renderer.material.SetTextureOffset("_MainTex",<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>,-leftTrackTextureOffset)); trackRpm = CalculateSmoothRpm(rightTrackWheelData); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (WheelData w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rightTrackWheelData){ w.wheelTransform.localPosition = CalculateWheelPosition(w.wheelTransform,w.col,w.wheelStartPos); w.boneTransform.localPosition = CalculateWheelPosition(w.boneTransform,w.col,w.boneStartPos); w.rotation = Mathf.Repeat(w.rotation + delta * trackRpm * <span class="hljs-number"><span class="hljs-number">360.0</span></span>f / <span class="hljs-number"><span class="hljs-number">60.0</span></span>f, <span class="hljs-number"><span class="hljs-number">360.0</span></span>f); w.wheelTransform.localRotation = Quaternion.Euler(w.rotation, w.startWheelAngle.y, w.startWheelAngle.z); CalculateMotorForce(w.col,accel,-steer); //<span class="hljs-number"><span class="hljs-number">6</span></span> } rightTrackTextureOffset = Mathf.Repeat(rightTrackTextureOffset + delta*trackRpm*trackTextureSpeed/<span class="hljs-number"><span class="hljs-number">60.0</span></span>f,<span class="hljs-number"><span class="hljs-number">1.0</span></span>f); rightTrack.renderer.material.SetTextureOffset("_MainTex",<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>,-rightTrackTextureOffset)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;leftTrackUpperWheels.Length;i++){ leftTrackUpperWheels[i].localRotation = Quaternion.Euler(leftTrackWheelData[<span class="hljs-number"><span class="hljs-number">0</span></span>].rotation, leftTrackWheelData[<span class="hljs-number"><span class="hljs-number">0</span></span>].startWheelAngle.y, leftTrackWheelData[<span class="hljs-number"><span class="hljs-number">0</span></span>].startWheelAngle.z); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;rightTrackUpperWheels.Length;i++){ rightTrackUpperWheels[i].localRotation = Quaternion.Euler(rightTrackWheelData[<span class="hljs-number"><span class="hljs-number">0</span></span>].rotation, rightTrackWheelData[<span class="hljs-number"><span class="hljs-number">0</span></span>].startWheelAngle.y, rightTrackWheelData[<span class="hljs-number"><span class="hljs-number">0</span></span>].startWheelAngle.z); } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> CalculateMotorForce(WheelCollider col, <span class="hljs-type"><span class="hljs-type">float</span></span> accel, <span class="hljs-type"><span class="hljs-type">float</span></span> steer){ //<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; steer == <span class="hljs-number"><span class="hljs-number">0</span></span>){ //<span class="hljs-number"><span class="hljs-number">7</span></span> col.brakeTorque = maxBrakeTorque; //<span class="hljs-number"><span class="hljs-number">7</span></span> }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accel == <span class="hljs-number"><span class="hljs-number">0.0</span></span>f){ //<span class="hljs-number"><span class="hljs-number">8</span></span> col.brakeTorque = rotateOnStandBrakeTorque; //<span class="hljs-number"><span class="hljs-number">9</span></span> col.motorTorque = steer*rotateOnStandTorque; //<span class="hljs-number"><span class="hljs-number">10</span></span> } }</code> </pre><br><ol><li>  Torque that will be transmitted to the colliders when the tank is in place. </li><li>  Braking moment which we will pass to the colliders when the tank is in place. </li><li>  Maximum braking torque. </li><li>  See lesson 1. </li><li>  Modifying the UpdateWheels () function will make it accept values ‚Äã‚Äãfrom virtual axes. </li><li>  We will use the CalculateMotorForce () function to control the torque and braking torque at the colliders; we will transfer the collider and virtual axes to this function (note for leftTrackWheelData we transfer a positive value from the horizontal axis, and for rightTrackWheelData it will allow us to move the tracks in different directions ). </li><li>  If no movement key is pressed, then we transfer the maximum braking torque to the collider (so that it does not roll off uneven places). </li><li>  If the forward key is not pressed, but the forward key is pressed then: </li><li>  We transfer the braking moment to the collider. </li><li>  We transmit the torque multiplied by the value obtained from the horizontal axis (this torque must be greater than the braking torque rotateOnStandBrakeTorque in order for the tank to move). </li></ol><br>  So, press Play, and then on the movement button to the side (A or D).  And what we see, only the pitiful attempts of our tank to turn around on the spot, such a feeling that it lacks power.  You can certainly increase the value of the rotateOnStandTorque variable, but the result will be pretty funny. <br><br>  In fact, it‚Äôs not a matter of torque, it‚Äôs more than enough to turn a tank.  Let's go back to the sources, that is, to our tank_collider prefab, the settings of which are inherited for all WheelColliders of the tank.  Pay attention to the Sideways Friction field, in the previous lesson I mentioned this setting, I said that this is the ‚Äúlateral‚Äù friction force of the wheel, and it is useful if we want to implement a drift.  Now this very force of friction that acts on our colliders from the sides is incredibly large, the torque of the wheels is not able to overcome it, so our tank does not turn.  Now pay attention to the variable Stiffness Factor inside Sideways Friction, we need it, in fact, this is the number by which the lateral friction force multiplies, set it to zero, press Play. <br><img src="https://habrastorage.org/storage/habraeffect/a5/97/a5974c036cfe867294bf2fa74d6438b6.jpg" alt="image"><br><br>  About the miracle, our tank has gone mad and now it can spin at the speed of a top, and even drive sideways, everything is correct, now there is no side friction at all.  Now exit Play mode, set the value to 0.06 and click Play again.  Well, finally, now our tank turns around its axis and is quite adequate.  Exit Play mode and set the value of Sideways Friction back to 1. Of course, all this is good to change the value directly from the prefab, but it is better to do it from the script, because when lateral friction is not controllable, there is a chance that our tank will go into real drift.  At the same time we will teach the tank to go forward and turn while moving.  Modify the CalculateMotorForce () function and declare another small global variables: <br><pre> <code class="hljs ruby">public float forwardTorque = <span class="hljs-number"><span class="hljs-number">500.0</span></span>f; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> public float rotateOnMoveBrakeTorque = <span class="hljs-number"><span class="hljs-number">400.0</span></span>f; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">2</span></span> public float minBrakeTorque = <span class="hljs-number"><span class="hljs-number">0</span></span>.0f; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">3</span></span> public float minOnStayStiffness = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">06</span></span>f; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">4</span></span> public float minOnMoveStiffness = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">05</span></span>f; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">5</span></span> public float rotateOnMoveMultiply = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">6</span></span> public void CalculateMotorForce(WheelCollider col, float accel, float steer){ WheelFrictionCurve fc = col.sidewaysFriction; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; steer == <span class="hljs-number"><span class="hljs-number">0</span></span>){ col.brakeTorque = maxBrakeTorque; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accel == <span class="hljs-number"><span class="hljs-number">0</span></span>.0f){ col.brakeTorque = rotateOnStandBrakeTorque; col.motorTorque = steer*rotateOnStandTorque; fc.stiffness = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f + minOnStayStiffness - Mathf.Abs(steer); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">8</span></span> col.brakeTorque = minBrakeTorque; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">9</span></span> col.motorTorque = accel*forwardTorque; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(steer &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">11</span></span> col.brakeTorque = rotateOnMoveBrakeTorque; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">12</span></span> col.motorTorque = steer*forwardTorque*rotateOnMoveMultiply;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">13</span></span> fc.stiffness = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f + minOnMoveStiffness - Mathf.Abs(steer); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">14</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(steer &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">15</span></span> col.motorTorque = steer*forwardTorque*rotateOnMoveMultiply;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">16</span></span> fc.stiffness = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f + minOnMoveStiffness - Mathf.Abs(steer); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">17</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fc.stiffness &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>f)fc.stiffness = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">18</span></span> col.sidewaysFriction = fc; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(col.rpm &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; accel &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">20</span></span> col.brakeTorque = maxBrakeTorque; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">21</span></span> }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(col.rpm &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; accel &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">22</span></span> col.brakeTorque = maxBrakeTorque; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">23</span></span> } }</code> </pre><br><ol><li>     (, ). </li><li>       . </li><li>   . </li><li>       . </li><li>        . </li><li>        . </li><li>   fc  WheelFrictionCurve,    Sideways Friction  Wheel Collider'. </li><li>    ,        : </li><li>     ; </li><li>          ; </li><li>         (                  ,   ,   ) : </li><li>     (   ,    ); </li><li>                 (               ,      ); </li><li>          fc. </li><li>         (                  ,   ,   ) : </li><li>        ,    . </li><li>          fc. </li><li>           ,  ,   . </li><li>   sidewaysFriction    fs (     col.sidewaysFriction.stiffnes = (float),   ). </li><li>    ,      : </li><li>     . </li><li>          : </li><li>  No comments. </li></ol><br>    ,     ,       ,    . <br><br>           ,      ,      ,        300 .  at one o'clock.          ,      .   ,   coming soon. </div><p>Source: <a href="https://habr.com/ru/post/116088/">https://habr.com/ru/post/116088/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116082/index.html">Prevent Recursion and Lazy Computing in Java</a></li>
<li><a href="../116083/index.html">The DVFU ROV Team 2010</a></li>
<li><a href="../116084/index.html">Fake certificates for popular sites</a></li>
<li><a href="../116085/index.html">RGB lamp</a></li>
<li><a href="../116087/index.html">We collect package for Solaris from sorts</a></li>
<li><a href="../116090/index.html">Mike Tyson will cure patients with gambling addiction</a></li>
<li><a href="../116091/index.html">Geolocation service inmile.com</a></li>
<li><a href="../116092/index.html">Bear Ballet and Artificial Intelligence</a></li>
<li><a href="../116093/index.html">European Commission servers have been attacked by hackers</a></li>
<li><a href="../116095/index.html">Wysips introduced a hybrid display with solar panels.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>