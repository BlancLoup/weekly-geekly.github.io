<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a cartoon water shader for the web. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part, we looked at setting the environment and the surface of the water. In this part, we will give objects buoyancy, add water lines on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a cartoon water shader for the web. Part 2</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="https://habr.com/post/416953/">first part,</a> we looked at setting the environment and the surface of the water.  In this part, we will give objects buoyancy, add water lines on the surface and create foam lines with a buffer of depths around the boundaries of objects that intersect the surface. <br><br>  To make the scene look a little better, I made some small changes to it.  You can customize your scene the way you want, and I did the following: <br><br><ul><li>  Added models of lighthouse and octopus. </li><li> Added earth model with color <code>#FFA457</code> . </li><li>  Added sky color to camera <code>#6CC8FF</code> . </li><li>  Added <code>#FFC480</code> backlight color to the scene (these parameters can be found in the scene settings). </li></ul><br>  My original scene now looks like this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/2fa/0d5/bc22fa0d57b5120e75cced6f105bebd2.png"></div><a name="habracut"></a><br><h2>  Buoyancy </h2><br>  The simplest way to create buoyancy is a script that pushes objects up and down.  Create a new <strong>Buoyancy.js</strong> script and set the following in its initialize: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getPosition().clone(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialRotation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getEulerAngles().clone(); <span class="hljs-comment"><span class="hljs-comment">//     ,  //        //     this.time = Math.random() * 2 * Math.PI; };</span></span></code> </pre> <br>  Now in update we execute the time increment and rotate the object: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      var pos = this.entity.getPosition().clone(); pos.y = this.initialPosition.y + Math.cos(this.time) * 0.07; this.entity.setPosition(pos.x,pos.y,pos.z); //    var rot = this.entity.getEulerAngles().clone(); rot.x = this.initialRotation.x + Math.cos(this.time * 0.25) * 1; rot.z = this.initialRotation.z + Math.sin(this.time * 0.5) * 2; this.entity.setLocalEulerAngles(rot.x,rot.y,rot.z); };</span></span></code> </pre> <br>  Apply this script to the boat and see how it rides up and down the water!  You can apply this script to several objects (including the camera - try it)! <br><br><h2>  Surface texturing </h2><br>  While we can see the waves, looking at the edges of the water surface.  Adding texture will make the surface movement more noticeable.  In addition, it is a low-cost way to simulate reflections and caustics. <br><br>  You can try to find some caustic textures or create it yourself.  I drew <a href="" rel="external">a texture</a> in Gimp that you can use freely.  Any texture will do, provided it can be tiled without visible joints. <br><br>  After picking up your favorite texture, drag it into the Assets window of your project.  We need to reference this texture from the Water.js script, so we will create an attribute for it: <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'surfaceTexture'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'texture'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Surface Texture'</span></span> });</code> </pre> <br>  And then assign it to the editor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/61e/32f/67261e32f145eda9dab99d1866181ced.png"></div><br>  Now we need to pass it to the shader.  Go to <strong>Water.js</strong> and set a new parameter in the <code>CreateWaterMaterial</code> function: <br><br><pre> <code class="javascript hljs">material.setParameter(<span class="hljs-string"><span class="hljs-string">'uSurfaceTexture'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.surfaceTexture.resource);</code> </pre> <br>  Now go back to <strong>Water.frag</strong> and declare a new uniform: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture;</code> </pre> <br>  We are almost done.  To render a texture on a plane, we need to know where each pixel is in the mesh.  That is, we need to transfer data from the vertex shader to the fragment shader. <br><br><h3>  Varying variables </h3><br>  <em>Varying</em> variables allow you to transfer data from a vertex shader to a fragment shader.  This is the third type of special variables that can be used in the shader (the first two are <em>uniform</em> and <em>attribute</em> ).  The variable is set for each vertex and each pixel can access it.  Since there are many more pixels than vertices, the value is interpolated between the vertices (hence the name "varying" appeared - it deviates from the values ‚Äã‚Äãpassed to it). <br><br>  To check it in work, we will declare a new variable in <strong>Water.vert</strong> as varying: <br><br><pre> <code class="javascript hljs">varying vec2 ScreenPosition;</code> </pre> <br>  And then assign the value <code>gl_Position</code> after its calculation: <br><br><pre> <code class="javascript hljs">ScreenPosition = gl_Position.xyz;</code> </pre> <br>  Now back to <strong>Water.frag</strong> and declare the same variable.  We will not be able to get debug output from the shader, but we can use color for visual debugging.  Here's how to do it: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec3 ScreenPosition; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    varying- color = vec4(vec3(ScreenPosition.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  The plane should now look black and white, and the color dividing line will pass where <code>ScreenPosition.x</code> = 0. Color values ‚Äã‚Äãchange only from 0 to 1, but the values ‚Äã‚Äãin <code>ScreenPosition</code> may be outside of this interval.  They are automatically limited, so when you see black, it can be 0 or a negative number. <br><br>  What we just did: transferred the screen position of each vertex to each pixel.  You can see that the line separating the black and white sides will always be in the center of the screen, regardless of where the surface is actually in the world. <br><br><blockquote>  <em>Task 1: create a new varying variable for transferring a position in the world instead of a screen position.</em>  <em>Visualize it in the same way.</em>  <em>If the color does not change with the movement of the camera, then everything is done correctly.</em> </blockquote><br><h3>  Using UV </h3><br>  <a href="https://ru.wikipedia.org/wiki/UV-%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="external">UV</a> is the 2D coordinates of each vertex on the mesh, normalized from 0 to 1. They are the ones that are needed to correctly sample the texture onto the plane, and we have already adjusted them in the previous section. <br><br>  <strong>Let's</strong> declare a new attribute in <strong>Water.vert</strong> (this name is taken from the definition of the shader in Water.js): <br><br><pre> <code class="javascript hljs">attribute vec2 aUv0;</code> </pre> <br>  And now we just need to pass it to the fragment shader, so just create a varying and assign the attribute value to it: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Water.vert //        varying vec2 vUv0; // .. //        //  varying,        vUv0 = aUv0;</span></span></code> </pre> <br>  Now we will declare the same varying variable in the fragment shader.  To make sure that everything works, we can visualize debugging as before, and then Water.frag will look like this: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  UV color = vec4(vec3(vUv0.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  You should see a gradient confirming that we have a value of 0 from one end and 1 from the other.  Now to sample the texture for real, we just need to do the following: <br><br><pre> <code class="javascript hljs">color = texture2D(uSurfaceTexture,vUv0);</code> </pre> <br>  After that we will see a texture on the surface: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/9bf/ae2/f499bfae266b0aa16709bbea0280df6f.png"></div><br><h3>  Texture stylization </h3><br>  Instead of simply setting the texture as a new color, let's combine it with the existing blue: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec4 WaterLines = texture2D(uSurfaceTexture,vUv0); color.rgba += WaterLines.r; gl_FragColor = color; }</code> </pre> <br>  This works because the texture color is black (0) everywhere, except for the lines of water.  By adding it, we do not change the original blue color, except for places with lines where it becomes lighter. <br><br>  However, this is not the only way to combine colors. <br><br><blockquote>  <em>Task 2: Can you combine the colors so that you get the weaker effect shown below?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/e18/22a/a3de1822a348656f47e5bd6cfa6cbed5.png"></div><br><h3>  Moving texture </h3><br>  As a final effect, we want the lines to move along the surface and it does not look so static.  To do this, we use the fact that any value outside the interval from 0 to 1, passed to the <code>texture2D</code> function, will be transferred (for example, both 1.5 and 2.5 become equal to 0.5).  Therefore, we can increase our position by the uniform time variable we have already specified in order to increase or decrease the density of lines on the surface, which will give the final fragmentary shader the following form: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0; <span class="hljs-comment"><span class="hljs-comment">//      1 //     pos *= 2.0; //   ,      pos.y += uTime * 0.02; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r; gl_FragColor = color; }</span></span></code> </pre> <br><h2>  Foam lines and depth buffer </h2><br>  Rendering foam lines around objects in water makes it much easier to see how objects are immersed and where they cross the surface.  In addition, so our water becomes much more believable.  To realize the foam lines, we somehow need to figure out where the boundaries of each object are, and do it efficiently. <br><br><h3>  Cunning </h3><br>  We need to learn to determine whether a pixel is close to the object on the surface of the water.  If so, then we can paint it in foam color.  There are no simple ways to solve this problem (as far as I know).  Therefore, to solve it, I use a useful technique for solving problems: I will take an example, the answer for which we know, and see if we can generalize it. <br><br>  Look at the image below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d0/0e7/eec/4d00e7eec8714a365c110aea67df9fab.png"></div><br>  Which pixels should be part of the foam?  We know that it should look something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a8/541/c4f/1a8541c4f8fdd65879966b909805c484.png"></div><br>  So let's look at two specific pixels.  Below I marked them with asterisks.  Black will be on the foam, and red will not.  How do we distinguish them in the shader? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/d35/fb2/012d35fb25d42c19a86adaa081048237.png"></div><br>  We know that even though these two pixels in the screen space are close to each other (both are rendered on top of the beacon body), in fact they are very far in the space of the world.  We can see this by looking at the same scene from a different angle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/5a0/31b/cd35a031bbd18805128ebd44ed1c1279.png"></div><br>  Note that the red star is not on the lighthouse, as it seemed to us, but the black one is actually there.  We can distinguish from using the distance to the camera, which is commonly called the "depth."  Depth 1 means that the point is very close to the camera, depth 0 means that it is very far away.  But this is not only a matter of absolute distances in the world, depth or camera.  The depth <em>relative to the pixel behind it is</em> important. <br><br>  Look again at the first view.  Suppose the lighthouse body has a depth value of 0.5.  The depth of the black asterisk will be very close to 0.5.  That is, it and the pixel below it have very close depth values.  On the other hand, the red star will have a much greater depth, because it is closer to the camera, say 0.7.  And although the pixel behind it is still on the lighthouse, it has a depth value of 0.5, that is, there is a difference here. <br><br>  This is the trick.  <em>When the depth of a pixel on the surface of the water is close enough to the depth of the pixel on top of which it is drawn, then we are fairly close to the border of some object</em> and can render the pixel as foam. <br><br>  That is, we need more information than we have in any pixel.  We somehow need to know the depth of the pixel over which it should be drawn.  And here we have the depth buffer. <br><br><h3>  Depth buffer </h3><br>  You can render the frame buffer or buffer as an offscreen target render or texture.  When we need to read data, we need to render off-screen.  This technique is used in the <a href="https://habr.com/post/333718/" rel="external">effect of smoke</a> . <br><br>  The depth buffer is a special target render, which contains information about the depth values ‚Äã‚Äãof each pixel.  Do not forget that the value in <code>gl_Position</code> , calculated in the vertex shader, was the value of the screen space, but it also has a third coordinate, the Z value. This Z value is used to calculate the depth, which is written to the depth buffer. <br><br>  The depth buffer is designed to correctly render the scene without having to sort the objects from behind.  Each pixel to be drawn first checks the depth buffer.  If its depth value is greater than the value in the buffer, then it is drawn, and its own value overwrites the value of the buffer.  Otherwise, it is discarded (because it means that there is another object in front of it). <br><br>  In fact, you can turn off writing to the depth buffer to see how everything will look without it.  Let's try to do this in Water.js: <br><br><pre> <code class="javascript hljs">material.depthTest = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  You will notice that water will now always be drawn from above, even if it is behind opaque objects. <br><br><h3>  Depth buffer visualization </h3><br>  For debugging purposes, let's add a way to render the depth buffer.  Create a new script <strong>DepthVisualize.js</strong> .  Attach it to the camera. <br><br>  To access the depth buffer in PlayCanvas, it‚Äôs enough to write the following: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.camera.camera.requestDepthMap();</code> </pre> <br>  So we automatically inject the uniform variable into all our shaders, which we can use by declaring it as follows: <br><br><pre> <code class="javascript hljs">uniform sampler2D uDepthMap;</code> </pre> <br>  Below is an example script requesting a depth map and rendering it over the stage.  It has a hot reboot configured. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DepthVisualize = pc.createScript(<span class="hljs-string"><span class="hljs-string">'depthVisualize'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  initialize,       DepthVisualize.prototype.initialize = function() { this.entity.camera.camera.requestDepthMap(); this.antiCacheCount = 0; //    ,         this.SetupDepthViz(); }; DepthVisualize.prototype.SetupDepthViz = function(){ var device = this.app.graphicsDevice; var chunks = pc.shaderChunks; this.fs = ''; this.fs += 'varying vec2 vUv0;'; this.fs += 'uniform sampler2D uDepthMap;'; this.fs += ''; this.fs += 'float unpackFloat(vec4 rgbaDepth) {'; this.fs += ' const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);'; this.fs += ' float depth = dot(rgbaDepth, bitShift);'; this.fs += ' return depth;'; this.fs += '}'; this.fs += ''; this.fs += 'void main(void) {'; this.fs += ' float depth = unpackFloat(texture2D(uDepthMap, vUv0)) * 30.0; '; this.fs += ' gl_FragColor = vec4(vec3(depth),1.0);'; this.fs += '}'; this.shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, this.fs, "renderDepth" + this.antiCacheCount); this.antiCacheCount ++; //     ,        this.command = new pc.Command(pc.LAYER_FX, pc.BLEND_NONE, function () { pc.drawQuadWithShader(device, null, this.shader); }.bind(this)); this.command.isDepthViz = true; //    ,      this.app.scene.drawCalls.push(this.command); }; //  update,     DepthVisualize.prototype.update = function(dt) { }; //  swap,      //      DepthVisualize.prototype.swap = function(old) { this.antiCacheCount = old.antiCacheCount; //      for(var i=0;i&lt;this.app.scene.drawCalls.length;i++){ if(this.app.scene.drawCalls[i].isDepthViz){ this.app.scene.drawCalls.splice(i,1); break; } } //    this.SetupDepthViz(); }; //      ,  : // http://developer.playcanvas.com/en/user-manual/scripting/</span></span></code> </pre> <br>  Try copying the code and commenting / uncommenting the line <code>this.app.scene.drawCalls.push(this.command);</code>  to enable / disable depth rendering.  This should look like the image below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c09/93a/c4f/c0993ac4f8ed7a4c739658bbff69e455.png"></div><br><blockquote>  <em>Task 3: the surface of the water is not drawn into the depth buffer.</em>  <em>The PlayCanvas engine does so intentionally.</em>  <em>Can you figure out why?</em>  <em>What is special about water?</em>  <em>In other words, given our rules for checking depths, what would happen if water pixels were recorded in the depth buffer?</em> </blockquote><br>  <em>Hint: in Water.js, you can change one line, which will allow you to write water to the depth buffer.</em> <br><br>  It should also be noted that in the initialize function, I multiply the depth value by 30. This is necessary to see it clearly, because otherwise the interval of values ‚Äã‚Äãwould be too small to display shades of color. <br><br><h3>  Implementation tricks </h3><br>  In the PlayCanvas engine there are several auxiliary functions for working with depth values, but as of this writing, they were not released in production, so we will have to configure them ourselves. <br><br>  Define the following uniform variables in <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   uniform-    PlayCanvas uniform sampler2D uDepthMap; uniform vec4 uScreenSize; uniform mat4 matrix_view; //      uniform vec4 camera_params;</span></span></code> </pre> <br>  We define these auxiliary functions over the main function: <br><br><pre> <code class="javascript hljs">#ifdef GL2 float linearizeDepth(float z) { z = z * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (camera_params.z * z + camera_params.w); } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #ifndef UNPACKFLOAT #define UNPACKFLOAT float unpackFloat(vec4 rgbaDepth) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec4 bitShift = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">256.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(rgbaDepth, bitShift); } #endif #endif float getLinearScreenDepth(vec2 uv) { #ifdef GL2 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y; #endif } float getLinearDepth(vec3 pos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(matrix_view * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)).z; } float getLinearScreenDepth() { vec2 uv = gl_FragCoord.xy * uScreenSize.zw; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getLinearScreenDepth(uv); }</code> </pre> <br>  Give the shader information about the camera in <strong>Water.js</strong> .  Paste it where you pass other uniform variables like uTime: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">"Camera"</span></span>).camera; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = camera.nearClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = camera.farClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera_params = [ <span class="hljs-number"><span class="hljs-number">1</span></span>/f, f, (<span class="hljs-number"><span class="hljs-number">1</span></span>-f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span> + f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span> ]; material.setParameter(<span class="hljs-string"><span class="hljs-string">'camera_params'</span></span>, camera_params);</code> </pre> <br>  Finally, we need a position in the world of each pixel for our fragment shader.  We need to get it from the vertex shader.  Therefore, we define in the <strong>Water.frag a</strong> varying variable: <br><br><pre> <code class="javascript hljs">varying vec3 WorldPosition;</code> </pre> <br>  Define the same varying variable in <strong>Water.vert</strong> .  Then assign it a distorted position from the vertex shader so that the full code looks like this: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; attribute vec2 aUv0; varying vec2 vUv0; varying vec3 WorldPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; uniform float uTime; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vUv0 = aUv0; vec3 pos = aPosition; pos.y += cos(pos.z*<span class="hljs-number"><span class="hljs-number">5.0</span></span>+uTime) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> * sin(pos.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span> + uTime); gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); WorldPosition = pos; }</code> </pre> <br><h3>  We implement the trick for real </h3><br>  Now we are finally ready to implement the technique described at the beginning of this section.  We want to compare the depth of the pixel we are in with the depth of the pixel below it.  The pixel we are in is taken from a position in the world, and the pixel below it is obtained from the screen position.  Therefore, we take these two depths: <br><br><pre> <code class="javascript hljs">float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth();</code> </pre> <br><blockquote>  <em>Task 4: one of these values ‚Äã‚Äãwill never be greater than the other (assuming depthTest = true).</em>  <em>Can you determine which one?</em> </blockquote><br>  We know that foam will be where the distance between the two values ‚Äã‚Äãis small.  So let's render this distinction for each pixel.  Paste this at the end of the shader (and disable the depth rendering script from the previous section): <br><br><pre> <code class="javascript hljs">color = vec4(vec3(screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_FragColor = color;</code> </pre> <br>  And it should look something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/173/883/ad2173883ebe214bbec6c97921810755.png"></div><br>  That is, we correctly select the boundaries of any object that is immersed in water in real time!  Of course, you can scale the difference to make the foam thicker or less. <br><br>  We now have many options for how to combine this output with the surface of the water to produce beautiful foam lines.  You can leave them with a gradient, use them for sampling from another texture, or assign them a specific color if the difference is less than or equal to a certain limit value. <br><br>  I liked most of all the assignment of color, similar to the lines of static water, so my finished main function looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0 * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; pos.y += uTime * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r * <span class="hljs-number"><span class="hljs-number">0.1</span></span>; float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth(); float foamLine = clamp((screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(foamLine &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>){ color.rgba += <span class="hljs-number"><span class="hljs-number">0.2</span></span>; } gl_FragColor = color; }</code> </pre> <br><h2>  Summing up </h2><br>  We created the buoyancy of objects immersed in water, laid a moving texture on the surface to simulate caustics, and learned how to use the depth buffer to create dynamic foam bands. <br><br>  In the third and last part, we will add post-processing effects and learn how to use them to create an underwater distortion effect. <br><br><h2>  Source </h2><br>  A complete PlayCanvas project can be found <a href="https://playcanvas.com/project/533435/overview/toon-water--tuts-tutorial" rel="external">here</a> .  In our repository there is also a <a href="https://github.com/OmarShehata/tutsplus-toon-water" rel="external">project port under Three.js</a> . </div><p>Source: <a href="https://habr.com/ru/post/416983/">https://habr.com/ru/post/416983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../411153/index.html">Nine circles of bureaucracy: how the airport in Denver is trying to get a license to the spaceport</a></li>
<li><a href="../416969/index.html">Pythagorean mathematical substantiation of the musical scale</a></li>
<li><a href="../416977/index.html">Smart Home Software # 2</a></li>
<li><a href="../416979/index.html">Scrum to big teams: LeSS Day 2018</a></li>
<li><a href="../416981/index.html">How eight people scale a highload project. Unsplash experience</a></li>
<li><a href="../416985/index.html">Up to a hundredth: top 10 reports SmartData 2017</a></li>
<li><a href="../416987/index.html">Gartner: Highlights on the IaaS Market in 2018</a></li>
<li><a href="../416989/index.html">Festo bionic robots: spiders and octopuses in the factories of the future?</a></li>
<li><a href="../416991/index.html">Recording video from your screen is not so secret. Burger King and Appsee Versions</a></li>
<li><a href="../416993/index.html">Meet Sophia: a robot almost indistinguishable from a human</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>