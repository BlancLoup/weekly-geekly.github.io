<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Static analysis of PHP code on the example of PHPStan, Phan and Psalm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo has been around for over 12 years. We have a lot of PHP code (millions of lines) and probably even lines written 12 years ago have been preserve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Static analysis of PHP code on the example of PHPStan, Phan and Psalm</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/yj/nq/4_/yjnq4_9tdzj0noyiimybxjpoctk.jpeg"><br><br>  Badoo has been around for over 12 years.  We have a lot of PHP code (millions of lines) and probably even lines written 12 years ago have been preserved.  We have code written back in the days of PHP 4 and PHP 5. We post the code twice a day, and each layout contains about 10-20 tasks.  In addition, programmers can post urgent patches - small changes.  And on the day of such patches, we have a couple of dozen.  In general, our code is changing very actively. <br><br>  We are constantly looking for opportunities to both speed development and improve the quality of the code.  And once we decided to implement static code analysis.  What came out of it, read under the cut. <br><a name="habracut"></a><br><h1>  Strict types: why we do not use it yet </h1><br>  Once we had a discussion in our corporate PHP chat.  One of the new employees told how at the previous place of work they introduced mandatory strict_types + scalar <a href="https://wiki.php.net/rfc/scalar_type_hints">type hints</a> for the entire code - and this significantly reduced the number of production bugs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Most of the old-timers chat was against this innovation.  The main reason was that PHP does not have a compiler that, at the compilation stage, would check the conformity of all types in the code, and if you don‚Äôt have 100% coverage of the code with tests, there is always a risk that errors will pop up during production, want to admit. <br><br>  Of course, strict_types will find a certain percentage of bugs caused by type mismatch and the way PHP "silently" converts types.  But many experienced PHP programmers already know how the type system works in PHP, what are the rules for type conversion, and in most cases they write the correct, working code. <br><br>  But we liked the idea of ‚Äã‚Äãhaving a certain system showing where in the code there is a mismatch of types.  We are thinking about alternatives to strict_types. <br><br>  At first we even wanted to patch PHP.  We wanted that if the function takes some scalar type (say, int), and another scalar type comes in (for example, float), then TypeError (which is essentially an exception) would not throw, but type conversion would occur, as well as the logging of this event in error.log.  This would allow us to find all the places where our assumptions about types are wrong.  But such a patch seemed risky to us, and there could be problems with external dependencies, which were not ready for such behavior. <br><br>  We abandoned the idea of ‚Äã‚Äãpatching PHP, but in time it all coincided with the first releases of the static analyzer Phan, the first commits of which were made by Rasmus Lerdorf himself.  So we came up with the idea to try static code analyzers. <br><br><h1>  What is static code analysis </h1><br>  Static code analyzers simply read the code and try to find errors in it.  They can perform both very simple and obvious checks (for example, the existence of classes, methods and functions, and more cunning ones (for example, search for type discrepancies, race conditions or vulnerabilities in code). The key is that analyzers do not perform code - they analyze the program text and check it for typical (and not so) errors. <br><br>  The most obvious example of a static PHP code analyzer are inspections in PHPStorm: when you write code, it highlights incorrect function calls, methods, mismatch of parameter types, etc. At the same time, PHPStorm does not run your PHP code ‚Äî it only analyzes it. <br><br>  I note that in this article we are talking about analyzers that are looking for errors in the code.  There is another class of analyzers - they check the style of writing code, cyclomatic complexity, the size of methods, the length of lines, etc. We do not consider such analyzers here. <br><br>  Although not all that the analyzers we are looking at are exactly the wrong thing.  By mistake, I mean the code that creates Fatal in production.  Very often, what analyzers find is rather an inaccuracy.  For example, in PHPDoc, an invalid parameter type may be specified.  This inaccuracy does not affect the operation of the code, but subsequently the code will evolve - another programmer may make a mistake. <br><br><h1>  Existing PHP code analyzers </h1><br>  There are three popular PHP code analyzers: <br><br><ol><li>  <a href="https://github.com/phpstan/phpstan">PHPStan</a> . <br></li><li>  <a href="https://github.com/vimeo/psalm">Psalm</a> <br></li><li>  <a href="https://github.com/phan/phan">Phan</a> . <br></li></ol><br>  And there is <a href="https://github.com/exakat/exakat">Exakat</a> , which we have not tried. <br><br>  From the user's side, all three analyzers are the same: you install them (most likely through Composer), configure them, after which you can run an analysis of the entire project or a group of files.  As a rule, the analyzer is able to beautifully display the results in the console.  You can also output the results in JSON format and use them in CI. <br><br>  All three projects are now actively developing.  Their maintainers are very actively responding to issues on GitHub.  Often, on the first day after the creation of a ticket, at least they react to it (they comment or put a bug / enhancement tag).  Many bugs we found were fixed in a couple of days.  But I especially like the fact that the maintainers of projects actively communicate with each other, report bugs to each other, and send pull requests. <br><br>  We have implemented and use all three analyzers.  Everyone has their own nuances, their own bugs.  But using three analyzers at the same time makes it easier to understand where the real problem is and where the false positive is. <br><br><h2>  What analyzers can do </h2><br>  Analyzers have many common features, so first consider what they can do, and then we turn to the features of each of them. <br><br><h3>  Standard checks </h3><br>  Of course, the analyzers perform all standard code checks to ensure that: <br><br><ul><li>  the code does not contain syntax errors; <br></li><li>  all classes, methods, functions, constants exist; <br></li><li>  variables exist; <br></li><li>  in PHPDoc, hints are true. <br></li></ul><br>  In addition, the analyzers check the code for unused arguments and variables.  Many of these errors lead to real fatals in the code. <br><br>  At first glance it may seem that good programmers do not make such mistakes, but sometimes we are in a hurry, sometimes copy-paste, sometimes we are just inconsiderate.  And in such cases, these checks greatly save. <br><br><h3>  Data Type Checks </h3><br>  Of course, static analyzers also perform standard checks regarding data types.  If the code says that the function accepts, say, int, then the analyzer will check if there are any places where the object would be passed to this function.  With most analyzers, you can set the test strictness and imitate strict_types: check that no string or Boolean is passed to this function. <br><br>  In addition to standard checks, analyzers still know how much <br><br>  <b>Union types</b> <br><br>  All analyzers support the concept of Union types.  Suppose you have a type function: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_bool($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no;     } <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> (is_numeric($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;     } }</code> </pre> <br>  Its contents are not very important - the type of the input parameter <code>string|int|bool</code> is important.  That is, the variable <code>$yes_or_no</code> is either a string, or an integer, or <code>Boolean</code> . <br><br>  Using PHP, this type of function parameter cannot be described.  But in PHPDoc this is possible, and many editors (for example, PHPStorm) understand it. <br><br>  In static analyzers, this type is called the <b>union type</b> , and they are very good at checking such data types.  For example, if we would write the above function like this (without checking for <code>Boolean</code> ): <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_numeric($yes_or_no)) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;    } }</code> </pre> <br>  the analyzers would see that either a string or a Boolean can come to the strtoupper, and return an error ‚Äî you cannot pass a Boolean to the strtoupper. <br><br>  This type of check helps programmers correctly handle errors or situations where a function cannot return data.  We often write functions that can return some data or <code>null</code> : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// load()  null   \User $User = UserLoader::load($user_id); $User-&gt;getName();</span></span></code> </pre> <br>  In the case of such a code, the analyzer will tell you that the <code>$User</code> variable here can be equal to <code>null</code> and this code can lead to fatal. <br><br>  <b>Type false</b> <br><br>  PHP itself has quite a few functions that can return either a value or false.  If we wrote such a function, how would we document its type? <br><br><pre> <code class="php hljs">         <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> resource|bool */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fopen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{       ‚Ä¶ }</code> </pre> <br>  Formally, everything seems to be right here: fopen returns either resource or <code>false</code> (which is of type <code>Boolean</code> ).  But when we say that a function returns a data type, it means that it can return <b>any</b> value from the set belonging to that data type.  In our example for the analyzer, this means that <code>fopen()</code> can return <code>true</code> .  And, for example, in the case of such a code: <br><br><pre> <code class="php hljs">$fp = fopen(<span class="hljs-string"><span class="hljs-string">'some.file'</span></span>,<span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($fp === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } fwrite($fp, <span class="hljs-string"><span class="hljs-string">"some string"</span></span>);</code> </pre> <br>  analyzers would complain that <code>fwrite</code> accepts the first resource parameter, and we pass <code>bool</code> (because the analyzer sees that the variant with true is possible).  For this reason, all analyzers understand this ‚Äúartificial‚Äù data type as <code>false</code> , and in our example we can write <code>@return false|resource</code> .  PHPStorm also understands this type description. <br><br>  <b>Array shapes</b> <br><br>  Very often, arrays in PHP are used as a <code>record</code> type - a structure with a clear list of fields, where each field has its own type.  Of course, many programmers are already using classes for this.  But we have a lot of legacy code in Badoo, and arrays are actively used there.  It also happens that programmers are too lazy to start a separate class for a one-time structure, and in such places they also often use arrays. <br><br>  The problem with such arrays is that there is no clear description of this structure (a list of fields and their types) in the code.  Programmers can make mistakes while working with such a structure: forget the required fields or add the ‚Äúleft‚Äù keys, confusing the code even more. <br><br>  Analyzers allow description of such structures: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  In this example, we described an array with three string fields: <code>scheme, host</code> and <code>path</code> .  If inside the function we turn to another field, the analyzer will show an error. <br><br>  If you do not describe the types, the analyzers will try to "guess" the structure of the array, but, as practice shows, with our code, this is not very good for them.  :) <br><br>  This approach has one drawback.  Suppose you have a structure that is actively used in the code.  It is impossible to declare a pseudotype in one place and then use it everywhere.  You have to write PHPDoc with the array description everywhere in the code, which is very inconvenient, especially if there are many fields in the array.  It will also be problematic to edit this type afterwards (add and delete fields). <br><br>  <b>Description of key types of arrays</b> <br><br>  In PHP, array keys can be integers and strings.  Sometimes types can be important for static analysis (and for programmers).  Static analyzers allow you to describe array keys in PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;int, \User&gt; $users */</span></span> $users = UserLoaders::loadUsers($user_ids);</code> </pre> <br>  In this example, we used PHPDoc to add a hint that in the <code>$users</code> array, the keys are int-int integers, and the values ‚Äã‚Äãare objects of the <code>\User</code> class.  We could describe the type as \ User [].  This would tell the analyzer that there are objects of the <code>\User</code> class in the array, but nothing would tell us about the type of keys. <br><br>  PHPStorm supports this array description format starting from version 2018.3. <br><br>  <b>Your PHPDoc namespace</b> <br><br>  PHPStorm (and other editors) and static analyzers can understand PHPDoc differently.  For example, analyzers support this format: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  And PHPStorm doesn't understand it.  But we can write this: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@phan</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  In this case, both the analyzers and PHPStorm will be satisfied.  PHPStorm will use <code>@param</code> , and analyzers will use their PHPDoc tags. <br><br><h3>  Checks related to PHP features </h3><br>  This type of verification is best illustrated with an example. <br><br>  Do we all know what the <a href="http://php.net/explode">explode ()</a> function can return?  If you skim through the documentation, it seems that it returns an array.  But if we look more closely, we will see that it can also return false.  In fact, it may return both null and an error if you pass the wrong types to it, but passing the wrong value with the wrong data type is already an error, so this option does not interest us right now. <br><br>  Formally from the point of view of the analyzer, if the function can return false or an array, then, most likely, then the code should check for false.  But the explode () function returns false only if the separator (the first parameter) is an empty string.  Often, it is explicitly registered in the code, and analyzers can check that it is not empty, which means that in this place, the explode () function accurately returns an array and does not need to check for false. <br><br>  PHP doesn‚Äôt have many of these features.  Analyzers gradually add relevant checks or improve them, and we, programmers, no longer need to memorize all these features. <br><br>  We proceed to the description of specific analyzers. <br><br><h2>  PHPStan </h2><br>  Development of a certain Ond≈ôej Mirtes from the Czech Republic.  Actively developed since the end of 2016. <br><br>  To start using PHPStan, you need: <br><br><ol><li>  Install it (the easiest way to do this is through Composer). <br></li><li>  (optional) Configure. <br></li><li>  In the simplest case, just run: <br></li></ol><br> <code>vendor/bin/phpstan analyse ./src</code> <br> <br>  (instead of <code>src</code> may be a list of specific files that you want to check). <br><br>  PHPStan will read the PHP code from the transferred files.  If he meets unknown classes, he will try to load them with autoload and through reflection to understand their interface.  You can also transfer the path to the <code>Bootstrap</code> file through which you configure the autoload and include some additional files to simplify the PHPStan analysis. <br><br>  Key features: <br><br><ol><li>  You can not analyze the entire code base, but only a part - PHPStan will try to load unknown classes with autoload. <br></li><li>  If for some reason some of your classes are not in the autoload, PHPStan will not be able to find them and will give an error. <br></li><li>  If you actively use magic methods through <code>__call / __get / __set</code> , then you can write a plugin for PHPStan.  There are already plugins for symfony, Doctrine, Laravel, Mockery and others. <br></li><li>  In fact, PHPStan performs autoloads not only for unknown classes, but in general for all.  We have a lot of old code written before the appearance of anonymous classes, when we create a class in one file, and then we instantiate it right away, and maybe even call some methods.  Autoload ( <code>include</code> ) such files leads to errors, because the code is not executed in a normal environment. <br></li><li>  Configs in <a href="https://ne-on.org/">neon</a> format (never heard of this format anywhere else). <br></li><li>  No support for their PHPDoc tags like <code>@phpstan-var, @phpstan-return</code> , etc. <br></li></ol><br>  Another feature is that errors have text, but there is no type.  That is, an error text is returned to you, for example: <br><br><ul><li> <code>Method \SomeClass::getAge() should return int but returns int|null</code> <br> </li><li> <code>Method \SomeOtherClass::getName() should return string but returns string|null</code> <br> </li></ul><br>  In this example, both errors, in general, are about the same: the method must return one type, but in reality it returns the other.  But the texts of errors are different, although similar.  Therefore, if you want to filter out any errors in PHPStan, do it only through regular expressions. <br><br>  For comparison, in other analyzers errors have a type.  For example, in Phan, such an error has the type <code>PhanPossiblyNullTypeReturn</code> , and you can specify in the config that no verification is required for such errors.  Also, having the type of error, you can, for example, easily collect statistics on errors. <br><br>  Since we do not use Laravel, Symfony, Doctrine and similar solutions, and we rarely use magical methods in the code, the main feature of PHPStan was unclaimed.  ; (Besides, due to the fact that PHPStan includes <b>all</b> checked classes, sometimes its analysis simply does not work on our code base. <br><br>  Nevertheless, PHPStan remains useful for us: <br><br><ul><li>  If you need to check several files, PHPStan is noticeably faster than Phan and a little (20-50%) faster than Psalm. <br></li><li>  PHPStan reports make it easier for us to find <code>false-positive</code> in other analyzers.  Usually, if there is some obvious <code>fatal</code> in the code, it is shown by all analyzers (or at least two out of three). <br></li></ul><br><br>  <b>Update:</b> <br>  PHPStan author Ond≈ôej Mirtes also read our article and <a href="https://twitter.com/OndrejMirtes/status/1052226015748067328">suggested</a> that PhpStan, like Psalm, has a sandbox site: <a href="https://phpstan.org/">https://phpstan.org/</a> .  This is very convenient for bug reports: you reproduce the error in and give a link in GitHub. <br><br><h2>  Phan </h2><br>  Developed by Etsy.  The first commits are from Rasmus Lerdorf. <br><br>  Of the three considered, Phan is the only <b>true</b> static analyzer (in the sense that it does not execute any of your files ‚Äî it parses the <b>entire</b> code base and then analyzes what you say).  Even for analyzing several files in our code base, it takes about 6 GB of RAM, and this process takes four to five minutes.  But a complete analysis of the entire code base takes about six to seven minutes.  For comparison, Psalm analyzes it for several tens of minutes.  And from PHPStan, we could not achieve a complete analysis of the entire code base due to the fact that it includes classes. <br><br>  The impression of Phan is twofold.  On the one hand, it is the most qualitative and stable analyzer, it finds a lot and the least problems with it when it is necessary to analyze the entire code base.  On the other hand, it has two unpleasant features. <br><br>  Under the hood, Phan uses the php-ast extension.  Apparently, this is one of the reasons that the analysis of the entire code base is relatively fast.  But php-ast shows the internal representation of the AST tree as it is displayed in PHP itself.  And in PHP itself, the AST tree does not contain information about comments that are located inside the function.  That is, if you wrote something like: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $type */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($type)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \My\Object $obj **/</span></span>   $obj = MyFactory::createObjectByType($type);   ‚Ä¶ }</code> </pre> <br>  then inside the AST tree there is information about the external PHPDoc for the <code>doSomething()</code> function, but there is no PHPDoc hint information that is inside the function.  And, accordingly, Phan also knows nothing about her.  This is the most common cause of <code>false-positive</code> in Phan.  There are <a href="https://github.com/phan/phan/wiki/Annotating-Your-Source-Code">some recommendations</a> on how to insert hints (via strings or assertions), but, unfortunately, they are very different from what our programmers are used to.  We partially solved this problem by writing a plugin for Phan.  But plugins are discussed below. <br><br>  The second unpleasant feature is that Phan poorly analyzes the properties of objects.  Here is an example: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|null */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $a = null)</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a = $a; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a &amp;&amp; strpos(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) === <span class="hljs-number"><span class="hljs-number">0</span></span>) {          var_dump(<span class="hljs-string"><span class="hljs-string">"test1"</span></span>);      } } }</code> </pre> <br>  In this example, Phan will tell you that in strpos you can pass null.  You can learn more about this problem here: <a href="https://github.com/phan/phan/issues/204">https://github.com/phan/phan/issues/204</a> . <br><br>  Summary.  Despite some difficulties, Phan is a very cool and useful development.  In addition to these two types of <code>false-positive</code> , it almost does not make mistakes, or makes mistakes, but on some really complex code.  We also liked the fact that the config is in a PHP file - this gives a certain flexibility.  Phan can also work as a language server, but we didn‚Äôt use this feature, as PHPStorm is enough for us. <br><br><h3>  Plugins </h3><br>  Phan has a well-developed API for plug-in development.  You can add your own checks, improve type inference for your code.  This API <a href="https://github.com/phan/phan/wiki/Writing-Plugins-for-Phan">has documentation</a> , but it‚Äôs especially cool that there are already ready-made working plugins inside that can be used as examples. <br><br>  We managed to write two plugins.  The first was intended for a one-time check.  We wanted to evaluate how our code is ready for PHP 7.3 (in particular, to find out if there are any <code>case-insensitive</code> constants in it).  We were almost sure that there were no such constants, but in 12 years anything could have happened - it should have been checked.  And we wrote a plugin for Phan that would curse if the third parameter was used in <code>define()</code> . <br><br><div class="spoiler">  <b class="spoiler_title">The plugin is very simple.</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span>(strict_types=<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">AST</span></span>\<span class="hljs-title"><span class="hljs-title">ContextNode</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">CodeBase</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Context</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Element</span></span>\<span class="hljs-title"><span class="hljs-title">Func</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>\<span class="hljs-title"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">ast</span></span>\<span class="hljs-title"><span class="hljs-title">Node</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefineThirdParamTrue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PluginV2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAnalyzeFunctionCallClosures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeBase $code_base)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{   $define_callback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       CodeBase $code_base,                  Context $context,                  Func $function,                  array $args    )</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($args) &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }       <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emitIssue(       $code_base,      $context,      <span class="hljs-string"><span class="hljs-string">'PhanDefineCaseInsensitiv'</span></span>,      <span class="hljs-string"><span class="hljs-string">'Define with 3 arguments'</span></span>,      []      );    };    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [          <span class="hljs-string"><span class="hljs-string">'define'</span></span> =&gt; $define_callback,    ]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefineThirdParamTrue();</code> </pre> <br></div></div><br><br>  In Phan, different plugins can be hung on different events.  In particular, <code>AnalyzeFunctionCallCapability</code> plug- <code>AnalyzeFunctionCallCapability</code> work when a function call is analyzed.  In this plugin, we made it so that when we call the <code>define()</code> function, our anonymous function is called, which checks that <code>define()</code> no more than two arguments.  Then we just started Phan, found all the places where <code>define()</code> was called with three arguments, and made sure that we don't have <code>case-insensitive-</code> . <br><br>  Using the plugin, we also partially solved the <code>false-positive</code> problem, when Phan does not see PHPDoc hints inside the code. <br><br>  We often use factory methods that take a constant as input and create an object from it.  Often the code looks like this: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Objects\Controllers\My $Object */</span></span> $Object = \Objects\Factory::create(\Objects\Config::MY_CONTROLLER);</code> </pre> <br>  Phan does not understand such PHPDoc hints, but in this code the class of the object can be obtained from the name of a constant passed to the <code>create()</code> method.  Phan allows you to write a plugin that is triggered when analyzing the return value of a function.  And using this plugin, you can tell the analyzer what type of function the function returns in this call. <br><br>  An example of this plugin is more complicated.  But in the Phan code there is a good example in <code>vendor/phan/phan/src/Phan/Plugin/Internal/DependentReturnTypeOverridePlugin.php.</code> <br><br>  In general, we are very pleased with the Phan analyzer.  Listed above <code>false-positive</code> we partially (in simple cases, with a simple code) learned to filter.  After that, Phan became an almost standard analyzer.  However, the need to immediately parse the entire code base (time and a lot of memory) still complicates the process of its implementation. <br><br><h2>  Psalm </h2><br>  Psalm is a Vimeo development.  Honestly, I didn‚Äôt even know that Vimeo uses PHP until I saw Psalm. <br><br>  This analyzer is the youngest of our troika.  When I read the news that Vimeo released Psalm, I was at a loss: ‚ÄúWhy invest resources in Psalm if you already have Phan and PHPStan?‚Äù But it turned out that Psalm has its own useful features. <br><br>  Psalm followed in the footsteps of PHPStan: it can also be given a list of files for analysis, and it will analyze them, and connect the missing classes with an autoload.  At the same time, it <b>only</b> includes non-found classes, and the files that we are asked to analyze will not include (this is the difference from PHPStan).  The config is stored in an XML file (for us, this is rather a minus, but not very critical). <br><br>  Psalm has a sandbox <a href="https://getpsalm.org/">site</a> where you can write PHP code and analyze it.  This is very convenient for bug reports: you reproduce the error on the site and give a link in GitHub.  And, by the way, the site describes all possible types of errors.  For comparison: there are no types of errors in PHPStan, but they are in Phan, but there is no single list that could be found. <br><br>  We also liked that when displaying errors, Psalm immediately shows the lines of code where they were found.  This <b>greatly</b> simplifies the reading of reports. <br><br>  But perhaps the most interesting feature of Psalm are its custom PHPDoc tags, which allow for improved analysis (especially the definition of types).  We list the most interesting of them. <br><br><h3>  @ psalm-ignore-nullable-return </h3><br>  It sometimes happens that a method can formally return <code>null</code> , but the code is already organized in such a way that it never happens.  In this case, it is very convenient that you can add this PHPDoc hint to the method / function - and Psalm will assume that <code>null</code> not returned. <br><br>  A similar hint also exists for false: <code>@psalm-ignore-falsable-return</code> . <br><br><h3>  Types for closure </h3><br>  If you have ever been interested in functional programming, you might have noticed that there often a function can return another function or take a function as a parameter.  In PHP, this style can be very confusing for your colleagues, and one of the reasons is that PHP does not have standards for documenting such functions.  For example: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  How can a programmer understand which interface the function has in the second parameter?  What parameters should it take?  What should she return? <br><br>  Psalm supports syntax for describing functions in PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $ar * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param Closure(int):bool $func */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  With such a description it is already clear that in <code>my_filter</code> you need to pass an anonymous function, which takes int as input and returns bool.  And, of course, Psalm will check that you have exactly such a function here in the code. <br><br><h3>  Enums </h3><br>  Suppose you have a function that accepts a string parameter, and only certain strings can be passed there: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{     $yes_or_no = strtolower($yes_or_no)     <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>($yes_or_no)  {           <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'yes'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;          <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'no'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;           <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>:                <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \InvalidArgumentException(‚Ä¶);     } }</code> </pre><br>  Psalm allows you to describe the parameter of this function like this: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param 'Yes'|'No' $yes_or_no **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  In this case, the Psalm will try to understand what specific values ‚Äã‚Äãare passed to this function, and give errors if there are values ‚Äã‚Äãother than <code>Yes</code> and <code>No</code> <br><br>  Read more about enum ah <a href="https://getpsalm.org/docs/typing_in_psalm/">here</a> . <br><br><h3>  Type aliases </h3><br>  Above, when describing <code>array shapes</code> I mentioned that, although analyzers allow us to describe the structure of arrays, it is not very convenient to use this, since the description of the array has to be copied in different places.  The correct solution, of course, is to use classes instead of arrays.  But in the case of multi-year legacy this is not always possible. <br><br>   ,      ,    ,    : <br><br><ul><li> ; <br></li><li> closure; <br></li><li> union- (,       ); <br></li><li> enum. <br></li></ul><br>   ,      ,    PHPDoc    , ,  .   Psalm      .    alias      PHPDoc   <code>alias</code> .  ,  :      PHP-.      . ,   Psalm. <br><br><h3> Generics aka templates </h3><br>     . ,     : <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $x; }</code> </pre> <br>     ?      ?   ? <br><br> , ,    , ‚Äî <code>mixed</code> ,             . <br><br>     <code>mixed</code> ‚Äî  .  ,            .    ,   <code>identity()</code>  /  ,    :     ,   .       -.  ,   : <br><br><pre> <code class="php hljs">$i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int $y = identity($i);</span></span></code> </pre> <br>       <code>(int)</code> ,  ,      <code>$y</code> ( <code>int</code> ). <br><br>       ?  Psalm     PHPDoc-: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param T $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-return T */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ $return $x; }</code> </pre> <br>   templates   Psalm   ,  /     . <br><br>  Psalm      templates: <br><br> ‚Äî <a href="https://github.com/vimeo/psalm/blob/master/src/Psalm/Stubs/CoreGenericFunctions.php">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericFunctions.php</a> ; <br> ‚Äî <a href="https://github.com/vimeo/psalm/blob/master/src/Psalm/Stubs/CoreGenericClasses.php">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericClasses.php</a> . <br><br>      Phan,      : <a href="https://github.com/phan/phan/wiki/Generic-Types">https://github.com/phan/phan/wiki/Generic-Types</a> . <br><br>  ,  Psalm  . ,    ¬´¬ª              .   ,  Psalm    ,    ,       Phan  PHPStan.     . <br><br><h2>    PHPStorm </h2><br>      :          ,   .    ,      ,    . <br><br>             .     Phan,    language server.    PHPStorm, ,   . <br><br> ,  ,  PHPStorm     ( ),       .         ‚Äî Php Inspections (EA Extended).     ‚Äî   ,   ,         .  ,      . ,      scopes     -   scopes. <br><br>     ,  <a href="https://github.com/klesun/deep-assoc-completion">deep-assoc-completion</a> .         . <br><br><h1>    Badoo </h1><br>     ? <br><br>       ,         . <br><br>     ,   .  ,     ,    <code>git diff</code>      / ,       ,     () .       ,    . <br><br> ,     :      -    <code>git diff</code> .     .             ,    .         . , ,  ,          ,    . <br><br>     ,     ,       : <br><br><img src="https://habrastorage.org/webt/zj/e2/rt/zje2rtxhy1nkwsamex4umguv4yw.png"><br><br>           <code>false-positive</code> . ,  ,   Phan        ,   ,     . ,   -    Phan      ,     ,      . <br><br><h1>     QA </h1><br>        : <br><br><ul><li>     ; <br></li><li>    <a href="https://habr.com/company/badoo/blog/354856/">code review</a> ; <br></li><li>    <a href="https://habr.com/company/badoo/blog/334034/"> </a> . <br></li></ul><br><br>   ‚Äî ,  ,      ,     .      : <br><br><ul><li>    100%  (   ,        ); <br></li><li>     ,      code review; <br></li><li>      ,        . <br></li></ul><br>         <code>strict types</code> .          ,  <code>strict types</code> ,    : <br><br><ul><li>     ,     <code>strict types</code> ,   ; <br></li><li>     ,     (,    ,        ); <br></li><li>        ,    PHP (,   <code>union types</code> ,    PHP); <br></li><li>       <code>strict types</code> ,        . <br></li></ul><br><h1>  :   </h1><br>  ,        .  There are several reasons for this. <br><br> -,     , ,      -  ,    . <br><br> -,     ,     ‚Äî  , ,     PHPDoc.        ‚Äî   . <br><br> -,     .  ,     -  ,            PHPDoc.  :) <br><br>  ,  ,     .    ,      . </div><p>Source: <a href="https://habr.com/ru/post/426605/">https://habr.com/ru/post/426605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426591/index.html">Master posture: stay alive</a></li>
<li><a href="../426593/index.html">DJI Phantom 4 RTK: New Generation Cartography</a></li>
<li><a href="../426595/index.html">Richard Hamming. "Non-existent chapter": How do we know what we know (1-10 minutes out of 40)</a></li>
<li><a href="../426597/index.html">Madrobots at IFA 2018. Part 2 - smart projectors: from XGIMI to Anker</a></li>
<li><a href="../426603/index.html">Spinning the spiral: math and hallucinations</a></li>
<li><a href="../426609/index.html">In Office 365 and other MS products will add voice I / O mode for dyslexics</a></li>
<li><a href="../426611/index.html">Integration with SAP ERP, for example with Django-python, using the oData (rest) protocol</a></li>
<li><a href="../426613/index.html">Do not let the 3D printer lazy</a></li>
<li><a href="../426615/index.html">We write CLI on NodeJS</a></li>
<li><a href="../426617/index.html">License to drive a car, or why applications should be Single-Activity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>