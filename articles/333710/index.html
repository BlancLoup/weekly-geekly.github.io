<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>K-sort: a new algorithm that exceeds the pyramid when n <= 7 000 000</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator. Translation of the 2011 article (amendment, sent on July 19, 2011) to arxiv.org on the statistical analysis of a quick sort modif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>K-sort: a new algorithm that exceeds the pyramid when n <= 7 000 000</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator.</i>  <i>Translation <a href="https://arxiv.org/ftp/arxiv/papers/1107/1107.3622.pdf">of the 2011 article (amendment, sent on July 19, 2011) to arxiv.org</a> on the statistical analysis of a quick sort modification.</i>  <i>Surely there are people who use the described version intuitively.</i>  <i>Here is the mathematical justification of efficiency with n &lt;= 7 000 000</i> <br><br><h4>  <b>Briefly about the main thing</b> </h4><br><img src="https://habrastorage.org/web/c43/613/e78/c43613e7890a4ca7b29250837e0d41bb.jpg"><br><br>  <b>Keywords</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Internal sorting;</i>  <i>Uniform distribution;</i>  <i>Medium temporal complexity;</i>  <i>Statistical analysis;</i>  <i>Statistical evaluation</i> <br><a name="habracut"></a><br>  Sundarajan and Chakraborty [10] presented a new version of quick sorting that removes exchanges.  Crazat [1] noted that the algorithm competes well with some other versions of quick sorting.  However, it uses an auxiliary array, increasing spatial complexity.  Here we provide the second version where we removed the auxiliary array.  This version, which we call K-sort, orders the elements faster than the pyramid with a significant array size (n &lt;= 7 000 000) for the input data of the uniform distribution U [0, 1]. <br><br>  <b>1. Introduction</b> <br><br>  There are several internal sorting methods (where all items can be stored in main memory).  The simplest algorithms, such as bubble sorting, usually take O (n <sup>2</sup> ) time ordering n objects and are only useful for small sets.  One of the most popular algorithms for large sets is Quick sort, which occupies O (n * log <sub>2</sub> n) on average and O (n <sup>2</sup> ) in the worst case.  Read more about sorting algorithms in Knut [2]. <br><br>  Sundarajan and Chakraborty [10] presented a new version of quick sorting that removes exchanges.  Crazeat [1] found that this algorithm competes well with some other versions of Quick sort, such as SedgewickFast, Bsort and Singleton sort for n [3000..200 000].  Since the comparison algorithm predominates over exchanges, deleting exchanges does not make the complexity of this algorithm different from the complexity of the classical quick sort.  In other words, our algorithm has an average and worst complexity, comparable to Quick sort, that is, O (n * log <sub>2</sub> n) and O (n <sup>2</sup> ), respectively, which is also confirmed by Crazat [1].  However, it uses an auxiliary array, thereby increasing spatial complexity.  Here we offer the second improved version of our sort, which we call K-sort, where the auxiliary array is removed.  It was found that the sorting of elements with K-sort is faster than the pyramid when the array size is significant (n &lt;= 7 000 000) of uniformly distributed input U [0, 1]. <br><br>  <b>1.1 K-sort</b> <br><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">Step</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>: Initialize the first element of the <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> as the key element <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i as <span class="hljs-built_in"><span class="hljs-built_in">left</span></span>, j as (<span class="hljs-built_in"><span class="hljs-built_in">right</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>), k = p where p <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">left</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>). <span class="hljs-keyword"><span class="hljs-keyword">Step</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>: Repeat <span class="hljs-keyword"><span class="hljs-keyword">step</span></span><span class="hljs-number"><span class="hljs-number">-3</span></span> till the condition (ji) &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> satisfied. <span class="hljs-keyword"><span class="hljs-keyword">Step</span></span><span class="hljs-number"><span class="hljs-number">-3</span></span>: Compare a[p] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> key element. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> key &lt;= a[p] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Step</span></span><span class="hljs-number"><span class="hljs-number">-3.1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( p <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> equal <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> equal <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">right</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> a[j] = a[p] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( j equals (<span class="hljs-built_in"><span class="hljs-built_in">right</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> temp = a[p] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> flag = <span class="hljs-number"><span class="hljs-number">1</span></span> decrease j by <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> assign p = j <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the comparison of <span class="hljs-keyword"><span class="hljs-keyword">step</span></span><span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied ie <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key &gt; a[p] ) <span class="hljs-keyword"><span class="hljs-keyword">Step</span></span><span class="hljs-number"><span class="hljs-number">-3.2</span></span>: assign a[i] = a[p] , increase i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> k by <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> p = k <span class="hljs-keyword"><span class="hljs-keyword">Step</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> a[i] = key <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag = = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> assign a[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = temp <span class="hljs-keyword"><span class="hljs-keyword">Step</span></span><span class="hljs-number"><span class="hljs-number">-5</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">left</span></span> &lt; i - <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Split</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> into <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> from start <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> i-th element <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> repeat steps <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Step</span></span><span class="hljs-number"><span class="hljs-number">-6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">left</span></span> &gt; i + <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Split</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> into <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> from i-th element <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> repeat steps <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span></code> </pre> <br><br><h4>  Demonstration </h4><br><img src="https://habrastorage.org/web/314/89b/2fc/31489b2fcf874635bd72b01f7b5cdc9b.png"><br><br>  Note.  If the auxiliary array has one value, it does not need to be processed. <br><br>  <b>2. Empirical (average time complexity)</b> <br><br>  A computer experiment is a series of code runs for various inputs (see Saks [9]).  Conducting computer experiments at <b>Borland International Turbo 'C ++' 5.02</b> , we could compare the average sorting time in seconds (the average took over 500 readings) for different values ‚Äã‚Äãof n for K-sort and Heap.  Using the Monte Carlo simulation (see Kennedy and Gentle [7]), an array of size n was filled with independent continuous uniform U [0, 1] variations, and copied into another array.  These arrays were sorted by comparable algorithms.  Table 1 and Fig.  1 shows empirical results. <br><br><img src="https://habrastorage.org/web/d25/564/498/d25564498e324acc92807dcafcab4810.png"><br><br><img src="https://habrastorage.org/web/c43/613/e78/c43613e7890a4ca7b29250837e0d41bb.jpg"><br><br>  <i>Fig.</i>  <i>1 Comparison Chart</i> <br><br>  The observed average times from the continuous uniform distribution of U (0,1) for the considered sorts are presented in table 1. Figure 1, together with table 1, show a comparison of the algorithms. <br><br>  The points on the graph constructed from Table 1 show that the average execution time for K-sorting is less than that of the heap sort when the size of the array is less than or equal to 7,000,000 elements, and above this range Heapsort runs faster. <br><br>  <b>3. Statistical analysis of empirical results using Minitab version 15</b> <b><br></b> <br>  <b>3.1.</b>  <b>Analysis for K-sort: Regression of the average sorting time y (K) by n * log 2 (n) and n</b> <b><br></b> <br><br><img src="https://habrastorage.org/web/a6b/6c7/b6a/a6b6c7b6a3f848159e1268fe11e42723.png"><br><img src="https://habrastorage.org/web/629/6d8/a6c/6296d8a6c65448768787e423a044cf99.png"><br>  <i>R stands for observation with large standardized residues.</i> <i><br></i>  <i>Fig.</i>  <i>2.1-2.4 shows a visual result of some additional model tests.</i> <br><br><img src="https://habrastorage.org/web/d4f/569/1ba/d4f5691ba0224574852f38d0a9f5268e.png"><br><br><img src="https://habrastorage.org/web/f27/05a/6bc/f2705a6bc840494eb4cb9f4bee79d4a3.png"><br><br><img src="https://habrastorage.org/web/5d7/3bd/571/5d73bd5715e2451cb6d66ab4920f4414.png"><br><br>  <b>4. Discussion part</b> <br><br>  It is easy to see that the sum of squares contributed by n * log (n) to the regression model in both the K-sort sort and Heap is significant compared to the sum obtained by n.  Recall that both algorithms have an average complexity of O (n * log <sub>2</sub> n).  Thus, the experimental results confirm the theory.  We saved the n-term in the model, because looking at the mathematical operator, resulting in O (nlog <sub>2</sub> n) complexity in the Quick sort and Heap sort, implies the n-term (see Knuth [2]). <br><br>  The comparative regression equation for the average case is obtained simply by subtracting y (H) from y (K). <br><br>  We have, y (K) - y (H) = 0.52586 + 0.00000035 n * log2 (n) - 0.00000792 n ‚Ä¶‚Ä¶ .. (3) <br><br>  The advantage of equations (1), (2) and (3) is that we can predict the average execution time of both sorting algorithms, as well as their difference even for huge values ‚Äã‚Äãof n, which are cumbersome to perform.  Such a ‚Äúcheap prediction‚Äù is the motto in computer experiments and allows us to carry out stochastic modeling even for non-random data.  Another advantage is that you only need to know the size of the input to make a prediction.  That is, the entire input (for which the answer is fixed) is not required.  Thus, the prediction through the stochastic model is not only cheap, but also more efficient (Sachs, [9]). <br><br>  It is important to note that when we directly work on the program execution time, we actually calculate the statistical estimate in a finite range (a computer experiment cannot be performed to enter an infinite size).  Statistical evaluation differs from mathematical evaluation in the sense that, unlike mathematical evaluation, it weighs and does not accurately calculate computational operations and, as such, is able to mix different operations into conceptual evaluation, while mathematical complexity is specific to the operation.  Here, the operation time is taken as its weight.  For a general discussion of statistical evaluation, including formal definition and other properties, see Chakraborty and Subic [5].  See also Chakraborty, Modi and Panigraha [4] to understand why statistical evaluation is the ideal boundary for parallel computations.  The assumption of statistical evaluation is obtained by running computer experiments where numerical values ‚Äã‚Äãare assigned to weights in a finite range.  This means that the credibility of the bound estimate depends on the proper development and analysis of our computer experiment.  Related literature on computer experiments with other applications, such as VLSI design, burning, heat transfer, etc., can be found in (Fang, Li and Sugyanto, [3]).  See also the review (Chakraborty [6]). <br><br>  <b>5. Conclusion and suggestions for future work</b> <br><br>  K-sort is obviously faster than Heap for the number of sorting elements up to 7,000,000, although both algorithms have the same order of complexity O (n * log <sub>2</sub> n) in the average case.  Future work includes the study of parameterized complexity (Mahmoud, [8]) for this improved version.  As a final comment, we highly recommend K-sort for at least n &lt;= 7,000,000. <br><br>  Nevertheless, we agree to choose Heap-sort in the worst case because it supports the complexity of O (n * log <sub>2</sub> n) even in the worst case, although it is more difficult to program it. <br><br>  <a href="http://www.sapub.org/global/showpaperpdf.aspx%3Fdoi%3D10.5923/j.algorithms.20120101.01"><b>NB Continuation of work, 2012</b></a> <br><br><div class="spoiler">  <b class="spoiler_title">Bibliography</b> <div class="spoiler_text">  [1] Khreisat, L., A QuickSort A Historical Perspective and International Journal of Computer Science, Network Security, Vol. 7 No.12, December 2007, p.  54-65 <br><br>  [2] Knuth, DE, The Art of Computer Programming, Vol.  3: Sorting and Searching, Addison <br>  Wesely (Pearson Education Reprint), 2000 <br><br>  [3] Fang, KT, Li, R. and Sudjianto, A., Design and Modeling of Computer Experiments <br>  Chapman and Hall, 2006 <br><br>  [4] S. Chakraborty, S., Modi, DN and Panigrahi, S., Will the Weight-based Statistical Bounds <br>  Revolutionize the IT ?, International Journal of Computational Cognition, Vol.  7 (3), 2009, 16-22 <br><br>  [5] Chakraborty, S. and Sourabh, SK, A Computer Experiment Oriented Approach to <br>  Algorithmic Complexity, Lambert Academic Publishing, 2010 <br><br>  [6] Chakraborty, S., Review of the book of Experiments authored by KT Fang, R. Li and A. Sudjianto, Chapman and Hall, 2006, published in Computing Reviews, Feb 12, 2008, <br>  <a href="http://www.reviews.com/widgets/reviewer.cfm%3Freviewer_id%3D123180%26count%3D26">www.reviews.com/widgets/reviewer.cfm?reviewer_id=123180&amp;count=26</a> <br><br>  [7] Kennedy, W. and Gentle, J., Statistical Computing, Marcel Dekker Inc., 1980 <br><br>  [8] Mahmoud, H., Sorting: A Distribution Theory, John Wiley and Sons, 2000 <br><br>  [9] Sacks, J., Weltch, W., Mitchel, T. and Wynn, H., Design and Analysis of Computer Experiments, Statistical Science 4 (4), 1989 <br><br>  [10] Sundararajan, KK and Chakraborty, S., A New Sorting Algorithm, Applied Math.  and Compu., Vol.  188 (1), 2007, p.  1037-1041 </div></div></div><p>Source: <a href="https://habr.com/ru/post/333710/">https://habr.com/ru/post/333710/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333698/index.html">Features of a great product manager</a></li>
<li><a href="../333702/index.html">Generics and Converters in Nim</a></li>
<li><a href="../333704/index.html">Corporate governance: how is a company legally built?</a></li>
<li><a href="../333706/index.html">Come on, girls! Ada lovelace dedicated</a></li>
<li><a href="../333708/index.html">3D Blockchain. Face Proof (PoF)</a></li>
<li><a href="../333712/index.html">What's new in Swift 4.0</a></li>
<li><a href="../333714/index.html">We do applications with search on Go</a></li>
<li><a href="../333716/index.html">Creating Angular 2+ components with the ability to switch themes</a></li>
<li><a href="../333718/index.html">Creating a GLSL smoke shader</a></li>
<li><a href="../333722/index.html">Current activity around MIPSfpga and not only</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>