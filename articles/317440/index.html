<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using the SchedulableObject pattern to separate business logic into a separate thread</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The mobile application interface is the face of the product. The more responsive the interface, the more joy the product brings. However, satisfaction...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using the SchedulableObject pattern to separate business logic into a separate thread</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/fcc/138/bff/fcc138bff4954a92ad408a51e7170205.jpg"><br><br>  The mobile application interface is the face of the product.  The more responsive the interface, the more joy the product brings.  However, satisfaction with the use of the application depends primarily on the scope of its functions.  As the number and complexity of tasks increase, they require more and more time.  If the application architecture assumes that all of them are executed in the main thread, then business logic tasks begin to compete over time with interface rendering tasks.  With this approach, sooner or later a script is necessarily located, the execution of which leads to the application sticking.  To combat this scourge, there are three fundamentally different approaches: <br><br><ol><li>  Optimization of algorithms and data structures involved in the execution of the problem scenario. </li><li>  Removal of the problem scenario from the main thread. </li><li>  Removal from the main stream of all functions of the application, except for the actual rendering of the user interface. </li></ol><br>  The SchedulableObject pattern allows you to accurately implement the third script.  Under the cat are considered parts of it with examples of implementation on Swift, as well as advantages and disadvantages compared to the first two approaches. <br><a name="habracut"></a><br><h1>  Formulation of the problem </h1><br>  It is considered to be a smooth interface that can be updated at least 60 times per second.  These figures can be viewed from the other side: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/0a1/7f7/422/0a17f74222f24d959c8ec82204f286dc.png"><br><br>  It turns out that each event-processing cycle should have time to complete in 16.7 ms.  Suppose a user observes a window that can be rendered in 10 ms.  This means that all business logic tasks should have time to be completed in 6.7 ms. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5ea/df7/040/5eadf704065c43898802ea1fe254293d.png"></div>  Consider as an example the business logic of adding a file to the Cloud.  It consists of many stages, the essence of which in the context of this article does not interest us. <br><br><img src="https://habrastorage.org/files/1b2/af5/8ae/1b2af58ae97a4b7b8e4704c7a019c29a.png"><br><br>  It is important that all of them together take 2.6 ms.  Dividing the maximum time allotted for business logic to work while adding one file, we get 3. So, if the application wants to remain responsive when working out this scenario, it cannot add more than three files at a time.  Fortunately for the user, but unfortunately for the developers, there are cases in the Cloud application when you need to add more than three files at a time. <br><br><img src="https://habrastorage.org/files/841/e92/06a/841e9206a94c4e16b3b4c3def8421424.png"><br><br>  The screenshots above show some of them: <br><br><ol><li>  Multiple selection of files from the system gallery of the device. </li><li>  Automatic download of new files from the gallery. </li></ol><br>  At the moment, to avoid long-term application hangs, the speed of adding files to the download queue by the autoload service is artificially limited by the shameful constants method.  Here are two of them: <br><br><pre><code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//     static uint const kMRCCameraUploaderBatchSize = 1000; static NSTimeInterval const kMRCCameraUploaderBatchDelaySec = 5;</span></span></code> </pre> <br>  Their semantics is as follows: according to the results of scanning the gallery for new photos, the service should add them to the download queue in batches of no more than 1000 pieces each with an interval of 5 seconds.  But even with this limitation, we have a hang of 1000 * 2.6 ms = 2.6 s every 5 s, which is bound to upset.  Artificial restriction of business logic bandwidth - this is the very symptom that indicates the need to look in the direction of the SchedulableObject pattern. <br><br><h1>  SchedulableObject vs algorithms </h1><br>  Why not solve the problem by optimizing algorithms and data structures?  I admit, with a perseverance worthy of a better application, when everything gets really bad, we optimize certain steps involved in adding photos to the download queue.  However, the potential of these efforts is deliberately limited.  Yes, you can twist something and increase the size of the pack to 2 or even 4 thousand pieces, but this does not solve the problem fundamentally.  First, for any optimization there will necessarily be such a data stream, which levels all its effect.  In relation to the Cloud, this is a user with 20 thousand photos and more in the gallery.  Secondly, the management will definitely want to make your script even more intelligent, which will inevitably lead to a complication of its logic, you will have to optimize the previously performed optimization.  Thirdly, loading is not the only scenario whose bandwidth is artificially limited.  The expansion of bottlenecks in an algorithmic way will require an individual approach to each scenario.  Worse, the quality attribute ‚ÄúPerformance‚Äù is the antagonist of another, more important, in my opinion, called ‚ÄúSustainability‚Äù.  Often, to achieve the required performance, you must either go for all sorts of tricks in the algorithms, or choose more complex data structures, or both.  Any choice will not delay negatively affect either the public interface of classes, or at least their internal implementation. <br><br><h1>  SchedulableObject vs selection script in a separate thread </h1><br>  Let us consider the shortcomings of the approach, in which for each scenario its own decision is made about the expediency of separating it into a separate stream.  To this end, we will follow the evolution of the architecture of some business applications, where we will be guided by this principle to solve the problem of ‚Äúbrakes‚Äù.  Since there are particularly interesting threads (threads) in the context of which the methods of objects are called, each of them will be coded by its own color.  Initially, when heavy scripts have not yet appeared, everything happens in the main thread, so all links and entities have the same blue color. <br><br><img src="https://habrastorage.org/files/627/0b3/3a6/6270b33a6b4d4a27875d44e7dea01c44.png"><br><br>  Let us assume that a scenario has appeared, during the development of which one of the objects began to consume too much time.  Because of this, the responsiveness of the user interface is starting to suffer.  Denote the problem data flow (data flow) bold arrows. <br><br><img src="https://habrastorage.org/files/244/b61/437/244b614378cb4b2aa513d7776e131689.png"><br><br>  Without refactoring of a resource-intensive class, it is impossible to make calls to it in a separate red stream. <br><br><img src="https://habrastorage.org/files/1cd/3c0/8e1/1cd3c08e1dc44726a7f9d91365f17f3a.png"><br><br>  The reason is that he has not one client, but two, and the second one still makes calls from the main, blue stream.  If these calls change the shared state of an object, then the classic problem of race to data will occur.  To protect against it, you must implement the red object in a thread-safe manner. <br><br><img src="https://habrastorage.org/files/1c7/041/293/1c7041293178488985f7a6b84920e63e.png"><br><br>  As the project progresses, another component becomes a bottleneck.  Fortunately, he has only one client, and no thread-safe implementation is required. <br><br><img src="https://habrastorage.org/files/3d1/ed4/3b4/3d1ed43b4569421d9a1b64f5370e91df.png"><br><br>  If you extrapolate this approach to the design of multi-threaded architecture, sooner or later it comes to the next state. <br><br><img src="https://habrastorage.org/files/4d0/b24/d4a/4d0b24d4a31a453186eadd05294dae3c.png"><br><br>  With a little complication, it becomes quite deplorable. <br><br><img src="https://habrastorage.org/files/d90/456/9cb/d904569cbccb4864b81b9ace1a4a5c40.png"><br><br>  The disadvantages of the presented approach with the conditional name Thread-Safe Architecture are as follows: <br><br><ol><li>  It is necessary to constantly monitor connections between objects for timely refactoring of a single-threaded implementation of a method or class to a thread-safe (and vice versa). </li><li>  Thread-safe methods are difficult to implement, because, in addition to applied logic, it is necessary to take into account the specifics of multi-threaded programming. </li><li>  The active use of synchronization primitives may ultimately make the application even slower than its single-threaded implementation. </li></ol><br><h1>  The principle of the SchedulableObject pattern </h1><br>  In the world of server, desktop, and even Android, heavy business logic is often separated into a separate process.  The interaction between the services within each of the processes remains single-threaded.  Services from different processes interact with each other using various interprocess communication mechanisms (COM / DCOM, Corba, .Net Remoting, Boost. Interprocess, etc.). <br><br><img src="https://habrastorage.org/files/8a6/0e8/10c/8a60e810c01f46c98e23c29fc037fa79.png"><br><br>  Unfortunately, in the world of iOS development, we are limited to only one process, and AS IS does not fit this architecture.  However, it can be reproduced in miniature, replacing a separate process with a separate thread, and the interprocess communication mechanism with indirect challenges. <br><br><img src="https://habrastorage.org/files/f5e/a33/6c5/f5ea336c5f4b48daa7703ff7ba4a08b5.png"><br><br>  More formally, the essence of transformation is: <br><br><ol><li>  Start one separate workflow. </li><li>  To associate with it an event processing cycle and a special object for delivering messages to it - the scheduler (from the English scheduler). </li><li>  Associate each variable object with one of the planners.  The more objects will be associated with workflow planners, the more time the main thread will have on its main responsibility - drawing the user interface. </li><li>  Choose the right way to interact objects with each other, depending on their belonging to the scheduler.  If the scheduler is common, then the interaction occurs by a direct call of methods, if not, then indirectly, by sending specialized events. </li></ol><br>  The proposed approach has already been adopted by the iOS community.  This is what the high-level architecture of Facebook's popular React Native framework looks like. <br><br><img src="https://habrastorage.org/files/4eb/1d8/156/4eb1d81563294ffeb503a1405bbf4e59.png"><br><br>  All JavaScript code is executed in a separate thread, and interaction with the native code occurs via indirect calls by <a href="https://medium.com/%40rotemmiz/react-native-internals-a-wider-picture-part-1-messagequeue-js-thread-7894a7cba868">sending messages</a> through the asynchronous bridge. <br><br><h1>  Components of the SchedulableObject Pattern </h1><br>  The SchedulableObject pattern is based on five components.  Below, for each of them, a zone of responsibility is defined and a naive implementation is proposed in order to most vividly illustrate its internal structure. <br><br><h3>  Developments </h3><br>  The most convenient abstraction for events in iOS are the blocks within which the required object method is invoked. <br><br><pre> <code class="hljs coffeescript">typealias Event = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Void</code> </pre> <br><h3>  Event queue </h3><br>  Since the events in the queue come from different threads, the queue requires a thread-safe implementation.  In fact, it is she who takes on all the difficulties of multi-threaded development of applied components. <br><br><pre> <code class="hljs markdown">class EventQueue { private let semaphore = DispatchSemaphore(value: 1) private var events = [<span class="hljs-string"><span class="hljs-string">Event</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) func pushEvent(event: @escaping Event) { semaphore.wait() events.append(event) semaphore.signal() } func resetEvents() -&gt; [<span class="hljs-string"><span class="hljs-string">Event</span></span>] { semaphore.wait() let currentEvents = events events = [<span class="hljs-string"><span class="hljs-string">Event</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) semaphore.signal() return currentEvents } }</code> </pre> <br><h3>  Message loop </h3><br>  Implements strictly sequential event handling from the queue.  This property of the component ensures that all calls to the objects implementing it are made in one strictly defined stream. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RunLoop</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventQueue = <span class="hljs-type"><span class="hljs-type">EventQueue</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> disposed = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> !disposed { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> event <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> eventQueue.resetEvents() { event() } <span class="hljs-type"><span class="hljs-type">Thread</span></span>.sleep(forTimeInterval: <span class="hljs-number"><span class="hljs-number">0.1</span></span>) } } }</code> </pre><br>  In iOS SDK there is a standard implementation of this component - NSRunLoop. <br><br><h3>  Flow </h3><br>  The kernel object of the operating system in which the message loop code is executed.  The lowest-level implementation in the iOS SDK is the NSThread class.  For practical purposes, it is recommended to use higher-level primitives like NSOperationQueue or the queue from the Grand Central Dispatch. <br><br><h3>  Scheduler </h3><br>  Provides a mechanism for delivering events to the desired queue.  As the main component through which client code executes object methods, it gives the name of both the SchedulableObject micro pattern and the Schedulable Architecture macro pattern. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scheduler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> runLoop = <span class="hljs-type"><span class="hljs-type">RunLoop</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> thread: <span class="hljs-type"><span class="hljs-type">Thread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thread = <span class="hljs-type"><span class="hljs-type">Thread</span></span>(target:runLoop, selector:#selector(<span class="hljs-type"><span class="hljs-type">RunLoop</span></span>.run), object:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) thread.start() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: @escaping Event)</span></span></span></span> { runLoop.eventQueue.pushEvent(event: event) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { runLoop.disposed = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><h1>  SchedulableObject </h1><br>  Provides a standard interface for indirect calls.  With respect to the target object, it can act as an aggregate, as in the example below, and as the base class, as in the <a href="http://bit.ly/schedulable_object">POSSchedulableObject</a> library. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SchedulableObject</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scheduler: <span class="hljs-type"><span class="hljs-type">Scheduler</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(object: <span class="hljs-type"><span class="hljs-type">T</span></span>, scheduler: <span class="hljs-type"><span class="hljs-type">Scheduler</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.object = object <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scheduler = scheduler } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(T)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { scheduler.schedule { event(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.object) } } }</code> </pre> <br><h3>  We put everything together </h3><br>  The program below duplicates the characters entered into the console.  The layer of business logic that we want to remove from the main thread is represented by the Assembly class.  It creates and provides access to two services: <br><br><ol><li>  Printer prints the lines it feeds to the console. </li><li>  PrintOptionsProvider allows you to configure the Printer service. </li></ol><br><pre> <code class="hljs bash">// // main.swift // SchedulableObjectDemo // class PrintOptionsProvider { var richFormatEnabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } class Printer { private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> optionsProvider: PrintOptionsProvider init(optionsProvider: PrintOptionsProvider) { self.optionsProvider = optionsProvider } func doWork(what: String) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> optionsProvider.richFormatEnabled { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"\(Thread.current): out \(what)"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"out \(what)"</span></span>) } } } class Assembly { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundScheduler = Scheduler() <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> printOptionsProvider: SchedulableObject&lt;PrintOptionsProvider&gt; <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> printer: SchedulableObject&lt;Printer&gt; <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> optionsProvider = PrintOptionsProvider() self.printOptionsProvider = SchedulableObject&lt;PrintOptionsProvider&gt;( object: optionsProvider, scheduler: backgroundScheduler); self.printer = SchedulableObject&lt;Printer&gt;( object: Printer(optionsProvider: optionsProvider), scheduler: backgroundScheduler) } } <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> assembly = Assembly() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> { guard <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> value = readLine(strippingNewline: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == <span class="hljs-string"><span class="hljs-string">"q"</span></span>) { assembly.backgroundScheduler.dispose() <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; } assembly.printOptionsProvider.schedule( event: { (printOptionsProvider: PrintOptionsProvider) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> printOptionsProvider.richFormatEnabled = arc4random() % 2 == 0 }) assembly.printer.schedule(event: { (printer: Printer) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> printer.doWork(what: value) }) }</code> </pre><br>  The last block of code, if desired, can be simplified: <br><br><pre> <code class="hljs cs">assembly.backgroundScheduler.schedule { assembly.printOptionsProvider.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.richFormatEnabled = arc4random() % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> assembly.printer.<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.doWork(what: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) }</code> </pre> <br><h3>  Rules of interaction with schedulable objects </h3><br>  The above program clearly demonstrates two rules of interaction with schedulable objects. <br><br><ol><li>  If the same scheduler is associated with the object client and the called object, then the method is called in the usual way.  So, Printer communicates directly with PrintOptionsProvider. </li><li>  If different planners are associated with the object's client and the called object, then the call occurs indirectly by sending an event.  In the example above, the while loop reads user input, executing in the main application thread, and therefore cannot directly access the business logic objects.  He interacts with them indirectly - through sending events. </li></ol><br>  Full listing of the application is available <a href="http://bit.ly/schedulable_object_concept">here</a> . <br><br><h1>  Disadvantages of the SchedulableObject Pattern </h1><br>  With all the elegance of the pattern, he has a dark side: high invasiveness.  All is well when the Schedulable Architecture is laid during the initial design, as in <a href="http://bit.ly/schedulable_object_demo">this demo application</a> , and the matter takes a completely different turn when life forces to implement it into the existing volume code base.  The N-stream nature of the pattern gives rise to two stringent requirements with far-reaching consequences. <br><br><h3>  Requirement # 1: Immutable Models </h3><br>  All entities moving between threads must be either immutable or schedulable.  Otherwise, the whole range of problems of competitive change in their condition does not slow down to wait.  Today, there is a clear trend towards the use of immutable model objects.  At its forefront are companies that are faced with the need to isolate business logic from the main stream.  Here is a list of perhaps the most vivid materials on this topic: <br><br><ul><li>  <a href="https://developer.apple.com/videos/play/wwdc2015/414/">Apple WWDC: Building Better Apps with Value Types in Swift</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DmLSeEoC6GjU">Facebook: ComponentKit ... emphasizes a <i>model</i> for <i>immutable components</i></a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DGWWez7BDKq4">Dropbox: Practical Cross-Platform Mobile C ++ Development</a> </li><li>  <a href="https://engineering.pinterest.com/blog/immutable-models-and-data-consistency-our-ios-app">Pinterest: Immutable models and data in our iOS App</a> </li><li>  <a href="https://realm.io/news/slug-peter-livesey-managing-consistency-immutable-models">LinkedIn: Managing Consistency of Immutable Models</a> </li></ul><br>  However, in the code bases of our day, we are more likely to encounter mutable models.  Moreover, readwrite properties are the only way to update them when using persistence frameworks like Core Data or Realm.  The implementation of Schedulable Architecture makes you either abandon them or provide some special mechanisms for working with models.  So, the Realm team offers the following: ‚Äú <a href="https://realm.io/news/threading-deep-dive/">Therefore, you can‚Äôt pass the realm objects between threads.</a>  <a href="https://realm.io/news/threading-deep-dive/">If you need the same data for another thread</a> .  With Core Data, there are also workarounds, but, in my opinion, this is all very inconvenient and looks like a ‚Äúthing from the side,‚Äù which I don‚Äôt want to put into architecture at the design stage.  Not so long ago, Facebook in the article ‚Äú <a href="https://code.facebook.com/posts/340384146140520/making-news-feed-nearly-50-faster-on-ios/">Making News Feed nearly 50% faster on iOS</a> ‚Äù announced its rejection of Core Data.  LinkedIn, referring to the same Core Data deficiency, recently introduced its persistent data storage framework: ‚ÄúI <a href="https://linkedin.github.io/RocketData/pages/100_coreData.html">‚Äôve got it</a> ‚Äù. <br><br><h3>  Requirement No. 2: Clusters of Services </h3><br>  Migrating to a separate stream only makes sense when the entire cluster of objects is ready for this.  If the services involved in different scenarios live in different streams, then an abundance of indirect calls between them will provoke an incredible code blast. <br><br><img src="https://habrastorage.org/files/d64/6a0/8e7/d646a08e755b49b5998969e833199b22.jpg"><br><br>  Now in the Mail.Ru Cloud as part of product development we are gradually preparing business logic for life outside the main stream.  So, with each release we increase the number of services implementing the SchedulableObject pattern.  As soon as their number reaches a critical mass, sufficient for the implementation of "heavy" scenarios, they will be assigned a workflow planner at a time, and the brakes due to business logic will be a thing of the past. <br><br><h1>  POSSchedulableObject library </h1><br>  The <a href="http://bit.ly/schedulable_object">POSSchedulableObject</a> library is the key ingredient for fully implementing the Schedulable Architecture pattern in the Mail.Ru Cloud iOS application.  Despite the fact that the code base is still preparing for the transformation from a single-threaded state to a two-threaded state, refactoring is already beneficial.  Since POSSchedulableObject is used as the base class for all managed objects, some of its properties are actively used now.  One of the key tasks is tracking unauthorized direct calls to object methods from ‚Äúenemy‚Äù flows for it.  Not once or twice, POSSchedulableObject informed us with an assertion that we are trying to access the business logic service from a certain workflow.  A common reason is the vain hopes that if in iOS 9 the completion-blocks of class methods from the iOS SDK are twitching in the main application thread, then in iOS 10 this contract will not change. <br><br>  A feature of the implementation of the call detection mechanism from an incorrect flow is that it can be used separately from the POSSchedulableObject class.  We used this property to check that the calls of our ViewController methods occur only in the main thread.  It looks like this. <br><br><pre> <code class="hljs pgsql">@implementation UIViewController (MRCApp) - (<span class="hljs-type"><span class="hljs-type">BOOL</span></span>)mrc_protectForMainThreadScheduler { POSScheduleProtectionOptions *<span class="hljs-keyword"><span class="hljs-keyword">options</span></span> = [POSScheduleProtectionOptions <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>:[POSSchedulableObject selectorsForClass:self.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> nonatomicOnly:YES predicate:^<span class="hljs-type"><span class="hljs-type">BOOL</span></span>(SEL _Nonnull selector) { NSString *selectorName = NSStringFromSelector(selector); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [selectorName rangeOfString:@"_"].<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>; }] <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span>:[POSSchedulableObject selectorsForClass:[UIResponder <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [POSSchedulableObject protect:self forScheduler:[RACTargetQueueScheduler pos_mainThreadScheduler] <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>]; } @<span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  More information about the library can be found in its description in the <a href="http://bit.ly/schedulable_object">repository on GitHub</a> .  As soon as we stop supporting iOS 7, we‚Äôll immediately take care of the version for Swift, the sketches of which were shown as part of the listings of the components of the pattern. <br><br><h1>  Conclusion </h1><br>  The SchedulableObject pattern provides a systematic approach for moving the business logic of an application out of the main thread.  The resulting Schedulable Architecture scales well for two reasons.  First, the number of worker threads does not depend on the number of services.  Secondly, the entire complexity of multi-threaded development has been transferred from application classes to infrastructure ones.  The architecture also has interesting hidden features.  For example, we can take out business logic not in one flow, but in several flows.  Changing the priority of each of them, we change at the macro level the intensity of use of system resources by each of the clusters of objects.  This can be useful, for example, when implementing multi-account in an application.  By increasing the priority of the thread in which the message processing loop of the business account of the current account is executed, we can thereby intensify the execution of the most relevant tasks for the user. <br><br><h1>  Links </h1><br><ol><li>  <a href="http://bit.ly/schedulable_object_concept">Playground with demonstration of the main components of the SchedulableObject pattern</a> </li><li>  <a href="http://bit.ly/schedulable_object">POSSchedulableObject library</a> </li><li>  <a href="http://bit.ly/schedulable_object_demo">De-application using the POSSchedulableObject library</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/317440/">https://habr.com/ru/post/317440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317428/index.html">Clouds like love</a></li>
<li><a href="../317430/index.html">CSS selectors in the showroom</a></li>
<li><a href="../317432/index.html">How to become an Oracle Certified Professional Java SE 8 Programmer</a></li>
<li><a href="../317434/index.html">Assassin's Creed III mission design lessons in the open world</a></li>
<li><a href="../317438/index.html">New approaches to securing virtual infrastructure</a></li>
<li><a href="../317442/index.html">Ask Badoo backend developers. Part 1. Platform</a></li>
<li><a href="../317444/index.html">Creating an Elixir application by example. From initialization to publication</a></li>
<li><a href="../317446/index.html">What Russian startups do not know well</a></li>
<li><a href="../317448/index.html">Can IT professionals change jobs without a pay rise: a survey infographic from My Circle</a></li>
<li><a href="../317450/index.html">Pre-New Year's Release API and Portal Scorocode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>