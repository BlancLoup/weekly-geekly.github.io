<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Brief introduction to rvalue links</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article ‚ÄúA Brief Introduction to Rvalue References‚Äù, Howard E. Hinnant, Bjarne Stroustrup, Bronek Kozicki. 

 Rvalue links are a sm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Brief introduction to rvalue links</h1><div class="post__text post__text-html js-mediator-article">  Translation of the article ‚ÄúA Brief Introduction to Rvalue References‚Äù, Howard E. Hinnant, Bjarne Stroustrup, Bronek Kozicki. <br><br>  Rvalue links are a small technical extension of the C ++ language.  They allow programmers to avoid logically unnecessary copying and to ensure perfect forwarding.  First of all, they are intended for use in high-performance projects and libraries. <br><br><h4>  Introduction </h4><br>  This document gives a primary insight into the new function of the C ++ language - rvalue link.  This is a quick tutorial, not a complete article.  For more information, see the list of links at the end. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Rvalue link </h4><br>  A rvalue reference is a composite type, very similar to a traditional reference in C ++.  To distinguish between these two types, we will call the traditional C ++ link an lvalue link.  When the term link appears, it refers to both types of links, and to lvalue links, and to rvalue links. <a name="habracut"></a><br><br>  According to the semantics of lvalue, a link is formed by putting &amp; after some type. <br><br><pre><code class="cpp hljs">A a; A&amp; a_ref1 = a; <span class="hljs-comment"><span class="hljs-comment">//  lvalue </span></span></code> </pre> <br>  If after some type put &amp;&amp;, then we get an rvalue link. <br><br><pre> <code class="cpp hljs">A a; A&amp;&amp; a_ref2 = a; <span class="hljs-comment"><span class="hljs-comment">//  rvalue </span></span></code> </pre><br>  A rvalue reference behaves exactly the same as a lvalue reference, except that it can be associated with a temporary object, whereas an lvalue cannot be associated with a temporary (non-constant) object. <br><br><pre> <code class="cpp hljs">A&amp; a_ref3 = A(); <span class="hljs-comment"><span class="hljs-comment">// ! A&amp;&amp; a_ref4 = A(); // Ok</span></span></code> </pre><br>  Question: Why would we need it ?! <br><br>  It turns out that the combination of rvalue of links and lvalue of links is what is needed for an easy implementation of move semantics.  The Rvalue link can also be used to achieve perfect forwarding, which was previously an unsolved problem in C ++.  For most programmers, the rvalue links allow you to create more productive libraries. <br><br><h4>  Move semantics </h4><br><h5>  Elimination of side copies </h5><br>  Copying can be expensive.  For example, for two vectors, when we write <code>v2 = v1</code> , it usually causes a function call, memory allocation and a loop.  This, of course, is acceptable when we really need two copies of a vector, but in many cases this is not so: we often copy a vector from one place to another, and then delete the old copy.  Consider: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">swap</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//       a a = b; //        b b = tmp; //        tmp (.. a) }</span></span></code> </pre><br>  In reality, we didn‚Äôt need copies of <code>a</code> or <code>b</code> , we just wanted to exchange them.  Let's try again: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">swap</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>; a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre><br>  This call <code>move()</code> returns the value of the object passed as a parameter, but does not guarantee the safety of this object.  For example, if we pass <code>vector</code> as a parameter in <code>move()</code> , then we can reasonably expect that after the function works, the parameter will have a zero-length vector, since all elements will be moved rather than copied.  In other words, a move is an erase read (destructive read). <br><br>  In this case, we optimized <code>swap</code> specialization.  However, we cannot specialize every function that copies a large object just before it deletes or overwrites it.  It would be non-constructive. <br><br>  The main task of link rvalue is to allow us to implement the move without rewriting the code and runtime overhead. <br><br><h5>  Move </h5><br>  The <code>move</code> function actually performs a very modest job.  Its task is to accept either the lvalue or the rvalue parameter, and return it as an rvalue without calling the copy constructor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remove_reference</span></span></span><span class="hljs-class">&lt;T&gt;:</span></span>:<span class="hljs-function"><span class="hljs-function">type&amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br>  Now everything depends on the client code, where the key functions (for example, the copy constructor and the assignment operator) that determine whether the lvalue parameter or rvalue should be overloaded.  If the lvalue parameter, then you need to copy.  If rvalue, then you can safely perform the move. <br><br><h5>  Overload for lvalue / rvalue </h5><br>  Consider a simple class that owns a resource and also provides copy semantics (copy constructor and assignment operator).  For example, <code>clone_ptr</code> could own a pointer and call its expensive <code>clone()</code> method to copy: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clone_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: T* ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//  explicit clone_ptr(T* p = 0) : ptr(p) {} //  ~clone_ptr() {delete ptr;} //   clone_ptr(const clone_ptr&amp; p) : ptr(p.ptr ? p.ptr-&gt;clone() : 0) {} clone_ptr&amp; operator=(const clone_ptr&amp; p) { if (this != &amp;p) { delete ptr; ptr = p.ptr ? p.ptr-&gt;clone() : 0; } return *this; } //   clone_ptr(clone_ptr&amp;&amp; p) : ptr(p.ptr) {p.ptr = 0;} clone_ptr&amp; operator=(clone_ptr&amp;&amp; p) { std::swap(ptr, p.ptr); return *this; } //   T&amp; operator*() const {return *ptr;} // ... };</span></span></code> </pre><br>  With the exception of move semantics, <code>clone_ptr</code> is the code that can be found in today's C ++ books.  Users could use <code>clone_ptr</code> like this: <br><br><pre> <code class="cpp hljs">clone_ptr&lt;base&gt; p1(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> derived); <span class="hljs-comment"><span class="hljs-comment">// ... clone_ptr&lt;base&gt; p2 = p1; //  p2  p1     </span></span></code> </pre><br><br>  Note that doing the copy constructor or assignment operator for <code>clone_ptr</code> is a relatively expensive operation.  However, when the source of the copy is an rvalue, you can avoid calling the potentially expensive <code>clone()</code> operation by stealing the rvalue pointer (no one will notice!).  In the semantics of relocation, the relocation constructor leaves the value of rvalue in the created object, and the assignment operator reverses the values ‚Äã‚Äãof the current object with the rvalue object of the link. <br><br>  Now, when the code is trying to copy rvalue <code>clone_ptr</code> , or if there is explicit permission to read the source of the rvalue copy (using <code>std::move</code> ), the work will be done much faster. <br><br><pre> <code class="cpp hljs">clone_ptr&lt;base&gt; p1(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> derived); <span class="hljs-comment"><span class="hljs-comment">// ... clone_ptr&lt;base&gt; p2 = std::move(p1); //  p2  ,  p1</span></span></code> </pre><br>  For classes composed of other classes (either through inclusion or through inheritance), the move constructor and the move assignment can easily be implemented using the <code>std::move</code> function. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-comment"><span class="hljs-comment">// ... public: // ... //   Derived(Derived&amp;&amp; x) //   rvalue : Base(std::move(x)), vec(std::move(x.vec)), name(std::move(x.name)) { } Derived&amp; operator=(Derived&amp;&amp; x) //   rvalue { Base::operator=(std::move(x)); vec = std::move(x.vec); name = std::move(x.name); return *this; } // ... };</span></span></code> </pre><br>  Each sub-object will now be processed as an rvalue in the displacement constructor and the object's moving assignment operator.  With <code>std::vector</code> and <code>std::string</code> , move operations are already implemented (just like our <code>clone_ptr</code> ), which allows you to avoid much more expensive copy operations. <br><br>  It is worth noting that the <code>x</code> parameter is treated as an lvalue in move operations, despite the fact that it is declared as a rvalue reference.  Therefore, you must use <code>move(x)</code> instead of just <code>x</code> when passing to the base class.  This is a key security mechanism for semantics of motion, designed to prevent accidental double-move attempts from some named variable.  All movements occur only from rvalues ‚Äã‚Äãor with an explicit reduction to rvalue (with <code>std::move</code> ).  If the variable has a name, then it is an lvalue. <br><br>  Question: What about types that do not own resources?  (For example, <code>std::complex</code> ?) <br><br>  In this case, no work is required.  The copy constructor is already optimal for copying with rvalue. <br><br><h4>  Relocatable but not replicable types </h4><br>  For some types of semantics of copying is not applicable, but they can be moved.  For example: <br><br><ul><li> <code>fstream</code> </li> <li>  <code>unique_ptr</code> (not shared and not copied ownership) </li><li>  A type representing a thread of execution. </li></ul><br>  If such types are made relocatable (although they remain not replicable), then their usability is extremely increased.  The moved but not copied object can be returned by value from the factory method (pattern): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_and_open_data_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* ... */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ... ifstream data_file = find_and_open_data_file(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  !</span></span></code> </pre><br>  In this example, the base file descriptor is transferred from one object to another, because  the <code>ifstream</code> source is rvalue.  There is only one file descriptor at any given time, and only <code>ifstream</code> owns it. <br><br>  A relocatable but non-replicable type can also be placed in standard containers.  If the container needs to ‚Äúcopy‚Äù the element inside itself (for example, during <code>vector</code> relocation), it will simply move it instead of copying. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;base&gt;&gt; v1, v2; v1.push_back(<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;base&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> derived())); <span class="hljs-comment"><span class="hljs-comment">// OK,    ... v2 = v1; //   !    . v2 = move(v1); //  .     v2.</span></span></code> </pre><br>  Many standard algorithms benefit from moving sequence elements instead of copying them.  This not only provides better performance (as in the case of <code>std::swap</code> , the implementation of which is described above), but also allows these algorithms to work with non-copied (but relocatable) types.  For example, the following code sorts <pre> <code class="hljs ruby"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">()(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> &lt; *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">;</span></span>} }; ... std::vector&lt;std::unique_ptr&lt;A<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">() //    { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">);</span></span> } template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) //     { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">));</span></span> } /<span class="hljs-regexp"><span class="hljs-regexp">/   </span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">            . : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :  ,   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">      ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">        ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">           </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,        (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">A1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> )       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   ,      ,       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  .          (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">std::bind</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ). </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">    : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ! A* q = new A(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ OK</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,    "5"   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">int&amp;</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">        rvalue "5".  ,      ,    . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :        </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;  </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       ,     :          4 .          8  .         16   ..     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> Rvalue        : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">  rvalue       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :    </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">    ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">move</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> -     , ,      ,       .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">a1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  lvalue/rvalue</span></span> ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typedef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">;</span></span> }; template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forward</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class">&lt;T&gt;::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> }</code> <br>  <br>        ,     .   ,   <span class="hljs-number"><span class="hljs-number">95</span></span>%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N169<span class="hljs-number"><span class="hljs-number">0</span></span></a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N186<span class="hljs-number"><span class="hljs-number">0</span></span></a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </pre> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> <h4> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </h4> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> <pre> <code class="hljs ruby"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">()(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> &lt; *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">;</span></span>} }; ... std::vector&lt;std::unique_ptr&lt;A<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">() //    { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">);</span></span> } template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) //     { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">));</span></span> } /<span class="hljs-regexp"><span class="hljs-regexp">/   </span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">            . : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :  ,   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">      ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">        ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">           </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,        (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">A1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> )       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   ,      ,       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  .          (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">std::bind</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ). </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">    : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ! A* q = new A(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ OK</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,    "5"   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">int&amp;</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">        rvalue "5".  ,      ,    . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :        </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;  </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       ,     :          4 .          8  .         16   ..     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> Rvalue        : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">  rvalue       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :    </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">    ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">move</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> -     , ,      ,       .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">a1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  lvalue/rvalue</span></span> ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typedef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">;</span></span> }; template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forward</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class">&lt;T&gt;::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> }</code> <br>  <br>        ,     .   ,   <span class="hljs-number"><span class="hljs-number">95</span></span>%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N169<span class="hljs-number"><span class="hljs-number">0</span></span></a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N186<span class="hljs-number"><span class="hljs-number">0</span></span></a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </pre> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> <pre> <code class="hljs ruby"><code class="cpp"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">()(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> &lt; *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">;</span></span>} }; ... std::vector&lt;std::unique_ptr&lt;A<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">() //    { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">);</span></span> } template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) //     { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">));</span></span> } /<span class="hljs-regexp"><span class="hljs-regexp">/   </span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">            . : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :  ,   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">      ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">        ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">           </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,        (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">A1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> )       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   ,      ,       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  .          (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">std::bind</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ). </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">    : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ! A* q = new A(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ OK</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,    "5"   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">int&amp;</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">        rvalue "5".  ,      ,    . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :        </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;  </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       ,     :          4 .          8  .         16   ..     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> Rvalue        : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">  rvalue       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :    </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">    ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">move</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> -     , ,      ,       .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">a1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  lvalue/rvalue</span></span> ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typedef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">;</span></span> }; template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forward</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class">&lt;T&gt;::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> }</code> <br>  <br>        ,     .   ,   <span class="hljs-number"><span class="hljs-number">95</span></span>%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N169<span class="hljs-number"><span class="hljs-number">0</span></span></a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N186<span class="hljs-number"><span class="hljs-number">0</span></span></a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code></code> </pre> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> <pre> <code class="hljs ruby"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">()(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> &lt; *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">;</span></span>} }; ... std::vector&lt;std::unique_ptr&lt;A<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">() //    { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">);</span></span> } template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) //     { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">));</span></span> } /<span class="hljs-regexp"><span class="hljs-regexp">/   </span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">            . : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :  ,   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">      ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">        ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">           </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,        (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">A1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> )       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   ,      ,       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  .          (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">std::bind</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ). </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">    : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ! A* q = new A(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ OK</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,    "5"   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">int&amp;</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">        rvalue "5".  ,      ,    . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :        </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;  </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       ,     :          4 .          8  .         16   ..     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> Rvalue        : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">  rvalue       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :    </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">    ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">move</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> -     , ,      ,       .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">a1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  lvalue/rvalue</span></span> ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typedef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">;</span></span> }; template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forward</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class">&lt;T&gt;::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> }</code> <br>  <br>        ,     .   ,   <span class="hljs-number"><span class="hljs-number">95</span></span>%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N169<span class="hljs-number"><span class="hljs-number">0</span></span></a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N186<span class="hljs-number"><span class="hljs-number">0</span></span></a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </pre> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> <pre> <code class="hljs ruby"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">()(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> &lt; *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">;</span></span>} }; ... std::vector&lt;std::unique_ptr&lt;A<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">() //    { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">);</span></span> } template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) //     { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">));</span></span> } /<span class="hljs-regexp"><span class="hljs-regexp">/   </span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">            . : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :  ,   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">      ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">        ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">           </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,        (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">A1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> )       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   ,      ,       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  .          (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">std::bind</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ). </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">    : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ! A* q = new A(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ OK</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,    "5"   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">int&amp;</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">        rvalue "5".  ,      ,    . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :        </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;  </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       ,     :          4 .          8  .         16   ..     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> Rvalue        : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">  rvalue       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :    </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">    ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">move</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> -     , ,      ,       .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">a1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  lvalue/rvalue</span></span> ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typedef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">;</span></span> }; template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forward</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class">&lt;T&gt;::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> }</code> <br>  <br>        ,     .   ,   <span class="hljs-number"><span class="hljs-number">95</span></span>%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N169<span class="hljs-number"><span class="hljs-number">0</span></span></a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N186<span class="hljs-number"><span class="hljs-number">0</span></span></a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </pre> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> <pre> <code class="hljs ruby"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">()(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> &lt; *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">;</span></span>} }; ... std::vector&lt;std::unique_ptr&lt;A<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">() //    { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">);</span></span> } template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) //     { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">));</span></span> } /<span class="hljs-regexp"><span class="hljs-regexp">/   </span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">            . : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :  ,   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">      ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">        ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">           </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,        (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">A1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> )       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   ,      ,       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  .          (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">std::bind</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ). </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">    : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ! A* q = new A(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ OK</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,    "5"   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">int&amp;</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">        rvalue "5".  ,      ,    . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :        </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;  </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       ,     :          4 .          8  .         16   ..     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> Rvalue        : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">  rvalue       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :    </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">    ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">move</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> -     , ,      ,       .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">a1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  lvalue/rvalue</span></span> ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typedef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">;</span></span> }; template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forward</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class">&lt;T&gt;::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> }</code> <br>  <br>        ,     .   ,   <span class="hljs-number"><span class="hljs-number">95</span></span>%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N169<span class="hljs-number"><span class="hljs-number">0</span></span></a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N186<span class="hljs-number"><span class="hljs-number">0</span></span></a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </pre> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> <pre> <code class="hljs ruby"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">()(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> &lt; *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">;</span></span>} }; ... std::vector&lt;std::unique_ptr&lt;A<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">() //    { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">);</span></span> } template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A1</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) //     { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::shared_ptr</span></span></span><span class="hljs-class">&lt;T&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">));</span></span> } /<span class="hljs-regexp"><span class="hljs-regexp">/   </span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">            . : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :  ,   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">      ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">        ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">           </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,        (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">A1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> )       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   ,      ,       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">T</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  .          (, </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">std::bind</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ). </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">    : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ! A* q = new A(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ OK</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,    "5"   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">int&amp;</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">        rvalue "5".  ,      ,    . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :        </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;  </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const AI</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> &amp;? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">       ,     :          4 .          8  .         16   ..     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> Rvalue        : </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><code class="cpp"><span class="hljs-regexp"><span class="hljs-regexp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">  rvalue       </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> .   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">const</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,         </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">factory</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> :    </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">    ? </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp">   </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">move</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> -     , ,      ,       .     </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">a1</span></span></code><span class="hljs-regexp"><span class="hljs-regexp"> ,     . </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> </span></span><br><span class="hljs-regexp"><span class="hljs-regexp"> , </span></span><code><span class="hljs-regexp"><span class="hljs-regexp">forward</span></span></code><span class="hljs-regexp"><span class="hljs-regexp">  lvalue/rvalue</span></span> ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typedef</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">;</span></span> }; template &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forward</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identity</span></span></span><span class="hljs-class">&lt;T&gt;::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">;</span></span> }</code> <br>  <br>        ,     .   ,   <span class="hljs-number"><span class="hljs-number">95</span></span>%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N169<span class="hljs-number"><span class="hljs-number">0</span></span></a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N186<span class="hljs-number"><span class="hljs-number">0</span></span></a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </pre> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> <h4> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </h4> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> <ul><li> <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     </a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> N1856 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </li> <li> <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     </a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> N1857 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </li> <li> <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     </a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> N1858 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </li> <li> <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     </a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> N1859 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </li> <li> <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     </a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> N1860 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </li> <li> <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     </a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> N1861 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </li> <li> <code><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html"><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     </a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> N1862 <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </li> </ul> <code><code class="cpp">vector&lt;unique_ptr&gt;,   ,     : <br> <br> struct indirect_less { template &lt;class T&gt; bool operator()(const T&amp; x, const T&amp; y) {return *x &lt; *y;} }; ... std::vector&lt;std::unique_ptr&lt;A&gt;&gt; v; ... std::sort(v.begin(), v.end(), indirect_less());</code> <br>      <code>unique_ptr</code> ,    <code>swap</code> (       ,    )    /   .  ,       ,            .       ( ,   ),       . <br> <br>   (perfect forwarding) <br>    ,   <code>std::shared_ptr</code>      .          . ,         ,      .      : <br> <br> <code class="cpp">template &lt;class T&gt; std::shared_ptr&lt;T&gt; factory() //    { return std::shared_ptr&lt;T&gt;(new T); } template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(const A1&amp; a1) //     { return std::shared_ptr&lt;T&gt;(new T(a1)); } //   </code> <br>            . : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5);</code> <br> :  ,   <code>T</code>      ? <br> <br>        ,     <code>factory</code>         <code>T</code> . <br> <br>           <code>factory</code> : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(a1)); }</code> <br>   .     <code>const</code>   <code>factory</code> ,        (, <code>A1</code> )       <code>T</code> .   ,      ,       <code>T</code>  .          (, <code>std::bind</code> ). <br> <br>    : <br> <br> <code class="cpp">std::shared_ptr&lt;A&gt; p = factory&lt;A&gt;(5); // ! A* q = new A(5); // OK</code> <br>       <code>factory</code> ,    "5"   <code>factory</code> ,     <code>int&amp;</code>        rvalue "5".  ,      ,    . <br> <br> :        <code>AI</code> &amp;  <code>const AI</code> &amp;? <br> <br>       ,     :          4 .          8  .         16   ..     . <br> <br> Rvalue        : <br> <br> <code class="cpp">template &lt;class T, class A1&gt; std::shared_ptr&lt;T&gt; factory(A1&amp;&amp; a1) { return std::shared_ptr&lt;T&gt;(new T(std::forward&lt;A1&gt;(a1))); }</code> <br>  rvalue       <code>factory</code> .   <code>const</code> ,         <code>factory</code> . <br> <br> :    <code>forward</code>    ? <br> <br>   <code>move</code> , <code>forward</code> -     , ,      ,       .     <code>a1</code> ,     . <br> <br> , <code>forward</code>  lvalue/rvalue ,    <code>factory</code> .  <code>factory</code>   rvalue,    <code>forward</code>   <code>T</code>   rvalue.   ,  lvalue   <code>factory</code> ,      <code>T</code>  lvalue. <br> <br>   <code>forward</code>    : <br> <br> <code class="cpp">template &lt;class T&gt; struct identity { typedef T type; }; template &lt;class T&gt; T&amp;&amp; forward(typename identity&lt;T&gt;::type&amp;&amp; a) { return a; }</code> <br>  <br>        ,     .   ,   95%    . <br> <br>       ,    ,  ,   ,     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">N1377</a> . <br> <br>         <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">N1385</a> . <br> <br>    rvalue  (     ),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1690.html">N1690</a> . <br> <br>    ,  rvalue ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1952.html">N1952</a> . <br> <br>   rvalue    ,  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">N2027</a> . <br> <br>     rvalue    ,   <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1771.html">N1771</a> . <br> <br>       ,    rvalue , : <br> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html">N1856</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1857.html">N1857</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1858.html">N1858</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1859.html">N1859</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1860.html">N1860</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1861.html">N1861</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1862.html">N1862</a> <br>   rvalue      (this),  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1821.htm">N1821</a> .</code> </div><p>Source: <a href="https://habr.com/ru/post/226229/">https://habr.com/ru/post/226229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226215/index.html">Ubisoft removes female characters from two games</a></li>
<li><a href="../226217/index.html">The man climbed onto an 8-meter glass wall using a device modeled on a gecko's paws.</a></li>
<li><a href="../226219/index.html">IT guy on vacation: gadgets to the telescope</a></li>
<li><a href="../226225/index.html">google protocol buffers: polymorphism, search</a></li>
<li><a href="../226227/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ113 (June 8 - 14, 2014)</a></li>
<li><a href="../226231/index.html">Basic VMWare vSphere Information</a></li>
<li><a href="../226235/index.html">Axiom - raise the degree!</a></li>
<li><a href="../226237/index.html">Experience exchange. Where to realize the knowledge of the addresses of the controller?</a></li>
<li><a href="../226241/index.html">POMP C6S - affordable phablet with attractive features</a></li>
<li><a href="../226243/index.html">Unicorn V838: video of the explosion of a star, collected from photos of the Hubble telescope for 4 years</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>