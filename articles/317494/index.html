<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is HTML5 streaming (and why mp4 streaming does not exist)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Often, customers ask if our server is able to ‚Äúmp4 streaming in HTML5‚Äù. In 99% of cases, the questioner does not understand what he is talking about. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is HTML5 streaming (and why mp4 streaming does not exist)</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d3/63d/168/6d363d1682944147a827c2e3dd77dbde.png" alt="image"></div><br>  Often, customers ask if our server is able to ‚Äúmp4 streaming in HTML5‚Äù.  In 99% of cases, the questioner does not understand what he is talking about.  It‚Äôs hard to blame clients: because of the confusion with terms, technical complexity and a wide variety of streaming options, it‚Äôs very easy to get confused. <br><br>  In this article we will tell you what HTML5 streaming is like, what options are good, and why the hell you can't say ‚Äúmp4 streaming‚Äù. <br><a name="habracut"></a><br><h2>  <font color="#001e8d">‚ñçTerms</font> </h2><br>  <b>HTML5 video</b> is when you insert a <i>&lt;video&gt;</i> tag into a web page and point it to some <i>src</i> .  HTML5 streaming is the same HTML5 video, but when the <i>src is</i> not a ready file, but a constantly updated video stream.  The video on YouTube is an HTML5 video, tweeting is HTML5 streaming. <br><br>  The <i>&lt;video&gt; tag</i> does not matter how the video stream is generated and transmitted, and whether the browser can play it.  The main thing is that src has a link to some kind of video stream.  Technically speaking, the specification says nothing about which <i>protocols, transports,</i> and <i>codecs are</i> supported in HTML5 video. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>A protocol</b> is how two participants in a video call (almost always a client and a server) exchange data in order to receive data.  The client is the one who comes to the server and initiates a communication session.  The video stream can flow from the server to the client (then this is the usual playback) or from the client to the server (then this is the publication).  Even when a giant wardrobe, eating electricity like an apartment building, comes to a small IP camera, it will be the server, and this wardrobe will be the client. <br><br>  The protocol usually implies at least a Play command (start playback), but sometimes there are also extended options: pause, continue, publish, rewind, etc. <br><br>  Examples of protocols: <b>RTSP, RTMP, HTTP, HLS, IGMP</b> . <br><br>  <b>Transport</b> , or <b>transport container</b> , or <b>container</b> - this is how compressed video is packaged in bytes for transmission from one participant to another (using some protocol). <br>  Examples of containers: <b>MPEG-TS, RTMP, RTP</b> . <br><table><tbody><tr><td>  Please note that RTMP is in the protocols and transports.  This is because in the description of RTMP there is a specification of what the parties have to send to each other so that the video will run out (i.e., the protocol), and how to package the video (i.e. transport).  This is not always the case.  For example, in the RTSP protocol, the video is packaged in an RTP transport. </td></tr></tbody></table><br>  <b>Codec</b> is a multi-valued term.  Here it means a way to compress raw video.  The difference between a codec and a transport is that a codec is about preparing a video, and a transport is about transmitting video over a protocol.  Video compressed by one codec can be sent using different protocols and different transports.  Most video streaming servers do not climb deeper than encoded video and operate only with protocols and transports. <br><br>  Codec examples: <b>h264, aac, mp3</b> . <br><table><tbody><tr><td>  Due to the fact that the term is multi-valued, there is a confusion with the names.  For example, H.264 is a standard for how to pack a stream of huge raw video frames in very few bytes, libx264 is a library for compression according to this standard, and there is also the software of the same name under Windows that can decode h264 and play it on the screen. </td></tr></tbody></table><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/924/c7f/a1c/924c7fa1c84449ba85fed75f104a044e.gif"></div><br><br>  So, the HTML5 specification does not describe protocols, transports, and codecs.  Therefore, the authors of the browsers themselves choose what to support, and by ‚ÄúHTML5 streaming‚Äù they mean different things. <br><br>  At the same time there are combinations that are supported by a significant part of browsers.  Consider the most promising. <br><br><h2>  <font color="#001e8d">‚ñçHLS</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec0/d7a/1f2/ec0d7a1f293e5f72a035c5686ffbe129.png" alt="image"></div><br><br>  <b>HLS</b> is h264 video and aac or mp3 audio packed in an MPEG-TS transport.  The stream is divided into segments described in m3u8 playlists and distributed over HTTP.  HLS supports multibitrate streams, Live / VOD.  The option is very simple, but at the same time it has a lot of details, because of which it works differently on different devices. <br><br>  We developed HLS in Epple, so initially it worked only in Safari on iOS and MacOS.  Even Safari on Windows did not know how to play HLS (when there was still a version under Win). <br><br>  Nevertheless, now HLS can play all set-top boxes and even almost all devices on Android. <br><br>  But all is not smooth.  Manufacturers of third-party players spat on the Apple standard in terms of reporting various audio tracks and added playing all that is in ordinary MPEG-TS: mpeg2 video, mpeg2 audio, etc. Because of this, you have to give different playlist formats for different players. <br><br><h2>  <font color="#001e8d">‚ñçMPEG-DASH</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac0/9a9/eff/ac09a9effb9ece603bc05dced852734a.png" alt="image"></div><br>  <b>MPEG-DASH</b> is usually h264 / h265 video and aac audio packaged in a mp4 or vp8 / vp9 transport packed in WebM, although the standard is not tied to specific codecs, protocols, or transports.  As in HLS, a stream can be broken up into segments, but this is optional.  Instead of playlists - MPD manifest in XML. <br><br>  MPEG-DASH is much like HLS.  Perhaps it is even more popular, because such giants as YouTube and Netflix have been using it as the main way to distribute content for several years. <br><br>  MPEG-DASH is good because in most browsers it works natively through MSE (about what it is - just below).  For him, even there is no implementation on Flash - this is honest, uncompromising HTML5. <br>  Definitely, MPEG-DASH is the real HTML5 streaming, followed by the future. <br><br><h2>  <font color="#001e8d">‚ñçMSE</font> </h2><br>  When it became clear that Flash would die anyway (after hundreds of false burials), the question of what would replace him would have an edge.  It would be nice to get in browsers the ability to play video in terms of quality and convenience close to what Flash can do (and he does it all the same well). <br><br>  In Flush, a very convenient mechanism appeared long ago for the universal playback of different variants - appendBytes.  The bottom line is that the user code itself wants to download frames of compressed video, packs it into a specified container (with Flush it is flv) and shoves it in a video player.  That is, the protocol and transport are implemented in user code that runs in the browser. <br><br>  <b>MSE (Media Sources Extensions)</b> is an extension to the HTML5 specification that allows you to do what appendBytes does in Flash.  Unfortunately, MSE is much more difficult both in understanding and in implementation. <br><br>  MPEG-DASH, created on its base, is even more cunning, so working with them is still a pleasure: tons of XML, parsing of binary containers in Javascript, unreasoned at the design stage cutting questions into segments - everything as we love, everything you need for a single, bugless implementation in all browsers. <br><br>  Interestingly, MSE works not only with MPEG-DASH, but also with HLS.  There is an implementation of hls.js that downloads HLS playlists, downloads MPEG-TS segments, repacks them into the required format for MSE and plays through MSE.  Apple even made a step towards compatibility with MPEG-DASH - the use of mp4-containers in HLS. <br><br>  By the end of 2017, Flash will most likely die completely, and today we can safely begin the project with MPEG-DASH. <br><br><h2>  <font color="#001e8d">‚ñçWebRTC</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c55/c80/a7c/c55c80a7c692d55f2e3f815a41052746.png" alt="image"></div><br>  In Flash, a suitable attempt was made in one technology to implement both real-time communication and mass broadcasting.  Unfortunately, in HTML5 it did not happen.  We have MSE to view the broadcasts, and WebRTC for video calls. <br><br>  <b>WebRTC</b> is SIP in a browser: a way to organize an audio and video channel and a data channel between two browsers through a server. <br><br>  The technology is not intended for streaming, but in principle it can, so it would be wrong to forget about it.  WebRTC is also considered to be HTML5, because it seems to require nothing but JavaScript in the browser.  But it requires the availability of the latest versions of both popular browsers, and with Edge is not compatible at all. <br><br>  Confusion in the understanding of WebRTC brings its use in the torrent-delivery of television.  The bottom line is that browsers through WebRTC organize a network of data channels, and then HLS- or MSE-segments of the video are distributed over this network, and playback takes place via Flash or MSE.  That is, WebRTC - for delivery, MSE - for playback.  It is important not to confuse this with using WebRTC to play videos. <br><br><h3>  <font color="#001e8d">‚ñç So what's up with the mp4 streaming?</font> </h3><br>  Any modern browser is likely to be able to request via HTTP protocol a file packed into the mp4 transport and containing a video compressed with the h264 / aac codec.  And even try to lose it.  This is the most convenient, understandable and standard version of playing files.  It lays itself a file on the disk, nginx gives it.  The code that plays mp4 in browsers is good enough.  For example, he can even download pieces of video as needed (unlike a Flash player that downloads the entire video). <br><br>  Around the h264 there was a lot of hype about his "closeness" and "lack of freedom."  So there is an ‚Äúopen‚Äù alternative that Google forsates - vp8 and vp9 video codecs packed into WebM transport.  WebM is a subset of the mkv transport (a. K. A. Matryoshka), which is very similar to mp4 in essence, but differs from it in its ‚Äúbinary‚Äù. <br><br>  It is from here that the legs grow in such a phenomenon as ‚Äúmp4 streaming‚Äù, which is arranged as WebM.  The fact is that in the usual mp4 at the very beginning the size of the entire container is indicated.  Therefore, if we want to broadcast live via normal mp4, we will fail.  And in order to succeed and create mp4 without a fixed end, the next move was invented: first, mp4 is written without frames, and then fragments with frames are signed at the end in blocks of several seconds.  This is called mp4 fragmented, or mp4 streaming. <br><br>  In fact, this is not a streaming, but a crutch, allowing you to create its appearance.  Mp4 is a great format for downloading videos, but not suitable for streaming, so you can simply forget about it and never use the term mp4 streaming. <br><br><h3>  <font color="#001e8d">‚ñç Conclusions</font> </h3><br><ul><li>  Good HTML5 streaming options: MPEG-DASH and HLS.  They are suitable for mobile devices, and for PCs, and consoles. </li><li>  The flash will die anyway, and MSE is already taking its place. </li><li>  WebRTC - HTML5 technology, primarily for communication, but not for television broadcasting. </li><li>  Do not bring old codecs to the web or try to deliver mp2video and mp2audio via HLS, even if your player is able to. </li><li>  Never say ‚Äúmp4 streaming‚Äù.  You are welcome. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/317494/">https://habr.com/ru/post/317494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317480/index.html">The book "Ruby. Object Oriented Design</a></li>
<li><a href="../317482/index.html">Cambium brings new life to your overloaded networks on Ubiquiti: a new program for operators</a></li>
<li><a href="../317484/index.html">How to teach a web application to speak 100 languages: localization features</a></li>
<li><a href="../317488/index.html">We start Gulp with votcher on a usual hosting through adminpanel</a></li>
<li><a href="../317490/index.html">Expansion of functionality of the mobile version and other changes on Habr√© and Giktatimes</a></li>
<li><a href="../317496/index.html">Comparing tracking systems Affise, HasOffers and FuseClick</a></li>
<li><a href="../317498/index.html">Piggy bank knowledge for PHPixie - Part 1</a></li>
<li><a href="../317500/index.html">Memo for seed investors</a></li>
<li><a href="../317504/index.html">Another article about Docker for a beginner [nginx + php-fpm + postgresql + mongodb]</a></li>
<li><a href="../317506/index.html">Small Business Stories - Shop in Voronezh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>