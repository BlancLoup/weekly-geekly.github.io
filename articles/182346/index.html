<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural texturing: cobblestone texture generation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We write a generator that takes a dozen input parameters and gives the texture of the cobblestone. 

 Introduction 
 My hobby is computer graphics and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural texturing: cobblestone texture generation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/a73/449/3f0/a734493f0b47088bd004d8c6478dfedf.png"><img src="https://habrastorage.org/storage2/c19/b52/b06/c19b52b0606a99d1f50b6f0c51ebcb64.png"><br><br>  We write a generator that takes a dozen input parameters and gives the texture of the cobblestone. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  My hobby is computer graphics and the invention of bicycles.  After playing in <a href="http://ru.wikipedia.org/wiki/.kkrieger">.kkrieger</a> and reading <a href="http://habrahabr.ru/company/unigine/blog/167075/">this</a> and <a href="http://habrahabr.ru/post/171805/">this</a> post, I had a burning desire to write my own texture generator.  Choosing as a theme texture - cobblestones, began to google.  Honestly, google cobble stone texture generator was difficult, even with the option-minecraft.  Spitting on this thing began to think for himself. <br><br><h4>  Where to begin </h4><br>  The course of my thoughts was approximately as follows: <br>  - i need stones <br>  - you need more stones!  For a great texture.  And the larger the texture, the longer the generation time.  This is bad. <br>  - stones are different (in size and color) <br>  - stones convex (relief) <br>  - rough stones texture <br>  - different types of stones have different types of roughness <br>  - since the texture has color and relief, it would not be bad to separate these components.  Let there be a pure color texture and a normal map. <br>  In our generator, the texture will be built in stages: first we create one texture, apply filters to it, mix it with another texture, etc. Now we need to remember or find known algorithms that can help us.  I will simply list and briefly describe all the methods that I used in my generator, simultaneously talking about optimizations. <br>  I decided to write the generator in C ++ using the Qt 4.XY library in QtCreator.  However, the generator class itself, I tried to write without Qt. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Cellular texture </h5><br>  This is the basis of the algorithm.  It is she who creates the frame for the stones.  Here <a href="http://www.blackpawn.com/texts/cellular/">is</a> described in detail what a mesh texture is and how to create it. <br>  In my code, the generateCelluarTexture function is responsible for this: <br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ProceduralTexture::generateCelluarTexture(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>) size = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellX = w/size+<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellY = h/size+<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointsX[cellX][cellY]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointsY[cellX][cellY]; srand(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;cellX; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;cellY; j++){ pointsX[i][j] = i*size+rand()%((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(size*<span class="hljs-number"><span class="hljs-number">0.7</span></span>))+size*<span class="hljs-number"><span class="hljs-number">0.15</span></span>-size; pointsY[i][j] = j*size+rand()%((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(size*<span class="hljs-number"><span class="hljs-number">0.7</span></span>))+size*<span class="hljs-number"><span class="hljs-number">0.15</span></span>-size; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distBuff[n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxDist = INT_MIN; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = i%w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = i/w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> min = INT_MAX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> min2 = INT_MAX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startX = x/size; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> finishX = startX+<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cp=<span class="hljs-number"><span class="hljs-number">-1</span></span>, point=<span class="hljs-number"><span class="hljs-number">0</span></span>; startX&lt;finishX; startX++){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startY = y/size; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> finishY = startY+<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; startY&lt;finishY; startY++, point++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startX&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || startX&gt;=cellX || startY&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || startY&gt;=cellY) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d = distance(x, y, pointsX[startX][startY], pointsY[startX][startY]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d&lt;min){ cp = point; min2 = min; min = d; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d&lt;min2 &amp;&amp; cp!=point) min2 = d; } } distBuff[i] = min2-min; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxDist&lt;distBuff[i]) maxDist = distBuff[i]; } <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *img = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[n]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) img[i] = (distBuff[i]*<span class="hljs-number"><span class="hljs-number">255</span></span>)/maxDist; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> img; }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/storage2/5be/4be/9e4/5be4be9e4573b575285918d62b8156f2.png" align="right"><br>  The function takes the size of the cell, returns a black and white image of the texture.  Now not much about optimization. <br>  First, in order not to go through all the points, I divided the image into rectangular areas of a given size (size).  Thus, in order to find the nearest point to the current pixel, you need to view 9 points from the current and neighboring cells.  This is written in the link above. <br>  Secondly, we don‚Äôt have to look for an ‚Äúhonest‚Äù distance.  I'm talking about the distance between two points.  The square of the distance will completely disappear (we get rid of the extraction of the root) - the picture as a result turns out to be more contrast, but does not have a negative effect on the final texture. <br><br><h5>  Brightness and Contrast </h5><br>  I think many people used this filter in Photoshop or other graphic editors.  Now we will write its implementation. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ProceduralTexture::brightnessContrast(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *img, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> brightness, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> contrast, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> onePass){ <span class="hljs-comment"><span class="hljs-comment">// onePass -   if (brightness!=0){ if (brightness&gt;0){ if (brightness&gt;1) brightness = 1; brightness = 1.0f-brightness; for (int i=0; i&lt;n; i++){ int r = 255-img[i]; r *= brightness; img[i] = 255-r; } } if (brightness&lt;0){ if (brightness&lt;-1) brightness = -1; brightness = 1.0f+brightness; for (int i=0; i&lt;n; i++) img[i] *= brightness; } } if (contrast!=1){ if (contrast&lt;0) contrast = 0; int avbr = 0; if (!onePass){ for (int i=0; i&lt;n; i++) avbr += img[i]; avbr /= n; } else avbr = 127; for (int i=0; i&lt;n; i++){ int res = contrast*(img[i]-avbr)+avbr; if (res&lt;0) res = 0; if (res&gt;255) res = 255; img[i] = res; } } }</span></span></code> </pre><br></div></div><br>  The function takes as input a pointer to an image and the coefficients of brightness and contrast.  Formulas for calculation are described <a href="http://algolist.manual.ru/graphics/filter/brightness.php">here</a> . <br><br><h5>  Perlin noise </h5><br>  There are quite a lot of articles written on the noise of the pearl (including on the habr), I will not describe the algorithm, I will tell only about the optimizations and give an example of the code. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// : interpolateTable = NULL; powTable = new float[maxOctaves]; for (int i=0; i&lt;maxOctaves; i++) powTable[i] = pow(0.5, i); inline int ProceduralTexture::getRnd(int x, int y){ return (0x6C078965*(seed^((x*2971902361)^(y*3572953751))))&amp;0x7FFFFFFF; } inline int ProceduralTexture::pointOfPerlinNoise(int x, int y, int cellSize){ int dx = x-(x/cellSize)*cellSize; int dy = y-(y/cellSize)*cellSize; int z1 = getRnd(x-dx, y-dy); // z3 --- z4 int z2 = getRnd(x-dx+cellSize, y-dy); // | | int z3 = getRnd(x-dx, y-dy+cellSize); // + z + int z4 = getRnd(x-dx+cellSize, y-dy+cellSize); // z1 --- z2 int z1z3 = z1*(1.0f-interpolateTable[dy])+z3*interpolateTable[dy]; int z2z4 = z2*(1.0f-interpolateTable[dy])+z4*interpolateTable[dy]; return z1z3*(1.0f-interpolateTable[dx])+z2z4*interpolateTable[dx]; } unsigned char *ProceduralTexture::generatePerlinNoise(int octaves){ unsigned char *img = new unsigned char[n]; if (octaves&lt;1) octaves = 1; if (octaves&gt;maxOctaves) octaves = maxOctaves; for (int i=0; i&lt;n; i++) img[i] = 0; float norm = 255.0f/INT_MAX; for (int j=1; j&lt;=octaves; j++){ int f = 1&lt;&lt;(octaves-j); delete[] interpolateTable; interpolateTable = new float[f]; for (int i=0; i&lt;f; i++){ float a = ((float)i/(float)f)*M_PI; interpolateTable[i] = (1.0f-cosf(a))*0.5f; } for (int i=0; i&lt;n; i++) img[i] += pointOfPerlinNoise(i%w, i/w, f)*powTable[j]*norm; } return img; }</span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/storage2/06d/2d4/955/06d2d4955370901fa20f8f21f6609560.png" align="right"><br>  First optimization: we get rid of the calculation of the interpolation coefficient (1.0f-cosf (a)) * 0.5f) - for this we simply calculate all the options in advance.  And there are not so many options here - the maximum amount is piled up.  Therefore, before calculating each octave, we calculate all the coefficients and enter them into the interpolateTable array. <br>  The second optimization is similar to the first - all the places where squares are calculated are replaced by pre-calculated values ‚Äã‚Äã(powTable). <br>  I also tried to simplify RNG as much as possible and get rid of floating point numbers as much as possible. <br><br><h5>  Soft jagged effect </h5><br>  I invented this effect myself (and perhaps invented a bicycle - I don‚Äôt know).  But the name he had better come up with failed - sorry.  What is similar to the effect of posterization in Photoshop, only it not only cuts the palette, but also smooths the transitions.  I will try to portray its essence in the form of a graph: <br>  It is necessary to convert a straight line linear gradient graph into a kind of ladder with smoothed corners. <br><img src="https://habrastorage.org/storage2/885/d56/8f8/885d568f808dbded015eb4c2ae8808bc.png"><br>  To do this, take the intensity value of the color of the current pixel, divide it by the number of iterations (steps).  We remember the integer part and the remainder of the division.  From the remainder we subtract half of its maximum diazon and multiply by the coefficient of smoothness.  The resulting number is added back to the integer part.  Oh, easier to show in the code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ProceduralTexture::postEffect(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *img, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iterations, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> smooth){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)img[i]/<span class="hljs-number"><span class="hljs-number">255.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ds = s*(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)iterations-(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(s*iterations)); ds = smooth*(ds<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>)+<span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ds&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) ds = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ds&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) ds = <span class="hljs-number"><span class="hljs-number">0</span></span>; s = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(s*(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)iterations))+ds)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)iterations; img[i] = s*<span class="hljs-number"><span class="hljs-number">255</span></span>; } }</code> </pre><br>  The function takes as input a pointer to an image that needs to be converted, the number of iterations and the degree of smoothness.  To feel exactly how this image filter changes, I will give an example: <br>  the number of iterations is always five.  The degree of smoothness from left to right: 1, 1.5, 2.5 <br><img src="http://habrastorage.org/storage2/f25/070/e18/f25070e182eb2350dffc8649c375284f.png"><img src="http://habrastorage.org/storage2/a15/a7e/ee9/a15a7eee973f14792da8a16335c6e0f0.png"><img src="http://habrastorage.org/storage2/41b/822/04a/41b82204a78758e307bd8cec6fc6831d.png"><br>  By the way, this filter is used in the second picture in the post title. <br><br><h5>  Mixing </h5><br>  A blend filter is required to combine two images.  For example, cellular texture and noise of pearl.  Mixing can be implemented in many different ways.  I did as follows: <br>  When mixing, the valueTest parameter is indicated - this number characterizes the intensity of the pixel above which it (the pixel) is not processed.  The opacity parameter is also indicated - the transparency itself when blending. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ProceduralTexture::mix(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *img1, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *img2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> valueTest, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> opacity){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (img2[i]&lt;=valueTest){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = img2[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = img1[i]; b = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)b/valueTest)*<span class="hljs-number"><span class="hljs-number">255.0f</span></span>; r = r-(<span class="hljs-number"><span class="hljs-number">255</span></span>-b)*opacity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) r = <span class="hljs-number"><span class="hljs-number">0</span></span>; img1[i] = r; } }</code> </pre><br></div></div><br><br><h5>  Colour </h5><br>  Each pebble has its own unique color.  But in general, all these colors are similar to each other.  For example, pebbles can be called green or brown, but among them there will be many different shades of green or brown.  The RGB palette for such purposes is not very suitable, as it is difficult for her to command ‚Äúgive all shades of a gray-brown-crimson color in the range of, say, 10%‚Äù.  Therefore, I chose the <a href="http://ru.wikipedia.org/wiki/HSV_(%25D1%2586%25D0%25B2%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C)">HSV</a> palette.  Through it is convenient to set the color: the brightness of the stones, saturation and hue.  You can also specify a hue range.  So, for example, if I need shades of yellow, I can set the hue component to 60 plus or minus 10. In the RGB palette, I would have to tinker with all the channels. <br>  However, when using the HSV model, there is a need for color conversion - because in the final image we have an RGB model.  Taking the algorithm from the same wiki, we will write the code: <br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> ColorRGB ProceduralTexture::hsvToRgb(ColorHSV &amp;hsv){ ColorRGB rgb; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hsv.s){ hsv.h %= <span class="hljs-number"><span class="hljs-number">360</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hsv.h&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) hsv.h += <span class="hljs-number"><span class="hljs-number">360</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = hsv.h/<span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)hsv.h/<span class="hljs-number"><span class="hljs-number">60.0f</span></span>)-(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)i; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c1 = (hsv.v*(<span class="hljs-number"><span class="hljs-number">100</span></span>-hsv.s))*<span class="hljs-number"><span class="hljs-number">0.0255f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c2 = (hsv.v*(<span class="hljs-number"><span class="hljs-number">100</span></span>-hsv.s*f))*<span class="hljs-number"><span class="hljs-number">0.0255f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c3 = (hsv.v*(<span class="hljs-number"><span class="hljs-number">100</span></span>-hsv.s*(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>f)))*<span class="hljs-number"><span class="hljs-number">0.0255f</span></span>; hsv.v *= <span class="hljs-number"><span class="hljs-number">2.55f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: rgb.r = hsv.v; rgb.g = c3; rgb.b = c1; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: rgb.r = c2; rgb.g = hsv.v; rgb.b = c1; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: rgb.r = c1; rgb.g = hsv.v; rgb.b = c3; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: rgb.r = c1; rgb.g = c2; rgb.b = hsv.v; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: rgb.r = c3; rgb.g = c1; rgb.b = hsv.v; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: rgb.r = hsv.v; rgb.g = c1; rgb.b = c2; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> rgb.r = rgb.g = rgb.b = hsv.v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rgb; }</code> </pre><br></div></div><br><img src="http://habrastorage.org/storage2/ad4/adb/c07/ad4adbc07a9ee2f348274ec03540af45.png" align="right"><br>  It now remains to write the function of painting the pebbles.  I just overloaded the mesh generation function.  In fact, the whole filling is reduced to the fact that we, when generating the initial set of random points, assign them a color. <br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ColorRGB *ProceduralTexture::generateCelluarTexture(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size, ColorHSV color, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hueRange){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>) size = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellX = w/size+<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellY = h/size+<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointsX[cellX][cellY]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointsY[cellX][cellY]; ColorRGB cellColor[cellX][cellY]; srand(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;cellX; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;cellY; j++){ pointsX[i][j] = i*size+rand()%((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(size*<span class="hljs-number"><span class="hljs-number">0.7</span></span>))+size*<span class="hljs-number"><span class="hljs-number">0.15</span></span>-size; pointsY[i][j] = j*size+rand()%((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(size*<span class="hljs-number"><span class="hljs-number">0.7</span></span>))+size*<span class="hljs-number"><span class="hljs-number">0.15</span></span>-size; } color.h -= (hueRange/<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;cellX; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;cellY; j++){ ColorHSV c = color; ch += rand()%hueRange; cellColor[i][j] = hsvToRgb(c); } ColorRGB *img = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColorRGB[n]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = i%w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = i/w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> px = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> py = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> min = INT_MAX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startX = x/size; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> finishX = startX+<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; startX&lt;finishX; startX++){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startY = y/size; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> finishY = startY+<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; startY&lt;finishY; startY++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startX&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || startX&gt;=cellX || startY&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || startY&gt;=cellY) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d = distance(x, y, pointsX[startX][startY], pointsY[startX][startY]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d&lt;min){ px = startX; py = startY; min = d; } } } img[i] = cellColor[px][py]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> img; }</code> </pre><br></div></div><br><br><h5>  Normal map </h5><br>  To give relief, I wrote a shader, which using a texture and a normal map creates a picture that you saw in the post title.  A normal map can be generated from the source image.  To do this, I calculate the difference between adjacent pixels - this is the angle of deviation of the normal.  After going through all the pixels, finding the minimum and maximum angle I normalize them (angles). <br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ProceduralTexture::generateNormalMap(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *img){ normalMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColorRG[n]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxR = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxG = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = i%w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = i/w; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dr = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)img[y*w+x<span class="hljs-number"><span class="hljs-number">-1</span></span>]-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)img[y*w+x]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dr&gt;maxR) maxR = dr; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dg = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)img[(y<span class="hljs-number"><span class="hljs-number">-1</span></span>)*w+x]-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)img[y*w+x]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dg&gt;maxG) maxG = dg; } } maxR *= <span class="hljs-number"><span class="hljs-number">2</span></span>; maxG *= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = i%w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = i/w; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">127</span></span>+(((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)img[y*w+x<span class="hljs-number"><span class="hljs-number">-1</span></span>]-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)img[y*w+x])*<span class="hljs-number"><span class="hljs-number">255</span></span>)/maxR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r&gt;<span class="hljs-number"><span class="hljs-number">255</span></span>) r = <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) r = <span class="hljs-number"><span class="hljs-number">0</span></span>; normalMap[y*w+x].r = r; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">127</span></span>-(((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)img[y*w+x+<span class="hljs-number"><span class="hljs-number">1</span></span>]-(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)img[y*w+x])*<span class="hljs-number"><span class="hljs-number">255</span></span>)/maxR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r&gt;<span class="hljs-number"><span class="hljs-number">255</span></span>) r = <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) r = <span class="hljs-number"><span class="hljs-number">0</span></span>; normalMap[y*w+x].r = r; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g = <span class="hljs-number"><span class="hljs-number">127</span></span>+(((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)img[(y<span class="hljs-number"><span class="hljs-number">-1</span></span>)*w+x]-img[y*w+x])*<span class="hljs-number"><span class="hljs-number">255</span></span>)/maxG; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g&gt;<span class="hljs-number"><span class="hljs-number">255</span></span>) g = <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) g = <span class="hljs-number"><span class="hljs-number">0</span></span>; normalMap[y*w+x].g = g; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g = <span class="hljs-number"><span class="hljs-number">127</span></span>-(((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)img[(y+<span class="hljs-number"><span class="hljs-number">1</span></span>)*w+x]-img[y*w+x])*<span class="hljs-number"><span class="hljs-number">255</span></span>)/maxG; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g&gt;<span class="hljs-number"><span class="hljs-number">255</span></span>) g = <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) g = <span class="hljs-number"><span class="hljs-number">0</span></span>; normalMap[y*w+x].g = g; } } }</code> </pre><br></div></div><br><img src="http://habrastorage.org/storage2/0b4/93b/bed/0b493bbed1eb57558cceadbf7485fb80.png" align="right"><br>  And here is the shader itself.  For clarity, I made point lighting in the position of the mouse cursor (in the pictures in the title, the mouse cursor was in the upper left corner <br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// varying vec4 texCoord; void main(){ gl_Position = gl_ModelViewProjectionMatrix*gl_Vertex; texCoord = gl_MultiTexCoord0; } // uniform sampler2D colorMap; uniform sampler2D normalMap; varying vec4 texCoord; uniform vec2 light; uniform vec2 screen; uniform float dist; void main() { vec3 normal = texture2D(normalMap, texCoord.st).rgb; normal = 2.0*normal-1.0; vec3 n = normalize(normal); vec3 l = normalize(vec3((gl_FragCoord.xy-light.xy)/screen, dist)); float a = dot(n, l); gl_FragColor = a*texture2D(colorMap, texCoord.st); }</span></span></code> </pre><br></div></div><br><br><h4>  Glue it all together </h4><br>  I applied the above functions in the following order: <br>  - creation of cellular texture <br>  - applying brightness / contrast filter <br>  - creating texture with the noise of the pearl <br>  - application of effect of gradation to perlin noise <br>  - applying a brightness / contrast filter to perlin noise <br>  - mixing of cellular texture and perlin noise <br>  - create normal map <br>  - coloring <br>  Each of the steps described has its own input parameters.  By changing them you can get a huge amount of unique textures. <br><br><h4>  But what about the seamless texture? </h4><br>  Honestly, I wanted to make the ability to create a seamless texture.  But for some reason it was lazy.  The recipe is simple: when generating a cellular texture, when searching for distances at the borders, you need to use points from the opposite side of the texture.  And when generating noise perlin ... if you honestly did not even think.  Probably something similar. <br><br><h4>  Few optimizations.  It was worth it? </h4><br>  In fact, the initial implementation of the code worked rather slowly, there were a lot of floating-point numbers, unnecessary iterations and calculations.  All I did was, if possible, endure the calculations and translate into numbers with a fixed point.  As a result, the performance between the original version and the current version has grown about 10 times.  There was an idea to parallelize the algorithm, but because of the suspicion that everything depends on the work with memory, I threw this idea away. <br><br><h4>  Source </h4><br>  The main class to generate is called ProceduralTexture.  I tried to write more or less beautifully, how much a 5th year student can do.  All the rest is a body kit, the interface part is needed only for demonstration.  Beautifully, I did not really try to write there. <br>  <a href="https://github.com/Torvald3d/TexGen">source code</a> <br><br><div class="spoiler">  <b class="spoiler_title">Some more examples</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage2/99e/f54/0ea/99ef540eab24efa97968ac48ab2779b3.png"><br><img src="http://habrastorage.org/storage2/207/f5f/d8a/207f5fd8ad97ce2a003d1349b4c32a5a.png"><br><img src="http://habrastorage.org/storage2/35c/978/8cf/35c9788cf89e8e1ab28be19a15ee926e.png"><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/182346/">https://habr.com/ru/post/182346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182334/index.html">Meet Magento Russia 2013 Conference</a></li>
<li><a href="../182338/index.html">Intel will introduce Tizen for developers at DevConf 2013 - June 14</a></li>
<li><a href="../182340/index.html">F * - new language with dependent types for .Net</a></li>
<li><a href="../182342/index.html">The evolution of altruism and P2P</a></li>
<li><a href="../182344/index.html">About proteins and complex networks</a></li>
<li><a href="../182348/index.html">Experience with AngularJS on the example of a game project</a></li>
<li><a href="../182352/index.html">Pitfalls of using sessions in PHP</a></li>
<li><a href="../182354/index.html">Xamarin + PCL + MVVM - how to facilitate writing mobile applications for different platforms</a></li>
<li><a href="../182356/index.html">Optimization options in C and C ++ languages</a></li>
<li><a href="../182358/index.html">Speaker Cheat Sheet, or How I Gave My First Report</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>