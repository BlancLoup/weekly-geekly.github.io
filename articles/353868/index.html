<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Map matching and processing of raw GPS data on an industrial scale</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Any measuring device, whether analog or digital, shows the result with a certain error and noise. The error of the GPS sensor is determined by the err...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Map matching and processing of raw GPS data on an industrial scale</h1><div class="post__text post__text-html js-mediator-article"><p>  Any measuring device, whether analog or digital, shows the result with a certain error and noise.  The error of the GPS sensor is determined by the error of the sensor itself and by factors such as: landscape, movement speed, number and position of satellites. </p><br><p>  In <a href="https://remoto.com/">our application,</a> we give the user the opportunity to view in detail the routes of his travels.  And if you display raw, not filtered data, it turns out that the route passes not along the road, but through buildings or water, some points of the route are very far from the neighboring or even there are no pieces of the route. </p><br><img src="https://habrastorage.org/webt/y1/ux/x_/y1uxx_56i6xqoctx02ys1gshxky.png"><br><p>  I think it is no secret that there are solutions on the market that provide the Map matching service.  It performs the processing of coordinates and as a result gives the coordinates attached to the road.  However, no service will understand the specifics of your data, and the result of processing raw data may not be the best.  In this regard, we developed a solution that allowed us to filter and impose sensor data on the roads as much as possible. </p><a name="habracut"></a><br><h2>  Input data </h2><br><p>  At the time of development, the OBD-dongle transmitted telematic data to the server in the form of points, each of which had the following parameters: </p><br><ul><li>  Coordinates obtained from the GPS sensor; </li><li>  The speed received from the car; </li><li>  Engine speed obtained from the car; </li><li>  Time specific point. </li></ul><br><p>  The points were transmitted according to the following algorithm - every 3 seconds or every 20 meters.  Note that the transfer algorithm is not perfect, but within the framework of a specific problem we decided not to change it, because  Obviously, if you transfer points using a more advanced algorithm, the result will only improve.  Also, the dongle collected such data as: heading (motion vector) and dilution of precision (roughly speaking, GPS accuracy), but this data was not transmitted to the server. </p><br><h2>  Algorithm </h2><br><p>  The algorithm that we used can be divided into two parts: </p><br><ul><li>  Data filtering; </li><li>  Map matching; </li><li>  Partial processing. </li></ul><br><p>  <b>Filtration</b> </p><br><p>  No one knows the specifics of your data better than you.  We decided to use our knowledge and filter the data on the side of our own service.  Let's look at a simple route example: </p><br><img src="https://habrastorage.org/webt/uk/3k/na/uk3knababz8gmnky1d43nbrhby0.png"><br><p>  The graph shows the speed of the car, received by the dongle from the car, and the speed calculated from the GPS.  As you can see, there are a lot of emissions on the graph - both upwards and downwards.  Standard filtering algorithms immediately come to mind: Kalman filter, alpha-beta filter.  For them, we undertook in the first place.  However, these filters did not perform well.  There were several reasons for this: low frequency and absolute heterogeneity of data (it is difficult to choose a single modified algorithm with a suitable error), the presence of transformations of incoming data was unacceptable.  Much better during testing showed a very simple linear velocity filter.  The essence of the algorithm is very simple: for all neighboring points, we calculate the speed using GPS and compare it with the speed obtained from the car, and if the differences are higher than the permissible error, then we throw out one of the points. </p><br><p>  Here is the pseudocode: </p><br><pre>  `for i in range (1, len (data)):
    velocity_gps = calc_dist (data [i - 1] .lat, data [i - 1] .lon, data [i] .lat, data [i] .lon) / (data [i] - data [i - 1])
    velocity_vehicle = (data [i - 1] .speed + data [i] .speed) / 2
    relative_error = abs (velocity_gps - velocity_vehicle) / (velocity_vehicle)
    if relative_error&gt; 1.5:
       data.remove (data [i]) ` </pre><br><p>  As a result of filtering, we obtain data without emissions, while points still do not fall on the road.  However, before the Map matching procedure, it‚Äôs worth to thin our data,  It makes no sense to transfer 10 points lying on one line, when two points are enough to define a line.  However, you don‚Äôt have to be zealous with filtering, for the Map matching service can count our data as noise.  To remove the extra points, we used the Ramer-Douglas-Peucker algorithm, or rather its slightly modified version. </p><br><img src="https://habrastorage.org/webt/q_/qz/jl/q_qzjlvfnruhja2w0ymi3c1rgy4.png"><br><p>  For a time-ordered pack of points, we calculate the distance for all points to the arc connecting the first and last points of the pack.  If the distance from each point is less than some value of E, then only the starting and ending points of the pack are returned.  Otherwise we divide the pack into two, division occurs at the point as far as possible from the arc, and then repeat the procedure. </p><br><p>  <b>Map matching</b> </p><br><p>  Due to the fact that the maps for our mobile applications and portals are provided by the Mapbox service, it was decided to use their Map matching service.  But we immediately faced a limitation - 100 points in the query.  Even taking into account filtering and reducing the number of points by the RDP algorithm, the average number on our routes is 250 points.  Accordingly, we need to handle batch files (batch), plus everything overlap, since  in some cases, with simple batching, processing errors will occur.  The batching algorithm is as follows: </p><br><ul><li>  N - the number of points for processing overlap; </li><li>  Cut the route into batches of no more than 100-N; </li></ul><br><img src="https://habrastorage.org/webt/r3/_a/c9/r3_ac98fgowo8tjv6ec2yllk-by.png"><br><ul><li>  Then we process the first batch; </li><li>  We take the last N points of processed data and the second batch; </li><li>  We continue to the last batch; </li></ul><br><img src="https://habrastorage.org/webt/_i/ab/tg/_iabtg_62cdccwjpqdjnsprld0y.png"><br><ul><li>  The end result consists of Processed1, Processed2, Processed3, Processed4. </li></ul><br><img src="https://habrastorage.org/webt/xo/3a/pf/xo3apfuvznub9rrvktbpwx8ueus.png"><br><p>  The next problem we encountered was the determination of the accuracy of the data.  The Mapbox API requires you to specify the accuracy of the data being transferred, even though this parameter is specified as optional in the document.  And if not to transfer it, it will be exposed from default value.  The parameter responsible for accuracy is gps_precision.  This is what the documentation says about it: </p><br><p>  <i>The used tracking device.</i>  <i>Use higher numbers (5-10) for noisy traces and lower numbers (1-3) for clean traces.</i>  <i>The default value is 4.</i> </p><br><p>  However, we did not transmit this data from the dongle at the time of developing the service.  Due to the rare frequency of the data, the use of noise level determination algorithms was impossible.  Thus, we processed a certain number of routes and tried to find the most suitable parameters.  But how to choose the best option for 1000 routes?  Manually doing it is impractical.  It turned out that this process can be automated due to the specificity of the results with the unsuccessfully chosen parameter.  If you select too low a parameter value, pieces of the route may disappear, and if you overstate a parameter, then extra loops will appear. </p><br><img src="https://habrastorage.org/webt/pn/po/m1/pnpom1kr9zr7zo0m8oz2bgrhr5i.png"><br><p>  The <a href="https://en.wikipedia.org/wiki/Dynamic_time_warping">DTW algorithm</a> is well suited to detect such cases.  As a result of processing 1000 routes and comparing the results of work using the DTW algorithm, it became clear that the best results are obtained with the values ‚Äã‚Äãof precision 3, 6, 10 (in different cases). <br>  As a result, in the absence of GPS data on accuracy, we launched processing in parallel with three different gps_precision (3,6,10), and then chose the best of them.  It was also planned to add a shipment of the dilution parameter from the dongle, which made it possible to greatly improve the quality of service. </p><br><p>  <b>Partial processing</b> </p><br><p>  The end points of the routes are often in places where the road is not marked on the map (parking, paths between houses, etc.).  Algorithms Map matching in such situations do not work very well, and I would like to specify as precisely as possible where the user left his car.  To solve this problem, we began to perform a cycle of processing not the entire route, but only internal points: we discard the beginning and end of the route, then add the beginning and end of the original route to the processed data.  The beginning and the end are defined as follows: we take 5% of the route or a part before the speed of the car becomes more than 10 km / h. </p><br><h2>  Final result </h2><br><p>  In the end I would like to demonstrate the result of processing routes.  As a result, <a href="https://remoto.com/consumer-services/">routes</a> pass almost everywhere along the roads, loud noises have disappeared, the missing pieces of routes have been restored (riding on a ring or a bridge). </p><br><img src="https://habrastorage.org/webt/7_/p3/96/7_p3963r_xsbd95wdohqmjkbtre.png"><br><img src="https://habrastorage.org/webt/hq/2b/vg/hq2bvglm2rrrfeq_r6mz781pvly.png"><br><p>  Author: Kirill Kulchenkov, <a href="https://habr.com/users/kulchenkov32/" class="user_link">kulchenkov32</a> , Senior Software Developer, Bright Box. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/353868/">https://habr.com/ru/post/353868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353856/index.html">Comparison of LAN scanning tools</a></li>
<li><a href="../353858/index.html">Open free webcast of the conference Mobius 2018 Piter</a></li>
<li><a href="../353862/index.html">Conference SMARTRHINO-2018</a></li>
<li><a href="../353864/index.html">Different facets of a digital enterprise</a></li>
<li><a href="../353866/index.html">A little about physics in almost Agar IO on aicups.ru</a></li>
<li><a href="../353870/index.html">Telecom's digital transformation, or how operators ‚Äúgo‚Äù to IT</a></li>
<li><a href="../353872/index.html">Hybrid Storage for Out-of-the-House Homes and High Availability from Synology</a></li>
<li><a href="../353876/index.html">Configure Sublime Text 3 to work with VHDL files</a></li>
<li><a href="../353878/index.html">How to hide DNS requests from the prying eyes of the provider</a></li>
<li><a href="../353880/index.html">Telegram and AWS Blocking - Morning does not start with coffee</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>