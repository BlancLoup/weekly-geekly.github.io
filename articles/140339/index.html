<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing compiler LALR (1) -parser. LR Generator Description</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 Good day. 
 This is the second part of an article about writing your own LALR analyzer. In this part I will talk about the evolution from p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing compiler LALR (1) -parser. LR Generator Description</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  Good day. <br>  This is the second part of an article about writing your own LALR analyzer.  In this part I will talk about the evolution from primitive ascending parsers to the most relevant, though not very new, LALR parsers.  Those who have not read the first article (links - below), I advise you to read at least the first half of the last section.  I will mention that little code snippet several times. <br><br>  In the comments to the last article, several people were interested in my motives in writing their own compiler compilers.  Unfortunately, they in this article will not find answers to this question.  I will not hide, initially I planned to write an article without a special theory, but with the justification of the tasks and goals for which I began to write a generator, and I wanted to share the nuances and peculiarities of implementation.  That is, the volume is pretty decent: a few screens.  But then I decided to still describe the basic theory of populist language, so the article has grown to three parts.  Thus, in order not to break the logic of presentation, I will first talk about LR / SLR / LALR analyzers, and tomorrow I will publish the final, and I think the most interesting part. <br><a name="habracut"></a><br><br><h4>  Why do we need evolution? </h4><br>  If you look at the primitive code of the example in the last part, you can see that the complexity of the algorithm is calculated as O (n), where n is the number of input characters.  I have to say that this is a very good estimate for algorithms.  For example, for the fastest sorting, the complexity is O (n * log (n)).  However, what does this statement about the complexity of the algorithm mean?  And it means that we will have to perform not n operations, but at least C * n, where C is a constant.  For this example, the constant is very large - the sum of the lengths of all the rules, and can easily be equal to 100, and 1000, and 10,000. That is, for a string of 10 characters, we will spend one hundred thousand operations.  But this is very bad. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      That's why we need to improve the algorithm of the parser itself.  The basic idea is to know at which step this symbol, together with a number of previous ones, can lead to convolution (replacing the last K characters, including already minimized non-terminals, into one non-terminal), and in which - to transfer, that is, the definition of where this terminal took its position.  Roughly speaking, if there are rules A = 012 and B = 021, then line 01 will lead to transfer for rule A, 02 - to transfer according to rule B, and 012 - to convolution according to rule A. This idea will bring the above-mentioned constant C to 1 It is easy to see that this scheme fits very well with the concept of FSM (finite automata).  To put it simply, this is a two-dimensional table that, by the number of the current state and the incoming symbol, gives a new state number.  And so on until we reach the final state. <br><br><h4>  FSM states </h4><br>  OK well.  I think it is obvious that the states should display the current position of the symbol in the rules - for the above examples A and B with previously read characters 0, 1 the state can be described as "we have already read the first 2 characters from the 3 rules of A".  If we add the rule C = 013, then the state will be less specific: ‚Äúwe have already read the first 2 characters from 3 A or C‚Äù.  And then everything will depend on the next symbol - 2 or 3. If 2 arrives, then we go to the state ‚Äúwe read 3 symbols from 3 A‚Äù and then we arrange convolution - turning 012 into symbol A. For 3 and C respectively - it is similar.  This should be clear. <br><br>  In addition, we need to determine where to start and when to stop.  In this example, the beginning is ‚ÄúWe have read 0 characters from 3x A or B or C‚Äù.  The ending is also kind of clear - 3 possible states ‚Äú3 out of 3x‚Äù for A / B / C.  That is, when a convolution occurs according to one of the rules, we stop.  However, if it works for a primitive, then it is worth a little more complicated, and everything breaks down. <br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">A</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> A | <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre>  Such a grammar specifies m zeros and then 1 at the end, that is, for example, "0000001".  What is the difficulty?  And the fact that we can no longer determine when to stop.  That is, if we stop at convolution A, then we immediately follow the first convolution (when we read Terminal 1, convolve it in A) and stop, and at the same time we will not draw even m convolutions (according to rule A = 0 A).  Therefore, when developing a grammar, a restriction is imposed on the presence of one starting symbol to which the grammar will be assembled.  S = A |  B |  C. But besides this, the special character S 'and the rule S' = S are automatically added to the parser and then in case of convolution of this rule we will know that the mission has been completed, you can go home.  Thus, we simultaneously determined both the initial state - ‚Äúwe considered 0 characters from 1 by the rule S '‚Äù, and the final one. <br><br>  Now is the time to think about state coding.  Well, we will not write our wishes and expectations in plain text.  The analyzer simply does not understand us.  We need to think about the machine representation of the above-used maxims.  In fact, it can be easily seen if we compare them with each other.  They contain only 2 defining moments - the rule and the current position in this rule.  And, as can be seen from the examples, the state may contain several such sets.  The sets themselves in the classics are called items.  And they look like this: A = 01 ¬∑ 2, that is, read 2 characters in rule A = 012. <br><br><h4>  FSM table </h4><br>  It remains only to set the FSM itself and the parser is actually ready.  The table of transitions between states is constructed very simply - convolution is determined when we encounter a state containing a rule with all the characters read.  That is, the marker (¬∑) stands at the very end.  In addition, since the columns in the table are specified by the current symbol, we must find out all the possible terminals that can follow after the collapsible symbol.  If a convolution has formed, but then the symbol follows, well, who could not find it in the general logic of grammar, then this is a mistake.  Example: <br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#start A A = B 2 B = 01</span></span></code> </pre><br>  Here, during the convolution of B, we have to check that 2 follows, and not any other character.  I think the logic of calculation of this set is clear, and if not, then the pseudo-algorithm will be below.  In addition to this point, when convolving it is necessary to take into account what needs to be tracked according to which parental rule is being analyzed.  That is, after all, the symbol for convolution can easily participate in several rules, and we need to clearly know which rule is currently undergoing this operation in order to go to the appropriate state.  This is solved by maintaining the state stack.  When shifting (receiving the terminal and changing the state), we push the state number onto the stack.  And when convolving, we extract from the stack L elements, where L is the length of the right side of the expression (a set of elements that collapse into one non-terminal).  And we put the index of the new state, which is determined by the same FSM table, with the column number equal to the non-terminal of the left part of the collapsed rule and the row number - the state at the top of the stack.  It may sound cumbersome, but in fact everything is simple.  I will illustrate the work of the algorithm on the above grammar. <br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">0.</span></span>  <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1.</span></span> ,  s0 {A = ¬∑ B <span class="hljs-number"><span class="hljs-number">2</span></span>},  {<span class="hljs-number"><span class="hljs-number">0</span></span>}  <span class="hljs-number"><span class="hljs-number">2.</span></span> ,   = [s0, <span class="hljs-number"><span class="hljs-number">0</span></span>] = s1 {B = <span class="hljs-number"><span class="hljs-number">0</span></span> ¬∑ <span class="hljs-number"><span class="hljs-number">1</span></span>} ,  {<span class="hljs-number"><span class="hljs-number">0</span></span>},  <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">3.</span></span> ,   = [s1, <span class="hljs-number"><span class="hljs-number">1</span></span>] = s2 {B = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ¬∑} ,  {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>},  <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">4.</span></span> ,   [s2, <span class="hljs-number"><span class="hljs-number">2</span></span>]     (<span class="hljs-number"><span class="hljs-number">2</span></span> -  ),   = [s2, <span class="hljs-number"><span class="hljs-number">2</span></span>] = s3 {A = B ¬∑ <span class="hljs-number"><span class="hljs-number">2</span></span>},  {B}  <span class="hljs-number"><span class="hljs-number">5.</span></span> ,   = [s3, <span class="hljs-number"><span class="hljs-number">2</span></span>] = s4 {A = B <span class="hljs-number"><span class="hljs-number">2</span></span> ¬∑} ,  {B, <span class="hljs-number"><span class="hljs-number">2</span></span>},  EOF (   )  <span class="hljs-number"><span class="hljs-number">6.</span></span> ,   = [s4, EOF] = s5 {S = A ¬∑},  {A}  <span class="hljs-number"><span class="hljs-number">7.</span></span> ,   = [s5, EOF] = s6  {S},  ,       ,      </code> </pre><br><br>  We figured out the convolution, but it is still unclear how we determine the transitions between states and where they come from.  But everything is resolved trivially - we simply iterate over all the available characters (terminals and non-terminals), applying to the current analyzed state.  If it contains an item of the form {A = ... ¬∑ X ...}, where X is an inline character, then we move the marker (this is exactly the use of the character X) and we get the point of the new state {A = ... X ¬∑ .. .}.  Of course, if we have several such items for X, then the new state will also contain several entries.  In addition, during this process we build the required FSM: [sOld, X] = sNew.  This is almost a finished line of the table.  It is only necessary to add convolution elements to it. <br><br>  Another important point.  Again, if we turn to the last example, it is clear that from the starting state {A = ¬∑ B 2} you can get only {A = B ¬∑ 2} and [s0, B] = sX.  But this is not true and will never work.  Just because at the input of the starting state we will not get a non-terminal (B), but only an input terminal (0, 1, 2).  In order to ensure the operation of the algorithm, it is necessary to take into account possible reversals (the operation is inverse to convolution).  That is, in this case, from the grammar, we see that it is possible to expand B and conditionally speaking {A = ¬∑ 0 1 2}, which fully corresponds to the logic.  Formalizing what I described can be written as: ‚Äúif the state contains {X = ... ¬∑ Y ...}, then it should contain items of the form {Y = ¬∑ ...}‚Äù.  This expansion process is called closure. <br><br>  Everything, now the theory is enough for drawing up both the FSM generation algorithm and the FSM-based analyzer itself.  Pseudocode built: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*      ,      */</span></span> <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstTerminal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (X.type == Terminal) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X; result = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (rule in rules) { <span class="hljs-comment"><span class="hljs-comment">//  X = Y ... if (rule.left == X) { //  , first(Y) result[] = first(rule.right[0]) } } return result; } //    ,     function nextTerminal(X) { result = []; for (rule in rules) { //  Y = ... X if (rule.right.end(X)) { /*   X   Y,   X     ,    Y */ result[] = nextTerminal(rule.left); } else { //  Y = ... X ... if (rule.right.has(X)) { //         result[] = firstTerminal(rule.right.next(X)); } } } return result; } //  function closeItem(I) { for (item in I) { //      Y = ... ¬∑ X ..., X   if (item.markered.type == NonTerminal) { for (rule in rules) { //  X = ... if (rule.left == item.markered) { //   X = ¬∑ ... I[] = {rule: rule, marker: 0}; } } } } } //        FSM function addReducing(I, FSM) { for (item in I) { //  X = ... ¬∑ if (item.markered == item.end) { //     S = A,  A -   if (item.rule.left == _START_) { //   ,    ,    FSM[I.index, EOF] = Success; } else { //    ,      for (term in nextTerminal(item.rule.left)) { /* rule      :           */ FSM[I.index, term] = {operation: Reduce, rule: item.rule}; } } } } } //     I    X function shiftState(I, X) { result = []; for (item in I) { //  Y = ... ¬∑ X ... if (item.markered == X) { //      result[] = {rule: item.rule, marker: item.marker + 1}; } } return closeItem(result); } //    function buildFSM() { FSM = {}; //     S = ¬∑ A states = [closeItem({rule: {S = A}, marker: 0})]; for (state in states) { //      addReducing(state, FSM); for (X in symbols) { new = states[] = shiftState(state, X); //   FSM[state.index, X] = {operation: Shift, index: new.index}; } } }</span></span></code> </pre><br>  Algorithm code: <br><pre> <code class="hljs bash">input &gt;&gt; term; accepted = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; /*   0 ,      ,   ==   */ stack = [0]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!accepted) { //   - stack.top() state = FSM[stack.top(), term]; switch (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Success: accepted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Shift: //      stack.push(state.index); input &gt;&gt; term; <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Reduce: //  L  stack.pop(state.rule.right.length); // state.rule.left -     // stack.pop() -  ,   X stack.push(FSM[stack.pop(), state.rule.left]); //     {..., Y, ..., Z}  {..., X}   X = Y ... Z <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; default: throw SyntaxError; } }</code> </pre><br><br><h4>  Further improvement of the algorithm.  SLR (1) </h4><br>  We got a fairly fast and good algorithm, but there is one flaw in it that is difficult to detect.  It lies in the imperfection of the definition of the symbol that comes after the collapsing non-terminal (function nextTerminal).  A small example: <br><pre> <code class="cpp hljs">A = B <span class="hljs-number"><span class="hljs-number">2</span></span> | C B = C <span class="hljs-number"><span class="hljs-number">0</span></span> | <span class="hljs-number"><span class="hljs-number">1</span></span> C = B States: S0: [{S = ¬∑ A}, {A = ¬∑ B <span class="hljs-number"><span class="hljs-number">2</span></span>}, {A = ¬∑ C}, {B = ¬∑ C <span class="hljs-number"><span class="hljs-number">0</span></span>}, {B = ¬∑ <span class="hljs-number"><span class="hljs-number">1</span></span>}, {C = ¬∑ B}] S1: [{S = A ¬∑}],   S0   A S2: [{A = B ¬∑ <span class="hljs-number"><span class="hljs-number">2</span></span>}, {C = B ¬∑}],   S0   B ... SX: [{A = B <span class="hljs-number"><span class="hljs-number">2</span></span> ¬∑}],   S2   <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre>  The grammar describes strings of the form 10 ... 02 and 10 ... 0.  nextSymbol = [0, 2, EOF].  And then we get that for FSM [S2, 2] we have to do a convolution according to the rule C = B, but at the same moment according to the rule A = B2, we have to do the transfer to SX via the same terminal 2 for the state S2 .  It is sad.  This happened because in the S2 state for the C = B item we have to wait only for EOF, based on A = C EOF, and no 2 or 0. They can appear only in the future. <br><br>  Yes.  This is a synthetic example, but in reality there are grammars with such traps.  Moreover, not so rare.  The solution is obvious - the determination of the points generating the convolution, by the expected symbol.  That is, {C = B ¬∑} transforms conditionally into {C = B ¬∑ [expect EOF]} or, for short, {C = B ¬∑, EOF}.  Only 2 points are affected - the generation of points (it is necessary to create points of a new format) and the generation of cells with convolution.  That is, only 2 functions closeItem () and addReducing (): <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  function closeItem(I) { for (item in I) { //      Y = ... ¬∑ X ..., X   if (item.markered.type == NonTerminal) { for (rule in rules) { //  X = ... if (rule.left == item.markered) { // X -   if (item.nextMarkered == item.end) { //       first = item.expect; } else { //        first = firstTerminal(item.nextMarkered); } //     for (expect in first) { //   X = ¬∑ ... I[] = {rule: rule, marker: 0, expect: expect}; } } } } } } //        FSM function addReducing(I, FSM) { for (item in I) { //  X = ... ¬∑ if (item.markered == item.end) { //     S = A,  A -   if (item.rule.left == _START_) { //   ,    ,    FSM[I.index, EOF] = Success; } else { /*      ,       */ FSM[I.index, item.expect] = {operation: Reduce, rule: item.rule}; } } } }</span></span></code> </pre><br><br><h4>  Vertex - LALR (1) </h4><br>  The disadvantage of the previous algorithm is noticeable to the naked eye ‚Äî where we used 1 point and 1 state, now there are several points and several states that differ only in the expected symbol.  Accordingly, the FSM table swells, and so much so that its size can be a couple of orders of magnitude greater than the corresponding table LR (0).  Not good. <br><br>  Finding a way out is easy - we combine states that differ only in the expected symbol.  For example: [{A = B, 0}, {B = C, 0}] and [{A = B, 1}, {B = C, 1}].  Why is it safe? <br><ol><li>  When building a new state during the transition, we do not use the expect character at all, so if s0 and s1 are identical in the core (part of the item except for the expected character), then s2 generated by X from s0 and s3 generated by X from s1 are also identical by core .  Thus, we can easily combine s0 and s1 into sn0, s2 and s3 into sn1, and create a connection between them.  This is completely correct. </li><li>  The second part of the FSM table is convolutions.  But here it is obvious that they, by definition, cannot intersect, since in states different expect-characters, then convolutions are written only in 1 cell for the corresponding expect-character.  And they can be painlessly combined. </li></ol><br><br>  So in the end we get the same LR (0), but without the restriction of grammar. <br><br><h4>  Parts of the article </h4><br><ol><li>  <a href="http://habrahabr.ru/post/140058/">Part 1. Basic theory</a> </li><li>  Part 2. Description of LR-generators </li><li>  <a href="http://habrahabr.ru/post/140441/">Part 3. Features of writing and possible features of LR-generators</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/140339/">https://habr.com/ru/post/140339/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140332/index.html">CSS3 menu selection</a></li>
<li><a href="../140333/index.html">Objectives of the audit of changes in IT infrastructure</a></li>
<li><a href="../140336/index.html">Android evolution: from G1 to Galaxy Nexus</a></li>
<li><a href="../140337/index.html">Setting up a Cherokee web service under Ubuntu 11.04 to work with WordPress</a></li>
<li><a href="../140338/index.html">cache-js. caching function</a></li>
<li><a href="../140340/index.html">Overview of the router NETGEAR WNDR3800</a></li>
<li><a href="../140344/index.html">What is travis-ci.org and what is it eaten with?</a></li>
<li><a href="../140345/index.html">Notification of unread incoming letter using Yoctupuce-Demo</a></li>
<li><a href="../140346/index.html">Blog-based social network XenForo</a></li>
<li><a href="../140347/index.html">Installing Mercurial Server and Using SSH Authorization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>