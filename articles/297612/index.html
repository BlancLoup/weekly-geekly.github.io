<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flowchart for Choosing the Optimal Software Development Methodology</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 How to choose a methodology? Often, when it is necessary to make a decision on the choice of methodology in the head, there is too much...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flowchart for Choosing the Optimal Software Development Methodology</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  How to choose a methodology?  Often, when it is necessary to make a decision on the choice of methodology in the head, there is too much heterogeneous information and it is hard to understand exactly what is best for the project.  In this article, I present a flowchart for choosing the optimal methodology, as a kind of hint that allows you to draw attention to some of the most important aspects. <br><br><img src="https://habrastorage.org/files/6d6/deb/d6b/6d6debd6b6374135a1db94884440de33.png"><br><a name="habracut"></a><br><br>  First of all I want to note that there is no universal set of conditions for all situations when choosing one or another methodology.  In each case, you should focus on the specifics of your project.  This block diagram will only outline the main aspects and allow you to recall the features of the main methodologies.  In no case do I call to treat it as the only correct guide for choosing a methodology.  Moreover, you should not extend it to such complex projects as the creation of operating systems, aircraft avionics, modeling of nuclear reactions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Secondly, choosing a methodology, do not blindly follow it.  Often it is necessary to ‚Äúfinish‚Äù it, adapting it to your project.  Something can be thrown out, something to add from other methodologies, to bring something of our own.  For example, no one bothers you to use this practice as pair programming in a waterfall model, if it benefits you.  On Habr√© there is an excellent <a href="http://habrahabr.ru/company/softline/blog/140737">article</a> on the adaptation of Skram and Kanban to a specific project, which illustrates this principle well. <br><br>  In the next chapter I will very briefly talk about the methodologies and models of the life cycle mentioned in the article for those who hear about them for the first time.  More details about each of them can be found in Wikipedia.  If you already know them, you can safely move on to Chapter 2: ‚ÄúAnalysis of the flowchart‚Äù. <br><br><h4>  1. Brief Description </h4><br><br>  <b>The life cycle model</b> is a general description of how the development process proceeds. <br><br>  <b>Methodology</b> - a more detailed set of rules, practices and principles, as a way to implement a particular model.  For example, the Scrum methodology implements an iterative development model. <br><br>  <b>The process framework</b> is, roughly speaking, a methodology containing a large number of rules, but in which it is not necessary to use them all, but you can choose only what you need and build your development process.  They have in their composition special applications that allow you to view and edit rules.  Examples: RUP, EssUp. <br><br>  <b>Cascade model</b> (or waterfall model, Waterfall) - characterized by the fact that the stages of development, such as: analysis, design, implementation, testing, go after each other.  Allows you to quickly create a system without additional overhead costs for the organization of the development process.  However, it works only when the requirements are stable and do not change during the development, because  we immediately describe all the requirements, and then immediately design the entire system. <br><br>  <b>V-Model</b> - invented in Germany and the United States, as a way to improve the cascade model for use in government projects.  V-Model has the specifics of projects for state bodies: fixed requirements, cost and time.  The difference is that the analysis and design stage is related to the testing phase.  For example, during the analysis of requirements, testing approaches are studied at the same time, during the design of the system architecture, high-level plans and test scripts are developed, during the design of the system components, methods for testing components and their interaction are developed, test scripts are created, utilities are written that help in testing, instructions, scripts, etc.  All this helps to better understand the requirements and design the system.  However, here, as well as in the cascade model, it is undesirable that requirements change during development. <br><br>  <b>Spiral model</b> (Spiral) - focused on projects in which there are serious risks.  Development is presented in the form of a spiral.  Each turn of the spiral is an iteration.  The coil of a spiral consists of four stages: planning, risk analysis, development, evaluation by the customer.  At the end of each iteration, it is decided whether to continue the project.  A characteristic feature is that at the stage of risk analysis, prototypes, concepts, models are created that are designed to resolve the risk at an early stage.  The farther the spiral movement, the more product development and fewer prototypes and concepts.  A typical application of this model is research projects.  It is a very expensive model, and is not justified in systems where risks are minor. <br><br>  <b>Iterative model</b> - focused on projects where the requirements may change in the course of development.  The project consists of iterations (from 1-2 to 6 weeks).  Each iteration may include the stage of analysis, design, implementation, testing.  It has a large overhead on the organization of the process than the cascade model, but the cost of correcting errors depending on the duration of the project is not so high.  The following methodologies implement an iterative model: Scrum, XP, partly Kanban. <br><br>  <b>Scrum Methodology</b> - The iteration is called a sprint.  The team consists of 3 roles: the product owner (customer representative), the scrum master (following the process), the rest of the team members.  Sprint begins with a planning rally, when the team selects and distributes tasks for the iteration, forming a backlog of sprints.  The sprint ends with a sprint review where a product is shown and a sprint retrospective rally is held to discuss improvements.  15-minute scrum meetings are held daily. <br><br>  <b>Extreme Programming Methodology</b> (XP) - consists of 12 practices: pair programming, development through testing, refactoring, simple architecture, collective code ownership, continuous integration, customer in a team, frequent releases, planning game, 40-hour work week, coding standards , system metaphor.  Be sure to use all 12 practices. <br><br>  <b>Kanban Methodology</b> (Kanban) - task pipeline.  There are only 3 rules: visualization of the development process using kanban boards, a limit on the number of tasks at each stage, constant measurement of team productivity and improvements. <br><br>  <b>The RAD</b> (Rapid Application Development) <b>methodology</b> is focused on the rapid development of an application, iteratively, with the simplest architecture, minimal process costs, maximally using ready-made components and powerful tools.  Has a limit on the duration of the project - 60-90 days.  I like the analogy with cakes from convenience foods.  So, RAD - when you need to quickly make a pie of ready-made components. <br><br><h4>  2. Analysis of flowcharts </h4> <br><img src="https://habrastorage.org/files/77c/a11/d37/77ca11d3784d43c7b290807a338de7c3.PNG"><br><br>  Startups are characterized by the fact that there, especially in the initial period, everything is built on enthusiasm.  Not always people work 8 hours a day.  If they impose some kind of methodology and put it in a certain framework, then either all their enthusiasm will die out or no one will follow the rules.  For example, it is rather silly to expect that the initiator of a startup will come in the morning on time to a scrum-rally, after a stormy night of coding.  In the future, when everything is stabilized, you can proceed to the use of a suitable methodology. <br><br><img src="https://habrastorage.org/files/6a6/988/b5b/6a6988b5b42a49eca948932e6a0d9a77.PNG"><br><br>  Every project has risks.  However, in this case, the risks are so serious that it is not known in advance whether it will be possible to implement the system at all.  If such risks are present, then, most likely, you will begin development with prototypes, concepts, models, etc.  to find out the fundamental possibility of our plans.  In this case, the spiral model will be the best model for you.  A typical example of this model is research projects.  But only research projects application of this model is not limited. <br><br>  An example from real practice in the field of retail: we needed to develop a mobile application that had to actively interact with certain equipment via Bluetooth.  These were readers of various cards, various types of printers and barcode scanners.  We did not know whether it was possible to do this on a mobile platform at all.  Therefore, we started with prototypes and concepts, in which we tried to figure out the fundamental possibility of interaction with equipment and existing limitations.  Then we met with the customer, demonstrated what we had and discussed workarounds for what could not be implemented. <br><br><img src="https://habrastorage.org/files/756/89e/fc9/75689efc928843f18c7c97b1994d412f.PNG"><br><br>  If in your case there are no such serious risks, then the next question arises: will the requirements change?  If your requirements are well known in advance, and you are sure that the customer will not make any significant changes in the development process, then you should choose a cascade development model.  I recommend choosing a cascade model when the project has a short duration.  In the case of clear and unchanging requirements, coupled with a short duration, the cascade model compared to the iterative model will give less process overhead.  At all stages of the implementation of programmers, nothing will distract from writing code: neither the need to urgently fix bugs from the last iteration, nor the endless rallies and releases. <br><br>  However, in the case of long-term projects, the cascade model will work poorly.  Despite the fact that there are no risks of changing requirements, there are technical risks.  For example, if you developed an incorrect architecture, chose the wrong technologies and tools, did not calculate the required performance, etc., you are more likely to find out at the end, and there may be no time to fix it.  The longer the project lasts, the higher the cost of correcting the error.  If at the initial stage refactorings and cardinal code changes are easy, then at the end of the project, this is already quite ‚Äúpainful‚Äù. <br><br>  A practical example: we needed to implement a mobile application that would do the exact same thing as the same desktop application.  Thus, the requirements were known and unchanged throughout the project. <br><br><img src="https://habrastorage.org/files/b63/3ce/8fb/b633ce8fbf2c436e91373e950d7fb00f.PNG"><br><br>  The next question is whether the requirements are complex.  Again, the question is not straightforward and depends on the project.  When you start a project, it is sometimes useful at the analysis and design stage to think about how you will be testing.  This can help identify potential problems earlier and better implement the architecture, work out requirements, etc.  When the requirements are complex, it is recommended to carefully think through all the test scenarios, and at the analysis and design stage, develop test approaches, test plans and test cases.  In this case, we come to the aid of the model V-Model, which is a kind of cascade model. <br><br>  The use of V-Model, where the requirements are quite simple will lead to the fact that the system will be more expensive.  Moreover, V-Model is criticized for generating a lot of documentation and bureaucracy and in reality serving not to create high-quality software that satisfies the customer, but to prove at the end of the project that the system works as originally required, instead of really developing what he needed. <br><br><img src="https://habrastorage.org/files/0c2/de1/943/0c2de194353a41a8bf7ebb9e39830e12.PNG"><br><br>  The formalized approach is that all the processes of the application life cycle are regulated in detail.  This is necessary in complex large projects with a large team. <br><br>  An example is the systems on which people‚Äôs lives depend: medicine, transport, energy.  Typically, such systems are developed in accordance with industry standards, repeatedly tested, subject to licensing.  Light methodologies in such systems do not work.  As you know, live communication is preferable to documentation in them, but, for example, if your application will be tested several times by different teams, it is better if this process is carefully documented.  If there are dozens of people in a team, then no product owner (customer representative for scram terminology) will be able to constantly explain the requirements to them all. <br><br>  Thus, if you need a formalized approach, then such methodologies as RUP, OpenUp, EssUp will become your choice.  Such methodologies are more than methodologies and it is more correct to call them process frameworks.  They were originally created for an iterative model; however, they can also be used in modifications in a cascade model. <br><br><img src="https://habrastorage.org/files/9ed/8db/88d/9ed8db88dc034c2f8c98566b7b700d57.PNG"><br><br>  If we do not need a formalized approach, then we will use so-called flexible methodologies.  Speed ‚Äã‚Äãor quality?  In fact, it implies a slightly more complex formulation: productivity or engineering? <br><br>  By productivity is meant the fastest process of adding functionality to an application.  Engineering implies a high level of development organization, innovative approaches and complex techniques that can be applied only by an experienced team.  I'm talking about such practices of extreme programming as development through testing, continuous integration, pair programming, etc.  The peculiarity of extreme programming is that it is necessary to use all 12 practices, only then the effect of them becomes maximum.  If you do not use some kind of practice, she will definitely pull everyone else along.  For example, if you refuse unit tests, then you cannot do frequent refactorings, without refactorings you cannot provide a simple architecture (as we know, a simple architecture is more difficult to develop than a complex one), etc. <br><br>  However, you can use the practice of extreme programming in other methodologies, moreover, it can be very useful.  For example, you can use pair programming in Scrum to help beginners quickly integrate into a project.  Thus, extreme programming can provide high quality at the expense of a higher level of engineering, but if you choose this methodology, the project can be more expensive.  Also, for successful application, a team that already has experience in using this methodology is required. <br><br><img src="https://habrastorage.org/files/2b8/6bf/d9f/2b86bfd9f1db4a24a45d1d380f520e72.PNG"><br><br>  If you need maximum productivity, then there are also options.  Scrum is focused on continuous process improvement.  For this, he has a retrospective rally that takes place at the end of the sprint.  Also during the sprint review, what was done well, what was bad and what was improved was discussed.  If you have an experienced team, a well-established process, and you basically do not need improvement, then following the Scrum methodology will take you too much time, which you could spend more profitably.  For example, according to Scrum, if the sprint lasts 1 month, then the sprint review should take 4 hours and the sprint retrospective should take 3 hours.  Plus, there is a sprint planning, lasting 8 hours and daily Scrum meetings for 15 minutes. <br><br>  If you have, for example, a non-cohesive team, or you are using tested technologies or an unfamiliar field of application for your application, or all together, then choosing the Scrum methodology can be a great solution.  When a new project starts, you can start using Scrum, and when the process becomes more streamlined, the architecture stabilizes, the need for constant improvements disappears, then you can switch to another methodology, for example, Kanban. <br><br><img src="https://habrastorage.org/files/b77/043/deb/b77043deb8fd475e9fb3c409581c2083.PNG"><br><br>  If improvement is not needed and all that is needed is to concentrate on completing tasks, then RAD or Kanban will work well.  RAD has a lot in common with agile methodologies, but there is a significant limitation on the duration of the project.  Preferably no more than 60-90 days.  Kanban is like a continuous conveyor that can last forever.  It works well on support projects, but it‚Äôs bad where you need to develop a complex architecture, because  focused on the rapid addition of features in the application.  By features we mean a piece of functionality that is visible to the user and directly solves any of his tasks.  For example, logging, optimization and scalability are not visible to the user, these are not features in Kanban terminology.  But the new page, report, additional filters in the search is what is visible to the user and is a feature. <br><br><h5>  Sources: </h5><br>  1. Dr.  Winston, W. Royce.  Managing development of large software systems.  1970. <a href="http://www.cs.umd.edu/class/spring2003/cmsc838p/Process/waterfall.pdf">http://www.cs.umd.edu/class/spring2003/cmsc838p/Process/waterfall.pdf</a> <br>  2. W Boehm, A spiral model of software development and enhancement.  1986. <a href="http://csse.usc.edu//TECHRPTS/1988/usccse88-500/usccse88-500.pdf">http://csse.usc.edu//TECHRPTS/1988/usccse88-500/usccse88-500.pdf</a> <br>  3. W Boehm.  Spiral Development: Experience, Principles, and Refinements.  2000. <a href="http://www.sei.cmu.edu/reports/00sr008.pdf">http://www.sei.cmu.edu/reports/00sr008.pdf</a> <br>  4. S. Belousova, I. Bessonova, Rudzhero Gilyarevsky.  Introduction to software systems and their development.  HSE.  <a href="http://www.intuit.ru/studies/courses/3632/874/info">http://www.intuit.ru/studies/courses/3632/874/info</a> <br>  5. K. Schw√§ber, D. Sutherland.Skram Hyde.  A comprehensive guide to Scrum: Rules of the game. <br>  <a href="http://scrumguides.org/docs/scrumguide/v1/Scrum-Guide-RUS.pdf">http://scrumguides.org/docs/scrumguide/v1/Scrum-Guide-RUS.pdf#zoom=100</a> <br>  6. Rational Unified Process.  Best Practices for Software.  Development Teams.  <a href="http://www.ibm.com/developerworks/rational/library/content/03July/1000/1251/1251_bestpractices_TP026B.pdf">http://www.ibm.com/developerworks/rational/library/content/03July/1000/1251/1251_bestpractices_TP026B.pdf</a> <br>  Introduction to OpenUP.  <a href="http://epf.eclipse.org/wikis/openup/">http://epf.eclipse.org/wikis/openup/</a> <br>  7. H. Kniberg, M. Skarin.  Scrum and Kanban: Squeeze the maximum.  InfoQ.  2010 <br>  8. K. Auer, R. Miller.  Extreme programming.  Staging processes.  - SPb .: Peter: 2004 <br>  9. Extreme programming - reality and myths.  <a href="http://skipy.ru/philosophy/xp.html">skipy.ru/philosophy/xp.html</a> <br>  10. M. Stephens, D. Rosenberg.  Extreme Programming Refactored: The Case Against XP.  APress, USA, 2003 <br>  11. James Christie.  The seductive and dangerous V Model. <br>  <a href="http://www.clarotesting.com/page11.htm">http://www.clarotesting.com/page11.htm</a> <br>  12. Adel Alshamrani.  A Comparison Model SDLC Models Waterfall Model, Spiral Model, and Incremental / Iterative Model.  <a href="http://www.academia.edu/10793943/A_Comparison_Between_Three_SDLC_Models_Waterfall_Model_Spiral_Model_and_Incremental_Iterative_Model">http://www.academia.edu/10793943/A_Comparison_Between_Three_SDLC_Models_Waterfall_Model_Spiral_Model_and_Incremental_Iterative_Model</a> </div><p>Source: <a href="https://habr.com/ru/post/297612/">https://habr.com/ru/post/297612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../297600/index.html">How do we account for the power of automated</a></li>
<li><a href="../297602/index.html">In 2016, two new companies under the Fujitsu brand will be born.</a></li>
<li><a href="../297606/index.html">How to cope with all the tasks for the year in just 12 weeks?</a></li>
<li><a href="../297608/index.html">How I did a business with a turnover of 6 million on software development, without investing a single penny</a></li>
<li><a href="../297610/index.html">Five signs that you are ready for SAT Prep</a></li>
<li><a href="../297614/index.html">Business projects 2013-2014: the fate of startups that have received the support of IIDF</a></li>
<li><a href="../297616/index.html">RSP Mikhalkov requires 114 million rubles from Hewlett-Packard</a></li>
<li><a href="../297618/index.html">Regional popularity of social networks</a></li>
<li><a href="../297620/index.html">In 2015, the budget of Roskomnadzor was cut by 1.47 billion rubles, and the budget of the Ministry of Communications and Mass Communications reduced even more</a></li>
<li><a href="../297622/index.html">How did we make analytics better</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>