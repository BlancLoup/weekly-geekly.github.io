<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a 3D printer shader effect</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this tutorial, we will recreate the effect of a 3D printer used in games such as Astroneer and Planetary Annihilation . This is an interesting effe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a 3D printer shader effect</h1><div class="post__text post__text-html js-mediator-article">  In this tutorial, we will recreate the effect of a 3D printer used in games such as <a href="http://astroneer.space/">Astroneer</a> and <a href="http://www.uberent.com/pa/">Planetary Annihilation</a> .  This is an interesting effect, showing the process of creating an object.  Despite the apparent simplicity, there are many far from trivial difficulties. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b3/74f/bb6/3b374fbb6ad191535b663c1a64e2b39b.gif"></div><br><a name="habracut"></a><br><h3>  Introduction: first try </h3><br>  To recreate this effect, let's start with something simpler.  For example, with a shader that colors an object differently depending on its position.  To do this, you need to access the position of the pixels drawn in the world.  This can be done by adding the <code>worldPos</code> field to the Unity 5 surface shader's <code>Input</code> structure. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Input { float2 uv_MainTex; float3 worldPos; };</code> </pre> <br>  You can then use the Y position in the world as a surface function to change the color of the object.  This can be achieved by changing the <code>Albedo</code> property in the <code>SurfaceOutputStandard</code> structure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _ConstructY; fixed4 _ConstructColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IN.worldPos.y &lt; _ConstructY) { fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Alpha = ca; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { o.Albedo = _ConstructColor.rgb; o.Alpha = _ConstructColor.a; } o.Metallic = _Metallic; o.Smoothness = _Glossiness; }</code> </pre> <br>  The result is a first approximation of the Astroneer effect.  The main problem is that the shaded display is still performed for the color part. <br><br><img src="http://www.alanzucconi.com/wp-content/uploads/2016/09/01.png" alt="image"><br><br><h3>  Unlit surface shader </h3><br>  In the previous tutorial of <a href="http://www.alanzucconi.com/%3Fp%3D1964">PBR and Lighting Models,</a> we studied how to create custom lighting models for surface shaders.  An unlit shader always creates the same color, regardless of ambient light and viewing angle.  You can implement it as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Unlit fullforwardshadows inline half4 LightingUnlit (SurfaceOutput s, half3 lightDir, half atten) { return _ConstructColor; }</span></span></code> </pre> <br>  His only task is to return a single solid color.  As we can see, it refers to <code>SurfaceOutput</code> , which was used in Unity 4. If we want to create our own lighting model that works with PBR and global illumination, then we need to implement a function that receives <code>SurfaceOutputStandard</code> as input.  In Unity 5, the following function is used for this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">inline half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingUnlit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SurfaceOutputStandard s, half3 lightDir, UnityGI gi</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ConstructColor; }</code> </pre> <br>  The <code>gi</code> parameter here refers to the global illumination (global illumination), but in our unlit shader it does not perform any tasks.  This approach works, but it has a big problem.  Unity does not allow the surface shader to selectively change the lighting function.  We cannot apply standard Lambert lighting to the lower part of the object and at the same time make the upper part unlit.  You can assign a single lighting function for the entire object.  We have to change the way the object is rendered depending on its position. <br><br><img src="http://www.alanzucconi.com/wp-content/uploads/2016/09/02.png" alt="image"><br><br><h3>  Pass the parameters of the lighting function </h3><br>  Unfortunately, the lighting function does not have access to the position of the object.  The easiest way to provide this information is to use a boolean variable ( <code>building</code> ), which we define as a surface function.  This variable can be checked by our new lighting function. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> building; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IN.worldPos.y &lt; _ConstructY) { fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Alpha = ca; building = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { o.Albedo = _ConstructColor.rgb; o.Alpha = _ConstructColor.a; building = <span class="hljs-number"><span class="hljs-number">1</span></span>; } o.Metallic = _Metallic; o.Smoothness = _Glossiness; }</code> </pre> <br><h3>  Extend the standard lighting function </h3><br>  The last problem we have to face is quite complicated.  As I explained in the previous section, we can use <code>building</code> to change the way lighting is calculated.  The part of the object that is currently being constructed will be unlit, and the rest will be correctly calculated lighting.  If we want our material to use PBR, we cannot rewrite all the code for photorealistic lighting.  The only reasonable solution is to call the standard lighting function, which is already implemented in Unity. <br><br>  In the traditional standard surface shader, the <code>#pragma</code> that defines the use of the PBR lighting function is as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows</span></span></code> </pre> <br>  By the standards of the Unity name, it is easy to see that the function used should be called <code>LightingStandard</code> .  This feature is in the <code>UnityPBSLighting.cginc</code> file, which you can connect if necessary. <br><br>  We want to create our own lighting function called <code>LightingCustom</code> .  Under normal circumstances, it simply calls the standard Unite PBR function called <code>LightingStandard</code> .  However, if necessary, it uses the previously defined <code>LightingUnlit</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">inline half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingCustom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SurfaceOutputStandard s, half3 lightDir, UnityGI gi</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!building) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LightingStandard(s, lightDir, gi); <span class="hljs-comment"><span class="hljs-comment">// Unity5 PBR return _ConstructColor; // Unlit }</span></span></code> </pre> <br>  To compile this code, Unity 5 needs to define another function: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">inline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingCustom_GI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SurfaceOutputStandard s, UnityGIInput data, inout UnityGI gi</span></span></span><span class="hljs-function">)</span></span> { LightingStandard_GI(s, data, gi); }</code> </pre> <br>  It is used to calculate the extent to which the illumination affects the global illumination, but is not necessary for the purposes of our tutorial. <br><br>  The result will come out exactly as we need: <br><br><img src="http://www.alanzucconi.com/wp-content/uploads/2016/09/03.png" alt="image"><br><br>  In this first part, we learned how to use two different lighting models in one shader.  This allowed us to render one half of the model using PBR, and the other to leave unlit.  In the second part, we will complete this tutorial and show how to animate and improve the effect. <br><br><h3>  We cut off the geometry </h3><br>  The easiest way to add to our shader is the effect of stopping rendering the upper part of the geometry.  To cancel drawing of an arbitrary pixel in the shader, you can use the <code>discard</code> keyword.  With it, you can draw only the border around the top of the model: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IN.worldPos.y &gt; _ConstructY + _ConstructGap) discard; ... }</code> </pre> <br>  It is important to remember that this can leave ‚Äúholes‚Äù in our geometry.  It is necessary to turn off the clipping of the edges, so that the reverse side of the object is completely rendered. <br><br><pre> <code class="cs hljs">Cull Off</code> </pre> <br><img src="http://www.alanzucconi.com/wp-content/uploads/2016/09/04.png" alt="image"><br><br>  Now we are most uncomfortable with the fact that the object looks hollow.  This is not just a feeling: in essence, all 3D models are hollow.  However, we need to create the illusion that the object is actually solid.  This can be easily achieved by painting the object from the inside with the same unlit shader.  The object is still hollow, but perceived to be filled. <br><br>  To achieve this, we simply color the triangles that are directed to the camera on the reverse side.  If you are unfamiliar with vector algebra, this may seem rather complicated.  In fact, this can be quite easily achieved using a <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BA%25D0%25B0%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">scalar product</a> .  The scalar product of two vectors shows how ‚Äúaligned‚Äù they are.  And this is directly related to the angle between them.  When the scalar product of two vectors is negative, the angle between them is more than 90 degrees.  We can test our initial condition by taking the dot product between the camera's gaze direction ( <code>viewDir</code> in the surface shader) and the triangle normal.  If it is negative, then the triangle is turned away from the camera.  That is, we see his "wrong side" and can render it in solid color. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Input { float2 uv_MainTex; float3 worldPos; float3 viewDir; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span></span></span><span class="hljs-function">)</span></span> { viewDir = IN.viewDir; ... } <span class="hljs-function"><span class="hljs-function">inline half4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingCustom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SurfaceOutputStandard s, half3 lightDir, UnityGI gi</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (building) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ConstructColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dot(s.Normal, viewDir) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _ConstructColor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LightingStandard(s, lightDir, gi); }</code> </pre> <br>  The result is shown in the images below.  On the left, "purlid geometry" is rendered in red.  If you use the color of the top of the object, the object no longer looks hollow. <br><br><img src="http://www.alanzucconi.com/wp-content/uploads/2016/09/05.png" alt="image"><br><br><h3>  Wavy effect </h3><br><img src="http://www.alanzucconi.com/wp-content/uploads/2016/10/pa2.gif" alt="image"><br><br>  If you played Planetary Annihilation, then you know that the shader of the 3D printer uses the effect of a slight waviness.  We can also implement it by adding a bit of noise to the position of the pixels drawn in the world.  This can be achieved either by texture noise, or by using a continuous periodic function.  In the code below, I use a sine wave with arbitrary parameters. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Input IN, inout SurfaceOutputStandard o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = +sin((IN.worldPos.x * IN.worldPos.z) * <span class="hljs-number"><span class="hljs-number">60</span></span> + _Time[<span class="hljs-number"><span class="hljs-number">3</span></span>] + o.Normal) / <span class="hljs-number"><span class="hljs-number">120</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IN.worldPos.y &gt; _ConstructY + s + _ConstructGap) discard; ... }</code> </pre> <br>  These parameters can be corrected manually for a beautiful wavy effect. <br><br><img src="http://www.alanzucconi.com/wp-content/uploads/2016/09/07.gif" alt="image"><br><br><h3>  Animation </h3><br>  The last part of the effect is animation.  It can be obtained by simply adding the <code>_ConstructY</code> parameter to the material.  The shader will take care of the rest.  You can control the speed of the effect either by code, or by using an animation curve.  In the first version, you can fully control its speed. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BuildingTimer</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material material; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> minY = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxY = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> duration = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Update is called once per frame void Update () { float y = Mathf.Lerp(minY, maxY, Time.time / duration); material.SetFloat("_ConstructY", y); } }</span></span></code> </pre> <br><img src="http://www.alanzucconi.com/wp-content/uploads/2016/09/08.gif" alt="image"><br><br>  I note at the end that the model used in this image looks hollow for a few seconds, because the bottom of the accelerators is unlocked.  That is, the object <i>is actually</i> hollow. <br><br>  <i>[You can download the Unity package (code, shader, and 3D models) by <a href="https://www.patreon.com/posts/11680223">supporting the</a> author of the original article with ten dollars to Patreon.]</i> </div><p>Source: <a href="https://habr.com/ru/post/331576/">https://habr.com/ru/post/331576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331562/index.html">Digital counterparts. Design through reflection</a></li>
<li><a href="../331564/index.html">nstd - C ++ library - "gentleman's set" of useful classes</a></li>
<li><a href="../331566/index.html">Optimize AWS Costs in SaaS Business</a></li>
<li><a href="../331568/index.html">Technical support 3CX responds: conditions for switching to the backup route (trunk) in outgoing rules</a></li>
<li><a href="../331570/index.html">How to organize a Performance Review in IT companies: Badoo experience</a></li>
<li><a href="../331582/index.html">Teach the bot! - marking of emotions and semantics of the Russian language</a></li>
<li><a href="../331584/index.html">Optimization history of one IoC container</a></li>
<li><a href="../331586/index.html">Design of the city based on data. Lecture in Yandex</a></li>
<li><a href="../331588/index.html">Compressing photos without apparent loss of quality: the Yelp experience</a></li>
<li><a href="../331590/index.html">Using MapXtreme .Net</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>