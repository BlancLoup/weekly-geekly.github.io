<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>You Gonna Hate This, or a Tale of How a Good Code Should Look</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day everyone. Some time ago I spoke to students on the topic "What we expect from good code" and decided to duplicate it here. In the process of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>You Gonna Hate This, or a Tale of How a Good Code Should Look</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/rt/m5/sc/rtm5scrsf_9nwof5hhonc3jslx0.jpeg" alt="If you are looking for the perfect code.  Apparently, it's time for me to participate in this :)"></p><br><p>  Good day everyone.  Some time ago I spoke to students on the topic "What we expect from good code" and decided to duplicate it here.  In the process of translation, the text has changed somewhat, but the essence remains the same.  The article turned out to be simple (and certainly not complete), but there is rational grain here. </p><a name="habracut"></a><br><h2 id="kod-dolzhen-rabotat">  The code should work </h2><br><p><img src="https://habrastorage.org/webt/fm/zg/gh/fmzgghanlo02sc7wjcgw1qx0hdk.jpeg" alt="Obvious things do not bring less problems from the fact that they are obvious. A lot of projects fall just because the development has not turned towards solving real user problems."></p><br><p>  Let's talk about what we expect from the code.  Well, for starters, it should work. </p><br><p>  It sounds obvious, of course, but each of us once tried or successfully launched a code that is not even going, so do not laugh.  The second point is that the code should work correctly with incorrect situations.  That is to catch mistakes.  But let's go back to the first point and talk a little about it. </p><br><p>  Periodically, I get a task that I have no idea how to do.  That is, in general (I try to look around and constantly try something new).  And then I immediately pulls to write some kind of abstraction, some kind of infrastructure in order to delay the moment of real work.  So, this is wrong.  The code should work.  I know that I repeat, but this is an important point.  If you don‚Äôt know how to solve a problem, don‚Äôt rush to create interfaces, modules and that's it.  This is a bad idea, and it will end up running out of time for you, and you will not get anywhere.  Remember, badly working code is many times better than good, but not working code. </p><br><p>  There is an old parable about two software companies that made the same product.  The first one did it anyhow, but the first one entered the market, and the second one did everything perfectly and was late.  As a result, the first campaign managed to win the market and bought the second company.  This is a little about something else, but the basic idea is still the same.  First we solve the problem, then we make the code beautiful. </p><br><p>  In general, first make a working prototype.  Let him be lame, wry, and miserable, but when they ask you you can say that there is already a solution, it remains to integrate it.  And rewrite it as it should.  You can try to express this maxim - if you know how to do the task - do it well.  If you do not know - first solve it somehow. </p><br><p>  And there is an important point.  I would like you to understand.  This is not a call to write bad code.  The code must be good.  This is a call to First Thing First - first the code works, then it refactors. </p><br><p>  Now let's talk about Shit Happens.  So, we have the code, it even works.  Rather, "works."  Let's look at a simple example: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (WebClient xx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xx.DownloadString(<span class="hljs-string"><span class="hljs-string">"https://some.super.url"</span></span>); } }</code> </pre> <br><p>  This is a great example of "working" code.  Why?  Because it does not take into account that sooner or later, our endpoint will fall off.  This example does not take into account the so-called edge case - borderline, "bad cases."  When you start writing code, think about what can go wrong.  In fact, I‚Äôm talking not only about remote calls, but about all the resources that are outside of your control ‚Äî user input, files, network connections, even a database.  All that can break, break at the most inopportune moment and the only thing you can do about it is to be ready for it as much as possible. </p><br><p>  Unfortunately, not all problems are so obvious.  There are a number of problem areas that are almost guaranteed to generate bugs.  For example, working with a locale, with time zones.  It is pain and shouts "everything works on my machine".  They just need to know and work with them carefully. </p><br><p>  By the way about user input.  There is a very good principle that says that any user input is considered incorrect until proven otherwise.  In other words, always validate what the user entered.  And yes, on the server too. </p><br><p>  Total: </p><br><ul><li>  First make the code work, </li><li>  Then make it good </li><li>  Don't forget about edge cases and error handling. </li></ul><br><h2 id="teper-pogovorim-o-podderzhke-koda">  Now let's talk about code support. </h2><br><p>  Support is a complicated concept, but I would include three components here - the code should be easy to read, easy to change and be uniform. </p><br><p>  Who writes comments in Russian?  Nobody writes?  Wonderful.  In general, one of the problems is non-English code.  Do not do it this way.  I had a piece of code with classes in Norwegian, and I just could not pronounce their names.  It was sad.  Obviously, maintaining such a code (for non-Norwegians) will not be a trivial task.  But this is rare. </p><br><p>  In general, ease of reading is about naming and structure.  Names of entities - classes, methods, variables, should be simple, readable and carry meaning.  Take our previous example. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (WebClient xx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xx.DownloadString(<span class="hljs-string"><span class="hljs-string">"https://some.super.url"</span></span>); } }</code> </pre> <br><p>  Can you understand what the Do method does, regardless of the implementation?  Hardly.  Similarly with variable names.  In order to understand what kind of xx object you need to look for its declaration.  It takes our time, interferes with the understanding of what, in general, occurs in the code.  Therefore, names must reflect the essence of the action or value.  For example, if you rename the Do method to GetUserName, the code will become a little clearer and in some cases we will not have to look into its implementation.  Similarly, with the names of variables in the form of x and xx.  True, there are generally accepted exceptions in the form of e for errors, i, k for cycle counters, n for dimensions, and a few more. </p><br><p>  Again, for example, take your code that you wrote a month ago and try to read it fluently.  Do you understand what is happening there?  If yes - I congratulate you.  If not, then you have a problem with the readability of the code. </p><br><p>  In general, there is such an interesting quote: </p><br><blockquote>  "There are only two hard things in Computer Science: cache of invalidation and naming things." ¬© Phil Karlton </blockquote><p>  <em>There are only two complex things in Computer Science: invalidation of cache and naming.</em> </p><br><p>  Remember it when you give names to your entities. </p><br><p>  The second component of the readable code is its complexity or structure.  I'm talking about those who like to write six nested iffs, or enter a Kolbek in the Kolbek Kolbek inside the Kolbek.  In JavaScript, there is even such a term - <a href="http://callbackhell.com/">Callback Hell</a> . </p><br><p><img src="https://habrastorage.org/webt/za/z9/s-/zaz9s-rf8qxjd81dcprgtck1iti.jpeg" alt="Talking about perfect code is easy, but writing it is a little more difficult. The most important thing here is not to lie to yourself. If your code is bad - do not call it candy, and take and finish"></p><br><p>  Have pity on your colleagues and yourself.  After a week, you have to literally wade through this code to fix or add something in it.  Avoiding this is not so difficult: </p><br><ul><li>  Write short functions, </li><li>  Avoid a lot of branching or nesting, </li><li>  Highlight the logical blocks of code in separate functions, even if you do not intend to reuse them, </li><li>  Use polymorphism instead of if </li></ul><br><p>  Now let's talk about another difficult thing - that good code is easy to change.  Who is familiar with the term Big ball of mud?  If someone is not familiar - look at the picture. </p><br><p><img src="https://habrastorage.org/webt/f7/im/z8/f7imz8vdygpsaphm_5xjnpqfs5w.png" alt="In general, in this regard, I really like open source. When your code is open to the whole world, somehow you want to make it at least normal."></p><br><p>  Each module depends on each module and a contract change in one place is likely to lead to the onset of a polar chanterelle or at least to a very long debug.  Theoretically, it is quite simple to deal with this - reduce the dependence of your code on your own code.  The less your code knows about any implementation details, the better it will be for it.  But in practice it is much more complicated, and leads to code overload. </p><br><p>  In the form of advice, I would formulate it like this: </p><br><ul><li>  Hide your code as deep as possible.  Imagine that tomorrow you will have to manually remove it from the project.  How many places will you have to fix and how difficult will it be to do this?  Try to minimize this amount. </li><li>  Avoid circular dependencies.  Split the code into layers (logic, interface, data access) and make sure that the layers of the "lower" level are not dependent on the layers of the "upper" level.  For example, data access should not depend on the user interface. </li><li>  Group the functionality into modules (projects, folders) and hide the classes inside them leaving only the facade and interfaces. </li></ul><br><p>  And draw.  Just draw on a piece of paper how your data is processed by the application and what classes are used for this.  This will help you understand the over complicated places before it all becomes irreparable. </p><br><p>  And finally, about uniformity.  Always try to adhere to the same style adopted in the team, even if it seems wrong to you.  This also applies to formatting, and approaches to solving the problem.  Do not use ~~ for rounding, even if it is faster.  The team will not appreciate it.  And when starting to write new code, always look into the project, maybe something from the one you need is already implemented and it can be reused. </p><br><p>  Total: </p><br><ul><li>  Correct naming </li><li>  Good structure </li><li>  Uniformity. </li></ul><br><h2 id="kod-dolzhen-byt-dostatochno-proizvoditelnym">  The code must be sufficiently productive. </h2><br><p>  Let's just talk a little bit.  The following requirement that we consider - the code must be sufficiently productive. </p><br><p>  What do I mean by "enough"?  Probably, everyone has heard that premature optimizations are evil, they kill readability and complicate the code.  It's true.  But it is also true that you should know your tool and not write on it so that the web client download Core I7 by 60%.  You should know the typical problems that lead to performance problems and avoid them even at the stage of writing code. </p><br><p>  Let's go back to our example: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetUserName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (WebClient http = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.DownloadString(<span class="hljs-string"><span class="hljs-string">"https://some.super.url"</span></span>); } }</code> </pre> <br><p>  This code has one problem - the synchronous execution of network boot.  This is an I / O operation that will freeze our flow until it is executed.  In desktop applications, this will lead to a hung interface, and in server applications, to useless memory reservations and exhausting the number of requests to the server.  Just knowing such problems, you can already write more optimized code.  And in most cases this will be enough. </p><br><p>  But sometimes, no.  Therefore, before writing code, you need to know in advance what requirements in terms of performance are put to it. </p><br><h2 id="a-teper-pogovorim-za-testy">  Now let's talk for the tests. </h2><br><p>  This is no less a holivar topic than the previous one, and maybe even more.  C tests all difficult.  Let's start with the statement - I believe that the code should be covered by a reasonable number of tests. </p><br><p>  Why do we need Code Coverage and tests at all?  In an ideal world - not needed.  In an ideal world, code is written without bugs, and the requirements never change.  But we live in a far from ideal world, so we need tests in order to be sure that the code works correctly (there are no bugs) and that the code works correctly after something has been changed.  This is the benefit that tests bring to us.  On the other hand, even 100% (due to the specificity of the calculation of metrics) covered with tests does not guarantee that you have covered absolutely everything.  Moreover, each additional test still slows down the development, since after changing the functional you will have to update the tests as well.  Therefore, the number of tests should be reasonable and the main difficulty lies in finding a compromise between the amount of code and the stability of the system.  Finding this facet is quite difficult and there is no universal recipe for how to do it.  But there are some tips that you might help to do this. </p><br><ul><li>  Cover the business logic of the application.  Business logic is all that the application is created for, and it should be as stable as possible. </li><li>  Cover complex, calculated things.  Calculations, transformations, complex merdzhi data.  Where easy to make a mistake. </li><li>  Cover bugs.  A bug is a flag that tells us that the code was vulnerable.  And this is a good place to write a test here. </li><li>  Cover frequently reused code.  There is a high probability that it will be updated frequently and we need to be sure that adding something one will not break the other. </li></ul><br><p>  Do not cover without much need </p><br><ul><li>  Other libraries - look for libraries whose code is already covered with tests. </li><li>  Infrastructure - DI, automapping (if there is no complex mapping), and so on.  For this, there are e2e or integration tests. </li><li>  Trivial things are assigning data to fields, forwarding calls, and so on.  Almost certainly you will find much more useful places to cover them with tests. </li></ul><br><p>  Well, in general, that's all. </p><br><h2 id="podvedem-itogi-horoshiy-kod-eto--">  Let's sum up.  Good code is - </h2><br><ul><li>  Working code </li><li>  Which is easy to read, </li><li>  Easy to change </li><li>  Fast enough </li><li>  And covered with tests in the right quantity. </li></ul><br><p>  Good luck in this difficult path.  And most likely, your gonna hate this.  Well, if not, welcome! </p><br><p><img src="https://habrastorage.org/webt/pi/qa/wv/piqawvohoaf7t1llilibt5hayzo.jpeg" alt="In fact, this is an amazing world of discovery, opportunity and creativity. Here, just next door, there is the boredom of form-sleeping, the despondency of 20+ year of legacy code, and a field of crutches for burning dates. So I would rather call it a passage over the hair bridge (C). Look for projects that you will burn. Try to do something good. Simply, make the world better and everything will be fine."></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/429732/">https://habr.com/ru/post/429732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429720/index.html">As a novice developer to survive the interview and not go crazy at work</a></li>
<li><a href="../429722/index.html">How we made payment via Google Pay at Yandex.Cash [updated]</a></li>
<li><a href="../429724/index.html">Useful review. 28 books that influenced my thinking, inspired or made better</a></li>
<li><a href="../429728/index.html">Modern MVot-based Kotlin architecture</a></li>
<li><a href="../429730/index.html">Large supercomputer to be built on Elbrus processors in Russia</a></li>
<li><a href="../429734/index.html">Dream to fly with electrotechnical bias</a></li>
<li><a href="../429736/index.html">Hogweed Sosnowski. In MO introduced fines for distribution</a></li>
<li><a href="../429738/index.html">The optimal location of shards in a petabyte cluster Elasticsearch: linear programming</a></li>
<li><a href="../429744/index.html">Learn OpenGL. Lesson 6.4 - IBL. Mirror irradiance</a></li>
<li><a href="../429750/index.html">Developer Cookbook: DDD Recipes (Part 3, Application Architecture)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>