<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The most frequent rake when using printf in programs for microcontrollers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From time to time in my projects I have to use printf in conjunction with a serial port (UART or an abstraction over USB that simulates a serial port)...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The most frequent rake when using printf in programs for microcontrollers</h1><div class="post__text post__text-html js-mediator-article">  From time to time in my projects I have to use printf in conjunction with a serial port (UART or an abstraction over USB that simulates a serial port).  And, as usual, the time between its applications passes a lot and I manage to completely forget all the nuances that need to be taken into account in order for it to work normally in a large project. <br><br>  In this article, I gathered my own top nuances that arise when using printf in microcontroller programs, sorted by most obvious to completely non-obvious. <br><a name="habracut"></a><br><h2>  Brief introduction </h2><br>  In fact, in order to use printf in programs for microcontrollers, it is enough: <ul><li>  connect the header file in the project code; </li><li>  override the system function _write to output to the serial port; </li><li>  describe the system call stubs that the linker requires (_fork, _wait, etc.); </li><li>  use printf call in the project. </li></ul><br>  In fact, not everything is so simple. <br><br><h2>  You need to describe all the stubs, not just those used. </h2><br>  The presence of a heap of undefined references when building a project is surprising at first, but after reading a little, it becomes clear what and for what.  In all my projects I connect this <a href="">submodule</a> .  Thus, in the main project, I override only the methods I need (only _write in this case), and the rest remain unchanged. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is important to note that all stubs must be C functions.  Not C ++ (or wrapped in extern "C").  Otherwise, the layout will fail (remember about changing names when building in G ++). <br><br><h2>  In _write comes on 1 character </h2><br>  Despite the fact that in the prototype of the _write method there is an argument that passes the length of the output message, it has a value of 1 (in fact, we ourselves will make it always 1, but more on that later). <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { ... }</code> </pre> <br>  On the Internet you can often see <a href="http://we.easyelectronics.ru/STM32/primenenie-printf-v-stm32f4.html">the following implementation of</a> this method: <br><div class="spoiler">  <b class="spoiler_title">Frequent implementation of the _write function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uart_putc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); {} USART_SendData(USART2, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) ch); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write_r (struct _reent *r, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * ptr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { r = r; file = file; ptr = ptr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 int index; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* For example, output string by UART */</span></span></span><span class="hljs-meta"> for(index=0; index&lt;len; index++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ptr[index] == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\n'</span></span></span><span class="hljs-meta">) { uart_putc(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\r'</span></span></span><span class="hljs-meta">); } uart_putc(ptr[index]); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return len; }</span></span></code> </pre> <br></div></div><br>  This implementation has the following disadvantages: <br><ul><li>  low productivity; </li><li>  streaming insecurity; </li><li>  the inability to use the serial port for other purposes; </li></ul><br><br><h3>  Poor performance </h3><br>  Poor performance is explained by sending bytes using processor resources: you have to keep track of the status register instead of using the same DMA.  To solve this problem, you can pre-prepare the buffer for sending, and upon receipt of the character of the end of the line (or filling the buffer) to send.  This method requires a buffer memory, but significantly improves the performance with frequent sending. <br><div class="spoiler">  <b class="spoiler_title">An example implementation of _write with buffer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"uart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;errno.h&gt; #include &lt;sys/unistd.h&gt; extern mc::uart uart_1; extern "C" { //      uart. static const uint32_t buf_size = 254; static uint8_t tx_buf[buf_size] = {0}; static uint32_t buf_p = 0; static inline int _add_char (char data) { tx_buf[buf_p++] = data; if (buf_p &gt;= buf_size) { if (uart_1.tx(tx_buf, buf_p, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } buf_p = 0; } return 0; } // Putty  \r\n    //    . static inline int _add_endl () { if (_add_char('\r') != 0) { return -1; } if (_add_char('\n') != 0) { return -1; } uint32_t len = buf_p; buf_p = 0; if (uart_1.tx(tx_buf, len, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } return 0; } int _write (int file, char *data, int len) { len = len; //   . if ((file != STDOUT_FILENO) &amp;&amp; (file != STDERR_FILENO)) { errno = EBADF; return -1; } //     //   \n. if (*data != '\n') { if (_add_char(*data) != 0) { return -1; } } else { if (_add_endl() != 0) { return -1; } } return 1; } }</span></span></span></span></code> </pre> </div></div><br>  Here, an object of the class uart - uart_1 is responsible for sending directly using dma.  The object uses FreeRTOS methods to block third-party access to the object at the time of sending data from the buffer (taking and returning mutex).  Thus, no one can use the uart object while sending from another thread. <br>  A few links: <br><ul><li>  _write function code as part of a real project <a href="">here</a> </li><li>  uart class interface <a href="">here</a> </li><li>  implementation of the interface of the uart class under stm32f4 <a href="">here</a> and <a href="">here</a> </li><li>  creating an instance of the uart class in the project <a href="">here</a> </li></ul><br><br><h3>  Stream insecurity </h3><br>  This implementation also remains unprotected by the stream, since no one interferes with the next FreeRTOS stream to start sending another line to printf and thereby rub the buffer that is being sent (mutex inside uart protects the object from being used in different streams, but not transmitted data ).  In case there is a risk that printf of another stream will be called, then it is required to implement a layer object that will block access to printf entirely.  In my particular case, only one stream interacts with printf, so additional complications will only decrease performance (constant capture and release of mutex inside the layer). <br><br><h3>  Inability to use the serial port for other purposes </h3><br>  Since we are sending only after the entire string has been received (or the buffer is full), instead of the uart object, you can call the converter method to some top-level interface for subsequent packet forwarding (for example, delivery with a guarantee according to the transmission protocol similar to transaction modbus).  This will allow you to use one uart both for displaying debug information and, for example, for user interaction with the control console (if it is available in the device).  It will be enough to write a decompressor on the recipient side. <br><br><h2>  The default output does not work float </h2><br>  If you use newlib-nano, then by default printf (as well as all their derivatives like sprintf / snprintf ... and others) do not support output of float values.  This is easily solved by adding the following compositor flags to the project. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS -Wl,-u,vfprintf; -Wl,-u,_printf_float; -Wl,-u,_scanf_float; <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre> <br>  View the full list of flags <a href="https://github.com/Vadimatorik/ChiptunePlayer-2.22-Firmware/blob/79cd1d107459f9154ea2cb3e9e29e6148daaa97f/CMakeLists.txt">here</a> . <br><br><h2>  The program hangs somewhere in the depths of printf </h2><br>  This is another flaw in the linker flags.  For the firmware to be linked with the required version of the library, you must explicitly specify the processor settings. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(HARDWARE_FLAGS -mthumb; -mcpu=cortex-m4; -mfloat-abi=hard; -mfpu=fpv4-sp-d16;) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS <span class="hljs-variable"><span class="hljs-variable">${HARDWARE_FLAGS}</span></span> <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre><br>  View the full list of flags can <a href="https://github.com/Vadimatorik/ChiptunePlayer-2.22-Firmware/blob/79cd1d107459f9154ea2cb3e9e29e6148daaa97f/CMakeLists.txt">also</a> be <a href="https://github.com/Vadimatorik/ChiptunePlayer-2.22-Firmware/blob/79cd1d107459f9154ea2cb3e9e29e6148daaa97f/CMakeLists.txt">here</a> . <br><br><h2>  printf causes the microcontroller to get into the hard fault </h2><br>  There may be at least two reasons: <br><ul><li>  stack problems; </li><li>  problems with _sbrk; </li></ul><br><h3>  Stack problems </h3><br>  This problem really manifests itself when using FreeRTOS or any other OS.  The problem is using the buffer.  In the first paragraph it was said that in _write comes 1 byte.  In order for this to happen, it is necessary in the code, before the first use of printf, to prohibit the use of buffering. <br><pre> <code class="cpp hljs">setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  It follows from the description of the function that one can also set one of the following values: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOFBF 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set fully buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOLBF 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set line buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IONBF 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set unbuffered */</span></span></span></span></code> </pre> <br>  However, this can lead to an overflow of the task stack (or interrupts, if you are suddenly a very bad person who calls printf from interrupts). <br><br>  Technically, it is possible to arrange stacks for each thread very carefully, but this approach requires careful planning and it is difficult to catch the mistakes it carries.  A much simpler solution is to receive one byte each, storing it in its own buffer and then output it in the required format, which was previously parsed. <br><br><h3>  Problems with _sbrk </h3><br>  This problem was personally for me the most implicit.  And so, what do we know about _sbrk? <br><ul><li>  another stub that you want to implement to support a large part of the standard libraries; </li><li>  required for heap memory allocation; </li><li>  used by all sorts of library methods like malloc, free. </li></ul><br>  Personally, in my projects in 95% of cases I use FreeRTOS with overridden new / delete / malloc methods using a bunch of FreeRTOS.  So when I allocate memory, I am sure that the allocation goes in the FreeRTOS heap, which occupies a predetermined amount of memory in the bss area.  Look at the layer <a href="">here</a> .  So, technically, there should be no problem.  The function simply should not be called.  But let's think, if she calls, where will she try to take the memory? <br><br>  Recall the layout of the RAM of the ‚Äúclassic‚Äù project for microcontrollers: <br><ul><li>  .data; </li><li>  .bss; </li><li>  empty space; </li><li>  initial stack </li></ul><br>  In data, we have the initial data of global objects (variables, structures, and other global project fields).  In bss, global fields that have an initial zero value and, carefully, a bunch of FreeRTOS.  It is just an array in memory.  which the methods from the heap_x.c file then work on.  Next comes the empty space, after which (or rather, from the end) is the stack.  Because  my project uses FreeRTOS, then this stack is used only until the scheduler starts.  And, thus, its use, in most cases, is limited to a collobite (in fact, usually the 100 byte limit). <br><br>  But where is the memory allocated with _sbrk?  Let's look at what variables it uses from the linker script. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *__attribute__ ((weak)) _sbrk (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> incr) { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_start; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_end; ...</code> </pre> <br>  Now we will find them in the linker script-e (my script is slightly different from the one provided by st, however this part is about the same there): <br><pre> <code class="bash hljs">__stack = ORIGIN(SRAM) + LENGTH(SRAM); __main_stack_size = 1024; __main_stack_limit = __stack - __main_stack_size; ...  flash,    ... .bss (NOLOAD) : ALIGN(4) { ... . = ALIGN(4); __bss_end = .; } &gt;SRAM __heap_start = __bss_end; __heap_end = __main_stack_limit;</code> </pre> <br>  That is, it uses memory between the stack (1 kb from 0x20020000 down at 128 kb ram) and bss. <br><br>  Understood.  But after all, carried has redefinition methods malloc, free and others.  It's not necessary to use _sbrk, is it?  As it turned out, necessarily.  Moreover, this method does not use printf, but the method for setting buffering is <b>setvbuf</b> (or rather _malloc_r, which is declared not as a weak function in the library. Unlike malloc, which can be easily replaced). <br><img src="https://habrastorage.org/webt/me/cf/er/mecfercw11rpbrxrfn0twjyqvva.jpeg"><br>  Since I was sure that sbrk is not used, I placed a bunch of FreeRTOS (bss section) close to the stack (because I knew that the stack was used 10 times less than required). <br><br>  Solutions to Problem 3: <br><ul><li>  make some indent between bss and stack; </li><li>  override _malloc_r so that _sbrk is not called (separate one method from the library); </li><li>  rewrite sbrk through malloc and free. </li></ul><br>  I stopped at the first option, because it is safe to replace the standard _malloc_r (which is inside libg_nano.a (lib_a-nano-mallocr.o)) I did not succeed (the method is not declared as __attribute__ ((weak)), but to exclude only a single function from the bi-library I did not succeed in making it).  I really didn‚Äôt want to rewrite sbrk for the sake of one call. <br><br>  The final solution was to allocate separate sections in RAM for the initial stack and _sbrk.  This ensures that at the stage of arranging the sections do not fit on each other.  Inside sbrk there is also a check for going beyond the section.  It was necessary to make a small revision so that when detecting a transition abroad, the thread hung in the while loop (since the use of sbrk occurs only at the initial stage of initialization and must be processed during the debugging phase of the device). <br><div class="spoiler">  <b class="spoiler_title">Modified mem.ld</b> <div class="spoiler_text"><pre> <code class="bash hljs">MEMORY { FLASH (RX) : ORIGIN = 0x08000000, LENGTH = 1M CCM_SRAM (RW) : ORIGIN = 0x10000000, LENGTH = 64K SRAM (RW) : ORIGIN = 0x20000000, LENGTH = 126K SBRK_HEAP (RW) : ORIGIN = 0x2001F800, LENGTH = 1K MAIN_STACK (RW) : ORIGIN = 0x2001FC00, LENGTH = 1K }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Changes in section.ld</b> <div class="spoiler_text"><pre> <code class="bash hljs">__stack = ORIGIN(MAIN_STACK) + LENGTH(MAIN_STACK); __heap_start = ORIGIN(SBRK_HEAP); __heap_end = ORIGIN(SBRK_HEAP) + LENGTH(SBRK_HEAP);</code> </pre> </div></div><br>  You can look at <a href="">mem.ld</a> and <a href="">section.ld</a> in my sandbox project <a href="https://github.com/Vadimatorik/ChiptunePlayer-2.22-Firmware/tree/bc82dab66e71867df8874ba0eabe56de997ab457">in this commit</a> . <br><br>  UPD 07/12/2019: corrected the list of flags for printf to work with float values.  Corrected a link to the CMakeLists worker with corrected compilation and linking flags (there were nuances so that the flags should be listed one by one and through ";", while everything on one line or on different lines doesn't matter). </div><p>Source: <a href="https://habr.com/ru/post/459420/">https://habr.com/ru/post/459420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459408/index.html">As I tried to fix the search on the cards for drivers. Part 3 (final)</a></li>
<li><a href="../459410/index.html">How to write code so that your colleagues do not matter</a></li>
<li><a href="../459414/index.html">Writing API for React components, part 4: beware of Apropacalypse</a></li>
<li><a href="../459416/index.html">Writing an API for React components, part 5: just use composition</a></li>
<li><a href="../45942/index.html">Start of the new tutorial "The Jobeet"</a></li>
<li><a href="../459422/index.html">We write API for React components, part 6: we create communication between components</a></li>
<li><a href="../459426/index.html">How was the design of Yandex. Auto</a></li>
<li><a href="../459428/index.html">Intel Quartus Prime - everything you need to work with Intel FPGA</a></li>
<li><a href="../45943/index.html">Eclipse and SFTP without problems</a></li>
<li><a href="../459430/index.html">Mobile application with automatic generation of forms: our case</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>