<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GameBoy Advance game protection against emulation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some of you may remember a series of noteworthy games for the Game Boy Advance, released during 2004. Light-gray cartridges with simple labels were ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GameBoy Advance game protection against emulation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/502/26c/ba9/50226cba91c34ad4a4d3e1c82040da8b.png"><br><br>  Some of you may remember a series of noteworthy games for the Game Boy Advance, released during 2004.  Light-gray cartridges with simple labels were very different from the usual, dark gray, with multi-colored labels.  They sold games ported to the original Nintendo Entertainment System.  These games, known in the USA as the <a href="http://nintendo.wikia.com/wiki/Classic_NES_Series">Classic NES Series</a> , are interesting for several reasons. <br><br>  They are especially interesting in terms of GBA emulation.  Usually, games for the Game Boy Advance are incredibly problematic, and the platform itself contains many tools to protect against failures.  Therefore, to run games, emulators must be compatible with the errors of the original equipment.  However, in the Classic NES Series, the developers went further and tried to protect the game from running in emulators. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/7f3/83a/cd8/7f383acd8f3f9bf85c097a2d43f55e53.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you tried to play in one of the old emulators, you probably saw the Game Pak Error screen.  As it turned out, these games use tricks and undefined behavior that complicate emulation.  It seems that it was a deliberate attempt to protect against copying such games.  In the interests of emulation accuracy, I painstakingly researched, implemented and recorded all the unusual actions performed in these games. <br><br><h2>  Trick 1: Memory Mirroring </h2><br>  The first trick used in games involves the Game Boy Advance memory structure.  GBA has a ‚Äúflat‚Äù (non-segmented) memory address space.  However, the top eight bits of the address signal the bus which device should have access to the memory at the moment.  00 is the BIOS, 02 is the main RAM, 03 is the RAM on the chip, etc.  However, since only 8 upper bits signal a device, and most devices have a very limited (less than 16 <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BA%25D0%25B8">mebibyte</a> ) address space, the bits between the upper 8 bits and the lower bits that signal the address in the device do not have a specific target. <br><br>  For example, the main RAM is 256 kibibytes.  This equals 18 bits of the address space.  This means that addresses in this area of ‚Äã‚Äãmemory are in the range from 02000000 to 0203FFFF, and everything from 02040000 to 02FFFFFF remains unaddressed.  In a conventional ARM device, accessing invalid addresses results in a data abort error (resetting data).  However, the GBA does not support data resets, so what is happening at this moment is particularly interesting.  Since the upper 8 bits are used to select a device, and the lower 18 bits are used for addressing in the device, 6 unused bits remain in the middle.  These unused bits are in fact simply <i>ignored</i> .  This means that when attempting to access data above valid memory areas in the main RAM, the upper bits are actually masked and only areas with valid addresses remain.  In some emulators, this property is called "mirrored" memory. <br><br>  Classic NES Series doesn't do anything special about mirrored memory: it copies the code to the main RAM, and then goes to one of these mirror addresses.  Such an action confuses some emulators, but thanks to the peculiarities of the implementation of memory areas, it never caused problems in mGBA.  However, this is still the easiest trick used in Classic NES. <br><br><h2>  Trick 2: code in VRAM </h2><br>  The further work of the games is much more interesting: they start copying data into video memory (VRAM), which in itself is perfectly normal, but then the execution of instructions is transferred to this data copied to video memory: after copying the code into the RAM area, usually reserved for graphics, it is executed there .  When I first saw this behavior of games, I thought that I had made some big mistake.  The transition to an invalid address is a typical symptom of an emulator failure.  This usually happens when copying to executable addresses or memory.  But after deep research, I realized that if you allow the game to execute code in video memory, there will be no failure and the work will be relatively stable.  There were still other problems, but it was obvious that this was a tactic to protect against emulation.  Using video memory in operations for which it was definitely not intended, at first confused me, but when I allowed games to do this work, I encountered other problems as well. <br><br><h2>  Trick 3: STM in DMA registers </h2><br>  The next trick is a very non-standard use of STM instructions.  STM (stands for ‚Äúmultiple storage‚Äù, multiple storage) is a class of instructions designed to pack multiple CPU registers into serial memory.  There are four types of STM instructions: subsequent decrement, preliminary decrement, subsequent increment and preliminary increment.  The description ‚Äúsubsequent decrement‚Äù refers to the structure of the packaged memory: the values ‚Äã‚Äãare stored alternately, the address is reduced by the size of the word after each word is saved.  Such an operation resembles the process of writing to memory in decreasing order.  If you save the values ‚Äã‚ÄãA, B, and C, they are stored in memory as CBA, so you can start with A, because this is the source address, and process the values ‚Äã‚Äãin reverse order. <br><br>  However, as Martin Korth wrote, the processor actually calculates in advance where the last register address will be, and writes the values ‚Äã‚Äãin the same order as in the case of increment instead of decrement.  Therefore, despite the fact that the CBA will be stored in memory as a result, it first writes C. The emulator will need to constantly calculate in advance how many registers will be stored, which can slow down work.  In general, the order of writing to memory may seem unimportant, especially for single-core processors, for which writing to memory can be considered atomic.  For the main RAM this may be true.  (Since the recording is done by one instruction, DMA ( <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D1%258F%25D0%25BC%25D0%25BE%25D0%25B9_%25D0%25B4%25D0%25BE%25D1%2581%25D1%2582%25D1%2583%25D0%25BF_%25D0%25BA_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8">direct memory access</a> ) cannot free up the CPU in the middle of the recording process.) However, in the Classic NES Series games, a tricky trick is done here: transferring DMA data for one instruction. <br><br>  DMA data transfers are used to efficiently copy memory from one area to another, often from Game Pak to main RAM, or from main RAM to sound FIFO buffers.  In the field of memory I / O registers there are three consecutive registers per DMA channel (there are four DMA channels in total), which can be recorded to configure DMA data transmission.  Usually, the game indicates the source and end addresses with two separate 32-bit entries, then starts the data transfer, recording the number and DMA control bits, or one final 32-bit entry, or two entries of 16 bits in each half of the control register. <br><br>  But the Classic NES Series games are much smarter: since these three registers are sequentially stored in memory, they use the STMIA and STMDA instructions to simultaneously record all three values.  STMIA is the simplest case: writing to one register, increment, writing to the next register, increment, writing to the control register, increment.  STMDA is a little different: it performs the decrement, so an ignorant emulator can write control bits to the address, which leads to incorrect transfer of DMA data.  Although A, B, and C are recorded as CBA, and the starting address is A, A must be recorded last.  I had to use the <a href="http://en.wikipedia.org/wiki/Hamming_weight">Hamming weight</a> for the writeable registers and <a href="">pick up the initial</a> write <a href="">offset</a> for the order to work properly.  After changing these operations according to the expectations of the equipment, the data transfer began to be performed properly. <br><br><h2>  Trick 4: hiding save types </h2><br>  But the tricks are not over.  The following trick is not so difficult, and in some other games it is also used.  The Game Boy Advance cartridge may have one or more save mechanisms.  Some games use save to NVRAM, which is byte-addressing.  They exist in memory block 0E and can be stored normally.  Other cartridges use flash memory in the same area and use a standard protocol to write bytes to flash memory or erase areas for reprogramming.  The third type is the EEPROM, it is located at the top of the Game Pak memory area (area 0D).  It uses a bit-level protocol that uses DMA data transmission to send a series of bits to the EEPROM for programming.  However, each game can have only one type of saving, and the cartridge header does not indicate which type is used in it.  Some emulators, including mGBA, try to determine the type of conservation, waiting until the game tries to interact with one of them.  But some games, including the Classic NES Series, are cheating emulators, trying to access the wrong type first.  For example, all these games use EEPROM, but pretend to use SRAM in them.  If they determine that they have written to SRAM, then demonstrate the Game Pak Error screen shown above.  This trick is pretty easy to get around, and the emulator <a href="https://github.com/mgba-emu/mgba/commit/c52edab71a0f3465c508b554130fdccb4108a654">checks</a> the game code <a href="https://github.com/mgba-emu/mgba/commit/c52edab71a0f3465c508b554130fdccb4108a654">in advance</a> .  If it detects the code associated with the Classic NES Series game, then it will forcibly change the save type to EEPROM. <br><br><h2>  Trick 5: prefetch violation </h2><br>  The next trick of these games turned out to be the hardest for me.  It took several days to complete the study, after which we had to make fairly low-level changes to the basic emulation cycle.  Device processors have a multi-step instruction flow process called a pipeline.  At each stage, a separate task is performed so that one part of the CPU is busy while the other is performing its own stage.  The conveyor is designed in such a way that after executing the instruction in one stage and passing it on to the next subsequent instruction, it can immediately take over the already vacated stage.  The Game Boy Advance ARM7TMDI processor has three steps that are necessary for accurate emulation: sampling (instructions), decoding, and execution.  At the sampling stage, a memory request is sent to the memory bus associated with the instruction.  Then it is passed to the decoding stage, at which the processor finds out what the instruction is.  And finally, the processor executes the instruction.  A naive interpreter will combine all three stages, either to speed up the work, or simply without knowing the principles of the work of the processors.  Until recently, the mGBA decoding and execution steps were combined.  However, when studying the code of Classic NES Series games, an important discovery was made: the game changed the instructions in the immediate vicinity of the execution stage.  Here is the assembler code derived from the classic NES Metroid video memory. <br><br><pre><code class="hljs css">06000260: <span class="hljs-selector-tag"><span class="hljs-selector-tag">E3A01000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#0</span></span> 06000264: <span class="hljs-selector-tag"><span class="hljs-selector-tag">E28FE008</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lr</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">pc</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#8</span></span> 06000268: <span class="hljs-selector-tag"><span class="hljs-selector-tag">E51F0010</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[$06000260]</span></span> 0600026<span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">E58E0000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">str</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[lr, #0]</span></span> 06000270: <span class="hljs-selector-tag"><span class="hljs-selector-tag">E3A010FF</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#255</span></span> 06000274: <span class="hljs-selector-tag"><span class="hljs-selector-tag">E3A010FF</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#255</span></span></code> </pre> <br>  The operation of the code is quite simple.  It saves 0 to r1, then loads the word at 06000260 into r0, saves it at 06000274. Then saves 255 to r1, and finally ... well, actually, I lied a little.  Notice that the last instruction in this assembly block is the same address that was stored two instructions earlier.  The value stored at this address is an instruction that saves the value 0 in r1 instead of 255. So what does this code do?  The answer depends on the length of the conveyor. <br><br>  The most important thing in understanding this block of code is to realize that after sending instructions to the pipeline, the change in memory that returns this address is not applicable.  This is similar to the principle of cache integrity, but an even more severe case.  This means that if the conveyor is long enough, the instruction going to the conveyor during recording will be as follows, which saves 255. If the conveyor is too short, it will save 0. As it turned out, the games are not loaded if they find the value 0 in the r1 register , and normally start with a value of 255. Realizing this, I had to extend the emulated pipeline into mGBA and insert a model of the stage between execution and selection.  In the real ARM7TDMI pipeline between these two stages there is a decoding stage.  However, I did not carefully read the specification and did not understand that this stage was implemented separately.  After <a href="https://github.com/mgba-emu/mgba/commit/28ac288d2cc753aab0493a471726cc5795a09363">adding one more stage of the pipeline</a> to the Classic NES Series game interpreter, they suddenly began to work! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/402/691/6b9/4026916b905e9e402d049e8daaf409a0.png" alt="image"><br><br><h2>  Trick 6: Inhomogeneities in the FIFO Buffer Sound </h2><br>  However, there is one difficulty: although the games can be played, the sound was hopelessly spoiled.  The solution required a little debugging, and this trick also turned out to be unique for the Classic NES Series and, therefore, due to incomplete overlap of specifications, it was implemented a little wrong.  Game Boy Advance has six audio channels: four procedurally generated audio channels (functionally enhanced channels of the original Game Boy) and two PCM audio channels.  As I understand it, Classic NES Series games use only one channel, one of the PCM channels.  PCM audio channels are controlled by a small internal FIFO buffer that starts DMA data transmission when a certain point is reached.  Games configure them to write 32 bits at a time into the I / O registers associated with each channel.  Since PCM channels are only 8 bits wide, 32-bit recording is actually four samples.  But the Classic NES Series games are a bit different: they write only 16 bits at a time, half, and not in a whole register.  Since I assumed that games could only write 32 bits at a time, this led to the emulator recording at one time two samples needed by the game and two empty samples.  This banal oversight completely distorted the sound in games.  After <a href="https://github.com/mgba-emu/mgba/commit/c52a5d2859a535cd439f914beffeb1f2eb49e9f6">making a simple fix the</a> game began to work normally. <br><br><h2>  We have achieved success, but why such difficulties? </h2><br>  I don‚Äôt know why Nintendo did all this for the sake of the usual ports of NES games.  Full-featured NES emulators have existed for a long time, good examples appeared in 1997.  Although it was the first time to play Classic NES Series games on a portable console, the Game Boy Advance emulation on other portable devices has existed for several years.  In addition, although the problems I listed prevented emulation in some projects, such protection was applied only in the Classic NES Series.  I don‚Äôt understand why they put so much effort into hindering the developers of emulators in this particular case, but for me this resulted in several long evenings of a consistent analysis of the functions of the game code until things got really bad. <br><br>  However, after eliminating all these problems, the games are started and run at 100%.  The most current fixes were made in version 0.1.0, but some major edits were postponed until later.  Games will be fully supported in version 0.2.0 after its release, and you can play them now in nightly releases. </div><p>Source: <a href="https://habr.com/ru/post/321198/">https://habr.com/ru/post/321198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321186/index.html">Plans to develop 3CX and a new training video course for partners and administrators</a></li>
<li><a href="../321188/index.html">Procrastination How to cage the demon who prevented to move towards the goal</a></li>
<li><a href="../321192/index.html">The digest of interesting materials for the mobile developer # 189 (January 30-February 5)</a></li>
<li><a href="../321194/index.html">Blockchain based guide</a></li>
<li><a href="../321196/index.html">Cloud Bottlenecks: Pokemon Go and Trivia Crack Stories</a></li>
<li><a href="../321202/index.html">The processor, it is a chipset, it is a chip, it is a platform, it is a system on a chip or what to pay attention to when choosing</a></li>
<li><a href="../321206/index.html">Analysis of Habrahabr and Geektimes articles</a></li>
<li><a href="../321208/index.html">Remote connection to the CodeMeter network key for ARCHICAD</a></li>
<li><a href="../321210/index.html">Classical labyrinth generation algorithms. Part 2: Immersion in Accident</a></li>
<li><a href="../321212/index.html">Study of the qualitative features of the dynamics of mathematical models of nonlinear nonautonomous systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>