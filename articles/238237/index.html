<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Universal metasystem in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habrhabr! 

 I want to share my experience in developing a metasystem for C ++ and embedding various scripting languages. 
 Relatively recently, I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Universal metasystem in C ++</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habrhabr! <br><br>  I want to share my experience in developing a metasystem for C ++ and embedding various scripting languages. <br>  Relatively recently, I began to write my game engine.  Of course, as in any good engine, there was a question about embedding a scripting language, and even better a few.  Of course, there are already enough tools for embedding a specific language (for example, luabind for Lua, boost.python for Python), and I didn't want to reinvent my own bike. <br><a name="habracut"></a><br>  I started by building simple and nimble Lua, and used luabind for binding.  And he looks really nice. <br><div class="spoiler">  <b class="spoiler_title">See for yourself</b> <div class="spoiler_text"><pre><code class="cpp hljs">class_&lt;BaseScript, ScriptComponentWrapper&gt;(<span class="hljs-string"><span class="hljs-string">"BaseComponent"</span></span>) .def(constructor&lt;&gt;()) .def(<span class="hljs-string"><span class="hljs-string">"start"</span></span>, &amp;BaseScript::start, &amp;ScriptComponentWrapper::default_start) .def(<span class="hljs-string"><span class="hljs-string">"update"</span></span>, &amp;BaseScript::update, &amp;ScriptComponentWrapper::default_update) .def(<span class="hljs-string"><span class="hljs-string">"stop"</span></span>, &amp;BaseScript::stop, &amp;ScriptComponentWrapper::default_stop) .property(<span class="hljs-string"><span class="hljs-string">"camera"</span></span>, &amp;BaseScript::getCamera) .property(<span class="hljs-string"><span class="hljs-string">"light"</span></span>, &amp;BaseScript::getLight) .property(<span class="hljs-string"><span class="hljs-string">"material"</span></span>, &amp;BaseScript::getMaterial) .property(<span class="hljs-string"><span class="hljs-string">"meshFilter"</span></span>, &amp;BaseScript::getMeshFilter) .property(<span class="hljs-string"><span class="hljs-string">"renderer"</span></span>, &amp;BaseScript::getRenderer) .property(<span class="hljs-string"><span class="hljs-string">"transform"</span></span>, &amp;BaseScript::getTransform)</code> </pre> <br></div></div><br>  It is easy to read, the class is registered simply and without problems.  But this solution is exclusively for Lua. <br><br>  Inspired by the Unity scripting system, I realized that there should definitely be several languages ‚Äã‚Äãin the system, as well as the possibility of their interaction with each other.  And here such tools as luabind give up slack: for the most part they are written using C ++ templates and generate code only for a specific language.  Each class must be registered in each system.  At the same time, you need to add a lot of header files and manually enter everything into the templates. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But I want to have a common type database for all languages.  And also the ability to download information about the types of plug-ins directly in runtime.  For these purposes, binding libraries are not suitable.  Need a real metasystem.  But here, too, it was not all smooth.  Finished libraries were rather cumbersome and inconvenient.  There are some very elegant solutions, but they draw additional dependencies and require the use of special tools (for example, Qt moc or gccxml).  There are, of course, quite nice options, such as, for example, the Camp reflection library.  It looks almost the same as luabind: <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cpp hljs">camp::Class::declare&lt;MyClass&gt;(<span class="hljs-string"><span class="hljs-string">"FunctionAccessTest::MyClass"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ***** constant value ***** .function("f0", &amp;MyClass::f).callable(false) .function("f1", &amp;MyClass::f).callable(true) // ***** function ***** .function("f2", &amp;MyClass::f).callable(&amp;MyClass::b1) .function("f3", &amp;MyClass::f).callable(&amp;MyClass::b2) .function("f4", &amp;MyClass::f).callable(boost::bind(&amp;MyClass::b1, _1)) .function("f5", &amp;MyClass::f).callable(&amp;MyClass::m_b) .function("f6", &amp;MyClass::f).callable(boost::function&lt;bool (MyClass&amp;)&gt;(&amp;MyClass::m_b)); }</span></span></code> </pre><br></div></div><br>  True performance of such "beautiful" solutions leaves much to be desired.  Of course, like any ‚Äúnormal‚Äù programmer, I decided to write my metasystem.  This is how the uMOF library appeared. <br><br><h5>  Meet uMOF </h5><br>  uMOF is a cross-platform open source library for metaprogramming.  Conceptually, it resembles Qt, but it is implemented using templates, which Qt itself refused at the time.  They did this for code readability.  And so really faster and more compact.  But using the moc compiler makes it totally dependent on Qt.  This is not always justified. <br><br>  Let's get to the point nevertheless.  To make the metadata available to the user in the class of the Object inheritor, you need to register OBJECT macros with inheritance hierarchy and EXPOSE to declare functions.  After that, the class API is available, which stores information about the class, functions, and public properties. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object { OBJECT(Test, Object) EXPOSE(Test, METHOD(func), METHOD(null), METHOD(test) ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Test() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"test"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; Test t; Method m = t.api()-&gt;method(<span class="hljs-string"><span class="hljs-string">"func(int,int)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = any_cast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(m.invoke(&amp;t, args)); Any res = Api::invoke(&amp;t, <span class="hljs-string"><span class="hljs-string">"func"</span></span>, {<span class="hljs-number"><span class="hljs-number">5.0f</span></span>, <span class="hljs-string"><span class="hljs-string">"6.0"</span></span>});</code> </pre><br></div></div><br>  While the definition of meta-information is invasive, an external variant is also planned for a more convenient wrapping of third-party code. <br><br>  Due to the use of advanced templates, uMOF turned out to be very fast, while being quite compact.  This also led to some restrictions:  C ++ 11 features are actively used, not all compilers are suitable (for example, to compile on Windows, you need the latest Visual C ++ November CTP).  Also, not everyone will like the use of templates in the code, so everything is wrapped up in macros.  Meanwhile, the macros hide a large number of templates and the code looks pretty neat. <br><br>  In order not to be unfounded I cite the results of benchmarks. <br><br><h5>  Test results </h5><br>  I compared the metasystems by three parameters: compile / link time, executable file size, and function call time in a loop.  As a reference, I took an example with native function calls.  The subjects were tested on Windows under Visual Studio 2013. <br><table><tbody><tr><th>  Framework </th><th>  Compile / Link time, ms </th><th>  Executable size, KB </th><th>  Call time spent *, ms </th></tr><tr><td>  Native </td><td>  371/63 </td><td>  12 </td><td>  2 (45 **) </td></tr><tr><td>  uMOF </td><td>  406/78 </td><td>  18 </td><td>  359 </td></tr><tr><td>  Camp </td><td>  4492/116 </td><td>  66 </td><td>  6889 </td></tr><tr><td>  Qt </td><td>  1040/80 (129 ***) </td><td>  15 </td><td>  498 </td></tr><tr><td>  cpgf </td><td>  2514/166 </td><td>  71 </td><td>  1184 </td></tr></tbody></table><br><div class="spoiler">  <b class="spoiler_title">Footnotes</b> <div class="spoiler_text">  * 10.000.000 calls <br>  ** Force no inlining <br>  *** Meta object compiler <br></div></div><br>  For clarity, the same thing in the form of graphs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a5d/1b8/964/a5d1b89649766a1a2b5a241e8d320dce.png" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/758/2b1/7fa/7582b17faaf2b00eed9c3e4004a1cb71.png" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0f/07b/421/c0f07b421f15b060cffb5506ddf79932.png" alt="image"><br><br>  I also looked at a few more libraries: <br><br><ul><li>  Boost.Mirror; </li><li>  XcppRefl; </li><li>  Reflex; </li><li>  XRtti. </li></ul><br>  But they did not fall into the role of subjects for various reasons.  Boost.Mirror and XcppRefl look promising, but are still under active development.  Reflex requires GCCXML, I did not find any adequate replacement for Windows.  XRtti again in the current release does not support Windows. <br><br><h5>  What is under the hood </h5><br>  So, how it all works.  The speed and compactness of the library give templates with functions as arguments, as well as variadic templates.  All meta information by type is organized as a set of static tables.  There is no additional load in runtime.  A simple structure in the form of an array of pointers does not give the code much swell. <br><div class="spoiler">  <b class="spoiler_title">Sample Method Description Template</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Class, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Return, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoker</span></span></span><span class="hljs-class">&lt;Return(Class::*)(Args...)&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Return</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class::*Fun)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args...)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">argCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Args); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> TypeTable **</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">types</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TypeTable *staticTypes[] = { Table&lt;Return&gt;::get(), getTable&lt;Args&gt;()... }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> staticTypes; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>... Is&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Any </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object *obj, F f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Any *args, unpack::indices&lt;Is...&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Class *&gt;(obj)-&gt;*f)(any_cast&lt;Args&gt;(args[Is])...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;Fun fun&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Any </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Any *args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc != <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Args)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Bad argument count"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invoke(obj, fun, args, unpack::indices_gen&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Args)&gt;()); } };</code> </pre><br></div></div><br>  An important role in efficiency is also played by the class Any, which allows you to rather compactly store types and information about them.  The basis was the hold_any class from the boost spirit library.  Templates are also actively used here to effectively wrap types.  Types smaller than a pointer are stored in size directly in void *, for larger types the pointer refers to an object of type. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyHelper</span></span></span><span class="hljs-class">&lt;T, True&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Bool&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_pointer&lt;T&gt;::value&gt; is_pointer; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CheckType&lt;T, is_pointer&gt;::type T_no_cv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T **src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (dest)T(*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(src)); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyHelper</span></span></span><span class="hljs-class">&lt;T, False&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Bool&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_pointer&lt;T&gt;::value&gt; is_pointer; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CheckType&lt;T, is_pointer&gt;::type T_no_cv; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T **src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **dest)</span></span></span><span class="hljs-function"> </span></span>{ *dest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(**src); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; Any::Any(T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; x) : _table(Table&lt;T&gt;::get()), _object(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T *src = &amp;x; AnyHelper&lt;T, Table&lt;T&gt;::is_small&gt;::clone(&amp;src, &amp;_object); }</code> </pre><br></div></div><br>  RTTI also had to be abandoned, too slowly.  Type checking is done solely by comparing pointers to a type table.  All type modifiers are pre-cleared, otherwise, for example, int and const int will be different types.  But in fact, their size is single, and in general it is the same type. <br><div class="spoiler">  <b class="spoiler_title">Another example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_cast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Any* operand)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operand &amp;&amp; operand-&gt;_table == Table&lt;T&gt;::get()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnyHelper&lt;T, Table&lt;T&gt;::is_small&gt;::cast(&amp;operand-&gt;_object); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre><br></div></div><br><h5>  How to use it </h5><br>  Embedding scripting languages ‚Äã‚Äãhas become easy and enjoyable.  For example, for Lua, it suffices to define a generic call function that checks the number of arguments and their types and, of course, calls the function itself.  Binding is also not difficult.  For each function in Lua, it is enough to save the MetaMethod in upvalue.  By the way, all objects in uMOF are ‚Äúthin‚Äù, that is, just a wrapper over a pointer that refers to an entry in a static table.  Therefore, you can copy them without concern about performance. <br><br>  An example of a Lua binding: <br><div class="spoiler">  <b class="spoiler_title">Example, a lot of code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;lua/lua.hpp&gt; #include &lt;object.h&gt; #include &lt;cassert&gt; #include &lt;iostream&gt; class Test : public Object { OBJECT(Test, Object) EXPOSE( METHOD(sum), METHOD(mul) ) public: static double sum(double a, double b) { return a + b; } static double mul(double a, double b) { return a * b; } }; int genericCall(lua_State *L) { Method *m = (Method *)lua_touserdata(L, lua_upvalueindex(1)); assert(m); // Retrieve the argument count from Lua int argCount = lua_gettop(L); if (m-&gt;parameterCount() != argCount) { lua_pushstring(L, "Wrong number of args!"); lua_error(L); } Any *args = new Any[argCount]; for (int i = 0; i &lt; argCount; ++i) { int ltype = lua_type(L, i + 1); switch (ltype) { case LUA_TNUMBER: args[i].reset(luaL_checknumber(L, i + 1)); break; case LUA_TUSERDATA: args[i] = *(Any*)luaL_checkudata(L, i + 1, "Any"); break; default: break; } } Any res = m-&gt;invoke(nullptr, argCount, args); double d = any_cast&lt;double&gt;(res); if (!m-&gt;returnType().valid()) return 0; return 0; } void bindMethod(lua_State *L, const Api *api, int index) { Method m = api-&gt;method(index); luaL_getmetatable(L, api-&gt;name()); // 1 lua_pushstring(L, m.name()); // 2 Method *luam = (Method *)lua_newuserdata(L, sizeof(Method)); // 3 *luam = m; lua_pushcclosure(L, genericCall, 1); lua_settable(L, -3); // 1[2] = 3 lua_settop(L, 0); } void bindApi(lua_State *L, const Api *api) { luaL_newmetatable(L, api-&gt;name()); // 1 // Set the "__index" metamethod of the table lua_pushstring(L, "__index"); // 2 lua_pushvalue(L, -2); // 3 lua_settable(L, -3); // 1[2] = 3 lua_setglobal(L, api-&gt;name()); lua_settop(L, 0); for (int i = 0; i &lt; api-&gt;methodCount(); i++) bindMethod(L, api, i); } int main(int argc, char *argv[]) { lua_State *L = luaL_newstate(); luaL_openlibs(L); bindApi(L, Test::classApi()); int erred = luaL_dofile(L, "test.lua"); if (erred) std::cout &lt;&lt; "Lua error: " &lt;&lt; luaL_checkstring(L, -1) &lt;&lt; std::endl; lua_close(L); return 0; }</span></span></span></span></code> </pre><br></div></div><br><h5>  Conclusion </h5><br>  So, what we have: <br>  Advantages of uMOF: <br><ul><li>  Compact; </li><li>  Fast; </li><li>  Does not require third-party tools, only a modern compiler. </li></ul><br>  Disadvantages of uMOF: <br><ul><li>  Not supported by all compilers; </li><li>  The auxiliary macros are rather clumsy. </li></ul><br>  The library is still quite raw, I would like to do a lot of interesting things - functions of variable arity (read, default parameters), non-invasive type registration, signals about changes in object properties.  And all this will surely appear, because the method has shown very good results. <br><br>  Thank you all for your attention.  I hope the library will be useful for someone. <br><br>  The project can be found on the <a href="https://bitbucket.org/occash/umof">link</a> .  Write your feedback and recommendations in the comments. </div><p>Source: <a href="https://habr.com/ru/post/238237/">https://habr.com/ru/post/238237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238223/index.html">ASUS RT-N18U Wireless Router Overview</a></li>
<li><a href="../238225/index.html">Adobe is leaving Russia</a></li>
<li><a href="../238231/index.html">Jump start on October 7th. Modernizing the company's IT infrastructure using Windows Server 2012 R2</a></li>
<li><a href="../238233/index.html">Creating a multi-user touch-enabled interface for Windows</a></li>
<li><a href="../238235/index.html">Police drones are looking for undeclared mansions in Argentina</a></li>
<li><a href="../238241/index.html">Access to HID devices from a Qt program for Android</a></li>
<li><a href="../238245/index.html">IB in American. Part 1. What is NIST 800-53 and what do security controls look like?</a></li>
<li><a href="../238247/index.html">How to buy gold?</a></li>
<li><a href="../238249/index.html">Cybercortex. Extended Perception and Thinking System</a></li>
<li><a href="../238253/index.html">DVR ParkCity DVR HD 450: tested on the roads</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>