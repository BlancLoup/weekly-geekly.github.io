<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why Go is Bad for Stupid Programmers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is written as a response to a previously published antipode article . 





 Over the past two years, I have been using Go to implement a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why Go is Bad for Stupid Programmers</h1><div class="post__text post__text-html js-mediator-article"><p>  The article is written as a response to a previously published <a href="https://habr.com/ru/post/344356/">antipode article</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac9/24e/5c8/ac924e5c8c90275379b035cfa5b1f23b.jpg" alt="image"></p><br><p>  Over the past two years, I have been using Go to implement a specialized RADIUS server with an advanced billing system.  In the course of studying the subtleties of the language itself.  Programs themselves are very simple and are not the goal of writing an article, but the experience of using Go deserves to say a few words in its defense.  Go is becoming an increasingly popular language for serious scalable code.  The language was created in Google, in which it is actively used.  Having drawn the line, I sincerely believe that the design of the Go language is bad for non-intelligent programmers. </p><a name="habracut"></a><br><h1>  Created for weak programmers? </h1><br><blockquote>  The weak talk about problems.  Strong talk about ideas and dreams ... </blockquote><p>  Go is very easy to learn, so simple that you can read the code with little or no training at all.  This feature of the language is used in many global companies when the code is read together with non-core specialists (managers, customers, etc.).  This is very convenient for methodologies such as Design Driven Development. </p><br><p>  Even novice programmers begin to issue quite a decent code after a week or two.  The book on which I studied Go is called ‚ÄúProgramming in Go‚Äù (written by Mark Summerfield).  The book is very good, it affects many of the nuances of the language.  After unreasonably complicated languages ‚Äã‚Äãsuch as Java, PHP, the lack of magic acts refreshingly.  But sooner or later, many limited programmers have a desire to use the old methods in the new field.  Is it really necessary? </p><br><p>  Rob Pike (the main ideologue of the language) created the Go language, as an industrial language that is easy to understand, effective in use.  The language is designed for maximum productivity in large teams and there is no doubt about it.  Many novice programmers complain that there are many features that they lack.  This striving for simplicity was a conscious decision of the developers of the language and, in order to fully understand why this was necessary, we must understand the motivation of the developers and what they sought in Go. </p><br><p>  So why was it created so simple?  Here are a couple of Rob Pike quotes: </p><br><blockquote>  The key point here is that our programmers are not researchers.  As a rule, they are very young, they come to us after their studies, they have probably studied Java, or C / C ++, or Python.  They are not able to understand the outstanding language, but at the same time we want them to create good software.  That is why language should be easy to understand and learn. <br><br>  He should be familiar, roughly speaking similar to C.  Google programmers start their careers early and most of them are familiar with procedural languages, in particular the C family.  The demand for fast productivity in a new programming language means that the language should not be too radical. <br></blockquote><p>  Wise words, isn't it? </p><br><h1>  Simplicity artifacts </h1><br><blockquote>  Simplicity is a prerequisite for beauty.  Lev Tolstoy. </blockquote><p>  Being simple is one of the most important aspirations in any design.  As you know, a perfect project is not a project where there is nothing to add, but one in which there is nothing to remove.  Many believe that in order to solve (or even express) complex problems, a complex tool is needed.  However, it is not.  Take for example the language PERL.  The ideologists of the language believed that the programmer should have at least three different ways to solve one problem.  The ideologists of the Go language went the other way, they decided that to achieve the goal one way is enough, but really good.  Such an approach has a serious foundation: the only way is easier to learn and harder to forget. </p><br><p>  Many migrants complain that the language does not contain elegant abstractions.  Yes, it is, but this is one of the main advantages of the language.  The language contains in its composition a minimum of magic - therefore, deep knowledge is not required for reading the program.  As for the verbosity of the code, this is not a problem at all.  A well-written program in the Golang language is readable vertically, with almost no structuring.  In addition, the speed of reading the program at least an order of magnitude greater than the speed of writing.  If we consider that all the code has uniform formatting (done with the built-in gofmt command), then reading a few extra lines is not a problem at all. </p><br><h1>  Not very expressive </h1><br><blockquote>  Art does not tolerate when its freedom is constrained.  Accuracy is not his responsibility. </blockquote><p>  Because of the desire for simplicity in Go, there are no constructions that are perceived in other languages ‚Äã‚Äãas something natural by people who are used to them.  At first this may be somewhat inconvenient, but then you notice that the program is read at times simpler and more unambiguous. </p><br><p>  For example, a console utility that reads stdin or a file from the command line arguments will look like this: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bufio"</span></span> <span class="hljs-string"><span class="hljs-string">"flag"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { flag.Parse() scanner := newScanner(flag.Args()) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { text += scanner.Text() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := scanner.Err(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } fmt.Println(text) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newScanner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(flags []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bufio</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scanner</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(flags) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bufio.NewScanner(os.Stdin) } file, err := os.Open(flags[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bufio.NewScanner(file) }</code> </pre> <br><p>  The solution of the same problem in the D language, although it looks somewhat shorter, however, is not read at all easier. </p><br><pre> <code class="plaintext hljs">import std.stdio, std.array, std.conv; void main(string[] args) { try { auto source = args.length &gt; 1 ? File(args[1], "r") : stdin; auto text = source.byLine.join.to!(string); writeln(text); } catch (Exception ex) { writeln(ex.msg); } }</code> </pre> <br><h1>  Hell copy </h1><br><blockquote>  The man wears hell in himself.  Martin luther </blockquote><p>  Newbies constantly complain about Go in terms of lack of generics.  To resolve this issue, most of them use direct copying code.  For example, such pseudo-professionals believe that the function for summing the list of integers is that it is impossible to implement the functionality in any way other than by simple copying and pasting for each data type. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(list); x++ { result += list[x] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(result) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(list); x++ { result += list[x] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(result) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { list32 := []<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} list64 := []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} fmt.Println(int32Sum(list32)) fmt.Println(int64Sum(list64)) }</code> </pre> <br><p>  There are sufficient means in the language to implement such constructions.  For example, generic programming is fine. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> list { res = fn(res, val) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32Sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int32</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a - b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(list []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, val := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> list { res = fn(res, val) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64Sub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a - b } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { list32 := []<span class="hljs-keyword"><span class="hljs-keyword">int32</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} list64 := []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>} fmt.Println(Eval32(list32, int32Add)) fmt.Println(Eval64(list64, int64Add)) fmt.Println(Eval64(list64, int64Sub)) }</code> </pre> <br><p>  And, although our code turned out to be somewhat longer than the previous case, but it became generalized.  Therefore, we will not be difficult to implement all the arithmetic operations. </p><br><p>  Many will say that a program in D looks much shorter and will be right. </p><br><pre> <code class="plaintext hljs">import std.stdio; import std.algorithm; void main(string[] args) { [1, 2, 3, 4, 5].reduce!((a, b) =&gt; a + b).writeln; }</code> </pre> <br><p>  However, only shorter, but not correct, since the implementation on D completely ignores the problem of error handling. </p><br><p>  In real life, when the complexity of logic increases, the gap is rapidly narrowing.  Even more rapidly, the gap is reduced when an action is required to be performed that cannot be performed with the help of standard language operators. </p><br><p>  In terms of maintainability, extensibility, readability, in my opinion, the Go language wins, although it loses in wordiness. </p><br><p>  Generalized programming in some cases gives us an undeniable benefit.  This clearly illustrates the sort package.  So, to sort any list, we just need to implement the interface sort.Interface. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"sort"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Names []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Len</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(ns) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Less</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ns[i] &lt; ns[j] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ns Names)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ns[i], ns[j] = ns[j], ns[i] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { names := Names{<span class="hljs-string"><span class="hljs-string">"London"</span></span>, <span class="hljs-string"><span class="hljs-string">"Berlin"</span></span>, <span class="hljs-string"><span class="hljs-string">"Rim"</span></span>} sort.Sort(names) }</code> </pre> <br><p>  If you take any open source project and execute the grep "interface {}" -R command, you will see how often the used interfaces are used.  Comrade comrades will immediately say that all this is due to the lack of generics.  However, this is not always the case.  Take for example the language DELPHI.  Despite the fact that he has these same generics, it contains a special type of VARIANT for operations with arbitrary data types.  The Go language does the same. </p><br><h1>  From the gun on the sparrows </h1><br><blockquote>  And the straitjacket must match the size of the madness.  Stanislav Lec. </blockquote><p>  Many extreme lovers can say that Go has another mechanism for creating generics - reflection.  And they will be right ... but only in rare cases. </p><br><p>  Rob Pike warns us: </p><br><blockquote>  It is a powerful tool that should be used with care.  It should be avoided as long as it is not strictly necessary. <br></blockquote><p>  Wikipedia tells us the following: </p><br><blockquote>  Reflection means a process during which a program can monitor and modify its own structure and behavior at run time.  The programming paradigm underlying reflection is called reflexive programming.  This is a type of metaprogramming. <br></blockquote><p>  However, as you know, you have to pay for everything.  In this case, it is: </p><br><ul><li>  complexity of writing programs </li><li>  program execution speed </li></ul><br><p>  Therefore, it is necessary to use reflection with caution, as tools of large caliber.  Thoughtless use of reflection leads to unreadable programs, constant errors and low speed.  Just the fact that a snob-programmer could show off his code in front of other, more pragmatic and modest colleagues. </p><br><h1>  Cultural baggage from C?  No, from a number of languages! </h1><br><blockquote>  Along with the state, heirs are also left with debts. </blockquote><p>  Despite the fact that many people believe that the language is completely based on the legacy of C, this is not the case.  The language has incorporated many aspects of the best programming languages. </p><br><h2>  Syntax </h2><br><p>  First of all, the syntax of grammatical structures is based on the syntax of the C language.  However, the DELPHI language also had a significant impact.  So, we see that the excess brackets are completely removed, so greatly reducing the readability of the program.  The language also contains the operator ": =" inherent in the DELPHI language.  The concept of packages is borrowed from languages ‚Äã‚Äãlike ADA.  The declaration of unused entities is borrowed from the PROLOG language. </p><br><h2>  Semantics </h2><br><p>  The basis of the packages was taken the semantics of the language DELPHI.  Each package encapsulates data and code and contains private and public entities.  This allows the package interface to be reduced to a minimum. </p><br><p>  The implementation of the delegation method was borrowed from the DELPHI language. </p><br><h2>  Compilation </h2><br><p>  No wonder there is a joke: Go was developed while the C program was compiled.  One of the strengths of the language is super-fast compilation.  The idea was borrowed from the DELPHI language.  In addition, each Go package corresponds to the DELPHI module.  These packages are recompiled only when really necessary.  Therefore, after the next edit, it is not necessary to compile the entire program, and it is enough to recompile only the modified packages and packages that depend on these modified packages (and only then, if the package interfaces have changed). </p><br><h2>  High level designs </h2><br><p>  The language contains many different high-level constructions that are not related to low-level C-type languages. </p><br><ul><li>  Strings </li><li>  Hash table </li><li>  Slices </li><li>  Duck typing is borrowed from languages ‚Äã‚Äãlike RUBY (which, unfortunately, many do not understand and do not use at full power). </li></ul><br><h2>  Memory management </h2><br><p>  Memory management generally deserves a separate article.  If in languages ‚Äã‚Äãlike C ++, control is completely given to the developer, in later languages ‚Äã‚Äãlike DELPHI, the reference counting model was used.  With this approach, cyclic references were not allowed, since lost clusters were formed, then Go is integrated with detection of such clusters (as in C #).  In addition, garbage collector surpasses most currently known implementations in performance and can already be used for many real-time tasks.  The language itself recognizes situations where the value for storing a variable can be allocated on the stack.  This reduces the load on the memory manager and increases the speed of the program. </p><br><h2>  Parallelism and competitiveness </h2><br><p>  The parallelism and competitiveness of language is beyond praise.  No low-level language can even remotely compete with the Go language.  In fairness, it is worth noting that the model was not invented by the authors of the language, but simply borrowed from the good old ADA language.  The language is able to handle millions of parallel connections involving all CPUs, while having an order less than the typical for multi-threaded code complex problems with deadlocks and race conditions. </p><br><h1>  Additional benefits </h1><br><blockquote>  If it is profitable, everyone will become disinterested. </blockquote><p>  The language also provides us with a number of undoubted benefits: </p><br><ul><li>  The only executable file after building the project greatly simplifies the deploy application. </li><li>  Static typing and type inference can significantly reduce the number of errors in the code, even without writing tests.  I know some programmers who generally do without writing tests and at the same time the quality of their code does not significantly suffer. </li><li>  Very simple cross-compilation and excellent portability of the standard library, which greatly simplifies the development of cross-platform applications. </li><li>  RE2 regular expressions are thread-safe and with predictable runtime. </li><li>  Powerful standard library, which allows in most projects to do without third-party frameworks. </li><li>  The language is powerful enough to concentrate on the task, and not on the methods of solving it, and at the same time low enough so that the task can be solved effectively. </li><li>  The eco system Go already contains out of the box a developed toolkit for all occasions: tests, documentation, package management, powerful linters, code generation, race conditions detector, etc. </li><li>  Go version 1.11 has a built-in semantic dependency management, built on top of the popular VCS hosts.  All the tools that make up the Go ecosystem use these services to download, build, and install code from them in one fell swoop.  And this is great.  With the advent of version 1.11, the problem with versioning packages was also completely resolved. </li><li>  Since the main idea of ‚Äã‚Äãthe language is to reduce magic, the language encourages developers to perform error handling explicitly.  And rightly so, because otherwise, he will simply forget about error handling altogether.  Another thing is that most developers deliberately ignore error handling, preferring instead to handle them, just to send an error up. </li><li>  The language does not implement the classical OOP methodology, since Go is no virtuality in its pure form.  However, this is not a problem when using interfaces.  The lack of OOP significantly reduces the entry barrier for beginners. </li></ul><br><h1>  Simplicity for community benefits </h1><br><blockquote>  Complicate is simple, difficult to simplify. </blockquote><p>  Go was designed to be simple and he succeeded in this goal.  It was written for smart programmers who understand all the advantages of teamwork and are tired of the infinite variability of Enterprise level languages.  Having a relatively small set of syntactic structures in its arsenal, it is almost not subject to change over time, so developers have plenty of time freed up precisely for development, and not for endless learning of language innovations. </p><br><p>  Companies also receive a number of advantages: a low entry threshold allows you to quickly find a specialist, and the immutability of the language allows you to use the same code 10 years later. </p><br><h1>  Conclusion </h1><br><blockquote>  The large size of the brain has not made a single elephant the Nobel Prize. </blockquote><p>  For those programmers whose personal ego prevails over team spirit, as well as theorists who love academic tasks and endless "self-improvement", the language is really bad, because it is a general-purpose artisan language that does not allow one to get aesthetic pleasure from the result of his work and show himself a professional in front of colleagues (provided that we measure the mind with these criteria, and not with the IQ coefficient).  Like everything in life - this is a matter of personal priorities.  Like all upcoming innovations, the language has already come a long way from general denial to mass recognition.  The language is ingenious in its simplicity, and, as you know, everything ingenious is simple! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/448932/">https://habr.com/ru/post/448932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448894/index.html">RetroPie Raspberry Case - From SlideShower</a></li>
<li><a href="../448896/index.html">Hypermys Theory</a></li>
<li><a href="../448904/index.html">The digest of fresh materials from the world of the frontend for the last week No. 361 (April 15 - 21, 2019)</a></li>
<li><a href="../448920/index.html">Using JavaScript console in browsers</a></li>
<li><a href="../448922/index.html">Artificial intelligence improves the graphics quality of old video games and does it really well.</a></li>
<li><a href="../448934/index.html">Free links, or what to do at your leisure site owner</a></li>
<li><a href="../448936/index.html">Speech formalization. Some considerations</a></li>
<li><a href="../448942/index.html">Cryptocurrency: lives or dies?</a></li>
<li><a href="../448944/index.html">Fluent 1.0: flexible localization system</a></li>
<li><a href="../448946/index.html">How to start using R in Enterprise. An example of a practical approach</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>