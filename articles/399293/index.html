<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Psychology of code readability</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everything that is written below never claims to be the absolute truth, but it still represents some model that helps me personally find ways to write...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Psychology of code readability</h1><div class="post__text post__text-html js-mediator-article">  Everything that is written below never claims to be the absolute truth, but it still represents some model that helps me personally find ways to write a little better code. <br><br>  Every programmer tries to write good code.  Readability is one of the main features of such a code.  A lot of books have been written about her, but there are still gaps in the subject.  For example, those very books are focused more on tips on HOW to write a readable code, and not on the reasons why one code is well readable, and the other not.  The book tells us "use the appropriate variable names" - but what makes one name more appropriate than another?  Does this work for all examples of this code?  Does this work for all programmers who will catch this code?  I would like to talk about the latter in more detail.  Let's dive a bit into the human psyche.  Our brain is our main tool, it would be good to study the specifics of his work. <br><a name="habracut"></a><br><h3>  Psychological foundation </h3><br>  Every programmer knows that the capabilities of our brain are not limitless.  There is a limit on the number of things we can think about.  This is our <a href="https://en.wikipedia.org/wiki/Working_memory">working memory limit</a> .  There is an old myth that a person can hold 7 ¬± 2 objects in memory at the same time.  This is called " <a href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two">Magic number seven</a> " and it is actually not very accurate.  Recent studies speak of the number 4 ¬± 1, or even less.  In any case, the number of ideas that we can keep in mind at the same time is very limited. <br><br>  Some people will say that they can easily handle more than four objects in memory at the same time.  This is true: fortunately, there is another process that is constantly happening in our head - this is grouping.  We combine similar small entities into slightly larger ones and operate with them already.  Remember how you call dates or phone numbers - not one digit at a time, but in groups of two, three or four.  In addition, each group of numbers is an independent entity.  Moreover, all the figures together form a "date" or "phone number" - also separate entities. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/e60/756/fc9/e60756fc983c1453af165a3578862f62.png" alt="image"><br><br>  From these groups we build our long-term memory.  I imagine it as a great web of such small groups and their sequences. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/871/208/00b/87120800b8ec4d445c6acc99e456d2c8.png" alt="image"><br><br>  Based on this picture, it may seem to you that moving from one part of the memory to another happens rather slowly.  And indeed it is.  In the science of user interface design, there is the concept of a "single focus of attention."  The name speaks for itself - we can only focus on one thing at a time.  Moreover, in addition to the focus, there is also a ‚Äúlocus‚Äù - the limited attention in space. <br><br>  You might think that this is the same as the working memory limit mentioned above, but there is an important difference.  The working memory limit tells you how many entities we can hold in memory.  The focus and locus of attention suggests that in order to perform some useful mental work, these entities also need to be ‚Äúclose by‚Äù, connected with something. <br><br>  It is important to know about the focus and locus of attention, since switching between ideas is a <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3197943/">very expensive process</a> .  And it becomes even more costly when we need to think about unfamiliar entities and group them on the go.  Fortunately, it works in the opposite direction - the better we know something, the less time it takes to switch attention to it and make sense of it.  This is called experience. <br><br>  We also remember things differently depending on the context.  Once the following <a href="">experiment</a> was carried out: a group of divers were read a set of words, and then, after a while, they were asked to reproduce them.  Both the initial reading and the reproduction were carried out both on land and in water.  Best of all was the case when the words were both read and reproduced on land.  But in the second place was a combination with reading and reproduction in water.  People remembered words in the context of their surroundings, and similar environments helped to remember better. <br><br>  From contexts and entities grouped in memory cells, we build <a href="https://en.wikipedia.org/wiki/Mental_representation">mental representations</a> and <a href="https://en.wikipedia.org/wiki/Mental_model">mental models</a> .  Mental models play a key role in our ability to find solutions to problems.  For the same problem, you can build different mental models, and each will have its pros and cons.  There is also the main problem in their construction and application: our brain.  Oh, our brain has a whole bunch of different flaws. <br><br>  Firstly, it is difficult for him to work with abstractions.  When some entities seem similar, they are located in the brain "close", are connected.  This leads to the fact that the brain sometimes makes mistakes which of them should be extracted and used in each particular case.  Example: confusion between l and 1, 0 and O. Another example is ambiguity.  "Key" - are we now about the subject for opening locks, building a flock of birds or a tool to work with nuts? <br><br>  Uncertainty about the correctness of the found abstraction slows down the process of thinking.  For a split second - but this may be enough to lose focus.  We can do a lot of things in general, but if we are able to understand, localize and filter out major distractions, then we may not be aware of ‚Äúevery little thing‚Äù.  If someone calls random numbers, as long as you think something, it will become much more difficult to count.  This can happen with visual factors: if there are several important objects on the screen and a couple of dozens of unimportant in the current situation, it will be more difficult for you to select and realize only the important ones. <br><br>  All of the above creates a cognitive load.  This is the amount of mental effort that is needed to solve a task.  Our ‚Äúoperational capacity‚Äù falls as we work and increases after a rest.  If you don‚Äôt give your head a conscious rest, you won‚Äôt be fooled by nature anyway, and after a while your brain will begin to ‚Äúsoar in the clouds‚Äù. <br><br>  Let's now get to the point and think about how it all concerns writing good code.  Next will be a few recommendations, rules of thumb and paradigms that can somehow help you in terms of psychology.  This, of course, is not a fundamental guide, but I hope you will catch the main ideas and will be able to use them further to evaluate other rules, tips and paradigms that you know. <br><br><h3>  Entity naming </h3><br>  Let's take a look at a simple for loop: <br><br><ul><li>  <b>A.</b>  for (i = 0 to N) </li><li>  <b>B.</b>  for (theElementIndex = 0 to theNumberOfElementsInTheList) </li></ul><br>  Which option do you like more?  Most programmers will recommend option <b>A.</b>  Why?  Because option <b>B</b> uses variable names that are too long, which prevents us from seeing at once a single (and well-known) pattern.  In addition, in this case, such long names do not help to create a better context, they simply add noise. <br><br>  Now let's look at the different ways of forming namespaces (these can be packages, modules, or something else in your programming language): <br><br><ul><li>  <b>A.</b>  strings.IndexOf (x, y) </li><li>  <b>B.</b>  s.IndexOf (x, y) </li><li>  <b>C.</b>  std.utils.strings.IndexOf (x, y) </li><li>  <b>D.</b>  IndexOf (x, y) </li></ul><br>  Option <b>B is</b> bad, because "s" is too short a name and does not help us understand that "this is probably a string." <br><br>  Option <b>C is</b> bad, because std.utils.strings is too long a name, we already understand that this is a string, you do not need to be reminded every time about where it is located. <br>  Option <b>D is</b> bad, because without namespaces we don‚Äôt understand very well what kind of function we call, where it comes from and what objects it will work on. <br><br>  It is important to note that if we are talking about lines in the code, it would be logical to assume that the IndexOf call for the line does some work on the line.  In this case, even the mention of the namespace "strings" will be redundant, as, for example, the addition operation on integers is more understandable in the form of a + b, and not in the form of int16.Add (a, b). <br><br><h3>  Variable state </h3><br>  Some programming paradigms say that any modification of a variable is a bad thing, because ‚Äúit becomes difficult to understand what changed and when.‚Äù  But let's look at these examples here: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// A. func foo() (int, int) { sum, sumOfSquares := 0, 0 for _, v := range values { sum += v sumOfSquares += v * v } return sum, sumOfSquares }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// B. func GCD(a, b int) int { for b != 0 { a, b = b, a % b } return a }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// C. func GCD(a, b int) int { if b == 0 { return a } return GCD(b, a % b) }</span></span></code> </pre> <br>  Here the first function (foo) is probably the easiest to understand.  Why?  Because the problem is not the modification of variables, but how exactly they are modified.  Example <b>A</b> does not contain any complex calculations, unlike <b>B</b> and <b>C.</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// D. sum = sum + vx sum = sum + vy sum = sum + vz sum = sum + vw</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// E. sum1 = vx sum2 := sum1 + vy sum3 := sum2 + vz sum4 := sum3 + vw</span></span></code> </pre> <br>  Here is another example of code where a version with a modified value of a variable ( <b>D</b> ) is easier to read.  Option <b>E</b> does not modify existing variables, but adds 3 new entities to describe the same idea.  More noise is harder to understand. <br><br><h3>  Idioms </h3><br>  Let's look at a few more cycles: <br><br><ul><li>  <b>A.</b>  for (i = 0; i &lt;N; i ++) </li><li>  <b>B.</b>  for (i = 0; N&gt; i; i ++) </li><li>  <b>D.</b>  for (i = 0; i &lt;= N-1; i + = 1) </li><li>  <b>C.</b>  for (i = 0; N-1&gt; = i; i + = 1) </li></ul><br>  How long did it take you to understand what each of them is doing?  I bet option <b>A</b> you perceived on the fly.  The remaining three options had to be read and understood.  The main reason is experience.  Variant <b>A</b> for many programmers lies in a separate, quickly accessible memory cell.  The remaining three are not.  For them, you need to build new temporary models in your head. <br><br>  But for a beginner, all four options will look the same - their complexity is really about equal and none of them will seem to the person "from the side" better than the other.  An experienced programmer at first glance will say "well, well, this is a passage through the array."  The newcomer will tell you that "here we reset the variable i, then compare it with N, execute the code inside the loop body, increment i and compare again, etc.". <br><br>  Option <b>A</b> is the ‚Äúidiomatic way‚Äù of writing a cycle.  It is not better than others in terms of computational complexity, but significantly better in terms of readability of the code, because it is included in the "basic vocabulary of the profession." <br><br>  Most programming languages ‚Äã‚Äãhave an idiomatic way of writing certain things.  There are classic documents and books, such as <a href="http://www.softwarepreservation.org/projects/apl/Papers/MYFAVORITEIDIOM">APL idioms</a> , <a href="http://www.dre.vanderbilt.edu/~sutambe/documents/More%2520C%2B%2B%2520Idioms.pdf">C ++ idioms,</a> as well as higher level things like the <a href="https://en.wikipedia.org/wiki/Design_Patterns">Gang of Four patterns</a> .  Using idioms from similar classic books, we can build more complex programs, some pieces of which will be understandable to other programmers (after all, they probably read the same books). <br><br>  All this has a negative aspect.  The more idioms we use, the larger vocabulary is required to remember for their understanding.  Dynamic languages ‚Äã‚Äãare subject to this problem more than others - programmers feel the opportunity to invent new flexible idioms for a clever solution to their current problem (and it even works), but each subsequent reader of this code will be forced to slow down, trying to understand the author‚Äôs unexpected approaches. <br><br><h3>  Consistency </h3><br>  A good example of consistency can be the names of entities such as "model" and "controller".  Having once learned what it is and how they are related to each other, you always get a valuable pair of idioms in your head.  Now in any code, when you see a class with the word Model or Controller in the name, you will understand what it was created for and what it is connected with. <br><br>  Such things as frameworks or game engines are always trying to act in a similar way: to give us an understanding of the basic entities, the links between them, and the ways they are manipulated.  Having learned the structure of one project on some framework or engine, a programmer can very quickly grasp the essence of another project on it. <br><br>  An important factor here is the consistency of the code design.  The more consistent the names of variables, classes, methods, code formatting, approaches to solving the same problems in different parts of the code base are in the code - the easier the reader understands the project, the faster he ‚Äútrusts‚Äù him. <br><br><h3>  Uncertainty </h3><br>  Uncertainty can slow both writing and code understanding.  As an example, consider the ambiguity.  For example, the following code: <br><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>].filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> v &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  for all its simplicity, all the same leaves open the question, what will be obtained in the end "2 and 3" or "1"?  So we are ‚Äúfiltering‚Äù or ‚Äúfiltering‚Äù here?  Most likely you will quickly find the answer in the documentation of your platform or library used - but you will have to digress, and then also remember the information found.  True, it would be better if the name and syntax speak for themselves?  Function names like <b>select</b> , <b>discard,</b> or <b>keep</b> would be much better. <br><br>  We can also understand the meaning of an entity in different ways.  For example, the function <b>GetUser (string)</b> may be perceived by some people as a search for a user by name, while others consider it to be a search using a unique user key.  You can easily get out of this situation by creating a special type <b>CustomerID</b> (even if it will be an alias to the same string) and using it in the prototype of the <b>GetUser (CustomerID)</b> function, but you can call the search for a user by name <b>GetUserByName (string)</b> .  There is already no uncertainty. <br><br>  Similarity is another common cause of errors.  If you have variables of the type <b>total1</b> , <b>total2</b> , <b>total3</b> - it is very easy to copy-paste a piece of code and forget to fix the index.  The code will be compiled, and the error will be found (if there will be) much later.  Calling these variables with names like <b>sum</b> , <b>sum_of_squares</b> , <b>total_error</b> is much safer. <br><br>  Another problem is the naming of the same entity by different names in different modules of your code.  This does not seem to be such a big problem: ‚ÄúI called it this way, another programmer put it in the base under that name, and in the UI it was called like this‚Äù.  All is well, all is well.  And then something breaks down and some other programmer, cursing, trying to understand how these things, which are completely different in name, are connected. <br><br>  Problems of ambiguity and similarity are inherent not only in writing source code.  In different contexts, the same words can mean different things.  For example, the word ‚Äúcustomer‚Äù means completely different things in the purchasing and sales departments of the same company.  Thus, you should never be afraid to seem ridiculous or inappropriate, once again asking everyone around you whether you understand the same terms in your subject area. <br><br><h3>  Comments </h3><br>  We all saw examples of stupid novice comments, such as: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     i  0  99 for(var i = 0; i &lt; 100; i++) { //     4 var a = 4;</span></span></code> </pre> <br>  Yes, it looks a little dumb.  But even such comments can make sense.  Think about learning a second (or third) programming language.  You already have knowledge of the syntax of one language, an understanding of all these conditional transitions, cycles, functions - and now you are learning the same thing in another language.  You do not need to re-examine these concepts in the new language, but only to bind in your head this format of a cycle or assignment to the abstract idiom of a ‚Äúcycle‚Äù or ‚Äúassignment‚Äù - this is where similar comments can be useful. <br><br>  As soon as this binding happened, these comments will become unnecessary garbage, since an explanation of what is happening will occur in your head when you look at the code itself.  In the course of how the programmer gains experience, his comments carry less and less information about WHAT the code does and more and more about WHY and IN WHAT CONTEXT it does.  ‚ÄúApproach X was chosen because alternative approaches Y and Z did not work for such and such reasons,‚Äù ‚Äúwhen modifying this code, remember that ...‚Äù. <br><br>  Good comments supplement the mental model of understanding code. <br><br><h3>  Contexts </h3><br>  The limited working memory limit leads us to the necessity of code decomposition.  We break a complex (or long) code into parts that operate with a limited number of objects.  But it is also possible to break and decompose in different ways.  Imagine, for example, a class that lies very deep in the inheritance tree.  And here you write in it some method that calls several other methods - one from the same class, another from the ‚Äúparent‚Äù, the third from the ‚Äúgrandfather‚Äù.  It seems that your class is quite simple - a couple of methods, rows of 5 in each.  But reading its code is difficult, because even reading these 10 lines requires creating an entire inheritance tree in your head (and keeping reading all the time!).  It's difficult.  Each new layer of inheritance is another idiom that occupies and exhausts our working memory limit. <br><br>  Same thing with tracking function calls.  Each step deep into the call stack is a step to the limit of our mental abilities. <br><br>  One of the ways to reduce the depth of our mental context model is to clearly separate them.  One example would be the concept of an ‚Äúearly return‚Äù: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> age)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (age &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  - } else { System.out.println("  "); } } public void SomeFunction(int age) { if (age &lt; 0){ System.out.println("  "); return; } //  - }</span></span></code> </pre> <br>  In the first version, when reading the code, we get to the ‚Äúdo something‚Äù part and we also remember that this part is performed only under the condition specified above.  However, when we reach the part of the ‚Äúelse‚Äù we have already far enough mentally departed from the original condition and to understand something this ‚Äúelse‚Äù refers, we need, first, to remove the read-only part from the head ‚Äúto do something ", Secondly, go back to the condition and realize it and, thirdly, go back to the" else "block already being in the context of the conditions under which we will get into it.  Enough long way. <br><br>  The second version of the code applies the concept of early return and is therefore the best alternative.  We first check the boundary conditions and react adequately to them.  Then we go to the main code block and execute it.  No mental jumps back and forth, no unnecessary change of contexts. <br><br><h3>  Rules of thumb </h3><br>  One of the fundamental rules of programming is ‚ÄúAvoid using global variables.‚Äù  But how about the case when the value of such a variable is assigned only once during initialization and never changes in the future - is this also a problem?  Yes, it's a problem.  The point here is not even ‚Äúvariability‚Äù or ‚Äúglobality‚Äù.  We introduce an entity that is accessible from everywhere, which means that it will explicitly or implicitly be present in any mental code model that you will build in your head.  Even if it is a constant, even if it is not used in this function ‚Äî knowledge of what is something, which of its own will (and not the will of this function) is visible and accessible ‚Äî already gives it the right to claim a place in the head reader of this code.  Of course, we do not write ‚Äúprograms in a vacuum‚Äù, they all work in some kind of environment, and even some ‚Äúpermissible‚Äù idioms like Singleton have the same properties.  So why are they considered a better option than global variables? <br><br>  It's all about the principle of sole responsibility.  Its purpose is to ensure that each entity in your code serves one purpose.  Not zero, not two - exactly one.  This restriction often leads to splitting into smaller parts.  This is not always good - with such a crushing one can reach so small parts that to collect something really useful from them will require serious efforts.  In addition, these small parts can be so tied to each other that this will lose the whole meaning of the principle of sole responsibility. <br><br>  A good example of this could be Carmack‚Äôs comment.  He showed these three pieces of code: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// A void MinorFunction1( void ) { } void MinorFunction2( void ) { } void MinorFunction3( void ) { } void MajorFunction( void ) { MinorFunction1(); MinorFunction2(); MinorFunction3(); } // B void MajorFunction( void ) { MinorFunction1(); MinorFunction2(); MinorFunction3(); } void MinorFunction1( void ) { } void MinorFunction2( void ) { } void MinorFunction3( void ) { } // C. void MajorFunction( void ) { { // MinorFunction1 } { // MinorFunction2 } { // MinorFunction3 } }</span></span></code> </pre><br>  By making smaller pieces of code, we can better ensure that their contents match their idea and name.  However, understanding the code does not make it any better.  We cannot read the code in a linear manner (top to bottom) and understand it - instead, we have to jump to the code of the called functions and back.  Veriant <b>C</b> proposes a solution to this problem - separating parts of the code into logical scopes, which, on the one hand, preserves their integrity and separation, and on the other, allows you to read the code sequentially and not lose the context for its execution. <br><br>  In practice, there is no ideal way to organize the code, because besides readability, which we talked about above, there are equally important things, such as reliability, maintainability, performance, speed of creating a minimally working prototype, etc.  Some of these values ‚Äã‚Äãcomplement each other, but some directly contradict each other.  In each case, it is important to understand what is the value of this particular project and what it is worth to focus efforts here and now. </div><p>Source: <a href="https://habr.com/ru/post/399293/">https://habr.com/ru/post/399293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../399279/index.html">Great chain of confidence: how blockchain and trust change the world</a></li>
<li><a href="../399281/index.html">What are the Japanese made of</a></li>
<li><a href="../399285/index.html">Post-horror: how technology tickles nerves</a></li>
<li><a href="../399287/index.html">Polar M600 - an overview of the capabilities of sports watches on Android Wear</a></li>
<li><a href="../399291/index.html">Apple recognized problems with the battery of some iPhone 6S</a></li>
<li><a href="../399297/index.html">Sound barcode is an alternative to NFC that does not require special hardware</a></li>
<li><a href="../399299/index.html">Near the Milky Way, a very dark satellite galaxy is seen.</a></li>
<li><a href="../399301/index.html">As augmented reality attracts and sells</a></li>
<li><a href="../399303/index.html">Global map: how different countries of the world approach the development of fintech</a></li>
<li><a href="../399305/index.html">Free internet on travel with ComfortWay</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>