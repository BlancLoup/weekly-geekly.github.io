<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Add system call. Part 4 and last</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Something bothers me Honduras ... - bothering? And you do not scratch him. 

 In the previous parts of the discussion ( 1st , 2nd and 3rd ), we cons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Add system call. Part 4 and last</h1><div class="post__text post__text-html js-mediator-article"><pre>                                                                                     - Something bothers me Honduras ...
                                                                                     - bothering?  And you do not scratch him.
</pre><br><br>  In the previous parts of the discussion ( <a href="http://habrahabr.ru/post/267535/">1st</a> , <a href="http://habrahabr.ru/post/267773/">2nd</a> and <a href="http://habrahabr.ru/post/268145/">3rd</a> ), we considered how, using the ability to change the contents of the sys_call_table, <b>change the</b> behavior of a particular Linux system call.  Now we will continue to experiment in the direction of whether (and how) we can dynamically <b>add a</b> new system call to your software project. <br><a name="habracut"></a><br>  We will not focus on the question ‚Äúwhy?‚Äù - in programming, the last thing to ask is ‚Äúwhy?‚Äù, You need to ask ‚Äúhow?‚Äù: If any technique is not close to you, you simply do not use it (see the epigraph).  But nevertheless, we will return shortly to this end, in the discussion. <br><br><h1>  What does this look like? </h1><br>  With a general similarity to the previously discussed examples of replacing a system call, this task, for all its similarity, has some aggravating features: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  The size of the original sys_call_table system call table slowly but monotonously increases from version to kernel version and significantly depends on the specific processor platform. </li><li>  The constant specifying the dimension of this table (known in the kernel as __NR_syscall_max, or in some new versions as __NR_syscalls) is declared a <b>preprocessing</b> constant (macro) of the compilation period, and is unknown at run time (at least, I do not know). </li><li>  Trying to add our own entry point <b>to the end of the</b> table, we have a significant risk to go beyond the area allocated to the table - this can not be done! </li></ul><br>  The size of the sys_call_table table is quite large, and it changes from version to kernel version (version 3.13), here‚Äôs a very <b>rough</b> estimate: <br><br><pre><code class="dos hljs">$ cat /proc/kallsyms | grep ' sys_' | grep T | wc -l <span class="hljs-number"><span class="hljs-number">357</span></span></code> </pre> <br>  The kernel versions in this part of the discussion will have to be mentioned all the time: what was defined in the header file of the previous version may be determined differently and in a completely different place (file) for the next version, if not explicitly defined at all.  This is a common practice in kernel codes.  But with all that, all the basic principles and dependencies remain unchanged from version to version. <br><br>  The above limiting circumstances are mitigated by the fact that the table of system calls is <b>not dense</b> , rather <b>sparse</b> , it has unused positions ( <b>left over</b> from outdated system calls and not currently supported).  <b>All</b> such positions are filled with the same address - a pointer to the function of the unrealized sys_ni_syscall () call handler: <br><pre> <code class="bash hljs">$ cat /proc/kallsyms | grep sys_ni_syscall c045b9a8 T sys_ni_syscall</code> </pre><br>  And the sys_ni_syscall () system call itself is defined like this: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">asmlinkage </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sys_ni_syscall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOSYS; }</code> </pre><br>  Therefore, we can add our new system call handler to <b>any</b> unused position in the sys_call_table table.  Let's pay attention to the fact that in these positions there are not obsolete, unused calls, but exactly a challenge, the only action of which is to return an error code.  Moreover, kernel developers do not have the right to reuse these positions, otherwise a completely outdated application could cause, without suspecting, a new replacement call. <br><br>  Statically, textually in the source code, it is possible to examine in detail the structure of the sys_call_table table (for the chosen platform and version).  For such studies, the source code itself is not very suitable as it is presented by developers, but fortunately for our purposes, today there are quite a lot of resources that visualize the kernel code using the LXR project (Linux Kernel Cross Reference), for example, here or here (this allows you to compare versions and easily find the necessary identifiers).  For example, I will show only those positions of the sys_call_table kernel 3.0.26 of the x86 architecture that contain (file &lt;arch / x86 / kernel / syscall_table_32.S&gt;) a link to sys_ni_syscall (but to the 3.2 kernel and further this file will disappear even from the code tree ... but the principles Formations of the table will remain the same and its view will not change): <br><br><pre> <code class="hljs ruby">ENTRY(sys_call_table) .long sys_restart_syscall /* <span class="hljs-number"><span class="hljs-number">0</span></span> - old <span class="hljs-string"><span class="hljs-string">"setup()"</span></span> system call, used <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> restarting *<span class="hljs-regexp"><span class="hljs-regexp">/ .long sys_exit ... .long sys_ni_syscall /</span></span>* old <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> syscall holder *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/17 .long sys_ni_syscall /</span></span>* old stty syscall holder *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/31 .long sys_ni_syscall /</span></span>* old gtty syscall holder *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/32 .long sys_ni_syscall /</span></span>* <span class="hljs-number"><span class="hljs-number">35</span></span> - old ftime syscall holder *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/35 .long sys_ni_syscall /</span></span>* old prof syscall holder *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/44 .long sys_ni_syscall /</span></span>* old lock syscall holder *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/53 .long sys_ni_syscall /</span></span>* old mpx syscall holder *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/56 .long sys_ni_syscall /</span></span>* old ulimit syscall holder *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/58 .long sys_ni_syscall /</span></span>* old profil syscall holder *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/98 .long sys_ni_syscall /</span></span>* old <span class="hljs-string"><span class="hljs-string">"idle"</span></span> system call *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/112 .long sys_ni_syscall /</span></span>* old <span class="hljs-string"><span class="hljs-string">"create_module"</span></span> *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/127 .long sys_ni_syscall /</span></span>* <span class="hljs-number"><span class="hljs-number">130</span></span>: old <span class="hljs-string"><span class="hljs-string">"get_kernel_syms"</span></span> *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/130 .long sys_ni_syscall /</span></span>* reserved <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> afs_syscall *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/137 .long sys_ni_syscall /</span></span>* Old sys_query_module *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/167 .long sys_ni_syscall /</span></span>* reserved <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> streams1 *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/188 .long sys_ni_syscall /</span></span>* reserved <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> streams2 *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/189 .long sys_ni_syscall /</span></span>* reserved <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> TUX *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/222 .long sys_ni_syscall /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/223 .long sys_ni_syscall /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/251 .long sys_ni_syscall /</span></span>* sys_vserver *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/273 .long sys_ni_syscall /</span></span>* <span class="hljs-number"><span class="hljs-number">285</span></span> *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span>* available *<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/285 ... .long sys_setns /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 346</span></span></code> </pre><br>  Listing shows only unused positions (except for the beginning and end of the table), comments are left from the source code, and the last comment, with the position number of the system call, is added by me. <br><br>  We see that for this version of the kernel, the table has 347 positions of system calls, of which 21 are not involved.  The analysis of unused positions <b>in dynamics</b> , without relying on variable kernel codes, will be the subject of the first kernel module in question: <br><br><pre> <code class="hljs pgsql">static <span class="hljs-type"><span class="hljs-type">void</span></span> **taddr, //  sys_call_table *niaddr; //  sys_ni_syscall() static <span class="hljs-type"><span class="hljs-type">int</span></span> nsys = <span class="hljs-number"><span class="hljs-number">0</span></span>; //      #define SYS_NR_MAX <span class="hljs-number"><span class="hljs-number">450</span></span> // SYS_NR_MAX -  ,   sys_call_table static <span class="hljs-type"><span class="hljs-type">int</span></span> sys_length( <span class="hljs-type"><span class="hljs-type">void</span></span>* data, const <span class="hljs-type"><span class="hljs-type">char</span></span>* sym, struct module* mod, unsigned long addr ) { <span class="hljs-type"><span class="hljs-type">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( strstr( sym, "sys_" ) != sym ) || ( <span class="hljs-number"><span class="hljs-number">0</span></span> == strcmp( "sys_call_table", sym ) ) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SYS_NR_MAX; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( taddr[ i ] == (<span class="hljs-type"><span class="hljs-type">void</span></span>*)addr ) { //  sys_*  sys_call_table <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( i &gt; nsys ) nsys = i; break; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } static <span class="hljs-type"><span class="hljs-type">void</span></span> put_entries( <span class="hljs-type"><span class="hljs-type">void</span></span> ) { <span class="hljs-type"><span class="hljs-type">int</span></span> i, ni = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">char</span></span> buf[ <span class="hljs-number"><span class="hljs-number">200</span></span> ] = ""; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= nsys; i++ ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( taddr[ i ] == niaddr ) { ni++; sprintf( buf + strlen( buf ), "%03d, ", i ); } LOG( "found %d unused entries: %s\n", ni, buf ); } static <span class="hljs-type"><span class="hljs-type">int</span></span> __init init_driver( <span class="hljs-type"><span class="hljs-type">void</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> == ( taddr = (<span class="hljs-type"><span class="hljs-type">void</span></span>**)kallsyms_lookup_name( "sys_call_table" ) ) ) { ERR( "sys_call_table not found!\n" ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EFAULT; } LOG( "sys_call_table address = %p\n", taddr ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> == ( niaddr = (<span class="hljs-type"><span class="hljs-type">void</span></span>*)kallsyms_lookup_name( "sys_ni_syscall" ) ) ) { ERR( "sys_ni_syscall found!\n" ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EFAULT; } LOG( "sys_ni_syscall address = %p\n", niaddr ); kallsyms_on_each_symbol( sys_length, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ); LOG( "sys_call_table length = %d\n", nsys + <span class="hljs-number"><span class="hljs-number">1</span></span> ); put_entries(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EPERM; } module_init( init_driver );</code> </pre><br>  As before, the optional details (such as the macro macro LOG (), etc.) are not shown, they are all in the complete attached files. <br>  It could have been easier (which is also correct) - to find out the length of sys_call_table, simply recalculate the number of kernel symbols using the sys_ * mask and subtract 1 (the sys_call_table symbol itself).  But we go the redundant way: <br><ul><li>  the loop contains the next character in the sys_ * mask; </li><li>  its <b>position is</b> searched in sys_call_table (this is an additional reassurance that this is a <b>system</b> call); </li><li>  if this position is greater than the previously found ones for the previous characters, then it is not considered the current number of the <b>last</b> call (the current size is sys_call_table); </li></ul><br>  This redundant (but not at all necessary) scheme allows you to simultaneously specify the <b>exact size of</b> the system call table for your architecture and Linux kernel version: <br><br><pre> <code class="bash hljs">$ uname -p i686 $ uname -r 3.13.0-37-generic $ sudo insmod nsys.ko insmod: ERROR: could not insert module nsys.ko: Operation not permitted $ dmesg | tail -n 4 [10751.601851] ! sys_call_table address = c1666140 [10751.602194] ! sys_ni_syscall address = c1075930 [10751.659769] ! sys_call_table length = 351 [10751.659779] ! found 27 unused entries: 017, 031, 032, 035, 044, 053, 056, 058, 098, 112, 127, 130, 137, 167, 169, 188, 189, 222, 223, 251, 273, 274, 275, 276, 285, 294, 317,</code> </pre><br>  In total, this version has 351 system calls, of which 27 are not used (almost 10% of the table size).  The stability of this list is very high (consciously for the analysis of the code version 3.0.26 was chosen, and for execution in the dynamics version 2.6.32 and 3.13, separated from each other by more than 4 years of release). <br><br>  <b>Note:</b> Without being distracted aside, we note nonetheless casually that the writing of a module is in a similar manner, which is a).  not intended for download at all, b).  and in connection with this consciously returns a non-zero completion code, c).  therefore, it has no unloading function at all (__exit) - it is the direct equivalent of a user application (starting from the main () point), but only running in supervisor mode, with maximum privileges.  But this is a subject for another discussion ... <br><br><h1>  Implementing a new system call </h1><br>  Now we are ready to return to the implementation of the stated task: add a new system call.  Naturally, we will also need a user-space test application using this call.  The number of the new call is defined in the general header file (syscall.h), for consistency in the use of the module and the program (ibid also mentioned LOG (), ERR () and other small things): <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/      #define __NR_own 223 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,     nsys.ko /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   3.31     27 : /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 017, 031, 032, 035, 044, 053, 056, 058, 098, 112, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 127, 130, 137, 167, 169, 188, 189, 222, 223, 251, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 273, 274, 275, 276, 285, 294, 317,</span></span></code> </pre><br>  It is easier and clearer to start with a user application that will perform a new system call.  Everything is simple here - it doesn't get easier: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_own_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = syscall( __NR_own, str, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( str ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( n == <span class="hljs-number"><span class="hljs-number">0</span></span> ) LOG( <span class="hljs-string"><span class="hljs-string">"syscall return %d\n"</span></span>, n ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ERR( <span class="hljs-string"><span class="hljs-string">"syscall error %d : %s\n"</span></span>, n, strerror( -n ) ); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>( n ); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">1</span></span> == argc ) do_own_call( <span class="hljs-string"><span class="hljs-string">"DEFAULT STRING"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( --argc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) do_own_call( argv[ argc ] ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_SUCCESS; };</code> </pre><br>  The program can do one or a series (if you specify several parameters on the command line) system calls and passes the character parameter to the call (just as it does, for example, sys_write).  And already in the module code, we will be able to see how this line is copied into the kernel space.  But the main interest here is the return code: the success or failure of the system call. <br><br>  And here is the module that ‚Äúpicks up‚Äù such a call from the core: <br><br><pre> <code class="hljs perl">asmlinkage long (*old_sys_addr) ( void ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     : asmlinkage long new_sys_call ( const char __user *buf, size_t count ) { static char buf_msg[ <span class="hljs-number"><span class="hljs-number">80</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = copy_from_user( buf_msg, (void*)buf, count ); buf_msg[ count ] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; LOG( <span class="hljs-string"><span class="hljs-string">"accepted %d bytes: %s\n"</span></span>, count, buf_msg ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }; static void **taddr; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   sys_call_table static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __init new_sys_init( void ) { void *waddr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( NULL == ( taddr = (void**)kallsyms_lookup_name( <span class="hljs-string"><span class="hljs-string">"sys_call_table"</span></span> ) ) ) { ERR( <span class="hljs-string"><span class="hljs-string">"sys_call_table not found!\n"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EFAULT; } old_sys_addr = (void*)taddr[ __NR_own ]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( waddr = (void*)kallsyms_lookup_name( <span class="hljs-string"><span class="hljs-string">"sys_ni_syscall"</span></span> ) ) != NULL ) LOG( <span class="hljs-string"><span class="hljs-string">"sys_ni_syscall address = %p\n"</span></span>, waddr ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ERR( <span class="hljs-string"><span class="hljs-string">"sys_ni_syscall not found!\n"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EFAULT; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( old_sys_addr != waddr ) { ERR( <span class="hljs-string"><span class="hljs-string">"not free slot!\n"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EINVAL; } LOG( <span class="hljs-string"><span class="hljs-string">"old sys_call_table[%d] = %p\n"</span></span>, __NR_own, taddr[ __NR_own ] ); rw_enable(); taddr[ __NR_own ] = new_sys_call; rw_disable(); LOG( <span class="hljs-string"><span class="hljs-string">"new sys_call_table[%d] = %p\n"</span></span>, __NR_own, taddr[ __NR_own ] ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } static void __exit new_sys_exit( void ) { rw_enable(); taddr[ __NR_own ] = old_sys_addr; rw_disable(); LOG( <span class="hljs-string"><span class="hljs-string">"restore sys_call_table[%d] = %p\n"</span></span>, __NR_own, taddr[ __NR_own ] ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } module_init( new_sys_init ); module_exit( new_sys_exit );</code> </pre><br>  A double reinsurance is also done here - checking whether the address in the specified (__NR_own) position of the sys_call_table table is the address of the unused sys_ni_syscall system calls. <br><br>  And now we evaluate what we did: <br><br><pre> <code class="dos hljs">$ ./syscall syscall error -<span class="hljs-number"><span class="hljs-number">1</span></span> : Operation <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> permitted $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? <span class="hljs-number"><span class="hljs-number">255</span></span> $ sudo insmod adds.ko $ lsmod | head -n3 Module Size Used by adds <span class="hljs-number"><span class="hljs-number">12622</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> pci_stub <span class="hljs-number"><span class="hljs-number">12550</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> $ dmesg | tail -n3 [<span class="hljs-number"><span class="hljs-number">15000</span></span>.<span class="hljs-number"><span class="hljs-number">600618</span></span>] ! sys_ni_syscall address = c1075930 [<span class="hljs-number"><span class="hljs-number">15000</span></span>.<span class="hljs-number"><span class="hljs-number">600622</span></span>] ! old sys_call_table[<span class="hljs-number"><span class="hljs-number">223</span></span>] = c1075930 [<span class="hljs-number"><span class="hljs-number">15000</span></span>.<span class="hljs-number"><span class="hljs-number">600623</span></span>] ! new sys_call_table[<span class="hljs-number"><span class="hljs-number">223</span></span>] = f87d9000 $ ./syscall new string <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> syscall return <span class="hljs-number"><span class="hljs-number">0</span></span> syscall return <span class="hljs-number"><span class="hljs-number">0</span></span> syscall return <span class="hljs-number"><span class="hljs-number">0</span></span> syscall return <span class="hljs-number"><span class="hljs-number">0</span></span> $ dmesg | tail -n4 [<span class="hljs-number"><span class="hljs-number">15070</span></span>.<span class="hljs-number"><span class="hljs-number">680753</span></span>] ! accepted <span class="hljs-number"><span class="hljs-number">4</span></span> bytes: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> [<span class="hljs-number"><span class="hljs-number">15070</span></span>.<span class="hljs-number"><span class="hljs-number">680799</span></span>] ! accepted <span class="hljs-number"><span class="hljs-number">3</span></span> bytes: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> [<span class="hljs-number"><span class="hljs-number">15070</span></span>.<span class="hljs-number"><span class="hljs-number">680804</span></span>] ! accepted <span class="hljs-number"><span class="hljs-number">6</span></span> bytes: string [<span class="hljs-number"><span class="hljs-number">15070</span></span>.<span class="hljs-number"><span class="hljs-number">680807</span></span>] ! accepted <span class="hljs-number"><span class="hljs-number">3</span></span> bytes: new $ ./syscall 'new string <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>' syscall return <span class="hljs-number"><span class="hljs-number">0</span></span> $ dmesg | tail -n1 [<span class="hljs-number"><span class="hljs-number">15167</span></span>.<span class="hljs-number"><span class="hljs-number">526452</span></span>] ! accepted <span class="hljs-number"><span class="hljs-number">19</span></span> bytes: new string <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> $ sudo rmmod adds $ dmesg | tail -n1 [<span class="hljs-number"><span class="hljs-number">15199</span></span>.<span class="hljs-number"><span class="hljs-number">917817</span></span>] ! <span class="hljs-built_in"><span class="hljs-built_in">restore</span></span> sys_call_table[<span class="hljs-number"><span class="hljs-number">223</span></span>] = c1075930 $ ./syscall syscall error -<span class="hljs-number"><span class="hljs-number">1</span></span> : Operation <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> permitted</code> </pre><br>  After the module is unloaded, the kernel is no longer able to support the execution of the required system call program! <br><br><h1>  Discussion </h1><br>  Actually, there is nothing to discuss here - everything is transparently shown by example.  But I initially promised to express my thoughts on why such a thing can be applied at all (but I repeat once again my firm conviction that the question ‚Äúwhy?‚Äù In programming is generally meaningless).  The trick shown provides another way for (two-way) applications to interact with the kernel.  Yes, of course there is an opportunity to do the same through / dev, / proc, or / sys ... but each of these methods is more ponderous than a system call, it involves a larger number of intermediate kernel mechanisms. <br><br>  When is it possible to use such a mechanism?  For example, for asynchronous application notifications about certain events in the kernel, when a separate application thread is blocked on a system call until the expected event occurs.  Such an event may be, for example, a hardware interrupt (IRQ) from the debugged new device (moderately not fast).  With this approach, any input-output operations with the device can be implemented from user space using the operations of the inb (), outb () ..., or ioperm () and iopl () operations.  All this together makes it possible to study the work and write out the exchange code with the device in the finest details without going beyond the user space, without the risks and difficulties associated with the privileged kernel mode.  And then, according to circumstances and at will: you can mechanically rewrite the code of this tested driver in the form of a module, or leave it as it is in user space. <br><br>  <b>Note: The</b> note above about low speed devices, which can only be worked out in this way, should not be taken too close to the heart either.  Truly high-speed devices and inside the Linux kernel do not work on interrupts, but use cyclic program polling.  Like, for example, all network interfaces of a network stack at the hardware level ... who knows the Linux network subsystem will understand what I mean. <br><br>  I'm not talking about the developers of proprietary hardware and projects that have the same rights to exist in nature, like others.  In their works, such a technique can find the ground for use. <br><br>  And again, as before, the archive of the code can be taken <a href="https://yadi.sk/d/JrOw3qsgjaf43">here</a> or <a href="https://drive.google.com/file/d/0B__cqmYoRw_6U0xCeHctRnZFeDQ/view%3Fusp%3Dsharing">here</a> ... <br><br><h1>  Epilogue </h1><br>  Since this is the final part of a small cycle about such an unusual (indecent?) Handling of Linux system calls, I would like to make a couple of words in the order of the total. <br><br>  When you start writing kernel modules or kernel patches, you initially feel a sense of constraint, limited only by the capabilities provided by the poorly documented API of the kernel, or are described in the few and outdated books of the type ‚Äúwriting Linux drivers‚Äù.  But experiments similar to those described in this cycle, and many other similar ones, suggest that in the kernel module you have access to <b>all</b> (without exception!) Possibilities of user space (launching new processes and threads, sending UNIX signals, etc.).  And plus to this, unattainable in user space capabilities associated with privileged (supervisor, ring 0) processor protection mode (privileged instructions, internal registers of the processor, response to interrupts). <br><br>  To show this is the main goal of this series of articles, and not at all just private tasks of replacing or adding system calls.  Kernel-mode programming should create a feeling of freedom that you are like gods here and can do everything here.  But this also requires an adequate degree of responsibility ... </div><p>Source: <a href="https://habr.com/ru/post/268409/">https://habr.com/ru/post/268409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268397/index.html">How VMware DRS works</a></li>
<li><a href="../268399/index.html">4 reasons to risk moving to software-defined data center ‚Äì y</a></li>
<li><a href="../268401/index.html">Natural Language Programming Instructions or Intentional Programming</a></li>
<li><a href="../268403/index.html">HackerSIM: small explanation (comment)</a></li>
<li><a href="../268405/index.html">Fractal bush from beginner for beginners</a></li>
<li><a href="../268411/index.html">Translation: One year with Go</a></li>
<li><a href="../268413/index.html">Three days that shook us in 2013</a></li>
<li><a href="../268417/index.html">ANVE.ru - best friend of suppliers and dealers</a></li>
<li><a href="../268419/index.html">We received GOLD for the operation of the data center TIER III - the final progress after T-III for the project and T-III for the finished object</a></li>
<li><a href="../268421/index.html">USB killer v2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>