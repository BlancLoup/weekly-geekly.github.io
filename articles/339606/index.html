<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Railway-oriented programming. Functional style error handling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As a user, I want to change the name and email in the system. 
 To implement this simple user history, we must receive a request, validate, update an ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Railway-oriented programming. Functional style error handling</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/da/2b/59da2b7193313753752158.gif"></div><br><blockquote>  As a user, I want to change the name and email in the system. </blockquote><br>  To implement this simple user history, we must receive a request, validate, update an existing record in the database, send a confirmation email to the user and return the answer to the browser.  The code will look about the same in C #: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteUseCase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = receiveRequest(); validateRequest(request); canonicalizeEmail(request); db.updateDbFromRequest(request); smtpServer.sendEmail(request.Email); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Success"</span></span>; }</code> </pre> <br>  and F #: <br><br><pre> <code class="hljs ruby">let executeUseCase = receiveRequest <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>validateRequest &gt;&gt; canonicalizeEmail &gt;&gt; updateDbFromRequest &gt;&gt; sendEmail &gt;&gt; returnMessage</code> </pre><a name="habracut"></a><br><h2>  Deviating from a happy journey </h2><br><img src="https://habrastorage.org/webt/59/da/2d/59da2d8f005bf618301003.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Complete the story: <br><blockquote>  As a user, I want to change the name and email in the system <br>  And see the error message if something goes wrong. </blockquote><br><h2>  What can go wrong? </h2><br><img src="https://habrastorage.org/webt/59/da/2f/59da2f754e3bf250799737.png"><br><br><ol><li>  Name may be empty, and email - not correct </li><li>  user with such id may not be found in the database </li><li>  SMTP server may not respond when sending a confirmation email </li><li>  ... </li></ol><br><h3>  Add error handling code </h3><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteUseCase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = receiveRequest(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isValidated = validateRequest(request); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isValidated) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Request is not valid"</span></span> } canonicalizeEmail(request); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = db.updateDbFromRequest(request); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Customer record not found"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DB error: Customer record not updated"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!smtpServer.sendEmail(request.Email)) { log.Error <span class="hljs-string"><span class="hljs-string">"Customer email not sent"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; }</code> </pre> <br>  Suddenly, instead of 6, we got 18 lines of code with branches and more nesting, which greatly worsened readability.  What will be the functional equivalent of this code?  It looks exactly the same, but now it has error handling.  You may not believe me, but when we get to the end, you will see that this is true. <br><br><h3>  Request-response architecture in imperative style </h3><br><img src="https://habrastorage.org/webt/59/da/2f/59da2fc5ea5c4731445734.gif"><br><br>  We have a request, an answer.  Data is passed along the chain from one method to another.  If an error occurs we simply use the early return. <br><br><h2>  Functional-style request-response architecture </h2><br><img src="https://habrastorage.org/webt/59/da/2f/59da2ffbdcaa8554842611.gif"><br><br>  On the "happy path" everything is absolutely the same.  We use composition of functions to transfer and process the message in a chain.  But if something goes wrong, we must pass an error message as the return value from the function.  So, we have two problems: <br><br><ol><li>  How to ignore the remaining functions in case of an error? </li><li>  How to return four values ‚Äã‚Äãinstead of one (one return value for each type of error)? </li></ol><br><h2>  How can a function return more than one value? </h2><br>  In functional PL <a href="https://fsharpforfunandprofit.com/posts/discriminated-unions/">types, union types</a> are widespread.  With their help, you can simulate several possible states within the same type.  The function has one return value, but now it takes one of four possible values: success or type of error.  It remains only to summarize the data approach.  We declare the <a href="https://habrahabr.ru/post/267231/">Result</a> type consisting of two possible values ‚Äã‚Äãof <code>Success</code> and <code>Failure</code> and add a generic argument with the data. <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Result&lt;<span class="hljs-symbol"><span class="hljs-symbol">'TEntity</span></span>&gt; = | Success <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'TEntity</span></span> | <span class="hljs-literal"><span class="hljs-literal">Failure</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code> </pre><br><h2>  Functional design </h2><br><img src="https://habrastorage.org/webt/59/da/31/59da316b94885094592883.gif"><br><br><ol><li>  Each use case is implemented using one function. </li><li>  Functions return a join from <code>Success</code> and <code>Failure</code> </li><li>  The function for processing a use case is created using a composition of smaller functions, each of which corresponds to one data conversion step. </li><li>  Errors at each step will be combined to return a single value. </li></ol><br><h2>  How to handle errors in a functional style? </h2><br><img src="https://habrastorage.org/webt/59/da/31/59da31a49b81e635380137.jpeg"><br><br>  If you have a very smart friend, well versed in FP, you may have a dialogue like this: <br><br><ul><li>  I would like to use composition of functions, but I lack a convenient way to handle errors. </li><li>  Oh, it's simple.  You need a monad </li><li>  It sounds hard.  What is a monad? </li><li>  A monad is just a monoid in the category of endofunctors. </li><li>  ??? </li><li>  What is the problem? </li><li>  I don't know what an endofunctor is. </li><li>  It's simple.  A functor is a homomorphism between categories.  And an endofunctor is just a functor that maps a category onto itself. </li><li>  Well, of course!  Now everything became clear ... </li></ul><br><blockquote>  Next comes the original untranslatable wordplay, based on <code>Maybe</code> (maybe) and <code>Either</code> (or one or the other).  <code>Maybe</code> and <code>Either</code> are also monad names.  If you like English humor and you also consider the terminology of OP too ‚Äúacademic‚Äù, be sure to check out the <a href="http://fsharpforfunandprofit.com/rop/">original report</a> . </blockquote><br><h2>  Connection with the Either monad and the composition Kleisli </h2><br><img src="https://habrastorage.org/webt/59/da/54/59da5400b133e934020568.gif"><br>  Any Haskell fan will notice that the approach I described is the <code>Either</code> monad, a specialized type of error list for the ‚ÄúLeft‚Äù ( <code>Left</code> ) case.  In Haskell, we could write this: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Result</span></span></span><span class="hljs-class"> ab = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> [a] (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">,[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">])</span></span></code> </pre> <br>  Of course, I'm not trying to impersonate the inventor of this approach, although I claim to be a stupid analogy with the railroad.  So why didn‚Äôt I use standard Haskell terminology?  First, this is not another monad guide.  Instead, the main focus is shifted to solving a specific error handling problem.  Most people who start learning F # are not familiar with monads, so I prefer the less frightening, more visual and intuitive approach for many. <br><br>  Secondly, I am convinced that the approach from the particular to the general is more effective: it is much easier to climb to the next level of abstraction, when you understand the current one well.  I would be wrong if I called my ‚Äúdouble-track‚Äù approach a monad.  Monads are more complicated and I don‚Äôt want to go into the <a href="https://wiki.haskell.org/Monad_laws">monadic laws</a> in this material. <br><br>  Thirdly, <code>Either</code> is too general a concept.  I would like to submit a recipe, not a tool.  The recipe for making bread, which says "just use flour and oven" is not very useful.  It‚Äôs also absolutely useless to have a ‚Äújust use <code>bind</code> and <code>Either</code> ‚Äù error handling guide.  Therefore, I propose an integrated approach that includes a whole set of techniques: <br><br><ol><li>  List of specialized error types, instead of just <code>Either String a</code> </li><li>  <code>bind (&gt;&gt;=)</code> for the composition of monadic functions in the pipeline </li><li>  Cleisley composition ( <code>&gt;=&gt;</code> ) for composition of monadic functions </li><li>  <code>map</code> and <code>fmap</code> for integrating non-monadic functions into the pipeline </li><li>  <code>tee</code> function to integrate functions returning a <code>unit</code> (analog <code>void</code> in F #) </li><li>  error code mapping </li><li>  <code>&amp;&amp;&amp;</code> for combining monadic functions in parallel processing (for example, for validation) </li><li>  Benefits of Using Error Codes in Domain Driven Design (DDD) </li><li>  obvious extensions for logging, domain events, compensatory transactions, and more </li></ol><br>  I hope you enjoy it more than just ‚Äúuse the Either monad.‚Äù <br><br><h2>  Railroad analogy </h2><br><img src="https://habrastorage.org/web/d40/dbd/c14/d40dbdc1477d4a0794d5ce043911ae9b.gif"><br>  I like to present the function as a train track and a transformation tunnel.  If we have two functions, one converting apples into bananas ( <code>apple ‚Üí banana</code> ) and the other bananas into cherries ( <code>banana ‚Üí cherry</code> ), combining them we get the functions of converting apples to cherries ( <code>apple ‚Üí cherry</code> ).  From the point of view of the programmer, there is no difference. This function is obtained using composition or written by hand, the main thing is its signature. <br><br><h2>  Fork </h2><br>  But we have a slightly different case: one value at the input and two possible ones at the output: one branch for successful completion and one for error.  In the "railway" terminology, we need a fork.  <code>Validate</code> and <code>UpdateDb</code> are such fork functions.  We can combine them with each other.  Add the <code>UpdateDb</code> function to <code>Validate</code> and <code>SendEmail</code> .  I call it the ‚Äúdouble track model.‚Äù  Some people prefer to call this approach to error handling "monad Either", but I like my name more (if only because it does not have the word "monad"). <br><img src="https://habrastorage.org/webt/59/da/38/59da38c58faff751185135.gif"><br><br>  Now there are ‚Äúsingle track‚Äù and ‚Äúdouble track‚Äù functions.  Separately, both those and others are assembled, but they are not linked with each other.  For this we need a small "adapter".  In case of success, we call the function and pass the value to it, and in case of an error, we simply pass the error value further without changes.  In the FP, this function is called <code>bind</code> . <br><br><img src="https://habrastorage.org/webt/59/da/86/59da864abfc7b838499256.jpeg"><br><br><h2>  bind </h2><br><img src="https://habrastorage.org/webt/59/da/39/59da3951e01c6625109578.jpeg"><br><pre> <code class="hljs kotlin">let bind switchFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> twoTrackInput -&gt; match twoTrackInput with | Success s -&gt; switchFunction s | Failure f -&gt; Failure f // </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a -&gt; Result&lt;'</span></span></span></span><span class="hljs-function"><span class="hljs-params">b&gt;)</span></span></span></span> -&gt; Result&lt;<span class="hljs-string"><span class="hljs-string">'a&gt; -&gt; Result&lt;'</span></span>b&gt;</code> </pre> <br>  As you can see, this function is very simple: just a few lines of code.  Pay attention to the function signature.  Signatures are very important in OP.  The first argument is the ‚Äúadapter‚Äù, the second argument is the input value in the two-track model, and the output is also the value in the two-track model.  If you see this signature with any other types: with a <code>list</code> , <code>asyn</code> , <code>feature</code> or <code>promise</code> , you‚Äôll have the same <code>bind</code> .  The function may be called differently, for example, <code><a href="https://ericlippert.com/2013/03/25/monads-part-ten/">SelectMany</a></code> in <code>LINQ</code> , but the essence does not change. <br><br><h2>  Validation </h2><br><img src="https://habrastorage.org/webt/59/da/39/59da39c240c17678132546.jpeg">  For example, there are three validation rules.  We can concatenate several validation rules using <code>bind</code> (to transform each one of them to a ‚Äútwo-track model‚Äù) and composition of functions.  That's the whole secret of error handling. <br><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> validateRequest = <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> nameNotBlank &gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> name50 &gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> emailNotBlank</code> </pre> <br>  Now we have a ‚Äúdouble track‚Äù function that accepts a request for input and returns a response.  We can use it as a building block for other functions. <br>  Often <code>bind</code> denoted by the <code>&gt;&gt;=</code> operator.  He borrowed from Haskell.  If you use <code>&gt;&gt;=</code> code will look like this: <br><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> (&gt;&gt;=) twoTrackInput switchFunction = <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> switchFunction twoTrackInput <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> validateRequest twoTrackInput = twoTrackInput &gt;&gt;= nameNotBlank &gt;&gt;= name50 &gt;&gt;= emailNotBlank</code> </pre><br>  When using <code>bind</code> type checking works the same way as before.  If you had composable functions, they will remain composable after using <code>bind</code> .  If the functions were not composable, then <code>bind</code> will not make them so. <br><br>  So, the base for error handling is as follows: we convert functions to a ‚Äútwo-track model‚Äù with <code>bind</code> and combine them with composition.  We move along the green gauge until everything is fine or we turn to red in case of an error. <br><br><h2>  But that is not all.  We will need to enter in this model </h2><br><ol><li>  single-track functions without errors </li><li>  deadlock functions </li><li>  functions throwing exceptions </li><li>  control functions </li></ol><br><h2>  Single-track functions without errors </h2><br><img src="https://habrastorage.org/webt/59/da/3a/59da3add400fb026280810.jpeg"><br><pre> <code class="hljs pgsql">let canonicalizeEmail input = { <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> email = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.email.Trim().ToLower() }</code> </pre> <br>  The <code>canonicalizeEmail</code> function is very simple.  It cuts off extra spaces and converts email to lower case.  It should not contain errors and exceptions (except NRE).  This is just a string conversion. <br><br>  The problem is that we learned how to compile using <code>bind</code> only double track functions.  We will need another adapter.  This adapter is called a <code>map</code> ( <code>Select</code> in <code>LINQ</code> ). <br><br><pre> <code class="hljs sql">let map singleTrackFunction twoTrackInput = match twoTrackInput <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Success</span></span> s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Success</span></span> (singleTrackFunction s) | <span class="hljs-keyword"><span class="hljs-keyword">Failure</span></span> f -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Failure</span></span> f // <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> : (<span class="hljs-string"><span class="hljs-string">'a -&gt; '</span></span>b) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Result</span></span>&lt;<span class="hljs-string"><span class="hljs-string">'a&gt; -&gt; Result&lt;'</span></span>b&gt;</code> </pre> <br>  <code>map</code> is a weaker function than <code>bind</code> , because you can create a <code>map</code> with <code>bind</code> , but not vice versa. <br><img src="https://habrastorage.org/webt/59/da/3b/59da3b4f658f4426739390.jpeg"><br><h2>  Dead-end functions </h2><br><img src="https://habrastorage.org/webt/59/da/3b/59da3b76e0d85966581122.jpeg"><br><pre> <code class="hljs pgsql">let updateDb request = // <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something // <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nothing</span></span> at <span class="hljs-keyword"><span class="hljs-keyword">all</span></span></code> </pre> <br>  Dead-end functions are write operations in the spirit of fire &amp; forget: you update the value in the database or write a file.  They have no return value.  They are also not bundled with double track functions.  All we need to do is get an input value, perform a dead-end function, and pass the value further down the chain.  By analogy with <code>bind</code> and <code>map</code> declare functions <code>tee</code> (sometimes called <code>tap</code> ). <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tee deadEndFunction oneTrackInput = deadEndFunction oneTrackInput oneTrackInput <span class="hljs-comment"><span class="hljs-comment">// tee : ('a -&gt; unit) -&gt; 'a -&gt; 'a</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/59/da/3c/59da3c0ee2259008680493.jpeg"><br><h2>  Functions that throw exceptions </h2><br><img align="left" src="https://habrastorage.org/webt/59/da/3c/59da3c550ee8a378249697.jpeg">  You, probably, have already noticed that a certain ‚Äúpattern‚Äù began to emerge.  Especially functions working with I / O.  The signatures of such methods lie because, besides successful completion, they can throw an exception, thus creating additional exit points.  From the signature of this is not visible, you need to familiarize yourself with the documentation in order to know what exceptions this or that function throws out. <br><br>  Exceptions are not suitable for this "double track" model.  Let's process them: the <code>SendEmail</code> function looks safe, but it can throw an exception.  Add another ‚Äúadapter‚Äù and wrap all such functions in a try / catch block. <br><br><blockquote>  ‚Äú <a href="https://www.youtube.com/watch%3Fv%3DBQ4yd2W50No">Do or do not, there is no try</a> ‚Äù - even Yoda does not recommend using exceptions <a href="https://stackoverflow.com/questions/729379/why-not-use-exceptions-as-regular-flow-of-control">for control flow</a> .  Many interesting things about this topic in Adam Sitnik's <a href="https://www.youtube.com/watch%3Fv%3DU92Ts53win4">Exceptional Exceptions</a> report (in English). </blockquote><br><h2>  Control functions </h2><br><img src="https://habrastorage.org/webt/59/da/3d/59da3d09b3383780015793.jpeg"><br>  In such functions, you just need to implement additional logic, for example, logging only successful operations or errors, or both.  Nothing complicated, we do by analogy with the previous cases. <br><br><h2>  Putting it all together </h2><br><img src="https://habrastorage.org/webt/59/da/3d/59da3d71ad366486644198.jpeg"><br>  We combined the functions <code>Validate</code> , <code>Canonicalize</code> , <code>UpdateDb</code> and <code>SendEmail</code> .  There was one problem.  The browser does not understand the "double-track model."  Now you need to go back to the "single-track" model.  Add the <code>returnMessage</code> function.  We return http code 200 and JSON success or <code>BadRequest</code> and a message in case of an error. <br><br><pre> <code class="hljs ruby">let executeUseCase = receiveRequest <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>validateRequest &gt;&gt; updateDbFromRequest &gt;&gt; sendEmail &gt;&gt; returnMessage</code> </pre> <br>  So, I promised that the code without error handling will be identical to the error handling code.  I admit, I cheated a little and declared new functions in a different namespace, wrapping functions to the left in <code>bind</code> . <br><br><h2>  Expanding the framework </h2><br><ol><li>  Considering possible errors in the design </li><li>  Parallelization </li><li>  Domain Events </li></ol><br><h2>  Considering possible errors in the design </h2><br>  I want to emphasize that <b>error handling is part of the software requirements</b> .  We focus only on successful scenarios.  It is necessary to level successful scenarios and rights errors. <br><br><pre> <code class="hljs pgsql">let validateInput input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.name = "" <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Failure "Name must not be blank" <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.email = "" <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Failure "Email must not be blank" <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Success <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> // happy <span class="hljs-type"><span class="hljs-type">path</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Result&lt;<span class="hljs-string"><span class="hljs-string">'TEntity&gt; = | Success of '</span></span>TEntity | Failure <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> string</code> </pre> <br>  Consider our validation function.  We use strings for errors.  This is a disgusting idea.  We introduce special types for errors.  In F #, the union type is usually used instead of enum.  Declare the type ErrorMessage.  Now, in the event of an error when a new error appears, we will have to add another option to the ErrorMessage.  This may seem like a burden, but I think it is, on the contrary, good, because such code is self-documenting. <br><br><pre> <code class="hljs vhdl">let validateInput input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.name = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-literal"><span class="hljs-literal">Failure</span></span> NameMustNotBeBlank <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.email = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-literal"><span class="hljs-literal">Failure</span></span> EmailMustNotBeBlank <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input.email doesn<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> match regex) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-literal"><span class="hljs-literal">Failure</span></span> EmailNotValid input.email <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Success input // happy path <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ErrorMessage = | NameMustNotBeBlank | EmailMustNotBeBlank | EmailNotValid <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailAddress</code> </pre> <br>  Imagine that you are working with legacy code.  You have a general idea of ‚Äã‚Äãhow the system should work, but you do not know exactly what can go wrong.  What if you had a file that describes all possible errors?  And more importantly, it‚Äôs not just text, but code, so this information is relevant. <br><br><blockquote>  This approach is very similar to checked exceptions in Java.  It is worth noting that they <a href="https://stackoverflow.com/questions/613954/the-case-against-checked-exceptions">did not take off</a> . </blockquote><br>  If you practice DDD, then you can build communication with business users based on this code.  You will have to ask questions about how to handle this or that situation, which in turn will force you and business users to consider more use cases at the design stage. <br><br>  After we replace strings with error types, we will have to modify the <code>retrunMessage</code> function to convert the types to strings. <br><br><pre> <code class="hljs perl">let returnMessage result = match result with | Success <span class="hljs-number"><span class="hljs-number">_</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"Success"</span></span> | Failure err -&gt; match err with | NameMustNotBeBlank -&gt; <span class="hljs-string"><span class="hljs-string">"Name must not be blank"</span></span> | EmailMustNotBeBlank -&gt; <span class="hljs-string"><span class="hljs-string">"Email must not be blank"</span></span> | EmailNotValid (EmailAddress email) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">sprintf</span></span> <span class="hljs-string"><span class="hljs-string">"Email %s is not valid"</span></span> email // database errors | UserIdNotValid (UserId id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">sprintf</span></span> <span class="hljs-string"><span class="hljs-string">"User id %i is not a valid user id"</span></span> id | DbUserNotFoundError (UserId id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">sprintf</span></span> <span class="hljs-string"><span class="hljs-string">"User id %i was not found in the database"</span></span> id | DbTimeout (<span class="hljs-number"><span class="hljs-number">_</span></span>,TimeoutMs ms) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">sprintf</span></span> <span class="hljs-string"><span class="hljs-string">"Could not connect to database within %i ms"</span></span> ms | DbConcurrencyError -&gt; <span class="hljs-keyword"><span class="hljs-keyword">sprintf</span></span> <span class="hljs-string"><span class="hljs-string">"Another user has modified the record. Please resubmit"</span></span> | DbAuthorizationError <span class="hljs-number"><span class="hljs-number">_</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">sprintf</span></span> <span class="hljs-string"><span class="hljs-string">"You do not have permission to access the database"</span></span> // SMTP errors | SmtpTimeout (<span class="hljs-number"><span class="hljs-number">_</span></span>,TimeoutMs ms) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">sprintf</span></span> <span class="hljs-string"><span class="hljs-string">"Could not connect to SMTP server within %i ms"</span></span> ms | SmtpBadRecipient (EmailAddress email) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">sprintf</span></span> <span class="hljs-string"><span class="hljs-string">"The email %s is not a valid recipient"</span></span> email</code> </pre> <br>  The conversion logic may be context-sensitive.  This greatly facilitates the task of internationalization: instead of searching for the lines scattered throughout the codebase, you only need to make a change in one function, right before transferring control to the UI layer.  Summarizing, we can say that this approach has the following advantages: <br><br><ol><li>  documentation for all cases in which something went wrong </li><li>  Tipo-safe, can not become obsolete </li><li>  reveals hidden requirements for sistemie </li><li>  simplifies unit testing </li><li>  simplifies internationalization </li></ol><br><h2>  Parallelization </h2><br><img src="https://habrastorage.org/webt/59/da/3f/59da3f477bda7260252712.jpeg"><br>  In the example with validation, the sequential model is inferior in the convenience of using parallel: instead of getting a validation error on each field, it is more convenient to get all the errors at once and correct them at the same time. <br><br>  If you can apply an operation to a pair and get an object of the same type as a result, then you can apply such operations to lists.  This is a property of monoids.  For a deeper understanding of the topic, you can read the article " <a href="http://fsharpforfunandprofit.com/posts/monoids-without-tears/">monoid without tears</a> ." <br><br><h2>  Domain Events </h2><br><img src="https://habrastorage.org/webt/59/da/3f/59da3f945ebda817816113.jpeg"><br><br>  In some cases, it is necessary to transfer additional information.  These are not errors, just something of additional interest in the context of the operation.  We can add these messages to the return value of the "successful path." <br><br><h2>  Beyond the scope of this article. </h2><br><ol><li>  Handling errors across service boundaries </li><li>  Asynchronous model </li><li>  Compensatory transactions </li><li>  Logging </li></ol><br><h2>  Summary.  Functional style error handling </h2><br><img src="https://habrastorage.org/webt/59/da/3f/59da3ffe40099216284623.jpeg"><br><br><ol><li>  Create a <code>Result</code> type.  Classic <code>Either</code> even more abstract and contains the properties <code>Left</code> and <code>Right</code> .  My <code>Result</code> type <code>Result</code> only more specialized. </li><li>  Use bind to convert functions to a ‚Äútwo-track model‚Äù </li><li>  Use the composition to link the individual functions to each other. </li><li>  We consider error codes as first-class objects. </li></ol><br><h2>  Links </h2><br><ol><li>  Source code with an example <a href="https://github.com/swlaschin/Railway-Oriented-Programming-Example">is available on github</a> </li><li>  <a href="https://habrahabr.ru/post/267231/">Article on Habr√©</a> based on the report with the implementation in C # </li></ol><br><a name="poll"></a></div><p>Source: <a href="https://habr.com/ru/post/339606/">https://habr.com/ru/post/339606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339590/index.html">Webpack and addictions</a></li>
<li><a href="../339592/index.html">Functional F #, which slowly appears in C #</a></li>
<li><a href="../339594/index.html">Expansion of analytical capabilities of the linear programming method with Python tools</a></li>
<li><a href="../339596/index.html">The history of hacking all the games in Telegram</a></li>
<li><a href="../339602/index.html">Service control panel. Part 1: Introduction</a></li>
<li><a href="../339608/index.html">The digest of interesting materials for the mobile developer # 224 (October 2 - October 8)</a></li>
<li><a href="../339610/index.html">Translation of two articles: ‚ÄúHow to commit changes to a Docker image‚Äù and ‚ÄúGuide for Moving Docker Containers‚Äù</a></li>
<li><a href="../339612/index.html">PGP offline key storage strategies</a></li>
<li><a href="../339614/index.html">Migrating business critical applications to the cloud: VMware tools overview</a></li>
<li><a href="../339616/index.html">At the bottom: what threatens underwater internet cables</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>