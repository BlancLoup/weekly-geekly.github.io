<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Poetic discourse with a taste of reverse engineering</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""The old man assembler noticed us 
 And going to the tomb, blessed " 



 Once I decided to write a poem program. The algorithm came up quickly - at t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Poetic discourse with a taste of reverse engineering</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>"The old man assembler noticed us</em> <em><br></em>  <em>And going to the tomb, blessed "</em> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/89e/0a5/cc1/89e0a5cc1b27471ab1e71086f4f0dd87.jpg" alt="image"></div><br><p>  Once I decided to write a poem program.  The algorithm came up quickly - at the end of the composed stanzas, put the rhyming words, and fill in the rest of the stanzas with words, taking into account the rhymes, rhythms, and the likelihood of finding them next to other words taken from ready-made connected texts.  Such Markov chains with rhymes fastened to them. <a name="habracut"></a></p><br><p>  Before implementing the algorithm, I decided to see what has already been created by others.  The first in the Yandex-search was found (who would doubt!) <a href="https://yandex.ru/autopoet">Yandex.Autopoet</a> , using neural networks trained on the verses of the classics.  The second point was the program ‚ÄúPoet's Assistant,‚Äù which, upon closer inspection, turned out to be the usual rhyming dictionary.  But in third place was the site of a famous writer and experienced fidoshnik Lleo aka Leonid Kaganov. </p><br><p>  Why was he there?  Because when he was a student at the Mining Institute, Lleo wrote a poetry-based program as a thesis.  I do not know how poetic the defense of such a diploma was, but the program seemed to work well - the poems written by her were posted on the author‚Äôs website.  The program itself was also found there, it worked under MS-DOS and a 32-bit DOS / 4GW extender.  The source code for this version was also posted.  I learned from the explanatory note to the diploma that there was also a version for OS / 2, apparently, even with a graphical interface, but its source was not found.  But the MS-DOS version could be run under DOSBox and see it in action: it really gave out rhymed and rather connected verses, although not very meaningful.  For 1996, when Lleo wrote this program, this level of autogenerated verses was very cool.  In my opinion, they are not even much worse than the poems of Yandex. Avtopopoet.  Or maybe Lleo became a famous writer with the help of a modified version of his program?  (Scandals, intrigues, investigations! Just kidding, of course, but who knows ...). </p><br><p>  I began to study how this program works.  For composing poems, she needed 2 files - a base of words and the markup of rhymes and the size of the composed verses.  The sources were in Assembler, about 3500 lines of sources under TASM.  The author of the program wrote about this: ‚ÄúI chose to solve most of the tasks on the assembler.  It was on it that I performed all the educational work, allowing you to choose a programming language.  Mainly because I write and debug a program in this language faster and easier - it allows you to more flexibly interact with the machine. ‚Äù  And here I fully agree - Assembler is very flexible, and does not impose any programming paradigm.  Although of course, it is faster to write programs in modern languages, collecting them from ready-made libraries-cubes.  In the source code there were all the characteristic signs of the Assembler programs of that time - short, not always intelligible, understandable only to the author names of variables and functions;  fixed sizes of arrays used with the comment ‚Äúprobably enough‚Äù;  a bunch of global variables, and sometimes witty author comments and error messages, like ‚ÄúCreative Crisis !!!‚Äù at the moment when the program runs out of words for the selection of rhymes.  Here in this spirit: </p><br><pre><code class="hljs mel">@@punkt13: ;call io ;db <span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">'{{F_LEVEL}}='</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> ;movzx eax,[F_LEVEL] ;call pr_dec cmp [nomer_LEVEL],<span class="hljs-number"><span class="hljs-number">0</span></span> ;<span class="hljs-number"><span class="hljs-number">13</span></span>)     ‚ñ†  <span class="hljs-number"><span class="hljs-number">16</span></span> jne @@punkt16 ;call io ;db <span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">'  '</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> ;call key cmp [F_LEVEL],<span class="hljs-number"><span class="hljs-number">0</span></span> ;<span class="hljs-number"><span class="hljs-number">13.0</span></span>)  ‚ñ† ‚ñ† =   jne @@punkt14 cmp [FREE_RHYME],<span class="hljs-number"><span class="hljs-number">0</span></span> ;<span class="hljs-number"><span class="hljs-number">13.1</span></span>)     ,  je @@error_twor ;‚ñ† ‚ñ†,  stc ret ;   @@punkt14: cmp [F_LEVEL],<span class="hljs-number"><span class="hljs-number">1</span></span> ;<span class="hljs-number"><span class="hljs-number">14</span></span>) ; ‚ñ† ‚ñ† = ‚ñ† ‚ñ†,  je @@<span class="hljs-number"><span class="hljs-number">565656</span></span> ;call io ;db <span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">'   ,    '</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  It was then that everything began - fascinated by the study of source codes, I forgot that I was originally going to implement the algorithm from scratch, and, recalling my own assembler programs, I decided to port the Lleo algorithm to a modern programming language.  Moreover, this algorithm was very similar to the one I had in mind.  As a language for porting, I chose Python - it is very convenient to work with text on it. </p><br><p>  Analysis of the program began with the fact that I walked through the code and removed all the commented code, there was a lot of it.  He left only the commented debugging output - he helped to understand what was happening in this place of the program.  Next, I deleted all the service calls, like getting command line keys and file I / O.  Now, when there was only code relating to the algorithm, I began to understand it and port it to Python.  For those functions, the purpose of which was clear, I immediately replaced the names with understandable ones, or, after rewriting them in Python, deleted the assembler code.  Remaining - began to translate line by line on Python.  Line by line, of course, it is strongly said that global state variables were widely used in the program, and so that it was not in the Python code, in many places the algorithm had to be completely rewritten without regard for the lines of the original program.  At this stage, the code looked like this - not yet Python, but not an Assembler: </p><br><pre> <code class="hljs pgsql">randomValue = init random(<span class="hljs-number"><span class="hljs-number">777</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> curMode==<span class="hljs-string"><span class="hljs-string">'C'</span></span>: print<span class="hljs-string"><span class="hljs-string">' '</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">' : '</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> BASEname NAME_SHABLON <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> loadBASE <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> curMode==<span class="hljs-string"><span class="hljs-string">'U'</span></span>: print<span class="hljs-string"><span class="hljs-string">'  '</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">' : '</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> loadBASE <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> stat <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> setUdarenie_N <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> saveBASE # <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> automat -    # jmp @@udara1 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br><p>  Unfortunately, right away I did not guess to look into the text of the explanatory note to the diploma, being sure that there was written a standard crap about economic justification.  Because of this, the actual algorithm of the verses and the format of the database of words, I literally reverse-engineering - according to the intelligibility of the names of variables and functions, the source code of the program is not very far from listing disassembler.  Although in general, the algorithm of the verses and the format of the verbal database are described in the <a href="https://lleo.me/soft/text_dip.htm">diploma note</a> .  I repent and sprinkle ashes on my head.  It is good that their analysis took no more than a couple of evenings.  In addition, not all the details of the format and the algorithm turned out to be in the documentation, so that later reverse engineering continued.  To work with binary data, Python found a very convenient unpack function.  And, having a little tinker with the order of data bytes in the data (of course, it is little endian here, since the program is written for an Intel processor), I was able to load the verbal database.  The format of the file with the rhythm of the verse was text, and very simple, it was not necessary to disassemble the download code. </p><br><p>  Now it was necessary to understand the proper algorithm for writing poetry.  As I wrote above, in general, it was described in the explanatory note, but some details were not there.  For example, the verse pattern is set in reverse order ‚Äî from the end of the stanza to the beginning.  Just like the fact that the Latin letter 'p' is everywhere replaced by Russian 'p' - the FIDO legacy, where there was a glitch from Russian ‚Äúp‚Äù, and it was replaced with Latin everywhere, so in Russian texts downloaded from FIDO ‚ÄúEverywhere was Latin, and it had to be transformed back into Russian.  Well, and other similar trivia.  In general, the algorithm was similar to the Markov chains described in the beginning of the article with rhymes, but it was distinguished by the fact that it used the stack to save the state while writing the stanza, with the ability to roll back states in the event that the algorithm comes to a dead end without finding a word with necessary stress and number of syllables.  The code also showed an attempt to compose poems on a given topic, for which the initial word of this topic was chosen, and then the search went on related words.  But it seems that this feature did not work, and in the function <code>make_RND_FIELD_TEMA</code> was only 1 hard-coded word index from which the program starts the selection of words. </p><br><p>  In the process of parsing the program there were funny moments. <br>  For example, at the beginning of the program was such a fragment: </p><br><pre> <code class="hljs scala">jmp @<span class="hljs-meta"><span class="hljs-meta">@skip</span></span> ; ... db <span class="hljs-symbol"><span class="hljs-symbol">'WATCO</span></span>M' ;     ,    <span class="hljs-type"><span class="hljs-type">DOS4GW</span></span> @<span class="hljs-meta"><span class="hljs-meta">@skip</span></span>:</code> </pre> <br><p>  The fact is that the 32-bit DOS / 4GW extender was written for programs compiled by commercial watcom compilers, and was itself a commercial product.  And the fact that the program was compiled by the Watcom compiler was determined by the "Watcom" line at the beginning of the program code.  If this line was not, then DOS / 4GW refused to work.  In fairness, I note that advanced people at that time used the PMODE / W by Tran extender, where there is no such nonsense, which is noticeably smaller in size, is free, and can be assigned to the program, while DOS / 4GW usually lies in the form separate executable file. </p><br><p>  There was also such a piece of code: </p><br><pre> <code class="hljs erlang-repl">proc bswap_eax ;   , ,   <span class="hljs-number"><span class="hljs-number">386</span></span>   bswap! mov [bswap_mes],eax ; ...</code> </pre> <br><p>  Indeed, there were no bswap commands on the 80386 processor, it appeared starting from 80486 and turned out to be very convenient, for example, to convert the little endian byte order -&gt; big endian.  So the people wrote such functions and comments. </p><br><p>  Another curious thing happened when I tested the algorithm for writing a verse.  For the test, I set the end of the stanza so that the word "busy" would definitely fill in the rhyme, which I saw exactly in the word database file.  However, this rhyme for some reason was not.  It turned out that the word "busy" is written in the database, and the "o" at the end is a part of the service data - a pointer to the word associated with it.  The fact that it was the letter ‚Äúo‚Äù is just a coincidence. </p><br><p>  When writing poetry was working, I quickly wrote down the spelling of prose - the usual Markov chains, and I wanted more - so that my program could generate the word base from the text itself, and not just use the finished program from the original program.  The base generation turned out to be devoted to almost the most part of the program, and due to the reasonableness of the algorithm of work, this part impressed me more than the one that composes verses.  In fact, she does all the preparatory work for composing poems: she can parse words from the input text, break them into syllables, and even automatically place accents based on the previously collected statistics of manual placement of accents by syllables.  Although, the emphasis is not always correct.  And, as far as I know, in the Russian language there is no sustainable rule for the placement of accents.  The base of accents was stored in a separate $$$$ SLOG.BSY file, the format of which was not described in the diploma note.  Here again I had a little reverse engineering. </p><br><p>  When the generation of the database of words earned, it was already possible to start experimenting with various texts.  As a result of experiments, it turned out that the algorithm for splitting words into syllables taken from the program does not always work correctly, and I rewrote it from scratch.  This also made it possible to refine the algorithm for obtaining a rhyming ending - now it works with syllables and stress, and not just goes to the vowel that is needed in order, relying on this feature to search for the right syllable. </p><br><p>  After that, I packed all the functionality into objects, decomposed into modules, and quickly wrote down a Python script using these modules, running from the command line, running with the same keys, and still able to do the same as the original program.  And he also knows how to load databases from the original program, although he already stores them in his format ‚Äî by serializing data through Python pickle.  Although the algorithm of the original program is pretty perelopachin, in many places I left the original comments - it is interesting to read them, and they keep the spirit of that era.  In addition, being launched with the ‚Äìoldschool key, the script displays the help of the original program in the console, where there are a lot of greetings to different people and steamers. </p><br><p>  Here is an example of poems being written: </p><br><pre> <code class="hljs markdown"><span class="hljs-emphasis"><span class="hljs-emphasis">***</span></span>                            </code> </pre><br><pre> <code class="hljs 1c">***    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>             <span class="hljs-keyword"><span class="hljs-keyword"></span></span>                <span class="hljs-keyword"><span class="hljs-keyword"></span></span>         <span class="hljs-keyword"><span class="hljs-keyword"></span></span> </code> </pre> <br><p>  As a result, we have a program that composes graphomaniac verses, with the help of which it is rather interesting to experiment with various texts. </p><br><p>  What else can you do good to her: </p><br><ul><li>  when generating a database of words, make a dictionary of rhymes - this will speed up the selection of words </li><li>  teach the program to use the dictionary of accents from the Internet, which will make it possible to place accents more correctly (but still not always correct - there are words in Russian with the same spelling but different accents) </li><li>  teach the program to write in those foreign languages ‚Äã‚Äãwhere the spelling uniquely determines the sound of the word.  It will be problematic with English - there, as they say, ‚ÄúWe write Liverpool we read Manchester‚Äù, but with French it is quite real.  In addition, it is easier to place accents there - they (almost) always fall to the end of the word. </li></ul><br><p>  That is, in fact, all that I wanted to talk about in this article. <br>  I have laid out the fruits of my labors on <a href="https://github.com/lebedevsergey/poet-ex-machina">Github</a> . </p><br><p>  Thank you all for your attention! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323034/">https://habr.com/ru/post/323034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323016/index.html">Multi-generation Intel processor performance comparison</a></li>
<li><a href="../323018/index.html">Objectives for sharing knowledge in an IT company</a></li>
<li><a href="../323020/index.html">Trends and prospects for the mobile application market: let's talk about money</a></li>
<li><a href="../323026/index.html">MTH: hurry to share our achievements</a></li>
<li><a href="../323030/index.html">Pattern Recognition and Scientific Knowledge</a></li>
<li><a href="../323036/index.html">Making your own log (archive) of alarms in Citect</a></li>
<li><a href="../323038/index.html">About ScalaCheck. Properties Part 3</a></li>
<li><a href="../323040/index.html">JPoint 2017 Java Conference: Moscow, April 7-8 - Review reports</a></li>
<li><a href="../323042/index.html">Zabbix 3.X: monitoring Adaptec controllers on Windows Server (Hyper-V Core)</a></li>
<li><a href="../323044/index.html">How we reconstructed the courthouse in Smolensk: from laser scans of stucco molding under mold to release</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>