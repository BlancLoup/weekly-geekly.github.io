<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32: FreeRTOS and Piezo Ceramic Emitter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A ceramic piezo emitter (buzzer) is a simple piece that, along with an LED, requires a minimum set of resources for control and is just as easily conn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32: FreeRTOS and Piezo Ceramic Emitter</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/e7d/0ff/c67/e7d0ffc675d64dd0a41ada4151b128ef.jpg" alt="image"><br><br>  A ceramic piezo emitter (buzzer) is a simple piece that, along with an LED, requires a minimum set of resources for control and is just as easily connected to a microcontroller.  Like the LED with the ability to smoothly adjust the brightness, the microcontroller requires no more than one channel of the timer and external output. <br><br>  There are a lot of lessons on the Internet ‚ÄúWe connect the squeaker to the Arduino‚Äù, only now they end up playing ‚ÄúA grasshopper sitting in the grass‚Äù or the voice acting of the RFID sensor.  Probably those who are engaged in this professionally and seriously, not to blogging and video recording. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But the miniature ceramic speaker is a step towards a more friendly interface with a man.  Pressing buttons, touching the touch panel, the reaction to various events ... Such is the feedback in the form of a sound response! <br><br>  We will try to do something with this under the cut, namely, write the driver for piezo dynamics and make it sound in parallel with several different external events. <br><a name="habracut"></a><br><h1>  <font color="#cc0000">Glands</font> </h1><br>  We will use a homemade board with a stm32f103 microcontroller in a 144-foot package and a <b><i>PKLCS1212E <b>40</b> A1-R1</i></b> piezo emitter from Murata. <br><br><img src="https://habrastorage.org/files/eea/868/7bf/eea8687bf0f44d169830e5aec8cae7e1.jpg" alt="image"><br><br>  This simple element is a ceramic plate, to the plates of which a signal of a certain frequency is given.  As a result, the plate oscillates itself and vibrates the air, and we hear a sound.  It makes no sense to bring the circuit board, but the connection of the tweeter is worth showing: <br><br><img src="https://habrastorage.org/files/62d/996/141/62d9961419fb4fbb9d4352ece7b94c50.PNG" alt="image"><br><br>  Pyezodinamik is turned on through the transistor and it is made for greater loudness of the sound (swinging with an amplitude of 5V), although you can hang it directly on the leg of the microcontroller (3.3V).  The documentation on it contains the frequency response, from which it can be seen that the maximum amplitude is achieved at an input signal of 4 kHz.  And in the component part number ( <i>PKLCS1212E <b>40</b> A1-R1</i> ) this is reflected ( <i>Expressed resonant frequency by two-digit alphanumerics. The unit is 100 hertz (Hz.) 4kHz (4000Hz) is denoted as "40."</i> ). <br><br><img src="https://habrastorage.org/files/72f/99f/8c6/72f99f8c6d83408dada72b8caef4a8a6.PNG" alt="image"><br><br>  We will work with sound, and here I will not dare to tell something deeper than the basics, since I myself have minimal knowledge: there are frequencies that the speaker can reproduce, there is an <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BA%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0">octave system</a> with which you can group, name the main frequencies, and Throw this data into an array.  We will work with him: <br><br><pre><code class="cpp hljs">u16 GL_BuzzerAllNotes[] = { <span class="hljs-number"><span class="hljs-number">261</span></span>, <span class="hljs-number"><span class="hljs-number">277</span></span>, <span class="hljs-number"><span class="hljs-number">294</span></span>, <span class="hljs-number"><span class="hljs-number">311</span></span>, <span class="hljs-number"><span class="hljs-number">329</span></span>, <span class="hljs-number"><span class="hljs-number">349</span></span>, <span class="hljs-number"><span class="hljs-number">370</span></span>, <span class="hljs-number"><span class="hljs-number">392</span></span>, <span class="hljs-number"><span class="hljs-number">415</span></span>, <span class="hljs-number"><span class="hljs-number">440</span></span>, <span class="hljs-number"><span class="hljs-number">466</span></span>, <span class="hljs-number"><span class="hljs-number">494</span></span>, <span class="hljs-number"><span class="hljs-number">523</span></span>, <span class="hljs-number"><span class="hljs-number">554</span></span>, <span class="hljs-number"><span class="hljs-number">587</span></span>, <span class="hljs-number"><span class="hljs-number">622</span></span>, <span class="hljs-number"><span class="hljs-number">659</span></span>, <span class="hljs-number"><span class="hljs-number">698</span></span>, <span class="hljs-number"><span class="hljs-number">740</span></span>, <span class="hljs-number"><span class="hljs-number">784</span></span>, <span class="hljs-number"><span class="hljs-number">831</span></span>, <span class="hljs-number"><span class="hljs-number">880</span></span>, <span class="hljs-number"><span class="hljs-number">932</span></span>, <span class="hljs-number"><span class="hljs-number">988</span></span>, <span class="hljs-number"><span class="hljs-number">1046</span></span>, <span class="hljs-number"><span class="hljs-number">1109</span></span>, <span class="hljs-number"><span class="hljs-number">1175</span></span>, <span class="hljs-number"><span class="hljs-number">1245</span></span>, <span class="hljs-number"><span class="hljs-number">1319</span></span>, <span class="hljs-number"><span class="hljs-number">1397</span></span>, <span class="hljs-number"><span class="hljs-number">1480</span></span>, <span class="hljs-number"><span class="hljs-number">1568</span></span>, <span class="hljs-number"><span class="hljs-number">1661</span></span>, <span class="hljs-number"><span class="hljs-number">1760</span></span>, <span class="hljs-number"><span class="hljs-number">1865</span></span>, <span class="hljs-number"><span class="hljs-number">1976</span></span>, <span class="hljs-number"><span class="hljs-number">2093</span></span>, <span class="hljs-number"><span class="hljs-number">2217</span></span>, <span class="hljs-number"><span class="hljs-number">2349</span></span>, <span class="hljs-number"><span class="hljs-number">2489</span></span>, <span class="hljs-number"><span class="hljs-number">2637</span></span>, <span class="hljs-number"><span class="hljs-number">2794</span></span>, <span class="hljs-number"><span class="hljs-number">2960</span></span>, <span class="hljs-number"><span class="hljs-number">3136</span></span>, <span class="hljs-number"><span class="hljs-number">3322</span></span>, <span class="hljs-number"><span class="hljs-number">3520</span></span>, <span class="hljs-number"><span class="hljs-number">3729</span></span>, <span class="hljs-number"><span class="hljs-number">3951</span></span>, <span class="hljs-number"><span class="hljs-number">4186</span></span>, <span class="hljs-number"><span class="hljs-number">4434</span></span>, <span class="hljs-number"><span class="hljs-number">4699</span></span>, <span class="hljs-number"><span class="hljs-number">4978</span></span>, <span class="hljs-number"><span class="hljs-number">5274</span></span>, <span class="hljs-number"><span class="hljs-number">5588</span></span>, <span class="hljs-number"><span class="hljs-number">5920</span></span>, <span class="hljs-number"><span class="hljs-number">6272</span></span>, <span class="hljs-number"><span class="hljs-number">6645</span></span>, <span class="hljs-number"><span class="hljs-number">7040</span></span>, <span class="hljs-number"><span class="hljs-number">7459</span></span>, <span class="hljs-number"><span class="hljs-number">7902</span></span>}; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OCTAVE_ONE_START_INDEX (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OCTAVE_TWO_START_INDEX (OCTAVE_ONE_START_INDEX + 12) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OCTAVE_THREE_START_INDEX (OCTAVE_TWO_START_INDEX + 12) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OCTAVE_FOUR_START_INDEX (OCTAVE_THREE_START_INDEX + 12) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OCTAVE_FIVE_START_INDEX (OCTAVE_FOUR_START_INDEX + 12) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUZZER_DEFAULT_FREQ (4186) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//C8 - 5th octave "Do" #define BUZZER_DEFAULT_DURATION (20) //20ms #define BUZZER_VOLUME_MAX (10) #define BUZZER_VOLUME_MUTE (0)</span></span></span></span></code> </pre> <br><h1>  <font color="#cc0000">Piezodinamika driver</font> </h1><br>  Pyezodinamik is not a LED, pulse-width modulation with a constant frequency and a variable pulse ratio does not work here.  The leg, on which the control transistor hangs (PA15, TIM2, CH1), is tuned in the PWM mode: <br><br><div class="spoiler">  <b class="spoiler_title">void BuzzerConfig (void)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuzzerConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ GPIO_InitTypeDef GPIO_Options; TIM_TimeBaseInitTypeDef TIM_BaseOptions; TIM_OCInitTypeDef TIM_PWM_Options; RCC_APB2PeriphClockCmd(BUZZER_CLK_PINS | RCC_APB2Periph_AFIO, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE); GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE); <span class="hljs-comment"><span class="hljs-comment">//PA.15 TIM2_CH1, BUZZER GPIO_Options.GPIO_Pin = BUZZER_PIN; GPIO_Options.GPIO_Speed = GPIO_Speed_10MHz; GPIO_Options.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(BUZZER_PORT, &amp;GPIO_Options); TIM_BaseOptions.TIM_Period = 2 * BUZZER_VOLUME_MAX - 1; TIM_BaseOptions.TIM_ClockDivision = TIM_CKD_DIV1; TIM_BaseOptions.TIM_CounterMode = TIM_CounterMode_Up; TIM_TimeBaseInit(TIM2, &amp;TIM_BaseOptions); TIM_PWM_Options.TIM_OCMode = TIM_OCMode_PWM1; TIM_PWM_Options.TIM_OutputState = TIM_OutputState_Enable; TIM_PWM_Options.TIM_OutputNState = TIM_OutputNState_Disable; TIM_PWM_Options.TIM_OCPolarity = TIM_OCPolarity_High; TIM_PWM_Options.TIM_Pulse = 0; TIM_OC1Init(TIM2, &amp;TIM_PWM_Options); TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable); TIM_ARRPreloadConfig(TIM2, ENABLE); TIM_Cmd(TIM2, ENABLE); }</span></span></code> </pre> </div></div><br>  The code does not contain an important timer setting parameter - a clock pre-splitter.  We will change it dynamically, and we will achieve the generation of sound of the desired frequency. <br><br>  Obviously, changing the frequency of the signal leads to a change in sound, but what about the pulse ratio?  I did not find anything useful on this issue in the documentation, but there was an assumption that changing the duty ratio entails a change in volume.  If this is true, then the meander (duty ratio = 50%) will give the maximum volume, and convergence to 0% (or symmetrically, to 100%) will reduce the volume, finally, to zero.  It really works so-so, so I just turn the beeper on and off using the following two macros: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUZZER_VOLUME_MAX 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUZZER_VOLUME_MUTE 0</span></span></code> </pre> <br>  BUZZER_VOLUME_MAX - this is the number of pulses, which is twice laid out in the required period of work, which is inversely proportional to the frequency.  We know the required frequency (setting), the period is also clear (x2), and therefore the predecessor for the timer will not be difficult to find.  In STM32, it is any number from 1 to 0xFFFF. <br><br>  Wrap all actions in the frequency setting function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuzzerSetFreq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 freq)</span></span></span><span class="hljs-function"> </span></span>{ TIM2-&gt;PSC = (SYSCLK_FREQ / (<span class="hljs-number"><span class="hljs-number">2</span></span> * BUZZER_VOLUME_MAX * freq)) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//prescaller }</span></span></code> </pre><br>  And changing the duty cycle to set the volume: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuzzerSetVolume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 volume)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(volume &gt; BUZZER_VOLUME_MAX) volume = BUZZER_VOLUME_MAX; TIM2-&gt;CCR1 = volume; }</code> </pre><br>  Everything, the driver of a tweaker is ready  You can play something, after creating an array of frequencies (and durations would be nice). <br><br><div class="spoiler">  <b class="spoiler_title">Happy birthday</b> <div class="spoiler_text"><pre> <code class="cpp hljs">u32 HappyBirthday[] = { <span class="hljs-number"><span class="hljs-number">262</span></span>, <span class="hljs-number"><span class="hljs-number">262</span></span>, <span class="hljs-number"><span class="hljs-number">294</span></span>, <span class="hljs-number"><span class="hljs-number">262</span></span>, <span class="hljs-number"><span class="hljs-number">349</span></span>, <span class="hljs-number"><span class="hljs-number">330</span></span>, <span class="hljs-number"><span class="hljs-number">262</span></span>, <span class="hljs-number"><span class="hljs-number">262</span></span>, <span class="hljs-number"><span class="hljs-number">294</span></span>, <span class="hljs-number"><span class="hljs-number">262</span></span>, <span class="hljs-number"><span class="hljs-number">392</span></span>, <span class="hljs-number"><span class="hljs-number">349</span></span>, <span class="hljs-number"><span class="hljs-number">262</span></span>, <span class="hljs-number"><span class="hljs-number">262</span></span>, <span class="hljs-number"><span class="hljs-number">523</span></span>, <span class="hljs-number"><span class="hljs-number">440</span></span>, <span class="hljs-number"><span class="hljs-number">349</span></span>, <span class="hljs-number"><span class="hljs-number">330</span></span>, <span class="hljs-number"><span class="hljs-number">294</span></span>, <span class="hljs-number"><span class="hljs-number">466</span></span>, <span class="hljs-number"><span class="hljs-number">466</span></span>, <span class="hljs-number"><span class="hljs-number">440</span></span>, <span class="hljs-number"><span class="hljs-number">349</span></span>, <span class="hljs-number"><span class="hljs-number">392</span></span>, <span class="hljs-number"><span class="hljs-number">349</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(HappyBirthday) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(u32); i++) { BuzzerSetFreq(HappyBirthday[i]); BuzzerSetVolume(BUZZER_VOLUME_MAX); DelayTime(<span class="hljs-number"><span class="hljs-number">400</span></span>); BuzzerSetVolume(BUZZER_VOLUME_MUTE); }</code> </pre></div></div><br><h1>  <font color="#cc0000">Piezodinamik as a shared resource</font> </h1><br>  The global idea is to create a convenient interface for pseudo-parallel access of various tasks to the hardware piezodynamics module using FreeRTOS.  I will not talk about FreeRTOS itself, this topic is not for one article, which is already quite a few (including good online documentation at <a href="http://www.freertos.org/">www.freertos.org</a> . I can recommend this <a href="http://microsin.net/programming/arm/freertos-part1.html">resource in Russian</a> ). <br><br>  Create a composite data type that describes the minimum set of necessary parameters for a single sound reproduction of a certain frequency and volume for a certain time.  It sounds scary, but this is just a structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> u16 freq; u16 volume; u16 duration; } BuzzerParameters_t;</code> </pre><br>  To use the tweeter as a resource, to which any task can give some data for ‚Äúsounding‚Äù, we will use the standard intertask communication and synchronization mechanism of the FreeRTOS <i><b>queue</b></i> . <br><br>  The queue stores in itself a finite set of data elements of a fixed size and is a FIFO buffer, in which tasks can both record data and take them away - with subsequent deletion (or without it, if desired).  Any number of tasks can write their data into the queue, but only the problem of piezodynamics will be read from it. <br><br>  Create a queue with a length of 10 elements, consisting of <b><i>building</i></b> blocks of type <b><i>BuzzerParameters_t</i></b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUZZER_QUEUE_LEN 10 QueueHandle_t BuzzerQueue = xQueueCreate(BUZZER_QUEUE_LEN, sizeof(BuzzerParameters_t);</span></span></code> </pre> <br>  Event processing tweeters will be engaged in the task dynamics.  Tasks in FreeRTOS are small subroutines that have an entry point and an infinite loop, the return of which is prohibited (allowed to either pause the task or delete it).  Prior to the start of the task, you need to create a task by passing the pointer to the task function as the first parameter, and the optional handle last. <br><br><pre> <code class="cpp hljs">TaskHandle_t BuzzerHandle; xTaskCreate(vTask_BuzzerBeep, <span class="hljs-string"><span class="hljs-string">"BuzzerBeep"</span></span>, configMINIMAL_STACK_SIZE, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, tskIDLE_PRIORITY + <span class="hljs-number"><span class="hljs-number">2</span></span>, &amp;BuzzerHandle);</code> </pre><br>  In an infinite loop, the task will wait for the data in the queue.  The <b><i>portMAX_DELAY</i></b> parameter means that the task is blocked by the scheduler until the queue is empty.  As soon as this becomes not so, the tweeter driver is initialized by the parameters passed through the queue, and the read element is removed from the queue (if it is not required to delete, there is a function <i><b>xQueuePeek ()</b></i> ). <br>  Instead of a delay based on the inactivity of the microcontroller for some time, the <b><i>vTaskDelay ()</i></b> function is used, blocking the task for a specified amount of time in milliseconds (actually, on the number of system ticks of the RTOS, but I have 1 tick = 1 ms).  Thus, the task is blocked again during the playback of the sound, and when the blocking time has elapsed, it stops generating it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTask_BuzzerBeep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvParameters)</span></span></span><span class="hljs-function"> </span></span>{ BuzzerParameters_t buzzerParameters; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { xQueueReceive(BuzzerQueue, &amp;buzzerParameters, portMAX_DELAY); BuzzerSetFreq(buzzerParameters.freq); BuzzerSetVolume(buzzerParameters.volume); vTaskDelay(buzzerParameters.duration); BuzzerSetVolume(BUZZER_VOLUME_MUTE); } }</code> </pre> <br>  It looks easy and logical, unlike shamanism with timers, interrupts and flags without using RTOS.  Now let's try this mechanism in action. <br><br>  Given: <br><br><ul><li>  Button.  It would be nice to distinguish between long and short pressing. </li><li>  Mechanical quadrature encoder.  You can rotate clockwise, counterclockwise, as well as press the button in the center.  For the button, short and long presses are also relevant. </li></ul><br><img src="https://habrastorage.org/files/908/d32/e10/908d32e10f054808aff9b38eb9352901.JPG" alt="image"><br><br>  Let's start with the button.  It can be in one of three states: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { BUTTON_RELEASED = <span class="hljs-number"><span class="hljs-number">0</span></span>, BUTTON_SHORT_PRESSED, BUTTON_LONG_PRESSED } BUTTON_PARAMETERS_t;</code> </pre> <br>  Initialize the microcontroller leg, configure the interrupt: <br><br><div class="spoiler">  <b class="spoiler_title">void StartButtonConfig (void)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartButtonConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ GPIO_InitTypeDef GPIO_Options; EXTI_InitTypeDef EXTI_Options; NVIC_InitTypeDef NVIC_Options; RCC_APB2PeriphClockCmd(START_BUTTON_CLK_PINS | RCC_APB2Periph_AFIO, ENABLE); GPIO_Options.GPIO_Pin = START_BUTTON_PIN; GPIO_Options.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(START_BUTTON_PORT, &amp;GPIO_Options); GPIO_EXTILineConfig(START_BUTTON_PORTSOURCE, START_BUTTON_PINSOURCE); EXTI_Options.EXTI_Line = START_BUTTON_EXTI_LINE; EXTI_Options.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_Options.EXTI_Trigger = EXTI_Trigger_Rising; EXTI_Options.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_Options); NVIC_Options.NVIC_IRQChannel = EXTI2_IRQn; NVIC_Options.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number"><span class="hljs-number">13</span></span>; NVIC_Options.NVIC_IRQChannelSubPriority = <span class="hljs-number"><span class="hljs-number">0</span></span>; NVIC_Options.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_Options); }</code> </pre> </div></div><br>  The first event that occurs when a button is pressed will be the input to the handler: <br><br><div class="spoiler">  <b class="spoiler_title">void EXTI2_IRQHandler (void)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EXTI2_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE; EXTI_InitTypeDef EXTI_Options; EXTI_ClearITPendingBit(EXTI_Line2); EXTI_Options.EXTI_Line = EXTI_Line2; EXTI_Options.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_Options.EXTI_Trigger = EXTI_Trigger_Rising; EXTI_Options.EXTI_LineCmd = DISABLE; EXTI_Init(&amp;EXTI_Options); xSemaphoreGiveFromISR(StartButtonSemaphore, &amp;xHigherPriorityTaskWoken); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xHigherPriorityTaskWoken == pdTRUE) { portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); } }</code> </pre> </div></div><br>  In it, we standardly reset the flag of the event and cut off the generation of interruption on this leg (this is my anti-debater, it works awesome).  Using the semaphore, we tell the task of processing the <i><b>vTask_GetStartButton ()</b></i> button that it‚Äôs time to work.  Exit interrupt. <br><br>  By this time, the <i><b>vTask_GetStartButton ()</b></i> task with the StartButtonHandle <b><i>handle</i></b> must already have been created and locked by the <b><i>xSemaphoreTake ()</i></b> function, waiting for the semaphore from the interrupt.  The logic of work is as follows: <br><br><ol><li>  We are waiting for <b><i>xSemaphoreTake () to</i></b> get the desired one from the interrupt. </li><li>  Peak the speaker (using the queue, aha!) And block the task for 1/4 of a second </li><li>  Peak every 100 ms for 300 ms if the button is in the clamped state.  Use different notes in the direction of increasing the frequency of the array <b><i>GL_BuzzerAllNotes []</i></b> </li><li>  In an infinite loop, we wait until the button is released completely (we definitely make a delay using the RTOS, otherwise waiting will take all the processor time for itself - what if the user puts a bottle of whiskey on the button, as in Silicon Valley =)) </li><li>  We define by <b><i>notePointer</i></b> variable, how long the button was held ( <b><i>BUTTON_LONG_PRESSED</i></b> or <b><i>BUTTON_SHORT_PRESSED</i></b> ) </li><li>  We pica for the last time, resume the interrupt response </li></ol><br>  But it is better to read the comments in the code - they are more consistent: <br><br><div class="spoiler">  <b class="spoiler_title">void vTask_GetStartButton (void * pvParameters)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTask_GetStartButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvParameters)</span></span></span><span class="hljs-function"> </span></span>{ BuzzerParameters_t buzzerLocalParameters; u32 localStartButtonState; EXTI_InitTypeDef EXTI_Options; u32 notePointer = <span class="hljs-number"><span class="hljs-number">0</span></span>; EXTI_Options.EXTI_Line = START_BUTTON_EXTI_LINE; EXTI_Options.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_Options.EXTI_Trigger = EXTI_Trigger_Rising; EXTI_Options.EXTI_LineCmd = ENABLE; buzzerLocalParameters.volume = BUZZER_VOLUME_MAX; buzzerLocalParameters.duration = BUZZER_DEFAULT_DURATION; <span class="hljs-comment"><span class="hljs-comment">/* * first semaphore take after creation (NEED!! it issued after power up) */</span></span> xSemaphoreTake(StartButtonSemaphore, portMAX_DELAY); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-comment"><span class="hljs-comment">/* * take semaphore from button interrupt */</span></span> xSemaphoreTake(StartButtonSemaphore, portMAX_DELAY); <span class="hljs-comment"><span class="hljs-comment">/* * buzzer "pick" on button click and wait */</span></span> buzzerLocalParameters.freq = NOTE_C7; xQueueSend(BuzzerQueue, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)&amp;buzzerLocalParameters, portMAX_DELAY); vTaskDelay(<span class="hljs-number"><span class="hljs-number">250</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* * "pick" new note while button pressed, but not more 3 times */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(GPIO_ReadInputDataBit(START_BUTTON_PORT, START_BUTTON_PIN) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { buzzerLocalParameters.freq = GL_BuzzerAllNotes[OCTAVE_FOUR_START_INDEX + notePointer]; xQueueSend(BuzzerQueue, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)&amp;buzzerLocalParameters, portMAX_DELAY); vTaskDelay(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(notePointer++ &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * wait while button pressed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(GPIO_ReadInputDataBit(START_BUTTON_PORT, START_BUTTON_PIN) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { vTaskDelay(<span class="hljs-number"><span class="hljs-number">100</span></span>); } localStartButtonState = (notePointer &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) ? (BUTTON_LONG_PRESSED) : (BUTTON_SHORT_PRESSED); xQueueSend(StartButtonQueue, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)&amp;localStartButtonState, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* * "pick" the last time and re-enable interrupt on click */</span></span> buzzerLocalParameters.freq = NOTE_C8; xQueueSend(BuzzerQueue, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)&amp;buzzerLocalParameters, portMAX_DELAY); EXTI_Init(&amp;EXTI_Options); <span class="hljs-comment"><span class="hljs-comment">//Enable interrupt (disabled in interrupts.c) notePointer = 0; vTaskDelay(100); } }</span></span></code> </pre> </div></div><br>  The result of the click is added to the pre-created queue for the button with the size of one element: <br><br><pre> <code class="cpp hljs">StartButtonQueue = xQueueCreate(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(u32));</code> </pre> <br>  After processing the click, the queue will store the result until a task reads it from there. <br><br>  <i>Here it is worthwhile to separately focus on the policy of adding to the data queue.</i>  <i>We are assisted by the third parameter of the function <b>xQueueSend ()</b> .</i>  <i>If it is 0 and the queue is full, then ignore the record and go on through the code.</i>  <i>PortMAX_DELAY, on the contrary, allows you to block the execution of a task until at least one entry is free in the queue.</i>  <i>In general, this parameter is the time for which the task must be blocked to wait for the free space to appear.</i>  <i>Pressing a button, for example, can be ignored, but you should always voice it, given that the voice acting does not take a lot of time with a reasonable <b>duration</b> parameter</i> . <br><br>  We do the same with the Encoder button (a separate interrupt, a separate <b><i>EncoderButtonQueue queue</i></b> , a separate processing task that sends data to the common speaker queue) <br><br>  Now encoder.  I want every click to be voiced, and even by ear it is clear that an increment or decrement happened.  We will not create a separate task, we will handle everything in the interrupt.  It is configured <u>only for one channel, but also for the front and the decay</u> (never, <u>never</u> use the hardware encoder handler built into this microcontroller - it is terrible): <br><br><div class="spoiler">  <b class="spoiler_title">void EncoderConfig (void)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncoderConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ GPIO_InitTypeDef GPIO_Options; EXTI_InitTypeDef EXTI_Options; RCC_APB2PeriphClockCmd(ENCODER_CLK_PINS | RCC_APB2Periph_AFIO, ENABLE); GPIO_Options.GPIO_Pin = ENCODER_A_PIN | ENCODER_B_PIN; GPIO_Options.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(ENCODER_PORT, &amp;GPIO_Options); GPIO_EXTILineConfig(ENCODER_PORTSOURCE, ENCODER_PINSOURCE); <span class="hljs-comment"><span class="hljs-comment">//Only one line interrupt! EXTI_Options.EXTI_Line = ENCODER_EXTI_LINE; EXTI_Options.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_Options.EXTI_Trigger = EXTI_Trigger_Rising_Falling; EXTI_Options.EXTI_LineCmd = ENABLE; EXTI_Init(&amp;EXTI_Options); }</span></span></code> </pre> </div></div><br>  At the entrance to the interrupt, we determine where the shaft is turned: clockwise or against: <br><br><div class="spoiler">  <b class="spoiler_title">void EXTI0_IRQHandler (void)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">u32 localEncoderAction; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GPIO_ReadInputDataBit(ENCODER_PORT, ENCODER_A_PIN) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GPIO_ReadInputDataBit(ENCODER_PORT, ENCODER_B_PIN) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { localEncoderAction = ENCODER_WAS_INCR; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { localEncoderAction = ENCODER_WAS_DECR; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GPIO_ReadInputDataBit(ENCODER_PORT, ENCODER_B_PIN) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { localEncoderAction = ENCODER_WAS_DECR; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { localEncoderAction = ENCODER_WAS_INCR; } } EXTI_ClearITPendingBit(EXTI_Line0);</code> </pre> </div></div><br>  All in the same interrupt handling function, based on the information about the direction of rotation, we will change the variable <b><i>buzzerRotationCounter</i></b> , which determines the index of the note being played from the <b><i>GL_BuzzerAllNotes []</i></b> array.  Rotating the encoder, we get an increase or decrease in the frequency of the sound by + -15 units from the value 25. Next, we form and send an element to the speaker's queue, take a look at the encoder event and exit the interrupt: <br><br><div class="spoiler">  <b class="spoiler_title">void EXTI0_IRQHandler (void), continued</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TickType_t xLastTime; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> s32 buzzerRotationCounter = <span class="hljs-number"><span class="hljs-number">15</span></span>; BuzzerParameters_t localParameters; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((xTaskGetTickCount() - xLastTime) &gt; <span class="hljs-number"><span class="hljs-number">300</span></span>) { buzzerRotationCounter = <span class="hljs-number"><span class="hljs-number">25</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(localEncoderAction == ENCODER_WAS_INCR) { buzzerRotationCounter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(buzzerRotationCounter &gt; <span class="hljs-number"><span class="hljs-number">39</span></span>) { buzzerRotationCounter = <span class="hljs-number"><span class="hljs-number">39</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">//ENCODER_WAS_DECR { buzzerRotationCounter--; if(buzzerRotationCounter &lt; 10) { buzzerRotationCounter = 10; } } xLastTime = xTaskGetTickCount(); localParameters.duration = 10;//BUZZER_DEFAULT_DURATION; localParameters.freq = GL_BuzzerAllNotes[buzzerRotationCounter]; localParameters.volume = BUZZER_VOLUME_MAX; xQueueSendFromISR(BuzzerQueue, (void *)&amp;localParameters, &amp;xHigherPriorityTaskWoken); xQueueSendFromISR(EncoderQueue, (void *)&amp;localEncoderAction, &amp;xHigherPriorityTaskWoken); if(xHigherPriorityTaskWoken == pdTRUE) { portEND_SWITCHING_ISR(xHigherPriorityTaskWoken); }</span></span></code> </pre> </div></div><br>  I could not describe the algorithm of working with words, but it was better to still <s>see</s> what came of it: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lttU3_8578k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1>  <font color="#cc0000">Well, why all this?</font> </h1><br>  Not that the above described is very difficult and it was necessary to sort it out in steps.  Seriously, the essence of the publication can be reduced globally to a proposal - we will create a queue for the task and, according to the invented algorithms, we will push the data there.  However, it seemed to me that such an example would not be bad for demonstrating the parallelization of access of various tasks to hardware resources of iron using FreeRTOS.  The same thing, but done by hand on flags and interruptions with timers, though the memory ate less than RTOS - but in terms of readability, portability and usability was an order of magnitude worse. <br><br>  And of course - the devices that we design, first of all, should be easy to use and not cause hate feelings to the user.  Hopefully, the manufacturers of my electric kettle someday will understand this, and the sounds that cause blood from the ears will disappear along with the blinding LEDs.  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/316990/">https://habr.com/ru/post/316990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316976/index.html">Database of countries, regions and cities</a></li>
<li><a href="../316978/index.html">Dear javascript</a></li>
<li><a href="../316980/index.html">Formula of trust</a></li>
<li><a href="../316986/index.html">Tuning Swift compiler. Part 1</a></li>
<li><a href="../316988/index.html">Nonlinear regression in Apache Spark. We develop with our own hands</a></li>
<li><a href="../316994/index.html">Bad advice or how to become a terrible leader.</a></li>
<li><a href="../316996/index.html">Creating a blog engine with Phoenix and Elixir / Part 5. Connecting ExMachina</a></li>
<li><a href="../317002/index.html">We write real Pointer Analysis for LLVM. Part 1: Introducing or first meeting with the world of program analysis</a></li>
<li><a href="../317004/index.html">RubyMine 2016.3: Debugging in attach mode, updated support for Puppet, SDK synchronization via rsync</a></li>
<li><a href="../317008/index.html">Productivity is my ecommerce site evaluation method</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>