<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Frontend performance optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A braking site is a pain not only for the user, but also for the developer. How you can fix the situation, when you need to rely on caching, and where...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Frontend performance optimization</h1><div class="post__text post__text-html js-mediator-article"> A braking site is a pain not only for the user, but also for the developer.  How you can fix the situation, when you need to rely on caching, and where you can trust the processor, and how all this can help optimize the performance of a complex frontend application, JS expert and HTML Academy teacher Igor Alekseenko (@ iamo0) is ready to explain in practice .  Under the cut - the decoding of his report with <a href="http://frontendconf.ru/">Frontend Conf 2017</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98e/f87/5aa/98ef875aa8c4e0ba7ec73f076594a534.jpg"><br><br><a name="habracut"></a><br>  <b><i>About speaker</i></b> <img src="https://habrastorage.org/getpro/habr/post_images/e69/e60/df3/e69e60df38a3a3a66f74b586a373cd9d.jpg" align="left"><br>  <i>Igor Alekseenko is a developer with a great experience, he conducts basic and advanced courses on JS at the HTML Academy.</i>  <i>He worked at Lebedev Studio, Islet, and JetBrains.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Today I wanted to talk about the problem of developers.  I will share my own pain, but I hope you share it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/940/589/d91/940589d9164ea40230b54bbe8685e5e3.png"><br><br>  I hate it when the interfaces slow down.  And I hate not only as a user of sites - but also as their developer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d6/048/db6/9d6048db65d39238b7a48d0398a92f11.png"><br><br>  Why?  Because we, as developers, are responsible for the emotions that people experience on sites, for their experience.  If a person comes to the site and gets some kind of negative experience - this is our fault.  This is not a designer, not a complex technology - this is us. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d36/af3/c1c/d36af3c1c26df9df7bfbd83c83a33a7f.png"><br><br>  Well, when the interface just slows down.  Well, you think, the user will come to our online game, but will not be able to aim and kill the opponent or see some jerky animation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/593/300/ee8/593300ee8988ca25d5cab2c56d678813.png"><br><br>  But in fact, everything is much more complicated.  Because there are more sites, and they solve more complex tasks.  If you are developing any banking application and you have had a second data transfer, and the user has lost money, or you have an online store, and the user could not buy the goods he needs, then you will lose this user.  And all this is simply due to the fact that your site is slow. <br><br>  A lost user is a loss of money, lost revenue from the company's point of view, and possibly your dismissal. <br><br>  Therefore, in general, braking the site - this is a serious problem.  And so it needs to be addressed. <br>  But in order to solve a problem, you need to know the enemy by sight.  Let's see what the brakes on sites are all about, why websites slow down and where it comes from. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80b/dbd/02b/80bdbd02b0c98d3c9277ea31719283bc.png"><br><br>  Brakes on sites occur when user interaction is no longer even.  What does it mean?  The fact is that when users browse the site, they see not just some static image.  Because the site is not just a picture, it is a process of user interaction with the interface that we offer him. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/512/8bc/1d8/5128bc1d8ab24538d0d7c87b51d6bca3.png"><br><br>  The user can see the same animations that I talked about.  It can trivially scroll the site - and this is also a dynamic interaction.  He pokes on buttons, enters text, drags elements.  This all works dynamically. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88e/581/047/88e581047995d142d1fb908e3296a572.png"><br><br>  Why does it work dynamically?  Why sites can live for a long time? <br>  This is due to the fact that such a structure as the Event Loop is built into all browser engines. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/934/50c/7b5/93450c7b532c49d92e28cd86d1189536.png"><br><br>  In fact, the Event Loop is such a simple programmer trick, which is that we simply start an infinite loop with a certain frequency.  So that we do not have a clogged stack and some kind of performance. <br><br>  This infinite loop at each step checks external conditions and starts certain actions.  For example, he understands that the user has scrolled the mouse and you need to slightly shift the page. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/676/44b/043/67644b0439303521da40c471b26e12e5.png"><br><br>  With the Event Loop, which is built into the browser engine, all user interactions are synchronized - scrolling, other things and the code that we execute in the long term.  That is, it all depends on this event loop. <br><br>  How to get into Event Loop frames? <br><br>  We have a cycle that turns with a certain frequency.  But we, as front-fenders, cannot control this frequency and do not know it.  We only have the opportunity to use ready-made, intended for us frames.  That is, we do not control the frequency, but we can fit into it.  For this, there is a requestAnimationFrame construction. <br><br>  If we pass the code to the callback requestAnimationFrame, then we get to the beginning of the next update frame.  Frames updates are different.  On the MAC, for example, these frames try to fit into 60 Fs, but the frequency is not always equal to 60 Fs.  Further on examples I will show it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/207/5cf/89c/2075cf89cdc88b5996cf0e8efcdfbc1d.png"><br><br>  We have already disassembled that at the core of Javascript is an infinite loop, which is updated with time.  Now we can assume where the brakes can arise from. <br><br>  There are frames that are updated over time.  We run some calculations on the site.  Any.  Everything we write in Javascript is actually computing.  If these calculations take longer than one visible update frame, the user sees lags. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee3/993/507/ee399350707cb7565b55b418ebcff711.png"><br><br>  That is, there is a series of consecutive frames, and then - some long calculation, which takes more than a frame.  The user sees a slight delay.  He is twitching animation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7a/f37/35b/d7af3735bd372df1b7d372c3781ad29f.png"><br><br>  Or the calculations may become too large, and then the page will freeze and nothing can be done with it. <br><br>  Ok, we understood what a brake is and why the site can slow down.  Now let's solve the problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/492/244/bfe/492244bfeb8e23a4b92526eb5c2ae46d.png"><br><br>  We are programmers, so we have the tools that run our code.  The main task of the programmer is to properly distribute the load balance between the processor and memory. <br>  We all know what a processor is.  This is a device in a computer that is responsible for instantaneous calculations.  That is, any command that we write is converted into an instruction for the processor, and it will execute this command. <br><br>  But if there is a sequence of commands that leads to some great result (let's say we calculated a complex value), but we don‚Äôt want to repeat this sequence - we can write the result of this command in memory and use another processor instruction called reading from memory . <br><br>  I just wanted to talk about it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/7a6/183/cb77a61835cac31f5fc563cc45650820.png"><br><br>  The first optimization, which seems logical, is to use memory in order not to use calculations. <br><br>  In principle, this strategy sounds advantageous.  Moreover, it is a good strategy and it is already in use. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a51/1cb/c6a/a511cbc6a314a71da728c86818e24860.png"><br><br>  For example, Javascript has a built-in Math object, which is designed to work with mathematics and calculations.  This object contains not only methods, but also some counted popular values ‚Äã‚Äã- so as not to recalculate them.  For example, as in the case of the number œÄ, which is stored up to a certain sign. <br><br>  Secondly, there is a good example about the old days.  I love programmers of the 80s because they wrote effective solutions.  The iron was weak, and they had to come up with some good stuff. <br><br>  In 3D shooters, trigonometry is always used: in order to count distances and sines, cosines, and other such things.  From the point of view of a computer, this is also a rather expensive operation. <br><br>  Previously, programmers at the compilation stage shoved tables of sines and cosines directly into the program code.  That is, they used the already calculated values ‚Äã‚Äãof trigonometric functions.  Instead of counting them for rendering the scene, they took them as constants. <br>  Thus you can optimize everything in the world.  You can pre-calculate the animation - how it will look, and do anything. <br><br>  In principle, it sounds very cool. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d5/4fd/2a3/4d54fd2a35a52a9fbfd908217ca637a1.png"><br><br>  Look, here are the frames, and instead of starting calculations that take several frames, we run calculations that only deal with reading: read the finished value, substitute, use.  And it turns out that the interface is very fast. <br>  Theoretically it sounds very cool.  But let's think about how exactly frontenders work with memory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/107/b37/3bf/107b373bf185512f6b40987f2b251191.png"><br><br>  When we open a browser tab, we are allocated a certain amount of memory.  By the way, we also don't know him.  In this we are also limited. <br><br>  But what's more, we cannot control this memory. <br><br>  There is another feature - something is already stored in this memory: <br><br><ol><li>  This memory stores the wound-time of the language: all constructors, all functions.  The language itself is stored in memory; <br></li><li>  You also use some data: download something from Ajax, generate some kind of structure; <br></li><li>  You have a DOM tree, and it also gets into memory, because Javascript cannot read HTML, and the browser converts the markup for it into a set of objects, into a tree.  In the memory of the browser, the tab gets everything that is in the markup, including all the tags in the form of each individual object.  Fall texts. <br></li></ol><br>  That is, for each transfer that stands between the tags, a browser memory object is created, like text-mode, and it hangs. <br>  We see that we have a lot of everything in our memory anyway, but at the same time we want to write something of our own there.  This is dangerous enough because memory can start to slow down. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14b/fc6/f0e/14bfc6f0ec94ae1cf9467bcdf4b125a5.png"><br><br>  There are two main reasons - and, oddly enough, they contradict each other.  The first is called ‚ÄúGarbage Collection‚Äù, and the second is ‚ÄúLack of Garbage Collection.‚Äù <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f5/dfb/290/7f5dfb2906921a461d3d0428dd8b5ae1.png"><br><br>  Let us examine each of them. <br><br>  Before I explain what garbage collection is, I‚Äôll tell you how we will look at work in terms of performance, memory, and everything else. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30d/b98/5d5/30db985d57c335ee2c9b2490910e95af.png"><br><br>  The fact is that all these things can be measured.  In any browser there are developer tools.  I‚Äôll show Chrome as an example, but in other browsers it‚Äôs also there.  We will look at the ‚ÄúProfiling‚Äù or ‚ÄúPerfomance‚Äù tab. <br><br>  It can be opened and measured at any time by a so-called browser performance snapshot.  Click on the button "Record / write."  Performance is being recorded, and after a while you can look at what was happening on the page and how it affected your memory and processor. <br><br>  What does this tab consist of? <br><br><ul><li>  Firstly, there is a timeline above that shows seconds, that is, the lifetime of the tab. <br></li><li>  Fps - the frame rate that was at that time; <br></li><li>  Processor load - on the joint graph it shows different calculations; <br></li><li>  Screenshots  You can not show them, by the way.  I advise you to disable them, because if you record a performance profile with screenshots enabled, you are guaranteed to lose Fps.  That is, if you need to calculate Fps, turn off the screenshots just in case. <br></li><li>  Memory.  This is the lowest chart. <br></li><li>  Detailed statistics of the same information that we see above.  That is, profilers can be increased at any moment and see exactly in frames what was happening.  We can even increase to the frame and see what operations were performed on it - even with links to the code. <br></li></ul><br>  So, we will measure this performance on Instagram with cats.  Everyone loves cats, everyone loves Instagram - so I decided to do so. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ce/ab6/f60/1ceab6f6054c434d1e3a580d7a2bc98c.png"><br><br>  Seals are not many, so we will look at the big pages.  We will have five pages with 5,000 cats, and we will learn how to switch them. <br><br>  Below is the code with which I generate the seals.  They are all unique. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e4/566/f29/8e4566f29d939f0f5b04ba4161855265.png"><br><br>  That is, I create a DOM element from some standard template and fill it with unique data.  Even where the pictures are repeated, I use the template: so that there is no caching and the memory test is clean. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/c20/41f/69ec2041f3f28a7c301bcb1d031fbd2f.png"><br><br>  When I create all the elements, I add them to one fragment - this is also an optimization that you all know.  To clean the pages, I‚Äôll just be - bald bombs!  - clean the container. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efc/78d/274/efc78d274088cff8afe28c0021782f3b.png"><br><br>  It works faster. <br><br>  So, garbage collection. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e7e/b0d/257/e7eb0d25754f8a1c7a2ee05ca69a07ed.png"><br><br>  Garbage collection is a process that is designed to optimize memory management.  He is not controlled by us.  The browser itself starts it when it realizes that the memory allocated for this tab is running out and you need to delete old unused objects. <br><br>  Old unused objects are objects that are no longer referenced.  That is, these are objects that are not written into variables, into objects, into arrays - in general, nowhere. <br><br>  It would seem, yes, this is a cool process, we need garbage collection, because the memory is really limited and needs to be freed. <br><br>  Why can this be a problem?  Because we don‚Äôt know how long garbage collection will take, and we don‚Äôt know when it will happen. <br><br>  Let's look at an example. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb9/f56/08f/bb9f5608f0d6b83e617a44d7d5af8fc1.png"><br><br>  Here I recorded a timeline profile of switching our pages with cats.  On the top graph, there are spikes in processor performance ‚Äî CPU utilization. <br><br>  In the lower graph, you can see that first the memory goes up - this is a graph of memory usage - and then a step down.  This is precisely the process of garbage collection. <br><br>  I had enough memory for the first two pages, and I drew 10,000 cats.  Then the memory is over and, in order to render another 5,000 cats, I deleted the old ones, because they are no longer used. <br><br>  Basically, it's cool.  Indeed, the browser took care of me and deleted what I do not use.  What is the problem? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e4/131/9cf/3e41319cfa2c8b240fcae1f6ebe94371.png"><br><br>  Let's bite our time, as I usually say, down this leap, and see how long the garbage collection process took. <br><br>  If you add 4 entries to garbadge collecting, you can see that the garbage collection process took 134 ms - this is 10 frames at 60 Fps. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb3/945/a2c/bb3945a2c34f6f45666781c57cb8777c.png"><br><br>  That is, if you wanted to move the block by 600 Ps for a certain time, then you would have lost the move to 100 Ps simply due to the fact that the browser decided to clean the memory.  You do not control the onset of this process, nor the duration.  This is bad. <br><br><blockquote>  Memory leak is a situation where some unused objects remain in memory during garbage collection, because the garbage collector thinks they can be used. </blockquote><br>  The second problem is exactly the opposite of the first.  It is called a memory leak. <br><br>  It would seem that the browser is so inconsistent: it needs to clean the memory for a long time, and not to clear the memory for a long time.  Why? <br><br>  A memory leak is a process where there is no such garbage collection.  That is, even it may be happening, but does not clean what we need.  Sometimes we can throw something in such a way - and, looking at it, the browser engine will understand that it cannot clean it. <br><br>  Let's look at code example. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/749/042/9f0/7490429f0d82159574f7182b4b6cc304.png"><br><br>  There is the same page switching, but every time I insert new elements on the page, I add a handler to each photo. <br><br>  Suppose I need to press the spacebar.  I hung up just in case for a document handler so that Keydo would not disappear anywhere.  What happens in this case? <br><br>  When I clean the container by removing HTML, I will remove the DOM nodes from the DOM tree.  But the handlers on the document will remain, because the document will remain on the page.  Nothing will happen to him.  When garbage collection takes place, the garbage collector will not remove these handlers. <br>  Let's see what is written inside these handlers? <br><br>  Inside these handlers, a node is used.  It turns out that the nodes will not be deleted from memory, because they are referenced.  This is called a memory leak.  From the point of view of logic, neither Iods nor handlers are needed.  But the collector does not know about it, because from his point of view they are used. <br><br>  What happens in this case?  Let's look at the schedule. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ee/600/230/9ee60023089338228090f8e1c3e2cc93.png"><br><br>  From the waves that rise and fall, the schedule turned into a ladder that grows upward.  With each page switch, memory is used more and more - but it is not cleaned, since handlers and nodes remain in memory. <br><br>  Memory is not released.  The computer also starts to slow down. <br><br>  Why?  Because a big memory is very bad.  The processor will be clogged when performing operations on a large DOM. <br><br>  The result is that when we try to optimize something with memory, we get a big risk. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f13/034/972/f130349727beab66fb03714c50b85836.png"><br><br>  Brendan Ike himself, who created Javascript, in a recent interview (WebAssembly) said: ‚ÄúJavascript is a good language.  It is fast and in terms of performance can sometimes be with C, but the problem starts when garbage collection occurs, because we do not know when the collector will come to us and how long it will work. ‚Äù <br><br><blockquote>  <b>Memory is unreliable</b> <br>  Brakes associated with memory can occur when writing values ‚Äã‚Äãto it, and when it is automatically cleaned.  Predicting the moment of occurrence of brakes is very difficult. <br></blockquote><br>  It turns out that memory optimizations - maybe good - but not reliable, because sometimes they can lose productivity and things will go badly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c23/fcc/797/c23fcc797905b81581ebc8cf52605a0c.png"><br><br>  So let's look at the other side of the picture, which I showed: how to optimize the speed of the application from the point of view of the processor - the main computing device. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/646/f06/8dc/646f068dc68b7acbc8cb4e3f5050b3c3.png"><br><br>  There are three main ways to speed up the processor: <br><br><ol><li>  Reduce the amount of computation; <br></li><li>  To shuffle - I'll explain later what it is; <br></li><li>  Do not use the processor.  This is also rather strange, but a good way to optimize the processor. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/0ee/3de/f2b/0ee3def2bc897340f43f863adffa686f.png"><br><br>  Let's look at our picture with cats. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f3/f60/b62/6f3f60b62ed8e1a8cf693f5d21e02805.png"><br><br>  I said that I had five pages of 5,000 seals.  In principle, this, by the way, is real volume.  You can scroll for 0.5 minutes of these cats, and you will have a DOM of 5,000 items. <br><br>  But if you think about it - it is not necessary for the first boot.  We now see four rows and five columns of cats.  These are 20 cats.  It turns out that the user, opening the page for the first time, sees 20 cats, and not all 5,000 pictures. <br><br>  And the browser renders 5 000. It turns out that we draw a lot of excess.  Why draw 5,000 cats, if we show 20? <br><br>  Well, we can even make a start - the user can scroll the site and he also needs to show something.  But if you draw 100 cats, it will already be 5 screens. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/383/217/2c2/3832172c25e831b51952dea7d0015b4d.png"><br><br>  Therefore, the first thing you can do is reduce the volume of the DOM.  This is the easiest way.  You reduce the DOM, and everything works faster. <br><br>  Let me prove it to you from the profiler point of view. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/01c/93f/40b01c93f409417052342600e632ba81.png"><br><br>  I draw the first page on 5,000 elements and use the profiler to record the loading process.  By the way, there is a ‚ÄúReload‚Äù button, and if you click on it, the profiler will record the page loading speed.  It will reload it and when the page is completely rendered and everything is ready, it will stop recording this screenshot and 5,000 seals will be rendered in four seconds. <br><br>  And here I recorded screenshots.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The user sees the first seals at the end of these four seconds. A little earlier, somewhere at the end of the third second, image wrappers appear. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b73/5a4/a2d/b735a4a2de5edcf187e9596630ec7ce5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you reduce the page to 100 elements (up to five screens), then the download will take only 0.5 seconds. Moreover, the user will immediately see the finished result - without wrappers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the first step is to reduce the amount of computation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second point is trotting. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b4/f9e/d27/4b4f9ed27ed0e029fbecd32dc3bf5979.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is trotting? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine that you have a certain frame rate and it does not fit into the frame rate that we chose. We have already talked about this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotling is a way of thinking when we take a step back and try to understand, do we really need the refresh rate that we have?</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/f5e/703/c88f5e703cdab4e196230ed3148ab0a9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose it is 60 Fps, and operations are performed with this frequency. But the calculations take more than 16.5 ms. And here you need to think - do you really need to enter these calculations in 16.5 ms? If not, then we can arrange the frequency to the desired one.</font></font><br><br>  Let's take an example.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have just optimized cats and we‚Äôre showing not 5,000 cats, but 100. Let's change the way the user interacts with these cats. We will not show large pages at once, we will show cats as needed. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3c/631/daa/b3c631daa8118cccb3f13bf362c930e6.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this you need a dynamic scroll. We scroll, reach the bottom, show the next page. Here the code is about that. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But I added some statistics to this code. I recorded the delta in pixels - how often the scroll event is triggered by me, and the counter of total scroll events. When I scrolled the page from top to bottom, at its height of 1,000 ps, ‚Äã‚Äãthe scroll event triggered every four. From top to bottom there were 500 checks.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b74/f40/3fd/b74f403fd64b7604dd3699e260f07211.png"><br><br>  Why so much?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because the scroll happens just at 60 Fps - the very one. And yesterday, LG showed an Ipad with a screen frequency of 120 Hz, which means that they will now try to make 120 Fps, and not 60. And here it will be necessary to think even more about it. Remember the donkey from the cartoon about Shrek, who asked ‚ÄúWe have already arrived? Have we arrived yet? ‚Äù- my check behaves the same way. She works too often and obsessively. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotling is to order the number of frames. I do not need to check every 4 ps before scrolling the bottom of the page. I can do this, say, 1 time in 100 ms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I added a small check based on dates. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ac/158/19a/4ac15819a588706e7ebb3126f7d4a846.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I look at how much time has passed since the last check, and run the next one.</font></font> What is the point?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The scroll event continues to occur, but I do not use all the scroll frames, but only some of them - those that fall under my conditions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When I used 100 ms, the check was performed every 20-30 ps, ‚Äã‚Äãand only 100 checks occurred from top to bottom. </font><font style="vertical-align: inherit;">In principle, this is normal - once in 100 ps ask if we are downstairs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the second way to calculate. </font><font style="vertical-align: inherit;">Check frame rate. </font><font style="vertical-align: inherit;">Maybe for a specific task you do not need 60 Fps and you can reduce it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third way is to give calculations. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9a/12d/88a/d9a12d88a827fe23935448d90b93435c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How can I give calculations from the processor?</font></font> There are several options: <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can give some calculations on the video card. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Some calculations can be given to the server; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can give the calculation to another thread. </font><font style="vertical-align: inherit;">This will not unload the user's processor - but it will unload the process that is open in the tab.</font></font><br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider each of these methods. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9d/95c/cf9/e9d95ccf9799b0431149649669f7a6c7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin with, I‚Äôll tell you why browser games are not made on SVG, but on anvas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Browser games are a thing in which there are so many </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disposable</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elements </font><font style="vertical-align: inherit;">that you throw out. You create them and throw them out, create them and throw them out. In such cases, when there is a complex interaction and a large number of small elements that are not long playing, it makes sense to use anvas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider a comparison of the ideology of SVG and anvas. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e57/fd9/cd2/e57fd9cd2629e7cee2dd99612efb29e6.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Under SVG, when you draw something, you need a DOM element. SVG is the DOM. You describe the format as markup, but, as we have already figured out, all the markup falls into JS as a DOM tree ‚Äî as an object, for example, with a class list or with all other properties.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you write on canvas, you simply operate on pixels. You have methods that describe the interaction with canvas. The result is pixels on the screen - and nothing more. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, on canvas we have to invent our own data structures - since there is no DOM tree, which was invented for us by someone. But then it may be slightly better for solving problems than the structures that SVG offers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once SVG has some kind of standard structure, it has an API. That is, you can do any interactions with SVG, for example, update one by one, animate.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On sanvas all this can not be done. You have to write everything by hand, as in assembly language. But then you can get a performance boost. After all, SVG is a DOM, and it will be considered on the processor, and pixel drawing will be on the video card. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at an example of why we rotate the Earth a little. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b61/98b/a8e/b6198ba8ea1c1da47a2e0aa1023e7118.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, the resolution is ridiculous in modern times - 800x600 - nothing at all. The Land that you see is vector graphics. All countries are described through one complex path. I did not draw each country separately as an object. They are all laid in one line of a certain shape. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will update the frames via </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requestAnimationFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . That is, the browser itself will tell me what my Fps is for drawing this thing. He himself will understand how much he can draw 1 frame.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an animation, I will rotate the Earth through 360 ¬∞ - from London to London. It was easier to write this way - I need to pass 0 to the array, because this is the London coordinate. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f4/c5f/013/7f4c5f0130632faf909160bbd0eb1c47.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I recorded the work profile of the canvas. First, look at the bottom chart. Only GPU is used here. That is only a video card for animation. There is nothing higher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is where the Main tab is involved. This is the work of the processor itself in changing the array of the number 0 by the number 360 and miscalculation of this contour depending on the angle - it multiplies the known coordinates of the countries by the formula of their projection on the circle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further only the video card is used.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end, I ran a few tests, and it turned out that on average, the animation lasts six seconds. With the help of simple calculations ‚Äî 360 ¬∞ in 60 seconds ‚Äî 60 Fps is obtained ‚Äî all is well. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b5e/fe9/1fb/b5efe91fb7f77468b848b9caaf1350c1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But SVG managed a little worse.</font></font> Why?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because if you look at the last two lines, we will see a completed Raster tab. This means that SVG created a DOM object for each frame, calculated all its parameters completely using the processor, not using the GPU, and using the video card already rendered it in the form of pixels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, first a DOM object that is long and difficult to compute, then pixels on the screen. This is quite seriously squandered performance. It took about eight seconds, and this is about 45 Fps. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I circled 45 Fps in a red frame, because this is what is called beyond the shame. You say, ‚ÄúWhat are you saying? There are even movies that run at 24 Fps. ‚Äù</font></font><br><br>  Not true.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even films that were recorded at 24 Fps at the dawn of cinema were shown at 48 Fps. This concept is explained to us by Thomas Edison: ‚ÄúYes, a person will see 24 Fps movement, but he will see flickering from updating the image‚Äù. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/9e0/a25/0529e0a25d89d617ec435185f2253937.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, he will see a moving picture, while noticing flicker. To prevent this from happening, you need at least 48 Fps. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, in old films each frame was shown twice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, even at the dawn of cinema, films were shown at 48 Fps. But SVG failed, failed the performance test, and this is bad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, it turns out that in certain cases sanvas is better than SVG. For example, if you have many such disposable elements that need to be thrown out, it is better to use sanvas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another test.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a30/bec/473/a30bec473e4f2c0682512af5a0a11cd4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When I was preparing and chasing away all the code samples, I accidentally forgot one line - clearing the previous frame. I got such a strange picture. I decided not just to get rid of this bug, but to see where my mistake would lead me, and measured the performance of this thing. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc9/99b/6ee/cc999b6eecd12bae9a00337513c79795.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When I measured the performance of the earth‚Äôs revolution on canvas without cleaning canvas, I got 60 Fps. I rechecked five times if I had the wrong picture. 60 Fps - and do not care about canvas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How do you think SVG did it? </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab8/854/564/ab8854564af56ed689652ac8b4b69657.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full animation took 24 minutes! He didn‚Äôt clean anything and a classic leak occurred. Memory grew and grew. I wanted to show the profiler, but for the first time I saw the window of death on the profiler. This is generally very strange. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To explain what happened, I'll show the profiler on a regular SVG.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6d/bec/10f/d6dbec10f18035f7d6b144aa436a8864.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory is used below, and every two seconds it is clogged, then cleaned and clogged again. Now put this ladder one on top of another and imagine what happened at the end of 24 minutes, when I managed to drink tea, go somewhere. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, if you have a lot of disposable-elements, there is a complex graphics and non-trivial interaction, it is better to use sanvas. It is unlikely that someone will describe the dust particles flying from the tree into which the fireball fell, as a DOM node, each of which has a class list. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No, better canvas. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9d/ae4/800/f9dae4800444278845a44de5fa79f325.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another calculation method is to transfer the calculations to the server. We just said that canvas have good and fast graphics. But somehow I had a task to draw a heatmap over the city: how often do restaurants meet there?</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d81/40e/3b2/d8140e3b2d43d883db3ddb65bcf258e3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I thought: graphics? </font><font style="vertical-align: inherit;">Graphics. </font><font style="vertical-align: inherit;">SVG is not suitable, because the update step is 1ps, that is, each pixel means something to me. </font><font style="vertical-align: inherit;">Therefore, there must be sanvas. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b5/0d0/26e/9b50d026e2004b960ab3d95260ccbc7d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I solved this task on anvas. </font><font style="vertical-align: inherit;">The data structure came, I walked along it, put a dot on the map, which had a certain saturation color.</font></font><br><br>  What happened?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In fact, I didn‚Äôt like the solution much because: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I had to write a lot of crutches. </font><font style="vertical-align: inherit;">Canvas is almost a graphical assembler, it has a fairly low level API and had to manually work with each pixel.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I had to run a lot of calculations, and the user saw the same thing. </font><font style="vertical-align: inherit;">That is, when the user slightly shifted the map - I recounted all over again.</font></font><img src="https://habrastorage.org/getpro/habr/post_images/df0/e9f/a2e/df0e9fa2ef71e33e3cfc99f1994d6eec.png"><br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then I thought: ‚ÄúWell, I‚Äôm a smart developer, I solved an awesomely difficult task - I drew a heat map, but it‚Äôs worth thinking about the user and don‚Äôt work, but simply: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> come to the backend, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which has python </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beautiful library for working with graphics, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which gives me static pictures, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and they are not mine </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and also cached. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, instead of loading the user's processor with his vanity, I went to the backend and asked me to generate pictures, that is, to load the processor of the backend computer that was designed for this. The user processor was loaded only by reading pictures from the cache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you know, the pictures have another advantage - they do not need to be recalculated every time. They are remembered and drawn - all is well. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/801/867/8af/8018678af7bb2577aeb4aae2ba720d9c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third way is to give in a parallel stream. In fact, this is a fairly new way for the frontend, because the guys who write in other languages ‚Äã‚Äãusually talked about this.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at the task. There is an editor, for example, Ace. Since this is a fully client-side editor, the client side is responsible for such basic things as blinking the cursor, scrolling, moving the cursor, and so on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But besides this, you need to highlight the code or say: ‚ÄúDude, you wrote the wrong operator in the wrong place‚Äù - and break it all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To say that the user wrote the wrong operator in the wrong place, you need to build an ST-tree, run through it, analyze it and so on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What did the Ace developers do? They said: ‚ÄúIn the mainstream we leave the main one. Let the cursor blink and go, and the screen scrolls. This will occur without delay. User will be satisfied. And we‚Äôll give all the remaining extras to the Worker. ‚Äù</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a tool that allows you to run Javascript file in a separate browser thread and avoid unnecessary expense of performance - for example, to build a tree. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is one limitation. </font><font style="vertical-align: inherit;">In the Worker service, you should not give up work with DOM. </font><font style="vertical-align: inherit;">That is, with DOM you are working in your thread, and you give complex calculations in parallel. </font><font style="vertical-align: inherit;">This will increase the performance of your frontend.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e0/ac5/a01/8e0ac5a0156d260dd1157b8b5c3ee273.png"><br><br>  To summarize<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How can I give calculations from a practical point of view? </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you are doing a visualization on D3, and it is complicated (there is such a thing - gravity. For example, you built a tree, and the more node it has, the stronger it attracts the node, and this is all animated) - it‚Äôs better to do it on anvas, don't do it on svg. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many server requests are not always bad. </font><font style="vertical-align: inherit;">This can be good if the user sees the interface faster.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Non-interactive overlay on Google maps - picture. </font><font style="vertical-align: inherit;">It is just a law.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you can count something in a parallel thread, do it. </font></font><img src="https://habrastorage.org/getpro/habr/post_images/7a3/902/a4d/7a3902a4daff0f165af8ed8d0ca170bd.png"><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have long been telling how to optimize and reduce computations. </font><font style="vertical-align: inherit;">But sometimes this can not be done. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, no real server on the Internet will answer me faster than 100 ms. </font><font style="vertical-align: inherit;">I can't do anything about it. </font><font style="vertical-align: inherit;">Even if I have a super-beautiful interface that is thought out to the smallest detail, all calculations are optimized, there will still be delays and users will be able to see the lags. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What to do with delays?</font></font> There are two ways: <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use transparent feedback, that is, show the user that "yes, I know that there is a delay, and this is normal." </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A little deceive user. </font></font><br></li></ol><br>  Now I will tell you how this is done. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f5/aa4/c49/7f5aa4c493395420cc0bfd3913abf681.png"><br><br>  Consider the correct feedback.  Let's go back to Instagram with cats and add some interaction. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b41/527/2cd/b415272cd2a707aef146e423bad33924.png"><br><br>  There is a cat, and the user wants to like him.  He brings the mouse, clicks on the asterisk, I show - yes, you liked, you're great!  There are more likes!  But this is not true.  Like is not like while it is not like on the server. <br><br>  Sometimes servers sometimes have this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/20d/e5e/fa9/20de5efa9b9b402bafbcc1b88f05b7cc.png"><br><br>  What do all developers do in this case? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/676/e38/08f/676e3808fa203d2f980927ed9dbc573f.png"><br><br>  No one makes any transparent feedback. <br><br>  How to do?  I'm not saying that you need to forget about the Optimistic UI, but showing the direction.  If the user has clicked on something, and the result is not instantaneous, you need to show it, for example, you can even highlight this asterisk.  At least show: ‚ÄúWait.  Yes, we understood that you clicked, but not everything is ready yet. ‚Äù <br><br>  When something goes wrong, it also needs a separate status.  That is, we need to be transparent and show the user what is happening.  As I said, we are responsible for the user's impression of the site.  And he is not a fool that did not understand what displays him in the console. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/884/053/0f2/8840530f2fe0cf4577ba74220cb7a03f.png"><br><br>  When I was preparing for this report, I called my mother and told her what I would talk about.  She told me a joke: <br><br>  - Why did you bring me 10 pizzas?  I ordered 1. <br>  - Yes, you ordered 1, but the button was pressed 10 times <br><br>  It seems like a stupid joke, but I meet with that.  Sometimes I write comments, press a button - and even the button does not bend, nothing happens.  I think - buggy, or what?  You need to click again. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f5/105/c5a/3f5105c5a60440b61a1d7d706872504a.png"><br><br>  But in fact, everything happened, the request went to the server (both requests went to the server), and both comments were drawn.  And users do not like when they see 2 identical comments. <br>  For some reason it is considered that I am guilty, although in fact the programmer is to blame.  It was possible to simply show the feedback - yes, no longer press this button, please.  We understood that you pressed it. <br><br>  When the answer came, you can even reset the content, and the user intuitively understands that you can enter another message. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de4/dc2/857/de4dc2857f3fce3460a4b36f4aa17249.png"><br><br>  At the development stage, it does not cost anything at all, but the interface will get better, the delay is more transparent.  The user will not be offended.  He knows that you need to go to the server.  As Louis C. Key said, ‚ÄúWait!  It flies into space! ‚ÄùWhile you complain that my site does not show in a second. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dac/042/bc0/dac042bc0144d16ea36f42870d20f0a6.png"><br><br>  The second way - you can slightly deceive the user. <br><br>  For example, when the guys developed Macintosh back in 1982 or in 1987, I don‚Äôt remember exactly, they had very weak hardware, because Apple had the task to fit in a certain price to make the computer affordable.  And they had to come up with interesting solutions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f36/dd2/c6e/f36dd2c6ed8d327e257d62a6bbcc931a.png"><br><br>  Jeff Raskin, who designed the first version of the Mac OS interface, came up with the following.  It is clear that the computer can not turn on instantly and immediately show the working screen.  Therefore, they photographed the last state of the screen before shutting down, recorded the picture on the zero track of the disk and, when the computer turned on, showed it. <br><br>  Why did this work?  Because a person needs seconds to switch the context.  That is, when we talk about Fps, professional pilots see 270 Fps.  But when people switch the context between tasks, it takes a few seconds to realize what is happening. <br><br>  When the guys from Mac OS showed the picture, people looked and thought: ‚ÄúYes, something happened here, something changed.‚Äù  As long as you understand what has happened, a real screen will be shown to you. <br>  This solution turned out to be so good that it still works on a Mac.  For example, when you turn on the MacBook, you see that the WI-FI indicator is already on full.  And after two seconds, he begins to search the network. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/240/6a0/0a0/2406a00a009569474c2c9fea186e8270.png"><br><br>  The second method, which follows from the first, is a cropped screenshot.  It is called Skeleton Screens.  This thing came up with Google Images. <br><br>  They had the same task, which we talked about a little earlier, - that if we show not all the pictures, but the user will scroll. <br><br>  They thought - we can't show all the pictures at once, but we can promise the user that there will be a picture.  And drew a gray block the size of the picture.  When the user stops, it shows the real picture.  When the user scrolls and sees gray blocks, he believes in it intuitively - well, yes, the picture did not have time to load, and this is normal. <br><br>  It can also be used, and it is good. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c9/27c/961/1c927c961272b72f17e2fba048d1e8c4.png"><br><br>  Summarize.  What to do if the site slows down? <br><br><ul><li>  Start with the processor, that is, improve your computing process: <br>  - Reduce memory, do not clog it, do small operations. <br>  - Check if you do these calculations too often. <br>  - Unload the processor, give complex algorithms to the backend, despite the fact that you are handsome and can write it. <br></li><li>  Add the correct feedback to the interface so that the user understands that, yes, the calculations are in progress, but this is normal. <br></li><li>  And after that, I wish you good luck in memory optimization. <br></li></ul><br><br><hr><br>  If you need more details on this topic, we have prepared a transcript of the speaker's answers to questions from the audience. <br><br><div class="spoiler">  <b class="spoiler_title">All under the spoiler</b> <div class="spoiler_text">  <b>- Workers seem to serialize / deserialize when data is sent to them.</b>  <b>We had such a situation with complex calculations.</b>  <b>We considered how many points on the chart a person has, how many came from the server, and it all was merzh.</b>  <b>When we moved everything to Worker, it became more inhibited.</b>  <b>And while we can not bring all this logic to the server - because he, too, begins to blunt.</b> <b><br><br></b>  <b>As a result, when loading the page there is a small lag.</b>  <b>We somehow decorated it, but, nevertheless, it is still there.</b>  <b>How can you deal with such situations?</b>  <b>Something to offer?</b> <br><br>  - The first thing that comes to mind is the very way to show the spinner that now something is considered, this is normal.  Secondly, the task is set in a general form and I cannot give a concrete solution, but I would look at what kind of data comes from the server.  Maybe there are too many of them. <br><br>  <b>- A thousand points with some data.</b> <br><br>  - Maybe it makes sense to thin out the data, show them less, if there is such an opportunity. <br><br>  <b>- Is that at some old retrospective thin out.</b>  <b>Option, by the way, thanks.</b> <br><br>  - Yes, first download less data, and then, as necessary, load a larger amount of data, and then it will work a little faster. <br><br>  <b>- There was an example about scrolling and about subtracting TimeOut, there was, I think, there was.</b>  <b>Will there be a worse solution if you use Windows TimeOut and Clear?</b>  <b>That is, we will check it once.</b> <br><br>  - This is a popular misconception that trotl is Windows TimeOut.  I do not remember who invented this, one of the big guys, it seems, Zakas.  In fact, this debounce is a slightly different operation.  Throttle is when calculations occur frequently, and we take only a fraction of them, but with an equal period of time.  That is, Throttle is when I have something executed guaranteed every 100 ms.  And the example with TimeOut will not work once every 100 ms.  The stack will be filled, and then, when it passes 100 ms, it will be executed. <br><br>  This is a good thing.  It is called debounce.  It also helps, for example, when the user enters something, you do not need to use Throttle to use and show a subject as you type, it is better to do this debounce when he entered it. <br><br>  <b>- I would like to clarify something about optimization on the processor.</b>  <b>Nothing was said about making the layers.</b>  <b>But it also allows you to save time on animations, transfer calculations to a graphics processor ‚Äî transfer exactly that image that you just need to draw at different points in time in different places.</b> <br><br>  - Will the change mean?  Yes I agree.  Simply, I rather talked about the code, the code, and Will-change - this is a declarative API, HTML more refers to markup. <br><br>  <b>- Anyway, optimization too.</b>  <b>And the second question is about the processor.</b>  <b>What about those poor browser users where service workers are not supported?</b>  <b>If we in our application are not tied to the fact that we throw some heavyweight calculations there, we are significantly limited in support.</b> <br><br>  - I also really like such a thing as task prioritization.  For example, React Fiber uses this. <br><br>  They collect all the tasks of updating the interface that they need, and perform them in order of priority - first important from the point of view of rendering, then - not so much.  And if we do not have a service worker, but we need to somehow distribute everything, we can gather a pool of tasks and do them the same way, depending on priority. <br><br>  React Fiber does it under the hood, it's cool. <br><br>  <b>- I understand that this is something in the spirit of approximate rendering, at first, more coarse, then more detailed?</b> <br><br>  - This is a very crude simplification, but something like this. <br><br>  <b>- I have a question about the DOM SVG animation.</b>  <b>Did you try to use lstgs sub, for example, did you run some tests, and how much faster was it?</b>  <b>This is a project that aims to improve the performance of the animation exactly DOM'a.</b> <br><br>  - No, I showed all hardcore, iron.  The animation is all hand written. <br><br>  <b>- It would be interesting to see such tests.</b> <br><br>  - In terms of tools?  This is a good idea, I will think.  I have already said that I have a website and maybe I will try it in time. <br><br>  <b>- They just say that they can immediately animate a lot of nodes without any lags, and they have tests.</b>  <b>Interesting.</b> <br><br>  - I agree with you, but, you know, after all there under the hood is the same thing that I just said.  You need to understand the direction to go.  If you understand that these libraries use this, that is good, and it will help.  I agree? <br></div></div><br>  We are also in a hurry to announce that we have opened <a href="https://www.youtube.com/watch%3Fv%3D2DtMxHnMUYQ%26list%3DPLH-XmS0lSi_zf4qPxvWDmMkf4foWonrH7">access to all video recordings of performances from Frontend Conf 2017</a> .  There are almost three dozen of them. <br><br>  At the same time, we invite pros to become speakers at our May RIT ++ conference festival.  If you have an interesting development experience and you are ready to share it, <a href="http://speakers.ritfest.ru/">leave a request</a> for our program committee. <br><br></div><p>Source: <a href="https://habr.com/ru/post/345498/">https://habr.com/ru/post/345498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345488/index.html">What is the difference between React and Vue?</a></li>
<li><a href="../345490/index.html">We are launching a new online course ‚ÄúWeb Services Development on Go‚Äù</a></li>
<li><a href="../345492/index.html">Non convolutional networks</a></li>
<li><a href="../345494/index.html">xss vulnerability</a></li>
<li><a href="../345496/index.html">As I asked students to write phishing emails</a></li>
<li><a href="../345500/index.html">Generative design: on the threshold of a new design era</a></li>
<li><a href="../345502/index.html">Monitoring SMART HDD - windows + python + zabbix</a></li>
<li><a href="../345504/index.html">Five safety rules for holiday trips</a></li>
<li><a href="../345506/index.html">We introduce mandatory verification of customers</a></li>
<li><a href="../345508/index.html">Analysis of publications on Habrahabr for 2017. Statistics, useful finds and ratings</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>