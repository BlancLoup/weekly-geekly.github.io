<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thoughts about programming in assembler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After many years of doing something without falling, I decided to return to basics. To programming. Again, in view of the many ‚Äúmodern achievements‚Äù i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thoughts about programming in assembler</h1><div class="post__text post__text-html js-mediator-article">  After many years of doing something without falling, I decided to return to basics.  To programming.  Again, in view of the many ‚Äúmodern achievements‚Äù in this area, it was difficult to decide what is really not enough, what to undertake in order to be both pleasant and useful.  Having tried a lot of things little by little, I decided to go back to where I was drawn from the first days of my acquaintance with a computer (even with a copy of Sir Sinclair‚Äôs work) - to programming in assembler.  In fact, at one time I knew the Assembler quite well (in this case, talking about x86), but for almost 15 years I have not written anything on it.  Thus, it is a kind of return of the "prodigal son." <br>  But then the first disappointment awaited.  To my deep regret, books, manuals and other assembler references found on the Internet contain minimal information on how to program in assembler, why it is so, and what it does. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">An example from another area</b> <div class="spoiler_text">  If we take boxing as an example, then all such manuals teach you to execute a punch, to move while standing on the floor, but absolutely what boxing does is boxing, and not ‚Äúpermitted muzzling.‚Äù  That is, combination work, features of the use of the ring, protective actions, tactical construction of the battle and, moreover, the strategy of the battle are not considered at all.  They taught a man to beat on a ‚Äúpear‚Äù and immediately to the ring.  This is fundamentally wrong.  But this is how almost all the ‚Äútextbooks‚Äù and ‚Äúmanuals‚Äù for programming in assembler are built. </div></div><br>  However, normal books should be, most likely under the mountain of "slag" I simply did not find them.  Therefore, before we fill in our knowledge with a global description of architecture, mnemonics and all sorts of tricks ‚Äúhow to make a fig with 2 fingers‚Äù, let us approach the issue of programming in an assembler from an ‚Äúideological‚Äù point of view. <br><br><h4>  Idyll </h4><br>  <i>A small note, hereinafter, a classification that differs from the one currently used will be used.</i>  <i>However, this is not the reason for the ‚Äúdebate about the color of truth,‚Äù it‚Äôs just easier in this form to explain the author‚Äôs point of view on programming.</i> <br><br>  So, today, it would seem, the era of happiness has arrived for programmers.  Huge selection of funds for all occasions and wishes.  There are millions of ‚Äúframeworks‚Äù / ‚Äúpatterns‚Äù / ‚Äútemplates‚Äù / ‚Äúlibraries‚Äù and thousands of tools that ‚Äúfacilitate‚Äù programming, hundreds of languages ‚Äã‚Äãand dialects, dozens of methodologies and various approaches to programming.  Take - I do not want.  But not "taken."  And the point is not in religious beliefs, but in the fact that all this looks like an attempt to eat something tasteless.  If desired, and zeal, you can adapt yourself to this, of course.  But, returning to programming, in the majority of the proposed technical beauty is not visible - only a lot of ‚Äúcrutches‚Äù are visible.  As a result, when using these "achievements", from under the "brush of artists" instead of fascinating landscapes, there is a solid "abstraction", or splints - if you are lucky.  Do most programmers are so mediocre, ignorant and have problems at the level of genetics?  No I do not think so.  So what is the reason? <br>  To date, there are many ideas and ways of programming.  Consider the most "trendy" of them. <br><ul><li>  Imperative programming - in this approach, the programmer sets the sequence of actions leading to the solution of the problem.  The basis is the division of the program into parts that perform logically independent operations (modules, functions, procedures).  But unlike the typed approach (see below), there is an important feature here ‚Äî the lack of ‚Äútyping‚Äù of variables.  In other words, the notion of ‚Äúvariable type‚Äù is missing; instead, it is understood that the values ‚Äã‚Äãof the same variable can have a different type.  Vivid representatives of this approach are Basic, REXX, MUMPS. </li><li>  Typed programming is a modification of imperative programming when the programmer and the system limit the possible values ‚Äã‚Äãof variables.  Of the most famous languages, it is Pascal, C. </li><li>  Functional programming is a more mathematical way of solving a problem when the solution consists in ‚Äúconstructing‚Äù a hierarchy of functions (and accordingly creating the missing ones), leading to the solution of the problem.  As examples: Lisp, Forth. </li><li>  Automata programming is an approach where the programmer builds a model / network consisting of messaging objects / actuators, both changing / storing their internal "state" and able to interact with the outside world.  In other words, this is what is commonly called "object programming" (not object-oriented).  This way of programming is presented in Smalltalk. </li></ul><br>  And how many other languages?  As a rule, these are already ‚Äúmutants‚Äù.  For example, the mixture of a typed and automaton approach gave ‚Äúobject-oriented programming‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As we see, each of the approaches (even without taking into account the limitations of specific implementations) imposes its own limitations on the programming technique itself.  But it cannot be otherwise.  Unfortunately, these restrictions are often created artificially to "maintain the purity of the idea."  As a result, the programmer has to ‚Äúdistort‚Äù the originally found solution into a form that at least somehow corresponds to the ideology of the language used or the ‚Äútemplate‚Äù used.  This is even without taking into account modern methods and methods of design and development. <br><br>  It would seem, programming in assembler, we are free to do everything in the way that we want and allows us to ‚Äúiron‚Äù.  But as soon as we want to use the ‚Äúuniversal driver‚Äù for any type of equipment, we are forced to change the freedom of ‚Äúcreativity‚Äù to the prescribed (standardized) approaches and ways to use the driver.  As soon as we need the opportunity to use the work of other colleagues or to give them the opportunity to do the same with the fruits of our work - we are forced to change the freedom to choose interaction between parts of the program in certain negotiated / standardized ways. <br><br>  Thus, the ‚Äúfreedom‚Äù that often breaks into an assembler often turns out to be a ‚Äúmyth.‚Äù  And this (understanding of limitations, and ways of organizing them), in my opinion, should be given increased attention.  The programmer must understand the reason for the restrictions being introduced, and that distinguishes the assembler from many high-level languages, be able to change them, if the need arises.  However, now an assembler programmer is forced to put up with the restrictions imposed by high-level languages, not having the gingerbreads available to programmers on them.  On the one hand, the operating systems provide a lot of functions already implemented, there are ready-made libraries and much more.  But how to use them, as specifically, implemented without regard to calling them from programs written in assembler, or even in general, contrary to the programming logic for the x86 architecture.  As a result, now programming in assembler with calling OS functions or external libraries of high-level languages ‚Äã‚Äãis ‚Äúfear‚Äù and ‚Äúhorror‚Äù. <br><br><h4>  The farther into the forest, the thicker </h4><br>  So, we realized that although assembler is very simple, we must be able to use it.  And the main consistency is the need to interact with the execution environment where our program runs.  If programmers in high-level languages ‚Äã‚Äãalready have access to the necessary libraries, functions, subroutines for many occasions, and they have access to ways of interacting with the outside world, in the form consistent with the idea of ‚Äã‚Äãthe language, then the assembler programmer has to wade through a thicket of all kinds of obstacles empty place.  When you look at what high-level languages ‚Äã‚Äãgenerate when compiling, it adds the feeling that those who wrote compilers either have no idea how the x86 processor works, ‚Äúor one of the two‚Äù (c). <br><br>  So let's go in order.  Programming is primarily engineering, that is, scientific work aimed at efficient (in terms of reliability, use of available resources, implementation timelines and ease of use) solving practical problems.  And, at the heart of any engineering is a systematic approach.  That is, it is impossible to consider any solution as a kind of ‚Äúunseparable‚Äù black box functioning in a complete and ideal vacuum. <br><div class="spoiler">  <b class="spoiler_title">Another example from another area</b> <div class="spoiler_text">  As a vivid example of a systematic approach, truck production in the USA can be cited.  In this case, the truck manufacturer is simply the manufacturer of the frame and cab + the designer's assembler.  Everything else (engine, transmission, suspension, electrical equipment, etc.) is taken based on the wishes of the customer.  One customer wanted to get some Kenworth with an engine from Detroit Diesel, a manual Fuller box, a spring suspension from some Dana - please.  It took the friend of this customer the same Kenworth model, but with the ‚Äúnative‚Äù Paccar engine, the Allison automatic transmission and the air suspension from another manufacturer - easy!  And so do all truck builders in the United States.  That is, a truck is a system in which each module can be replaced with another one of the same purpose and seamlessly docked with the existing ones.  Moreover, the method of module docking is made with the maximum available versatility and convenience of further expanding the functionality.  That is what an engineer should strive for. </div></div><br><br>  Unfortunately, we will have to live with what we have, but in the future this should be avoided.  So, a program is, in essence, a set of modules (as it is called as they are called, and how they ‚Äúbehave‚Äù), composing which we achieve the solution of the task at hand.  For efficiency, it is highly desirable that these modules can be reused.  And not just use at any cost, but use a convenient way.  And here we are waiting for another unpleasant "surprise."  Most high-level languages ‚Äã‚Äãoperate with such structural units as ‚Äúfunction‚Äù and ‚Äúprocedure‚Äù.  And, as a way of dealing with them, ‚Äúparameter transfer‚Äù is applied.  This is quite logical, and there are no questions.  But as always, ‚Äúwhat is being done is not what is being done - how is being done‚Äù (c).  And here begins the most incomprehensible.  There are 3 ways of organizing the transfer of parameters: <b>cdecl</b> , <b>stdcall</b> , <b>fastcall</b> .  So, none of these methods is native for x86.  Moreover, they are all flawed in terms of expanding the functionality of the called subroutines.  That is, having increased the number of parameters passed, we are forced to change all the call points of this function / subroutine, or to produce a new subroutine with similar functionality that will be called in a slightly different way. <br><br>  The above mentioned parameters transfer methods work relatively well on processors with 2 separate stacks (a data stack and an address / control stack) and advanced stack manipulation commands (at least an index reference to the stack elements).  But when programming on x86, you have to pervert first when transferring / receiving parameters, and then not forgetting their ‚Äústructural‚Äù removal from the stack.  Along the way, trying to guess / calculate the maximum stack depth.  Recall that x86 (16/32 bit mode) is a processor that has: <br><ul><li>  specialized registers (RONS - general-purpose registers - as such are absent: that is, we cannot multiply the contents of the GS register by one command with the value from EDI and get the result in the EDX: ECX pair, or divide the value from the EDI: ESI register pair by the contents register EAX); </li><li>  few registers; </li><li>  one stack; </li><li>  the memory cell does not provide any information on the type of value stored there. </li></ul>  In other words, the programming methods used for processors with a large register file, with the support of several independent stacks, etc.  most of them are not applicable when programming on x86. <br><br>  The next peculiarity of interaction with ready-made modules written in ‚Äúhigh-level languages‚Äù is the ‚Äústruggle‚Äù with ‚Äútypes of variables‚Äù.  On the one hand, the reason for the appearance of variable types is clear - the programmer knows what values ‚Äã‚Äãare used within his subprogram / module.  On this basis, it seems quite logical that, by setting the type of values ‚Äã‚Äãof a variable, we can ‚Äúsimplify‚Äù the writing of the program by placing control of the types / limits of values ‚Äã‚Äãon the language translator.  But even here the baby was splashed out with water.  Because any program is written not for generating spherical horses in a vacuum, but for practical work with user data.  That is an obvious violation of the systems approach - as if the developers of high-level languages ‚Äã‚Äãviewed their systems without taking into account interaction with the outside world.  As a result, when programming in a typed language, the developer must look at all possible types of "wrong" input data, and look for ways to circumvent uncertainties.  And it is here that the monstrous systems of support of regular expressions, exception handling, signatures of methods / procedures for different types of values ‚Äã‚Äãand other other generation of crutches appear on the scene. <br><br>  As mentioned above, for the x86 architecture, the value itself stored in the memory cell does not have any type.  An assembler programmer gets the privilege and <b>responsibility</b> to determine how to handle this very value.  And how to determine the type of value and how to handle it - there are many options to choose from.  But, we emphasize once again, they all relate only to the values ‚Äã‚Äãreceived from the user.  As developers of typed languages ‚Äã‚Äãcorrectly noted: the types of values ‚Äã‚Äãof internal and service variables are almost always known in advance. <br><br>  This reason (the perverted transfer of parameters to modules written in high-level languages ‚Äã‚Äãand the need to strictly monitor the types of parameters passed in the same modules) is seen as the main one, due to which assembly language programming is unreasonably difficult.  And the majority prefers to understand the wilds of ‚Äúhigh-level languages‚Äù in order to take advantage of what has already been gained by others than to suffer, I insert the same ‚Äútypical‚Äù crutches to correct what they did not do.  And the rare assembler translator somehow ‚Äúunloads‚Äù the programmer from this routine. <br><br><h4>  What to do? </h4><br>  Preliminary conclusions with a 15-year <b>break</b> in programming in assembler. <br>  First, about the modules or parts of the program.  In the general case, it is worth to distinguish two types of executive modules of the program in assembly language - ‚Äúoperation‚Äù and ‚Äúsubprogram‚Äù. <br><ul><li>  A ‚Äúoperation‚Äù is a module that performs an ‚Äúatomic‚Äù action and does not require a set of parameters for its execution (for example, the operation to clear the entire screen, or the operation to calculate the median of a number series, etc.). </li><li>  The ‚Äúsubroutine‚Äù is to call a functional module that requires, for correct functioning, a set of input parameters (more than 2‚Äì3). </li></ul>  And here it is worth assessing the experience of imperative and functional languages.  They gave us 2 valuable tools that should be used: ‚Äúdata structure‚Äù (or, for example, REXX - compound / supplemented variables) and ‚Äúdata non-clutter‚Äù. <br><br>  To transfer parameters to subroutines, it is convenient to use ‚Äústructures‚Äù, that is, formed sets of parameters located in a certain area of ‚Äã‚Äãmemory available and the main program and called subroutines.  Moreover, it is possible to standardize the approach, and use the ‚Äú0-th‚Äù parameter as a bit mask of the filled / significant fields of the structure.  That is, it will be a kind of call signature, which the subroutine can additionally analyze and change the operation logic, depending on the actual parameters used.  Moreover, the developer can extend the capabilities of the subroutine, while maintaining compatibility with the old calls, and increase the number of parameters used without having to produce many such subroutines with the same functionality within the supported API.  An additional advantage of this approach is the reduction of ‚Äúparasitic‚Äù work with the stack. <br><br>  It is also useful to follow the rule of non-tangency - that is, the immutability of the transmitted parameters.  The subroutine cannot (should not) change values ‚Äã‚Äãin the structure passed to it and the result returns either in registers (no more than 2-3 parameters), or also in a new structure created.  Thus, we are spared the need to make copies of structures, in case of a ‚Äúforgotten‚Äù change in data by subroutines, and we can use an already created structure or its main part to call several subroutines operating with one / similar set of parameters.  Moreover, practically ‚Äúautomatically‚Äù we come to the next ‚Äúfunctional‚Äù rule - the internal context-independence of subprograms and operations.  In other words - to the separation of the state / data from the method / subprogram of their processing (as opposed to the automaton model).  In cases of parallel programming, as well as sharing a single subroutine, we eliminate both the need to produce multiple execution contexts and watch for their "non-intersection", and the creation of many instances of one subroutine with different "states" in the case of several of its calls. <br><br>  As for the ‚Äútypes‚Äù of data, then you can leave ‚Äúeverything as it is‚Äù, and you can also not reinvent the wheel and take advantage of the fact that developers of translators of imperative languages ‚Äã‚Äãhave long used - ‚Äúvalue type identifier‚Äù.  That is, all data coming from the outside world is analyzed and each received value is assigned an identifier of the processed type (integer, floating point, packed BCD, character code, etc.) and the size of the field / value.  Having this information, the programmer, on the one hand, does not drive the user into an unnecessarily narrow framework of the ‚Äúrules‚Äù of entering values, but on the other hand, he has the ability to choose the most efficient way to process user data in the process.  But, I repeat once again, this only applies to working with user data. <br><br>  These were general considerations about assembly programming, not related to design, debugging and error handling.  I hope that the OS developers who write them from 0-la (and even more so on assembler) will have something to think about and they will choose (though not described above, but any other) ways to make programming in assembler more systematic, convenient and enjoyable, but they will not blindly copy others, often hopelessly ‚Äúcrooked‚Äù options. </div><p>Source: <a href="https://habr.com/ru/post/207186/">https://habr.com/ru/post/207186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207170/index.html">Manipulations with quantization matrices. Part 2</a></li>
<li><a href="../207172/index.html">Rails 4.1 beta1 out</a></li>
<li><a href="../207174/index.html">Canonical released a preview of the Ubuntu Touch dual boot for smartphones</a></li>
<li><a href="../207180/index.html">Changes in the rules of the Chrome Web Store: one extension - one function</a></li>
<li><a href="../207182/index.html">CCNP Service Provider Certification</a></li>
<li><a href="../207188/index.html">A passion for programming. Chapter 14. Be a Mentor</a></li>
<li><a href="../207190/index.html">For designers and not only</a></li>
<li><a href="../207196/index.html">Search for black holes on a home computer</a></li>
<li><a href="../207198/index.html">Button. 100 years long story</a></li>
<li><a href="../207200/index.html">Do not postpone acquisitions in foreign online stores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>