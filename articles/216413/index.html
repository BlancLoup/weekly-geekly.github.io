<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Calling x86 procedures from EFI Byte Code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The use of EFI Byte Code technology (abbreviated to EBC) allows you to create cross-platform applications and drivers running on a virtual processor i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Calling x86 procedures from EFI Byte Code</h1><div class="post__text post__text-html js-mediator-article">  The use of EFI Byte Code technology (abbreviated to EBC) allows you to create <a href="http://habrahabr.ru/post/212363/" title="Cross-platform evaluation of graphics capabilities in the context of UEFI">cross-platform applications</a> and drivers running on a virtual processor implemented as part of the platform firmware.  The architecture of this processor is defined in the Unified Extensible Firmware Interface specification.  Ideally, an EBC program should interact exclusively with virtual machine resources, UEFI system tables and other objects, abstracted from the hardware implementation of the platform.  In practice, the exact adherence to this principle significantly limits the functionality of the software product.  You can get out of the situation without losing cross-platformity if you use subroutines in the native code of the central processor, conditionally receiving control in the case of detection of a given hardware platform. <a name="habracut"></a><br><br><h4>  Formulation of the problem </h4><br>  Consider an example of reading a given MSR (Model Specific Register) register from an EBC application.  As is well known, the x86 instruction system contains the RDMSR (Read MSR) instruction, which receives the 32-bit MSR address in the ECX register as an input parameter, and returns the 64-bit MSR content in the EDX registers (upper 32 bits) and EAX (lower 32 bits) ).  In the command system of the virtual machine EBC, similar functionality is not provided, which is why a subroutine call in native code is required. <br><br>  Note that in the information-diagnostic utility <a href="http://jelezo.com.ua/programmy/utilita_uefimark.html" title="UEFImark utility">UEFImark x64 Edition</a> the RDMSR instruction is used directly, and in the <a href="http://jelezo.com.ua/programmy/uefimark_ebc_edition.html" title="UEFImark, EBC Edition">UEFImark EBC Edition</a> this requires calling the native subroutines from the EBC program. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Experimental Conditions </h4><br>  It is assumed that prior to transferring control to the procedure in question, the EBC program detected the x86 platform and found that one of the IA32 or x64 architectures is supported.  The method of detection is beyond the scope of this article, it is planned to consider in subsequent publications. <br><br>  FASM 1.69.50 is used to translate examples.  EBC instructions are implemented using macros, x86 code is translated for 64-bit mode, the features of ensuring its compatibility with 32-bit mode are discussed below. <br><br><h5>  Calling procedure EBC_Read_MSR </h5><br><pre><code class="hljs delphi">;--- Subroutine: EBC/x86 gate <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> MSR ----------------------------------; ; Caller must verify x86 support (IA32 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> x64) before call this subroutine, ; ; but this subroutine differentiate IA32/x64 internally. ; ; ; ; INPUT: R1 = Global variables pool base address ; ; R6 = MSR <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> (same <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ECX before RDMSR instruction) ; ; OUTPUT: R3 = MSR data after <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> (same <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> EDX:EAX after RDMSR instruction) ; ; R4-R7 can be changed ; ;----------------------------------------------------------------------------; EBC_Read_MSR: XOR64 R7,R7 ; R7=<span class="hljs-number"><span class="hljs-number">0</span></span> PUSH64 R7 ; Storage <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> output MOVQ R7,R0 ; Address <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> storage = stack pointer PUSHN R7 ; Parameter<span class="hljs-string"><span class="hljs-string">#2</span></span> = Output address PUSHN R6 ; Parameter<span class="hljs-string"><span class="hljs-string">#1</span></span> = MSR address MOVINW R7,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> CMPI32WEQ R7,<span class="hljs-number"><span class="hljs-number">4</span></span> ; R7=<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>-bit, R7=<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span>-bit MOVIQW R7,_IA32_Read_MSR ; This pointer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> IA32 (native width=<span class="hljs-number"><span class="hljs-number">4</span></span>) JMP8CS Native_Gate MOVIQW R7,_x64_Read_MSR ; This pointer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x64 (native width=<span class="hljs-number"><span class="hljs-number">8</span></span>) Native_Gate: ADD64 R7,R1 ; Add base address = R1 CALL32EXA R7 POPN R6 ; Remove Parameter<span class="hljs-string"><span class="hljs-string">#1</span></span> POPN R7 ; Remove Parameter<span class="hljs-string"><span class="hljs-string">#2</span></span> POP64 R3 ; <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> R3 = Output RET</code> </pre> <br>  <b>Fig.</b>  <b>1</b> .  <i><a href="">EBC procedure that calls the x86 MSR reading procedure</a></i> <br><br>  Consider the sequence of operations performed by the calling EBC procedure. <br><ol><li>  A reservation on the stack of a 64-bit variable in which the called procedure will write the contents of the specified MSR register. </li><li>  The call to the stack of the second input parameter for the called procedure is the address for saving the contents of the MSR.  This is the address of the variable created in step 1. </li><li>  The stack entry of the first input parameter for the called procedure is the address of the MSR register accepted by the subroutine in register R6. </li><li>  Determining the natural bit depth using the EBC instruction MOVINW.  If it was previously established that the platform is x86-compatible, then the value of the natural digit capacity of 4 means IA32 (4 bytes = 32 bits), 8 means x64 (8 bytes = 64 bits). </li><li>  Selecting the address for the entry point to the called subroutine (in accordance with the results of step 4 and placing it in register R7. </li><li>  Call the subroutine at the address obtained in step 5. </li><li>  Reading and deleting previously written parameters from the stack, the value of the variable created in step 1 in which the called subroutine wrote the result ‚Äî the 64-bit content of the MSR ‚Äî is read into the R3 register. </li></ol><br><br>  The bit width of the parameters that are pushed onto the stack by PUSHN instructions (Push Natural) and read from the stack by POPN instructions (Pop Natural) is 32 bits for IA32 UEFI and 64 bits for x64 UEFI. <br><br><h5>  Called procedures: IA32_Read_MSR, x64_Read_MSR </h5><br><pre> <code class="hljs delphi">;--- <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> Model-Specific <span class="hljs-keyword"><span class="hljs-keyword">Register</span></span>, selected by input <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> --------------; ; INPUT: Parm<span class="hljs-string"><span class="hljs-string">#1</span></span> = MSR address (ECX before RDMSR), natural width <span class="hljs-number"><span class="hljs-number">32</span></span>/<span class="hljs-number"><span class="hljs-number">64</span></span> ; ; Parm<span class="hljs-string"><span class="hljs-string">#2</span></span> = Address <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> output data, natural width <span class="hljs-number"><span class="hljs-number">32</span></span>/<span class="hljs-number"><span class="hljs-number">64</span></span> ; ; OUTPUT: R7 = Reserved <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> UEFI status ; ; QWORD at Address [Parm<span class="hljs-string"><span class="hljs-string">#2</span></span>] = MSR data (EDX:EAX after RDMSR) ; ;------------------------------------------------------------------------; IA32_Read_MSR: ; Entry point <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> IA32 push rbx rcx rdx mov ecx,[rsp+<span class="hljs-number"><span class="hljs-number">16</span></span>] ; ECX = Parm<span class="hljs-string"><span class="hljs-string">#1</span></span> = MSR address, assembled same <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [esp+<span class="hljs-number"><span class="hljs-number">16</span></span>], can use <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> IA32 mov ebx,[rsp+<span class="hljs-number"><span class="hljs-number">20</span></span>] ; EBX = Parm<span class="hljs-string"><span class="hljs-string">#2</span></span> = Output address, assembled same <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [esp+<span class="hljs-number"><span class="hljs-number">20</span></span>], can use <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> IA32 jmp Entry_R_MSR x64_Read_MSR: ; Entry point <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x64 push rbx rcx rdx mov rbx,rdx ; RBX=Output address (p<span class="hljs-string"><span class="hljs-string">#2</span></span>), RCX=MSR address (p<span class="hljs-string"><span class="hljs-string">#1</span></span>) Entry_R_MSR: rdmsr ; RCX=Input, EDX:EAX=Output mov [rbx+<span class="hljs-number"><span class="hljs-number">00</span></span>],eax mov [rbx+<span class="hljs-number"><span class="hljs-number">04</span></span>],edx pop rdx rcx rbx ret</code> </pre> <br>  <b>Fig.</b>  <b>2</b>  <i><a href="">Called x86 MSR Read Procedure</a></i> <br><br>  Consider the sequence of operations performed by the called x86 procedure. <br><ol><li>  Entry point for IA32 (label IA32_Read_MSR).  Preservation in a stack of registers EBX, ECX, EDX.  From the stack frame created by the calling procedure, the input parameters are read: the address of the MSR and the address of the variable to store the contents of the MSR.  Go to step 3. </li><li>  Entry point for x64 (x64_Read_MSR tag).  Saving to the stack of registers RBX, RCX, RDX.  In registers RCX and RDX, the first and second input parameters are accepted respectively. </li><li>  Performing the target operation is reading the MSR using the RDMSR instruction. </li><li>  Save read MSR content to the address specified by the second input parameter. </li><li>  Recovery registers EDX, ECX, EBX (for IA32) or RDX, RCX, RBX (for x64) and return to the calling procedure. </li></ol><br><br>  Looking at the procedure, you can find a contradiction: a number of 64-bit mode instructions are used for the 32-bit branch of execution, for example, the PUSH and POP instructions operating with 64-bit registers.  How it works?  The fact is that the 32-bit and 64-bit forms of these instructions are encoded in the same way, and their interpretation depends on the mode of operation of the processor.  Thus, code 53h in the 32-bit mode corresponds to the PUSH EBX instruction, and in the 64-bit mode - the PUSH RBX instruction. <br><br>  Consider the mechanisms for transferring input and output parameters of subroutines. <br><br>  For IA32 EFI, the input parameters of the called subroutine are passed through the stack.  In the procedure in question, the first parameter is located at [ESP + 16].  The offset 16 is made up of two terms: 4 bytes of the stack are used to store the EIP command counter, which is necessary when returning from the subroutine, 12 bytes for the EBX, ECX, EDX registers written to the stack by the PUSH instruction.  4 + 12 = 16. <br><br>  For x64 UEFI, the four first input parameters of the called subroutine are passed through the registers RCX, RDX, R8, R9, and the subsequent ones through the stack.  In our example, only two parameters are used, transmitted in RCX and RDX. <br><br>  For IA32 UEFI, the contents of the 32-bit x86-register EAX after returning from the x86-subroutine is in the 32 low bits of the 64-bit EBC-register R7.  The contents of the higher 32 bits of R7 are undefined.  For x64 UEFI, the contents of the 64-bit x86-register RAX after returning from the x86-subroutine is in the EBC-register R7.  This functionality is convenient for the transfer of status codes, in the considered example is not used. <br><br>  The described technology is used not only to call the procedures included in the application, but also when accessing the UEFI API, the processing of which is implemented in the firmware.  For example, when using the <a href="https://ru.intel.com/business/community/index.php%3Fautomodule%3Dblog%26blogid%3D59442%26showentry%3D4648" title="EFI Byte Code and Time Management">CPU Architectural Protocol</a> and <a href="https://ru.intel.com/business/community/index.php%3Fautomodule%3Dblog%26blogid%3D59442%26showentry%3D4641" title="File operations in UEFI">File I / O Protocol</a> functions. <br><br><h4>  Summary </h4><br>  The described method should be used only when it is required to provide functionality that is unattainable within the framework of the <a href="http://habrahabr.ru/post/214119/" title="EFI Byte Code and Memory Operations">EFI Byte Code</a> .  Thus, in the information-diagnostic utility <a href="http://jelezo.com.ua/skrinshoty/utilita_uefimark_ebc_edition.html">UEFImark EBC Edition</a> , the CPUID instruction in the native code is used to display the processor model and the list of supported technologies. <br><br>  It is important to note that any direct access to hardware resources makes it difficult to ensure cross-platform.  In particular, despite the fact that in the examples above, it is possible to distinguish between the IA86 and x64 x86 platforms, the application must make sure that it works on the x86 platform before transferring control.  Running on ARM or Itanium will lead to unpredictable consequences due to differences in the system commands of the CPU. </div><p>Source: <a href="https://habr.com/ru/post/216413/">https://habr.com/ru/post/216413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216401/index.html">Big data: size matters?</a></li>
<li><a href="../216403/index.html">Samsung invites to the final of the Hakaphon tour in Yakhroma park, Moscow</a></li>
<li><a href="../216407/index.html">Hi, Baynet! The adventures of the Runet assault in the partisan country</a></li>
<li><a href="../216409/index.html">The logic of thinking. Part 14. Hippocampus</a></li>
<li><a href="../216411/index.html">JTAG Peripheral Scanning: Testing Electronics Prototypes</a></li>
<li><a href="../216417/index.html">Microsoft Onenote - now free</a></li>
<li><a href="../216419/index.html">Writing Your Orm for Android with Canas and Senorites, Part 3</a></li>
<li><a href="../216421/index.html">How to create and earn SaaS (Part I / remove all unnecessary, hit the target, experiment)</a></li>
<li><a href="../216427/index.html">Unreal Engine 4 is now available for everyone.</a></li>
<li><a href="../216429/index.html">Epic released Unreal Engine 4 with $ 19 subscription sources</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>