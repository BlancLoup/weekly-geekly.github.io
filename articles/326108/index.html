<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A little about the lines in C, or several options to optimize non-optimizable</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habra, hello! 

 Not so long ago, I had a rather interesting incident in which one of the teachers of a computer science college was implicated. 

 Ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A little about the lines in C, or several options to optimize non-optimizable</h1><div class="post__text post__text-html js-mediator-article">  Habra, hello! <br><br><img align="left" src="https://habrastorage.org/files/f39/ded/9ad/f39ded9ad02d48f59d5fefb5f816ab5e.jpg">  Not so long ago, I had a rather interesting incident in which one of the teachers of a computer science college was implicated. <br><br>  Talking about programming under Linux slowly moved to the fact that this person began to argue that the complexity of system programming is in fact greatly exaggerated.  That the C language is simple as a match, in fact, like the Linux kernel (in his words). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I had with me a laptop with Linux, which was attended by a gentleman's toolkit for developing in the C language (gcc, vim, make, valgrind, gdb).  I don‚Äôt remember what goal we set for ourselves then, but after a couple of minutes my opponent was behind this laptop, completely ready to solve the problem. <br><br>  And literally in the very first lines, he made a serious mistake when allocating memory under ... a string. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) * <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(buffer));</code> </pre> <br>  buffer is a stack variable in which data was entered from the keyboard. <br><br>  I think there will definitely be people who will ask: ‚ÄúCan anything be wrong here?‚Äù. <br>  <i>Believe, maybe.</i> <br><br>  And what exactly - read on the cut. <br><a name="habracut"></a><br><h3>  A bit of theory - a kind of LikBez. </h3><br>  <b>If you know - scroll to the next header.</b> <br><br>  A string in C is an array of characters that, in a good way, should always end with '\ 0' - the end of line character.  The lines on the stack (static) are declared like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> str[n] = { <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre> <br>  n is the size of the character array, the same as the length of the string. <br><br>  Assigning {0} - ‚Äúzeroing‚Äù of the line (optional, you can declare without it).  The result is the same as the memset (str, 0, sizeof (str)) and bzero (str, sizeof (str)) functions.  It is used so that in the uninitialized variables there is no litter. <br><br>  Also on the stack, you can immediately initialize the line: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[BUFSIZE] = <span class="hljs-string"><span class="hljs-string">"default buffer text\n"</span></span>;</code> </pre> <br>  In addition, the line can be declared a pointer and allocate memory for it on the heap: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(size);</code> </pre> <br>  size - the number of bytes that we allocate for the line.  Such strings are called dynamic (due to the fact that the required size is calculated dynamically + the allocated memory size can be increased at any time using the realloc () function). <br><br>  In the case of a stack variable, I used the notation n to determine the size of the array, in the case of a variable on the heap ‚Äî I used the notation size.  And it perfectly reflects the true essence of the difference between an ad on a stack and an ad with allocating memory on a heap, because n is usually used when talking about the number of elements.  And size is another story altogether ... <br><br>  I think.  enough for now.  Go ahead. <br><br><h3>  We will help valgrind </h3><br>  In my previous article, I also mentioned it.  <a href="http://www.valgrind.org/">Valgrind</a> ( <a href="https://ru.wikipedia.org/wiki/Valgrind">once a wiki article</a> , <a href="http://alexott.net/ru/linux/valgrind/Valgrind.html">two is a small how-to</a> ) is a very useful program that helps a programmer to track memory leaks and context errors ‚Äî these are the things that most often come up when working with strings. <br><br>  Let's look at a small listing that implements something similar to the program I mentioned, and run it through valgrind: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define HELLO_STRING "Hello, Habr!\n" void main() { char *str = malloc(sizeof(char) * strlen(HELLO_STRING)); strcpy(str, HELLO_STRING); printf("-&gt;\t%s", str); free(str); }</span></span></span></span></code> </pre> <br>  And, actually, the result of the program: <br><br><pre> <code class="hljs kotlin">[<span class="hljs-symbol"><span class="hljs-symbol">indever@</span></span>localhost <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>]$ gcc main.c [<span class="hljs-symbol"><span class="hljs-symbol">indever@</span></span>localhost <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>]$ ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> -&gt; Hello, Habr!</code> </pre><br>  Nothing unusual yet.  And now let's run this program with valgrind! <br><br><pre> <code class="hljs 1c">[indever@localhost public]$ valgrind --tool=memcheck ./a.out ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== Memcheck, a memory error detector ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== Copyright (C) <span class="hljs-number"><span class="hljs-number">2002</span></span>-<span class="hljs-number"><span class="hljs-number">2015</span></span>, and GNU GPL'd, by Julian Seward et al. ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== Command: ./a.out ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== Invalid write of size 2 ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== at 0x<span class="hljs-number"><span class="hljs-number">4005</span></span>B4: main (in /home/indever/prg/C/public/a.out) ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== Address 0x<span class="hljs-number"><span class="hljs-number">520004</span></span>c is 12 bytes inside a block of size 13 alloc'd ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== at <span class="hljs-number"><span class="hljs-number">0</span></span>x4C2DB9D: malloc (vg_replace_malloc.c:<span class="hljs-number"><span class="hljs-number">299</span></span>) ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== by <span class="hljs-number"><span class="hljs-number">0</span></span>x400597: main (in /home/indever/prg/C/public/a.out) ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== Invalid read of size <span class="hljs-number"><span class="hljs-number">1</span></span> ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== at <span class="hljs-number"><span class="hljs-number">0</span></span>x4C30BC4: strlen (vg_replace_strmem.c:<span class="hljs-number"><span class="hljs-number">454</span></span>) ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== by <span class="hljs-number"><span class="hljs-number">0</span></span>x4E89AD0: vfprintf (in /usr/lib64/libc-<span class="hljs-number"><span class="hljs-number">2.24</span></span>.so) ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== by <span class="hljs-number"><span class="hljs-number">0</span></span>x4E90718: printf (in /usr/lib64/libc-<span class="hljs-number"><span class="hljs-number">2.24</span></span>.so) ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== by <span class="hljs-number"><span class="hljs-number">0</span></span>x4005CF: main (in /home/indever/prg/C/public/a.out) ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== Address <span class="hljs-number"><span class="hljs-number">0</span></span>x520004d is <span class="hljs-number"><span class="hljs-number">0</span></span> bytes after a block of size <span class="hljs-number"><span class="hljs-number">13</span></span> alloc'd ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== at 0x4C2DB9D: malloc (vg_replace_malloc.c:299) ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== by 0x<span class="hljs-number"><span class="hljs-number">400597</span></span>: main (in /home/indever/prg/C/public/a.out) ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== -&gt; Hello, Habr! ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== HEAP SUMMARY: ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== in use at exit: 0 bytes in 0 blocks ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== total heap usage: 2 allocs, 2 frees, 1,037 bytes allocated ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== All heap blocks were freed -- no leaks are possible ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== For counts of detected and suppressed errors, rerun with: -v ==<span class="hljs-number"><span class="hljs-number">3892</span></span>== ERROR SUMMARY: 3 errors from 2 contexts (suppressed: 0 from 0)</code> </pre><br>  <i>== 3892 == All heap blocks were freed - no leaks are possible</i> - there <i>are no leaks</i> , and it pleases.  But you should lower your eyes a little lower (although, I want to note, this is just the result, the main information is a little elsewhere): <br><br>  <i>== 3892 == ERROR SUMMARY: 3 errors from 2 contexts (suppressed: 0 from 0)</i> <br>  3 errors.  In 2 contexts.  In such a simple program.  How!? <br><br>  Yes, very simple.  The whole ‚Äújoke‚Äù is that the strlen function does not take into account the end-of-line character - '\ 0'.  Even if you explicitly specify it in the incoming line (#define HELLO_STRING "Hello, Habr! \ N \ 0"), it will be ignored. <br><br>  Slightly higher than the result of the program execution, the lines <i>-&gt; Hello, Habr!</i>  There is a detailed report on what and where our precious valgrind did not like.  I propose to look at these lines and draw conclusions. <br><br>  Actually, the correct version of the program will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define HELLO_STRING "Hello, Habr!\n" void main() { char *str = malloc(sizeof(char) * (strlen(HELLO_STRING) + 1)); strcpy(str, HELLO_STRING); printf("-&gt;\t%s", str); free(str); }</span></span></span></span></code> </pre> <br>  Pass through valgrind: <br><br><pre> <code class="hljs delphi">[indever@localhost <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>]$ valgrind --tool=memcheck ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> -&gt; Hello, Habr! ==<span class="hljs-number"><span class="hljs-number">3435</span></span>== ==<span class="hljs-number"><span class="hljs-number">3435</span></span>== HEAP SUMMARY: ==<span class="hljs-number"><span class="hljs-number">3435</span></span>== <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> use at <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> blocks ==<span class="hljs-number"><span class="hljs-number">3435</span></span>== total heap usage: <span class="hljs-number"><span class="hljs-number">2</span></span> allocs, <span class="hljs-number"><span class="hljs-number">2</span></span> frees, <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">038</span></span> bytes allocated ==<span class="hljs-number"><span class="hljs-number">3435</span></span>== ==<span class="hljs-number"><span class="hljs-number">3435</span></span>== All heap blocks were freed -- no leaks are possible ==<span class="hljs-number"><span class="hljs-number">3435</span></span>== ==<span class="hljs-number"><span class="hljs-number">3435</span></span>== <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> counts <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> detected <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> suppressed errors, rerun <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: -v ==<span class="hljs-number"><span class="hljs-number">3435</span></span>== ERROR SUMMARY: <span class="hljs-number"><span class="hljs-number">0</span></span> errors from <span class="hljs-number"><span class="hljs-number">0</span></span> contexts (suppressed: <span class="hljs-number"><span class="hljs-number">0</span></span> from <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br>  Fine.  No errors, +1 byte of allocated memory helped solve the problem. <br><br>  Interestingly, in most cases the first and second programs will work the same, but if the memory allocated for the line that the end character did not fit into was not zeroed, then the printf () function, when outputting such a line, will output all the garbage after this line - everything will be displayed until the line end character appears on the printf () path. <br><br>  However, you know, (strlen (str) + 1) is such a solution.  We face 2 problems: <br><br><ol><li>  And if we need to allocate memory for a string formed using, for example, s (n) printf (..)?  We do not support arguments. </li><li>  Appearance.  The string with the declaration of the variable looks just awful.  Some guys to malloc also (char *) manage to fasten, as if writing under the pluses.  In a program where you regularly need to process lines, it makes sense to find a more elegant solution. </li></ol><br>  Let's come up with a solution that will satisfy both us and valgrind. <br><br><h4>  snprintf () </h4><br> <code><i>int snprintf(char *str, size_t size, const char *format, ...);</i></code>  - function - sprintf extension, which formats the string and writes it according to the pointer passed as the first argument.  It differs from sprintf () in that the str will not write a byte more than specified in size. <br><br>  The function has one interesting feature - in any case, it returns the size of the string being formed (without taking into account the end-of-line character).  If the string is empty, then 0 is returned. <br><br>  One of the problems I have described using strlen is related to the functions sprintf () and snprintf ().  Suppose we need to write something in the str string.  The final line contains the values ‚Äã‚Äãof other variables.  Our record should be something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * str = <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(str, <span class="hljs-string"><span class="hljs-string">"Hello, %s\n"</span></span>, <span class="hljs-string"><span class="hljs-string">"Habr!"</span></span>);</code> </pre> <br>  The question is: how to determine how much memory should be allocated for the str line? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * str = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) * (<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str, <span class="hljs-string"><span class="hljs-string">"Hello, %s\n"</span></span>, <span class="hljs-string"><span class="hljs-string">"Habr!"</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre>  - it's not gonna go.  The prototype of the strlen () function looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; size_t strlen(const char *s);</span></span></span></span></code> </pre> <br>  const char * s does not imply that the string passed to s can be a format string with a variable number of arguments. <br><br>  Here we can use the useful property of the function snprintf (), which I mentioned above.  Let's look at the code for the following program: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; void main() { /* .. snprintf()     ,      */ size_t needed_mem = snprintf(NULL, 0, "Hello, %s!\n", "Habr") + sizeof('\0'); char *str = malloc(needed_mem); snprintf(str, needed_mem, "Hello, %s!\n", "Habr"); printf("-&gt;\t%s", str); free(str); }</span></span></span></span></code> </pre> <br>  Run the program in valgrind: <br><br><pre> <code class="hljs delphi">[indever@localhost <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>]$ valgrind --tool=memcheck ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> -&gt; Hello, Habr! ==<span class="hljs-number"><span class="hljs-number">4132</span></span>== ==<span class="hljs-number"><span class="hljs-number">4132</span></span>== HEAP SUMMARY: ==<span class="hljs-number"><span class="hljs-number">4132</span></span>== <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> use at <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> blocks ==<span class="hljs-number"><span class="hljs-number">4132</span></span>== total heap usage: <span class="hljs-number"><span class="hljs-number">2</span></span> allocs, <span class="hljs-number"><span class="hljs-number">2</span></span> frees, <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">041</span></span> bytes allocated ==<span class="hljs-number"><span class="hljs-number">4132</span></span>== ==<span class="hljs-number"><span class="hljs-number">4132</span></span>== All heap blocks were freed -- no leaks are possible ==<span class="hljs-number"><span class="hljs-number">4132</span></span>== ==<span class="hljs-number"><span class="hljs-number">4132</span></span>== <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> counts <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> detected <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> suppressed errors, rerun <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: -v ==<span class="hljs-number"><span class="hljs-number">4132</span></span>== ERROR SUMMARY: <span class="hljs-number"><span class="hljs-number">0</span></span> errors from <span class="hljs-number"><span class="hljs-number">0</span></span> contexts (suppressed: <span class="hljs-number"><span class="hljs-number">0</span></span> from <span class="hljs-number"><span class="hljs-number">0</span></span>) [indever@localhost <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>]$</code> </pre><br>  Fine.  Support arguments we have.  Because we pass zero to the snprintf () function as the second argument, writing to the zero pointer will never result in Seagfault.  However, despite this, the function will still return the size required by the string. <br><br>  But on the other hand, we had to create an additional variable, and the construction <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> needed_mem = <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, %s!\n"</span></span>, <span class="hljs-string"><span class="hljs-string">"Habr"</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>);</code> </pre> <br>  looks even worse than strlen (). <br><br>  <i>In general, + sizeof ('\ 0') can be removed if at the end of the format line you specify '\ 0' (size_t needed_mem = snprintf (NULL, 0, "Hello,% s! \ N <b>\ 0</b> ", "Habr")) ;), but this is not always possible (depending on the string processing mechanism, we can allocate an extra byte).</i> <i><br></i> <br>  Need to do something.  I thought a little and decided that now was the time to appeal to the wisdom of the ancients.  We describe the macro function that will call snprintf () with a null pointer as the first argument, and null as the second.  And let's not forget about the end of the line! <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> strsize(args...) snprintf(NULL, 0, args) + sizeof(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\0'</span></span></span><span class="hljs-meta">)</span></span></code> </pre> <br>  Yes, it may be news for someone, but macros in C support a variable number of arguments, and a triple-dot tells the preprocessor that the specified argument of the macro function (in our case, it‚Äôs args) corresponds to several real arguments. <br><br>  Let's test our solution in practice: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define strsize(args...) snprintf(NULL, 0, args) + sizeof('\0') void main() { char *str = malloc(strsize("Hello, %s\n", "Habr!")); sprintf(str, "Hello, %s\n", "Habr!"); printf("-&gt;\t%s", str); free(str); }</span></span></span></span></code> </pre> <br>  Run with valgrund: <br><br><pre> <code class="hljs delphi">[indever@localhost <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>]$ valgrind --tool=memcheck ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> -&gt; Hello, Habr! ==<span class="hljs-number"><span class="hljs-number">6432</span></span>== ==<span class="hljs-number"><span class="hljs-number">6432</span></span>== HEAP SUMMARY: ==<span class="hljs-number"><span class="hljs-number">6432</span></span>== <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> use at <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> blocks ==<span class="hljs-number"><span class="hljs-number">6432</span></span>== total heap usage: <span class="hljs-number"><span class="hljs-number">2</span></span> allocs, <span class="hljs-number"><span class="hljs-number">2</span></span> frees, <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">041</span></span> bytes allocated ==<span class="hljs-number"><span class="hljs-number">6432</span></span>== ==<span class="hljs-number"><span class="hljs-number">6432</span></span>== All heap blocks were freed -- no leaks are possible ==<span class="hljs-number"><span class="hljs-number">6432</span></span>== ==<span class="hljs-number"><span class="hljs-number">6432</span></span>== <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> counts <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> detected <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> suppressed errors, rerun <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: -v ==<span class="hljs-number"><span class="hljs-number">6432</span></span>== ERROR SUMMARY: <span class="hljs-number"><span class="hljs-number">0</span></span> errors from <span class="hljs-number"><span class="hljs-number">0</span></span> contexts (suppressed: <span class="hljs-number"><span class="hljs-number">0</span></span> from <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br>  Yes, there are no mistakes.  Everything is correct.  And valgrind is pleased, and the programmer can finally go to sleep. <br><br>  But, finally, I will say something else.  In case we need to allocate memory for any string (even with arguments) there is already a <i>fully working ready solution</i> . <br><br>  This is the asprintf function: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* See feature_test_macros(7) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; int asprintf(char **strp, const char *fmt, ...);</span></span></span></span></code> </pre><br>  As the first argument, it takes a pointer to a string (** strp) and allocates memory according to a dereferenced pointer. <br><br>  Our program written using asprintf () will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; void main() { char *str; asprintf(&amp;str, "Hello, %s!\n", "Habr"); printf("-&gt;\t%s", str); free(str); }</span></span></span></span></code> </pre> <br>  And, actually, in valgrind: <br><br><pre> <code class="hljs delphi">[indever@localhost <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>]$ valgrind --tool=memcheck ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> -&gt; Hello, Habr! ==<span class="hljs-number"><span class="hljs-number">6674</span></span>== ==<span class="hljs-number"><span class="hljs-number">6674</span></span>== HEAP SUMMARY: ==<span class="hljs-number"><span class="hljs-number">6674</span></span>== <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> use at <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> blocks ==<span class="hljs-number"><span class="hljs-number">6674</span></span>== total heap usage: <span class="hljs-number"><span class="hljs-number">3</span></span> allocs, <span class="hljs-number"><span class="hljs-number">3</span></span> frees, <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">138</span></span> bytes allocated ==<span class="hljs-number"><span class="hljs-number">6674</span></span>== ==<span class="hljs-number"><span class="hljs-number">6674</span></span>== All heap blocks were freed -- no leaks are possible ==<span class="hljs-number"><span class="hljs-number">6674</span></span>== ==<span class="hljs-number"><span class="hljs-number">6674</span></span>== <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> counts <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> detected <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> suppressed errors, rerun <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: -v ==<span class="hljs-number"><span class="hljs-number">6674</span></span>== ERROR SUMMARY: <span class="hljs-number"><span class="hljs-number">0</span></span> errors from <span class="hljs-number"><span class="hljs-number">0</span></span> contexts (suppressed: <span class="hljs-number"><span class="hljs-number">0</span></span> from <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br>  Everything is fine, but, as you can see, more memory was allocated in total, and now alloc'ov are three, not two.  On weak embedded systems, using this feature is undesirable. <br>  In addition, if we write man asprintf in the console, we will see: <br><br><pre> <code class="hljs pgsql">CONFORMING <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> These <span class="hljs-keyword"><span class="hljs-keyword">functions</span></span> are GNU extensions, <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> C <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> POSIX. They are <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> available under *BSD. The FreeBSD implementation sets strp <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> error.</code> </pre> <br><br>  Hence it is clear that this function is available only in the GNU source code. <br><br><h2>  Conclusion </h2><br>  In conclusion, I want to say that working with strings in C is a very complex topic, which has a number of nuances.  For example, to write a ‚Äúsafe‚Äù code when dynamically allocating memory, it is recommended to use the calloc () function instead of malloc () - calloc clogs the allocated memory with zeros.  Well, or after allocating memory, use the memset () function.  Otherwise, the garbage that initially lay on the allocated area of ‚Äã‚Äãmemory may cause questions during debugging, and sometimes when working with a string. <br><br>  More than half of my fellow C-programmers (most of them are beginners), who, at my request, solved the task with memory allocation for strings, did it in such a way that in the end this led to context errors.  In one case - even to a memory leak (well, the person forgot to make free (str), with whom it does not happen).  As a matter of fact, this encouraged me to create this creation, which you just read. <br><br>  I hope someone this article will be useful.  Why am I all this town - no language is simple.  Everywhere has its own subtleties.  And the more subtleties of the language you know, the better your code. <br><br>  I believe that after reading this article, your code will be a little better :) <br>  <i><b>Good luck, Habr!</b></i> </div><p>Source: <a href="https://habr.com/ru/post/326108/">https://habr.com/ru/post/326108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326096/index.html">PostgreSQL indexes - 1</a></li>
<li><a href="../326098/index.html">A step-by-step guide to the CSS Grid auto-placement algorithm</a></li>
<li><a href="../326102/index.html">Online cash vs blockchain: you did not know this, but thought about it?</a></li>
<li><a href="../326104/index.html">Not soon the fence is built, especially a beautiful data center. How we build the data center "Avantage". Part 1</a></li>
<li><a href="../326106/index.html">PostgreSQL indexes - 2</a></li>
<li><a href="../326110/index.html">It's very simple</a></li>
<li><a href="../326112/index.html">IP KVM DIY 2.0</a></li>
<li><a href="../326114/index.html">Primitives for implementing 1-Wire master using PWM and ICP for STM8L and STM32</a></li>
<li><a href="../326116/index.html">The subtleties of Scala: we study CanBuildFrom</a></li>
<li><a href="../326118/index.html">Editors ONLYOFFICE v.4.3: yes, we added footnotes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>