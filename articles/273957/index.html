<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compile C \ C ++ code in WebAssembly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebAssembly is a new binary format into which web applications can be compiled. It is designed and implemented right at the moment when you read these...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compile C \ C ++ code in WebAssembly</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://github.com/WebAssembly/design">WebAssembly</a> is a new binary format into which web applications can be compiled.  It is designed and implemented right at the moment when you read these lines and the developers of all major browsers move it forward.  Everything changes very quickly!  In this article, we will show the current state of the project with a fairly deep immersion in the tools for working with WebAssembly. <br><br>  In order for WebAssembly to work, we need two main components: tools for assembling code into a WebAssembly format binary and browsers that can download and execute this binary.  Both are not yet fully created and very much depend on the completion of work on <a href="https://github.com/WebAssembly/spec">the</a> WebAssembly <a href="https://github.com/WebAssembly/spec">specification</a> , but in general these are separate components and their development goes in parallel.  This separation is a good thing, it will allow compilers to create WebAssembly applications that can work in any browser, and browsers run WebAssembly programs no matter what compiler they were created with.  In other words - we get an open competition of development tools and browsers that will continuously move all this forward, bringing an excellent choice to the end user.  In addition, this separation allows teams of toolkit and browser developers to work in parallel and independently. <br><br>  A new project on the side of the WebAssembly toolkit, which I want to talk about today, is called <a href="https://github.com/WebAssembly/binaryen">Binaryen</a> .  Binaryen is a compiler library for supporting WebAssembly in compilers, written in C ++.  If you are not personally working on a WebAssembly compiler, then you probably do not need to directly know anything about Binaryen.  If you use any WebAssembly compiler, then it probably uses Binaryen under the hood - we will look at the examples below. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The core of the Binaryen library is intended for parsing and generating WebAssembly, as well as presenting its code as an abstract syntax tree (AST).  Based on these features, the following useful utilities are created: <br><br><ul><li>  A command line utility that can load the WebAssembly module, parse it and execute its code as an interpreter (perform actions, output the result to the console).  To load the module and output the result, the time notation of s-expressions is used, which has the suffix .wast (I remind you that the final <a href="">presentation format of the WebAssembly binary modules</a> is still under development). </li><li>  asm2wasm is a utility for compiling asm.js into WebAssembly. </li><li>  wasm2asm is a utility for compiling WebAssembly in asm.js (still under development) </li><li>  s2wasm, which compiles .s files (the format created by the <a href="http://llvm.org/devmtg/2015-10/slides/BastienGohman-WebAssembly-HereBeDragons.pdf">new backend for WebAssembly to LLVM</a> ) in WebAssembly. </li><li>  wasm.js - Binaryen port on javascript.  This will allow you to run all the above tools directly in the browser. </li></ul><br><br>  About Binaryen you can see <a href="https://kripken.github.io/talks/wasm.html">these slides</a> . <br><br>  Once again I remind you that WebAssembly is in the stage of active design, which means that the input and output formats of Binaryen (.wast, .s) are not final.  Binaryen is constantly updated with the WebAssembly specification update.  The degree of cardinality changes with time decreases, but no one, of course, can guarantee any compatibility. <br><br>  Let's take a look at a few areas where Binaryen might be useful. <br><br>  <b>Compiling in WebAssembly using Emscripten</b> <br><br>  Emscripten can compile C code in asm.js, and Binaryen (using the asm2wasm utility) can compile asm.js into WebAssembly, so the Emscripten + Binaryen bundle gives us a complete set of tools for compiling C and C ++ code into WebAssembly.  You can run asm2wasm on asm.js code, but it's easier to let Emscripten do it for you, like this: <br><br><pre><code class="bash hljs">emcc file.cpp -o file.js -s <span class="hljs-string"><span class="hljs-string">'BINARYEN=‚Äùpath-to-binaryen‚Äù'</span></span></code> </pre> <br><br>  Emscripten will compile the file file.cpp and the output will give you a javascript file, plus a separate .wast file with WebAssembly.  Under the hood, Emscripten will compile the code in asm.js, run asm2wasm for it and save the result.  This is described in more detail on the Emscripten <a href="https://github.com/kripken/emscripten/wiki/WebAssembly">wiki</a> . <br><br>  But wait, what's the point of compiling something in WebAssembly, if browsers don't support it yet?  Great question!  :) Yes, we can not yet run this code in any browser.  But we can already test something with it.  So, we want to check if the binary Emscripten + Binaryen has created the correct binary.  How to do it?  To do this, we can use wasm.js, which Emscripten integrated into the output .js file received by the emcc command (see above).  wasm.js contains the Binaryen port in Javascript, including the interpreter.  If you run file.js (in node.js or in a browser), then you will get the result of performing WebAssembly.  This allows us to actually confirm that the compiled WebAssembly binary works correctly.  You can look at <a href="https://kripken.github.io/talks/wasm.html">an example of</a> such a program, plus a <a href="https://github.com/WebAssembly/build-suite">couple</a> more <a href="https://github.com/WebAssembly/build-suite">examples</a> are in the repository for test purposes. <br><br>  Of course, we are not yet standing on solid ground with all these tools.  The test environment is weird.  C ++ code is compiled into WebAssembly and then executed in a WebAssembly interpreter, which is itself written in C ++ but ported to JavaScript.  And while there are no other ways to run it all.  But we have several reasons to believe the results: <br><br><ul><li>  The output code passes all Emscripten tests.  They include processing of a set of real code bases (Python, zlib, SQLite) plus a set of ‚Äúsuspicious‚Äù situations in C and C ++.  From experience, it can be said that if Emscripten tests pass for all these cases, then the other code processed by Emscripten will behave normally </li><li>  The Binaryen interpreter passes all internal WebAssembly tests that determine the correctness of WebAssembly execution.  In other words, when we get WebAssembly support in browsers, they will have to behave in the same way (well, except to work faster). </li><li>  Most of the work is done by Emscripten, which is a stable compiler used in production for a long time and only a relatively small part is done on top of it using Binaryen (its code is only a couple of thousand lines).  Less code - less bugs. </li></ul><br><br>  All this shows that we already have some result, we can compile the code in C and C ++ in WebAssembly and even run it somehow. <br><br>  Note that WebAssembly is just another new feature, and, distracting from it, everything else in Emscripten still works: Emscripten allows you to use libc and syscalls, OpenGL / WebGL code, integration with browsers, integration with node.js and t .d  As a result, projects that are already using Emscripten will be able to switch to WebAssembly simply by adding a new command line parameter.  And this will allow C ++ projects to be compiled into WebAssembly and work in browsers without any effort. <br><br>  <b>Using new experimental backend for LLVM for WebAssembly with Emscripten</b> <br><br>  We have just seen a new important stage in the development of Emscripten, which gave him the opportunity to create WebAssembly modules and even test their work.  But the work does not stop there: it was just the use of the current asm.js compiler, along with the asm2wasm utility.  There is a new backend to LLVM for WebAssembly (or rather, not yet, but it is being actively written) - right in the main development branch of LLVM.  And, although it is not yet ready for real use, over time it will become a very important tool.  Binaryen supports the format of its output. <br><br>  The LLVM backend for WebAssembly, like most LLVM backends, creates an assembler code, in this case in a special .s format.  This format is close to WebAssembly, but not directly identical to it ‚Äî it is more like the C compiler output (linear list of instructions, one instruction per line) than the abstract WebAssembly syntax tree.  This .s-file can be converted to WebAssembly in a rather trivial way (in general, Binaryen includes the s2wasm utility, which does just that - see how simple it is).  You can run it by itself, or use Emscripten for this, which now supports the new WASM_BACKEND option, which you can use like this: <br><br><pre> <code class="bash hljs">emcc file.cpp -o file.js -s <span class="hljs-string"><span class="hljs-string">'BINARYEN=‚Äùpath-to-binaryen‚Äù'</span></span> -s WASM_BACKEND=1</code> </pre><br><br>  Note that you also need to use the BINARYEN option, since s2wasm is part of Binaryen.  When all these options are specified, Emscripten uses the new backend for WebAssembly instead of using the asm.js compiler.  After calling the backend and receiving a file in it in the .s-format, Emscripten will call s2wasm for conversion to WebAssembly.  Some examples of programs that you can already build in a similar way can be found on the Emscripten project. <br><br>  Thus, we have two ways to assemble a WebAssembly module using Binaryen: <br><ol><li>  <b>Emscripten + asm.js backend + asm2wasm</b> , which is already working right now and should be a relatively simple and acceptable option </li><li>  <b>Emscripten + new backend for WebAssembly + s2wasm</b> , which is not yet fully working version, but with the development of backend for WebAssembly will come to the fore. </li></ol><br><br>  The goal at the moment is to make the transition from the first method to the second one as less complicated as possible.  Ideally, everything should be reduced to replacing one argument on the command line. <br><br>  Thus, we have a clear plan: <br><br><ol><li>  Use Emscripten to generate asm.js code (today) </li><li>  Moving to WebAssembly generation via asm2wasm (already available, but browsers are not yet ready) </li><li>  Moving to WebAssembly generation via new LLVM backend (as soon as it is ready) </li></ol><br><br>  Each step gives new advantages to users (speed!) And practically does not cause difficulties for developers. <br><br>  In conclusion, I want to say that although this article is written about Binaryen in the context of its use with Emscripten, it is still a separate library for WebAssembly for general use.  If you have ideas for creating some tools for working with WebAssembly, you can take the Binaryen library and work with it, without looking at Emscripten, LLVM or something else. </div><p>Source: <a href="https://habr.com/ru/post/273957/">https://habr.com/ru/post/273957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273945/index.html">Sberbank shares the experience of creating an application in Material Design: styles and themes</a></li>
<li><a href="../273947/index.html">Disaster corporate data center as a service</a></li>
<li><a href="../273949/index.html">According to Rambler.iOS V</a></li>
<li><a href="../273951/index.html">Plugin for Redmine: reports on work</a></li>
<li><a href="../273955/index.html">We become professional PHP developers. Part 3: Teamwork</a></li>
<li><a href="../273959/index.html">Entirely Russian, convergent and ... hyperconvergent. Why we made the platform "SCALA-R"</a></li>
<li><a href="../273961/index.html">Basic Zen</a></li>
<li><a href="../273965/index.html">FactRuEval - a competition to select named entities and extract facts</a></li>
<li><a href="../273967/index.html">Using JMeter for distributed load organization</a></li>
<li><a href="../273971/index.html">Configuring Grandstream UCM 61xx series and its integration with 1C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>