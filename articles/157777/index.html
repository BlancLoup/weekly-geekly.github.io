<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Infinite value generators on Delphi + Assembler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In functional programming languages, it is possible to generate infinite sequences of values ‚Äã‚Äã(as a rule of numbers) and operate on these sequences. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Infinite value generators on Delphi + Assembler</h1><div class="post__text post__text-html js-mediator-article">  In functional programming languages, it is possible to generate infinite sequences of values ‚Äã‚Äã(as a rule of numbers) and operate on these sequences.  It is implemented by a function that, without interrupting its work, generates values ‚Äã‚Äãone after another based on its internal state. <br>  But, unfortunately, in ordinary languages ‚Äã‚Äãit is not possible to ‚Äúreturn‚Äù values ‚Äã‚Äãto the place of a call without leaving the function.  One challenge - one result. <br>  Generators would be conveniently used in conjunction with Delphi's ability to enumerate values ‚Äã‚Äã(GetEnumerator / MoveNext / GetCurrent).  In this article, we will create a generator function (maybe even infinite) and use it with such an object for enumeration so that everything works transparently without needing to delve into the implementation. <br><a name="habracut"></a><br>  The reason why it is impossible to return a value without completely exiting the function is that the called function uses the same stack as the calling one.  That is, if the called function generates the next value, then you need to find a way to return control to the program for processing.  The main thing is that the local data of the called function is not damaged, and, when necessary, we can start it from the same place where we interrupted.  Let's start with the fact that the function needs a separate stack.  Neither Windows nor the processor can prevent us from creating several stacks and switching between them from time to time.  The only thing that we will lose is a Stack Overflow exception (of course, only if the function really goes beyond the stack).  Instead, a standard Access Violation will be generated. <br><br>  You can write a suitable function for the generator yourself or take something familiar and understandable, for example, the Fibonacci number generator. <br>  The algorithm described in the article does not limit us in choosing a function; it can return (generate) values ‚Äã‚Äãof any type, and most importantly be ‚Äúinfinite‚Äù.  The ‚Äúinfinite‚Äù function generates values ‚Äã‚Äãuntil the enumeration is interrupted by the break statement in the body of the for-in loop.  For example, you can search for files on the disk, browsing each one and interrupting the search when the right one is found.  The advantages of this method, compared to writing your own enumerator, are that the function can use local variables (for example, TSearchRec together with the FindFirst / FindNext / FindClose functions).  And compared to storing all the values ‚Äã‚Äãin a temporary array, the generators consume less memory, and in the case of searching for something, the time is reduced by an average of half (not spent on the formation of the remaining part of the array after the element found). <br>  Imagine that we have such a function: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Generator: TGeneratorWithParam&lt;UInt64, UInt64&gt; )</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> V1, V2, V: UInt64; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> V1 := <span class="hljs-number"><span class="hljs-number">1</span></span>; V2 := <span class="hljs-number"><span class="hljs-number">1</span></span>; V := V1 + V2; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> Generator.Yield( V ) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ( V &gt;= V2 ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> V1 := V2; V2 := V; V := V1 + V2; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The function generates numbers and "gives" them to the enumerator by calling Generator.Yield. <br>  When values ‚Äã‚Äãgo beyond the bit grid (the second condition after ‚Äúand‚Äù), the function ends its work. <br>  Note that if Generator.Yield returns False, the function will also terminate.  This will happen if the enumerator was destroyed before the function listed all the numbers up to 2 ^ 64, that is, the for-in loop was interrupted by a break, exit statement, or interrupted by an exception. <br><br>  The code for outputting numbers will be: <br><br><pre> <code class="delphi hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TGenerator&lt;UInt64&gt;.Create( Fibonacci ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> WriteLn( X ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  Now you need to write such a class TGeneratorWithParam &lt;T1, T2&gt; so that the above function and the code that uses it can work together. <br><br>  The code will use the latest Delphi features (XE2, XE3) and will compile the same successfully with both the 32-bit and 64-bit compilers (the full code at the end of the article under the spoiler). <br><br>  In order for the function to ‚Äúreturn‚Äù values ‚Äã‚Äãof different types, we will make the TGenerator class parameterized. <br>  Then you need to select data that does not depend on the return type in a separate class, so that this class can be accessed from the assembly code. <br><br><pre> <code class="delphi hljs"> TGeneratorContext = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> SP: NativeUInt; <span class="hljs-comment"><span class="hljs-comment">//  . //   -    //     , //    -     //  . Stack: PNativeUIntArray; //   . //     VirtualAlloc StackLen: NativeUInt; //   Generator: TObject; //     Active: Boolean; //    end; TGeneratorBase = class protected Context: TGeneratorContext; //  ( ..  ) FFinished: Boolean; //    end; TGeneratorWithParam&lt;ParamT, ResultT&gt; = class( TGeneratorBase ) protected FFunc: TGeneratorFunction&lt;ParamT, ResultT&gt;; FValue: ResultT; FParam: ParamT; public procedure Stop; function Yield( const Value: ResultT ): Boolean; public function GetCurrent: ResultT; function MoveNext: Boolean; property Current: ResultT read GetCurrent; function GetEnumerator: TGeneratorWithParam&lt;ParamT, ResultT&gt;; constructor Create( Func: TGeneratorFunction&lt;ParamT, ResultT&gt;; const Param: ParamT ); overload; constructor Create( Func: TGeneratorFunction&lt;ParamT, ResultT&gt; ); overload; destructor Destroy; override; property Param: ParamT read FParam; property Value: ResultT read FValue; end; TGenerator&lt;T&gt; = class( TGeneratorWithParam&lt;T, T&gt; ); //       : //TGenerator&lt;T&gt; = TGeneratorWithParam&lt;T, T&gt;; //   Delphi   </span></span></code> </pre><br><br>  It is also necessary to provide the possibility to complete the enumeration both from the program side (exit from the for-in loop) and from the side of the function (exit from the function). <br>  As soon as the main program completes the for-in loop, the TGenerator object is destroyed, in the destructor of which the function is terminated: <br>  1. Again the context switches to the execution of the function. <br>  2. Method Yield on the side of the function generator returns False <br>  3. The generator function exits the loop and ends its work regularly.  It can also correctly finalize its variables, free up resources, etc. <br><br>  Let's do one interesting trick with the TGenerator class.  Let's declare the GetEnumerator method, as well as the MoveNext and GetCurrent methods (let's not forget about the Current property). <br>  The GetEnumerator method will look like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">:</span></span> TGeneratorWithParam&lt;ParamT, ResultT&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Self; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  What's going on here?  The function returns the generator object itself as an enumerator object. <br>  This is done to simplify the use of the class, as well as based on this feature: if the function has completed its execution after exiting the for-in loop, then there is no easy way to start it again for the next loop.  Therefore, it is decided to cancel the repeated use of the enumerator.  I.e: <br>  1. Created a generator <br>  2. Received enumerator (aka generator) <br>  3. Listed all the values. <br>  4. Destroyed enumerator (aka generator) <br><br>  If you need to restart the function and list all the values, then the generator is created again. <br>  Note that if a certain object (or even a record) in the GetEnumerator method returns an object, it is released automatically after exiting the loop.  The same applies to interfaces and records, but they are deleted correctly and in other cases, and the fact that this rule applies to objects is a bit atypical for Delphi, in which there is no automatic deletion of the created objects (really so far, because work is underway above the full garbage collection, it can be seen in the source code of system.pas from XE3). <br><br>  When creating a generator, you must perform the following steps: <br><br>  1. To allocate memory for the stack. <br><br><pre> <code class="delphi hljs"> Context.Stack := VirtualAlloc( <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, MinStackSize, MEM_RESERVE <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> MEM_COMMIT, PAGE_READWRITE ); Context.StackLen := MinStackSize <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> SizeOf( NativeUInt );</code> </pre><br><br>  2. Set the SP pointer. <br><br><pre> <code class="delphi hljs"> Context.SP := NativeUInt( @Context.Stack^[Context.StackLen - <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF CPUX64}</span></span> - <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span>] );</code> </pre><br><br>  2. Write the initial values ‚Äã‚Äãto the stack. <br><br><pre> <code class="delphi hljs"> Context.Stack^[Context.StackLen - <span class="hljs-number"><span class="hljs-number">4</span></span>] := GetFlags; <span class="hljs-comment"><span class="hljs-comment">//    (EFLAGS/RFLAGS) Pointer( Context.Stack^[Context.StackLen - 3] ) := @Func; //    (EIP/RIP) Pointer( Context.Stack^[Context.StackLen - 2] ) := @TGeneratorContext.Return; //     ,   - Pointer( Context.Stack^[Context.StackLen - 1] ) := Self; // Self   TGeneratorContext.Return</span></span></code> </pre><br><br>  Also for debugging purposes, immediately after creating the stack, you can enter the following line: <br><br><pre> <code class="delphi hljs"> FillChar( Context.Stack^, Context.StackLen * SizeOf( NativeUInt ), $DD );</code> </pre><br><br>  In the destructor, you need to stop the function and free up the memory allocated for the stack. <br><br><pre> <code class="delphi hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FFinished <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Stop; VirtualFree( Context.Stack, <span class="hljs-number"><span class="hljs-number">0</span></span>, MEM_RELEASE );</code> </pre><br><br>  The MoveNext method will call the generator function, get a value from it and check whether the transfer should continue (that is, if the function has not completed).  The method is not too complicated, especially if you consider how much it does. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveNext</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Context.Active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">//     ... begin Context.Active := True; Context.Enter( NativeUInt( Self ) ); //  :   -&gt;   //    Enter    //    (Self),   EAX ( RCX  x64) //   .     //     . end else begin Context.Enter( Ord( True ) ); //  ,    ,   //   EAX  True.     //   Yield    //    . end; Result := not FFinished; //         FValue, //      True,    // ,  False,  - //   (   ). end;</span></span></code> </pre><br><br>  The following method looks quite simple.  Only three lines, one of which is never even executed.  This is the Yield method, which is called from the function when the next value is generated. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Yield</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: ResultT )</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FValue := Value; <span class="hljs-comment"><span class="hljs-comment">//      Context.Leave; //  :   -&gt;   Result := not FFinished; //     ,   , //   Yield,     //     (    ), //         // Delphi     // . end;</span></span></code> </pre><br><br>  The main task of this function is not to return the result to the generator function at all, but to save the generated value and return to the main context so that this value can be processed inside the for-in loop, for example, displayed on the screen.  In fact, after the stack is replaced in the Context.Leave procedure, control will be immediately transferred to the line following the procedure called Context.Enter (in the MoveNext method). <br><br>  The Stop method is executed in one case: if by the time the destructor is called, the function has not yet completed the generation of values.  Since the functions need to finalize the variables, free up resources and generally complete the work, then you need to transfer control to it again, making the call to Yield method return False. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFinished := True; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Context.Active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">//      ... Context.Enter( Ord( False ) ); //  :   -&gt;   //     EAX  False, //     ,    Yield. end;</span></span></code> </pre><br><br>  To switch the stack, we will have a separate procedure.  It will be used to switch to both sides. <br>  Its task is to save the state to the current stack and load the new state from the new stack. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SwitchContext</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> <span class="hljs-comment"><span class="hljs-comment">//   SwitchContext   ECX   //     TGeneratorContext pushfd //  EFLAGS push EBX //    push EBP //  EAX,ECX,EDX  //  ,     //  push ESI //     . push EDI // //    : //      SP   xchg ESP, dword ptr [ECX].TGeneratorContext.&amp;SP //      pop EDI pop ESI pop EBP pop EBX popfd //  EFLAGS // ret end;</span></span></code> </pre><br><br>  You do not need to save the EIP register, because after executing the ret instruction (and it is implicitly present in any Delphi assembly procedure), the processor will return to the address that was stored on the stack during the call to Enter and Leave procedures. <br><br>  This is what the Enter procedure will look like: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorContext</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Input: NativeUInt )</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> mov ECX, EAX <span class="hljs-comment"><span class="hljs-comment">// Self,   TGeneratorContext mov EAX, EDX // Input,  EAX     jmp SwitchContext //   end;</span></span></code> </pre><br><br>  And so Leave: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorContext</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Leave</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> mov ECX, EAX <span class="hljs-comment"><span class="hljs-comment">// Self,   TGeneratorContext jmp SwitchContext end;</span></span></code> </pre><br><br>  After the generator function is completed, the execution will be passed to this procedure, since its address is in the stack below everything, forcing the function, upon reaching the ret instruction, return back here to complete the generation. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorContext</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Return</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> pop ECX <span class="hljs-comment"><span class="hljs-comment">//    Self,   TGeneratorContext mov [ECX].TGeneratorBase.FFinished, 1 //  Finished := True lea ECX, [ECX].TGeneratorBase.Context //    Context. jmp SwitchContext //     end;</span></span></code> </pre><br><br>  Only a small utility function remains, which receives the value of the flag register: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFlags</span></span></span><span class="hljs-function">:</span></span> NativeInt; <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> pushfd pop EAX <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  Test the module better in the console application.  If you use the module in a windowed application, then you need to remove the output to the screen using WriteLn. <br><br><div class="spoiler">  <b class="spoiler_title">Full module code (including X86 / X64 assembler)</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> DCa.Generators; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Winapi.Windows; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MinStackSize = <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">16384</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TNativeUIntArray = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span> .. <span class="hljs-number"><span class="hljs-number">65535</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> NativeUInt; PNativeUIntArray = ^TNativeUIntArray; TGeneratorWithParam&lt;ParamT, ResultT&gt; = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; TGeneratorFunction&lt;ParamT, ResultT&gt; = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Generator: TGeneratorWithParam&lt;ParamT, ResultT&gt; )</span></span></span><span class="hljs-function">;</span></span> PGeneratorContext = ^TGeneratorContext; TGeneratorContext = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SP: NativeUInt; Stack: PNativeUIntArray; StackLen: NativeUInt; Generator: TObject; Active: Boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Input: NativeUInt = 0 )</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Leave</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Return</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TGeneratorBase = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Context: TGeneratorContext; FFinished: Boolean; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TGeneratorWithParam&lt;ParamT, ResultT&gt; = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>( TGeneratorBase ) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> FFunc: TGeneratorFunction&lt;ParamT, ResultT&gt;; FValue: ResultT; FParam: ParamT; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Yield</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: ResultT )</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrent</span></span></span><span class="hljs-function">:</span></span> ResultT; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveNext</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Current: ResultT <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> GetCurrent; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">:</span></span> TGeneratorWithParam&lt;ParamT, ResultT&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func: TGeneratorFunction&lt;ParamT, ResultT&gt;; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Param: ParamT )</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func: TGeneratorFunction&lt;ParamT, ResultT&gt; )</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Param: ParamT <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FParam; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Value: ResultT <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FValue; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TGenerator&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>( TGeneratorWithParam&lt;T, T&gt; ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Generator: TGeneratorWithParam&lt;UInt64, UInt64&gt; )</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFlags</span></span></span><span class="hljs-function">:</span></span> NativeInt; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Generator: TGeneratorWithParam&lt;UInt64, UInt64&gt; )</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> V1, V2, V: UInt64; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> WriteLn( <span class="hljs-string"><span class="hljs-string">'Fib Enter'</span></span> ); V1 := <span class="hljs-number"><span class="hljs-number">1</span></span>; V2 := <span class="hljs-number"><span class="hljs-number">1</span></span>; V := V1 + V2; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> Generator.Yield( V ) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ( V &gt;= V2 ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> V1 := V2; V2 := V; V := V1 + V2; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; WriteLn( <span class="hljs-string"><span class="hljs-string">'Fib Exit'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFlags</span></span></span><span class="hljs-function">:</span></span> NativeInt; <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF CPUX86}</span></span> pushfd pop EAX <span class="hljs-meta"><span class="hljs-meta">{$ELSE}</span></span> pushfq pop RAX <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func: TGeneratorFunction&lt;ParamT, ResultT&gt;; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Param: ParamT )</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFunc := Func; FParam := Param; Context.Generator := Self; Context.Stack := VirtualAlloc( <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, MinStackSize, MEM_RESERVE <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> MEM_COMMIT, PAGE_READWRITE ); Context.StackLen := MinStackSize <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> SizeOf( NativeUInt ); <span class="hljs-meta"><span class="hljs-meta">{$IFDEF DEBUG}</span></span> FillChar( Context.Stack^, Context.StackLen * SizeOf( NativeUInt ), $DD ); <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span> Context.SP := NativeUInt( @Context.Stack^[Context.StackLen - <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF CPUX64}</span></span> - <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-meta"><span class="hljs-meta">{$ENDIF}</span></span>] ); Context.Stack^[Context.StackLen - <span class="hljs-number"><span class="hljs-number">4</span></span>] := GetFlags; Pointer( Context.Stack^[Context.StackLen - <span class="hljs-number"><span class="hljs-number">3</span></span>] ) := @Func; Pointer( Context.Stack^[Context.StackLen - <span class="hljs-number"><span class="hljs-number">2</span></span>] ) := @TGeneratorContext.Return; Pointer( Context.Stack^[Context.StackLen - <span class="hljs-number"><span class="hljs-number">1</span></span>] ) := Self; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func: TGeneratorFunction&lt;ParamT, ResultT&gt; )</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Create( Func, <span class="hljs-keyword"><span class="hljs-keyword">Default</span></span> ( ParamT ) ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FFinished <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Stop; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; VirtualFree( Context.Stack, <span class="hljs-number"><span class="hljs-number">0</span></span>, MEM_RELEASE ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrent</span></span></span><span class="hljs-function">:</span></span> ResultT; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">:</span></span> TGeneratorWithParam&lt;ParamT, ResultT&gt;; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := Self; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveNext</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Context.Active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Context.Active := True; Context.Enter( NativeUInt( Self ) ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Context.Enter( Ord( True ) ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FFinished; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFinished := True; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Context.Active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Context.Enter( Ord( False ) ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGeneratorWithParam</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParamT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultT</span></span></span><span class="hljs-function">&gt;.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Yield</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value: ResultT )</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FValue := Value; Context.Leave; Result := <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FFinished; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TGeneratorContext }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SwitchContext</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> <span class="hljs-meta"><span class="hljs-meta">{$IFDEF CPUX86}</span></span> pushfd <span class="hljs-comment"><span class="hljs-comment">//EFLAGS push EBX push EBP push ESI push EDI // xchg ESP, dword ptr [ECX].TGeneratorContext.&amp;SP // pop EDI pop ESI pop EBP pop EBX popfd //EFLAGS {$ELSE} pushfq //EFLAGS push RBX push RBP push RSI push RDI push R10 push R11 push R12 push R13 push R14 push R15 // xchg RSP, qword ptr [RDX].TGeneratorContext.&amp;SP // pop R15 pop R14 pop R13 pop R12 pop R11 pop R10 pop RDI pop RSI pop RBP pop RBX popfq //EFLAGS {$ENDIF} end; procedure TGeneratorContext.Enter( Input: NativeUInt ); asm {$IFDEF CPUX86} mov ECX, EAX mov EAX, EDX jmp SwitchContext {$ELSE} mov RAX, RDX mov RDX, RCX mov RCX, RAX jmp SwitchContext {$ENDIF} end; procedure TGeneratorContext.Leave; asm {$IFDEF CPUX86} mov ECX, EAX jmp SwitchContext {$ELSE} mov RDX, RCX jmp SwitchContext {$ENDIF} end; procedure TGeneratorContext.Return; asm {$IFDEF CPUX86} pop ECX mov [ECX].TGeneratorBase.FFinished, 1 lea ECX, [ECX].TGeneratorBase.Context jmp SwitchContext {$ELSE} pop RDX mov [RDX].TGeneratorBase.FFinished, 1 lea RDX, [RDX].TGeneratorBase.Context jmp SwitchContext {$ENDIF} end; initialization finalization end.</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/157777/">https://habr.com/ru/post/157777/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../157763/index.html">IEC60027-2: Let's use standards, or 1024 B == 1 KiB && 1024 B! = 1 KB && 1000 B == 1 kB</a></li>
<li><a href="../157765/index.html">Office will still be released for iOS and Android</a></li>
<li><a href="../157771/index.html">Yandex Browser 1.1: with Turbo technology from Opera Software</a></li>
<li><a href="../157773/index.html">Nokia Lumia 920 for $ 450 ?!</a></li>
<li><a href="../157775/index.html">Keyboard, idea, two hands</a></li>
<li><a href="../157781/index.html">Kinect will be able to model objects</a></li>
<li><a href="../157783/index.html">Access to variables Thread local storage (TLS) of any thread</a></li>
<li><a href="../157785/index.html">We bypass protection management-plane</a></li>
<li><a href="../157787/index.html">Big Three M2M Solutions</a></li>
<li><a href="../157791/index.html">Adobe Edge Animation, Chrome 23 and Brain Promotions Post</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>