<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Porting code to iOS / Android mobile devices</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What do you think is more attractive: to face new interesting problems and develop nontrivial algorithms or to rewrite existing logic from one languag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Porting code to iOS / Android mobile devices</h1><div class="post__text post__text-html js-mediator-article">  What do you think is more attractive: to face new interesting problems and develop nontrivial algorithms or to rewrite existing logic from one language to another and fight with strange features of specific APIs?  I have been working on mobile development for 8 years already, and, without hesitation, I choose the first option, but I also like to make war with the API.  Those who agree with me, but still do not know how to do the first and minimize the second, it will be interesting to look under the cat. <br><br><a name="habracut"></a>  In this article I will share with you my thoughts on the general principles of porting.  We will not get into the jungle of specific software implementations of applications for Android or iOS.  I'll just try to tell you how to make the application easily transferred to various devices and could be called cross-platform. <br><br><h4>  Action plan </h4><br>  To begin, we define a range of tasks.  In this article, we will not affect embedded systems, which, of course, also work for the benefit of mobile technology.  We will consider only modern mobile devices: phones and tablets.  The first part of the article will be devoted to the architecture of modern mobile processors and restrictions, and vice versa, the features that the mobile developer receives from them.  In the second part I will talk about some basic techniques that are necessary for writing portable code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  CPU </h4><br>  Not so long ago, about five years ago, there were a lot of different companies that produced mobile processors with their own architectures.  However, now the main architecture can be counted on the fingers of one hand, and there will still be a reserve.  First of all, it is ARM.  In addition to it, there are MIPS, which are usually included in the Java NDK, and Intel with its Atom. <br><br>  All the methods discussed below are applicable to all of these systems.  But for convenience, we consider them on the example of the most common ARM-processors.  What do we need to know about them? <br><br><ul><li>  from a commercial point of view: <b>kernel licensing</b> .  You can buy a license and create your processor. </li><li>  from a technological point of view: system on chip <b>(System On Chip)</b> .  All modules are collected in one place. </li><li>  from the point of view of the software developer: a powerful <b>RISC-architecture</b> </li></ul><br><br><h5>  Licensing </h5><br>  ARM itself does not release processors, it sells a release license, and various firms (Samsung, LG, Broadcom, Apple, Qualcomm, Freescale) buy licenses and release their own versions of processors, single-core or multi-core - which ones they like. <br>  What does licensing give?  You do not just take the core, you make your processor.  You can refine it: to improve it or, on the contrary, to simplify it is your right.  A history example is a famous Intel with an <a href="http://www.marvell.com/application-processors/pxa-family/">XScale processor</a> .  They bought a license for ARMv5TE and seriously reworked it.  In my opinion, this is the most successful of the existing processing.  They improved the work with memory, increased the cache, and, if we compare the implementation of Intel and Samsung based on ARMv5TE, then Intel won times, probably two times.  The main feature of this processor was the fact that a 40-bit battery coprocessor first appeared in it, which allowed multiplying with 4 numbers in 1 clock cycle, while the older ones had the Wireless MMX coprocessor, which provides a powerful set of SIMD instructions <br><br><h5>  System on chip </h5><br>  From an engineer‚Äôs point of view, what is a system on a chip?  This is a small microprocessor, on which a bunch of different devices.  You buy a license from ARM, put there one, two-as you want cores.  Additional coprocessors (graphics, DSP, etc.), memory (ROM, FLASH ...) In addition, I / O interfaces are usually inserted there: Ethernet, USB, COM ports, if necessary.  In order to make all this go to work, oscillators and timers are added to the same crystal in order not to make additional strapping by separate blocks onto the board. <br><img src="https://habrastorage.org/storage2/b24/e70/46f/b24e7046f67a697f24ddd59b57c43a01.png"><br>  The implementation of the system on a chip has become possible for ARM, because this system has very few transistors compared to the same Pentium.  Because of this, it takes up little space on the chip, and technologically it turns out to contain everything that the developers want.  It is unlikely that we would have managed to fit all these units in Core i5 - if only because it is large in itself and with a large heatsink (since there are many transistors and they all get very hot). <br><br><h5>  RISC architecture </h5><br>  Consider the features of architecture that are important for developers. <br><br><ul><li>  First of all, it is a <b>load / store architecture</b> .  All operations are performed with registers: loaded - calculated - unloaded, and nothing else.  Cannot perform an operation with operand in memory. </li><li>  To support work with registers, the kernel has a large register file - <b>16 registers of 32 bits each</b> .  They are, in principle, equivalent.  Some, of course, have specialized names that seem to hint at their purpose, but all operations are available to you with reference to any register. </li><li>  <b>Fixed length commands</b> .  In ARM mode, this is usually 32 bits: 1 command - 1 word, one after another.  The conveyor to this fact is certainly pleased, because nothing changes, everything is predictable. </li><li>  One of the features of ARM is the ability to not only handle memory offset, but also read and load from memory with pre-increment, post-increment with shift in a register or directly in numeric form.  <b>Powerful address commands</b> - one of the most important features of ARM </li><li>  All <b>operations tend to be completed in 1 clock</b> .  Maybe more or less - these are nuances for different cores. </li><li>  Another great ARM chip is <b>conditional execution</b> .  When you write instructions (arithmetic, or just check the flag), you have flags, and the following operations are performed only if the condition is met.  Accordingly, you do not need to make large transitions.  It is very convenient: it does not reset the conveyor, while increasing productivity. </li><li>  <b>Fast shift</b>  ARM allows you to perform shift arithmetic: you can write a + = (j &lt;&lt; 2);  in one command, which will be executed in one clock. </li></ul><br><br><h4>  ARM family </h4><br><img src="https://habrastorage.org/storage2/327/0b5/0d5/3270b50d5f0d8b7ff9d7334d844b528d.jpg"><br>  As the ARM family developed and progressed: <br><ul><li>  <b>ARM9</b> will be considered basic.  This is the past, although it is used, but not in modern phones. </li><li>  <b>ARM9E</b> is still found in Android, and this must be taken into account.  In ARM9E appeared DSP-instructions, which made it possible to greatly accelerate the voice processing algorithms. </li><li>  The core of the <b>ARM10</b> has gone almost unnoticed. </li><li>  On the basis of the <b>ARM11</b> various devices came out, but the most significant device was the first iPhone.  An innovation here is the emergence of SIMD instructions, albeit weaker than Intel's Wireless MMX in XScale. </li><li>  <b>Cortex</b> is the most common core today.  This may be a multi-core Cortex A9 system or a single-core Cortex A8, but they have the same architecture - ARMv7.  Here ARM made a small revolution called NEON.  This is a separate coprocessor, which may not be on the chip, even though it is included in the ARMv7 architecture.  A feature of NEON is the presence of 64-bit and 128-bit commands that provide parallel addition, subtraction, translation, and saturation.  It is here that ARM has a full-fledged SIMD, which provides acceleration in processing digital signals. </li><li>  ARM has announced "our bright future" - 64-bit <b>Cortex-A50</b> core with ARMv8 architecture.  They promise full compatibility with everything that happened before in a separate 32-bit mode. </li></ul><br><br><h5>  Thumb </h5><br>  I would like to dwell separately on the last row of the table from the previous paragraph.  What is Thumb?  Initially it was a set of packaged ARM instructions.  If we choose the second between speed and compactness of the code, then short 16-bit instructions with limited functionality are an excellent solution. <br><br>  Thumb2 is an evolution of Thumb.  It includes part of the ARM instructions, and consists of a set of 16-bit and 32-bit instructions designed to ensure the density of the code in Thumb and at the same time preserve the performance of a full-fledged ARM. <br><br><h4>  Cross platform </h4><br>  I will take the liberty to define cross-platform: ‚ÄúA cross-platform code can be considered a code for which the cost of transferring to another system is much less than the cost of writing this code from scratch.‚Äù  That is, we do not call porting the situation "I have some kind of algorithm, I want to do the same on iOS - accordingly, I have to write the same for this platform."  This is not porting, this is writing again.  To port an algorithm, it must meet the conditions of cross-platform. <br><br>  I define the principles of writing cross-platform code as ‚Äúseparation and unification‚Äù.  I will try to explain what it is.  These items are not postulates, this is my vision. <br><ol><li>  First of all, <b>uniform typing</b> - it is important to write code in its single types, since native native types may differ on different platforms </li><li>  Separation of code into algorithmic and non-algorithmic part.  The <b>system calls and basic operations are</b> pulled from the algorithms. </li><li>  <b>The device-dependent part</b> : we divide the program into an algorithmic part (mathematics) and into what depends on the system </li></ol><br><br>  Let us consider each item in more detail. <br><br><h5>  Uniform typing </h5><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_MSC_VER) typedef signed char int8_t; typedef signed short int16_t; typedef signed int int32_t; typedef signed __int64 int64_t; typedef unsigned char uint8_t; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef unsigned __int64 uint64_t; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(LINUX_ARM) typedef signed char int8_t; typedef signed short int16_t; typedef signed int int32_t; typedef signed long long int64_t; typedef unsigned char uint8_t; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef unsigned long long uint64_t; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #endif</span></span></span></span></code> </pre> <br>  What do I mean by uniform typing?  You simply define your types.  The above example describes stdint.  It is defined for the Microsoft compiler and for Linux.  If you want more control, you can write ‚Äúmy_love_int8‚Äù, ‚Äúmy_love_int16‚Äù and then use these types in your program.  This helps a lot, for example, if you work with a network: you are always sure that all packages are int16, the distance between them is 0, the offset is different and nothing else.  After all, if you define everything through char, which suddenly becomes two-byte, everything will go somewhere wrong. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkStatistics</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> currentBufferSize; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> preferredBufferSize; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> currentPacketLossRate; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> currentDiscardRate; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> currentExpandRate; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> currentPreemptiveRate; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> currentAccelerateRate; };</code> </pre><br><br>  Also, to simplify reading and writing code dependent on the platform / compiler / version of the language, it is very useful to introduce your own unified defaults.  such as: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(__APPLE__) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> TARGET_OS_IPHONE # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_OS_IOS # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(TARGET_IPHONE_SIMULATOR) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_OS_IOS # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_OS_IOS_SIMULATOR # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(TARGET_OS_MAC) || defined (__OSX__) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_OS_MACOSX # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_OS_MACOSX # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(_WIN64) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_OS_WIN64 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_OS_WINDOWS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> _WIN32 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_OS_WIN32 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_OS_WINDOWS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> ANDROID # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_OS_ANDROID #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> Unsupported OS target! #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_M_X64) || defined(__x86_64__) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_ARCH_X86_FAMILY # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_ARCH_64_BIT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(__ARMEL__) || defined(__arm) || defined(_M_ARM_FP) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_ARCH_ARM_FAMILY # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_ARCH_32_BIT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(__ppc__) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_ARCH_PPC_FAMILY # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAILRU_ARCH_32_BIT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> Please add support for your architecture in typedefs.h #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br><h5>  Algorithms </h5><br>  In my practice there were a lot of heavy algorithms, such as voice and video codecs.  For ease of porting, it is desirable that the algorithm does not use any system functions, and even better to do without system libraries. <br><br><h5>  System calls </h5><br>  One of the basic principles of writing portable and managed code is not to use malloc inside algorithms.  Your algorithm should determine how much memory it will need, transfer this value to your memory manager, who already allocates memory and gives a reference to the allocated chunk during initialization.  The algorithm uses this piece.  Happiness and harmony. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Interface int32 MyAlgorithm_GetMemSizeNeed() int32 MyAlgorithm_Init(void *memory) void *MyAlgorithm_Destroy() // Using { void *m = MyManager_GetMem(MyAlgorithm_GetMemSizeNeed()); MyAlgorithm_init(m); //... m = MyAlgorithm_Destroy(); MyManager_FreeMem(m); }</span></span></code> </pre><br><br>  What happens when your algorithm allocates memory itself?  If you often create and kill processes, and many more algorithms, they begin to allocate and free memory randomly, then memory fragmentation begins.  This leads to the fact that at some point you simply can not allocate the required amount of memory, even if the total amount of free memory is more than you need.  RAM is still a fairly expensive resource, especially on mobile devices. <br>  By the same principle, it is desirable to allocate other system functions. <br><br><h5>  Basic operations </h5><br>  Under the basic operations means the selection of such non-specific operations that are not in C, but which you use often. <br><br>  Consider a simple CLZ (Count Leading Zeros) operation.  There is no such operation in C, and if necessary, you can write an algorithm for counting zeros.  The point is that in some processors, in particular in ARM, it is implemented at the hardware level.  In these cases, we calmly use what we have.  For this, the compiler may have an intrinsic function.  If the compiler does not implement such a function (as in our example, the implementation of GCC), you can put an assembler operation.  For those processors in which this operation is not implemented, you will have to write a separate code.  However, this is still a basic operation.  What is good?  You write a basic operation once, call it in your code, and if you need to port, you simply write a unit test, port this operation, check the result with a unit test.  If everything is OK, then the code you use will also be OK. <br><br><img src="https://habrastorage.org/storage2/844/f2f/44c/844f2f44cc25d921549809dd6050578b.jpg"><br><br><h6>  Unseen circumstances </h6><br>  To demonstrate the need to highlight the basic operations, I would give a seemingly simple example: a shift for int64.  In principle, this command is in C, but it can be implemented differently, since it is not a standard int, but int64.  Int64 in different systems are differently called, but this is half the problem.  The biggest trouble is that they can also be performed in different ways. <br><br><h6>  Example: uint64 &gt;&gt; n </h6><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> LogicalShiftRigth(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> number, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shift) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number &gt;&gt; shift; } <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> test = <span class="hljs-number"><span class="hljs-number">0x1234567812345678</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> res63 = LogicalShiftRigth(test, <span class="hljs-number"><span class="hljs-number">63</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> res64 = LogicalShiftRigth(test, <span class="hljs-number"><span class="hljs-number">64</span></span>);</code> </pre><br><br>  Consider a basic operation called logical shift right.  There is a number that needs to be shifted by 63 and by 64. These are the boundary values.  As is known, it is the boundary values ‚Äã‚Äãthat bring the most trouble.  What will be in res63 and res64?  The idea should be zeros.  But in fact, everything is not so simple. <br><br><img src="https://habrastorage.org/storage2/333/21a/b72/33321ab72b0fce3c60629116005f4635.jpg"><br><br>  Depending on the bitness of the platform, we get different results, although everything is done thoroughly and according to the rules.  That is why it is better to allocate controversial things to the basic operators and when porting separately do tests on them. <br><br><h5>  Hardware dependent parts </h5><br><br>  The hardware-dependent parts of the mobile application have the following features: <br><br><ul><li>  Strongly depend on <b>API frameworks</b> , whether it be Android, iOS or something else. </li><li>  Often use <b>non-native means</b> .  For example, the code that uses video in Android can have this algorithm: the engine is written in C. It calls Java via JNI, which then returns the result via JNI. </li><li>  Use <b>less portable languages</b> .  For less portable languages, I refer, for example, Objective C and Java.  Despite the fact that Java is considered a cross-platform language, it is clearly lacking in comparison with C universality. </li></ul><br><br><h5>  Base Wrappers </h5><br><br>  In order to somehow unify the work with hardware-dependent parts of the code, it will be a good practice to single out a set of basic wrappers.  I will offer my version of the list of wrappers. <br><br><ul><li>  <b>System log</b>  Normal printf () helps a lot with development.  Each platform has its own frameworks;  for example, for iOS it could be NSLog, for Android - Logcat. </li><li>  <b>Memory manager</b> .  As we‚Äôve already figured out, it‚Äôs better to have your own memory manager, which makes malloc / free.  In addition, you can teach him to look for memory leaks. </li><li>  <b>Mutexes / atomic operations</b> also have different implementations in different systems. </li><li>  <b>The thread manager</b> is an add-on for mutexes and the main API for creating a multi-threaded application. </li><li>  <b>System information</b> can be useful if you change something in runtime.  If your code is optimized for multiple processors, you can in the runtime find out what the system is and connect the necessary part. </li><li>  <b>Tracing / logging</b> is no longer just a system log;  it's debugging bugs, and it's great if it is the same for all platforms. </li><li>  <b>Working with files</b> involves <b>file</b> I / O, .pm dumps, and so on.  It is very convenient to have output through a single interface. </li><li>  <b>Profiling tools</b> .  If you have a heavy code, standard means can not always quickly figure out what is lost and where.  You can, of course, use the native tools of each specific platform, or you can write your own cross-platform clock, log, and so on, and call them in the code. </li></ul><br><br><h5>  Additional Wrappers </h5><br><br>  Depending on what the device does, you may need additional wrappers.  Here is a brief list of hardware parts that make it necessary to use wrappers (they are necessary for porting to go smoothly). <br><br><ul><li>  Sockets / Networking </li><li>  Audio devices </li><li>  Video devices </li><li>  Input device </li></ul><br><br><h4>  Subtotal </h4><br><br><img src="https://habrastorage.org/storage2/0c0/c02/1e5/0c0c021e59fe673c07805afb49340e18.jpg"><br><br>  Following all the above recommendations, we get an algorithm that is written through the same types that you transfer.  This algorithm does not require any intervention at all.  In theory, it should compile and earn immediately.  It is better to have unit tests for it.  If the algorithm is compiled and tested, then most likely everything will be fine.  Basic operations are also ported, but they may not be. <br><br>  Hardware parts already require porting.  And it is better that they have an interface as close as possible to the system.  They will be easier to check, and they are faster ported. <br><br><h3>  Attention! </h3><br><br>  Finally, I would like to give some general recommendations: what you should pay attention to when writing portable code. <br><br><ul><li>  <b>Memory data / code.</b>  Remember, in mobile memory devices, a lot does not happen.  She is always a little, and the one that is, constantly trying to sneak off somewhere, is to give her freedom.  Therefore, it is better to have your own memory manager to avoid fragmentation.  In addition, it is desirable that the code be small: if ARM-specific operations are not critical for you, it is better to use Thumb2. </li><li>  <b>Data alignment</b>  Prior to ARMv7, ARM architectures did not support access to unaligned data.  But even after such behavior became possible, this operation causes an additional idle processor to operate.  So it is better to align the memory along the int border, and even better along the cache boundary: this will provide you with a quick load. </li><li>  <b>Optimization for the processor.</b>  If you have heavy algorithms, especially voice and video, without optimization, nothing will work for you.  And if it suddenly takes off, it will quickly devour the entire battery. </li><li>  <b>Floating point</b>  By default, there is no floating point on ARM.  Now in the Cortex unit appeared NEON, it implements floating point operations, but, again, not in all devices.  If about smartphones running iOS it is known that there is always a floating point there, then manufacturers of Android devices may refuse it in order to save it.  Therefore, in the case of Android, Get CPU Features will help us, where there is a floating point check. </li><li>  <b>Integer division.</b>  With it, things are the same as with floating point: not all kernels can divide int into int, and this should be remembered. </li><li>  <b>Multithreading and MainThread.</b>  If your application is not multi-threaded - make it multi-threaded.  Loading UI in mobile applications is a terrible thing: with a single-threaded implementation, a wide range of effects are possible, from brakes to crash of an application.  If you already have a multi-threaded system, pay attention to MainThread, because many things must be executed only from it. </li></ul><br><br><h3>  Small total </h3><br><br><ol><li>  First, understanding the processor architecture improves porting quality. </li><li>  Second: the key to successful porting is a good cross-platform code.  That is, the less time you spend rewriting existing code, the better, faster and cheaper.  Everyone will be happy, especially the manager. </li><li>  And third: the simplicity of code portability is determined by the well-thought-out architecture.  So if you are writing a new application, think of it as cross-platform from the very beginning.  Even if you do not plan to endure it, maybe someone else will have to do this. </li></ol><br>  If you want to see a good example of the implementation of cross-platform code, I advise you to pay attention to libjingle.  Almost all of the postulates discussed in this article are performed there. <br><br>  If you know how to make porting the code even easier or you want to discuss some of the points I have outlined in more detail, I‚Äôll be happy to talk to you in the comments. </div><p>Source: <a href="https://habr.com/ru/post/182506/">https://habr.com/ru/post/182506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182482/index.html">Waiting for new MacBook Pro Retina or thinking about integrated graphics</a></li>
<li><a href="../182488/index.html">Can I cash in on users? 3 easy ways to increase application monetization</a></li>
<li><a href="../182494/index.html">Microsoft released another set of updates, June 2013</a></li>
<li><a href="../182502/index.html">High Availability Optical Ring</a></li>
<li><a href="../182504/index.html">IT infrastructure health metrics, thresholds and users of IT services</a></li>
<li><a href="../182508/index.html">Experiments with VMware</a></li>
<li><a href="../182512/index.html">Ekovozhdeniye with the new Cellocator IQ 50 terminal: a practical overview</a></li>
<li><a href="../182516/index.html">New chipsets from Texas Instruments will speed up charging time and increase battery life for smartphones and tablets</a></li>
<li><a href="../182518/index.html">How to make qmake always rebuild a project from scratch when changing macros</a></li>
<li><a href="../182520/index.html">Indexing nonatomic attributes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>