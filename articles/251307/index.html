<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>node-seq in a new way (again about asynchrony)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! I am writing to you as a slop. Indeed, while spacecraft with vertical takeoff and landing travel through the oceans, and the most impatie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>node-seq in a new way (again about asynchrony)</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habr!  I am writing to you as a slop.  Indeed, while spacecraft with vertical takeoff and landing travel through the oceans, and the most impatient are using features of ES6 in their projects, I brought you another library to facilitate the life of the asynchronist. <br><a name="habracut"></a><br>  Of course, there are a million promises realized for a long time, and async for those who want it.  There is also, well-known in narrow circles, the <a href="https://github.com/substack/node-seq">Seq</a> library from the notorious fellow Substack.  I started using it practically from the first days of my javascript and used it wherever I could.  The approach proposed by this library seems to me more understandable and logical for curbing asynchronous noodles than the approach used, for example, in async.  See for yourself: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Hash = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'hashish'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Seq = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'seq'</span></span>); Seq() .seq(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ fs.readdir(__dirname, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }) .flatten() .parEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function">) </span></span>{ fs.stat(__dirname + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + file, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.into(file)); }) .seq(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sizes = Hash.map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.size }) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.dir(sizes); });</code> </pre> <br>  Everything is so simple and clear that even explaining laziness.  Unfortunately, the library has not been developed or supported for a long time.  In addition, during the time I used it, I got a list of bugs that somehow stumbled upon, a list of features I wanted, a list of complaints - because not everything worked as well as in my imagination.  Once, I once again stumbled upon the incoherence of the world and decided that this moment had come.  It's time to fork and fix.  I often do this, but what makes this library seem to me a real magic. <br><br>  So happy and determined to do git clone, cd, gvim, and try to understand what's going on here.  I do not understand.  The author uses a couple of his libraries and for enlightenment it is necessary to deal with them first.  After a couple of hours I get bored and I discover the Fatal Deficit.  No sooner said than done.  Sit down and write from scratch Library of Dreams.  Oddly enough, there was no magic in all this.  The prototype was ready for the evening.  Then, for some time, I finished using it in a real project, replacing it with Seq completely.  And so it turned out what happened.  Let's get acquainted. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>YAFF - Yet Another Flow Framework.</b> <br><br>  Overall, I tried to make it compatible with Seq.  And most of the code was migrated simply by replacing the import (it was var Seq = require ('seq'); it became var Seq = require ('yaff');).  Of course, I had to replace something else.  Seq uses the .catch () method to catch fleas.  For example, the above piece of code can be changed like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Hash = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'hashish'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Seq = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'seq'</span></span>); Seq() .seq(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ fs.readdir(__dirname, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }) .flatten() .parEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function">) </span></span>{ fs.stat(__dirname + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + file, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.into(file)); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">)(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> console.error(err</span></span></span><span class="hljs-function">); )) .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seq</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function (</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sizes = Hash.map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.size }) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.dir(sizes); });</code> </pre><br>  This construction is terrible because after we ‚Äúcaught‚Äù the error, we can continue.  You can not do it this way.  First, it is not clear what to do if parEach (or other similar methods) throw a few errors.  Catch only the first?  Catch all?  And if we have already gone far down and in some parEach the error popped up on the timer?  And if below we already have no catch?  And if those catch that below are not prepared for error handling which will come out on the timer from forEach?  There are many unanswered questions.  Therefore, I decided that in each YAFF there should be only one construction for error handling and it should be at the end.  And in order not to violate the nodejs traditions, let it process the result as well.  It turns out beauty.  Make sure: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); YAFF([<span class="hljs-string"><span class="hljs-string">'./'</span></span>, <span class="hljs-string"><span class="hljs-string">'../'</span></span>]) .par(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function">) </span></span>{ fs.readdir(path, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }) .par(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function">) </span></span>{ fs.readdir(path, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }) .flatten() .parMap(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function">) </span></span>{ fs.stat(__dirname + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + file, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stat.size; }) .unflatten() .finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, sizes</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e; log(sizes); });</code> </pre><br>  If we assume that this is all inside the asynchronous function, then in finally we can simply throw the callback provided to us, a la: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listDirs = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dirs, cb</span></span></span><span class="hljs-function">) </span></span>{ YAFF(dirs) [ ] .finally(cb); };</code> </pre><br>  Conveniently?  I like it too.  In general, this library is built on the concept of a stack-array of arguments (it was worth writing about it from the very beginning).  And all the methods that are here anyway, this stack is changed by applying to it or to its individual elements.  For example, a flock of functions wrapped in par will take one element from the stack, in the order in which these par are written and only after all par shoot callbacks (and the callback inside all this this methods) does YAFF go to what he has to do next the queue.  Suppose then that we have several functions wrapped in seq.  YAFF will apply the entire stack to them and replace it with something that returns a wrapped function to the callback.  Here is the code to make it clear: <br><br><pre> <code class="javascript hljs">YAFF([<span class="hljs-string"><span class="hljs-string">'one'</span></span>, <span class="hljs-string"><span class="hljs-string">'two'</span></span>, <span class="hljs-string"><span class="hljs-string">'three'</span></span>]) .par(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">one</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, one); }) .par(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">two</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, two); }) .par(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">three</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, three); }) .seq(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">one, two, three</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, one, three); }) .seq(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">one, three</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }) .seq(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">'and so on and so forth'</span></span>); })</code> </pre><br>  Of course, if someone calls his callback with a non-zero first argument (error), then YAFF will immediately spit on all the functions that still remain there, and go to do what is written in finally.  If you forgot to write finally or thought that there could be no error in your error code, then YAFF, in case of an error, will unceremoniously throw an exception.  So it is better to finally be. <br><br>  Still, there are all sorts of synchronous functions for working with the stack of arguments as with an array: push, pull, filter, set, reduce, flatten, extend, unflatten, empty, shift, unshift, splice, reverse, save (name), load (fromName ).  Fuf, like everything.  The names speak for themselves, but if that - do not hesitate to ask and look at the source.  There is one file ( <a href="">main.js</a> ) and everything is very simple. <br><br>  And, of course, for the sake of which everything was started - asynchronous functions for processing data arrays: forEach (YAFF will not wait for processing of this block to end, the results of this block will not affect the stack. YAFF immediately goes to the next handler in the chain), seqEach , parEach (YAFF will wait until all functions are fired, but the results will not affect the stack).  seqMap, parMap, seqFilter, parFilter - do what you expect;  YAFF waits for them to work and the results of the work of these blocks replace those values ‚Äã‚Äãthat were on the stack before.  In addition, all methods with the par prefix after the function, you can specify a number.  This number is the limit of simultaneously running asynchronous functions.  Something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resizePhotos(photos, cb) { YAFF(photos) .parMap(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">photo</span></span></span><span class="hljs-function">) </span></span>{ asyncReisze(photo.image, photo.params, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-number"><span class="hljs-number">10</span></span>) .unaflatten() .finally(cb); }</code> </pre><br>  In this example, we resynim a stack of photos asynchronously.  In order not to overload the server, we resize no more than 10 pictures simultaneously for each client.  unflatten is needed in order to collect photos spread over the stack into an array which will be one argument for callback. <br><br>  YAFF also has mseq and mpar methods - a nod to async users.  These methods accept an array of functions that will be executed sequentially or in parallel.  With the same success, you could write a bunch of seq () and par (), but sometimes you want to generate functions dynamically.  We still have a functional language, right? <br><br>  In order to completely confuse you, I came up with the following example and drew a picture (in desperate hope that it will clarify everything): <br><br><pre> <code class="javascript hljs">YAFF([<span class="hljs-string"><span class="hljs-string">'./'</span></span>]) .mseq([ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path1</span></span></span><span class="hljs-function">) </span></span>{ fs.readdir(path1, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, arg); } ]) .flatten() .parMap(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function">) </span></span>{ fs.stat(__dirname + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + file, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stat.size; }) .unflatten() .finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, sizes</span></span></span><span class="hljs-function">) </span></span>{ log(sizes); });</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Big picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/93d/830/af1/93d830af1412466ba41d515fae3165c8.png"><br></div></div><br>  I hope that I was able to clearly explain what I wanted;  you are imbued with the idea and I'm not the only one who does not understand why you need async. <br><br>  All specific requests and suggestions are better arranged in the form of <a href="https://github.com/mynameisdaniil/yaff/issues">issues</a> (in English, do not hesitate - I also do not know it well, we will train literature together) on a githaba or even in the form <a href="https://github.com/mynameisdaniil/yaff/pulls">of pull requests</a> . <br><br>  Oh yeah, the library is on <a href="https://www.npmjs.com/package/yaff">npmjs.org</a> . <br><br>  PS Just now, in a fit of passion, added the synchronous method apply ‚Äî now all other synchronous methods can be thrown away.  But I will leave for convenience and compatibility. </div><p>Source: <a href="https://habr.com/ru/post/251307/">https://habr.com/ru/post/251307/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251295/index.html">Data compression methods</a></li>
<li><a href="../251297/index.html">Ekspozzer - creating a panorama from a video, averaging a video stream</a></li>
<li><a href="../251299/index.html">Lamp showing the weather forecast</a></li>
<li><a href="../251301/index.html">Administration of computers on the local network before loading the operating system</a></li>
<li><a href="../251303/index.html">16 months of functional programming</a></li>
<li><a href="../251309/index.html">IBM invites to the ‚ÄúSoftlayer Introduction‚Äù webinar</a></li>
<li><a href="../251311/index.html">Implementation of the universal aquarium controller</a></li>
<li><a href="../251313/index.html">Wi-Fi is good, but it is normal. Practice using Ruckus in the office</a></li>
<li><a href="../251315/index.html">Wordpress Benefits</a></li>
<li><a href="../251317/index.html">Excursion to the largest data center in Europe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>