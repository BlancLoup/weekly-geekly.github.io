<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JSON-RPC in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article about the declarative JSON serializer, I explained how using C ++ templates you can describe data structures and serialize the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JSON-RPC in C ++</h1><div class="post__text post__text-html js-mediator-article"><p>  In the previous <a href="https://habrahabr.ru/post/311262/">article</a> about the declarative JSON serializer, I explained how using C ++ templates you can describe data structures and serialize them.  This is very convenient, because  not only reduces the size of the code, but also minimizes the number of possible errors. The concept - if the code is compiled, then it works.  Approximately the same approach is applied in wjrpc, which will be discussed in this article.  But since wjrpc is ‚Äútorn out‚Äù from the framework under which it was designed for interfaces, I will also address the issues of architecture and asynchronous interfaces. </p><br><a name="habracut"></a><br><p>  I will not describe the JSON serializer on which wjrpc runs and with which the JSON description is implemented for message data structures.  I told about <a href="https://github.com/mambaru/wjson">wjson</a> in the previous article.  Before considering the declarative version of the description of the API services for JSON-RPC, consider how you can implement parsing in ‚Äúmanually‚Äù.  This will require writing more run-time code to extract data and checks, but it is easier to understand.  All examples can be found in the examples section of the project. </p><br><p>  As an example, consider the simple calculator API, which can perform addition, subtraction, multiplication, and division operations.  The queries themselves are trivial, so I‚Äôll only give the code for the addition operation: </p><br><div class="spoiler">  <b class="spoiler_title">calc / api / plus.hpp</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;functional&gt; namespace request { struct plus { int first=0; int second=0; typedef std::unique_ptr&lt;plus&gt; ptr; }; } // request namespace response { struct plus { int value=0; typedef std::unique_ptr&lt;plus&gt; ptr; typedef std::function&lt;void(ptr)&gt; callback; }; } // response</span></span></span></span></code> </pre> </div></div><br><p>  I prefer the structure for each pair of request-response to place in a separate file in a specially designated folder.  This makes it easier to navigate the project.  Using namespaces and defining auxiliary types, as shown in the example above, is not necessary, but increases the readability of the code.  The meaning of these typedefs will be explained later. </p><br><p>  For each request, create a JSON description. </p><br><div class="spoiler">  <b class="spoiler_title">calc / api / plus_json.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/plus.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjson/json.hpp&gt; #include &lt;wjson/name.hpp&gt; namespace request { struct plus_json { JSON_NAME(first) JSON_NAME(second) typedef wjson::object&lt; plus, wjson::member_list&lt; wjson::member&lt;n_first, plus, int, &amp;plus::first&gt;, wjson::member&lt;n_second, plus, int, &amp;plus::second&gt; &gt; &gt; type; typedef typename type::serializer serializer; typedef typename type::target target; }; } namespace response { struct plus_json { JSON_NAME(value) typedef wjson::object&lt; plus, wjson::member_list&lt; wjson::member&lt;n_value, plus, int, &amp;plus::value&gt; &gt; &gt; type; typedef typename type::serializer serializer; typedef typename type::target target; }; }</span></span></span></span></code> </pre> </div></div><br><p>  Why put it in a structure, I told in the article on wjson.  I will only note that here typedef definitions require that these structures be recognized as a json description. </p><br><p>  Processing JSON-RPC messages can be divided into two stages.  At the first stage, you need to determine the type of the request and the name of the method, and at the second, deserialize the parameters for this method. </p><br><div class="spoiler">  <b class="spoiler_title">Serialized JSON-RPC for plus</b> <div class="spoiler_text"><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>{ "jsonrpc":"2.0", "method":"plus", "params":{ "first":2, "second":3 }, "id":1 }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">source</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-comment"><span class="hljs-comment">&lt;!--&lt;/spoiler&gt;--&gt;</span></span> ,         : <span class="hljs-comment"><span class="hljs-comment">&lt;!--&lt;spoiler title="  "&gt;--&gt;</span></span> ```cpp struct request { std::string version, std::string method, std::string params, std::string id }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">JSON description for requests</b> <div class="spoiler_text"><pre> <code class="cpp hljs">JSON_NAME(jsonrpc) JSON_NAME(method) JSON_NAME(params) JSON_NAME(id) <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::object&lt; request, wjson::member_list&lt; wjson::member&lt;n_jsonrpc, request, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, &amp;request::version&gt;, wjson::member&lt;n_method, request, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, &amp;request::method&gt;, wjson::member&lt;n_params, request, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, &amp;request::params, json::raw_value&lt;&gt; &gt;, wjson::member&lt;n_id, request, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, &amp;request::id, json::raw_value&lt;&gt; &gt; &gt; &gt; request_json;</code> </pre> </div></div><br><p>  With this description, in the <code>request::params</code> and <code>request::id</code> fields, json will be copied as is, without any conversion, and the actual name of the <code>request::method</code> will be in the <code>request::method</code> field.  Having determined the name of the method, we can deserialize the parameters with the structures described above. </p><br><p>  To determine the name of a method, it is not necessary to deserialize the entire query into an intermediate data structure.  It is enough to parse it, and deserialize only the query piece belonging to the params field.  This can be done using wjson :: parser directly, but wjson also provides the raw_pair construction (I did not consider it in the previous article), which will not deserialize the elements, but remember its location in the input buffer.  Consider how this is implemented in wjrpc. </p><br><p>  To begin with, wjrpc does not work with std :: string strings, but defines the following types: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> wjrpc { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; data_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;data_type&gt; data_ptr; }</code> </pre> <br><p>  You can consider data_ptr as a relocatable buffer, the use of which allows us to guarantee that the data will not be copied over again. </p><br><p>  Any incoming wjrpc message will attempt to deserialize into the following structure: </p><br><div class="spoiler">  <b class="spoiler_title">wjrpc :: incoming</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> wjrpc { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">incoming</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> data_type::iterator iterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;iterator, iterator&gt; pair_type; pair_type method; pair_type params; pair_type result; pair_type error; pair_type id; }; }</code> </pre> </div></div><br><p>  All wjrpc :: incoming elements are pairs of iterators in the input buffer.  For example, method.first, when deserializing, will point to a quotation mark that opens the name of the method, after the colon, in the input request, and method.second to the next position after the closing quotation mark.  This structure also describes not only the request, but also the response to the request as well as an error message.  Determine the type of message simply by filling in the fields.  JSON is the description for this structure: </p><br><div class="spoiler">  <b class="spoiler_title">wjrpc :: incoming_json</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> wjrpc { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">incoming_json</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> incoming::pair_type pair_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::iterator_pair&lt;pair_type&gt; pair_json; JSON_NAME(id) JSON_NAME(method) JSON_NAME(params) JSON_NAME(result) JSON_NAME(error) <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjson::object&lt; incoming, wjson::member_list&lt; wjson::member&lt;n_method, incoming, pair_type, &amp;incoming::method, pair_json&gt;, wjson::member&lt;n_params, incoming, pair_type, &amp;incoming::params, pair_json&gt;, wjson::member&lt;n_result, incoming, pair_type, &amp;incoming::result, pair_json&gt;, wjson::member&lt;n_error, incoming, pair_type, &amp;incoming::error, pair_json&gt;, wjson::member&lt;n_id, incoming, pair_type, &amp;incoming::id, pair_json&gt; &gt; &gt; type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> type::target target; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> type::member_list member_list; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> type::serializer serializer; }; }</code> </pre> </div></div><br><p>  There is no full-fledged deserialization here - this is essentially parsing with remembering positions in the input buffer.  Obviously, after such a deserialization, the data will be valid only as long as the input buffer exists. </p><br><p>  The wjrpc :: incoming_holder class captures the buffer with the request and parses it into the structure described above.  I will not describe in detail its interface, but I will show how you can use it to implement JSON-RPC. </p><br><div class="spoiler">  <b class="spoiler_title">First a simplified one method example.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/plus.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/plus_json.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjrpc/errors/error_json.hpp&gt; #include &lt;wjrpc/incoming/incoming_holder.hpp&gt; #include &lt;wjrpc/outgoing/outgoing_holder.hpp&gt; #include &lt;wjrpc/outgoing/outgoing_result.hpp&gt; #include &lt;wjrpc/outgoing/outgoing_result_json.hpp&gt; #include &lt;wjrpc/outgoing/outgoing_error.hpp&gt; #include &lt;wjrpc/outgoing/outgoing_error_json.hpp&gt; #include &lt;iostream&gt; int main() { std::vector&lt;std::string&gt; req_list = { "{\"method\":\"plus\", \"params\":{ \"first\":2, \"second\":3 }, \"id\" :1 }", "{\"method\":\"minus\", \"params\":{ \"first\":5, \"second\":10 }, \"id\" :1 }", "{\"method\":\"multiplies\", \"params\":{ \"first\":2, \"second\":2 }, \"id\" :1 }", "{\"method\":\"divides\", \"params\":{ \"first\":9, \"second\":3 }, \"id\" :1 }" }; std::vector&lt;std::string&gt; res_list; for ( auto&amp; sreq : req_list ) { wjrpc::incoming_holder inholder( sreq ); //      inholder.parse(nullptr); //       if ( inholder.method() == "plus" ) { //     auto params = inholder.get_params&lt;request::plus_json&gt;(nullptr); //    wjrpc::outgoing_result&lt;response::plus&gt; res; res.result = std::make_unique&lt;response::plus&gt;(); //   res.result-&gt;value = params-&gt;first + params-&gt;second; //  id      auto raw_id = inholder.raw_id(); res.id = std::make_unique&lt;wjrpc::data_type&gt;( raw_id.first, raw_id.second ); //   typedef wjrpc::outgoing_result_json&lt;response::plus_json&gt; result_json; res_list.push_back(std::string()); result_json::serializer()( res, std::back_inserter(res_list.back()) ); } /* else if ( inholder.method() == "minus" ) { ... } */ /* else if ( inholder.method() == "multiplies" ) { ... } */ /* else if ( inholder.method() == "divides" ) { ... } */ } for ( size_t i =0; i != res_list.size(); ++i) { std::cout &lt;&lt; req_list[i] &lt;&lt; std::endl; std::cout &lt;&lt; res_list[i] &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; } }</span></span></span></span></code> </pre> </div></div><br><p>  Here, most of the code is the formation of the answer, because we do not check for errors.  First, we initialize the incoming_holder string and parse it.  At this stage, the input string is deserialized into the incoming structure described above.  If the string contains any valid json object, then this stage will pass without errors. </p><br><p>  Next you need to determine the type of request.  This is easily done by the presence or absence of the ‚Äúmethod‚Äù, ‚Äúresult‚Äù, ‚Äúerror‚Äù and ‚Äúid‚Äù fields. </p><br><table><thead><tr><th>  Combination </th><th>  Message type </th><th>  Check </th><th>  Receive </th></tr></thead><tbody><tr><td>  method and id </td><td>  request </td><td>  is_request </td><td>  get_params &lt;&gt; </td></tr><tr><td>  method without id </td><td>  notification </td><td>  is_notify </td><td>  get_params &lt;&gt; </td></tr><tr><td>  result and id </td><td>  response to a request </td><td>  is_response </td><td>  get_result &lt;&gt; </td></tr><tr><td>  error and id </td><td>  error in response to request </td><td>  is_request_error </td><td>  get_error &lt;&gt; </td></tr><tr><td>  error without id </td><td>  other errors </td><td>  is_other_error </td><td>  get_error &lt;&gt; </td></tr></tbody></table><br><p>  If none of the conditions are met, then it is obvious that the request is incorrect. </p><br><div class="spoiler">  <b class="spoiler_title">An example with checks and one method</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/plus.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/plus_json.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjrpc/errors/error_json.hpp&gt; #include &lt;wjrpc/incoming/incoming_holder.hpp&gt; #include &lt;wjrpc/outgoing/outgoing_holder.hpp&gt; #include &lt;wjrpc/outgoing/outgoing_result.hpp&gt; #include &lt;wjrpc/outgoing/outgoing_result_json.hpp&gt; #include &lt;wjrpc/outgoing/outgoing_error.hpp&gt; #include &lt;wjrpc/outgoing/outgoing_error_json.hpp&gt; #include &lt;iostream&gt; int main() { std::vector&lt;std::string&gt; req_list = { "{\"method\":\"plus\", \"params\":{ \"first\":2, \"second\":3 }, \"id\" :1 }", "{\"method\":\"minus\", \"params\":{ \"first\":5, \"second\":10 }, \"id\" :1 }", "{\"method\":\"multiplies\", \"params\":{ \"first\":2, \"second\":2 }, \"id\" :1 }", "{\"method\":\"divides\", \"params\":{ \"first\":9, \"second\":3 }, \"id\" :1 }" }; std::vector&lt;std::string&gt; res_list; for ( auto&amp; sreq : req_list ) { wjrpc::incoming_holder inholder( sreq ); wjson::json_error e; inholder.parse(&amp;e); if ( e ) { typedef wjrpc::outgoing_error&lt;wjrpc::error&gt; error_type; error_type err; err.error = std::make_unique&lt;wjrpc::parse_error&gt;(); typedef wjrpc::outgoing_error_json&lt;wjrpc::error_json&gt; error_json; std::string str; error_json::serializer()(err, std::back_inserter(str)); res_list.push_back(str); } else if ( inholder.is_request() ) { auto raw_id = inholder.raw_id(); auto call_id = std::make_unique&lt;wjrpc::data_type&gt;( raw_id.first, raw_id.second ); //       if ( inholder.method() == "plus" ) { auto params = inholder.get_params&lt;request::plus_json&gt;(&amp;e); if ( !e ) { wjrpc::outgoing_result&lt;response::plus&gt; res; res.result = std::make_unique&lt;response::plus&gt;(); res.result-&gt;value = params-&gt;first + params-&gt;second; res.id = std::move(call_id); typedef wjrpc::outgoing_result_json&lt;response::plus_json&gt; result_json; std::string str; result_json::serializer()( res, std::back_inserter(str) ); res_list.push_back(str); } else { typedef wjrpc::outgoing_error&lt;wjrpc::error&gt; error_type; error_type err; err.error = std::make_unique&lt;wjrpc::invalid_params&gt;(); err.id = std::move(call_id); typedef wjrpc::outgoing_error_json&lt;wjrpc::error_json&gt; error_json; std::string str; error_json::serializer()(err, std::back_inserter(str)); res_list.push_back(str); } } /* else if ( inholder.method() == "minus" ) { ... } */ /* else if ( inholder.method() == "multiplies" ) { ... } */ /* else if ( inholder.method() == "divides" ) { ... } */ else { typedef wjrpc::outgoing_error&lt;wjrpc::error&gt; error_type; error_type err; err.error = std::make_unique&lt;wjrpc::procedure_not_found&gt;(); err.id = std::move(call_id); typedef wjrpc::outgoing_error_json&lt;wjrpc::error_json&gt; error_json; std::string str; error_json::serializer()(err, std::back_inserter(str)); res_list.push_back(str); } } else { typedef wjrpc::outgoing_error&lt;wjrpc::error&gt; error_type; error_type err; err.error = std::make_unique&lt;wjrpc::invalid_request&gt;(); typedef wjrpc::outgoing_error_json&lt;wjrpc::error_json&gt; error_json; std::string str; error_json::serializer()(err, std::back_inserter(str)); res_list.push_back(str); } } for ( size_t i =0; i != res_list.size(); ++i) { std::cout &lt;&lt; req_list[i] &lt;&lt; std::endl; std::cout &lt;&lt; res_list[i] &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; } }</span></span></span></span></code> </pre> </div></div><br><p>  Here, most of the code is error handling, or rather, the formation of the corresponding message.  But for all types of errors, the code is similar, the differences are only in the type of error.  You can make one template function for serializing all types of errors. </p><br><div class="spoiler">  <b class="spoiler_title">Error message generation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> E&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(wjrpc::incoming_holder inholder, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; out)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjrpc::outgoing_error&lt;wjrpc::error&gt; common_error; common_error err; err.error = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;E&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( inholder.has_id() ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> id = inholder.raw_id(); err.id = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;wjrpc::data_type&gt;(id.first, id.second); } <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjrpc::outgoing_error_json&lt;wjrpc::error_json&gt; error_json; error_json::serializer()(err, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(out)); }</code> </pre> </div></div><br><p>  To generate an error message, we only need to know the type of error and the call identifier, if any.  The inholder object is moved and after the formation of the message it is no longer needed.  In the example, it is used only to retrieve the call identifier, but it can also ‚Äúpick up‚Äù the input buffer ‚Äî to serialize messages there so as not to create a new one. </p><br><p>  Similarly, it is possible to implement the result serialization.  But before continuing to get rid of the same type of code, let's put in order the application part, which is somewhat lost here and is represented with just one line for each method. </p><br><h2 id="interfeysy">  Interfaces </h2><br><p>  As I said, wjrpc is torn out of the framework, in which the interface must be explicitly defined for the components.  Moreover, it is not just a structure exclusively with pure virtual methods, but also certain restrictions are imposed on the parameters of the methods. </p><br><p>  All input and output parameters should be combined into structures, even if there is only one field.  This is convenient not only for the formation of a json description for a query, when the deserialized structure can be passed directly to the method, without prior conversion, but also from the standpoint of extensibility. </p><br><p>  For example, in all methods we return a number - the result of the operation.  Meaning to describe the result structure with one field, if possible number?  And the input parameters in general could be passed by an array (positional parameters). </p><br><p>  But now imagine that the requirements have changed a bit, and to the list of parameters you need to add supporting information, or, in the answer, for the division operation, a flag indicating that division by zero has occurred.  In this case, to make corrections, you need to ‚Äúshake up‚Äù not only the interface and all its implementations, but also all the places where it is used. </p><br><p>  If we have a JSON-RPC service, then the changes will affect not only the server, but also the client, whose interfaces need to be somehow coordinated.  And in the case of structures, it is enough just to add a field to the structure.  Moreover, you can update the client part and the server part independently. </p><br><p>  Another feature of the framework is that all methods have an asynchronous interface, i.e.  the result is not returned directly, but through a callback function.  And in order to avoid unintended copying errors, the input and output objects are described as std :: unique_ptr &lt;&gt;. </p><br><p>  For our calculator, taking into account the described limitations, we get the following interface: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">icalc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~icalc() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::plus::ptr req, response::plus::callback cb)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::minus::ptr req, response::minus::callback cb)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiplies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::multiplies::ptr req, response::multiplies::callback cb)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divides</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::divides::ptr req, response::divides::callback cb)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Given the auxiliary typedefs that we defined in the input structures, it looks quite nice.  But the implementation for such interfaces can be quite voluminous with respect to simple examples.  You need to make sure that the input request is not nullptr, and also check the callback function.  If it is not defined, then it is obvious that this is a notification, and in this case, the call must simply be ignored.  This functionality is easy to template, as shown in the example implementation of our calculator </p><br><div class="spoiler">  <b class="spoiler_title">calc1.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"icalc.hpp"</span></span></span><span class="hljs-meta"> class calc1 : public icalc { public: virtual void plus( request::plus::ptr req, response::plus::callback cb) override; virtual void minus( request::minus::ptr req, response::minus::callback cb) override; virtual void multiplies( request::multiplies::ptr req, response::multiplies::callback cb) override; virtual void divides( request::divides::ptr req, response::divides::callback cb) override; private: template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename Res, typename ReqPtr, typename Callback, typename F&gt; void impl_( ReqPtr req, Callback cb, F f); };</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">calc1.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc1.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjrpc/memory.hpp&gt; template&lt;typename Res, typename ReqPtr, typename Callback, typename F&gt; void calc1::impl_( ReqPtr req, Callback cb, F f) { //   if ( cb == nullptr ) return; //   if ( req == nullptr ) return cb(nullptr); auto res = std::make_unique&lt;Res&gt;(); res-&gt;value = f(req-&gt;first,req-&gt;second); cb( std::move(res) ); } void calc1::plus( request::plus::ptr req, response::plus::callback cb) { this-&gt;impl_&lt;response::plus&gt;( std::move(req), cb, [](int f, int s) { return f+s; } ); } void calc1::minus( request::minus::ptr req, response::minus::callback cb) { this-&gt;impl_&lt;response::minus&gt;( std::move(req), cb, [](int f, int s) { return fs; }); } void calc1::multiplies( request::multiplies::ptr req, response::multiplies::callback cb) { this-&gt;impl_&lt;response::multiplies&gt;( std::move(req), cb, [](int f, int s) { return f*s; }); } void calc1::divides( request::divides::ptr req, response::divides::callback cb) { this-&gt;impl_&lt;response::divides&gt;( std::move(req), cb, [](int f, int s) { return s!=0 ? f/s : 0; }); }</span></span></span></span></code> </pre> </div></div><br><p>  The article is not about the implementation of the calculator, so the code presented above should not be taken as best practice.  An example of a method call: </p><br><pre> <code class="cpp hljs">calc-&gt;plus( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(params), [](response::plus::ptr result) { ‚Ä¶ });</code> </pre> <br><p>  Back to the topic of interfaces, and now we will continue to ‚Äúshorten‚Äù the code of our service.  In order to asynchronously serialize the result, it is necessary to ‚Äúcapture‚Äù the incoming request. </p><br><div class="spoiler">  <b class="spoiler_title">like so</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;wjrpc::incoming_holder&gt; ph = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;wjrpc::incoming_holder&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(inholder) ); calc-&gt;plus( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(params), [ph, &amp;res_list](response::plus::ptr result) { <span class="hljs-comment"><span class="hljs-comment">//    wjrpc::outgoing_result&lt;response::plus&gt; resp; resp.result = std::move(result); //    auto raw_id = ph-&gt;raw_id(); auto call_id = std::make_unique&lt;wjrpc::data_type&gt;( raw_id.first, raw_id.second ); resp.id = std::move(call_id); //   typedef wjrpc::outgoing_result_json&lt;response::plus_json&gt; result_json; typedef wjrpc::outgoing_result_json&lt;response::plus_json&gt; result_json; //   auto d = ph-&gt;detach(); d-&gt;clear(); result_json::serializer()( resp, std::back_inserter(d) ); res_list.push_back( std::string(d-&gt;begin(), d-&gt;end()) ); });</span></span></code> </pre> </div></div><br><p>  Since  incoming_holder is moved, then in order to ‚Äúcapture‚Äù it, move it to std :: shared_ptr.  It shows how you can take a buffer from him, but in this case it does not make much sense - all the same, the result is placed in the list of strings.  Capturing res_list by reference is for example only.  we know that the request will be executed synchronously. </p><br><p>  We have already written a template function for serializing errors, we will do the same for answers.  But for this, in addition to the type of result, you need to pass its value and json-description. </p><br><div class="spoiler">  <b class="spoiler_title">Universal serializer response to the request</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ResJ&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;wjrpc::incoming_holder&gt; ph, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ResJ::target::ptr result, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; out)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ResJ result_json; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> result_json::target result_type; wjrpc::outgoing_result&lt;result_type&gt; resp; resp.result = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(result); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> raw_id = ph-&gt;raw_id(); resp.id = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;wjrpc::data_type&gt;( raw_id.first, raw_id.second ); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> wjrpc::outgoing_result_json&lt;result_json&gt; response_json; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> response_json::serializer()( resp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter( out ) ); }</code> </pre> </div></div><br><p>  Here you need to specify the template parameter explicitly - this is the json description for the response structure, from which you can take the type of the described structure.  Using this function, the code for each JSON-RPC method will be greatly simplified. </p><br><div class="spoiler">  <b class="spoiler_title">New version of the plus method</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( inholder.method() == <span class="hljs-string"><span class="hljs-string">"plus"</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//   auto params = inholder.get_params&lt;request::plus_json&gt;(&amp;e); if ( !e ) { std::shared_ptr&lt;wjrpc::incoming_holder&gt; ph = std::make_shared&lt;wjrpc::incoming_holder&gt;( std::move(inholder) ); calc-&gt;plus( std::move(params), std::bind( send_response&lt;response::plus_json&gt;, ph, std::placeholders::_1, std::ref(out)) ); } else { make_error&lt;wjrpc::invalid_params&gt;(std::move(inholder), out ); } } // else if ( inholder.method() == "minus" ) { ... } // else if ( inholder.method() == "multiplies" ) { .... } // else if ( inholder.method() == "divides" ) { .... } else { make_error&lt;wjrpc::procedure_not_found&gt;(std::move(inholder), out ); }</span></span></code> </pre> </div></div><br><p>  For each method, the code was reduced to a minimum, but this is not enough for me.  Receiving parameters and checking for an error is also the same type code. </p><br><div class="spoiler">  <b class="spoiler_title">Serialization and method invocation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> JParams, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> JResult, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (icalc::*mem_ptr)( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> JParams::target&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> JResult::target&gt;) &gt; ) &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(wjrpc::incoming_holder inholder, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;icalc&gt; calc, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; out)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> JParams params_json; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> JResult result_json; wjson::json_error e; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params = inholder.get_params&lt;params_json&gt;(&amp;e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !e ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;wjrpc::incoming_holder&gt; ph = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;wjrpc::incoming_holder&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(inholder) ); (calc.get()-&gt;*mem_ptr)( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(params), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bind( send_response&lt;result_json&gt;, ph, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::placeholders::_1, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(out) ) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { out = make_error&lt;wjrpc::invalid_params&gt;(); } }</code> </pre> </div></div><br><p>  This is almost the same as implemented in wjrpc.  As a result, the code of the demo example will be reduced to a minimum (here you can bring the implementation of all methods) </p><br><div class="spoiler">  <b class="spoiler_title">The final version of the example with the 'manual processing'</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; req_list = { <span class="hljs-string"><span class="hljs-string">"{\"method\":\"plus\", \"params\":{ \"first\":2, \"second\":3 }, \"id\" :1 }"</span></span>, <span class="hljs-string"><span class="hljs-string">"{\"method\":\"minus\", \"params\":{ \"first\":5, \"second\":10 }, \"id\" :1 }"</span></span>, <span class="hljs-string"><span class="hljs-string">"{\"method\":\"multiplies\", \"params\":{ \"first\":2, \"second\":2 }, \"id\" :1 }"</span></span>, <span class="hljs-string"><span class="hljs-string">"{\"method\":\"divides\", \"params\":{ \"first\":9, \"second\":3 }, \"id\" :1 }"</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; res_list; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> calc = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;calc1&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; sreq : req_list ) { res_list.push_back( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>() ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; out = res_list.back(); wjrpc::<span class="hljs-function"><span class="hljs-function">incoming_holder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inholder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( sreq )</span></span></span></span>; wjson::json_error e; inholder.parse(&amp;e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( e ) { out = make_error&lt;wjrpc::parse_error&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( inholder.is_request() ) { <span class="hljs-comment"><span class="hljs-comment">//       if ( inholder.method() == "plus" ) { invoke&lt;request::plus_json, response::plus_json, &amp;icalc::plus&gt;( std::move(inholder), calc, out ); } else if ( inholder.method() == "minus" ) { invoke&lt;request::minus_json, response::minus_json, &amp;icalc::minus&gt;( std::move(inholder), calc, out ); } else if ( inholder.method() == "multiplies" ) { invoke&lt;request::multiplies_json, response::multiplies_json, &amp;icalc::multiplies&gt;( std::move(inholder), calc, out ); } else if ( inholder.method() == "divides" ) { invoke&lt;request::divides_json, response::divides_json, &amp;icalc::divides&gt;( std::move(inholder), calc, out ); } else { out = make_error&lt;wjrpc::procedure_not_found&gt;(); } } else { out = make_error&lt;wjrpc::invalid_request&gt;(); } } for ( size_t i =0; i != res_list.size(); ++i) { std::cout &lt;&lt; req_list[i] &lt;&lt; std::endl; std::cout &lt;&lt; res_list[i] &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; } }</span></span></code> </pre> </div></div><br><p>  Such a manic desire to reduce the run-time amount of code due to several reasons.  Removing the extra <code>if</code> using a rather complex construction, we not only reduce the amount of code, but also remove potential places where the programmer will be happy to commit to code.  And programmers love to copy-paste, especially uninteresting code associated with serialization, spreading it across the entire project, or even adding it to other projects.  Laziness is the engine of progress when it makes a person invent something that will allow him to work less.  But not in the case when things are postponed until later.  It would seem a trivial check, but with words - this is still a prototype, writing a couple of lines of code is postponed, then forgotten and at the same time copied to the entire project, and also picked up by other programmers. </p><br><p>  In fact, we have not yet begun to consider wjrpc.  ,      wjson,       ,  ,      JSON-RPC ,   ,      .      wjrpc: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/calc1.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/plus_json.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/minus_json.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/multiplies_json.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/divides_json.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjrpc/handler.hpp&gt; #include &lt;wjrpc/method.hpp&gt; #include &lt;iostream&gt; #include &lt;functional&gt; JSONRPC_TAG(plus) JSONRPC_TAG(minus) JSONRPC_TAG(multiplies) JSONRPC_TAG(divides) struct method_list: wjrpc::method_list &lt; wjrpc::target&lt;icalc&gt;, wjrpc::invoke_method&lt;_plus_, request::plus_json, response::plus_json, icalc, &amp;icalc::plus&gt;, wjrpc::invoke_method&lt;_minus_, request::minus_json, response::minus_json, icalc, &amp;icalc::minus&gt;, wjrpc::invoke_method&lt;_multiplies_, request::multiplies_json, response::multiplies_json, icalc, &amp;icalc::multiplies&gt;, wjrpc::invoke_method&lt;_divides_, request::divides_json, response::divides_json, icalc, &amp;icalc::divides&gt; &gt;{}; class handler: public wjrpc::handler&lt;method_list&gt; {}; int main() { std::vector&lt;std::string&gt; req_list = { "{\"method\":\"plus\", \"params\":{ \"first\":2, \"second\":3 }, \"id\" :1 }", "{\"method\":\"minus\", \"params\":{ \"first\":5, \"second\":10 }, \"id\" :1 }", "{\"method\":\"multiplies\", \"params\":{ \"first\":2, \"second\":2 }, \"id\" :1 }", "{\"method\":\"divides\", \"params\":{ \"first\":9, \"second\":3 }, \"id\" :1 }" }; std::vector&lt;std::string&gt; res_list; auto calc = std::make_shared&lt;calc1&gt;(); handler h; handler::options_type opt; opt.target = calc; h.start(opt, 1); for ( auto&amp; sreq : req_list ) { h.perform( sreq, [&amp;res_list](std::string out) { res_list.push_back(out);} ); } for ( size_t i =0; i != res_list.size(); ++i) { std::cout &lt;&lt; req_list[i] &lt;&lt; std::endl; std::cout &lt;&lt; res_list[i] &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; } }</span></span></span></span></code> </pre> <br><p>   JSONRPC_TAG         ,  JSON <em>NAME  wjson,     ,    n</em> ,   . </p><br><p>    wjrpc::method_list  wjrpc::invoke_method    .      wjrpc::handler.          ,     . </p><br><p>     perform_io,    wjrpc::data_ptr. </p><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; data_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;data_type&gt; data_ptr; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(data_ptr) &gt; <span class="hljs-keyword"><span class="hljs-keyword">output_handler_t</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform_io</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_ptr d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">output_handler_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> handler)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)&gt; handler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;data_type&gt;( str.begin(), str.end() ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;perform_io( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(d), [handler](data_ptr d) { handler( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(d-&gt;begin(), d-&gt;end()) ); }); }</code> </pre> </div></div><br><p> ,         .   ,   ,      ,       </p><br><div class="spoiler">  <b class="spoiler_title">like so</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">plus_handler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; t, request::plus::ptr req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   t.target()-&gt;plus( std::move(req), nullptr ); } template&lt;typename T, typename Handler&gt; void operator()(T&amp; t, request::plus::ptr req, Handler handler) { //   t.target()-&gt;plus( std::move(req), [handler](response::plus::ptr res) { if ( res != nullptr ) handler( std::move(res), nullptr ); else handler( nullptr, std::make_unique&lt;wjrpc::service_unavailable&gt;() ); }); } };</span></span></code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">plus_handler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;, request::plus::ptr req)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Handler&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;, request::plus::ptr req, Handler handler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req==<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { handler( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;wjrpc::invalid_params&gt;() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> res = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;response::plus&gt;(); res-&gt;value = req-&gt;first + req-&gt;second; handler( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(res), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } };</code> </pre> </div></div><br><p>  handler  ,      ,     .  t ‚Äî     JSON-RPC- (  self  python).       : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method_list</span></span></span><span class="hljs-class">:</span></span> wjrpc::method_list &lt; wjrpc::target&lt;icalc&gt;, wjrpc::method&lt; wjrpc::name&lt;_plus_&gt;, wjrpc::invoke&lt;request::plus_json, response::plus_json, plus_handler&gt; &gt;, wjrpc::invoke_method&lt;_minus_, request::minus_json, response::minus_json, icalc, &amp;icalc::minus&gt;, wjrpc::invoke_method&lt;_multiplies_, request::multiplies_json, response::multiplies_json, icalc, &amp;icalc::multiplies&gt;, wjrpc::invoke_method&lt;_divides_, request::divides_json, response::divides_json, icalc, &amp;icalc::divides&gt; &gt;{};</code> </pre> <br><p>   , invoke_method&lt;&gt;    wjrpc::method&lt;&gt;,    : </p><br><div class="spoiler"> <b class="spoiler_title">mem_fun_handler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Params, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Result, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> I, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (I::*mem_ptr)( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Params&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Result&gt;) &gt; ) &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_fun_handler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Params&gt; request_ptr; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Result&gt; responce_ptr; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; error&gt; json_error_ptr; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(responce_ptr, json_error_ptr) &gt; jsonrpc_callback; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; t, request_ptr req)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; t, request_ptr req, jsonrpc_callback cb)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> </div></div><br><p>          ,     JSON-RPC   ,         ,            . </p><br><p>       ,    (     ),   ,    (  )      .    .   ,   - ,    .          .    ,     ? -       .  ,   ,   .         ,   ,     .     ,   ,    ,    . </p><br><p>  -    ‚Äú‚Äù     .        wjrpc::invoke_method.      ,    JSON-RPC.        ‚Äú‚Äù   ,      . </p><br><p>     ,           wjrpc::invoke_method. </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">icalc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~icalc() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> request::plus::<span class="hljs-function"><span class="hljs-function">ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::plus::ptr req)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> request::minus::<span class="hljs-function"><span class="hljs-function">ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::minus::ptr req)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> request::multiplies::<span class="hljs-function"><span class="hljs-function">ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiplies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::multiplies::ptr req)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> request::divides::<span class="hljs-function"><span class="hljs-function">ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divides</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::divides::ptr req)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> </div></div><br><p>  wjrpc::handler&lt;&gt;           .  callback, ,   ,   ,      ,      . </p><br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text"><pre> <code class="cpp hljs">calc-&gt;plus( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](response::plus::ptr) {} );</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;calc&gt; pthis = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;shared_from_this(); calc-&gt;plus( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), [pthis](response::plus::ptr) {} );</code> </pre> </div></div><br><p>    , ..          .  Option </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;calc&gt; wthis = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;shared_from_this(); calc-&gt;plus( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), [wthis](response::plus::ptr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pthis = wthis.lock() ) { <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> } } );</code> </pre> <br><p>  ,         (,   ).         ,    ,      callback-    . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; w = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;_p; <span class="hljs-comment"><span class="hljs-comment">/* _p = std::shared_ptr&lt;int&gt;(1);*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;calc&gt; wthis = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;shared_from_this(); calc-&gt;plus( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), [wthis, w](response::plus::ptr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pthis = wthis.lock() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> == w.lock() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> } } );</code> </pre> <br><p>        (  wjrpc) </p><br><div class="spoiler"> <b class="spoiler_title">callback-</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> H&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">owner_handler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; weak_type; owner_handler() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; owner_handler(H&amp;&amp; h, weak_type alive) : _handler( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;H&gt;(h) ) , _alive(alive) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">()(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:result_of&lt; H(Args&amp;&amp;...) &gt;::type { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = _alive.lock() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _handler( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)... ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::result_of&lt; H(Args&amp;&amp;...) &gt;::type(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: H _handler; weak_type _alive; };</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"> (   )</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">owner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; alive_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; weak_type; owner() : _alive( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>) ) { } owner(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> owner&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; owner&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> owner&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; owner(owner&amp;&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; owner&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (owner&amp;&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-function">alive_type&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _alive; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> alive_type&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _alive; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _alive = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(*_alive + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Handler&gt; owner_handler&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove_reference&lt;Handler&gt;::type&gt; wrap(Handler&amp;&amp; h) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> owner_handler&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::remove_reference&lt;Handler&gt;::type &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Handler&gt;(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(_alive) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> alive_type _alive; };</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// owner -   std::weak_ptr&lt;calc&gt; wthis = this-&gt;shared_from_this(); calc-&gt;plus( std::move(req), this-&gt;wrap([wthis](response::plus::ptr) { if ( auto pthis = wthis.lock() ) { /* ‚Ä¶ */ } })); // ‚Ä¶ //    owner::reset(); //  callback-   </span></span></code> </pre> </div></div><br><p>          .          .        ,     . ,      ,        .     ,  . </p><br><h2 id="json-rpc-engine"> JSON-RPC Engine </h2><br><p>  wjrpc::engine ‚Äì ,  ,  jsonrpc-,           . ,          ,    ,      wjrpc::engine.          .       callback-,       ,    .      wjrpc::engine,   ,    ,   ,   . </p><br><p>        ,     icalc.     ,         plus,  . </p><br><div class="spoiler"> <b class="spoiler_title">calc/calc_p.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"icalc.hpp"</span></span></span><span class="hljs-meta"> class calc_p : public icalc { public: void initialize(std::shared_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;icalc&gt;); virtual void plus( request::plus::ptr req, response::plus::callback cb) override; virtual void minus( request::minus::ptr req, response::minus::callback cb) override; virtual void multiplies( request::multiplies::ptr req, response::multiplies::callback cb) override; virtual void divides( request::divides::ptr req, response::divides::callback cb) override; private: template&lt;typename ReqPtr, typename Callback&gt; bool check_( ReqPtr&amp; req, Callback&amp; cb); std::shared_ptr&lt;icalc&gt; _next; };</span></span></span></span></code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title">calc/calc_p.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc_p.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; void calc_p::initialize(std::shared_ptr&lt;icalc&gt; next) { _next = next; } void calc_p::plus( request::plus::ptr req, response::plus::callback cb) { if ( !this-&gt;check_(req, cb)) return; req-&gt;first++; req-&gt;second++; _next-&gt;plus(std::move(req), [cb](response::plus::ptr res) { res-&gt;value++; cb(std::move(res) ); }); } void calc_p::minus( request::minus::ptr req, response::minus::callback cb) { if ( this-&gt;check_(req, cb)) _next-&gt;minus(std::move(req), std::move(cb) ); } void calc_p::multiplies( request::multiplies::ptr req, response::multiplies::callback cb) { if ( this-&gt;check_(req, cb)) _next-&gt;multiplies(std::move(req), std::move(cb) ); } void calc_p::divides( request::divides::ptr req, response::divides::callback cb) { if ( this-&gt;check_(req, cb)) _next-&gt;divides(std::move(req), std::move(cb) ); } template&lt;typename ReqPtr, typename Callback&gt; bool calc_p::check_( ReqPtr&amp; req, Callback&amp; cb) { if ( cb==nullptr ) return false; if ( req != nullptr ) return true; cb(nullptr); return false; }</span></span></span></span></code> </pre> </div></div><br><p>  ,      icalc,      ,   plus,     ‚Äú‚Äù.            . </p><br><p>        ,    :   ,   ,       .      ,         ,         . </p><br><p>  ,      ,    ,     JSON-RPC . </p><br><pre> <code class="cpp hljs">JSONRPC_TAG(plus) JSONRPC_TAG(minus) JSONRPC_TAG(multiplies) JSONRPC_TAG(divides) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method_list</span></span></span><span class="hljs-class">:</span></span> wjrpc::method_list &lt; wjrpc::call_method&lt;_plus_, request::plus_json, response::plus_json&gt;, wjrpc::call_method&lt;_minus_, request::minus_json, response::minus_json&gt;, wjrpc::call_method&lt;_multiplies_, request::multiplies_json, response::multiplies_json&gt;, wjrpc::call_method&lt;_divides_, request::divides_json, response::divides_json, icalc&gt; &gt; {};</code> </pre> <br><p>   ,   ,      ,    JSON-   .       ‚Äî       icalc: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ::wjrpc::handler&lt;method_list&gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> icalc { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::plus::ptr req, response::plus::callback cb)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> call&lt;_plus_&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), cb, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::minus::ptr req, response::minus::callback cb)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> call&lt;_minus_&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), cb, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiplies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::multiplies::ptr req, response::multiplies::callback cb)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> call&lt;_multiplies_&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), cb, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divides</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( request::divides::ptr req, response::divides::callback cb)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> call&lt;_divides_&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), cb, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } };</code> </pre> <br><p>      ‚Äî    call&lt;&gt;    ,   ,     ,  .        ,      .     ,      callback  nullptr. </p><br><p>      JSON-RPC ,   callback    nullptr,      ,   ,     .   JSON-RPC        .      ,     . </p><br><p>      , ,      : </p><br><img src="https://habrastorage.org/files/261/d79/e2b/261d79e2bc4a4c91a7a3c3620a0a06af.png"><br><p><br>       ,         ,  ,     ,    .      ,     ,    ,     .      ,         .   ‚Äî  ,      .         ,    ,   ,    . </p><br><p>          .       callback,         callback,    ,   .    JSON-RPC ,    id   JSON-RPC    .       callback  ,            callback,       . </p><br><div class="spoiler"> <b class="spoiler_title">calc/calc_p.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/calc1.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/calc_p.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/plus_json.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/minus_json.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/multiplies_json.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"calc/api/divides_json.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wjrpc/engine.hpp&gt; #include &lt;wjrpc/handler.hpp&gt; #include &lt;wjrpc/method.hpp&gt; #include &lt;iostream&gt; #include &lt;functional&gt; namespace service { JSONRPC_TAG(plus) JSONRPC_TAG(minus) JSONRPC_TAG(multiplies) JSONRPC_TAG(divides) struct method_list: wjrpc::method_list &lt; wjrpc::target&lt;icalc&gt;, wjrpc::invoke_method&lt;_plus_, request::plus_json, response::plus_json, icalc, &amp;icalc::plus&gt;, wjrpc::invoke_method&lt;_minus_, request::minus_json, response::minus_json, icalc, &amp;icalc::minus&gt;, wjrpc::invoke_method&lt;_multiplies_, request::multiplies_json, response::multiplies_json, icalc, &amp;icalc::multiplies&gt;, wjrpc::invoke_method&lt;_divides_, request::divides_json, response::divides_json, icalc, &amp;icalc::divides&gt; &gt;{}; class handler: public ::wjrpc::handler&lt;method_list&gt; {}; typedef wjrpc::engine&lt;handler&gt; engine_type; } namespace gateway { JSONRPC_TAG(plus) JSONRPC_TAG(minus) JSONRPC_TAG(multiplies) JSONRPC_TAG(divides) struct method_list: wjrpc::method_list &lt; wjrpc::call_method&lt;_plus_, request::plus_json, response::plus_json&gt;, wjrpc::call_method&lt;_minus_, request::minus_json, response::minus_json&gt;, wjrpc::call_method&lt;_multiplies_, request::multiplies_json, response::multiplies_json&gt;, wjrpc::call_method&lt;_divides_, request::divides_json, response::divides_json&gt; &gt; {}; class handler : public ::wjrpc::handler&lt;method_list&gt; , public icalc { public: virtual void plus( request::plus::ptr req, response::plus::callback cb) override { this-&gt;template call&lt;_plus_&gt;( std::move(req), cb, nullptr ); } virtual void minus( request::minus::ptr req, response::minus::callback cb) override { this-&gt;template call&lt;_minus_&gt;( std::move(req), cb, nullptr ); } virtual void multiplies( request::multiplies::ptr req, response::multiplies::callback cb) override { this-&gt;template call&lt;_multiplies_&gt;( std::move(req), cb, nullptr ); } virtual void divides( request::divides::ptr req, response::divides::callback cb) override { this-&gt;template call&lt;_divides_&gt;( std::move(req), cb, nullptr ); } }; typedef wjrpc::engine&lt;handler&gt; engine_type; } int main() { //  N1 auto prx1 = std::make_shared&lt;calc_p&gt;(); //  auto gtw = std::make_shared&lt;gateway::engine_type&gt;(); //  auto srv = std::make_shared&lt;service::engine_type&gt;(); //  N2 auto prx2 = std::make_shared&lt;calc_p&gt;(); //  auto clc = std::make_shared&lt;calc1&gt;(); //      prx2-&gt;initialize(clc); //         service::engine_type::options_type srv_opt; srv_opt.target = prx2; srv-&gt;start(srv_opt, 11); //   gateway::engine_type::options_type cli_opt; gtw-&gt;start(cli_opt, 22); //         gtw-&gt;reg_io(33, [srv]( wjrpc::data_ptr d, wjrpc::io_id_t /*io_id*/, wjrpc::output_handler_t handler) { std::cout &lt;&lt; " REQUEST: " &lt;&lt; std::string( d-&gt;begin(), d-&gt;end() ) &lt;&lt; std::endl; srv-&gt;perform_io(std::move(d), 44, [handler](wjrpc::data_ptr d) { //     JSON-RPC  std::cout &lt;&lt; " RESPONSE: " &lt;&lt; std::string( d-&gt;begin(), d-&gt;end() ) &lt;&lt; std::endl; handler(std::move(d) ); }); }); //       ID auto gtwh = gtw-&gt;find(33); //       prx1-&gt;initialize(gtwh); //  plus   (prx1-&gt;gtw-&gt;srv-&gt;prx2-&gt;clc) auto plus = std::make_unique&lt;request::plus&gt;(); plus-&gt;first = 1; plus-&gt;second = 2; prx1-&gt;plus( std::move(plus), [](response::plus::ptr res) { std::cout &lt;&lt; "1+2=" &lt;&lt; res-&gt;value &lt;&lt; std::endl;; }); //  plus   (gtw-&gt;srv-&gt;prx2-&gt;clc) auto minus = std::make_unique&lt;request::minus&gt;(); minus-&gt;first = 4; minus-&gt;second = 3; gtwh-&gt;minus( std::move(minus), [](response::minus::ptr res) { std::cout &lt;&lt; "4-3=" &lt;&lt; res-&gt;value &lt;&lt; std::endl;; }); }</span></span></span></span></code> </pre> </div></div><br><p>  Result: </p><br><pre> <code class="cpp hljs">REQUEST: {<span class="hljs-string"><span class="hljs-string">"jsonrpc"</span></span>:<span class="hljs-string"><span class="hljs-string">"2.0"</span></span>,<span class="hljs-string"><span class="hljs-string">"method"</span></span>:<span class="hljs-string"><span class="hljs-string">"plus"</span></span>,<span class="hljs-string"><span class="hljs-string">"params"</span></span>:{<span class="hljs-string"><span class="hljs-string">"first"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">"second"</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>},<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>} RESPONSE: {<span class="hljs-string"><span class="hljs-string">"jsonrpc"</span></span>:<span class="hljs-string"><span class="hljs-string">"2.0"</span></span>,<span class="hljs-string"><span class="hljs-string">"result"</span></span>:{<span class="hljs-string"><span class="hljs-string">"value"</span></span>:<span class="hljs-number"><span class="hljs-number">8</span></span>},<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>} <span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>=<span class="hljs-number"><span class="hljs-number">9</span></span> REQUEST: {<span class="hljs-string"><span class="hljs-string">"jsonrpc"</span></span>:<span class="hljs-string"><span class="hljs-string">"2.0"</span></span>,<span class="hljs-string"><span class="hljs-string">"method"</span></span>:<span class="hljs-string"><span class="hljs-string">"minus"</span></span>,<span class="hljs-string"><span class="hljs-string">"params"</span></span>:{<span class="hljs-string"><span class="hljs-string">"first"</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-string"><span class="hljs-string">"second"</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>},<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>} RESPONSE: {<span class="hljs-string"><span class="hljs-string">"jsonrpc"</span></span>:<span class="hljs-string"><span class="hljs-string">"2.0"</span></span>,<span class="hljs-string"><span class="hljs-string">"result"</span></span>:{<span class="hljs-string"><span class="hljs-string">"value"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>},<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>} <span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-number"><span class="hljs-number">-3</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>       ,    JSON-RPC  2  3  1  2.     ,    ,     8.      ,    9.      ,   ,     ,    munus   ,     . </p><br><p>       ‚Äî    ,     , ,   ,      , , : </p><br><div class="spoiler"> <b class="spoiler_title">create_id</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> wjrpc::<span class="hljs-keyword"><span class="hljs-keyword">io_id_t</span></span> create_id() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;wjrpc::<span class="hljs-keyword"><span class="hljs-keyword">io_id_t</span></span>&gt; counter( (wjrpc::<span class="hljs-keyword"><span class="hljs-keyword">io_id_t</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter.fetch_add(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> </div></div><br><p>           . ,   : </p><br><pre> <code class="cpp hljs"> gtw-&gt;reg_io(<span class="hljs-number"><span class="hljs-number">33</span></span>, []( wjrpc::data_ptr, wjrpc::<span class="hljs-keyword"><span class="hljs-keyword">io_id_t</span></span>, wjrpc::<span class="hljs-keyword"><span class="hljs-keyword">output_handler_t</span></span>)</code> </pre> <br><p>   JSON-RPC    ,      .     - , ,   ,        .          .         .   44 ‚Äî     ,      .       service::engine_type,        (    ,    wjrpc   ),     . </p><br><p>            (::pipe),   ,  ,       ,        ,   -     ,         ,     ,      .            examples , ,     ,    . </p><br><p>          wjson,       ,    wjrpc::incoming_holder     JSON-RPC .       ,    wjrpc::handler       ,     run-time . </p><br><p>  <a href="https://github.com/mambaru/wjrpc">wjrpc</a>  .    <a href="https://github.com/migashko/faslib">faslib</a>  <a href="https://github.com/mambaru/wjson">wjson</a> .     : </p><br><pre> <code class="cpp hljs">git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/migashko/faslib.git git clone https://github.com/mambaru/wjson.git git clone https://github.com/mambaru/wjrpc.git #      wjrpc cd faslib mkdir build cd build cmake .. #     cd ../../wjrpc mkdir build cd build cmake -DWJRPC_BUILD_ALL=ON .. make</span></span></code> </pre> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/312994/">https://habr.com/ru/post/312994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312976/index.html">Ruby Hero Russia Award 2016</a></li>
<li><a href="../312978/index.html">The unsightly truth about entrepreneurship</a></li>
<li><a href="../312980/index.html">Developer of the week: Katie McLaughlin</a></li>
<li><a href="../312984/index.html">That complicates the formalization of the project and gives rise to hidden errors</a></li>
<li><a href="../312990/index.html">VeraCrypt encryption software audited</a></li>
<li><a href="../312998/index.html">Reverse engineering procedural generation in No Man's Sky</a></li>
<li><a href="../313000/index.html">Linux Foundation launches reload of javascript community</a></li>
<li><a href="../313002/index.html">Cisco SMB RV320 / 325 Secure Routers with Built-in WEB Filtering: Feature Overview</a></li>
<li><a href="../313004/index.html">New venture fund of Silicon Valley, who wants to save the world and earn money to boot</a></li>
<li><a href="../313006/index.html">Technostream announced a month of game development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>