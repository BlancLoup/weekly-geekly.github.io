<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study Bootmgr. Part 1 - tools and basic principles of debugging the initial stages of loading Windows</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 Perhaps some readers will remember my very first article on a resource dedicated to booting Windows from a VHD image. Perhaps I would...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study Bootmgr. Part 1 - tools and basic principles of debugging the initial stages of loading Windows</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction </h1><br><p>  Perhaps some readers will remember <a href="https://habrahabr.ru/post/228641/">my very first article on a resource</a> dedicated to booting Windows from a VHD image.  Perhaps I would not have returned to this topic if there were no people who tried to repeat this technology on their home machines.  Naturally, with the implementation of this solution, there were problems concerning mainly the errors that bootmgr spits out in cases when he does not like something.  Attempts to interpret download errors like 0xc03a0003 by googling do not lead to particularly valuable results, and the Microsoft documentation on this subject keeps significant silence.  There was an idea to study the processing of VHD-images, having received information first-hand, that is, from the loader itself. </p><br><p>  If you turn to the information already available on the network, then there is a wonderful blog <a href="http://datadump.ru/">"Notes of Enikeyschik about Windows"</a> on whose pages ( <a href="http://datadump.ru/mbr-windows7/">one</a> , <a href="http://datadump.ru/pbr-windows7/">two</a> and <a href="http://datadump.ru/bootmgr-windows-7/">three</a> ), in my opinion, the most valuable information is available on bootmgr device issues.  The author reviewed in detail the boot process, including the MBR and PBR code studies, focusing on the bootmbr structure, briefly describing the processes that occur during its operation. </p><br><p>  We will go further - we will describe the tools that can be used to study the bootloader device and try to deal with some algorithms that interest us.  If such a proposal seemed interesting to someone, you are welcome under the cat. </p><a name="habracut"></a><br><h1>  1. Get the Bootmgr code from the system </h1><br><p>  Bootmgr loader appeared in the operating systems of the Windows family since Windows Vista.  The reason for its development was the fact that the good old ntldr, used in the NT line, could not boot the system, on computers with motherboards equipped with UEFI, at that time (2005) was not common among a wide range of ordinary users. </p><br><p>  By default, with a regular installation, this bootloader is placed in a separate partition located at the beginning of the HDD, with a size sufficient to accommodate the bootmgr itself as well as its configuration files.  This section is not mounted in the normal system operation mode and the drive letter is not assigned to it.  In systems with MBR, the creation of this partition can be avoided by installing Windows on a pre-marked and formatted HDD.  In this case, the bootloader is placed in the same partition as the OS files.  Systems with EFI + GPT initially require a partition of type 0xef and formatted in FAT. </p><br><p>  Thus, our first task is to get bootmgr.  It is advisable to take it from the system, which will act as an experimental.  To do this, install Windows on a virtual machine.  This can be both VirtualBox, and VMware, and QEMU - it all depends on what kind of virtualization tools you have.  I mainly work in Linux, I will mainly focus on the tools used there, although I will pay attention to Windows. </p><br><p>  So, suppose we have a virtual machine (VM) with Windows 7 (x86) installed on it.  The disk layout is based on the MBR, the system is installed in one partition.  Suppose this is QEMU, the disk on which the experimental one is installed is in raw format.  that is, an ordinary binary image.  Mount this image </p><br><pre><code class="bash hljs">$ sudo modprobe -r loop $ sudo modprobe loop max_part=15 $ sudo losetup -f win7.hdd $ sudo mount /dev/loop0p1 ~/virt-win $ ls -l ~/virt-win</code> </pre> <br><p>  On the mounted partition we will see the following contents. </p><br><pre> <code class="bash hljs"> 5504541 -rwxrwxrwx 1 root root 24  11 2009 autoexec.bat drwxrwxrwx 1 root root 4096  21 09:08 Boot -rwxrwxrwx 1 root root 391640  21 2015 bootmgr -rwxrwxrwx 1 root root 8192  21 09:08 BOOTSECT.BAK -rwxrwxrwx 1 root root 10  11 2009 config.sys lrwxrwxrwx 2 root root 60  14 2009 <span class="hljs-string"><span class="hljs-string">'Documents and Settings'</span></span> -&gt; /home/maisvendoo/virt-win/Users -rwxrwxrwx 1 root root 2415517696  21 09:26 hiberfil.sys -rwxrwxrwx 1 root root 3220692992  21 09:26 pagefile.sys drwxrwxrwx 1 root root 0  14 2009 PerfLogs drwxrwxrwx 1 root root 4096  21 09:14 ProgramData drwxrwxrwx 1 root root 4096  12 2011 <span class="hljs-string"><span class="hljs-string">'Program Files'</span></span> drwxrwxrwx 1 root root 0  21 09:14 Recovery drwxrwxrwx 1 root root 0  21 09:14 <span class="hljs-string"><span class="hljs-string">'$Recycle.Bin'</span></span> drwxrwxrwx 1 root root 4096  21 09:09 <span class="hljs-string"><span class="hljs-string">'System Volume Information'</span></span> drwxrwxrwx 1 root root 4096  21 09:14 Users drwxrwxrwx 1 root root 16384  21 09:09 Windows</code> </pre> <br><p>  The file <strong>bootmgr</strong> is of interest to us.  However, before we need not quite it, but the 32-bit bootmg boot image of bootmgr.exe, which is packaged in bootmgr.  To unpack it, you must use the <a href="https://github.com/coderforlife/bmzip">bmzip</a> utility, which is written in general for Windows (it did not work out with a swoop under Linux), so we will execute the unpacking on a virtual machine.  The binary build of this utility, which worked fine, turned out to be quite difficult to find, despite the fact that <a href="http://datadump.ru/bootmgr-windows-7/">there was</a> a link to it.  As a result, the package was found on one of the sites dedicated to bootmgr customization.  For bmzip to work, the MSCompression.dll library was needed.  The ready-to-work package <a href="">can</a> now <a href="">be downloaded here</a> . </p><br><p>  Create the utils folder on the VM disk and copy bmzip.exe there with MSCompression.dll.  Unmount the image and run the VM.  Run the command prompt as administrator.  To accidentally spoil the bootloader, make a copy of it. </p><br><pre> <code class="bash hljs">C:\ Windows\System32&gt;<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> c:\ C:\ xcopy bootmgr utils\bootmgr /h</code> </pre> <br><p>  The bootloader file is hidden and systemic, so remove these attributes from it. </p><br><pre> <code class="bash hljs">C:\ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> utils C:\ attrib -S -H /s</code> </pre> <br><p>  Unpack the bootloader </p><br><pre> <code class="bash hljs">C:\ bmzip bootmgr bootmgr.exe</code> </pre> <br><p>  As a result, we get the unpacked bootmgr.exe image </p><br><p><img src="https://habrastorage.org/files/0b4/759/dcd/0b4759dcd9f64f8db01e7bd37c85880c.png" alt="image"></p><br><p>  Turn off the VM and mount its disk in Linux again.  Create a folder where we will gut the bootloader with a disassembler and copy the unpacked image there. </p><br><pre> <code class="bash hljs">$ mkdir -p ~/work/bootmgr/ $ cp ~/virt-win/utils/bootmgr.exe ~/work/bootmgr/</code> </pre> <br><h1>  2. Disassemble bootmgr.exe </h1><br><p>  Now let's feed the resulting "executable" to the disassembler.  For example IDA Pro.  Run the "go" and open the extracted file in it. </p><br><p><img src="https://habrastorage.org/files/d76/5f3/6c0/d765f36c02ae4c098ee1e2d0567e95ee.png" alt="image"></p><br><p>  IDA correctly identifies the file as a 32-bit PE executable file.  Click OK.  Now, if the plug-in for working with pdb files is installed in IDA Pro, during the disassembling process we will be offered to download debug symbols, and not from anywhere, but from the Microsoft website. </p><br><p><img src="https://habrastorage.org/files/adf/51d/ea7/adf51dea71594d6aabb0dc28f58df985.png" alt="image"></p><br><p>  We agree and get this picture </p><br><p><img src="https://habrastorage.org/files/aa7/cc4/c8c/aa7cc4c8cec644298f9871a859c7124d.png" alt="image"></p><br><p>  Yeah, on the left we see the prototypes of the functions contained in the file being examined, thanks to the fact that we agreed to download the debug symbols.  This will greatly facilitate our subsequent work.  In the meantime, we define the entry point to the bootloader code, and it is not difficult to guess that this will be the BmMain () function.  However, without taking it on faith, press Ctrl + E </p><br><p><img src="https://habrastorage.org/files/56a/d42/10d/56ad4210d15348cca61eeb1a1862edcb.png" alt="image"></p><br><p>  making sure that our guess is correct - BmMain () is the entry point located at 0x401000.  Click OK and move to the beginning of the code. </p><br><p><img src="https://habrastorage.org/files/211/e4e/a42/211e4ea42f2f4a28be1ad2f3fc5fd482.png" alt="image"></p><br><p>  We see the header of the BmMain () function with an impressive list of local variables, and just below the function code itself </p><br><p><img src="https://habrastorage.org/files/a8c/8ba/76c/a8c8ba76cfc74b37ac5cca24ee75c35b.png" alt="image"></p><br><p>  Understanding the jumble of assembly code is quite difficult, and why not do it.  First of all, let's decide on what functions of the loader we want to explore.  Did I talk about VHD there?  Well, let's look for something in the code regarding virtual disks.  Right-click on the list of functions on the left and in the pop-up context menu, select "Quick filter" (or go to the window with prototypes and press Ctrl + F).  In the search bar, type "vhd" and ... </p><br><p><img src="https://habrastorage.org/files/c3b/2fa/af8/c3b2faaf8c4c487b9b54f0c2035fc6db.png" alt="image"></p><br><p>  Yes, these functions are available in an amount of 33 pieces.  Among them, <strong>VhdOpen ()</strong> will obviously be responsible for opening the virtual disk, but for example <strong>VhdiVerifyVhdFooter ()</strong> is responsible for checking the correctness of the VHD disk footer.  That is, we roughly imagine where we will put breakpoints in the debugger.  By the way, it's time to talk about debugging. </p><br><h1>  3. Debugging Bootmgr on a bunch of QEMU + IDA Pro </h1><br><p>  We start the virtual machine with the <strong>-s -S</strong> keys - this enables debug mode </p><br><pre> <code class="bash hljs">$ qemu-system-x86_64 ~/VM/qemu/win7-efi/win-x86.hdd -m 4096 -s -S</code> </pre> <br><p>  VM starts and immediately pauses, waiting for the debugger to connect. </p><br><p>  <strong>Important!</strong>  Never use the <strong>-enable-kvm</strong> switch using hardware virtualization.  When used, debugging in QEMU does not work. </p><br><p>  Now on the toolbar in IDA, select the "Remote GDB debugger" debugger </p><br><p><img src="https://habrastorage.org/files/4ab/50a/993/4ab50a993e9e4fdb855f4d8d9c079bf8.png" alt="image"></p><br><p>  Having answered "Yes" to several questions asked to us, we will get a window </p><br><p><img src="https://habrastorage.org/files/793/05d/a01/79305da016a448f78808907ce79bbf1b.png" alt="image"></p><br><p>  where we set the parameters of the connection with the VM: localhost on port 1234. Click OK.  We‚Äôll be told that some process is already running and is waiting for the debugger to connect - do we want to join it?  Of course we go! </p><br><p><img src="https://habrastorage.org/files/de2/d99/44e/de2d9944efbc4687ba8d14c59dacb724.png" alt="image"></p><br><p>  Therefore, we answer "Yes" and ... </p><br><p><img src="https://habrastorage.org/files/a9f/f5f/f2f/a9ff5ff2f43f4b169099ef01bef2c2b3.png" alt="image"></p><br><p>  we pause somewhere in the beginning of the bios of the virtual machine.  Great, but now we have to get to the place where bootmgr starts running.  Put a breakpoint on the BmMain () function.  Click on the toolbar a list of breakpoints, press Insert on the keyboard and indicate at what address we want to interrupt the execution of the code and go to debugging </p><br><p><img src="https://habrastorage.org/files/f68/c62/8bc/f68c628bc35f429b8e051c56ad7786ce.png" alt="image"></p><br><p>  We drive in the address 0x401000.  If we want to break the necessary function, then go to the main menu and open the list of functions in the debugging session: View -&gt; Open subviews -&gt; Functions.  In the list that appears, right-click the context menu and select Add breakpoint.  Now press F9 and after a short wait we get to the very beginning of the bootloader code </p><br><p><img src="https://habrastorage.org/files/fc3/375/b91/fc3375b91293424a8cb3f9e2741f46b3.png" alt="image"></p><br><p>  Now we can go through the code step by step, watch the values ‚Äã‚Äãof registers and the stack, track the call stack and so on.  To some extent, the debugger built into IDA is convenient and intuitive. </p><br><p>  Maybe they will ask me - is it possible to use GDB?  You can run the VM in debug mode, run gdb in the console </p><br><pre> <code class="bash hljs">$ gdb -q</code> </pre> <br><p>  Connect to a remote VM session </p><br><pre> <code class="bash hljs">(gdb) target remote localhost:1234</code> </pre> <br><p>  Enable display of disassembled instructions. </p><br><pre> <code class="bash hljs">(gdb) display/4i <span class="hljs-variable"><span class="hljs-variable">$pc</span></span></code> </pre> <br><p>  If you are not satisfied with the AT &amp; T syntax, switch to Intel. </p><br><pre> <code class="bash hljs">(gdb) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> disassembly-flavor intel</code> </pre> <br><p>  Put a breakpoint on BmMain () and start execution </p><br><pre> <code class="bash hljs">(gdb) b *0x401000 Breakpoint 1 at 0x401000 (gdb) c Continuing. Breakpoint 1, 0x00401000 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ?? () 1: x/4i <span class="hljs-variable"><span class="hljs-variable">$pc</span></span> =&gt; 0x401000: mov edi,edi 0x401002: push ebp 0x401003: mov ebp,esp 0x401005: and esp,0xfffffff8 (gdb)</code> </pre> <br><p>  Please, we see almost the same thing as seen in IDA, while having all the power of GDB.  Almost, because here we will not be able to use debugging symbols from Microsoft, because GDB does not understand them.  But the possibilities of GDB are much wider than those of IDA in terms of the debugging process and its automation. </p><br><p>  However, there is another possibility of debugging, which you cannot pass </p><br><h1>  3. Debugging on WinDbg + VirtualBox </h1><br><p>  Those who are developing drivers for Windows are certainly familiar with this great debugger.  It is remarkable that it has capabilities comparable to the capabilities of Linux GDB.  Its only drawback is a creepy way to customize its interface.  But we will omit these moments, and turn to the capabilities of this debugger for the problem we are solving. </p><br><p>  So, let us have a VM based on VirtualBox.  Let's create a COM port for this VM with the following parameters </p><br><p><img src="https://habrastorage.org/files/b9d/893/63a/b9d89363a121403dae97c6cdd63b8e84.png" alt="image"></p><br><p>  This is a virtual COM port that is forwarded to the named pipe.  To debug through the serial port, the virtual machine should be configured accordingly.  We load it and we start the console with the administrative rights.  With it we enter the bootloader configuration commands for debugging. </p><br><pre> <code class="bash hljs">c:\ Windows\system32&gt; bcdedit /bootdebug {bootmgr} on</code> </pre> <br><p>  This command will enable the debugger boot feature.  Next, configure the port for debugging </p><br><pre> <code class="bash hljs">c:\ Windows\system32&gt; bcdedit /dbgsettings serial debugport:1 baudrate:115200</code> </pre> <br><p>  We indicate that we use COM1 at a speed of 115200 baud.  Great, turn off the VM and start the debugger. </p><br><p>  The WinDbg debugger can be officially downloaded from the Microsoft website along with the driver development kit.  However, this debugger build has a problem - a glitch with the display of register values.  Therefore, I use an assembly that downloads from the same Redmod site, <a href="http:">referenced from a tweeter</a> and a certain Dominic Wong.  In this build, this bug is missing.  Run WinDbg with the following command. </p><br><pre> <code class="bash hljs">c:\Wingdbx86&gt; windbg -b -k com:pipe,port=\\.\pipe\com1,resets=0,reconnect</code> </pre> <br><p>  Open the interface settings (File -&gt; Open Workspace in File) in which, among other parameters, the path <a href="http://msdl.microsoft.com/download/symbols">http://msdl.microsoft.com/download/symbols is</a> saved to download debugging symbols from Microsoft servers.  I have this way pre-hammered into the settings (File -&gt; Symbol File Path) and saved in the theme for WinDbg.  This setting will allow us to automatically get debug information for the bootloader. </p><br><p>  Now run the VM.  Almost immediately it will pause, and in the debugger window we will see the following picture. </p><br><p><img src="https://habrastorage.org/files/911/66e/813/91166e8138f24bcfb4f8f96ec3d2bc07.png" alt="image"></p><br><p>  Yeah, the debugger connected to the VM and got to the point, kindly provided to us by Microsoft.  Well, now all debugging options using windbg are available to us. </p><br><p>  However, we do not stop at the very beginning of the loader code, but a little further.  As step-by-step debugging shows, we are right behind the <strong>BlInitializeLibrary ()</strong> function that provides initial hardware initialization. </p><br><p><img src="https://habrastorage.org/files/89d/803/2ff/89d8032ff3ae498eafee3a77f0e7490f.png" alt="image"></p><br><p>  and, when debugging with IDA, we simply do not get here.  Thus, when debugging with WinDbg, some of the bootmgr actions elude us right after its launch.  This is the disadvantage of using standard debugging tools provided by Microsoft.  However, the unavailable code we can always investigate separately using IDA. </p><br><p>  Now, as an example, let's take a look at how bootmgr works with fixed-size VHD images. </p><br><h1>  4. Debugging boot from VHD </h1><br><p>  The following is considered on the WinDbg debugger connected to the VM on VirtualBox, but equally true for other debugging methods, taking into account their features.  VM used in this example contains two systems: one installed on the HDD, the other on the VHD image.  Put a breakpoint on the function <strong>VhdOpen ()</strong> </p><br><pre> <code class="bash hljs">kd&gt; bp VhdOpen</code> </pre> <br><p>  and hit F5.  The debugger will be on the specified function. </p><br><p><img src="https://habrastorage.org/files/b8c/3ca/5f6/b8c3ca5f6f604ee186cd8d0d1b6b3fae.png" alt="image"></p><br><p>  Moreover, attention - we still did not go into the boot menu at all and did not choose a boot from VHD.  This means that the VHD check takes place long before the menu appears.  We observe the same behavior, for example, if we drop bootmgr an empty VHD.  The boot menu will not show us at all, but they will show an error with the code 0xc000000F. </p><br><p>  We go a little further by pressing F10 or typing <strong>p</strong> in the command line and get to the <strong>VhdiAllocateVhdData ()</strong> call - this is obviously the creation in memory of some structures for working with the image </p><br><p><img src="https://habrastorage.org/files/ea5/43b/211/ea543b211c414be780efc13dff818c89.png" alt="image"></p><br><p>  Below is a call to <strong>VhdiVerifyAndInitializeVhd ()</strong> - obviously checking the correctness of the image.  It seemed interesting to me and I went inside (F11) </p><br><p><img src="https://habrastorage.org/files/6ca/ece/885/6caece88522b49ebbd15279c2c11361b.png" alt="image"></p><br><p>  Below, after some preparatory operations, the loader reads the last 512 bytes of the image, which contain the so-called "footer" of the image, calling the <strong>VhdiReadVhdInformation ()</strong> function.  No need to go to the fortuneteller to understand - the function will return a pointer to the structure containing the footer data.  As I managed to find out, this pointer, after calling <strong>VhdiReadVhdInformation ()</strong> is in the ecx register.  Its value is 0x110098.  Look at the memory at that address. </p><br><pre> <code class="bash hljs">kd&gt; db 0x110098</code> </pre> <br><p>  The command reads the memory at the specified address, displaying it in the debugger window as a sequence of bytes. </p><br><pre> <code class="bash hljs">00110098 63 6f 6e 65 63 74 69 78-00 00 00 02 00 00 01 00 conectix........ 001100a8 ff ff ff ff ff ff ff ff-70 5e d3 1e 77 69 6e 20 ........p^..win 001100b8 00 06 00 01 57 69 32 6b-00 00 00 40 06 00 00 00 ....Wi2k...@.... 001100c8 00 00 00 40 06 00 00 00-cb 2c 10 3f 02 00 00 00 ...@.....,.?.... 001100d8 83 e6 ff ff 75 11 0a 5a-eb 03 c6 43 b9 c9 d6 df ....u..Z...C.... 001100e8 24 b6 76 57 00 00 00 00-00 00 00 00 00 00 00 00 $.vW............ 001100f8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 00110108 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................</code> </pre> <br><p>  Yeah, we see the familiar word - conectix.  This field precedes the VHD image footer, is called a cookie, and stores the memory that Microsoft bought VHD technology from Conectix, which developed this virtual disk format for older Macintosh computers. This is undoubtedly VHD footer, we can see here the signature of the operating system it was created (Wi2k) as well as the win sequence indicates that the VHD was created using Windows tools.  Yes, it was so.  Passing a little further, we come across a call <strong>VhdiVerifyVhdFooter ()</strong> checking the format of the footer.  As a parameter, it receives a pointer to the structure described above, for some reason through the esi register (???) </p><br><p><img src="https://habrastorage.org/files/24d/390/9b3/24d3909b380b443da503aafc6cd74bde.png" alt="image"></p><br><p>  This piece of code interested me the most, so somewhere using IDA Pro, somewhere with my hands, I converted it to pseudocode in C </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">usercall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VhdiVerifyVhdFooter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> footer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> error_code; <span class="hljs-comment"><span class="hljs-comment">// Error code int cur_checksum; // Actual checksum, writed in VHD int calc_checksum; // Calculated checksum int disk_type; // Disk type int creator_host_os; // Creator host OS // Error code error_code = -1069940733; // 0xc03a0003 // Check cookie if ( RtlCompareMemory((const void *)footer, "conectix", 8) == 8 ) { // Store actual checksumm cur_checksum = *(_DWORD *)(footer + 64); // Write zero to checksum in footer structure *(_DWORD *)(footer + 64) = 0; // Calculate check summ calc_checksum = BlUtlCheckSum(0x40001, 0, footer, 0x200); // Restore checsum in footer *(_DWORD *)(footer + 64) = cur_checksum; // Checksum verify if ( calc_checksum == cur_checksum ) { // File type verify if ( *(_WORD *)(footer + 14) == 1 ) { // Check disk type disk_type = *(_DWORD *)(footer + 60); if ( disk_type == 2 || disk_type == 3 || disk_type == 4 ) { // Check creator host OS creator_host_os = *(_DWORD *)(footer + 36); if ( creator_host_os != 1798465879 &amp;&amp; creator_host_os ) { error_code = -1073741637; // 0xc00000bb } // Check disk size (by integer sectors count) else if ( *(_DWORD *)(footer + 48) &amp; 0x1FF || *(_DWORD *)(footer + 40) &amp; 0x1FF ) { error_code = -1069940718; // 0xc03a0012 } else { error_code = 0; } } else { error_code = -1069940732; // 0xc03a0004 } } else { error_code = -1069940731; // 0xc03a0005 } } else { error_code = -1069940734; // 0xc03a0002 } } return error_code; }</span></span></code> </pre> <br><p>  The VHD footer can be represented as the following structure (in the comments, the displacements from its beginning are indicated). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//----------------------------------------------------------------------------- // VHD foother's data //----------------------------------------------------------------------------- struct vhd_footer_t { char cookie[8]; // +0 uint32_t features; // +8 uint32_t file_format_version; // +12 uint64_t data_offset; // +16 uint32_t time_stamp; // +24 char creator_application[4]; // +28 uint32_t creator_version; // +32 char creator_host_os[4]; // +36 uint64_t original_size; // +40 uint64_t current_size; // +48 vhd_disk_geometry_t disk_geometry; // +56 uint32_t disk_type; // +60 uint32_t checksum; // +64 vhd_uuid_t unique_id; // +68 uint8_t saved_state; // +84 uint8_t reserved[427]; };</span></span></code> </pre> <br><p>  Using this data, we can conclude which fields of the footer the bootmgr checks and which errors it throws.  If the VHD image is correct, this function returns zero; otherwise, the alignment is </p><br><pre> <code class="bash hljs">0xc03a0003 -  cookie 0xc03a0002 -     0xc03a0005 -     0xc03a0004 -     0xc00000bb -      Windows 0xc0300012 -     512 (   VHD)</code> </pre> <br><p>  The information I received resolved the dispute that arose with a colleague in the forum at which the method of loading Windows with VHD was discussed.  I lost it, considering that the images created by VirtualBox will not be loaded using bootmgr.  VirtualBox, creating such images, writes all the fields in accordance with the Microsoft specification, except the creator_application field, where it is written win in the original image and vbox in the case of virtualbox.  But this field is not checked by bootmgr, so the disks work, but they did not work for me for a completely different reason, which is the subject of a completely different story ... </p><br><h1>  Conclusion </h1><br><p>  Perhaps the article is somewhat muddled.  But, she says that the pots are fired not by the gods, but the debugging of the low-level Windows code is only a matter of technology.  The information you are interested in can always be obtained by putting your head and hands to it.  In this text, I tried to summarize the scattered information I collected on the net about debugging bootmgr.  I hope that I did it, thank all the readers for their attention and ... </p><br><p>  <em>to be continued!</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/301334/">https://habr.com/ru/post/301334/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301316/index.html">Attention: Is IT in IT under attack?</a></li>
<li><a href="../301320/index.html">How we drew road shields on the map</a></li>
<li><a href="../301324/index.html">Generating classes from a database using DataGrip</a></li>
<li><a href="../301330/index.html">Calling Java code from Love2D</a></li>
<li><a href="../301332/index.html">So you think you know Const?</a></li>
<li><a href="../301336/index.html">ASP.NET Core RC2: Integrated Modularity Support (application parts)</a></li>
<li><a href="../301338/index.html">Effective dependency injection when scaling Ruby applications</a></li>
<li><a href="../301340/index.html">The growth of hockey players: analyze the data of all world championships in the current century</a></li>
<li><a href="../301344/index.html">Python: Thinking Programmer</a></li>
<li><a href="../301346/index.html">Informational hiding in PDF documents</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>