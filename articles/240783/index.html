<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Finger Trees (Part 1. Introduction)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An article on Habr√© has recently been released on how you can create such structures in a functional language as the Queue (first went in, first came ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Finger Trees (Part 1. Introduction)</h1><div class="post__text post__text-html js-mediator-article"> <i>An article on Habr√© has recently been released on how you can create such structures in a functional language as the Queue (first went in, first came out) and Dec (reminiscent of a two-sided stack - first went in, the first came from both ends).</i>  <i>I looked at this code and realized that it was terribly inefficient - the complexity of the order of <code>O(n)</code> .</i>  <i>Quickly figure out how to create structures with <code>O(1)</code> did not work for me, so I discovered the code of the library implementation.</i>  <i>But there was not an easy and understandable implementation, but <code>&lt; &gt;</code> .</i>  <i>It was a description of finger trees, the need and elegance of which for this data structure is well revealed by the current article.</i> <br><br><h4>  Finger Trees </h4><br>  In this article we will look at finger trees.  These are functional immutable general-purpose data structures developed by Hinze and Patterson.  Finger trees provide a functional data structure Sequence ( <code>sequence</code> ), which provides a depreciated access constant in time for adding both to the beginning and to the end of the sequence, as well as logarithmic time for concatenation and for random access.  In addition to good asymptotic execution times, the data structure is incredibly flexible: in combination with monoidal tags on elements, finger trees can be used to implement efficient random access sequences, ordered sequences, interval trees, and priority queues. <br><br>  The article will consist of 3 parts: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Finger Trees (Part 1. Introduction) <br>  <a href="http://habrahabr.ru/post/243205/">Finger Trees (Part 2. Operations)</a> <br>  Finger Trees (Part 3. Application) <br><br><h4>  Developing a data structure </h4><br>  The basis and motivation of finger trees came from 2-3 trees.  2-3 trees are trees that can have two or three branches at each inner vertex and that have all their leaves at the same level.  While a binary tree of the same depth <code>d</code> must be 2 <sup>d</sup> leaves, 2-3 trees are much more flexible and can be used to store any number of elements (the number should not be a power of two). <br>  Consider the following 2-3 tree: <br><br><img src="https://habrastorage.org/files/50b/d43/d01/50bd43d01bcd4b0386d27c9a62989470.png"><br><br>  This tree stores fourteen items.  Access to any of them requires three steps, and if we were to add more elements, the number of steps for each of them would grow logarithmically.  We would like to use these trees to model the sequence.  However, in many applicable sequences very often and repeatedly refer to the beginning or to the end, and much less often to the middle.  To satisfy this wish, we can change this data structure so that the priority of access to the beginning and end is the highest, unlike other features. <br><br>  In our case, we add two fingers.  The finger is just the point at which you can access parts of the data structure, in imperative languages ‚Äã‚Äãthis would be just a pointer.  In our case, however, we will restructure the entire tree and make the parents of the first and last children the two roots of our tree.  Visually, considering the issue of changing the tree above, we grab the first and last nodes on the penultimate layer, and pull them up, letting the rest of the tree hang down: <br><br><img src="https://habrastorage.org/files/8ad/123/6f6/8ad1236f65514f658ceb5ff5a4b600f1.png"><br><a name="habracut"></a><br>  This new data type is known as the finger tree.  The finger tree consists of several layers (circled in blue) that are strung on the axis shown in brown <br><br><img src="https://habrastorage.org/files/94b/d2b/66e/94bd2b66e21e4f41952b7e343f837998.png"><br><br>  Each layer of the finger tree has a prefix (on the left) and a suffix (on the right), as well as a link to the further trip deep into.  The prefix and suffix contain the values ‚Äã‚Äãof the finger tree: on the first layer there are 2-3 trees of depth 0, on the second layer there are 2-3 trees of depth 1, on the third layer they contain 2-3 trees of depth 2 and so on.  The main element of this 2-3 tree is now the element at the bottom. <br><br>  Well, having the description, let's describe the data structure.  To begin with, we need to define a 2-3 tree structure that will need to be used to save things strung on an axis. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Branch3</span></span></span><span class="hljs-class"> aaa </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--  (node)   3 . | Branch2 aa -- ...   2 . deriving Show</span></span></span></span></code> </pre><br>  Note that the branch is parameterized by its children.  This allows you to have nested branches for the representation of 2-3 trees and to ensure the same depth.  For example, a 2-3 tree with a depth of 1 may be a <code>Node Char</code> : <br><pre> <code class="haskell hljs">&gt; <span class="hljs-comment"><span class="hljs-comment">-- 2-3   2     . &gt; Branch3 'n' 'o' 't' Branch3 'n' 'o' 't' &gt; Branch2 'a' 't' Branch2 'a' 't'</span></span></code> </pre><br>  However, we can also create deeper 2-3 trees.  For example, a 2-3 tree, depth 2 may be a <code>Node (Node Char)</code> : <br><br><pre> <code class="haskell hljs">&gt; <span class="hljs-type"><span class="hljs-type">Branch2</span></span> (<span class="hljs-type"><span class="hljs-type">Branch3</span></span> 'n' 'o' 't') (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'a' 't') <span class="hljs-type"><span class="hljs-type">Branch2</span></span> (<span class="hljs-type"><span class="hljs-type">Branch3</span></span> 'n' 'o' 't') (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'a' 't')</code> </pre><br>  Note that the mapping ensures that a 2-3 tree will have the same depth, because the depth is present in the tree type.  It also has its drawbacks, since it is more difficult to write functions that are parametric in the tree depth parameter.  But this is not so bad for our case. <br>  For our further convenience, let's add some methods that allow us to convert branch values ‚Äã‚Äãfrom lists of length 2 or 3. For this, we will use the <i>OverloadedLists</i> extension for <i>GHC</i> , which will allow us to write <code>fromList</code> and <code>toList</code> for various data types, and then use them for comparisons with the sample, if we use lists: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">{- LANGUAGE OverloadedLists, TypeFamilies -}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GHC.Exts (<span class="hljs-type"><span class="hljs-type">IsList(..)</span></span>) instance IsList (<span class="hljs-type"><span class="hljs-type">Node</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) where type Item (<span class="hljs-type"><span class="hljs-type">Node</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>) = a toList (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> <span class="hljs-title"><span class="hljs-title">xy</span></span>) = [x, y] toList (<span class="hljs-type"><span class="hljs-type">Branch3</span></span> <span class="hljs-title"><span class="hljs-title">xyz</span></span>) = [x, y, z] fromList [x, y] = Branch2 xy fromList [x, y, z] = Branch3 xyz fromList _ = error "Node must contain two or three elements"</code> </pre><br>  Now that we have our type 2-3 tree, we also need a type to save the prefix and suffixes that are strung on the axis of the finger tree.  If our finger tree is a complete analogy of 2-3 trees, then each of the very first prefixes and suffixes can have 2 or 3 elements, and the middle ones can have only 1 or 2 (because one of the links goes up one level along the axis).  However, to reduce the information content, the requirement is relaxed for finger trees, and, instead, each prefix and suffix contain from 1 to 4 elements.  More values ‚Äã‚Äãcan not be.  We could allow the prefix and suffix to be stored as lists, but we will instead use more selective constructors, each of which is responsible for its correct number of elements: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--    ,    --      1  4 data Affix a = One a | Two aa | Three aaa | Four aaaa deriving Show</span></span></code> </pre><br>  Working with this type of data is not so convenient, so we will quickly add helpers that allow you to work with affixes as lists. <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--       instance IsList (Affix a) where type Item (Affix a) = a toList (One x) = [x] toList (Two xy) = [x, y] toList (Three xyz) = [x, y, z] toList (Four xyzw) = [x, y, z, w] fromList [x] = One x fromList [x, y] = Two xy fromList [x, y, z] = Three xyz fromList [x, y, z, w] = Four xyzw fromList _ = error "Affix must have one to four elements" --        --           affixPrepend :: a -&gt; Affix a -&gt; Affix a affixPrepend x = fromList . (x :) . toList affixAppend :: a -&gt; Affix a -&gt; Affix a affixAppend x = fromList . (++ [x]) . toList</span></span></code> </pre><br>  Now that we have determined the type of data needed to store values ‚Äã‚Äã(2-3 trees, preserving values ‚Äã‚Äãand affixes attached to the axis), we can create an axial data structure.  This axial structure is what we call the finger tree, and it is defined as follows: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  ,    ,       data FingerTree a = Empty --     | Single a --     ,       --    ,       | Deep { prefix :: Affix a, --   deeper :: FingerTree (Node a), --     ,  2-3  suffix :: Affix a --   } deriving Show</span></span></code> </pre><br>  In the definition above, the deep field <code>FingerTree a</code> is of type <code>FingerTree (Node a)</code> .  This means that the values ‚Äã‚Äãstored on the next layer are 2-3 trees that are one level deeper.  Thus, the affixes of the first layer <code>FingerTree Char</code> store only <code>Char</code> , the second layer stores <code>FingerTree (Node Char)</code> and has affixes that store 2-3 trees of depth 1 ( <code>Node Char</code> ).  The third layer will be <code>FingerTree (Node (Node Char))</code> and has affixes that store 2-3 trees of depth 2 <code>Node (Node Char)</code> ). <br><br>  Now that we have defined our type of finger tree, we will spend a little more time and consider the example that was shown above in order to understand how we translate it into the <code>FingerTree Char</code> structure: <br><br><img src="https://habrastorage.org/files/8ad/123/6f6/8ad1236f65514f658ceb5ff5a4b600f1.png"><br><br>  Translating it into a tree, we get: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">layer3</span></span> :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a layer3 = <span class="hljs-type"><span class="hljs-type">Empty</span></span> layer2 :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> (<span class="hljs-type"><span class="hljs-type">Node</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span>) layer2 = <span class="hljs-type"><span class="hljs-type">Deep</span></span> prefix layer3 suffix <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> prefix = [<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'i' 's', <span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'i' 's'] suffix = [<span class="hljs-type"><span class="hljs-type">Branch3</span></span> 'n' 'o' 't', <span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'a' 't'] layer1 :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> layer1 = <span class="hljs-type"><span class="hljs-type">Deep</span></span> prefix layer2 suffix <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> prefix = ['t', 'h'] suffix = ['r', 'e', 'e'] exampleTree :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> exampleTree = layer1</code> </pre><br><pre> <code class="haskell hljs">&gt; exampleTree <span class="hljs-type"><span class="hljs-type">Deep</span></span> {prefix = <span class="hljs-type"><span class="hljs-type">Two</span></span> 't' 'h', deeper = <span class="hljs-type"><span class="hljs-type">Deep</span></span> {prefix = <span class="hljs-type"><span class="hljs-type">Two</span></span> (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'i' 's') (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'i' 's'), deeper = <span class="hljs-type"><span class="hljs-type">Empty</span></span>, suffix = <span class="hljs-type"><span class="hljs-type">Two</span></span> (<span class="hljs-type"><span class="hljs-type">Branch3</span></span> 'n' 'o' 't') (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'a' 't')}, suffix = <span class="hljs-type"><span class="hljs-type">Three</span></span> 'r' 'e' 'e'}</code> </pre><br>  In the next part of the article, we will learn how to easily work with finger trees as sequences. </div><p>Source: <a href="https://habr.com/ru/post/240783/">https://habr.com/ru/post/240783/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240769/index.html">Overview of JPA-RS New Features in EclipseLink</a></li>
<li><a href="../240773/index.html">Atom - TypeScript implementation</a></li>
<li><a href="../240775/index.html">Working with a COM port in a web project</a></li>
<li><a href="../240779/index.html">Create your own dojo widgets</a></li>
<li><a href="../240781/index.html">KodiCMS architecture</a></li>
<li><a href="../240785/index.html">Simple Rest Api framework based on Phalcon</a></li>
<li><a href="../240787/index.html">Web application - well, almost without a back-end: Flask, Redis, API via JSONP, JSFiddle.net</a></li>
<li><a href="../240789/index.html">CleverStyle CMS module architecture</a></li>
<li><a href="../240791/index.html">Russian translation Apple iPhone Developer Program License Agreement + Schedule 2 v19</a></li>
<li><a href="../240793/index.html">Multiboot, UEFI, NTFS or almost a recipe for happiness</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>