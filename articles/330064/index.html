<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kotlin, bytecode compilation and performance (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a continuation of the publication. The first part can be found here. 

 Content: 
 Cycles 
 When 
 Delegates 
 Object and companion object 
 l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kotlin, bytecode compilation and performance (part 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/3af/e51/f5a/3afe51f5a54a4ce583d5665dfb4d06c3.png"><br><br>  This is a continuation of the publication.  The first part can be found <a href="https://habrahabr.ru/company/inforion/blog/330060/">here.</a> <br><br><h2>  Content: </h2><br>  <a href="https://habrahabr.ru/company/inforion/blog/330064/">Cycles</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330064/">When</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330064/">Delegates</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330064/">Object and companion object</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330064/">lateinit properties</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330064/">coroutines</a> <br>  <a href="https://habrahabr.ru/company/inforion/blog/330064/">findings</a> <br><a name="habracut"></a><br><h2>  Cycles: </h2><a name="P1"></a><br>  Kotlin lacks a classic three-part for, as in Java.  This may seem a problem to someone, but if you look at all the cases of using such a cycle in more detail, you can see that for the most part it is used just for enumerating values.  Kotlin has a simplified construction to replace it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs pgsql">//Kotlin fun range<span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>) { println(i) } }</code> </pre> <br>  1..10 here is the range for which the iteration occurs.  The Kotlin compiler is smart enough, it understands what we are going to do in this case, and therefore removes all the extra overhead.  The code is compiled into a regular while loop with a loop counter variable.  No iterators, no overhead projector, everything is quite compact. <br><br><pre> <code class="hljs pgsql">//Java <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static final <span class="hljs-type"><span class="hljs-type">void</span></span> range<span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span>() { <span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; byte var1 = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i &lt;= var1) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.println(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == var1) { break; } ++i; } } }</code> </pre><br>  A similar loop through the array (which is written to Kotlin as Array &lt;*&gt;) is compiled in a similar way into a for loop. <br><br><pre> <code class="hljs pgsql">//Kotlin fun arrayLoop(x: <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;String&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x) { println(s) } }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public static final void arrayLoop(@NotNull String[] x) { Intrinsics.checkParameterIsNotNull(x, "x"); for(int var2 = 0; var2 &lt; x.length; ++var2) { String s = x[var2]; System.out.println(s); } }</span></span></code> </pre><br>  A slightly different situation arises when the enumeration of elements from the list occurs: <br><br><pre> <code class="hljs pgsql">//Kotlin fun listLoop(x: List&lt;String&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x) { println(s) } }</code> </pre><br>  In this case, you have to use an iterator: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public static final void listLoop(@NotNull List x) { Intrinsics.checkParameterIsNotNull(x, "x"); Iterator var2 = x.iterator(); while(var2.hasNext()) { String s = (String)var2.next(); System.out.println(s); } }</span></span></code> </pre><br>  Thus, depending on which elements are searched, the Kotlin compiler itself chooses the most efficient way to convert a cycle into bytecode. <br><br>  The following is a comparison of performance for loops with similar solutions in Java: <br><br><h4>  Cycles </h4><br><img src="https://habrastorage.org/web/3a3/b67/b5b/3a3b67b5bb2b43fd84f2fc6010a9ae06.png"><br><br>  As you can see, the difference between Kotlin and Java is minimal.  Baytkod turns out very close to that generates javac.  According to the developers, they still plan to improve this in the next versions of Kotlin so that the resulting bytecode will be as close as possible to the patterns that javac generates. <br><br><h2>  When </h2><a name="P2"></a><br>  When is an analog switch from Java, only with more functionality.  Consider the following examples and what they are compiled into: <br><br><pre> <code class="hljs kotlin">/Kotlin <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tableWhen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(x) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"zero"</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"one"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"many"</span></span> }</code> </pre><br>  For such a simple case, the resulting code is compiled into an ordinary switch; no magic happens here: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public static final String tableWhen(int x) { String var10000; switch(x) { case 0: var10000 = "zero"; break; case 1: var10000 = "one"; break; default: var10000 = "many"; } return var10000; }</span></span></code> </pre><br>  If, however, slightly change the example above, and add constants: <br><br><pre> <code class="hljs haskell">//<span class="hljs-type"><span class="hljs-type">Kotlin</span></span> val <span class="hljs-type"><span class="hljs-type">ZERO</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> val <span class="hljs-type"><span class="hljs-type">ONE</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> fun constWhen(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = when(x) { <span class="hljs-type"><span class="hljs-type">ZERO</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"zero"</span></span> <span class="hljs-type"><span class="hljs-type">ONE</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"one"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"many"</span></span> }</code> </pre><br>  That code in this case is already compiled into the following form: <br><br><pre> <code class="hljs pgsql">//Java <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static final String constWhen(<span class="hljs-type"><span class="hljs-type">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x == ZERO?"zero":(x == ONE?"one":"many"); }</code> </pre><br>  This is because at the moment the Kotlin compiler does not understand that the values ‚Äã‚Äãare constants, and instead of converting to switch, the code is converted to a set of comparisons.  Therefore, instead of the constant time, a transition to a linear one takes place (depending on the number of comparisons).  According to the developers of the language, in the future this can be easily corrected, but in the current version it is still so. <br><br>  It is also possible to use the const modifier for constants known at compile time. <br><pre> <code class="hljs haskell">//<span class="hljs-type"><span class="hljs-type">Kotlin</span></span> ( <span class="hljs-type"><span class="hljs-type">When2</span></span>.kt) const val <span class="hljs-type"><span class="hljs-type">ZERO</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> const val <span class="hljs-type"><span class="hljs-type">ONE</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> fun constWhen(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = when(x) { <span class="hljs-type"><span class="hljs-type">ZERO</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"zero"</span></span> <span class="hljs-type"><span class="hljs-type">ONE</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"one"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"many"</span></span> }</code> </pre><br>  Then, in this case, the compiler already correctly optimizes when: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">When2Kt</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ZERO = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ONE = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constWhen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ String var10000; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: var10000 = <span class="hljs-string"><span class="hljs-string">"zero"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: var10000 = <span class="hljs-string"><span class="hljs-string">"one"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: var10000 = <span class="hljs-string"><span class="hljs-string">"many"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> var10000; } }</code> </pre><br>  If we replace constants with Enum: <br><br><pre> <code class="hljs haskell">//<span class="hljs-type"><span class="hljs-type">Kotlin</span></span> ( <span class="hljs-type"><span class="hljs-type">When3</span></span>.kt) enum <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-type"><span class="hljs-type">NumberValue</span></span> { <span class="hljs-type"><span class="hljs-type">ZERO</span></span>, <span class="hljs-type"><span class="hljs-type">ONE</span></span>, <span class="hljs-type"><span class="hljs-type">MANY</span></span> } fun enumWhen(x: <span class="hljs-type"><span class="hljs-type">NumberValue</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = when(x) { <span class="hljs-type"><span class="hljs-type">NumberValue</span></span>.<span class="hljs-type"><span class="hljs-type">ZERO</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"zero"</span></span> <span class="hljs-type"><span class="hljs-type">NumberValue</span></span>.<span class="hljs-type"><span class="hljs-type">ONE</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"one"</span></span> <span class="hljs-type"><span class="hljs-type">NumberValue</span></span>.<span class="hljs-type"><span class="hljs-type">MANY</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"many"</span></span> }</code> </pre><br>  That code, as well as in the first case, will be compiled into a switch (almost the same as in the case of enum enumeration in Java). <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class When3Kt$WhenMappings { // $FF: synthetic field public static final int[] $EnumSwitchMapping$0 = new int[NumberValue.values().length]; static { $EnumSwitchMapping$0[NumberValue.ZERO.ordinal()] = 1; $EnumSwitchMapping$0[NumberValue.ONE.ordinal()] = 2; $EnumSwitchMapping$0[NumberValue.MANY.ordinal()] = 3; } } public static final String enumWhen(@NotNull NumberValue x) { Intrinsics.checkParameterIsNotNull(x, "x"); String var10000; switch(When3Kt$WhenMappings.$EnumSwitchMapping$0[x.ordinal()]) { case 1: var10000 = "zero"; break; case 2: var10000 = "one"; break; case 3: var10000 = "many"; break; default: throw new NoWhenBranchMatchedException(); } return var10000; }</span></span></code> </pre><br>  The ordinal number of the element determines the branch number in the switch, which is followed by the selection of the desired branch. <br><br>  Let's look at the performance comparison of solutions on Kotlin and Java: <br><br><h4>  When </h4><br><img src="https://habrastorage.org/web/98c/395/ff6/98c395ff6ef941069dab59860b1f1d1d.png"><br><br>  As you can see, a simple switch works the same way.  In the case when the Kotlin compiler could not determine that the variables are constants and turned to comparisons, Java runs a little faster.  And in a situation where we enumerate enum values, there is also a small loss for fussing with the definition of the branch by the value of ordinal.  But all these shortcomings will be corrected in future versions, and besides, the loss in performance is not very large, and in critical places you can rewrite the code to another option.  Quite reasonable price for usability. <br><br><h2>  Delegates </h2><a name="P3"></a><br>  Delegation is a good alternative to inheritance, and Kotlin supports it right out of the box.  Consider a simple example with class delegation: <br><br><pre> <code class="hljs python">//Kotlin package examples interface Base { fun print() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseImpl</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(val x: Int)</span></span></span><span class="hljs-class"> :</span></span> Base { override fun print() { print(x) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(b: Base)</span></span></span><span class="hljs-class"> :</span></span> Base by b { fun anotherMethod(): Unit {} }</code> </pre><br>  The Derived class in the constructor receives an instance of the class that implements the Base interface, and in turn delegates the implementation of all methods of the Base interface to the transmitted instance.  The decompiled code of the Derived class will look like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Base $$delegate_0; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Base b)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(b, <span class="hljs-string"><span class="hljs-string">"b"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$$delegate_0 = b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$$delegate_0.print(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anotherMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre><br>  An instance of the class is passed to the class constructor, which is stored in the immutable internal field.  The Base interface's print method is also redefined, where the method is simply called from the delegate.  Everything is quite simple. <br><br>  It is also possible to delegate not only the implementation of the entire class, but also its individual properties (and from version 1.1 it is still possible to delegate initialization to local variables). <br><br>  Code on Kotlin: <br><br><pre> <code class="hljs pgsql">//Kotlin <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DeleteExample { val <span class="hljs-type"><span class="hljs-type">name</span></span>: String <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Delegate() }</code> </pre><br>  Compiled into code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeleteExample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Delegate name$delegate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Delegate(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> KProperty[] $$delegatedProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KProperty[]{(KProperty)Reflection.property1(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PropertyReference1Impl(Reflection.getOrCreateKotlinClass(DeleteExample.class), <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"getName()Ljava/lang/String;"</span></span>))}; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name$delegate.getValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, $$delegatedProperties[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } }</code> </pre><br>  When the DeleteExample class is initialized, an instance of the Delegate class is created, which is stored in the name field $ delegate.  And then the getName function call is redirected to the getValue function call from name $ delegate. <br><br>  Kotlin already has several standard delegates: <br><br>  - lazy, for lazy evaluation of the field value. <br>  - observable, which allows you to receive notifications about all changes in the field <br>  - map used to initialize field values ‚Äã‚Äãfrom Map values. <br><br><h2>  Object and companion object </h2><a name="P4"></a><br>  Kotlin has no static modifier for methods and fields.  Instead, for the most part, it is recommended to use functions at the file level.  If you need to declare functions that can be called without an instance of the class, then for this there is an object and a companion object.  Let's look at examples of how they look in bytecode: <br><br>  A simple object declaration with one method is as follows: <br><br><pre> <code class="hljs pgsql">//Kotlin <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ObjectExample { fun objectFun(): <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre><br>  In the code, you can then access the objectFun method without creating an ObjectExample instance.  The code is compiled into almost canonical singleton: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectExample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ObjectExample INSTANCE; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectExample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ INSTANCE = (ObjectExample)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectExample(); } }</code> </pre><br>  And the place of the call: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//Kotlin val value = ObjectExample.objectFun()</span></span></code> </pre><br>  Compiled to the INSTANCE call: <br><br><pre> <code class="hljs pgsql">//Java <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = ObjectExample.INSTANCE.objectFun();</code> </pre><br>  The companion object is used to create similar methods only already in the class for which it is supposed to create instances. <br><br><pre> <code class="hljs pgsql">//Kotlin <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ClassWithCompanion { val <span class="hljs-type"><span class="hljs-type">name</span></span>: String = "Kurt" companion <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { fun companionFun(): <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span> } } //<span class="hljs-keyword"><span class="hljs-keyword">method</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> ClassWithCompanion.companionFun()</code> </pre><br>  Calling the companionFun method also does not require creating an instance of the class, and in Kotlin it will look like a simple call to a static method.  But in fact there is an appeal to the companion class.  Let's see the decompiled code: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class ClassWithCompanion { @NotNull private final String name = "Kurt"; public static final ClassWithCompanion.Companion Companion = new ClassWithCompanion.Companion((DefaultConstructorMarker)null); @NotNull public final String getName() { return this.name; } public static final class Companion { public final int companionFun() { return 5; } private Companion() { } public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } } //  ClassWithCompanion.Companion.companionFun();</span></span></code> </pre><br>  The Kotlin compiler simplifies calls, but from Java, however, it doesn‚Äôt look so beautiful.  Fortunately, it is possible to declare methods to be truly static.  For this there is a summary @JvmStatic.  It can be added to both the object methods and the companion object methods.  Consider the example object: <br><br><pre> <code class="hljs pgsql">//Kotlin <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ObjectWithStatic { @JvmStatic fun staticFun(): <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> } }</code> </pre><br>  In this case, the staticFun method will actually be declared static: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectWithStatic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ObjectWithStatic INSTANCE; <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectWithStatic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ INSTANCE = (ObjectWithStatic)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectWithStatic(); } }</code> </pre><br>  For the methods from the companion object, you can also add the @JvmStatic annotation: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassWithCompanionStatic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String = <span class="hljs-string"><span class="hljs-string">"Kurt"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span> } }</code> </pre><br>  For this code, the static method companionFun will also be created.  But the method itself will still call the method from the companion: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassWithCompanionStatic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name = <span class="hljs-string"><span class="hljs-string">"Kurt"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ClassWithCompanionStatic.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassWithCompanionStatic.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Companion.companionFun(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } }</span></span></code> </pre><br>  As shown above, Kotlin provides various options for declaring both static methods and companion methods.  Calling static methods is a little faster, so in places where performance is important, it‚Äôs still better to put @JvmStatic annotations on methods (but you still shouldn‚Äôt count on a big gain in speed) <br><br><h2>  lateinit properties </h2><a name="P5"></a><br>  Sometimes there is a situation when you need to declare a notnull property in a class, the value for which we cannot immediately specify.  But when initializing the notnull field, we are obliged to assign a default value to it, or to make the Nullable property and write null to it.  In order not to go to nullable, there is a special modifier lateinit in Kotlin, which tells the Kotlin compiler that we are committed to initializing the property ourselves later. <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//Kotlin class LateinitExample { lateinit var lateinitValue: String }</span></span></code> </pre><br>  If we try to access the property without initialization, then a UninitializedPropertyAccessException will be thrown.  This functionality works quite simply: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public final class LateinitExample { @NotNull public String lateinitValue; @NotNull public final String getLateinitValue() { String var10000 = this.lateinitValue; if(this.lateinitValue == null) { Intrinsics.throwUninitializedPropertyAccessException("lateinitValue"); } return var10000; } public final void setLateinitValue(@NotNull String var1) { Intrinsics.checkParameterIsNotNull(var1, "&lt;set-?&gt;"); this.lateinitValue = var1; } }</span></span></code> </pre><br>  An additional check of the property value is inserted into getter, and if it contains null, an exception is thrown.  By the way, precisely because of this, in Kotlin it is impossible to make a lateinit property with the type Int, Long and other types that correspond to the primitive types of Java. <br><br><h2>  coroutines </h2><a name="P6"></a><br>  In Kotlin 1.1, there is a new functionality called coroutines.  With it, you can easily write asynchronous code in a synchronous form.  In addition to the main library (kotlinx-coroutines-core) to support interrupts, there is also a large set of libraries with various extensions: <br><br>  kotlinx-coroutines-jdk8 - additional library for JDK8 <br>  kotlinx-coroutines nio are extensions for asynchronous IO from JDK7 +. <br><br>  kotlinx-coroutines-reactive - utilities for jet streams <br>  kotlinx-coroutines-reactor - utilities for Reactor <br>  kotlinx-coroutines-rx1 - utilities for RxJava 1.x <br>  kotlinx-coroutines-rx2 - utilities for RxJava 2.x <br><br>  kotlinx-coroutines-android - UI context for Android. <br>  kotlinx-coroutines-javafx - JavaFx context for JavaFX UI applications. <br>  kotlinx-coroutines-swing - Swing context for Swing UI applications. <br><br>  <b>Note: Functionality is still in the experimental stage, so everything said below may still change.</b> <br><br>  To indicate that a function can be interrupted and used in the context of an interrupt, the suspend modifier is used. <br><br><pre> <code class="hljs pgsql">//Kotlin suspend fun asyncFun(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">3</span></span> }</code> </pre><br>  The decompiled code looks like this: <br><br><pre> <code class="hljs perl">//Java public static final Object asyncFun(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>, @NotNull Continuation $continuation) { Intrinsics.checkParameterIsNotNull($continuation, <span class="hljs-string"><span class="hljs-string">"$continuation"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Integer.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">x</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre><br>  It turns out almost the original function, except that one additional parameter is passed that implements the Continuation interface. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Continuation</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> context: CoroutineContext <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resumeWithException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exception: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre><br>  It contains the execution context, defines the function of returning the result and the function of returning the exception, in case of an error. <br><br>  Korutiny compiled into a state machine (state machine).  Consider an example: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = a() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y = foo(a).await() <span class="hljs-comment"><span class="hljs-comment">//   #1 b() val z = bar(a, y).await() //   #2 c(z)</span></span></code> </pre><br>  The foo and bar functions return the CompletableFuture, on which the await function is called.  Decompiling such code in Java will not work (mostly due to goto), so consider it in pseudocode: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> &lt;anonymous_for_state_machine&gt; extends </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CoroutineImpl</span></span></span><span class="hljs-class">&lt;...&gt; implements </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Continuation</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">&gt; { //     int label = 0 //    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> a = null </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Y</span></span></span><span class="hljs-class"> y = null void resume(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">) { if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class"> == 0) goto </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L0</span></span></span><span class="hljs-class"> if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class"> == 1) goto </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L1</span></span></span><span class="hljs-class"> if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">label</span></span></span><span class="hljs-class"> == 2) goto </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L2</span></span></span><span class="hljs-class"> else throw </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IllegalStateException</span></span></span><span class="hljs-class">() </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L0</span></span></span><span class="hljs-class">: a = a() label = 1 data = foo(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">).await(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">) // 'this'   continuation if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">COROUTINE_SUSPENDED</span></span></span><span class="hljs-class">) return // ,  await   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L1</span></span></span><span class="hljs-class">: //     ,    data y = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Y</span></span></span><span class="hljs-class">) data b() label = 2 data = bar(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">).await(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">) // 'this'   continuation if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">COROUTINE_SUSPENDED</span></span></span><span class="hljs-class">) return // ,  await   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L2</span></span></span><span class="hljs-class">: //         data </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> z = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class">) data c(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">z</span></span></span><span class="hljs-class">) label = -1 //      return } }</span></span></code> </pre><br>  As you can see, there are 3 states: L0, L1, L2.  Execution starts in the L0 state, then from which it switches to the L1 state and after in L2.  At the end, the state is switched to -1 as an indication that no more steps are allowed. <br><br>  Korutin themselves can be performed in different threads, there is a convenient mechanism for managing this by specifying a pool in the context of launching a korutina.  You can see a detailed <a href="">guide</a> with a large number of examples and a description of their use. <br><br>  All source codes on Kotlin are available in <a href="https://github.com/evgzakharov/kotlin_bytecode_examples">github</a> .  You can open them on your own and experiment with the code, at the same time looking at which final bytecode the sources are compiled into. <br><br><h2>  findings </h2><a name="P7"></a><br>  Application performance on Kotlin will not be much worse than in Java, and using the inline modifier may even turn out to be better.  The compiler in all places tries to generate the most optimized bytecode.  Therefore, do not be afraid that when you switch to Kotlin you will get a big performance degradation.  And in especially critical places, knowing what Kotlin compiles, you can always rewrite the code to a more suitable option.  A small fee for the fact that the language allows you to implement complex structures in a fairly concise and simple form. <br><br>  Thanks for attention!  I hope you enjoyed the article.  I ask all those who have noticed any errors or inaccuracies to write me about it in a personal message. </div><p>Source: <a href="https://habr.com/ru/post/330064/">https://habr.com/ru/post/330064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330048/index.html">Understanding the event architecture of Node.js</a></li>
<li><a href="../330052/index.html">Software Defined Radio by the hands of a sixteen year old</a></li>
<li><a href="../330056/index.html">The history of the creation of the Virtual File System Git (GVFS, Git Virtual File System)</a></li>
<li><a href="../330060/index.html">Kotlin, bytecode compilation and performance (part 1)</a></li>
<li><a href="../330062/index.html">Own scripting engine for games using C ++ and Lua (part 1)</a></li>
<li><a href="../330066/index.html">Issue # 3: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../330068/index.html">Must-Have: 20 game assets for the designer and artist</a></li>
<li><a href="../330070/index.html">Load optimization in the ‚ÄúRemains in warehouses‚Äù task using partitioning in SQL Server</a></li>
<li><a href="../330072/index.html">Zen will not call</a></li>
<li><a href="../330074/index.html">Check Point Security CheckUP - R80.10. Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>