<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Roslyn to automatically translate C # code into 1C code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An idea appeared to see how an object-oriented approach will look like in 1C, the language of which is very limited in means and does not provide for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Roslyn to automatically translate C # code into 1C code</h1><div class="post__text post__text-html js-mediator-article">  An idea appeared to see how an object-oriented approach will look like in 1C, the language of which is very limited in means and does not provide for the definition of classes.  A program to automatically translate C # class definitions into another language would allow the generated code to be changed as new ideas appear.  The search for implementation tools led to the Roslyn project - the open source C # compiler. <br><br>  Roslyn is an open source compilation platform for C # and Visual Basic.  Roslyn performs two basic actions: it builds a syntax tree (parsing) and compiles a syntax tree.  Additionally, it allows analyzing source code, recursively bypassing it, working with Visual Studio projects, and executing code on the fly. <br><br>  Note that Roslyn is currently in Beta.  Based on this, over time, the compiler may change something. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Roslyn - open C # compiler </h2><br><br>  You can connect Roslyn to the project via Nuget: <pre><code class="cs hljs">Install-Package Microsoft.CodeAnalysis ‚ÄìPre</code> </pre> <br>  For convenience, the code is better to immediately connect the three namespaces <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis.CSharp; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis.CSharp.Syntax; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis;</code> </pre><br>  You can get the syntax tree of a code from a string (or file) like this: <br><pre> <code class="cs hljs">SyntaxTree tree = CSharpSyntaxTree.ParseText(codeString);</code> </pre><br>  The syntax tree is a hierarchy of objects inherited from SyntaxNode.  Objects are created for all occasions.  Examples: ClassDeclarationSyntax - class definition, NamespaceDeclarationSyntax - namespace definition, PropertyDeclarationSyntax - property definition, AccessorDeclarationSyntax - property access method definition (get / set), BlockSyntax - block content (between curly brackets), ExpressionStatementSyntax - expression, etc. <br><br>  If there is a task to recursively go through all the elements of the tree, you can create your own Walker class and inherit it from CSharpSyntaxWalker.  The base class allows you to override the common Visit method (SyntaxNode node) or a large number of specialized ones: void VisitNamespaceDeclaration (NamespaceDeclarationSyntax node), void VisitClassDeclaration (ClassDeclarationSyntax node), void VisitConstructorDeclaration (ConstructorDeclarationSyntax node), etc.  Do not forget to call the base method in each redefined method in order not to stop the recursion. <br><br>  The recursive traversal call can be started as follows: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> walker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Walker(); walker.Visit(tree.GetRoot());</code> </pre><br>  There is no type information in the syntax tree.  Information about the types used appears after the call: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> compilation = CSharpCompilation.Create(<span class="hljs-string"><span class="hljs-string">"1ccode"</span></span>).WithOptions(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)).AddReferences(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetadataFileReference(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>).Assembly.Location)).AddSyntaxTrees(tree); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Model = compilation.GetSemanticModel(tree);</code> </pre><br>  After this call, you can get information about the types used, for example, by calling <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classSymbol = Model.GetDeclaredSymbol(classDeclarationSyntax);</code> </pre><br>  Now, having information about the type, you can find out which class the given type inherited: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = type.BaseType;</code> </pre><br>  Or get all type members via type. GetMembers () <br><br><h2>  Automatic translation of C # code to 1C code </h2><br><br>  The code does not claim to be complete and correct, as it has the goal to get a general idea of ‚Äã‚Äãthe OOP approach in 1C. <br><br>  To translate the C # code into the 1C code, a Walker class was created, inherited from CSharpSyntaxWalker.  Walker enumerates all definitions and builds on output 1C code. <br><br>  The class performs the following transformations. <br><br>  The namespace is translated by the VisitNamespaceDeclaration method into the 1C module, where dots in the name are replaced with underscores. <br><br>  There is no concept class in 1C, so the class definition is skipped in the VisitClassDeclaration method.  The name of the class will be present in the name of each function and procedure 1C to denote belonging to the same type.  The methods present in the base classes, but missing in the current class through the DeclareBaseClassMethodsToImplement and the DeclareBaseClassPropertiesToImplement, are defined with the call of the ‚Äúbasic‚Äù functions / procedures 1C. <br><br>  Constructors in VisitConstructorDeclaration are translated into definitions of 1C functions with a class name, the first _this parameter and a list of parameters.  If there is no call to another constructor of this class, all the fields of the class in the structure are initialized.  The call of other constructors is determined. <br><br>  Property definitions in VisitPropertyDeclaration are skipped.  Definitions of their access methods are important. <br><br>  Methods for accessing properties in VisitAccessorDeclaration are translated into definitions with the names &lt;class name&gt; _ Get_ &lt;property name&gt; and &lt;class name&gt; _ Set_ &lt;property name&gt;.  If they are auto-implemented, then the access code for the variable _this._private_ &lt;class name&gt; _ &lt;property name&gt; is generated. <br><br>  For methods in VisitMethodDeclaration, 1C-procedure definitions are generated. <br><br>  Expressions and ‚Äúreturns‚Äù in VisitExpressionStatement and VisitReturnStatement are commented via // and inserted into the text as is. <br><br><div class="spoiler">  <b class="spoiler_title">Walker.cs source code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis.CSharp; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis.CSharp.Syntax; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.CodeAnalysis; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Roslyn</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Walker</span></span> : <span class="hljs-title"><span class="hljs-title">CSharpSyntaxWalker</span></span> { SyntaxTree Tree { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } CSharpCompilation Compilation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } SemanticModel Model { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } TextWriter Writer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Walker</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TextWriter writer, SyntaxTree tree, CSharpCompilation compilation</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Writer = writer; Tree = tree; Compilation = compilation; Model = Compilation.GetSemanticModel(tree); } Dictionary&lt;ClassDeclarationSyntax, FieldDeclarationSyntax[]&gt; _classFields = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;ClassDeclarationSyntax, FieldDeclarationSyntax[]&gt;(); NamespaceDeclarationSyntax _currentNamespace; ClassDeclarationSyntax _currentClass; PropertyDeclarationSyntax _currentProperty; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Tabs = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SyntaxNode node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Tabs++; //var indents = new String('\t', Tabs); //Writer.WriteLine(indents + node.GetType().Name + "/" + node.CSharpKind()); base.Visit(node); //Tabs--; } public override void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node) { _currentNamespace = node; Writer.WriteLine(" " + node.Name.ToString().Replace(".", "_")); base.VisitNamespaceDeclaration(node); } public override void VisitClassDeclaration(ClassDeclarationSyntax node) { _currentClass = node; var fields = node.ChildNodes().OfType&lt;FieldDeclarationSyntax&gt;().ToArray(); _classFields[node] = fields; Writer.WriteLine(); Writer.WriteLine(string.Format("// {0}", node.Identifier)); base.VisitClassDeclaration(node); DeclareBaseClassPropertiesToImplement(node); DeclareBaseClassMethodsToImplement(node); } void DeclareBaseClassMethodsToImplement(ClassDeclarationSyntax classNode) { var classSymbol = Model.GetDeclaredSymbol(classNode); List&lt;string&gt; processedMembers = new List&lt;string&gt;(); var type = classSymbol; while (type != null) { foreach(var member in type.GetMembers()) { var declarators = member.DeclaringSyntaxReferences; if (declarators == null || declarators.Length == 0) continue; if (declarators.Length != 1) throw new NotImplementedException(); var memberNode = declarators[0].GetSyntax() as MethodDeclarationSyntax; if (memberNode == null) continue; if (processedMembers.Any(m=&gt;m == member.Name)) continue; processedMembers.Add(member.Name); if (type == classSymbol) //Skip original class members. Declare only base classes continue; Writer.WriteLine(); Writer.WriteLine(string.Format(" {0}_{1}(_this)", _currentClass.Identifier, memberNode.Identifier)); Writer.WriteLine(string.Format(" {0}_{1}(_this);", type.Name, member.Name)); Writer.WriteLine(string.Format(";")); } type = type.BaseType; } } void DeclareBaseClassPropertiesToImplement(ClassDeclarationSyntax classNode) { var classSymbol = Model.GetDeclaredSymbol(classNode); List&lt;string&gt; processedMembers = new List&lt;string&gt;(); var type = classSymbol; while (type != null) { foreach(var member in type.GetMembers()) { var declarators = member.DeclaringSyntaxReferences; if (declarators == null || declarators.Length == 0) continue; if (declarators.Length != 1) throw new NotImplementedException(); var memberNode = declarators[0].GetSyntax() as PropertyDeclarationSyntax; if (memberNode == null) continue; if (processedMembers.Any(m =&gt; m == memberNode.Identifier.ToString())) continue; processedMembers.Add(memberNode.Identifier.ToString()); if (type == classSymbol) //Skip original class members. Declare only base classes continue; Writer.WriteLine(); Writer.WriteLine(string.Format(" {0}__{1}(_this)", _currentClass.Identifier, memberNode.Identifier)); Writer.WriteLine(string.Format("  {0}__{1}(_this);", type.Name, member.Name)); Writer.WriteLine(string.Format(";")); Writer.WriteLine(); Writer.WriteLine(string.Format(" {0}__{1}(_this, value)", _currentClass.Identifier, memberNode.Identifier)); Writer.WriteLine(string.Format(" {0}__{1}(_this);", type.Name, member.Name)); Writer.WriteLine(string.Format(";")); } type = type.BaseType; } } public override void VisitConstructorDeclaration(ConstructorDeclarationSyntax node) { Writer.WriteLine(); var symbol = Model.GetDeclaredSymbol(node); List&lt;string&gt; parameters = new List&lt;string&gt;(); parameters.Add("_this"); parameters.AddRange(node.ParameterList.Parameters.Select(m =&gt; m.Identifier.ToString()).ToArray()); Writer.WriteLine(string.Format(" {0}({1}){2}", node.Identifier, String.Join(", ", parameters), " ")); Writer.WriteLine(); Tabs++; var indents = new String('\t', Tabs); //Initialize members first if no this constructor initializer (:this()) call if (!node.DescendantNodes().OfType&lt;ConstructorInitializerSyntax&gt;().Any(m=&gt;m.CSharpKind() == SyntaxKind.ThisConstructorInitializer) &amp;&amp; _classFields.ContainsKey(_currentClass)) { Writer.WriteLine(indents + String.Format("// ")); //Writer.WriteLine(String.Format("_this =  ();")); foreach (var field in _classFields[_currentClass]) { Writer.WriteLine(String.Format(indents + "_this.(\"{0}\", {1})", field.Declaration.Variables[0].Identifier, field.Declaration.Variables[0].Initializer.Value)); } } if (node.Initializer != null) { List&lt;string&gt; arguments = new List&lt;string&gt;(); arguments.Add("_this"); arguments.AddRange(node.Initializer.ArgumentList.Arguments.Select(m =&gt; m.Expression.ToString()).ToArray()); if (node.Initializer.ThisOrBaseKeyword.CSharpKind() == SyntaxKind.BaseKeyword) { Writer.WriteLine(indents + String.Format("//   ")); Writer.WriteLine(indents + String.Format("{0}({1});", _currentClass.BaseList.Types[0], String.Join(", ", arguments))); } else if (node.Initializer.CSharpKind() == SyntaxKind.ThisConstructorInitializer) { Writer.WriteLine(indents + String.Format("//  ")); Writer.WriteLine(indents + String.Format("{0}({1});", _currentClass.Identifier, String.Join(", ", arguments))); } } Writer.WriteLine(String.Format(indents + "_this.(\"__type\", \"{0}.{1}\")", symbol.ContainingNamespace.Name, symbol.ContainingType.Name)); base.VisitConstructorDeclaration(node); Tabs--; Writer.WriteLine(indents + string.Format(" _this;")); Writer.WriteLine(string.Format("; //{0}({1}){2}", node.Identifier, String.Join(", ", parameters), " ")); } public override void VisitPropertyDeclaration(PropertyDeclarationSyntax node) { _currentProperty = node; var symbol = Model.GetDeclaredSymbol(node); base.VisitPropertyDeclaration(node); } public override void VisitAccessorDeclaration(AccessorDeclarationSyntax node) { Writer.WriteLine(); if (node.CSharpKind() == SyntaxKind.GetAccessorDeclaration) { Writer.WriteLine(string.Format(" {0}__{1}(_this)", _currentClass.Identifier, _currentProperty.Identifier)); } else if (node.CSharpKind() == SyntaxKind.SetAccessorDeclaration) { Writer.WriteLine(string.Format(" {0}__{1}(_this, value)", _currentClass.Identifier, _currentProperty.Identifier)); } Tabs++; if (node.Body == null) { //auto implemented var indents = new String('\t', Tabs); if (node.CSharpKind() == SyntaxKind.GetAccessorDeclaration) { Writer.WriteLine(indents + string.Format(" _this._private_{0}_{1};", _currentClass.Identifier, _currentProperty.Identifier)); } else if (node.CSharpKind() == SyntaxKind.SetAccessorDeclaration) { Writer.WriteLine(indents + string.Format("_this._private_{0}_{1} = value;", _currentClass.Identifier, _currentProperty.Identifier)); } } base.VisitAccessorDeclaration(node); Tabs--; if (node.CSharpKind() == SyntaxKind.GetAccessorDeclaration) { Writer.WriteLine(string.Format(";")); } else if (node.CSharpKind() == SyntaxKind.SetAccessorDeclaration) { Writer.WriteLine(string.Format(";")); } } public override void VisitMethodDeclaration(MethodDeclarationSyntax node) { Writer.WriteLine(); Writer.WriteLine(string.Format(" {0}_{1}(_this)", _currentClass.Identifier, node.Identifier)); Tabs++; base.VisitMethodDeclaration(node); Tabs--; Writer.WriteLine(string.Format(";")); } public override void VisitExpressionStatement(ExpressionStatementSyntax node) { var indents = new String('\t', Tabs); Writer.WriteLine(("\r\n" + node.ToString()).Replace("\r\n", "\r\n" + indents + "//")); base.VisitExpressionStatement(node); } public override void VisitReturnStatement(ReturnStatementSyntax node) { var indents = new String('\t', Tabs); Writer.WriteLine(("\r\n" + node.ToString()).Replace("\r\n", "\r\n" + indents + "//")); base.VisitReturnStatement(node); } //public override void VisitBlock(BlockSyntax node) //{ // Writer.WriteLine(node.ToString()); // base.VisitBlock(node); //} } }</span></span></code> </pre><br></div></div><br><br><h2>  Work result </h2><br><br>  As a result, the code <br><br><div class="spoiler">  <b class="spoiler_title">C # source code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> 1.2 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>  { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> () { <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-string"><span class="hljs-string">" "</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _<span class="hljs-number"><span class="hljs-number">1</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> {_<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>;}} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>() { <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>  :  { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> () : <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>() { <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-string"><span class="hljs-string">" "</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>() { <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-string"><span class="hljs-string">" (int i)"</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>(); } } }</code> </pre><br></div></div><br><br>  Will be translated into 1C: Enterprise code <br><br><div class="spoiler">  <b class="spoiler_title">Source Code 1C: Enterprise</b> <div class="spoiler_text"><pre> <code class="1c hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span>_<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">//   (_this)  //  _this.("_1", 10) _this.("__type", "2.") //1 = " ";  _this; ; //(_this)   __1(_this) //return _1; ;  __1(_this, value) //_1 = value; ;  __1(_this)  _this._private__1; ;  __1(_this, value) _this._private__1 = value; ;  _1(_this) //1 = "1"; ; //   (_this)  //  _this.("_1", 20) //    (_this); _this.("__type", "2.") //1 = " "; //1();  _this; ; //(_this)   (_this, i)  //   (_this); _this.("__type", "2.") //1 = " (int i)"; //1();  _this; ; //(_this, i)   __1(_this)  __1(_this); ;  __1(_this, value) __1(_this); ;  __1(_this)  __1(_this); ;  __1(_this, value) __1(_this); ;  _1(_this) _1(_this); ;</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/245453/">https://habr.com/ru/post/245453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245443/index.html">Petooh programming language</a></li>
<li><a href="../245445/index.html">A vulnerability has been discovered in the anti-counterfeiting system.</a></li>
<li><a href="../245447/index.html">The simpler the better, or when ELB is not needed</a></li>
<li><a href="../245449/index.html">.NET / Mono in Java? Easy!</a></li>
<li><a href="../245451/index.html">20 million pesos and half a year in Chile: how SmartProgress won a grant at the other end of the world</a></li>
<li><a href="../245455/index.html">Problem, solution and stability check in statics</a></li>
<li><a href="../245459/index.html">Analog video input for Virturilki and its use in the national economy</a></li>
<li><a href="../245461/index.html">When running World of Tanks game replays, arbitrary code can be executed on your computer</a></li>
<li><a href="../245465/index.html">Why students need a CppCat code analyzer</a></li>
<li><a href="../245467/index.html">Protecting a Phalcon + AngularJS web application against CSRF attacks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>