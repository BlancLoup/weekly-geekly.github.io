<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nebraska problem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Casey Muratori is one of the programmers for The Witness. In the process of developing the game, he published in his blog posts about technical proble...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nebraska problem</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f5/7b0/b52/8f57b0b526e9ff131913c69b764bcac9.jpg" alt="image"></div><br>  <i>Casey Muratori is one of the programmers for The Witness.</i>  <i>In the process of developing the game, he published in his blog posts about technical problems that stood before him.</i>  <i>Below is a translation of one of these posts.</i> <br><br>  Throughout my career as a programmer, one principle remained unchanged: I always take the time to ask myself - why am I doing something exactly as I do?  This has always happened, from the creation of simple software constructs to high-level algorithms.  Even deep-rooted ideas are often mistaken, and by subjecting these ideas to doubts, we can come to surprising and important discoveries. <br><br>  Therefore, when I work on something, I reflexively begin to consider the reasons behind it.  And planting grass, too, was no exception. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The code I described last week is already embedded in <i>The Witness</i> source tree, along with many other non-related grass system modifications, which I will discuss next week.  It was a reasonable solution to the obvious problem, and time was running out, so I knew that then it was not up to the solution of deeper issues.  But in my head I made a mental note that the next time I work on the generation of patterns, I need to ask the question "why."  Thanks to the time allotted for writing this article, I got this opportunity. <br><br>  The question ‚Äúwhy‚Äù in this case is quite simple: why do we use blue noise to place the grass? <br><a name="habracut"></a><br>  Blue noise is a great noise pattern.  As I mentioned in the first article about grass, he has nice looking properties.  But when I changed the grass system <i>The Witness</i> to more effectively create blue noise, I simply repeated after the one who wrote the code initially.  But who said he made a good decision by choosing a blue noise?  What task exactly did he want to solve, and was the blue noise the best solution?  In the past, I used blue noise for things like grass, but was I sure that under current conditions it would be the best location strategy? <br><br>  When I wrote the previous <a href="https://mollyrocket.com/casey/stream_0013.html">two</a> <a href="https://mollyrocket.com/casey/stream_0014.html">articles</a> and the code that was used to generate these schemes, I realized that the answers to these questions most likely are ‚Äúno‚Äù.  I hinted at this in the previous article, when I said that our approach has a theoretical problem, and now I can clearly say what this problem is, and then return to the attempts of its solution. <br><br><h2>  Rows of corn </h2><br>  Here are a few screenshots of the patterns created by the original techniques of rough searching and sampling of the neighbors, which I discussed earlier: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb1/e54/1b4/cb1e541b4679d2cd418e03667a527605.png"></div><br>  Here is how these patterns look from the point of view of a regular player: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/b12/838/627b128386ed26ec7c1be68b2cafd913.png"></div><br>  And here, finally, what the patterns look like, at each point of which flora billboards are located: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/125/003/5d7/1250035d7723057bff6ed5073117d216.png"></div><br>  As you can see, there is not much difference between them, that is, we did a good job and created a brute force algorithm that can work quite quickly in <i>The Witness</i> .  But if you look at these screenshots a little longer, you can see that it is a bit difficult to understand how generally blue noise is good.  In fact, I have no idea how bad or good these patterns are.  We have no starting point from which we could compare such images.  How can you tell how good the pattern is without some well-known scheme that creates better results? <br><br>  Intuitively, it seemed to me that the blue noise effectively covers the space.  At a higher level, the grass distribution task can be formulated as ‚Äúusing the minimum number of points to create a visually pleasing coverage of the desired area‚Äù.  I say ‚Äúthe minimum number of points‚Äù because, as in the case of any other real-time rendering task, the fewer points you need to adequately cover the space visually, the lower the costs for rendering grass in each frame.  The lower the cost, the more power the graphics system has to render other things.  And in <i>The Witness</i> there are a lot of other things that need to be rendered in each frame, believe me. <br><br>  Therefore, yes, if I didn‚Äôt like filling in some places, I could always be able to increase the density of blue noise by spending more rendering power, but getting a more dense coverage: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4eb/459/66d/4eb45966d1d9873b9e8ddbe9a22ccd47.png"></div><br>  But it is obvious that you need to strive for the lowest possible density, and at the same time create a convincing coverage, so I understood that the required level should be similar to the first screenshots of the article.  Without an excessive amount of points, it may not be possible to avoid empty spots near the player, but a little further away from him the ideal pattern will make the grass beautiful and rich. <br><br>  However, when I experimented with patterns last week, I noticed a very unpleasant thing.  In the same pattern, when the camera is rotated at certain points, parts of the pattern create almost even rows, and obvious voids are noticeable even far from the camera, where ideally there should be enough vegetation overlapping each other: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/213/03d/b3c/21303db3c9d8681ae68761f6c8ce1b96.png"></div><br>  This is noticeable when using both techniques, so it is similar to the property of blue noise in general, or at least all kinds of blue noise generated by the Poisson spot method. <br><br>  For reasons that I will not reveal now, I had to spend some time sitting in the back seat of a car in Nebraska, traveling along the most boring freeway in the world (almost any way in Nebraska can be called that).  If you look at the corn fields from the window, you will notice that the rows of corn have the same property: from a variety of angles they look like corn fields, but looking at the right angle, we will see that they suddenly become very repetitive.  Long and narrow gaps between the rows are visible.  This is quite normal for a corn field, but not quite well when you need to create the illusion of densely growing grass. <br><br>  Because of the similarity to this property of the corn field, I called this problem with blue noise "the Nebraska problem." <br><br>  I did not want the Nebraska problem to interfere with the distribution of grass.  As far as I know, this is a theoretical problem, because there is nothing wrong with the blue noise algorithms themselves.  In this case, the practice is absolutely correct, only theory is inadequate. <br><br>  Since I did not know the theory of noise that could cope with this problem and did not even encounter articles that would mention its existence, I decided to experiment with breaking the rules of blue noise to see if I could solve the Nebraska problem on my own. <br><br><h2>  Experimenting with packing factor </h2><br>  Every time I start researching a new task, I don‚Äôt have a clear idea about it.  I understand that the problem exists, but it has not yet been specifically defined, so I randomly try obvious things. <br><br>  The first thing I tried was to change the way the points were selected by the neighbor selection algorithm.  In the previous article, I did not go into details of how this algorithm selects the points to be checked.  I simply made it take a random point ‚Äúfrom r to 2r‚Äù in a random direction from the base point. <br><br>  This can be done in different ways.  The simplest is to uniformly choose the angle and distance in the range from r to 2r and use them directly.  But if you apply the points selected in this way, you can see that they have a noticeable deviation to the center of the circle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c6/2bc/f0c/4c62bcf0c53dff2a98849d79800749b6.png"></div><br>  What's going on here?  If you think about it, it becomes clear that the larger the radius of the circle, the farther the point on the circle moves as the angle changes.  This means that to cover the perimeter of large circles with the same Euclidean density of random points, we need to take more random angles than when covering small circles.  That is, if we uniformly take a random angle and a random radius, then as a result, smaller radii will always be covered more densely than large ones.  To really select points with a uniform density inside a circle, it is necessary either to select an angle and radius not uniformly to take into account the changing influence of the angle as the radius increases, or, more simply, you can simply select points in a square and discard those that do not fall into a circle. <br><br>  Well, so why am I talking about this?  When implementing the algorithm of selection of neighbors, I usually leave the bias when approaching the center.  It turns out faster, and it turned out that visually it does not affect the finished pattern.  But since my task was to change the pattern, I had to think - what if forcing a sample of points to be even more biased? <br><br>  Therefore, I decided to introduce the concept of "packing ratio".  Instead of selecting points in the gap at a distance from r to 2r from the base point, I made the parameter equal to 2. Thus, I can force all selected points to be closer to the base points, theoretically reducing the average distance of the pattern and creating a denser packing: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/f71/6c1/1d8f716c127bf92ac19efcc9d3fe6efb.png"></div><br>  Unfortunately, this attempt quickly proved its fruitlessness, because the dense packaging emphasized the Nebraska problem even more.  If you look at the patterns, you can understand this: when the packaging becomes more dense, the probability that the two ‚Äúbranches‚Äù of the neighbors selection algorithm will run parallel to each other increases without the possibility of creating more stochastic patterns that dilute the empty space in between. <br><br><h2>  Consider spaces </h2><br>  So, experiments with packaging turned out to be unproductive and it was logical.  I began to think that it might not be enough to allow the points to be placed more flexibly in spaces that are not filled tightly.  Perhaps, if I make a second pass over the original blue noise pattern with a looser placement radius, I can fill the places where the aligned rows create noticeable gaps: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e85/bb2/175/e85bb217523ff61ae8cce091b46c06a3.png"></div><br>  It turned out that it actually works.  At least, it seemed so at first glance.  But when I counted the number of points, I realized that in fact if you simply create a blue noise pattern with the same number of points as when filling in the gaps, it will also be quite dense and will not allow you to avoid the problem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/704/a70/97f/704a7097fb1a2bb691b33b96fe3727dd.png"></div><br>  That is, although the elimination of gaps in the original pattern can bear fruit, I could immediately see how to make this method work efficiently: in fact, it increased the number of points, and did not eliminate the problem with the distribution of existing points. <br><br><h2>  We plant grass along the lines </h2><br>  Having failed with a few modifications of blue noise, I began to try more ridiculous approaches that didn‚Äôt have blue noise properties at all, just to check if there was something interesting.  Returning to the first concepts, I thought: so, if my goal is to avoid lines of sight with spaces, then it may be worthwhile to generate a pattern based on this principle.  Therefore, I wrote an algorithm that selected random lines of sight in the field.  He passed along each of the lines and searched for the lengths of the lines along which a certain distance traveled, without meeting points: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/443/887/6d3/4438876d378536d7168645321b35d7fe.png"></div><br>  Unfortunately, since the algorithm selects random lines, it may well choose two lines right next to each other, which again brings us back to the Nebraska problem.  In some parts of the pattern, it works quite well, but in those parts where the lines are approximately parallel, the Nebraska problem manifests itself in full force. <br><br><h2>  Selective deletion </h2><br>  Similar to the previous method, I thought that it might be worth trying the opposite approach: start with dense coverage of the area generated by white noise, and then remove only those points that do not exactly create long continuous lines of empty space.  Each point had to be checked with a large number of directions, and the algorithm determined where the first ‚Äúhit‚Äù occurred along these lines in the forward and reverse directions.  If the distance along all the tested lines was small, then I deleted this point.  If the resulting distance along any of these lines is too large, then I left a point: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/362/90e/39e36290e693750f3d097833439c3098.png"></div><br>  Unfortunately, it gave results similar to the previous attempt: when setting the parameters in one way, the Nebraska problem disappeared, but the sampling was too dense.  With a different setting of the parameters, the sampling turned out to be too sparse and noticeable gaps appeared everywhere, even if I deliberately tried to avoid the Nebraska problem. <br><br>  At that moment I should have known.  what happens but this did not happen.  It is worth considering that most likely it was in the middle of Wednesday and I realized that I would never have time before my deadline <i>for Witness</i> , so I started to get a little nervous.  I think not clearly enough.  What should I do?  Should I keep pushing or just call and say: ‚Äúwell, I have a problem with the algorithm, and damn if I know how to solve it.  Have a nice environment.  CHRISTMAS CANCELED! ‚Äù. <br><br>  I know how important Santa Claus is to you all.  It is not every day that the fat, constantly smiling bearded grandfather secretly penetrates the house and leaves ‚Äúpresents‚Äù for your children, whom he has ‚Äúwatched‚Äù all year.  Would you really like to be the person who canceled Christmas? <br><br>  No, of course not, and I decided - Christmas cannot be canceled.  Christmas is not canceled.  CHRISTMAS JUST A LIGHTLY POSTPONING. <br><br><h2>  Relaxation </h2><br>  So, well, no problem.  Christmas is postponed.  It was Wednesday, so it may take place on Thursday.  Or on Friday.  Back to work. <br><br>  If you read articles on graphics research, you probably agree with what I will say: if people get into a situation where the algorithm obviously simply does not work, then you should definitely relax.  Can't arrange the points where they are needed?  Relax!  If you can't find a way to put points where they are needed, let them figure it out for yourself. <br><br>  Therefore, I added a relaxation phase.  And I tried to use two different ‚Äúenergy functions‚Äù for relaxation, the first of which was a simple version of ‚Äúchase away other points‚Äù: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/dec/d5f/223decd5f5feb7aa86c1cc3bb388aabf.png"></div><br>  The second was a version of ‚Äúbreak adjacent lines‚Äù: she searched for sets of three or more points that are approximately on the same line, and tried to move one of the internal points in the direction from which there was more open space: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f3/b64/470/0f3b6447059bf49601f803d594950f5b.png"></div><br>  As you can see from the illustrations, none of these strategies looked promising.  Although they were completely situational and I could tune it in order to get better results, I did not see anything in the preliminary results that would mean a big sense in relaxation strategies.  It seemed that no matter how I tried to move the points, they as a result randomly created new corn rows, even if I broke old ones, or the gaps between them turned out to be too large, which was even worse. <br><br>  It was Wednesday night, and it was dinner time.  But it was an unusual environment, so the dinner, too, was supposed to be unusual.  In fact, it was Crazy Wednesday, that is, it was time for a mad dinner on Wednesday. <br><br><h2>  Directional restrictions </h2><br>  Crazy Wednesday is a special day of the week (often they don't even happen on Wednesdays, but I won't say why) when <a href="http://nothings.org/">Shaun Barrett</a> , <a href="http://fgiesen.wordpress.com/">Fabien Guisin</a> , <a href="http://robertoconcerto.blogspot.com/">Jeff Roberts</a> and I are going to have a completely insane time: four programmers are sitting around a table restaurant and within an hour discuss the details of a specific technical problem.  And if this sounds insanely not enough for you, then specifically on that Insane Wednesday we had a special guest - <a href="http://tommyrefenes.tumblr.com/">Tommy Refenes</a> , so I knew that she would be even Crazier than before. <br><br>  A visit to Mad Environment will be useful, because I can discuss the problem with other guys, and maybe I will have a fresh look.  So it happened. <br><br>  After I explained the problem to them, Fabien and Sean came to the conclusion that first of all it was best to prevent the original neighbor selection algorithm from creating lines, thus avoiding the task of correcting the pattern.  If the original random generation algorithm does not create rows, then as a result, patterns can be obtained better than after correcting rows after the process, because eliminating rows is a global problem: you need to move points so that the pattern can change dramatically with this change.  If you do not create rows initially, then the entire pattern will be rowless, that is, the global problem simply disappears. <br><br>  Therefore, I tried heuristics to prevent the creation of lines, for example, making so that each new point would never be along the same line as the previous one: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef7/6ed/e7d/ef76ede7d212d3315a445453c69f7f92.png"></div><br>  Unfortunately, I still got the Nebraska problem.  Even no direct branch of the neighbor selection algorithm created rows, it seems that the neighboring branches were conspiring with each other and still creating rows! <br><br>  It was already starting to get ridiculous.  How is it that each algorithm produces the same artifact?  What's happening? <br><br><h2>  Twisted Hex Pack </h2><br>  Although I was still not overwhelmed by a serious insight, I began to understand what the error was.  I took a step back and thought about what might be necessary to create a pattern without corn rows that would not use too many points.  I began to come to the conclusion that I really needed curves.  I wanted to make the generated lines always give bends to points, because the two curves of a number of points are the pattern in which linear gaps will never be seen.  Any random arrangement can actually create the mutual influence of points, creating adjacent lines, even on each side of just three points - this is enough to show the Nebraska problem.  Therefore, an algorithm that creates a guaranteed absence of gaps may not be random at all, but is constant. <br><br>  This completely changed my approach to the problem.  All this time I thought that for a good coverage accident is obligatory.  But now, after careful consideration of the problem, it seemed to me that an accident could actually be bad. <br><br>  Therefore, I began to think about repeating patterns that may have the properties I need.  They should have looked not obvious when viewed from the point of view of an ordinary player (standing on the grass).  They should not contain continuous straight lines of points.  They must effectively cover the space. <br><br>  I knew that hexagonal packings had the most dense packing for circles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b98/4cf/e19/b984cfe19b54dc0dcb39465ce3333b10.png"></div><br>  Therefore, I decided that if we need to effectively cover the space, then it is probably best to start with hexagonal packaging, because it will position each point at a distance that is visually optimal for coverage, while minimizing the number of points used. <br><br>  But hexagon packs themselves are obviously terrible, because these are corn rows in different directions, that is, not at all what I need.  So I thought - what if I twist the hex wrap?  I tried to interpret the hexagon packing in polar coordinates in order to get curved rows of rows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/156/71b/6e3/15671b6e3fdf4d5a3449528a04142d7f.png"></div><br>  I also tried various turn patterns, similar to the original neighbor selection algorithm, in which I branched out new points in a hexagon pattern, which were turned randomly or permanently. <br><br>  Unfortunately, the hex packs also did not work.  They either left gaps, or created crowding, or made lines in one of the directions.  But, fortunately, it was they who opened my eyes to what exactly my goal is. <br><br>  See - distribution is performed on the plane.  There are always two orthogonal bases on the plane.  Therefore, using one axis of curvature, which I applied for curving hex packing with polar coordinates, would never fit: I would bend one of the axes along which lines could be created, but not the other.  In fact, I needed a distribution of points with two axes of curvature, so that literally there were no possibilities for creating lines in space with any periodicity. <br><br><h2>  Offset concentric intersection packing </h2><br>  Well, well, two axes of curvature, no problem.  I will simply take two circles and place points on my pattern, in which the concentric rings of these circles intersect: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a6/310/010/7a6310010cf14a6f699f412a98508eb8.png"></div><br>  It looked beautiful.  I felt that I could already be close to a solution.  Looking at the distribution from different angles, I saw that the main problem was that the curvature still remained visible, because it was a bit weak in order to visually hide the space between the points.  I thought that it was possible to increase the curvature, but then I thought - what if, let's say, I will shift every third concentric ring of a circle?  Instead of evenly distributed concentric rings, the radius of each third ring will be slightly shifted to introduce noise, and also slightly reduce the noticeable repeatability of the pattern.  I remind you that this is a fully deterministic displacement, that is, in fact there is no chance: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82c/739/f03/82c739f033d6542e0610d79521a40ca5.png"></div><br>  Bingo.  That is the kind of coverage I need!  Dense visible coverage and absolute inability to notice spaces except where you stand (which, of course, cannot be corrected by any pattern except an increase in the number of points and literally a complete coverage of space).  It was possible to completely eliminate the problem areas of the review that appeared in the algorithm without offsets: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/efc/ea1/0c8efcea1d1d287c8ffec7aca6eae2b6.png"></div><br>  There is also a bonus - you can use much fewer points than I took for blue noise with spaces, to get a visually better coverage: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/595/eac/bbd595eacf58eb08bba5a62b3c35c7fe.png"></div><br><h2>  Why so many failures? </h2><br>  As in the case of most difficult problems, when you dive into it, you often cannot find the right view of things.  That is why this is called "dive."  Anyway, looking back at the previous few days, I see the fundamental mistake of my approach. <br><br>  I started with a pretty good random coverage - with blue noise, and I wanted to improve it.  But if you remember what is an accident and how it works, then you can realize a fairly obvious truth: an accident is never optimal.  For any set of criteria, the probability that a set of optimal input data can be chosen randomly is extremely small.  If you take 100 dice and throw them, then you will not get 600. Perhaps never (you can of course use the D20 bones, but I want this metaphor to be understandable and not playing D &amp; D).  It is also impossible to limit randomness in any way.  Even if you take all the cubes and replace all units, twos, threes and fours for sixes, that is, only fives and sixes remain on the cube, you still almost never throw away 600. Even if you do this and transfer all the fives, you will have to do it's seven times until you get all the sixes. <br><br>  Therefore, if you want to do something optimal, then there is a chance that you will have to go beyond random algorithms.  I continued to look for schemes that could create optimality from randomness, but this was very unlikely.  Since the blue noise is quite a good pattern for my purposes, I tried to find a fracture in randomness, and each scheme was doomed to failure, because there is simply no better random scheme.  To make this jump, I had to go from chaos to order and directly control the optimum. <br><br>  In fact, this is a very important lesson that can be learned from this experience.  The pattern itself is not so important.  It is important to understand whether your task is related to optimization, and if so, is it necessary for some other reason to use chance?  If yes, then you have to choose something less than optimal.  If you do not do this, then in order to move on, you will have to abandon chance. <br><br>  As it happens with many discoveries, if you think about it, it is quite simple and practically explains itself.       ,                  ,    . <br><br><h2> ,   </h2><br>     ,  ? , , ,   , ¬´    ¬ª.     ,           ,  .  And that's fine.   ,              . <br><br>  ,            .    ,        ,   ,      <i>The Witness</i> -      .       ,      ,    ,         . <br><br>             .  ,   ¬´ ¬ª    .      ,   ¬´ ¬ª ,   ¬´ ¬ª,      .      ,    ,           .   ,            ,                . </div><p>Source: <a href="https://habr.com/ru/post/345346/">https://habr.com/ru/post/345346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345332/index.html">Kubernetes Service Writing Guide</a></li>
<li><a href="../345336/index.html">We spread the application in the App Store. Even if you are not a developer</a></li>
<li><a href="../345340/index.html">A story about how to create a repository and understand Redux</a></li>
<li><a href="../345342/index.html">What are dangerous social networks on your PC?</a></li>
<li><a href="../345344/index.html">Sending a request to the specified MS SQL Server databases of all the specified servers using available tools</a></li>
<li><a href="../345348/index.html">Adapting RoboVM for compiling for iOS from Windows / Linux</a></li>
<li><a href="../345350/index.html">Adding 3D objects to video</a></li>
<li><a href="../345356/index.html">Universal Dumper / Injector Unity3D (Mono, Android)</a></li>
<li><a href="../345358/index.html">Creating a Christmas animation with Wolfram Language</a></li>
<li><a href="../345362/index.html">Monte Carlo option premium calculation vs Black-Scholes formula</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>