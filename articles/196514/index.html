<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The system of automatic counting circles and time for RC-car. Part 2 Protocols AMB20 and AMBRc</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article I talked about transponders, how information is transmitted from the transponder to the decoder through the air. Today I will ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The system of automatic counting circles and time for RC-car. Part 2 Protocols AMB20 and AMBRc</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/195804/">previous</a> article I talked about transponders, how information is transmitted from the transponder to the decoder through the air.  Today I will tell you how to transfer information about the number and time of the transponder to the computer. <img src="https://habrastorage.org/storage3/661/5f7/2cd/6615f72cde4fa9f434a47a39eabf13df.jpg"><a name="habracut"></a>  Some of the information I picked <a href="http://www.flipsideracing.org/projects/fslapcounter/browser/trunk/Classes/SerialLapCounters.rbbas%3Frev%3D1248">here</a> and on <a href="http://www.rctech.net/forum/radio-electronics/688671-lap-timing-decoder-5.html">rctech.net</a> <h4>  Let's collect the scheme </h4>  And we will collect it on a breadboard without soldering: <img src="https://habrastorage.org/storage3/ff3/f18/f70/ff3f18f704d2a68e51d8f432c3f0a950.jpg">  What we need: 1.  atmega16 (in my device is atmega32, but the essence does not change) 2.  Quartz for USART 7.3728 MHz.  (In my device - 16.59 MHz) 3.  Quartz watch on 32kgts.4.  USB-RS232 adapter5.  The LED, the button and the resistor. In order not to bathe with the MK firmware - we flood it with the bootloader.  Excellent article is on <a href="http://easyelectronics.ru/avr-uchebnyj-kurs-ispolzovanie-bootloadera.html">easyelectronics.ru</a> .  That's it, I use it.  The LED and the button are needed both for the bootloader and for the main program. Our decoder has its own clock for a more accurate calculation of lap times, and how can we make it even more accurate?  Yes, no matter how, just transmit the transponder number and the time when it was passed through the loop. The LED in the bootloader will indicate that the bootloader is loaded.  And in the main program, it will just blink, saying that everything is fine with the clock. With a button, we will imitate the model's passage over the loop.  In principle, any USB-RS232 adapter will do. A circuit in the proteus to see what the terminal gives out: <img src="https://habrastorage.org/storage3/601/1e0/441/6011e04419ee2328a35af5001346e5f0.png"><h4>  AMB20 </h4>  This protocol can be divided into two parts: Initialization of the controller and transmission of information about the transponder and time. <h5>  Counting time </h5>  A timer with 32kHz quartz is interrupted once a second. <pre><code class="cs hljs">interrupt [TIM2_OVF] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer2_ovf_isr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++GlobalS==<span class="hljs-number"><span class="hljs-number">60</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++GlobalM==<span class="hljs-number"><span class="hljs-number">60</span></span>) { GlobalH++; GlobalM=<span class="hljs-number"><span class="hljs-number">0</span></span>; } GlobalS=<span class="hljs-number"><span class="hljs-number">0</span></span>; } LED=!LED; }</code> </pre>  I think everything is clear and simple. <h5>  Initialization </h5>  During initialization, the program opens the COM port and puts the RTS on the ground.  The output of this signal will hang on INT0 controller.  By interrupt, we send to the computer program @ 00000001 and reset the time in the controller: <pre> <code class="cs hljs">delay_ms(<span class="hljs-number"><span class="hljs-number">100</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"@00000001\r\n"</span></span>); GlobalH=<span class="hljs-number"><span class="hljs-number">0</span></span>; GlobalM=<span class="hljs-number"><span class="hljs-number">0</span></span>; GlobalS=<span class="hljs-number"><span class="hljs-number">0</span></span>; GlobalMs=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><h5>  Passing tag through loops </h5>  In order for the program to understand that a label has passed through the loop, it needs to send a record of the form: @ AABBCCDDEE where AAA is the transponder number from 1 to 99BB - hours CC - minutes DD - seconds EE - hundredths of a second <pre> <code class="cs hljs">Trans=<span class="hljs-number"><span class="hljs-number">1</span></span>; MS=GlobalMs_Timer/<span class="hljs-number"><span class="hljs-number">2.56</span></span>; H=GlobalH; M=GlobalM; S=GlobalS; printf(<span class="hljs-string"><span class="hljs-string">"@%02u%02u%02u%02u%02u\r\n"</span></span>,Trans,H,M,S,MS);</code> </pre>  For example: @ 0102030405 means that the transponder with the number 01 passed a loop for 2 hours 3 minutes 4 seconds and 50ms <img src="https://habrastorage.org/storage3/14a/645/3b1/14a6453b1d0fe4449c7ce4fc50ec38d8.png">  Everything is very simple. <div class="spoiler">  <b class="spoiler_title">Program code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/***************************************************** This program was produced by the CodeWizardAVR V2.05.0 Professional Automatic Program Generator ¬© Copyright 1998-2010 Pavel Haiduc, HP InfoTech srl http://www.hpinfotech.com Project : Version : Date : 01.04.2013 Author : Company : Comments: Chip type : ATmega16 Program type : Application AVR Core Clock frequency: 7,372800 MHz Memory model : Small External RAM size : 0 Data Stack size : 256 *****************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#include &lt;mega16.h&gt; #ifndef RXB8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RXB8 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #ifndef TXB8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TXB8 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #ifndef UPE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UPE 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #ifndef DOR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOR 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #ifndef FE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FE 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #ifndef UDRE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UDRE 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #ifndef RXC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RXC 7 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FRAMING_ERROR (1&lt;&lt;FE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PARITY_ERROR (1&lt;&lt;UPE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DATA_OVERRUN (1&lt;&lt;DOR) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DATA_REGISTER_EMPTY (1&lt;&lt;UDRE) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RX_COMPLETE (1&lt;&lt;RXC) // USART Receiver buffer #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RX_BUFFER_SIZE 32 char rx_buffer[RX_BUFFER_SIZE]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> RX_BUFFER_SIZE &lt;= 256 unsigned char rx_wr_index,rx_rd_index,rx_counter; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> unsigned int rx_wr_index,rx_rd_index,rx_counter; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> // This flag is set on USART Receiver buffer overflow bit rx_buffer_overflow; // USART Receiver interrupt service routine interrupt [USART_RXC] void usart_rx_isr(void) { char status,data; status=UCSRA; data=UDR; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((status &amp; (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0) { rx_buffer[rx_wr_index++]=data; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> RX_BUFFER_SIZE == 256 // special case for receiver buffer size=256 </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (++rx_counter == 0) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rx_wr_index == RX_BUFFER_SIZE) rx_wr_index=0; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (++rx_counter == RX_BUFFER_SIZE) { rx_counter=0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> rx_buffer_overflow=1; } } } #ifndef _DEBUG_TERMINAL_IO_ // Get a character from the USART Receiver buffer #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _ALTERNATE_GETCHAR_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> used+ char getchar(void) { char data; while (rx_counter==0); data=rx_buffer[rx_rd_index++]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> RX_BUFFER_SIZE != 256 </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rx_rd_index == RX_BUFFER_SIZE) rx_rd_index=0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #asm("cli") --rx_counter; #asm("sei") return data; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> used- #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> // USART Transmitter buffer #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TX_BUFFER_SIZE 256 char tx_buffer[TX_BUFFER_SIZE]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> TX_BUFFER_SIZE &lt;= 256 unsigned char tx_wr_index,tx_rd_index,tx_counter; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> unsigned int tx_wr_index,tx_rd_index,tx_counter; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> // USART Transmitter interrupt service routine interrupt [USART_TXC] void usart_tx_isr(void) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (tx_counter) { --tx_counter; UDR=tx_buffer[tx_rd_index++]; } } #ifndef _DEBUG_TERMINAL_IO_ // Write a character to the USART Transmitter buffer #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _ALTERNATE_PUTCHAR_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> used+ void putchar(char c) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (tx_counter || ((UCSRA &amp; DATA_REGISTER_EMPTY)==0)) { tx_buffer[tx_wr_index++]=c; ++tx_counter; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> UDR=c; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> used- #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> // Standard Input/Output functions #include &lt;stdio.h&gt; #include &lt;delay.h&gt; char GlobalH,GlobalM,GlobalS,GlobalMs; float TempFloat; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GlobalMs_Timer TCNT2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LED PORTD.7 unsigned int Trans; // External Interrupt 0 service routine interrupt [EXT_INT0] void ext_int0_isr(void) { delay_ms(100); printf("@00000001\r\n"); GlobalH=0; GlobalM=0; GlobalS=0; GlobalMs=0; } interrupt [EXT_INT1] void ext_int1_isr(void) { char H,M,S,MS,Trans; Trans=1; MS=GlobalMs_Timer/2.56; H=GlobalH; M=GlobalM; S=GlobalS; printf("@%02u%02u%02u%02u%02u\r\n",Trans,H,M,S,MS); } interrupt [EXT_INT2] void ext_int2_isr(void) { } interrupt [TIM0_OVF] void timer0_ovf_isr(void) { } interrupt [TIM2_OVF] void timer2_ovf_isr(void) { char i; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (++GlobalS==60) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (++GlobalM==60) { GlobalH++; GlobalM=0; } GlobalS=0; } LED=!LED; } void main(void) { PORTA=0x00; DDRA=0x00; PORTB=0x00; DDRB=0x00; PORTC=0x00; DDRC=0x00; PORTD=0b1001100; DDRD=0x80; TCCR0=0x05; TCNT0=0x00; OCR0=0x00; ASSR=0x08; TCCR2=0x05; TCNT2=0x00; OCR2=0x00; GICR|=0xE0; MCUCR=0x0A; MCUCSR=0x00; GIFR=0xE0; TIMSK=0x41; // USART initialization // Communication Parameters: 8 Data, 1 Stop, No Parity // USART Receiver: On // USART Transmitter: On // USART Mode: Asynchronous // USART Baud Rate: 9600 UCSRA=0x00; UCSRB=0xD8; UCSRC=0x86; UBRRH=0x00; UBRRL=0x2F; #asm("sei") while (1) { } }</span></span></code> </pre></div></div>  The disadvantages of this protocol are obvious - the number of the transponder is not more than 99. Consider another protocol. <h4>  AMBRC </h4>  This protocol requires much more memory from the MK.  Further it will be clear why.  This protocol can be divided into three parts: the initialization of the decoder, the passage through the label and the status of the decoder. <h5>  Initialization </h5>  The program sends the following text to the decoder "?; 0; 0; 0;"  and return the corset (clcf) bytes - (0x0D, 0x0A).  Nothing more interesting in the decoder program does not send.  Therefore, when at the input we have a baytik 0x0A and set the initialization flag (why we need the flags will be described below). <pre> <code class="cs hljs">interrupt [USART_RXC] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usart_rx_isr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> status,data; status=UCSRA; data=UDR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((status &amp; (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==<span class="hljs-number"><span class="hljs-number">0</span></span>) { rx_buffer[rx_wr_index++]=data; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data==<span class="hljs-number"><span class="hljs-number">0x0A</span></span>) {TimeToInit=<span class="hljs-number"><span class="hljs-number">1</span></span>;} <span class="hljs-comment"><span class="hljs-comment">//       #if RX_BUFFER_SIZE == 256 // special case for receiver buffer size=256 if (++rx_counter == 0) { #else if (rx_wr_index == RX_BUFFER_SIZE) rx_wr_index=0; if (++rx_counter == RX_BUFFER_SIZE) { rx_counter=0; #endif rx_buffer_overflow=1; } } }</span></span></code> </pre>  But in the main loop we initialize: <pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TimeToInit) { putchar(<span class="hljs-number"><span class="hljs-number">1</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"$\t%i\t7\t0\t1\t1\t"</span></span>,decoderid); putchar(<span class="hljs-number"><span class="hljs-number">0xF8</span></span>); putchar(<span class="hljs-number"><span class="hljs-number">0xF9</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); GlobalS=<span class="hljs-number"><span class="hljs-number">0</span></span>; GlobalMs_Timer=<span class="hljs-number"><span class="hljs-number">0</span></span>; sequence_number=<span class="hljs-number"><span class="hljs-number">0</span></span>; TimeToInit=<span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre>  I did not find a complete description of the protocol, I found only a partial one.  An entry to the COM port will be sent as follows: <blockquote>  01 24 09 31 30 30 09 37 09 30 09 31 09 31 09 F8 F9 0D 0A </blockquote>  Here the decoder number is 100. The recording always starts with a byte (0x01).  Next comes the $ sign.  Between each value is a Tab (0x09) sign.  All entries end with a carriage return (0x0D 0x0A).  Well, do not forget that you need to reset the time and sequence_number.  sequence_number is the number of the parcel, incremented with each parcel. <h5>  Decoder status </h5>  Every 4 seconds we need to send the status.  Package type: <blockquote>  # 100 980 0 x06BA </blockquote>  The bytes are like this: <blockquote>  01 23 09 31 30 30 09 31 30 32 38 09 30 09 78 39 42 39 46 0D 0A </blockquote>  Here you can see the decoder number, sequence_number, which is zero (I don‚Äôt know why) and the checksum.  The checksum is considered in the putchar procedure: <pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putchar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (tx_counter == TX_BUFFER_SIZE); <span class="hljs-meta"><span class="hljs-meta">#asm("cli") crcwork = (crcTable[(crcwork &gt;&gt; 8) &amp; 0xff] ^ (crcwork &lt;&lt; 8) ^ c); //      </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (tx_counter || ((UCSRA &amp; DATA_REGISTER_EMPTY)==0)) { tx_buffer[tx_wr_index++]=c; ++tx_counter; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> UDR=c; #asm("sei") }</span></span></code> </pre>  The crcTable table is calculated in advance; it is here: <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  flash unsigned int crcTable [256] = {0,4129,8258,12387,16516,20645,24774,28903,33032,37161,41290,45419,49548,53677,57806,61935,4657,528,12915,8786,21173 , 17044,29431,25302,37689,33560,45947,41818,54205,50076,62463,58334,9314,13379,1056,5121,25830,29895,17572,21637,42346,46411,34088,38153,58862,62927 , 50604,54669,13907,9842,5649,1584,30423,26358,22165,18100,46939,42874,38681,34616,63455,59390,55197,51132,18628,22757,26758,30887,2112,6241,10242 , 14371,51660,55789,59790,63919,35144,39273,43274,47403,23285,19156,31415,27286,6769,2640,14899,10770,56317,52188,64447,60318,39801,35672,47931,43802 , 27814,31879,19684,23749,11298,15363,3168,7233,60846,64911,52716,56781,44330,48395,36200,40265,32407.28342,24277,20212,15891,11826,7761,369,65439 , 61374,57309,53244,48923,44858,40793,36728,37256,33193,45514,41451,53516,49453,61774,57711,42424,161,12482,8419,20484,16421,28742,24679,33721,37784 , 41979,46042,49981,54044,58239,62302,689,4752,8947,13010,16949,21012,25207,29270,46570,42443,38312,34185,62830,58703,54  572,50445,13538,9411,5280,1153,29798,25671,21540,17413,42971,47098,34713,38840,59231,63358,50973,55100,9939,14066,1681,5808,26199,30326,17941, 22068,55628,51565,63758,59695,39368,35305,47498,43435,22596,18533,30726,26663,6336,2273,14466,10403,52093,56156,60223,64286,35833,39896,43963,48026, 19061,23124,27191,31254,2801,6864,10931,14994,64814,60687,56684,52557,48554,44427,40424,36297,31782,27655,23652,19525,15522,11395,7392,3265,61215, 65342,53085,57212,44955,49082,36825,40952,28183,32310,20053,24180,11923,16050,3793,7920}; </div></div>  The code for the package itself looks like this: <pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TimeToSendAmbStatus) { sequence_number++; putchar(<span class="hljs-number"><span class="hljs-number">1</span></span>); crcwork=<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>; printf(<span class="hljs-string"><span class="hljs-string">"#\t%i\t%i\t0\t"</span></span>,decoderid,sequence_number); printf(<span class="hljs-string"><span class="hljs-string">"x%02X%02X\r\n"</span></span>,((crcwork&gt;&gt;<span class="hljs-number"><span class="hljs-number">8</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0xff</span></span>),(crcwork&amp;<span class="hljs-number"><span class="hljs-number">0xff</span></span>)); TimeToSendAmbStatus=<span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre>  Here you can see how the sequece_number is incremented.  Initially, 0x01 is sent, then crcwork = 0xFFFF is reset.  Helmet part of the parcel.  At the same time, a checksum is considered.  The next action helmet is our checksum and carriage return.  And so every four seconds: <pre> <code class="cs hljs">interrupt [TIM2_OVF] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer2_ovf_isr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> times; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++times==<span class="hljs-number"><span class="hljs-number">4</span></span>) { TimeToSendAmbStatus=<span class="hljs-number"><span class="hljs-number">1</span></span>; times=<span class="hljs-number"><span class="hljs-number">0</span></span>; } GlobalS++; LED=!LED; }</code> </pre><h5>  Transponder number and time sending </h5>  This is where the difficulties begin.  Transforming the time and the number of the transponder and sending it to the buffer for USART takes a lot of time (as it was about 300ms for me) and that is why I do not send anything directly in the interrupts, but leave this case to the main loop.  In order for everything to work, you need to use an intermediate buffer and some variables: <pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TranspondersCountMax 20 unsigned long int Transponders[TranspondersCountMax]; unsigned long int TranspondersTimeS[TranspondersCountMax]; unsigned int TranspondersTimeMS[TranspondersCountMax]; char TransponderNeedToSend, TranspondersCountInt, TranspondersCountMain;</span></span></code> </pre>  The buffer is cyclical by the way. And this is how we will fill the buffer: <pre> <code class="cs hljs">interrupt [EXT_INT1] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ext_int1_isr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { unsigned <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MS; MS=GlobalMs_Timer*<span class="hljs-number"><span class="hljs-number">3.90625</span></span>; S=GlobalS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TransponderNeedToSend&lt;TranspondersCountMax) { TransponderNeedToSend++; Transponders[TranspondersCountInt]=<span class="hljs-number"><span class="hljs-number">1234567</span></span>; TranspondersTimeS[TranspondersCountInt]=S; TranspondersTimeMS[TranspondersCountInt]=MS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++TranspondersCountInt==TranspondersCountMax) TranspondersCountInt=<span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre>  And in the main loop: <pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TransponderNeedToSend) { sequence_number++; putchar(<span class="hljs-number"><span class="hljs-number">1</span></span>); crcwork=<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>; printf(<span class="hljs-string"><span class="hljs-string">"@\t%i\t%i\t%07lu\t%u.%03u\t130\t119\t2\t"</span></span>, decoderid, sequence_number, Transponders[TranspondersCountMain], TranspondersTimeS[TranspondersCountMain], TranspondersTimeMS[TranspondersCountMain]); <span class="hljs-comment"><span class="hljs-comment">//putchar('@'); //putchar(9); //printf("%i",decoderid); //putchar(9); //printf("%i",sequence_number); //putchar(9); //printf("%07lu",Trans); //putchar(9); //printf("%u.%03u",S,MS); //putchar(9); //printf("130"); //putchar(9); //printf("119"); //putchar(9); //printf("2"); //putchar(9); printf("x%02X%02X\r\n",((crcwork&gt;&gt;8)&amp;0xff),(crcwork&amp;0xff)); if (++TranspondersCountMain==TranspondersCountMax) TranspondersCountMain=0; TransponderNeedToSend--; }</span></span></code> </pre>  The comments indicate the same thing, only easier to understand, because the line "@ \ t% i \ t% i \ t% 07lu \ t% u.% 03u \ t130 \ t119 \ t2 \ t" will break the leg.  Sending one, counting checksum is the same as sending decoder status. <blockquote>  @ 100 10 1234567 37.589 130 119 2 xEB94 </blockquote>  As you can see, everything is very simple. <h4>  A few words about the counting programs </h4>  There are many AMB serif-compatible programs, but I prefer to use RCM Begginers.  It is free, in Russian and very simple.  You can download it <a href="http://www.rc-timing.ch/en/downloads/freeware.html">here</a> .  In Russia, RCM Ultimate (which is cooler and more expensive) is extremely popular among modellers.  Both AMB20 and AMBRc are configured as: <img src="http://habrastorage.org/storage3/603/08c/f38/60308cf38b12160c204d5e950d8b626b.jpg">  I didn‚Äôt really like the rest of the programs. <h4>  Instead of conclusion </h4>  Source codes for CodeVision Avr and a scheme for the proteus can be found <a href="">here</a> Video work: <iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/4Oo95jz4Toc&amp;xid=17259,15700022,15700043,15700186,15700191,15700253,15700256&amp;usg=ALkJrhjj8RpNW61kyenZuNLzslxYGBXHOQ" frameborder="0" allowfullscreen=""></iframe></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/196514/">https://habr.com/ru/post/196514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196494/index.html">Leaseweb hacked</a></li>
<li><a href="../196498/index.html">Mystery of the nebulae- "butterflies"</a></li>
<li><a href="../196500/index.html">How to disable the search on a new tab Chrome</a></li>
<li><a href="../196504/index.html">Sprint Driver - Feel the power of speed</a></li>
<li><a href="../196510/index.html">The digest of news from the world of mobile development for the last week ‚Ññ27 (September 30 ‚Äî October 6, 2013)</a></li>
<li><a href="../196516/index.html">6-axis 3D printer works small wonders</a></li>
<li><a href="../196518/index.html">Writing a server that does not fall under load</a></li>
<li><a href="../196522/index.html">My new tripod ‚ÄúKrutoy_duvuk‚Äù and how I went green</a></li>
<li><a href="../196524/index.html">BlackBerry is negotiating the sale of its assets with Intel, LG, Samsung, Cisco and other</a></li>
<li><a href="../196528/index.html">The FBI does not know what to do with the withdrawn Bitcoins of the Silk Road resource, the FBI does not yet have access to Ross Ulbricht‚Äôs wallet.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>