<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[DotNetBook] Span: new .NET data type</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With this article, I continue to publish a whole series of articles, the result of which will be a book on the work of the .NET CLR, and .NET as a who...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[DotNetBook] Span: new .NET data type</h1><div class="post__text post__text-html js-mediator-article"><p><img width="350" src="https://habrastorage.org/webt/34/ua/e6/34uae6usmglyw10vxga3sgfgh8c.jpeg" align="left">  With this article, I continue to publish a whole series of articles, the result of which will be a book on the work of the .NET CLR, and .NET as a whole (about 200 pages of the book are ready, so welcome to the end of the article for links). </p><br><p>  Both the language and the platform have existed for many years: all this time there have been many means for working with unmanaged code.  So why now comes the next API to work with unmanaged code if in fact it has existed for many, many years?  In order to answer this question, it is enough to understand what we lacked before. </p><br><p> Developers of the platform have tried to help us brighten up everyday development using unmanaged resources: these are automatic wrappers for imported methods.  And marshalling, which in most cases works automatically.  It is also a <code>stackallloc</code> instruction, which is referred to in the chapter on the stack stack.  However, as for me, if early developers using C # came from the world of C ++ (as I did), now they come from higher-level languages ‚Äã‚Äã(for example, I know a developer who came from JavaScript).  And what does it mean?  This means that people are becoming more and more suspicious of uncontrollable resources and constructions that are close in spirit to C / C ++ and even more so to Assembly language. </p><br><blockquote>  The article, though large, is an introduction to the topic Span &lt;T&gt; and Memory &lt;T&gt; <br><ul><li>  <a href="https://habr.com/post/418911/">Span &lt;T&gt;: a new .NET data type</a> </li><li>  <a href="https://habr.com/post/420051/">Span &lt;T&gt; and ReadOnlyMemory &lt;T&gt;</a> </li><li>  Practice using Span &lt;T&gt; and Memory &lt;T&gt; </li></ul><br></blockquote><blockquote><h3>  Note </h3><br>  The chapter published on Habr√© is not updated and it is possible that it is already somewhat outdated.  So, please ask for a more recent text to the original: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub, table of contents</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="">GitHub, chapter</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.2 of the book, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><a name="habracut"></a><br><p>  As a result of such an attitude, there is less and less content of unsafe code in projects and more and more confidence in the API of the platform itself.  This is easily verified if you look for the use of the <code>stackalloc</code> construct on open repositories: it is negligible.  But if you take any code that uses it: </p><br><p>  <strong>Interop.ReadDir class</strong> <br>  <a href="">/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs</a> </p><br><pre> <code class="hljs pgsql">unsafe { // s_readBufferSize <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> zero <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> the native implementation does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support reading <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> a buffer. byte* buffer = stackalloc byte[s_readBufferSize]; InternalDirectoryEntry <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> ret = ReadDirR(dir.DangerousGetHandle(), buffer, s_readBufferSize, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>); // We <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> DirectoryEntry <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ensure there are <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> dangling <span class="hljs-keyword"><span class="hljs-keyword">references</span></span>. outputEntry = ret == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> DirectoryEntry() { InodeName = GetDirectoryEntryName(<span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>), InodeType = <span class="hljs-keyword"><span class="hljs-keyword">temp</span></span>.InodeType } : <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(DirectoryEntry); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br><p>  It becomes clear the reason for the unpopularity.  Look without reading the code and answer one question for yourself: do you trust him?  I can assume that the answer is no.  Then answer the other: why?  The answer will be obvious: besides the fact that we see the word <code>Dangerous</code> , which somehow hints that something can go wrong, the second factor affecting our attitude is the line <code>byte* buffer = stackalloc byte[s_readBufferSize];</code>  more specifically, <code>byte*</code> .  This record is a trigger for anyone to have a thought in their head: ‚Äúwhat else couldn‚Äôt it be possible to do something else?‚Äù.  Then let's understand psychoanalysis a little bit more: why can a similar idea arise?  On the one hand, we use the constructs of the language and the syntax proposed here is far from, for example, C ++ / CLI, which allows you to do anything at all (including inserts on a pure Assembler), and on the other, it looks unusual. </p><br><p>  So what is the question?  How to get developers back into the fold of unmanaged code?  It is necessary to give them a sense of calm that they cannot make a mistake by chance, out of ignorance.  So, what <code> Span&lt;T&gt;</code> and <code>Memory&lt;T&gt;</code> <code> Span&lt;T&gt;</code> introduced for? </p><br><h2 id="spant-readonlyspant">  Span [T], ReadOnlySpan [T] </h2><br><p>  The <code>Span</code> type represents a part of a certain data array, a subrange of its values.  At the same time, allowing, as in the case of an array, to work with elements of this range for both writing and reading.  However, let us, for overclocking and general understanding, compare the types of data for which the implementation of the <code>Span</code> type was made and look at the possible goals of its introduction. </p><br><p>  The first data type you want to talk about is a regular array.  For arrays, working with Span will look like this: </p><br><pre> <code class="hljs php"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> span = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Span&lt;int&gt;(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> position = span.BinarySearch(<span class="hljs-number"><span class="hljs-number">3</span></span>); Console.WriteLine(span[position]); <span class="hljs-comment"><span class="hljs-comment">// -&gt; 3</span></span></code> </pre> <br><p>  As we can see in this example, for a start we create a certain array of data.  After that we create a <code>Span</code> (or a subset), which, referring to the array itself, allows it to the access code only access that range of values ‚Äã‚Äãthat was specified during initialization. </p><br><p>  Here we see the first property of this data type: this is the creation of some context.  Let's develop our idea with contexts: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Main() { var <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> [] {<span class="hljs-string"><span class="hljs-string">'1'</span></span>,<span class="hljs-string"><span class="hljs-string">'2'</span></span>,<span class="hljs-string"><span class="hljs-string">'3'</span></span>,<span class="hljs-string"><span class="hljs-string">'4'</span></span>,<span class="hljs-string"><span class="hljs-string">'5'</span></span>,<span class="hljs-string"><span class="hljs-string">'6'</span></span>}; var span = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Span&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TryParseInt32(span, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> var res)) { Console.WriteLine(res); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine("Failed to parse"); } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> TryParseInt32(Span&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> result) { result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[i] &lt; <span class="hljs-string"><span class="hljs-string">'0'</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[i] &gt; <span class="hljs-string"><span class="hljs-string">'9'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; result = result * <span class="hljs-number"><span class="hljs-number">10</span></span> + ((<span class="hljs-type"><span class="hljs-type">int</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[i] - <span class="hljs-string"><span class="hljs-string">'0'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">----- 234</span></span></code> </pre> <br><p>  As we can see, <code>Span&lt;T&gt;</code> introduces an abstraction of access to a certain section of memory for both reading and writing.  What does this give us?  If we recall, on the basis of what else <code>Span</code> can be made, then we recall both unmanaged resources and lines: </p><br><pre> <code class="hljs pgsql">// Managed <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-string"><span class="hljs-string">'3'</span></span>, <span class="hljs-string"><span class="hljs-string">'4'</span></span>, <span class="hljs-string"><span class="hljs-string">'5'</span></span>, <span class="hljs-string"><span class="hljs-string">'6'</span></span> }; var arrSpan = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Span&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TryParseInt32(arrSpan, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> var res1)) { Console.WriteLine(res1); } // String var srcString = "123456"; var strSpan = srcString.AsSpan().<span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TryParseInt32(strSpan, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> var res2)) { Console.WriteLine(res2); } // <span class="hljs-type"><span class="hljs-type">void</span></span> * Span&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt; buf = stackalloc <span class="hljs-type"><span class="hljs-type">char</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>]; buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'1'</span></span>; buf[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'2'</span></span>; buf[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-string"><span class="hljs-string">'3'</span></span>; buf[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-string"><span class="hljs-string">'4'</span></span>; buf[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-string"><span class="hljs-string">'5'</span></span>; buf[<span class="hljs-number"><span class="hljs-number">5</span></span>] = <span class="hljs-string"><span class="hljs-string">'6'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TryParseInt32(buf.<span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> var res3)) { Console.WriteLine(res3); } <span class="hljs-comment"><span class="hljs-comment">----- 234 234 234</span></span></code> </pre> <br><p>  That is, it turns out that <code>Span&lt;T&gt;</code> is a unification tool for working with memory: managed and unmanaged, which guarantees safety in working with this kind of data during the Garbage Collection: if the sections of memory with controlled arrays move, then for it will be safe for us. </p><br><p>  However, is it worth it so much joy?  Was it possible to achieve all this before?  For example, if we talk about managed arrays, then there is even no doubt: just wrap the array in another class, providing a similar interface and everything is ready.  Moreover, a similar operation can be done with strings: they have the necessary methods.  Again, just wrap the string in the exact same type and provide methods for working with it.  Another thing is that in order to store a string, buffer or array in one type, you will have to tinker strongly, storing references to each of the possible options in a single copy (of course, there will be only one active): </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> OurSpan&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T[] _array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _str; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T * _buffer; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Or if to make a start from architecture, then to do three types inheriting the uniform interface.  It turns out that in order to make a single interface tool between these <code>managed</code> data types, while maintaining maximum performance, a path other than <code>Span&lt;T&gt;</code> does not exist. </p><br><p>  Further, if we continue the reasoning, what is a <code>ref struct</code> in terms of <code>Span</code> ?  These are the very ‚Äústructures, they are only on the stack,‚Äù which we so often hear about at interviews.  This means that this data type can only go through the stack and has no right to go to the heap.  That is why <code>Span</code> , being a ref structure, is a context data type that ensures the operation of methods, but not objects in memory.  From this for his understanding and it is necessary to make a start. </p><br><p>  From here we can formulate the definition of the type Span and the readonly type associated with it of type ReadOnlySpan: </p><br><blockquote>  Span is a data type that provides a single interface for working with heterogeneous types of data arrays, as well as the ability to transfer a subset of this array to another method so that regardless of the context depth, the access speed to the original array is constant and as high as possible. </blockquote><p>  And really: if we have something like this: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; buffer</span></span></span><span class="hljs-function">)</span></span> { buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; Method2(buffer.Slice(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)); } Method2(Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; buffer) { buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; Method3(buffer.Slice(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)); } Method3(Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; buffer) { buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  then the speed of access to the source buffer will be as high as possible: you are not working with a managed object, but with a managed pointer.  Those.  not with the .NET managed type, but with an unsafe type enclosed in a managed shell. </p><br><h3 id="spant-na-primerah">  Span [T] on examples </h3><br><p>  The person is so arranged that often until he gets a certain experience, then the final understanding for which the necessary tool often does not come.  Therefore, since we need some experience, let's turn to examples. </p><br><h4 id="valuestringbuilder">  ValueStringBuilder </h4><br><p>  One of the most algorithmically interesting examples is the <code>ValueStringBuilder</code> type, which is prikopan somewhere in the depths of <code>mscorlib</code> and for some reason, like many other interesting data types, is marked with the <code>internal</code> modifier, which means that if you didn‚Äôt study the source code mscorlib, we would would never know. </p><br><p>  What is the main disadvantage of the StringBuilder system type?  This is of course its essence: both he himself and what he is based on (and this is an array of <code>char[]</code> characters) are reference types.  And this means at least two things: we still (albeit slightly) load a bunch and the second - we increase the odds of a miss in the processor caches. </p><br><p>  Another question that I had to StringBuilder - is the formation of small strings.  Those.  when the resulting string "give a tooth" is short: for example, less than 100 characters.  When we have sufficiently short formatting, performance raises questions: </p><br><pre> <code class="hljs cs"> <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string"> is in range [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{min}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{max}</span></span></span><span class="hljs-string">]"</span></span></code> </pre> <br><p>  How much worse is this record than manual shaping via StringBuilder?  The answer is far from always obvious: everything strongly depends on the place of formation: how often this method will be called.  After all, first <code>string.Format</code> allocates memory for an internal <code>StringBuilder</code> , which will create an array of characters (SourceString.Length + args.Length * 8) and if during the formation of the array it turns out that the length was not guessed, then another <code>StringBuilder</code> will be created to form the continuation, thus forming a single-linked list.  As a result, it will be necessary to return the generated string: this is another copy.  Tranquility and waste.  Now, if we could get rid of placing the first string in the heap of the first array, it would be great: we would definitely get rid of one problem. </p><br><p>  Take a look at the type from the depths of <code>mscorlib</code> : </p><br><p>  <strong>Class ValueStringBuilder</strong> <br>  <a href="">/ src / mscorlib / shared / System / Text / ValueStringBuilder</a> </p><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> struct ValueStringBuilder { //           private <span class="hljs-type"><span class="hljs-type">char</span></span>[] _arrayToReturnToPool; //     private Span&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt; _chars; private <span class="hljs-type"><span class="hljs-type">int</span></span> _pos; //    ,       <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> ValueStringBuilder(Span&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt; initialBuffer) { _arrayToReturnToPool = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; _chars = initialBuffer; _pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> Length { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; _pos; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-type"><span class="hljs-type">int</span></span> delta = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - _pos; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Append(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>, delta); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _pos = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } } //   -       <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> override string ToString() { var s = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> string(_chars.<span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, _pos)); Clear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; } //       //     :   <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> count) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_pos &gt; _chars.Length - count) { Grow(count); } <span class="hljs-type"><span class="hljs-type">int</span></span> remaining = _pos - <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>; _chars.<span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, remaining).CopyTo(_chars.<span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + count)); _chars.<span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, count).Fill(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); _pos += count; } [MethodImpl(MethodImplOptions.AggressiveInlining)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Append(<span class="hljs-type"><span class="hljs-type">char</span></span> c) { <span class="hljs-type"><span class="hljs-type">int</span></span> pos = _pos; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; _chars.Length) { _chars[pos] = c; _pos = pos + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { GrowAndAppend(c); } } [MethodImpl(MethodImplOptions.NoInlining)] private <span class="hljs-type"><span class="hljs-type">void</span></span> GrowAndAppend(<span class="hljs-type"><span class="hljs-type">char</span></span> c) { Grow(<span class="hljs-number"><span class="hljs-number">1</span></span>); Append(c); } //   ,     //         //            //           [MethodImpl(MethodImplOptions.NoInlining)] private <span class="hljs-type"><span class="hljs-type">void</span></span> Grow(<span class="hljs-type"><span class="hljs-type">int</span></span> requiredAdditionalCapacity) { <span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>(requiredAdditionalCapacity &gt; _chars.Length - _pos); <span class="hljs-type"><span class="hljs-type">char</span></span>[] poolArray = ArrayPool&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt;.Shared.Rent(Math.Max(_pos + requiredAdditionalCapacity, _chars.Length * <span class="hljs-number"><span class="hljs-number">2</span></span>)); _chars.CopyTo(poolArray); <span class="hljs-type"><span class="hljs-type">char</span></span>[] toReturn = _arrayToReturnToPool; _chars = _arrayToReturnToPool = poolArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (toReturn != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ArrayPool&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt;.Shared.<span class="hljs-keyword"><span class="hljs-keyword">Return</span></span>(toReturn); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] private <span class="hljs-type"><span class="hljs-type">void</span></span> Clear() { <span class="hljs-type"><span class="hljs-type">char</span></span>[] toReturn = _arrayToReturnToPool; this = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> safety, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> avoid <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> pooled <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> this instance <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> erroneously appended <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> again <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (toReturn != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ArrayPool&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt;.Shared.<span class="hljs-keyword"><span class="hljs-keyword">Return</span></span>(toReturn); } } //  :       private <span class="hljs-type"><span class="hljs-type">void</span></span> AppendSlow(string s); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> TryCopyTo(Span&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt; destination, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> charsWritten); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Append(string s); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Append(<span class="hljs-type"><span class="hljs-type">char</span></span> c, <span class="hljs-type"><span class="hljs-type">int</span></span> count); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> unsafe <span class="hljs-type"><span class="hljs-type">void</span></span> Append(<span class="hljs-type"><span class="hljs-type">char</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> length); <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Span&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt; AppendSpan(<span class="hljs-type"><span class="hljs-type">int</span></span> length); }</code> </pre> <br><p>  This class is similar in functionality to its older brother, <code>StringBuilder</code> , while possessing one interesting and very important feature: it is a significant type.  Those.  stored and transmitted entirely by value.  And the newest modifier type <code>ref</code> , which is assigned to the type declaration signature, tells us that this type has an additional limitation: it has the right to be only on the stack.  Those.  outputting its instructions in the class fields will result in an error.  Why all these squats?  To answer this question, just look at the <code>StringBuilder</code> class, the essence of which we have just described: </p><br><p>  <strong>Class StringBuilder</strong> <a href="">/src/mscorlib/src/System/Text/StringBuilder.cs</a> </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StringBuilder</span></span> : <span class="hljs-title"><span class="hljs-title">ISerializable</span></span> { <span class="hljs-comment"><span class="hljs-comment">// A StringBuilder is internally represented as a linked list of blocks each of which holds // a chunk of the string. It turns out string as a whole can also be represented as just a chunk, // so that is what we do. internal char[] m_ChunkChars; // The characters in this block internal StringBuilder m_ChunkPrevious; // Link to the block logically before this block internal int m_ChunkLength; // The index in m_ChunkChars that represent the end of the block internal int m_ChunkOffset; // The logical offset (sum of all characters in previous blocks) internal int m_MaxCapacity = 0; // ... internal const int DefaultCapacity = 16;</span></span></code> </pre> <br><p>  StringBuilder is a class within which there is a reference to an array of characters.  Those.  when you create it, then at least two objects are created: a StringBuilder itself and an array of characters of at least 16 characters (by the way, this is why it is so important to set the expected length of the string: its construction will go through the generation of a simply connected list of 16-character arrays. Agree, waste ).  What does this mean in the context of our conversation about the type ValueStringBuilder: by default is absent, since  it borrows memory from the outside, plus it itself is a significant type and forces the user to place a buffer for characters on the stack.  As a result, the entire instance of the type is placed on the stack along with its contents, and the question of optimization here becomes resolved.  No heap allocation?  No problem with subsidence performance.  But you tell me: why then do not use ValueStringBuilder (or its self-written version: it‚Äôs internal itself and is not available to us) always?  The answer is this: you have to look at the problem that you are solving.  Will the resulting string be of known size?  Will she have some known maximum length?  If the answer is "yes" and if the size of the string does not exceed some reasonable limits, then you can use a meaningful version of StringBuilder.  Otherwise, if we expect long lines, we switch to using the regular version. </p><br><h4 id="valuelistbuilder">  ValueListBuilder </h4><br><p>  The second data type, which I would especially like to note, is the <code>ValueListBuilder</code> type.  It was created for situations where it is necessary for a short time to create a certain collection of elements and immediately give it to the processing of some algorithm. </p><br><p>  Agree: the task is very similar to the <code>ValueStringBuilder</code> task.  Yes, and it is solved in a very similar way: </p><br><p>  <strong><a href="">ValueListBuilder.cs</a> file</strong> </p><br><p>  Speaking directly, such situations are quite frequent.  However, earlier we solved this question in another way: we created a <code>List</code> , filled it with data and lost the link.  If the method is called often enough, a sad situation arises: many instances of the <code>List</code> class hang in the heap, and along with them the arrays associated with them hang in the heap.  Now this problem is solved: no additional objects will be created.  However, as in the case of <code>ValueStringBuilder</code> , it is solved only for Microsoft programmers: the class has the modifier <code>internal</code> . </p><br><h3 id="pravila-i-praktika-ispolzovaniya">  Rules and practice of use </h3><br><p>  In order to finally understand the essence of a new data type, it is necessary to ‚Äúplay around‚Äù with it by writing a couple of, or better, more methods that use it.  However, the basic rules can be learned now: </p><br><ul><li>  If your method will process some incoming data set without changing its size, you can try to stay on the <code>Span</code> type.  If there is no modification of this buffer, then on the type <code>ReadOnlySpan</code> ; </li><li>  If your method will work with strings, calculating some statistics or parsing a string, your method <em>must</em> accept <code>ReadOnlySpan&lt;char&gt;</code> .  Exactly: this is a new rule  After all, if you accept a string, you are forcing someone to make a substring for you </li><li>  If it is necessary within the framework of the method to make a fairly short array with data (say, 10Kb maximum), then you can easily organize such an array using <code>Span&lt;TType&gt; buf = stackalloc TType[size]</code> .  However, of course, TType should only be a significant type, since  <code>stackalloc</code> only works with meaningful types. </li></ul><br><p>  In other cases, it is worth looking at either <code>Memory</code> or using classic data types. </p><br><h3 id="kak-rabotaet-span">  How Span Works </h3><br><p>  Additionally, I would like to talk about how Span works and what is so remarkable about it.  And there is something to talk about: the data type itself is divided into two versions: for .NET Core 2.0+ and for all others. </p><br><p>  <strong>File <a href="">Span.Fast.cs, .NET Core 2.0</a></strong> </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Span&lt;T&gt; { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    .NET    internal readonly ByReference</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> _pointer; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">      private readonly int _length; // ... }</span></span></code> </pre> <br><p>  <strong>File ???</strong>  <strong>[decompiled]</strong> </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Span&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> System.Pinnable&lt;T&gt; _pinnable; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IntPtr _byteOffset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  The thing is that the <em>large</em> .NET Framework and .NET Core 1. * do not have a specially modified garbage collector (unlike the version of .NET Core 2.0+) and therefore have to drag along an additional pointer: to the beginning of the buffer with which Job.  That is, it turns out that <code>Span</code> internally works with managed objects of the .NET platform as unmanaged.  Look at the insides of the second variant of the structure: there are three fields there.  The first field is a link to the managed object.  The second is the offset from the beginning of this object in bytes to get the beginning of the data buffer (in rows this is a buffer with <code>char</code> characters, in arrays it is a buffer with data of an array).  And, finally, the third field - the number of items laid one after another of this buffer. </p><br><p>  For example, take the <code>Span</code> job for strings: </p><br><p>  <strong><a href="">Coreclr :: src / System.Private.CoreLib / shared / System / MemoryExtensions.Fast.cs file</a></strong> </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ReadOnlySpan&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsSpan</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadOnlySpan&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> text.GetRawStringData(), text.Length); }</code> </pre> <br><p>  Where <code>string.GetRawStringData()</code> looks like this: </p><br><p>  <strong><a href="">Coreclr :: src / System.Private.CoreLib / src / System / String.CoreCLR.cs field definition file</a></strong> </p><br><p>  <strong>GetRawStringData definition file <a href="">coreclr :: src / System.Private.CoreLib / shared / System / String.cs</a></strong> </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> sealed partial <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> String : IComparable, IEnumerable, IConvertible, IEnumerable&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>&gt;, IComparable&lt;string&gt;, IEquatable&lt;string&gt;, ICloneable { // // These fields map directly onto the fields <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> an EE StringObject. See <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.h <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the layout. // [NonSerialized] private <span class="hljs-type"><span class="hljs-type">int</span></span> _stringLength; // <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> empty strings, this will be <span class="hljs-string"><span class="hljs-string">'\0'</span></span> since // strings are <span class="hljs-keyword"><span class="hljs-keyword">both</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>-terminated <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> length prefixed [NonSerialized] private <span class="hljs-type"><span class="hljs-type">char</span></span> _firstChar; <span class="hljs-type"><span class="hljs-type">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-type"><span class="hljs-type">char</span></span> GetRawStringData() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _firstChar; }</code> </pre> <br><p>  Those.  it turns out that the method climbs directly into the line, and the <code>ref char</code> specification allows you to track the GC unmanaged link inside the line, moving it along with the line during the GC response. </p><br><p>  The same story happens with arrays: when <code>Span</code> is created, some code inside the JIT calculates the offset of the beginning of the array data and initializes <code>Span</code> this offset.  And how to calculate the displacements for strings and arrays, we learned in the chapter about the structure of objects in memory. </p><br><h3 id="spant-kak-vozvraschaemoe-znachenie">  Span [T] as return value </h3><br><p>    ,   <code>Span</code> ,    ,        .     : </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = GetSpan(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Span&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSpan</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; reff = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reff; }</code> </pre> <br><p>       . ,     : </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = GetSpan(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Span&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSpan</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; reff = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reff; }</code> </pre> <br><p>      .    , ,     ,       . </p><br><p> ,  ,   ,    ,      .  ,          .         ,   ,     ,       x[0.99]    . </p><br><p> ,  ,        ,     ,  : <code>CS8352 Cannot use local 'reff' in this context because it may expose referenced variables outside of their declaration scope</code>   :     ,   , ,                  . </p><br><h2 id="esli-poyavilis-voprosy">    </h2><br><p>   <code>Span&lt;T&gt;</code>  ,  .         ,    use cases    . </p><br><blockquote><h3>  Link to the whole book </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.0 books, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/418911/">https://habr.com/ru/post/418911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418901/index.html">The Russians won the most gold medals of the European Olympiad in Informatics eJOI 2018</a></li>
<li><a href="../418903/index.html">Scientists: there is not enough CO‚ÇÇ on Mars to warm the atmosphere. The explosion of the poles will not help</a></li>
<li><a href="../418905/index.html">InlineKeyboard in Telegram Bots</a></li>
<li><a href="../418907/index.html">How to teach Zabbix to send problem notifications directly to the desktop</a></li>
<li><a href="../418909/index.html">"Python takes the lead": who uses it and why</a></li>
<li><a href="../418913/index.html">UE4 | Inventory for Multiplayer # 1 | Data Store on DataAsset</a></li>
<li><a href="../418915/index.html">Balancing traffic between web servers using IP CEF on network equipment</a></li>
<li><a href="../418917/index.html">Security starts with a home router</a></li>
<li><a href="../418919/index.html">On the professional growth of the designer and work with stress. And how to find strength in the most difficult times</a></li>
<li><a href="../418921/index.html">4 libraries that simplify the life of a React-developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>