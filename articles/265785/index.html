<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data Access Layer as a storage management tool</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When designing the full life cycle of an Enterprise application, the issue of organizing their access to data becomes very important. There are severa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data Access Layer as a storage management tool</h1><div class="post__text post__text-html js-mediator-article">  When designing the full life cycle of an Enterprise application, the issue of organizing their access to data becomes very important.  There are several reasons for this: <br><ul><li>  pricing or other data warehouse vendor policies change regularly, but enterprises using storage data do not always agree with these changes; </li><li>  With the growth of the enterprise itself and the scale of its IT infrastructure, existing data storage solutions may cease to meet its needs or financial capabilities; </li><li>  data storage technologies are evolving, new tools are emerging, designed to solve specialized tasks; </li><li>  as part of open source projects, cheap or even free alternatives to expensive commercial solutions are being developed. </li></ul><br>  All this may lead to the fact that at some point the company wants (or will be forced) to change the data storage technology or start using new technologies simultaneously with the current ones.  However, if during the design of automated systems their business logic was not separated from working with data warehouses, then a change in the storage tool can lead to costly and poorly managed migration. <br><br>  The problem of separating business logic and working with data at the level of an individual application is solved by the widely known architectural template Data Access Layer (DAL), which is described more than once in Habrahabr.  In order for this template to be scaled to the level of the entire enterprise, it is necessary to supplement it with a number of architectural principles that are discussed in this article.  Following these principles will allow an enterprise to perform a controlled (controlled) replacement or add storage technology to its IT architecture. <br><a name="habracut"></a><br><h2>  Problematics </h2><br>  <i>This section describes in more detail the original issues and prerequisites that led to the development of the DAL concept.</i> <br><br><h3>  The need to work with specialized databases </h3><br>  Currently, classic relational database management systems (RDBMS) have ceased to be the only means for solving the problem of data storage during application development.  From universal DBMS is the transition to specialized.  At the same time, specialization of storage means goes in different directions: by volume (Big Data class), load (HighLoad class), performance (High Performance, Fast Data classes), etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For the architecture of a particular application, the selection of a means or class of storage means for a specific task being solved is included in the norm.  For large-scale IT systems, the simultaneous use of several databases of various types within one application (heterogeneous storage, Fig. 1) for different groups of data is often optimal. <br><br><img src="https://habrastorage.org/files/5b0/83e/0de/5b083e0debf148eea3c8e0657fcfd489.png"><br>  <i>Fig.</i>  <i>1. Universal and specialized databases</i> <br><br>  For example, for individual tasks that do not need to present simple structure data in the relational model, but require increased performance and scalability requirements, specialized key-value (key-value) storages may be used.  For other special types of data (document, photo, video, excel, text) and various non-functional requirements, there are a lot of other means of storage with various access interfaces (NoSQL) that are widely used. <br><br>  At the same time, the SQL language remains the most suitable interface for working with relational data, when an application requires complex data structures and analytical queries with moderate non-functional requirements (volumes of stored data, scaling, parallel processing, performance). <br><br>  Thus, a modern enterprise with a developed IT architecture is increasingly confronted with the need to move away from the ‚Äúsingle gold standard‚Äù of the applied DBMS (often Oracle or Microsoft databases) and find themselves face to face with the need to provide the application infrastructure in the form of multiple databases and warehouses , including the NoSQL class. <br><br>  At the level of application architecture, this leads to the emergence of many previously inaccessible opportunities to use specialized databases, which allows us to speed up development, reduce maintenance costs, provide fundamentally new business opportunities (if, of course, new opportunities are used wisely).  For example, the use of cluster databases with storage in memory (the so-called in-memory database, characteristic representatives - VoltDB or SAP HANA) can implement a radically different approach to solving business intelligence problems by speeding up calculations by several orders of magnitude. <br><br>  In turn, at the level of the technical architecture of an enterprise, there is a need to work with a large number of heterogeneous databases, which significantly complicates and increases the cost of all IT service processes, requires retraining of specialists, leads to more complex management tasks, including life cycle management of the technologies used. <br><br>  The optimal solution of the listed problems should combine, on the one hand, the possibility of simultaneous use of several modern specialized databases, and on the other, controllability of this design at the level of the general policy and technological strategy of the enterprise. <br><br><h3>  Environmental Impact </h3><br>  The second significant factor initiating the process of change in the technical infrastructure of an enterprise is the change in the commercial (or other) conditions of the solution providers for the enterprise.  This is especially true for RDBMS, with which business applications are often more closely connected than with operating systems, network equipment or file storage systems. <br><br>  Under certain conditions, there may be an urgent need to replace RDBMS of certain suppliers.  In this case, an urgent replacement of the database in many actively working business applications can be extremely expensive and complex project, fraught with disruptions and downtime of information systems, and as a result - and business.  To eliminate the risk of getting into such a difficult situation for an enterprise could be a gradual and systematic preparation of business applications for a DBMS change should the need arise. <br><br><h3>  The need for modernization and technological development </h3><br>  The emergence of the task of replacing storage facilities can be caused not only by a change in external conditions, but also by the need for technological modernization and development. <br><br>  In the case of external changes, the architect is faced with the fact that the storage medium used is outdated, no longer maintained by the manufacturer, or has lost competitiveness for other reasons.  If replacement of the storage medium requires substantial processing of the application, it will remain irrational from the point of view of expenditure of funds for a long time.  As a result, part of the enterprise architecture is gradually becoming obsolete morally, and the IT service is beginning to experience problems with support, maintenance and staffing, since it is difficult to select employees to work with outdated products. <br><br>  In the second case, even if the competitiveness of a specific storage medium is preserved, trends and technological development tasks may require a transition to new technologies, opening up fundamentally different opportunities for the development of application functionality.  If an existing application is closely connected with one type of database or only one type of database is fixed within the framework of the entire enterprise architecture, then many opportunities for developing business applications are closed. <br><br><h2>  Data Access Layer Concept </h2><br>  <i>This section describes the general concept and principles of DAL, with which you can solve the above problems.</i>  <i>Here the concept is described in the abstract and is not yet associated with the use of certain technologies or software products.</i> <br><br><h3>  Principle of managed specialized storage </h3><br>  So, the concept being developed should correspond to the set problem: <br><ul><li>  to ensure the possibility of using specialized databases in the IT architecture of an enterprise while maintaining controllability (for example, by controlling their diversity and use); </li><li>  prepare business applications for a smooth and technological change of the DBMS in case of aggravation of relations with the supplier of the DBMS or, possibly, for reasons of technological modernization and technological development. </li></ul><br>  The concept is based on the principle of managed specialized data storage, which introduces a unified and controlled way to access various data for applications (Fig. 2). <br><br><img src="https://habrastorage.org/files/d80/440/a9d/d80440a9d99746c08ac8af5c34bd1007.png"><br>  <i>Fig.</i>  <i>2. The principle of managed specialized data storage</i> <br><br>  At the level of enterprise technology policy, a fixed set of data classes is defined for which some storage facilities are provided in the infrastructure.  At the same time, each data class assumes a specialized access interface (so far - at the logical level) that is optimal for this class.  For example, for the key-value data class, the access interface must provide read and write operations on the key.  And for the ‚Äúrelational model‚Äù data class, the access interface is represented as some fixed SQL dialect. <br><br>  For each such logical data class, the infrastructure can provide storage with a different level of non-functional requirements that is clearly fixed by some SLA (defined by the class of storage). <br><br>  Enterprise applications request and use various classes of data and corresponding access interfaces, abstracting from specific technologies that currently implement one or another interface.  Access control to various databases is provided in a controlled mode, and the application ‚Äúdoes not know‚Äù with which implementation of the database it works. <br><br>  As a result, on the one hand, an application can use specialized storage facilities, accessing them through a well-defined software interface.  On the other hand, if it is necessary to replace a particular DBMS with a similar one, you will not have to make serious modifications in the application.  In extreme cases, a relatively inexpensive adaptation to the fine features of the new technology without the need to revise the architecture.  The entire structure of access to data ‚Äúapplications - various DBMS‚Äù across the enterprise becomes observable and controlled. <br><br><h3>  Restricting the way data is accessed at the software architecture level </h3><br><br><img src="https://habrastorage.org/files/41f/e4c/a9c/41fe4ca9c2cb45d8b2309fb0a04450a5.png"><br>  <i>Fig.</i>  <i>3. Restriction of access to data at the level of software architecture</i> <br><br>  Another important principle of DAL is related to the mechanism for providing the chosen data access method for business applications (Fig. 3).  Theoretically, it would be sufficient to fix a number of data access restrictions at the level of the architectural policy of the enterprise and monitor compliance with these restrictions when designing and developing information systems. <br><br>  However, in practice such control is rather difficult to organize.  This requires time-consuming expensive expert architects from the enterprise.  At the same time, it is still possible that, for one reason or another, the manufacturer of the information system will not go beyond the contractual class of data and SLA.  The accumulation of such precedents over time leads to the fact that the application is not portable to another DBMS, despite the formally limited data access interface. <br><br>  The solution to this problem can only be a rigid separation of the application from the DBMS in such a way that the application basically does not get direct access to the DBMS, but works only through a specialized data access module - this is the Data Access Layer.  In essence, it turns out that DAL fixes the architectural policy of an enterprise in terms of data access at the level of software architecture, which gives much more guarantees for the fulfillment of a data class contract compared to fixation at the level of specifications and agreements. <br><br>  For information systems implemented on different basic technologies and requiring different data access interfaces, the implementation of DAL modules may be different.  Instances of these modules may also be different for different applications, and may be common - for reasons of economy of resources or, on the contrary, to ensure the independence of the functioning of systems.  But in all cases, the principle of indirect application access to the storage facilities should be respected. <br><br><h3>  Removal of business logic from the database </h3><br>  The principle of separation of applications from storage facilities through unified access interfaces can solve the problem of a rapid transition to alternative storage technology, but only if the application itself is deployed outside the database.  In practice, information systems are still often found and actively used, in which a substantial part of the business logic of an application is implemented within the DBMS in the embedded procedural language.  For such systems, easy portability to other DBMS can be ensured only by processing the system with the removal of business logic from the DBMS to a separate application server. <br><br>  For all newly developed or actively developed systems, it is also necessary to control that a large amount of functionality does not accumulate inside the DBMS, which can make it difficult to switch to another means of storage.  It is technically rather difficult to control this, since it is necessary to embed an intermediate link not only in the process of accessing data, but also in the process of managing data structures and DBMS settings.  Therefore, such control should be provided when deploying new systems and their updates, as well as in the processes of architectural audit of the proposed technical solutions with the help of expert evaluation. <br><br><h3>  Concepts </h3><br>  <i>This section refines and details the DAL description object model briefly introduced in the previous section.</i> <br><br><img src="https://habrastorage.org/files/6b4/d25/543/6b4d25543d8e402aa7f8887dea0b126e.png"><br>  <i>Fig.</i>  <i>4. Conceptual model of the DAL concept</i> <br><br>  The concept introduces several concepts (Fig. 4): <br><ul><li>  data class; </li><li>  storage facility; </li><li>  storage facility characteristic; </li><li>  storage class; </li><li>  data group; </li><li>  data container. </li></ul><br>  These concepts and taxonomies are used as a methodical tool for designing speakers, as well as a means of managing the level of data storage across the enterprise. <br><br><h4>  Data class </h4><br>  Defines an ideal data abstraction, independent of either specific technologies or implementation limitations: <br><ul><li>  an abstract (‚Äúlogical-mathematical‚Äù) model of the data itself (for example, ‚Äúa set of relational relations‚Äù or ‚Äúa set of key-value pairs‚Äù); </li><li>  a model (or several models) of data access and calculations over data (for example, ‚Äúrelational algebra‚Äù or MapReduce); </li><li>  security model (for example, "named containers", "users" and "rights"); </li><li>  data structure model (for example, ‚Äúschema with description of tables‚Äù or ‚Äúlist of attribute groups‚Äù). </li></ul><br>  At the data class level, there are still no transactional issues, no performance issues, or in-memory type implementation characteristics.  The business logic of an application is implemented on the basis of a specific data class, and a change in the class of data cannot happen without redesigning the application logic. <br><br><h4>  Data structure </h4><br>  Defines a data structure in a certain model (defined by a data class) that is specific to a particular application: for example, for a relational model, a list of tables, columns, and keys. <br><br><h4>  Storage facilities </h4><br>  Specific storage facilities on the market or deployed in the enterprise (various types of databases) provide the capabilities of one or several classes of storage for several classes of data. <br><br><h4>  Feature Storage </h4><br>  Represents any significant numerical, qualitative characteristic or binary sign of the storage medium: <br><ul><li>  read / write performance; </li><li>  scalability; </li><li>  work in memory (in-memory); </li><li>  restrictions; </li><li>  specialization (for example, Big Data or Fast Data); </li><li>  support for ACID transactions, etc. </li></ul><br><br><h4>  Storage Class (SLA) </h4><br>  Within the framework of one data class groups such a set of storage characteristics, which, on the one hand, is often required in applications, and on the other hand, provides an alternative implementation (storage facility). <br><br>  Different data classes may define different SLAs.  Translating application data from one storage class to another may require partial redesign, since compensation will be needed for the weakening or disappearing properties of the SLA.  Alterations are also likely, if it is necessary to allocate a separate group of data within an application for placement in another data class or storage medium followed by integration of this data with other groups. <br><br><h4>  Data group </h4><br>  Data within a specific application, according to the logic of this application, belong to the same data class and require one SLA;  for example, in an application, the ‚ÄúX reference books‚Äù data group belonging to the key-value class and requiring quick reading by key can be highlighted. <br><br><h4>  Data container </h4><br>  The identifiable amount of data stored by some storage medium and corresponding to one data group of the same application.  In response to a data storage request for the application, one or more data containers are allocated. <br><br><h2>  Data Access Layer Structure </h2><br>  <i>This section describes the principal design of the DAL software that implements the concept of unified data access.</i>  <i>In the description of the structure of DAL are considered including the issues of selection and application of specific technologies and software products.</i> <br><br><h3>  DAL functions and boundaries in the enterprise IT landscape </h3><br>  The DAL structure is a set of software tools from which a unified data access layer can be built within an enterprise IT architecture that implements the principle of ‚Äúmanaged specialized data storage‚Äù and fixes it in a rigid form of software architecture.  DAL forms a controlled "layer" between business applications and storage facilities (databases) (Fig. 5). <br><br><img src="https://habrastorage.org/files/65b/987/f65/65b987f654694037968ee17282b4a6c7.png"><br>  <i>Fig.</i>  <i>5. DAL structure in enterprise architecture</i> <br><br>  The DAL structure is a collection of loosely coupled software modules for accessing data from different applications.  The weak connectivity of the modules allows you to avoid problems in synchronizing the development processes and updating various applications and DAL software.  The access modules themselves can have specific implementations for various underlying technologies on which business applications are developed. <br><br><h3>  Principles applied in DAL design </h3><br><ol><li>  The task is not automatic, non-stop, cost-effective or instantaneous switching of a working speaker from one storage medium to another.  Design solutions should not completely exclude (which is long and difficult), but significantly reduce the dependence of the application logic on the storage medium in such a way as to greatly facilitate a possible transition.  It is necessary to rely on a reasonable approach of NP designers and their understanding of architectural principles and goals, and therefore not try to build a super-secure technical system. </li><li>  In designing, ready-made, existing and standardized tools and components should be used to the maximum.  If an enterprise wants to ensure maximum independence from vendors, then it is preferable to use Open Source products and technologies, but only sufficiently mature, with the appropriate size of the community and examples of implementations in responsible enterprises. </li><li>  You should strive for simplicity of transferring existing speakers to DAL. </li><li>  It is better to increase the capabilities of the implemented DAL gradually, iteratively.  The first step should be simple, cheap and fast, aimed at solving the most urgent problems (in particular, the portability of relational DBMS). </li><li>  A new approach to storage management may not be limited to technical means, but include, for example, changes in the organizational mechanisms of the enterprise in terms of infrastructure management, as well as in the design and technical audit processes of the plant. </li></ol><br><h3>  Layout options for DAL structure components </h3><br><img src="https://habrastorage.org/files/5dd/ab1/122/5ddab1122f6247f3a3ee96b6bea9322a.png"><br>  <i>Fig.</i>  <i>6. Layout options for DAL structure components</i> <br><br>  The DAL structure involves two options for the placement of data access modules (Fig. 6). <br><ol><li>  In the form of a library included in the application.  In this embodiment, it is necessary to develop different types of access modules for different speaker design technologies. </li><li>  In the form of a network service.  This option is intended for those cases when for some reason the data access service in the form of a library is impossible or undesirable (for example, the IC is developed on a platform that does not have a library for working with DAL).  In this embodiment, DAL is available for any application that can work with network services via HTTP.  For this placement method, the set of data access interfaces provided may be limited. </li></ol><br><h3>  Data Access Software Interfaces </h3><br>  To implement access of business applications to the data of each class, one should give preference to industry standards and de facto standards for programmatic access interfaces (APIs).  This will ensure not only the simplest adaptation of existing speakers to work with DAL, but also the long-term sustainability of the data access layer to subsequent technological changes. <br><br>  Software data access interfaces (APIs) that business applications use, may vary for different underlying application technologies.  This optimizes development and conforms to de facto standards for this underlying technology.  It is important to note that this separation does not violate the general principles of the concept of unified data access, since - and this is important - the application remains independent of the specific database technology used.  For example, for applications developed in Java, the standard JDBC interface in the Java world can be the standard interface for accessing relational data, while the ODBC interface is provided for C / C ++ applications. <br><br><h3>  SQL dialect constraint when working through ODBC / JDBC interfaces </h3><br><img src="https://habrastorage.org/files/c36/db2/960/c36db29604e4496caab356bdb7ca4f75.png"><br>  <i>Fig.</i>  <i>7. SQL unification and translation</i> <br><br>  For relational data, modern DBMSs provide a large number of specific features and dialects of the SQL language.  The active use of various tools in applications leads to a deterioration of their portability.  Therefore, as part of the implementation of DAL, the SQL-based access to the relational data must specifically restrict the SQL dialect used in such a way that the application in principle does not have the ability to be tied to the features of a particular DBMS (Fig. 7). <br><br>  In addition to the task of restricting the dialect used, there also arises the task of translating individual syntax elements of SQL into a dialect of a specific DBMS.  This need arises from the fact that some common RDBMS capabilities widely used in applications, although present in the vast majority of them, are not included in the SQL standard. <br><br><h2>  RDBMS Access Module for Java Applications </h2><br>  Based on the design principles outlined above, the first and most relevant module for implementing DAL is the access module to relational data.  Despite the fact that, as described in the problematic, corporate business applications are increasingly taking advantage of the potential advantages of using NoSQL-DB, relational databases remain the most widely used and popular types of storage tools (often simply because a large number of application software is already developed based on RDBMS). <br><br>  We also recall that for applications implemented on different basic technologies, it is highly likely that the development of different access modules will be necessary.  This section describes the DAL module device for Java applications.  This technology is widespread in large corporations and banks and is characterized by a large number of sustainable and supported industry standards that can be taken as the basis for developing a unified data access interface. <br><br><h3>  Interfaces to access relational data </h3><br>  For Java applications, two standard access interfaces to RDBMS are widely distributed: <br><ul><li>  access directly to relational data through the JDBC interface and the SQL language; </li><li>  access via the object model through the JPA (Java Persistence API) object-relational adapter. </li></ul><br>  In practice, applications use a combination of these two access methods.  JPA is often used to modify data and read single objects, and for complex reports and samples, SQL queries are executed directly through a JDBC connection or through special inputs to JPA (so-called native queries). <br><br>  It seems expedient to fix these two methods together as a unified access interface.  It is necessary, as mentioned above, to explicitly restrict the SQL dialect used in direct queries to some ‚Äúunified‚Äù variant, since JDBC and JPA native queries allow you to execute arbitrary queries in the syntax of an arbitrary DBMS. <br><br><h3>  Constructive implementation of the DAL module for Java </h3><br>  So, the DAL module for accessing Java applications to RDBMS should provide the JPA and JDBC interfaces, but at the same time limit the use of SQL to its ‚Äúunified‚Äù version, in order to ensure the most rapid transfer to another RDBMS, if necessary. <br><br>  A module with such requirements could be developed independently, but the best option is to use ready-made software components with similar functionality for this.  In our company, when implementing DAL, the <a href="http://teiid.jboss.org/">JBoss Teiid</a> product, originally intended for federation (virtualization) of data access <a href="http://teiid.jboss.org/">across the enterprise</a> , was selected as such a component after analyzing a number of existing finished products (Fig. 8). <br><br><img src="https://habrastorage.org/files/f48/678/599/f486785999b149b4b3eec5d6b086021d.png"><br>  <i>Fig.</i>  <i>8. Constructive implementation of the DAL module for Java</i> <br><br>  The following functions and properties of JBoss Teiid correspond to the DAL requirements described above: <br><ul><li>  providing a JPA interface for Java applications; </li><li>  Providing a JDBC interface for Java applications </li><li>  Using your own unified SQL dialect (based on the SQL-99 standard); </li><li>  translating your own SQL dialect into specific dialects of supported databases; </li><li>  availability of connectors for most used RDBMS and simple extensibility; </li><li>  the ability to work as a built-in module, and in network service mode; </li><li>  open source (open source), the possibility of free use for commercial purposes, a developed community and examples of implementation in large enterprises. </li></ul><br>  In addition, the use of Teiid offers the following additional features: <br><ul><li>  database consolidation by creating a so-called ‚Äúvirtual DB‚Äù (virtual DB, VDB) in the settings using the visual designer.  Such a ‚Äúvirtual database‚Äù is associated with real means of storage (not only relational); </li><li>  efficient execution of ‚Äúcross-queries‚Äù - SQL queries to the ‚Äúvirtual database‚Äù, which are automatically translated into SQL queries to the real database; </li><li>  caching the results of queries to the "virtual database". </li></ul><br><h2>  DAL Usage Examples </h2><br>  As part of the study of the migration possibilities for PostgreSQL, our company conducted a pilot project to transfer one of the IT systems from Oracle to this DBMS.  The object was a calculated back-office system built on the principle of a three-tier architecture.  Most of the business logic (basic calculations) of the IT system was at the application server level, and part of the logic (accounting) was in Oracle stored procedures.  When designing this IT system, the principle of data access via the Data Access Layer was originally incorporated into the architecture.  This layer was built on JPA technology with the implementation of Hibernate. <br><br>  Since the migration needed to be carried out in a short time and the transfer of the accounting component logic to PostgreSQL would take considerable time, we decided to first implement an intermediate option - hybrid data storage at the same time in Oracle and PostgreSQL.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The accounting logic and the tables necessary for it remained in Oracle, and the rest of the application data was migrated to PostgreSQL. The transfer of the account part to PostgreSQL was planned for the second stage of the migration.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the organization of hybrid access, a solution based on JBoss Teiid was prepared: a ‚Äúvirtual database‚Äù was created, combining access to PostgreSQL tables and stored procedures and accounting part tables in Oracle. This allowed the system to access two DBMS as a single database. Since the application worked through DAL, all these subtleties were screened for it. Also, at the DAL level, improvements were made to convert Oracle-specific SQL constructs into expressions supported by Teiid. These improvements concerned only work with data and did not affect the business functionality of the system. After completing the modifications, the system successfully passed modular and functional testing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font><a href="http://habrahabr.ru/company/custis/blog/262605/"><font style="vertical-align: inherit;">recent post</font></a><font style="vertical-align: inherit;"> was devoted to the technical details of the database migration from Oracle to PostgreSQL.</font></font><a href="http://habrahabr.ru/company/custis/blog/262605/"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my colleague Maxim Tregubov. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, the approach of organizing access to data through DAL played a positive role in the modernization of a number of applications of our company. During the upgrade, various application logs (audit logs, interactions with external systems, etc.) were transferred to Hadoop-based archive storage. The remaining application data remained in the operational relational DBMS. Since access to these logs was carried out through a separate component with its own API, the replacement of the storage medium did not affect the rest of the application's functionality and did not require significant improvements.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If an enterprise wants to preserve independence from suppliers of specific solutions for IT infrastructure, then developers of enterprise IT systems should abstract themselves as far as possible from the specifics of these solutions. </font><font style="vertical-align: inherit;">Following the architectural principles of the Data Access Layer will allow the enterprise not to be held hostage by proprietary DBMS and choose the most suitable solution for data storage in terms of its capabilities and cost. </font><font style="vertical-align: inherit;">In addition, the company will be able to use new technologies for working with data without significant modifications to the AU.</font></font></div><p>Source: <a href="https://habr.com/ru/post/265785/">https://habr.com/ru/post/265785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265775/index.html">We write the real noise of Perlin</a></li>
<li><a href="../265777/index.html">Windows 10 through 10. Issue # 2. Interaction with users through live tiles and notifications</a></li>
<li><a href="../265779/index.html">‚ÄúThank you for using our products and services.‚Äù What we allow services</a></li>
<li><a href="../265781/index.html">Fourier processing of digital images</a></li>
<li><a href="../265783/index.html">Housing cost as a function of coordinates</a></li>
<li><a href="../265787/index.html">Books according to which we taught programming in childhood and we will teach children</a></li>
<li><a href="../265791/index.html">Using Intel HAXM when developing applications for Android Wear and TV</a></li>
<li><a href="../265793/index.html">Experience developing games for Android. From idea to implementation</a></li>
<li><a href="../265795/index.html">Encodings and web pages</a></li>
<li><a href="../265797/index.html">Creating domain zones in AzureDns [cheat sheet]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>