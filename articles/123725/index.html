<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>KLEE virtual machine for symbolic code execution</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post we will try to apply the symbolic execution technique using the example of the symbolic VM KLEE to solve a simple ASCII maze. How much do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>KLEE virtual machine for symbolic code execution</h1><div class="post__text post__text-html js-mediator-article">  In this post we will try to apply the symbolic execution technique using the example of the symbolic VM KLEE to solve a simple ASCII maze.  How much do you think we can find the right solutions? <br><img src="https://habrastorage.org/storage1/b6b59d8c/e859b5c3/fffa32b6/771d5fde.png"><br><a name="habracut"></a><br><h4>  Labyrinth </h4><br>  The labyrinth itself is a C program, the code for which you can take <a href="http://pastebin.com/6wG5stht">here</a> .  After launch, the game waits for a sequence of steps to be entered (a - step left, d - right, w - up and s - down).  It looks like this: <br><br><pre>  Player pos: 1x4
 Iteration no.  2. Action: s.
 + - + --- + --- +
 | X |  | # |
 | X |  - + |  |
 | X |  |  |  |
 | X + - |  |  |
 |  |  |
 + ----- + --- + </pre><br>  Despite the seeming simplicity, the maze hides within itself one secret and therefore has more than one solution. <br><br><h4>  KLEE </h4><br>  KLEE is a symbolic interpreter of the LLVM bitcode, i.e.  he can execute code generated by any front end.  The essence of symbolic execution is that all input values ‚Äã‚Äãof the program being started contain not specific values, but symbolic restrictions on possible values.  During execution, new character variables can be created (for example, when their values ‚Äã‚Äãdepend on the result of an operation with a character operand), as well as existing ones change (when branching in the program execution path).  In the second case, KLEE uses the SMT solver to determine if it is possible in principle to execute a program along a given path. <br>  If you are interested in this topic, you can look <a href="http://klee.llvm.org/">here</a> and read <a href="http://llvm.org/pubs/2008-12-OSDI-KLEE.pdf">it</a> or even <a href="http://www.ece.cmu.edu/~ejschwar/papers/oakland10.pdf">this</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The idea of ‚Äã‚Äãthe post is simple - to feed the maze program a character string and see how KLEE will find solutions. <br><br><h4>  Parse the code </h4><br>  The labyrinth is defined as a two-dimensional array of characters. <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> H 7 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> W 11 char maze[H][W] = { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"+-+---+---+"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"| | |#|"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"| | --+ | |"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"| | | | |"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"| +-- | | |"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"| | |"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"+-----+---+"</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br>  The draw () task is to draw our array on the screen. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; H; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; W; j++) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"%c"</span></span>, maze[i][j]); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); }</code> </pre><br>  The main () function starts with declaring variables that hold the position of the player, an iterator, and a 28-byte array that stores actions.  Then, the initial position of the player is set equal to (1.1) and a cross is drawn on this spot. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-comment"><span class="hljs-comment">//Player position int ox, oy; //Old player position int i = 0; //Iteration number #define ITERS 28 char program[ITERS]; x = 1; y = 1; maze[y][x]='X';</span></span></code> </pre><br>  We read from stdin what the player entered there. <br><pre> <code class="cpp hljs"> read(<span class="hljs-number"><span class="hljs-number">0</span></span>,program,ITERS);</code> </pre><br>  Further, at each iteration of the cycle, we save the old coordinates of the user and move it to a new location. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i &lt; ITERS) { ox = x; <span class="hljs-comment"><span class="hljs-comment">//Save old player position oy = y; switch (program[i]) { case 'w': y--; break; case 's': y++; break; case 'a': x--; break; case 'd': x++; break; default: printf("Wrong command!(only w,s,a,d accepted!)\n"); printf("You loose!\n"); exit(-1); }</span></span></code> </pre><br>  If the player has reached the end - we congratulate him. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maze[y][x] == <span class="hljs-string"><span class="hljs-string">'#'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"You win!\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"Your solution \n"</span></span>,program); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  If something is wrong - we return to the place where we stood. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maze[y][x] != <span class="hljs-string"><span class="hljs-string">' '</span></span> &amp;&amp; !((y == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; maze[y][x] == <span class="hljs-string"><span class="hljs-string">'|'</span></span> &amp;&amp; x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; W))) { x = ox; y = oy; }</code> </pre><br>  If you hit the wall - the player lost. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ox==x &amp;&amp; oy==y){ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"You loose\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>); }</code> </pre><br>  Well, if nothing happened - then we just stepped.  Move the player, draw the picture, increase the iterator and go back to the beginning. <br><pre> <code class="cpp hljs"> maze[y][x]=<span class="hljs-string"><span class="hljs-string">'X'</span></span>; draw (); <span class="hljs-comment"><span class="hljs-comment">//draw it i++; sleep(1); //me wait to human }</span></span></code> </pre><br><br><h4>  Let's go through the maze manually </h4><br>  If you suddenly want to go through the game yourself, then most likely you will receive the following solution: ssssddddwwaawwddddssssssddwwww <br><img src="http://feliam.files.wordpress.com/2010/10/maze3.gif?w=315&amp;h=195" alt="image"><br><br><h4>  And now with KLEE </h4><br>  First of all, we need LLVM, the translator C -&gt; LLVM IR (llvm-gcc or clang) and, in fact, KLEE.  In most Linux distributions, these packages are already in the repositories. <br>  To translate mace.c in the LLVM bitcode, run the command <br><pre>  $ llvm-gcc -c ‚Äìemit-llvm maze.c -o maze.bc </pre><br>  As mentioned earlier, instead of llvm-gcc, you can use clang. <br><br>  As a result of executing this command, we received the file maze.bc, which is a bitcode of the labyrinth program.  It can even be run on the LLVM interpreter: <br><pre>  $ lli maze.bc </pre><br><br>  To test the code with KLEE, we need to mark some variables with symbolic ones.  In this case, it will be an array of actions declared at the beginning of main ().  So, replace the string <br><pre> <code class="cpp hljs"> read(<span class="hljs-number"><span class="hljs-number">0</span></span>,program,ITERS);</code> </pre><br>  on <br><pre> <code class="cpp hljs"> klee_make_symbolic(program,ITERS,<span class="hljs-string"><span class="hljs-string">"program"</span></span>);</code> </pre><br>  And do not forget to add the header file KLEE <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;klee/klee.h&gt;</span></span></span></span></code> </pre><br>  Now KLEE will be able to go through any possible path of execution (and the labyrinth corridor).  Moreover, if these paths can lead to any error (for example, a buffer overflow), KLEE signals this to us.  We carry out <br><pre>  $ klee maze.bc </pre><br>  and observe the following picture: <br><img src="http://feliam.files.wordpress.com/2010/10/maze_klee.gif?w=315&amp;h=195" alt="image"><br>  As can be seen from the last 3 messages, KLEE found 321 different paths.  True, this is not the 321 right decision. <br><pre>  KLEE: done: total instructions = 112773
 KLEE: done: completed paths = 321
 KLEE: done: generated tests = 318 </pre><br><br>  A detailed report is saved to the klee-last directory. <br><pre>  $ ls klee-last /
 assembly.ll test000078.ktest test000158.ktest
 info test000079.ktest test000159.ktest
 messages.txt test000080.ktest test000160.ktest
 run.istats test000081.ktest test000161.ktest
 run.stats test000082.ktest test000162.ktest
 test000001.ktest test000083.ktest test000163.ktest
 test000075.ktest test000155.ktest warnings.txt </pre><br><br>  Each test can be viewed using the ktest-tool utility. <br><pre>  $ ktest-tool klee-last / test000222.ktest
 ktest file: 'klee-last / test000222.ktest'
 args: ['maze_klee.o']
 num objects: 1
 object 0: name: 'program'
 object 0: size: 29
 object 0: data: 'ssssddddwwaawwddddssssddwwwd \ x00 ‚Ä≤ </pre><br>  In this case, you can simply take the value of the program variable from here and play the test, passing this value to the maze program. <br><br>  So, we have found all possible routes in the program.  But do not look through every test to find all the right solutions!  We need to force KLEE to highlight tests that really go to ‚ÄúYou win!‚Äù. <br>  In the KLEE interface, there is a function klee_assert (), which does the same thing as its similar assert () in C - calculates the value of a boolean expression and, if it is false, interrupts program execution.  For our case, this is what the doctor ordered. <br>  Add after line <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"You win!\n"</span></span>);</code> </pre><br>  unconditional call klee_assert () <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"You win!\n"</span></span>); klee_assert(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//Signal The solution!!</span></span></code> </pre><br>  Now KLEE will not stop generating tests for all possible execution paths, however the tests leading to the call to klee_assert () will have .err in their name: <br><pre>  $ ls -1 klee-last / | grep -A2 -B2 err
 test000096.ktest
 test000097.ktest
 test000098.assert.err
 test000098.ktest
 test000098.pc </pre><br>  Let's look at one of them. <br><pre>  $ ktest-tool klee-last / test000098.ktest
 ktest file: 'klee-last / test000098.ktest'
 args: ['maze_klee.o']
 num objects: 1
 object 0: name: 'program'
 object 0: size: 29
 object 0: data: 'sddwddddssssddwwww \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 ‚Ä≤ </pre><br>  So, the proposed KLEE solution is <b>sddwddddssssddwwww</b> <br>  Hey, let me!  It looks short!  Let's try it on a real maze: <br><img src="http://feliam.files.wordpress.com/2010/10/maze_klee_fakewall.gif?w=315&amp;h=195" alt="image"><br>  I knew it!!!  There are fake walls in the maze!  And KLEE safely passed through them!  But wait, if KLEE had to find all the solutions, then where is our first?  Why didn't KLEE find it? <br>  Well, usually we only need one way to the error, if we are looking for the error itself, and we do not need alternative ways to it.  Therefore, in this case we will use one of 10,000 command line options. <br><pre>  $ klee ‚Äìemit-all-errors maze_klee.o </pre><br>  We look at the result: <br><img src="http://feliam.files.wordpress.com/2010/10/maze_klee_allerrors.gif?w=315&amp;h=195" alt="image"><br>  Now we got 4 tests, which are 4 possible solutions of our labyrinth: <br><br><pre>  $ ktest-tool klee-last / test000097.ktest
 ktest file: 'klee-last / test000097.ktest'
 args: ['maze_klee.o']
 num objects: 1
 object 0: name: 'program'
 object 0: size: 29
 object 0: data: 'sddwddddsddw \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 ‚Ä≤
 $ ktest-tool klee-last / test000136.ktest
 ktest file: 'klee-last / test000136.ktest'
 args: ['maze_klee.o']
 num objects: 1
 object 0: name: 'program'
 object 0: size: 29
 object 0: data: 'sddwddddssssddwwww \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 ‚Ä≤
 $ ktest-tool klee-last / test000239.ktest
 ktest file: 'klee-last / test000239.ktest'
 args: ['maze_klee.o']
 num objects: 1
 object 0: name: 'program'
 object 0: size: 29
 object 0: data: 'ssssddddwwaawwddddsddw \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 \ x00 ‚Ä≤
 $ ktest-tool klee-last / test000268.ktest
 ktest file: 'klee-last / test000268.ktest'
 args: ['maze_klee.o']
 num objects: 1
 object 0: name: 'program'
 object 0: size: 29
 object 0: data: 'ssssddddwwaawwddddssssddwwww \ x00 ‚Ä≤ </pre><br>  So, the solutions of this labyrinth: <br>  1. <b>ssssddddwwaawwddddssssddwwww</b> <br>  2. <b>ssssddddwwaawwddddsddw</b> <br>  3. <b>sddwddddssssddwwww</b> <br>  4. <b>sddwddddsddw</b> </div><p>Source: <a href="https://habr.com/ru/post/123725/">https://habr.com/ru/post/123725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123715/index.html">useful utility vmware boomerang</a></li>
<li><a href="../123717/index.html">Common words about a web search device</a></li>
<li><a href="../123718/index.html">Flags of 254 countries by one sprite</a></li>
<li><a href="../123721/index.html">Continuing the war between customs and Russian Post</a></li>
<li><a href="../123723/index.html">Sony Ericsson Xperia Neo video review</a></li>
<li><a href="../123727/index.html">The second competition is CUBRID. Search for a solution</a></li>
<li><a href="../123728/index.html">F ** k GTD! (post good :)</a></li>
<li><a href="../123729/index.html">Every bugtracker project</a></li>
<li><a href="../123730/index.html">The latest mission of the shuttle - look online</a></li>
<li><a href="../123734/index.html">I just came to say hello!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>