<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Such different asynchrony</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Dmitry Karlovsky and I ... a multi-tasking person. I mean, I have a lot of tasks and not enough time to finish them all. In part, th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Such different asynchrony</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello, my name is Dmitry Karlovsky and I ... a multi-tasking person.  I mean, I have a lot of tasks and not enough time to finish them all.  In part, this is for the better - there is always something to do.  On the other hand, while you are torn between projects, the world is heading somewhere not there and there is no one to climb on the armored car and urge the crowd to stop and think a little.  And the question is serious - for a long time the world of JS was immersed in the <em>hell of callbacks</em> and not only did not fight with them - they were idolized.  Then he is a little less than completely mired in promises.  Now, props of varying degrees of curvature are being strenuously inserted from different sides.  A light at the end of the tunnel can not see everything.  But first things first... </p><br><h1 id="teoriya-mnogozadachnosti">  Multitasking theory </h1><br><p>  First, we define the terms.  In the process of work, the application performs various tasks.  For example, "download file from remote server" or "process user request". </p><br><p>  It is not uncommon for one task to perform additional tasks - "subtasks".  For example, to process a user request, you need to download a file from a remote server. </p><br><p>  We can launch a subtask synchronously, and then the current task will be blocked waiting for the subtask to complete.  And we can run asynchronously, and then the current task will continue its execution without waiting for the completion of the subtask. </p><br><p>  However, it is usually to complete the task, though not immediately, but it also requires completion of the subtask and subsequent processing of its results.  The blocking of one task while waiting for signals from another will be called ‚Äúsynchronization‚Äù.  In general, the synchronization of the same tasks can occur many times, according to the most diverse logic, but in the future we will consider only the simplest and most common option - synchronization upon completion of the subtask. </p><a name="habracut"></a><br><p>  In languages ‚Äã‚Äãthat support multithreading, usually each task runs in a separate "system thread" or (more correctly) "thread".  Each thread can run on a separate processor core, in parallel with other threads.  Since there may be a lot of threads, and the number of cores is very limited, the operating system implements a "preemptive multithreading" mechanism, when any thread, if it is long running, can be forcibly suspended to allow other threads to work. </p><br><p>  Parallel work of tasks leads to various problems when working with shared memory, for solving which it is necessary to use non-trivial synchronization mechanisms.  In order to simplify the work of a programmer and increase the reliability of the software produced by him, some languages ‚Äã‚Äãcompletely abandon multithreading and run all tasks in a single thread.  In this case, multitasking is implemented in one of the following ways: </p><br><p>  <strong>The</strong> fibers, also known as coroutines.  In fact, these are the same threads, but implementing ‚Äúcooperative multitasking‚Äù.  All fibers have their stacks, but are executed within the framework of one thread, and therefore cannot be executed in parallel.  The decision about when to switch the thread to another fiber, takes the fiber itself. </p><br><p>  <strong>Chains of tasks</strong> .  The essence of the approach is that instead of suspending the current task for the duration of the subtask, we divide the task into many small subtasks and tell each one what task to perform at the end of this task. </p><br><p>  State machines, also known as "generators", "asynchronous functions" (async functions) and "half-programs" (semicoroutines) and "coroutines without stack" (stackless coroutines).  In fact, these are objects that store the local state of a single method, at the beginning of which there is a branch with a transition to the code of one of the steps of the original task.  When the step is completed, control is returned to the calling function.  Recalling the asynchronous function already leads to a transition to another step. </p><br><h1 id="realizacii-na-nodejs">  Implementations on NodeJS </h1><br><p>  In the <a href="https://github.com/nin-jin/async-js">nin-jin / async-js</a> repository, separate implementations of a simple application on different multitasking models are collected in separate branches.  The essence of the application is simple and consists of 3 parts: </p><br><ol><li>  <strong>Model</strong> (user.js).  It loads the config from disk and provides a method for getting the username from this config. </li><li>  <strong>Display</strong> (greeter.js).  Accepts a user model and prints, accessing it in the console. </li><li>  <strong>Controller</strong> (index.js).  Prints the user a greeting and then a farewell.  Along the way, it displays the time of its work and logs an error if an exception occurs, preventing the process from falling. </li></ol><br><p>  The config is simple: </p><br><pre><code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"Anonymous"</span></span> }</code> </pre> <br><h2 id="sinhronnyy-kodhttpsgithubcomnin-jinasync-jscomparesyncdiffunifiednamesync">  <a href="https://github.com/nin-jin/async-js/compare/sync%3Fdiff%3Dunified%26name%3Dsync">Synchronous code</a> </h2><br><p>  <strong>user.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'fs'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getConfig = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( config ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configText = fs.readFileSync( <span class="hljs-string"><span class="hljs-string">'config.json'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse( configText ) } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.getName = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getConfig().name }</code> </pre> <br><p>  <strong>greeter.js</strong> </p><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.say = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( greeting , user )</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( greeting + <span class="hljs-string"><span class="hljs-string">', '</span></span> + user.getName() + <span class="hljs-string"><span class="hljs-string">'!'</span></span> ) }</code> </pre> <br><p>  <strong>index.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./user'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greeter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./greeter'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time( <span class="hljs-string"><span class="hljs-string">'time'</span></span> ) greeter.say( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> , user ) greeter.say( <span class="hljs-string"><span class="hljs-string">'Bye'</span></span> , user ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd( <span class="hljs-string"><span class="hljs-string">'time'</span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error( error ) }</code> </pre> <br><p>  Extremely simple and straightforward.  It is easy to understand and just as easy to make changes.  But it has one major drawback - while this task is being performed no other task can be completed, even if we are waiting for the file to be downloaded from the network drive and are not doing anything useful.  If this is a script of one task, as in the example above, then that's okay, but if we need a web server that needs to process multiple requests at the same time, then a single-task solution does not suit us. </p><br><h2 id="predopredelyonnye-cepochkihttpsgithubcomnin-jinasync-jscomparesyncasync-nodejs">  <a href="https://github.com/nin-jin/async-js/compare/sync...async-nodejs">Predefined chains</a> </h2><br><p>  Many synchronous methods in the <a href="https://nodejs.org/en/docs/">NodeJS API</a> have their asynchronous counterparts, where the last argument is the "continuation", that is, the function that should be called after the end of the asynchronous task. </p><br><p>  <strong>user.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'fs'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getConfig = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( config ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setImmediate( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done( <span class="hljs-literal"><span class="hljs-literal">null</span></span> , config ) }) fs.readFile( <span class="hljs-string"><span class="hljs-string">'config.json'</span></span> , ( error , configText ) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done( error ) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { config = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse( configText ) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done( error ) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done( <span class="hljs-literal"><span class="hljs-literal">null</span></span> , config ) }) } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.getName = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> { getConfig( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> error , config </span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done( error ) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = config.name } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done( error ) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done( <span class="hljs-literal"><span class="hljs-literal">null</span></span> , name ) } ) }</code> </pre> <br><p>  <strong>greeter.js</strong> </p><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.say = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( greeting , user , done )</span></span></span><span class="hljs-function"> =&gt;</span></span> { user.getName( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( error , name )</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done( error ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( greeting + <span class="hljs-string"><span class="hljs-string">', '</span></span> + name + <span class="hljs-string"><span class="hljs-string">'!'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done() }) }</code> </pre> <br><p>  <strong>index.js</strong> </p><br><pre> <code class="hljs lua">var user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./user'</span></span> ) var greeter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./greeter'</span></span> ) var script = done =&gt; { console.<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>( <span class="hljs-string"><span class="hljs-string">'time'</span></span> ) greeter.say( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> , user , <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) greeter.say( <span class="hljs-string"><span class="hljs-string">'Bye'</span></span> , user , <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> done( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) console.timeEnd( <span class="hljs-string"><span class="hljs-string">'time'</span></span> ) done() } ) } ) } script( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !<span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) } )</code> </pre> <br><p>  As you can see, the code is much more complicated.  We had to rewrite all (even synchronous) functions in a chained style.  At the same time, proper error handling is a special pain: if you forget to handle an error somewhere, the application may or may not fall, or may fall, but not immediately, but a little later, away from the place of the error.  And if it does not fall by some miracle, then the error will not be pledged in any way.  Writing code in this style requires a programmer to be sensitive and attentive, so most modules in NPM are charged guns that can give you an unforgettable clock at any time in a debugger company. </p><br><h2 id="postopredlyaemye-cepochkihttpsgithubcomnin-jinasync-jscomparesyncasync-promises">  <a href="https://github.com/nin-jin/async-js/compare/sync...async-promises">Postvalue chains</a> </h2><br><p>  Implemented through promises, they take on the bulk of the work of throwing up errors.  The only thing that needs to be remembered is that there should be an error handler at the end of the chain, otherwise the application may terminate by completing the task without saying anything. </p><br><p>  <strong>user.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'fs'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getConfig = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> resolve , reject </span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( config ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolve( config ) fs.readFile( <span class="hljs-string"><span class="hljs-string">'config.json'</span></span> , ( error , configText ) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reject( error ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolve( config = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse( configText ) ) } ) } ) } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.getName = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getConfig().then( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">config</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config.name } ) }</code> </pre> <br><p>  <strong>greeter.js</strong> </p><br><pre> <code class="hljs pgsql">module.exports.say = ( greeting , <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> ) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.getName().<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-type"><span class="hljs-type">name</span></span> =&gt; { console.log( greeting + <span class="hljs-string"><span class="hljs-string">', '</span></span> + <span class="hljs-type"><span class="hljs-type">name</span></span> + <span class="hljs-string"><span class="hljs-string">'!'</span></span> ) } ) }</code> </pre> <br><p>  <strong>index.js</strong> </p><br><pre> <code class="hljs coffeescript">var user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./user'</span></span> ) var greeter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./greeter'</span></span> ) Promise.resolve() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time( <span class="hljs-string"><span class="hljs-string">'time'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> greeter.say( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> , user ) } ) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> greeter.say( <span class="hljs-string"><span class="hljs-string">'Bye'</span></span> , user ) } ) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd( <span class="hljs-string"><span class="hljs-string">'time'</span></span> ) } ) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error( error ) } )</code> </pre> <br><p>  Compared to the predefined chains, the code turned out to be simpler, but it is still broken down into many small functions.  The advantage of this approach is that it will work equally well in any environment.  Even where there are no promises initially - they are easy to add with a complicated library. </p><br><p>  In general, both types of chains lead to a large amount of visual noise and complicate the writing of nonlinear algorithms using cycles, conditional branchings, local variables, and so on. </p><br><h2 id="generatoryhttpsgithubcomnin-jinasync-jscomparesyncasync-generators-co">  <a href="https://github.com/nin-jin/async-js/compare/sync...async-generators-co">Generators</a> </h2><br><p>  Some JS engines support generators that are fairly elegantly integrated with promises, which makes it possible to implement ‚Äúsuspendable functions‚Äù (awaitable). </p><br><p>  <strong>user.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'fs'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> co = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'co'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getConfig = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( config ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> resolve , reject </span></span></span><span class="hljs-function">) =&gt;</span></span> { fs.readFile( <span class="hljs-string"><span class="hljs-string">'config.json'</span></span> , ( error , configText ) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reject( error ) resolve( <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse( configText ) ) } ) } ) } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.getName = co.wrap( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getConfig() ).name } )</code> </pre> <br><p>  <strong>greeter.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> co = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'co'</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.say = co.wrap( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> greeting , user </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( greeting + <span class="hljs-string"><span class="hljs-string">', '</span></span> + ( <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> user.getName() ) + <span class="hljs-string"><span class="hljs-string">'!'</span></span> ) } )</code> </pre> <br><p>  <strong>index.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> co = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'co'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./user'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greeter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./greeter'</span></span> ) co( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time( <span class="hljs-string"><span class="hljs-string">'time'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> greeter.say( <span class="hljs-string"><span class="hljs-string">'Hello'</span></span> , user ) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> greeter.say( <span class="hljs-string"><span class="hljs-string">'Bye'</span></span> , user ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd( <span class="hljs-string"><span class="hljs-string">'time'</span></span> ) } ).catch( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error( error ) } )</code> </pre> <br><p>  The code was almost as simple as synchronous, except that we had to turn all functions into generators and wrap them in a special wrapper that received a promise (yield) from the generator, subscribes to its rezolv, after which the generator continues to transmit he received values.  Thus, we can again use conditional branches, cycles, and other flow control idioms. </p><br><h2 id="asinhronnye-funkciihttpsgithubcomnin-jinasync-jscomparesyncasync-await-babel">  <a href="https://github.com/nin-jin/async-js/compare/sync...async-await-babel">Asynchronous functions</a> </h2><br><p>  In fact, this is nothing more than syntactic sugar for generators.  But this sugar is still in few places supported, so for the time being it is necessary to use babel to transform it into code on generators. </p><br><p>  <strong>user.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'fs'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getConfig = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( config ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> resolve , reject </span></span></span><span class="hljs-function">) =&gt;</span></span> { fs.readFile( <span class="hljs-string"><span class="hljs-string">'config.json'</span></span> , ( error , configText ) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reject( error ) resolve( <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse( configText ) ) } ) } ) } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.getName = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getConfig() ).name }</code> </pre> <br><p>  <strong>greeter.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.say = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ( greeting , user ) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( greeting + <span class="hljs-string"><span class="hljs-string">', '</span></span> + ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> user.getName() ) + <span class="hljs-string"><span class="hljs-string">'!'</span></span> ) }</code> </pre> <br><p>  <strong>index.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./user'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greeter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./greeter'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'time'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> greeter.say(<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>, user) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> greeter.say(<span class="hljs-string"><span class="hljs-string">'Bye'</span></span>, user) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'time'</span></span>) } app().catch( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error( error ) } )</code> </pre> <br><h3 id="voloknahttpsgithubcomnin-jinasync-jscomparesyncasync-fibers">  <a href="https://github.com/nin-jin/async-js/compare/sync...async-fibers">Fibers</a> </h3><br><p>  Simple native extension for NodeJS implements full-fledged fibers.  All you need is to run the task in the fiber and further, at any level of nesting of function calls, you can pause the fiber, transferring control to another.  In the example below, so-called "futures" (futures) are used, which allow you to synchronize one task with another at any time. </p><br><p>  <strong>user.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Future = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'fibers/future'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> FS = Future.wrap( <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'fs'</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getConfig = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( config ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configText = FS.readFileFuture( <span class="hljs-string"><span class="hljs-string">'config.json'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse( configText.wait() ) } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.getName = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getConfig().name }</code> </pre> <br><p>  <strong>greeter.js</strong> </p><br><p>  And it didn‚Äôt even need to be changed - it is still the same synchronous. </p><br><p>  <strong>index.js</strong> </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Future = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'fibers/future'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./user'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greeter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./greeter'</span></span> ) Future.task( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">'time'</span></span>) greeter.say(<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>, user) greeter.say(<span class="hljs-string"><span class="hljs-string">'Bye'</span></span>, user) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">'time'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error( error ) } } ).detach()</code> </pre> <br><p>  When using fibers, most of the code remains synchronous, but if necessary, wait, not all the thread is blocked, but only a single fiber.  The result is a parallel execution of synchronous fibers. </p><br><h1 id="proizvoditelnost">  Performance </h1><br><p>  Let's compare the execution time of the main task in each multitasking version on NodeJS v6.3.1: </p><br><ol><li>  Synchronous code: 4ms. </li><li>  Predefined chains: 6ms. </li><li>  Promises: 7ms. </li><li>  Generators: 7ms. </li><li>  Asynchronous functions turned into generators via Babel: 22ms. </li><li>  Fibers: 6ms. </li></ol><br><p>  Findings: </p><br><ol><li>  Synchronous code is much faster than asynchronous. </li><li>  Fibers practically do not give a penalty in terms of performance (only on launching and switching fibers). </li><li>  Promises and generators give a penalty to challenge each function.  In the example, we have few functions, so the drawdown is not large. </li><li>  Babel generates a very lousy code. </li></ol><br><h1 id="otladka">  Debugging </h1><br><p>  Let's see how our applications respond to an exceptional situation.  For example, in the config instead of an object we simply put <code>null</code> .  Loading and parsing the config will take place normally, but the <code>getName</code> method should fall with an error.  We have already taken care that the application does not fall, does not ignore the error, but logged the security in the console.  Here is what our implementations will derive: </p><br><h2 id="sinhronnyy-kod">  Synchronous code </h2><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>: Cannot read property <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> at <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.module.exports.getName (./user.js:<span class="hljs-number"><span class="hljs-number">13</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>) at <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.module.exports.say (./greeter.js:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">41</span></span>) at <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.&lt;anonymous&gt; (./index.js:<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span>) at Module._compile (<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.js:<span class="hljs-number"><span class="hljs-number">541</span></span>:<span class="hljs-number"><span class="hljs-number">32</span></span>) at <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.Module._extensions..js (<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.js:<span class="hljs-number"><span class="hljs-number">550</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) at Module.load (<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.js:<span class="hljs-number"><span class="hljs-number">456</span></span>:<span class="hljs-number"><span class="hljs-number">32</span></span>) at tryModuleLoad (<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.js:<span class="hljs-number"><span class="hljs-number">415</span></span>:<span class="hljs-number"><span class="hljs-number">12</span></span>) at <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>.Module._load (<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.js:<span class="hljs-number"><span class="hljs-number">407</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>) at <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>.Module.runMain (<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.js:<span class="hljs-number"><span class="hljs-number">575</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) at startup (node.js:<span class="hljs-number"><span class="hljs-number">160</span></span>:<span class="hljs-number"><span class="hljs-number">18</span></span>)</code> </pre> <br><p>  It seems that stektrays captured a fair share of NodeJS internals, but the main thing is that the sequence of calls that we are interested in is <code>index.js:7 -&gt; say@greeter.js:2 -&gt; getName@user.js:13</code> present, which means we can understand how the application has come to this error. </p><br><h2 id="predopredelyonnye-cepochki">  Predefined chains </h2><br><pre> <code class="hljs pgsql">TypeError: Cannot <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> property <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> at error (./<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.js:<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">30</span></span>) at fs.readFile.error (./<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.js:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span>) at FSReqWrap.readFileAfterClose [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> oncomplete] (fs.js:<span class="hljs-number"><span class="hljs-number">439</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  The structure starts from the arrival of a file upload event.  What happened before that we will not know. </p><br><h2 id="obeschaniya">  Promises </h2><br><pre> <code class="hljs pgsql">TypeError: Cannot <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> property <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> at getConfig.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>.config (./<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.js:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span>)</code> </pre> <br><p>  Maximum minimalistic stektrays. </p><br><h2 id="generatory">  Generators </h2><br><pre> <code class="hljs pgsql">TypeError: Cannot <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> property <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> at <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.&lt;anonymous&gt; (./<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.js:<span class="hljs-number"><span class="hljs-number">18</span></span>:<span class="hljs-number"><span class="hljs-number">33</span></span>) at next (native) at onFulfilled (./node_modules/co/<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js:<span class="hljs-number"><span class="hljs-number">65</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>)</code> </pre> <br><p>  Here the same promises are used with all the ensuing consequences. </p><br><h2 id="asinhronnye-funkcii">  Asynchronous functions </h2><br><pre> <code class="hljs pgsql">TypeError: Cannot <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> property <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> at <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.&lt;anonymous&gt; (<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.js:<span class="hljs-number"><span class="hljs-number">18</span></span>:<span class="hljs-number"><span class="hljs-number">12</span></span>) at undefined.next (native) at step (C:\proj\async-js\<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.js:<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">253</span></span>) at C:\proj\async-js\<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.js:<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">430</span></span></code> </pre> <br><p>  It would be strange to expect something else here. </p><br><h2 id="volokna">  Fibers </h2><br><pre> <code class="hljs delphi">TypeError: Cannot <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> null at <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.module.<span class="hljs-keyword"><span class="hljs-keyword">exports</span></span>.getName (./user.js:<span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>) at <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.module.<span class="hljs-keyword"><span class="hljs-keyword">exports</span></span>.say (./greeter.js:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">41</span></span>) at Future.task.error (./<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js:<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span>) at ./node_modules/fibers/future.js:<span class="hljs-number"><span class="hljs-number">467</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span></code> </pre> <br><p>  All that is needed and almost nothing extra. </p><br><p>  In the debugger, you will see the same picture: you can walk through the stack of synchronous and fiberized code, look at the values ‚Äã‚Äãof local variables, set breakpoints and walk along the steps of executing your application.  At the same time, code broken into chains of functions, flavored with promises or wrapped in generators is a real nightmare for a debugger.  And if you also used the crooked transpiler, then <a href="http://domfactov.com/vnuk-saddama-huseyna-mustafa-huseyn-samyiy-hrabryiy-malchik.html">Mustafa Hussein</a> himself would envy the developer‚Äôs courage to debug this code. </p><br><h1 id="chto-delat">  What to do? </h1><br><ol><li>  Do not chase fashion, but use solutions that allow you to write concise, fast, easy to debug code. </li><li>  Helping <em>people in sunglasses</em> look for a way to the light. </li><li>  Promote a comprehensive analysis of the issues, instead of pushing one-sided opinion. </li></ol><br><p>  Fibers, objectively, by the sum of qualities, are better than the other solutions presented here.  The only drawback is that this is by no means a standard and is not even planned for implementation in browsers.  But this is not so much a minus of fibers as a minus of a community that pushes promises, generators, asynchronous functions into standards, but completely ignores much simpler and more direct solutions. </p><br><h1 id="ssylki">  Links </h1><br><ol><li>  <a href="https://github.com/nin-jin/async-js">github: nin-jin / async-js</a> - sources of examples. </li><li>  <a href="https://en.wikipedia.org/wiki/Coroutine">wiki: coroutine</a> - compilation of coroutines as concepts. </li><li>  <a href="https://github.com/laverdet/node-fibers">npm: node-fibers</a> is a module that adds fibers to NodeJS. </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/307288/">https://habr.com/ru/post/307288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307272/index.html">EA Global 2016 Effective Altruism Conference - Live Broadcast</a></li>
<li><a href="../307278/index.html">Sending and receiving SMS using Laravel and Nexmo</a></li>
<li><a href="../307280/index.html">A bit about VPN: A brief overview of software implementations</a></li>
<li><a href="../307282/index.html">What to do with other people's debts?</a></li>
<li><a href="../307286/index.html">The digest of interesting materials for the mobile # 165 developer (from August 1-7)</a></li>
<li><a href="../307294/index.html">SQL and XPath vs RosRestra</a></li>
<li><a href="../307296/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ222 (August 1 - 7, 2016)</a></li>
<li><a href="../307298/index.html">Is Saas a service or license?</a></li>
<li><a href="../307300/index.html">Cambium cnPilot - inexpensive WiFi, which surprised us</a></li>
<li><a href="../307306/index.html">SObjectizer: from simple to complex. Part II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>