<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stack variables - fast and sometimes dead</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ programs use the so-called automatic storage for local and temporary variables. Usually, automatic memory is implemented on top of the program st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stack variables - fast and sometimes dead</h1><div class="post__text post__text-html js-mediator-article"><img align="right" alt="FAIL" src="https://habrastorage.org/storage1/23511255/47be4434/e52d276d/50b4bc20.png">  C ++ programs use the so-called automatic storage for local and temporary variables.  Usually, automatic memory is implemented on top of the program stack, so it is called stack memory.  Its big plus is the allocation and release of memory is extremely fast (usually one processor instruction).  Its big minus is a relatively small amount, an attempt to allocate memory in excess of this volume leads to the so-called stack overflow, and then the program crashes. <br><br>  This implies a restriction - you can not try to allocate too much memory on the stack.  Too much?  How much it?  The answer is not as obvious as you might think at first glance. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Too much - just more than what is available.  The statement is perfectly accurate, but not very useful. <br><br>  How much is available depends on various factors.  For example, on Windows, for the main thread of the program, the amount of stack memory is specified in the linker settings, and for the remaining threads, when they are created.  Maybe the code will be executed in another program (module for the web server), then the stack size will be set by the web server (IIS limits the stack of threads for the user code to 256 kilobytes, although the default size in Windows is 1 megabyte).  On other systems, there may be level constraints on the entire system.  In any case, the stack size is not very large and does not always depend on the code that uses it for stack variables. <br><br>  How much stack is used is also not always dependent on the developer. <br><br>  First, the code never starts by itself - it is launched by someone.  There is some entry point - this is a user-defined function to which control is transferred.  Before the entry point, there could be a bundle of functions that chained each other along the chain and eventually one of them caused the entry point.  They, too, can contribute to the exhaustion of the stack, and the maximum allowed volume will remain less than the developer expects. <br><br>  Secondly, even in user code, it is not so obvious how much stack memory is used.  The reader will be outraged - how not obvious?  To take and calculate the amount of memory for all local variables is quite simple.  For example, here ... <br><br><blockquote><pre> <code class="hljs pgsql"><code class="cpp">//sample <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> trivial() { <span class="hljs-type"><span class="hljs-type">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>] = {}; MessageBoxA( <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer, buffer, <span class="hljs-number"><span class="hljs-number">0</span></span> ); }</code></code> </pre> </blockquote><br><br>  ... obviously, 4 megabytes of memory is used, and on Windows (with the default stack size) it will not fly. <br><br>  Well, then the example is more complicated.  Go to ideone.com.  Disclaimer: at the time of writing the post in C ++ mode on ideone.com, gcc-4.3.4 was used, in other versions of gcc the behavior may be different.  Try this code: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//sample 1 #include &lt;stdio.h&gt; int main() { char buffer[7 * 1000 * 1000] = {}; printf( "%s", buffer ); }</span></span></code> </pre> </blockquote><br><br>  The result is success.  Well, now we try this: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//sample 2 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { if( rand() ) { char buffer[7 * 1000 * 1000] = {}; printf( "%s", buffer ); } else { char buffer[6 * 1000 * 1000] = {}; printf( "%s", buffer ); } }</span></span></code> </pre></blockquote><br>  EXTREMELY UNEXPECTEDLY <br><br>  The result is a runtime error.  What happened?  Did a rand () call cause stack exhaustion? <br><br>  Very simple - in most implementations of C ++, the entire amount of stack memory needed by this function is immediately allocated to the function ‚Äî the compiler simply inserts the ‚Äúallocate so much‚Äù code to the beginning of the function (in Visual C ++, the _chkstk () function is used for this). the compiler, based on what variables it decides to place in memory (some variables are mapped to registers, and some may be in dead code and just be deleted) and in what order. <br><br>  In the second example, the compiler decided that it was necessary to allocate memory for both arrays, ignoring that these arrays are allocated in mutually exclusive branches of the branch operator.  The standard allows this behavior (section 3.7 of ISO / IEC 14882: 2003 (E) speaks of a ‚Äúminimum lifetime‚Äù). <br><br>  The consumption of stack memory by a particular function, among other things, depends on whether the compiler can reuse the memory occupied by the variables in this function.  For example, gcc-4.3.4 failed in the second example.  Visual C ++ 10 copes with the second example, but it does not cope in this case (it is assumed that the stack size is 1 megabyte): <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//sample 3 class Temp { public: Temp() { memset( buffer, 0, sizeof( buffer ) ); printf( "%S", buffer ); } void Process() { printf( "%S", buffer ); } private: WCHAR buffer[300 * 1024]; }; int _tmain(int argc, _TCHAR* argv[]) { switch( rand() ) { case 1: Temp().Process(); break; case 2: Temp().Process(); break; default: break; } }</span></span></code> </pre> </blockquote><br><br>  Now the reader will argue that "there is nothing to allocate memory for such large objects on the stack," and this will be another absolutely true and absolutely useless statement.  In the real world, stack exhaustion occurs for less silly reasons. <br><br>  For example, there was a switch with 19 branches, in each of which a temporary object was created as in the example above.  The code worked for years.  Then they added the 20th branch with their temporary object.  The stack was, say, 256 kilobytes, before function call 56 was already used up.  For the complete exhaustion of the stack, then it is enough that each temporary object is on average just over 20 kilobytes, which is not so blatant from the point of view of a Windows developer accustomed to a megabyte stack.  20 kilobytes - still ‚Äúgood developers don't allocate on the stack‚Äù?  Well, there will be enough 2-kilobyte objects if the stack is almost exhausted. <br><br>  What can be done?  Three options. <br><br>  Option number one is to create ‚Äúlarge‚Äù objects not on the stack.  The obvious alternative is dynamic memory.  She has two problems.  First, it will be necessary to take care of the timely and proper removal of the object on its own, but there is no need to reinvent this bike, there are smart pointers.  Secondly, the allocation and release of dynamic memory is much slower - one processor instruction cannot be used there, so at least it is worth assessing whether such a transition will give a noticeable slowdown and, if suspicious, profile this code. <br><br>  Option number two - reduce objects.  Maybe it is not necessary to use a 256-kilobyte array, but you can get by with a 4-kilobyte array?  This is not always possible and this does not exclude the risk of overflow, but it significantly reduces it in many cases. <br><br>  Option number three - to divide the function into several, so that the memory for objects with non-intersecting lifetime is distinguished from different functions. <br><br>  Be prepared for the fact that the compiler does not always allocate memory for stack variables as the developer expects.  To win the Darwin Award has long been so easy. <br><br>  <i>Dmitry Mescheryakov,</i> <i><br><br></i>  <i>product department for developers</i> </div><p>Source: <a href="https://habr.com/ru/post/131713/">https://habr.com/ru/post/131713/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../131707/index.html">Change the life</a></li>
<li><a href="../131708/index.html">The new IM + 5.6 - the thirteenth supported communication protocol has become ... Mail.ru Agent</a></li>
<li><a href="../131709/index.html">Developer Meeting in Moscow</a></li>
<li><a href="../131710/index.html">About some techniques of attack Man in the middle</a></li>
<li><a href="../131712/index.html">Back mask</a></li>
<li><a href="../131714/index.html">Javascript inheritance for dummies</a></li>
<li><a href="../131715/index.html">MonoDevelop 2.8.2 released</a></li>
<li><a href="../131716/index.html">Waiting for user reaction to Dialog in Android</a></li>
<li><a href="../131720/index.html">Progress bar on CSS3</a></li>
<li><a href="../131724/index.html">Ainol Novo 8 Tablet Review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>