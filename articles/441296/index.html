<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenStreetMap part average: visualization of hidden data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All of us are accustomed, considering the classic basic substrates on the Internet, to see settlements, roads and their names, houses with their numbe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenStreetMap part average: visualization of hidden data</h1><div class="post__text post__text-html js-mediator-article"><p>  All of us are accustomed, considering the classic basic substrates on the Internet, to see settlements, roads and their names, houses with their number.  But even these property objects are much more than just a name or a number.  Buildings have a number of floors, roads have a number of lanes, and cities have a number of inhabitants.  But this is only the tip of the iceberg - OpenStreetMap is so rich in a variety of spatial data that you simply never saw some of them.  And without specialized renderers you will never see, unless you are interested in editing data, what is this line with strange tags.  Today we will make such an ultra-specialized render for showing forest areas. </p><br><p><img src="https://habrastorage.org/webt/ae/7r/_m/ae7r_mo4w4x-v8amg0uqh15vjii.png" alt="Forest Quarters"></p><a name="habracut"></a><br><p>  Step 1. Research. <br>  You can certainly guess with your finger in the sky how they could be denoted, but it‚Äôs safer to go to wiki osm.  And there we can find the following: <a href="https://wiki.openstreetmap.org/wiki/RU:Tag:boundary%253Dforest_compartment">boundary = forest_compartment</a> </p><br><p> Therefore, forest areas are designated by polygons with the tag <code>boundary=forest_compartment</code> .  True, there is a clarification that it was originally designated as <code>boundary=forestry_compartment</code> , but was less literate.  And since the number of uses with the old designation is significant (according to taginfo about 4 thousand times) we will not discount it. </p><br><p>  Step 2. Data. <br>  <a href="https://download.geofabrik.de/russia.html">Take</a> data from <a href="https://download.geofabrik.de/russia.html">Geofabrik</a> .  Download the file to the whole of Russia - <code>russia-latest.osm.pbf</code> .  Using <code>osmconvert</code> we get data in o5m format for subsequent filtering. </p><br><pre> <code class="plaintext hljs">osmconvert russia-latest.osm.pbf -o=russia-latest.o5m</code> </pre> <br><p>  Now we filter only the data we need using <code>osmfilter</code> </p><br><pre> <code class="plaintext hljs">osmfilter russia-latest.o5m --keep="boundary=forest_compartment =forestry_compartment" -o=forest_compartment-local.o5m</code> </pre> <br><p>  Step 3. Vector tiles. <br>  A little bit of theory.  The old approach is to request some data from a large database, get a picture from them, save it in order to give it to the client in the future.  In the new - from a large database to request some data and save them for later transfer to the client.  And let the client himself turns them into a picture.  Profit, as it were, on the face - we rendered the load on the rendered image onto the client‚Äôs shoulders.  Of the minuses - on the coffee machine may not be able to see the map, need support WebGL. </p><br><p>  And so Mapbox suggested a vector tile format and a container for them in the form of an sqlite database.  Therefore, now it is not a scattering of files in folders, but a neat single file.  A vector tile contains logical layers (houses, roads, etc.) that consist of geometry and attributes. </p><br><p>  Here we will prepare them for our forest quarters.  I will use the <a href="https://github.com/systemed/tilemaker">TileMaker</a> tool.  At the input it accepts OSM data in pbf format, so after filtering we need to convert it back to this format. </p><br><pre> <code class="plaintext hljs">osmconvert forest_compartment-local.o5m -o=forest_compartment-local.pbf</code> </pre> <br><p>  Now we need to explain to TileMaker which layers and with which attributes we need, according to the <a href="">documentation</a> . </p><br><p>  Step 4. Layers? <br>  And what layers do we need?  And it depends on what we show.  Those.  first of all, we must already somehow visualize the visual part.  And how it can be achieved from the available data.  From OSM data we have a polygon mesh and their attributes.  In the attributes there is the name of the forest district and the number of the quarter. </p><br><p><img src="https://habrastorage.org/webt/ii/mb/6v/iimb6vqew9cch0kpobg2ko4qej8.png" alt="OSM Raw Data"></p><br><p>  From this the easiest to display the quarter and sign it with your number.  Those.  we need a polygonal layer, in the center of the polygon we will display an inscription with its number. <br>  And here the first feature of vector tiles comes up.  When a large source polygon falls on different tiles, only its parts fall into tiles.  And when drawing it, there are two different polygons, respectively, for them there will be two signatures in the center of their halves. </p><br><p><img src="https://habrastorage.org/webt/qp/av/s-/qpavs-uusqadrvzpisc2ukozii4.png"></p><br><p>  Therefore, for the vector tiles prepare a separate layer with the inscriptions, when there is still all the necessary information about the geometry. </p><br><p>  Bottom line: we need two layers, polygonal for the fill and dot for the signature.  Create a file <code>config.json</code> . </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"layers"</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">"settings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"minzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"basezoom"</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include_ids"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"freeExec"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Forest Compartment RUS"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ODbL 1.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Forest compartment from OpenStreetMap"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"compress"</span></span>: <span class="hljs-string"><span class="hljs-string">"gzip"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"attribution"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;a href=\"http://www.openstreetmap.org/copyright/\" target=\"_blank\"&gt;&amp;copy;  OpenStreetMap&lt;/a&gt;"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"json"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"vector_layers"</span></span>: [ ] } } } }</code> </pre> <br><p>  In the layers section we specify what we need. </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"layers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"forest_compartment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"minzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"forest_compartment_label"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"minzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span> } },</code> </pre> <br><p>  The names of the layers are indicated and on what scale we will show them. </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"json"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"vector_layers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Compartment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: {}}, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"forest_compartment_label"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Compartment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: {<span class="hljs-attr"><span class="hljs-attr">"ref"</span></span>:<span class="hljs-string"><span class="hljs-string">"String"</span></span>}} ] }</code> </pre> <br><p>  In the metadata, we tell the future visualizer what attributes we have available.  For the label layer, we will have the block number in <code>ref</code> . </p><br><p>  Step 5. Data processing. <br>  For this purpose, a script in the <code>lua</code> language serves, which will decide which objects from the OSM data we need, to which layer to send them and with which attributes. </p><br><p>  Let's start with the <code>process.lua</code> file template. </p><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- Nodes will only be processed if one of these keys is present node_keys = { } -- Initialize Lua logic function init_function() end -- Finalize Lua logic() function exit_function() end -- Assign nodes to a layer, and set attributes, based on OSM tags function node_function(node) end -- Similarly for ways function way_function(way) end</span></span></code> </pre> <br><p>  What we have here: </p><br><p>  Node_keys - there are a lot of points in the OSM data, if we poke into this script with each, the processing will last a very long time.  This is a kind of filter that tells us which points are interesting to us with which keys. </p><br><p>  function node_function (node) - the function will be called for every point that is interesting to us from the previous item.  Here we must decide what to do with it. </p><br><p>  function way_function (way) is a function that will be called on any line and on relations with the multipolygon and boundary type, since  they are considered area objects. </p><br><p>  Start writing code.  First we will indicate which points we need: </p><br><pre> <code class="lua hljs">node_keys = { <span class="hljs-string"><span class="hljs-string">"boundary"</span></span> }</code> </pre> <br><p>  Now we write the function for processing them: </p><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">node_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> boundary = node:Find(<span class="hljs-string"><span class="hljs-string">"boundary"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> boundary == <span class="hljs-string"><span class="hljs-string">"forestry_compartment"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> boundary == <span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ref = node:Find(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ref ~= <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> node:Layer(<span class="hljs-string"><span class="hljs-string">"forest_compartment_label"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) node:Attribute(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>, ref) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  What happens here: read the value of the <code>boundary</code> key through the <code>node:Find("")</code> .  If it is <code>forest_compartment</code> , then we read the block number from the <code>ref</code> tag.  If it is not empty, then this object is added to our layer with labels, via the <code>Layer("_", ___)</code> .  In the attribute of the layer <code>ref</code> save the block number. <br>  Almost as easy for areal quarters: </p><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">way_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(way)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> boundary = way:Find(<span class="hljs-string"><span class="hljs-string">"boundary"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> way:IsClosed() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ( boundary == <span class="hljs-string"><span class="hljs-string">"forestry_compartment"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> boundary == <span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> way:Layer(<span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) way:AttributeNumeric(<span class="hljs-string"><span class="hljs-string">"nomerge"</span></span>, way:Id()) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ref = way:Find(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ref ~= <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> way:LayerAsCentroid(<span class="hljs-string"><span class="hljs-string">"forest_compartment_label"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) way:Attribute(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>, ref) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Here we additionally check that the line is closed, since  It happens that the tags are present simply on the segments.  It is worth noting that the <code>forest_compartment</code> layer <code>forest_compartment</code> areal (therefore, the second argument in the <code>Layer("", true))</code> function <code>Layer("", true))</code> , and we take the place for the signature as the center of the <code>LayerAsCentroid</code> figure. </p><br><p>  It is also worth paying attention to the attribute that we add, although we did not specify it in the config - <code>nomerge</code> .  It is needed to defeat another feature, this time already the TileMaker converter (although in the new version there is a parameter to disable it). </p><br><p>  The peculiarity is that for optimization, when there are many objects with the same attributes in one layer, the converter for them combines the geometry into one.  For example, we have a street consisting of three separate segments, which in the end will be sent to the render three times.  This is longer, compared to the system that we would send a single object to the render, but with a slightly more complex (uniting them all) geometry. </p><br><p>  In our case, all adjacent neighborhoods would be united into one large polygon, and we do not need this.  Therefore, we add the number of the object so that they are different and not combined. </p><br><p>  Now it's time to start the process of creating vector tiles. </p><br><pre> <code class="plaintext hljs">tilemaker forest_compartment-local.pbf --output forest_compartment-local.mbtiles</code> </pre> <br><p>  As a result, we should have a <code>forest_compartment-local.mbtiles</code> file <code>forest_compartment-local.mbtiles</code> </p><br><p>  Step 6. Create a style. <br>  We get an account on <a href="https://www.mapbox.com/">mapbox.com</a> .  In Mapbox Studio, in the Tileset section, create a new tileset by dragging our previously created file into the download window.  Within a minute, it should be processed and added to the list. </p><br><p>  Now go to the Styles section and create a new one based on the finished Light, so that we can see the main map elements, such as roads, settlements, etc.  We are going to Cheboksary because forest quarters were noticed there. </p><br><p>  We descend to the 11th level of the scale (we only created tiles for it) and click the Add layer button.  In the data source tab we find our data source <code>forest_compartment-local-XXXXX</code> , in it we select the polygonal layer.  It should be highlighted on the right green. </p><br><p><img src="https://habrastorage.org/webt/dq/ka/-h/dqka-h_wx2qcqz-xbncxutb1exo.png" alt="Adding a layer"></p><br><p>  Next on the style tab, set the fill color to green and the strokes to brown. </p><br><p><img src="https://habrastorage.org/webt/zb/h_/zp/zbh_zpmk7tmktabdpbfvxoekbeu.png" alt="Color setting"></p><br><p>  Now it remains to add a signature.  We add a new layer, only this time we select <code>forest_compartment_label</code> in the data, and type select <code>symbol</code> , the numbers should appear on the right. </p><br><p><img src="https://habrastorage.org/webt/er/gh/_x/ergh_x_oj7bjv0redgs9bf9ylta.png" alt="Add a label layer"></p><br><p>  In the style tab, we indicate that we need to display our <code>ref</code> attribute. </p><br><p><img src="https://habrastorage.org/webt/zl/7r/nq/zl7rnqapwxl7qqtzyminooid1z4.png" alt="Attribute for signature"></p><br><p>  That's as if everything, click on the right side of the screen publish and we can share the link so that others can look at our creation.  But the display of maps is not free, as elsewhere, so I will not give you my link, so as not to get to the effect. </p><br><p>  PS: Perhaps in an additional article I will tell you how I achieved the location of the signature with the name of the forest area on a group of neighborhoods in it. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/441296/">https://habr.com/ru/post/441296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441282/index.html">Big interview with creator Jenkins, Kohsuke Kawaguchi</a></li>
<li><a href="../441286/index.html">The Yandex neural network co-wrote a play for viola and orchestra</a></li>
<li><a href="../441288/index.html">6 points of conversion growth or effective techniques of working with the price on the site</a></li>
<li><a href="../441290/index.html">"The Witcher 3: Wild Hunt": how localizers translated names and titles</a></li>
<li><a href="../441292/index.html">Fintech-digest: the robot of the Central Bank against financial pyramids, banks check the data of subscribers of cellular operators</a></li>
<li><a href="../441298/index.html">Cisco Live EMEA 2019: we are changing the old IT bike on BMW in the clouds</a></li>
<li><a href="../441300/index.html">Anachronism, crunchy, bad organizational structure: three pains of a timlid in a corporation</a></li>
<li><a href="../441302/index.html">AMA with Habrom (Straight line with TM, v 6.0)</a></li>
<li><a href="../441304/index.html">Waymo taught robobomi obey the gestures of the traffic controller</a></li>
<li><a href="../441306/index.html">How for 1 day QA-engineer to get an offer in Moscow (and is it expensive to live here)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>