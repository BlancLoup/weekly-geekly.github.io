<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analysis of the consensus algorithm in Tendermint</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article describes the BCA consensus algorithm (Byzantine Consensus Algorithm) used in Tendermint. Developed on the basis of the DLS protocol, it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analysis of the consensus algorithm in Tendermint</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/vs/ey/p1/vseyp1uv4h2qiqhkzkpk_stzbzw.jpeg" alt="tendermint_logo"></p><br><p>  This article describes the BCA consensus algorithm (Byzantine Consensus Algorithm) used in Tendermint.  Developed on the basis of the DLS protocol, it does not require any "active" mining, as in Proof-of-Work, and can ensure the safe operation of the network with at least 2/3 + (strictly more than two thirds) "honest" network participants.  Below is a story about how this algorithm is implemented in Tendermint, shows the statistics of its work and simulates the behavior of the algorithm on a small network of five participants. </p><a name="habracut"></a><br><h1 id="table-of-contents">  Table of contents </h1><br><ul><li>  Introduction </li><li>  Validators </li><li>  Simple scheme </li><li>  Algorithm steps <br><ul><li>  Malicious proposer </li><li>  Optimal scenario </li></ul></li><li>  Conclusion </li><li>  Links </li></ul><br><h1 id="introduction">  Introduction </h1><br><p>  Since the advent of Bitcoin, enormous work has been done on its Proof-of-Work to find new consensus algorithms.  All has undergone to revision: </p><br><ul><li>  network bandwidth (it's hard to talk about the competition of Visa and Bitcoin, having 7 TPS against 4000 TPS) </li><li>  network scaling (for example, data sharding problem) </li><li>  resistance to a whole class of new attacks characteristic of blockchain networks </li></ul><br><p>  At the moment, it seems to us, there are not many projects with potentially interesting solutions for these problems.  First of all, this is of course the Delegated-Proof-of-Stake family (BitShares, EOS, Lisk).  In addition, there is <a href="https://nem.io/">NEM</a> with Proof-of-Importance and <a href="https://www.reddit.com/r/nem/comments/6u3cle/noob_question_what_is_the_transactions_per_second">declared</a> 4000 TPS (we will definitely tell about how this is possible in one of the following articles).  The tangle created in IOTA deserves some attention.  But in this article we would like to focus on the BCA algorithm and its implementation in the Tendermint project. </p><br><h1 id="validators">  Validators </h1><br><p>  First of all, you need to talk about those who support the network in working condition (that is, it participates in building consensus).  Unlike the same Proof-of-Work or Proof-of-Stake, where anyone can become a miner at any time, in the BCA only the so-called <em>validators</em> can take part in the formation of the blockchain. </p><br><p>  How a regular network participant becomes a validator depends on the specific implementation.  In the simplest case, validators are declared in the genesis block and in the future their list does not change (the main thing is that the initial list of design validators is strictly less than 1/3!).  In the same Tendermint, you can easily implement a rotation of validators.  To do this, it is enough to indicate in the protocol a special transaction that will be sent by the participant if he wants to "run".  In addition, it is possible, like within the same Lisk, to enter a vote for candidates or to select them according to some existing parameters. </p><br><p>  In the implementation of Tendermint, for any block you can always get an accurate list of validators *.  They are identified by their public keys, and in the voting process they sign with the corresponding private keys messages sent to other validators and regular members of the network.  Thus, you can always determine the author of a voice and be sure that no one ‚Äúfrom the side‚Äù can take part in building a consensus. </p><br><hr><br><p>  * The initial list is specified in the genesis file;  Transactions that change the list of validators are the same transactions as any others, which means they are also saved in the blockchain and are available to all network members to get the current list of validators. </p><br><h1 id="simple-scheme">  Simple scheme </h1><br><p>  Let's start with an abstract description of what happens in the algorithm, at the time of searching for block N. </p><br><pre><code class="hljs erlang-repl">NewHeight -&gt; (Propose -&gt; Prevote -&gt; Precommit)+ -&gt; Commit -&gt; NewHeight -&gt;...</code> </pre> <br><p>  <code>Propose</code> - some proposer * offers its version of the block to the height N. </p><br><p>  <code>Prevote</code> - at this step, each of the validators gives their "estimated opinion" to the block.  In the simplest case, the validator will send a message like "Received block &lt;block hash&gt; to the network, I agree with everything". </p><br><p>  <code>Precommit</code> - after some time allocated to the <code>Prevote</code> step, each validator checks how many <code>Prevote</code> messages have accumulated from other participants.  If there are <code>Precommit</code> + of the total number of validators, then the validator sends a transaction to <code>Precommit</code> . </p><br><p>  Three steps in parentheses <code>(Propose -&gt; Prevote -&gt; Precommit)</code> - this is the so-called <em>round</em> .  Its essence is that there are many cases where for some reason it was not possible to find a new unit.  For example, the selected proposer could be offline or could offer a deliberately incorrect block (this case is described in detail below). </p><br><p>  In this case, two changes are made to the consensus building process: </p><br><ul><li>  A new proposer is selected. </li><li>  Each step has a certain time duration common to all (conventionally, the <code>Prevote</code> step lasts 5 seconds, after which all participants switch to <code>Precommit</code> ).  Since it is likely that something went wrong due to a weak connection (for example, the proposer has bad Internet, he didn‚Äôt have time to load and scatter the block over the network), the duration of each step increases by some constant. </li></ul><br><p>  The following is an illustration of the entire process from the official Tendermint documentation: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9f/4ca/6f7/e9f4ca6f7f298e584e914839d2b6cbb6.png" alt="alogorithm"></p><br><hr><br><p>  * It is important to note that the proposer are selected by the round-robin algorithm from the list of validators in proportion to their weight **.  This gives two interesting properties: first of all, we need determinism (each network participant should be able to uniquely know which of the validators will become a proposer in this round).  But at the same time, we have a pseudo-random choice, which will allow to negate the attacks associated with the previously known sequence of proposer-s in the selection process. </p><br><p>  ** What weight is - to decide the protocol developer.  In the simplest case, you can give all validators the same weight, that is, the choice of proposer will be uniform. </p><br><h1 id="algorithm-steps">  Algorithm steps </h1><br><p>  In this section, I illustrated the work of the algorithm "on the fingers" in two cases - when there is something wrong with the proposed block and when everything is fine with it.  Of course, there are many more branches and cases that can be invented, but these two are basic and, having understood them, you can independently model the behavior of the algorithm in the remaining cases. </p><br><h2 id="malicious-proposer">  Malicious proposer </h2><br><p>  For a complete understanding of the algorithm, I propose to parse its work on the "real" network.  First, let's set the network itself: </p><br><ul><li>  There are 5 validators: <strong>A</strong> , <strong>B</strong> , <strong>C</strong> , <strong>D</strong> , <strong>E</strong> (as you already understood, the total number of network participants does not matter, for the BCA only validators are important). </li><li>  Validator <strong>A is</strong> selected as proposer.  Moreover, I propose to make <strong>A</strong> a Byzantine validator in order to look at the network operation at the moment when it is being attempted to compromise. </li><li>  Each step lasts t seconds;  the algorithm starts at time T. </li></ul><br><p>  So, let's start creating the <strong>#X</strong> block.  The first step is the <code>Propose</code> step, with a duration of t seconds, during which the proposer must create a block and ‚Äúscatter‚Äù it over the network, and it is extremely important that other validators have time to get this block. </p><br><p><img src="https://habrastorage.org/webt/nr/fe/hv/nrfehvfv7vizv_u5af3u6_41wai.png" alt="propose"></p><br><p>  We now turn to <code>Prevote</code> .  Now, the main task of validators is to check the block and decide whether they "agree" with it or not.  In this case, <strong>B</strong> , <strong>C</strong> , <strong>D</strong> , <strong>E</strong> will send <code>Prevote nil</code> message over the network - it means that none of them agree with the proposed block.  For greater realism, suppose that <strong>E has</strong> a bad Internet and has not received anything at all in t seconds.  <strong>A</strong> (proposer also participates in the voting!) <code>Prevote</code> send <code>Prevote</code> , in an attempt to maintain its incorrect block.  For greater realism, let <strong>E have a</strong> bad Internet as usual and he did not receive any new messages from <strong>A</strong> , <strong>B</strong> , <strong>C</strong> , <strong>D at all</strong> . </p><br><p><img src="https://habrastorage.org/webt/nq/xf/ml/nqxfmlwjnffadt2lvcu1xhsftfc.png" alt="prevote_start"></p><br><p>  Then the messages received in the <code>Prevote</code> step for each validator are as follows: </p><br><p><img src="https://habrastorage.org/webt/_x/ww/t9/_xwwt9dbu8hfzdfkam877sgjd5o.png" alt="prevote_end"></p><br><p>  Let me explain that <strong>E has a</strong> bad Internet and other participants do not have time to receive messages from him at all. </p><br><p>  Remained the final step of the round - <code>Precommit</code> .  <strong>B</strong> , <strong>C</strong> , <strong>D</strong> , <strong>E</strong> will <code>Precommit nil</code> message to the <code>Precommit nil</code> network (because the number of <code>Prevote</code> messages in each of them is less than <code>Prevote</code> + the number of validators).  Let's look at the collected <code>Precommit</code> messages for each validator: </p><br><p><img src="https://habrastorage.org/webt/jm/6-/1_/jm6-1_wnn33nyo-na2knsxxaaem.png" alt="precommit_end"></p><br><p>  Obviously, there are no validators that would collect <code>Precommit</code> + <code>Precommit</code> messages, which means, according to the scheme above, this round will be completed without creating a new height block <strong>#X</strong> .  Important note - in each block there should be these same <code>Precommit</code> messages and, obviously, there should be at least <code>Precommit</code> +.  Therefore, even if <strong>A</strong> wants to scatter a ‚Äúfalse‚Äù block over the network, then it will not have the necessary number of messages signed by <code>Precommit</code> , which means that any participant will instantly notice a trick. </p><br><h2 id="optimal-scenario">  Optimal scenario </h2><br><p>  As you already understood, in the round described above, it was not possible to create a new block.  This means that before the start of the next round, the other validator will be chosen by the proposer (let it be <strong>B</strong> ) and the length of the steps is slightly increased in order to level the effect of a slow connection.  So in this round, the validator <strong>E</strong> will no longer stand aside because of the bad Internet, but will fully participate. </p><br><p>  Again, we start with the <code>Propose</code> step, and this time the block is completely valid and managed to reach all validators.  Therefore, I suggest that you immediately switch to the <code>Prevote</code> step and see what the list of <code>Prevote</code> messages look like for each validator.  For more interest, let's assume that <strong>A</strong> is still malicious, so this time it will try to prevent the creation of the block. </p><br><p><img src="https://habrastorage.org/webt/te/cl/i1/tecli1ey1zty2j4rpbbo1psdvok.png" alt="prevote_end_optimal"></p><br><p>  It can be seen that all validators have enough <code>Prevote</code> messages to send <code>Precommit</code> messages.  Again, for the sake of interest, suppose that <strong>A</strong> sends a message to <code>Precommit nil</code> , although this is formally wrong on his part. </p><br><p><img src="https://habrastorage.org/webt/ue/zo/xr/uezoxrjnyzub7ydlc_2hu6_q0ck.png" alt="precommit_end_o"></p><br><p>  In any case, we see that this did not create problems for other participants and they have <code>Precommit</code> + <code>Precommit</code> messages in order to create a new block. </p><br><h1 id="conclusion">  Conclusion </h1><br><p>  I hope that the article was useful to you, since you have read it to this point :) A few more words about the Tendermint - in the near future we will publish at least three articles about this wonderful technology.  The first will be some overview of the whole project and its capabilities.  And in the second, the process of creating your blockchain (no ICO, we promise!) On the Tendermint + Python 3 bundle will be demonstrated in as much detail as possible. </p><br><h1 id="links">  Links </h1><br><ul><li>  <a href="https://github.com/tendermint/tendermint/wiki/Validators">Tendermint wiki - Validators</a> </li><li>  <a href="https://github.com/tendermint/tendermint/wiki/Byzantine-Consensus-Algorithm">Tendermint wiki - Byzantine Consensus Algorithm</a> </li><li>  <a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf">Consensus in the Presence of Partial Synchrony - C. Dwork, 1988</a> </li><li>  <a href="https://arxiv.org/pdf/1707.01873.pdf">Blockchain Consensus Protocols in the Wild - Christian Cachin, Marko Vukoli</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350012/">https://habr.com/ru/post/350012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350002/index.html">Two models are better than one. Experience Yandex.Translate</a></li>
<li><a href="../350004/index.html">Issue # 12: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../350006/index.html">"Tutor: Mathematics" to prepare for the exam and CDF - from idea to release. A story about a unique educational project</a></li>
<li><a href="../350008/index.html">Learn OpenGL. Lesson 4.7 - Advanced data handling</a></li>
<li><a href="../350010/index.html">YouTrack 2018.1 release: dependent task fields, personal localization and much more</a></li>
<li><a href="../350014/index.html">How to make an adequate display of the horizontal scroll bar in a QTreeWidget with one column</a></li>
<li><a href="../350016/index.html">Digital events in Moscow from February 26 to March 4</a></li>
<li><a href="../350018/index.html">You may not need Rust to speed up your JS</a></li>
<li><a href="../350022/index.html">FastTrack Training. "Network Basics". "Basics of switching or switches." Part two. Eddie Martin December 2012</a></li>
<li><a href="../350026/index.html">(Non) security monitoring systems: Zabbix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>