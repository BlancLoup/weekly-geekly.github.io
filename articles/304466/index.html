<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unity: how we created a generator of houses for AssetStore or return to Khrushchev</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The reason for writing this article was this article about "Khrushchev", which raised an interesting topic for me about software generation of meshes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unity: how we created a generator of houses for AssetStore or return to Khrushchev</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/631/7ce/d60/6317ced609a54411a4efe8a29ea902c9.jpg"><br><br>  The reason for writing this article was <strong><a href="https://habrahabr.ru/post/196862">this article</a></strong> about "Khrushchev", which raised an interesting topic for me about software generation of meshes in <strong><a href="https://unity3d.com/ru">Unity</a></strong> . <br><br>  My article is not intended for those who have long been working on Unity, it is unlikely that there will be something new for people familiar with the intricacies of Unity.  Also, for completely newbies, there are possible unobvious "difficulties" and why you need to invent something when so everything is in the editor.  The most suitable audience for us are developers who already know how to do something in Unity, but they haven‚Äôt yet solved the task of dynamically changing the meshes in the editor.  Also, perhaps some will benefit from our experience with the inspector. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The author does not pretend to have absolute knowledge of the subject area, I just want to tell in my own words the solution of some tasks that appeared during the creation of an asset. <br><a name="habracut"></a><br><img src="https://habrastorage.org/files/b75/1f2/544/b751f2544362437aa88893f9c9c8d342.jpg"><br><br>  After reading the above article, I immediately realized that this is what is needed for our project.  Originally we were going to create houses from exported fbx files.  Of course, we didn‚Äôt do one-on-one as described, we pushed away from the basic idea and immediately set ourselves the task: editing and viewing buildings directly in the Unity editor without switching to the running game mode.  As a result of the previous idea, it turned out to fit all the building settings in one script and, as a result, in the object inspector it turned out to edit the entire structure entirely in one place. <br><br><img src="https://habrastorage.org/files/f06/be4/6df/f06be46df7ab4dbcb44bf87bc45d9830.jpg"><br><br><h4>  Small retreat </h4><br>  I'll start with self-irony.  Our small team some time ago began to develop games for mobile platforms.  Starting with the ambitious task of creating your own game engine, we started to work.  According to my own experience of developing in other areas of activity and reading books about creating game engines, it was decided to write everything in pure C <strong>(</strong> <strong><a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8_%2528%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F%2529">PureC</a> )</strong> .  Several key subsystems of the engine were implemented: an optimized memory manager;  graphic renderer;  a hierarchy of objects based on the component approach <strong>( <a href="https://habrahabr.ru/post/197920/">publication on Habr√©</a> )</strong> to the creation of composite models;  tied <strong><a href="https://ru.wikipedia.org/wiki/Lua">LUA</a></strong> for the possibility of scripting created games;  implemented the ability to store in a local <a href="https://ru.wikipedia.org/wiki/SQLite"><strong>SQLite</strong></a> database everything and everything (including Lua scripts) and so on.  After quite a long time implementing all of the above and mastering the interfaces provided by OpenGL, we came to a disappointing conclusion: we can create a full-fledged engine, but very soon. <br><br><h4>  Switch to Unity </h4><br>  Naturally, in parallel with the creation of its own engine, we were interested in the achievements of the gaming industry.  We were very attracted by the <strong><a href="https://www.unrealengine.com/what-is-unreal-engine-4">Unreal Engine</a></strong> , but the minimum project of 30 ... 45MB for mobile platforms immediately cooled us, and we decided to look for other solutions, <strong><a href="http://www.shivaengine.com/">Shiva</a></strong> approached more or less, after a brief study of this engine, we decided to look for more options. <br><br>  Finally, we recently tried our hand at Unity.  The C # syntax in Unity was partially mastered, but it was quite difficult to get used to the fact that, thanks to the garbage collection system <strong>( <a href="http://docs.unity3d.com/ru/current/Manual/UnderstandingAutomaticMemoryManagement.html">GC</a> ), it was</strong> not always necessary to free up the resources that were no longer needed. <br><br><h4>  Selected topics for work </h4><br>  Before describing further work, I‚Äôll immediately tell you about the limitations: I started studying Unity 5 right away, that is, all the examples should be workable in the 5th version of Unity, for the previous 4th, and even more so the 3rd version, I can‚Äôt give any guarantees.  From my own experience I can say that some of the lessons / scripts I came across for the 4th version turned out to run on 5-ke, some required reformatting to the new version and were successfully launched, and some could not be started, had to change the command syntax .  I don‚Äôt know anything about backward compatibility of versions (small addition: before publishing an asset, the following scripts were successfully tested on Unity 4.5.0). <br><br>  For the visual content of the game, it was decided to saturate the surrounding background with various buildings.  Immediately I wanted to see in the editor the approximate appearance of the buildings.  In order to be able to "run" the script directly in the editor, it is necessary to write the line [ExecuteInEditMode], i.e., before the class inherited from MonoBehaviour.  Create the MyTest.cs script in the project and modify it using the following template: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [ExecuteInEditMode] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTest</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> {     <span class="hljs-comment"><span class="hljs-comment">//   ,     //      //   }</span></span></code> </pre> <br>  When changing any field in the inspector, the script method (if implemented) Update () will be called.  In order to save on the size of the scripts collected for the game, this method can be "screened" with a couple of #if UNITY_EDITOR ... #endif directives, thus drawing an approximate template of the directly modified script in the component inspector: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [ExecuteInEditMode] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTest</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR    void Update () {        Debug.Log ("Update");    } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  Attach this script to any component on the scene and change the value of the i field in the inspector, the Update will be immediately displayed in the console (more precisely, the number of Update messages will increase), the script will ‚Äúexpect‚Äù changes in public fields the rest of the time. <br><br>  It should be noted that if there are a large number of components with this script on the stage, the scene will noticeably slow down.  To get rid of this, you need to move the change handler in the inspector to the script in a special folder Editor.  The contents of this folder will not fall into the finished project.  Let's create an Editor folder with the MyTestInspector.cs script in it: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; [CustomEditor(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MyTest))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTestInspector</span></span> : <span class="hljs-title"><span class="hljs-title">Editor</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//       public override void OnInspectorGUI()    {        //           DrawDefaultInspector ();        //            MyTest mt = target as MyTest;        //  ,        //            mt.DoRefresh();    } }</span></span></code> </pre><br>  Let's look at the modified MyTest script: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [ExecuteInEditMode] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTest</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">10</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoRefresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {        Debug.Log (<span class="hljs-string"><span class="hljs-string">"Update"</span></span>);    } }</code> </pre><br><h4>  Setup inspector for more convenient work </h4><br>  After studying the official certificate and googling, we first focused on a variant that provided for redrawing public properties in the inspector and reacting to their change by appropriate methods in the script, but then it was decided to split the original data for editing into interrelated data structures with which it is easy to operate without losing in about 130 simultaneously visible settings for building a building.  After that, the need for "own inspector" disappeared.  However, we hope to return to this approach in the future when creating and editing components.  If anyone is interested, I can give links: <a href="http://docs.unity3d.com/Manual/ExtendingTheEditor.html"><strong>here</strong></a> and <a href="https://unity3d.com/ru/learn/tutorials/modules/intermediate/editor/building-custom-inspector"><strong>here</strong></a> . <br><br><h4>  Some subtleties of creating an interface </h4><br>  In the usual creation of a public variable of type int or float, like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iterator=<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx=<span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre><br>  In the inspector, they are displayed as simple editing fields, with frequent changes of these values ‚Äã‚Äãin the process of work, it is terribly annoying to constantly hit the mouse in the fields, enter meaningful numbers that are slightly different from each other, and look at the changes made, it is much more convenient to use a different approach.  When declaring fields immediately before a variable (in the line above), specify the allowable range for the input values: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Range(-10, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iterator=<span class="hljs-number"><span class="hljs-number">2</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx=<span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre><br>  After such additions in front of the variables, in the inspector it is enough to move the slider to smoothly or abruptly change the value. <br><br>  In order not to show all the fields in the script at the same time, and we have about 130 of them, we can resort to grouping strongly related values ‚Äã‚Äãinto one class, and already this class should be declared a public field in the script.  In order to be able to save changes of fields in separate instances of classes and show fields in the inspector, it is necessary to write the line [System.Serializable] before declaring the class (again, the line above), we end up with: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LeftRightSide</span></span> {    [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)]    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftSide=<span class="hljs-number"><span class="hljs-number">3</span></span>;    [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)]    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightSide=<span class="hljs-number"><span class="hljs-number">20</span></span>; }</code> </pre><br>  After you declare this class as a public field in your script, a hidden / expandable block of fields will appear in the inspector to edit the contents of the class described above.  The hierarchical nesting of various classes into each other is possible and it is limited only by common sense.  Such a simple technique allows, firstly: grouping data related to each other, and secondly: it simplifies navigation in the inspector.  We describe the entire script: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [ExecuteInEditMode] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTest</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LeftRightSide leftRight=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LeftRightSide();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoRefresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {        Debug.Log (<span class="hljs-string"><span class="hljs-string">"Update"</span></span>);    } } [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LeftRightSide</span></span> {    [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)]    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftSide;    [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)]    <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightSide; }</code> </pre><br><h4>  Variable directly in the mesh editor </h4><br>  Preparing components for drawing a mesh.  In order to be able to edit and show the mesh, you can use the features of the editor, for example: create an empty object on the scene, then add the MeshFilter and MeshRenderer to it through the menu items Component-&gt; Mesh-&gt; Mesh Filter and Component-&gt; Mesh-&gt; Mesh Renderer respectively.  The first component is responsible for the ‚Äúinternal‚Äù geometry of the mesh, the second is associated with drawing the mesh on the screen.  There is another, more reliable way to add these components.  When creating a script, it is necessary to instruct to add the above two components, if they are missing on the component to which the script is attached.  To do this, before declaring the descendant class MonoBehaviour, write the string [RequireComponent (typeof (MeshFilter), typeof (MeshRenderer))].  Sample script preparation: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] [ExecuteInEditMode] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTest</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre><br><h4>  A bit of theory (those who know how to work with meshes in Unity can skip this section) </h4><br>  To display something in the mesh of a component, it is necessary to fill the mesh with the required data.  The very minimum of which consists of a set of vertices and so-called facets (this name has synonyms, for example: triangles, faces, facets, an array of indices), that is, the rules for associating vertices with each other.  Additionally, the possibility of drawing textures will be considered, that is, you will need to use uv-coordinates.  Normals will also be shown briefly.  Immediately make a reservation, here I consider only the "classic" work of shaders, without considering the work of the particle system, the grid mode of operation, and others.  That is, the mode of drawing by triangles based on vertices and the rules of their "bundle" will be considered.  In general, a detailed review of this topic, i.e.  meshes, shaders, vertex bundles, facets, normals, texture coordinates, vertex buffers, matrices and other things can (and should) take up several books, so I‚Äôll confine myself to the minimum amount of information that should be enough to build dynamic meshes displayed directly in the editor. <br><br>  Knowing how to draw a triangle, you can draw an arbitrarily complex shape, combining triangles together.  For example, for a square, a rhombus, a parallelepiped, a trapezium, and generally a quadrangle, two triangles are enough.  To draw more complex shapes, more triangles are needed, but the principle will not change.  That is, the minimum and sufficient primitive for drawing everything else, we agree to consider a triangle. <br><br>  I‚Äôll briefly mention shaders: shaders are specially written and compiled programs that draw triangles according to certain rules.  In fact, everything is somewhat more complicated, but for brevity we will accept such an interpretation.  I will only mention that when drawing the next triangle, the shader does not know anything about the neighboring triangles. <br><br>  The memory in the computer is linear, and wherever there is a large / composite data block (that is, structure, class, array, etc.), its contents are immediately behind each other, and access to its elements is also best organized linearly.  And since the mesh is a complex structure, which can contain fairly large volumes of different, but united by the type of specific data, then the management of this data will also be properly organized by linear access.  That is, it is necessary to create and fill in arrays with the appropriate data, and then "attach" these arrays to the mesh. <br><br>  I will list some data types we need for building meshes: <br><br>  Vertices (vertices) - consist of an array of data of type Vector3, that is, of a structure containing three consecutive data of type float, which is nothing more than the spatial coordinates of a single vertex along the x, y and z axes. <br><br>  Vertex indices or facets (triangles) - consist of an array of int data type, but here you need to take into account that whole numbers must be grouped by 3 into one triangle.  Consider this point in more detail, the fact is that to describe a single triangle (that is, a minimally drawn primitive), you need to specify 3 vertex indices.  The first three numbers define the drawing of the first triangle, the second three - the second, etc.  It is also important to mention the order of traversing vertices in a triangle.  If you enumerate vertices (that is, vertex indices) clockwise, the triangle "looks at you", that is, you see it, otherwise the triangle will not appear and you will not see it, but if you visually "bypass" it from the opposite side, he will be visible to you (that is, from a new perspective, the enumeration of the vertices "will change" and will be clockwise).  As you might guess, the total length of the entire array will be equal to the number of triangles multiplied by three. <br><br>  Normals (normals) - consist of an array of data of type Vector3, this is an array of "perpendiculars" to the vertices, the dimension of the array of normals and the array of vertices is the same.  The absolute length of each normal vector is equal to one, in essence, a ‚Äúangle of rotation‚Äù of a vertex is formed.  Why do we need these normals?  They are needed in order to properly consider the lighting of the triangle.  Knowing the angles between the normal, the beam of the light source and the eye of the observer, we can calculate the illumination.  Normals are created and computed not for triangles, as you might expect, namely for the vertices separately.  If the normal is set only to a triangle, then the shader does not know how the normal from the triangle to the triangle should change (because the shader knows nothing about neighboring triangles), the drawn figure will look albeit illuminated, but strongly angular.  The fact is that the shader, when processing each triangle, uniformly changes some parameters between the vertices from one to another, including the normals to the vertices.  This results in a smooth change in illumination, even within a single triangle.  If the normals to the vertices of the triangle diverge from each other, then the triangle will look "convex", if the normals converge, then the triangle will be "concave", if the normals are parallel, the triangle will be flat.  Neighboring triangles will be built on the same principle, they will coincide the corresponding vertices with the normals, and if the triangles are at different, but not very different angles, then the transition between triangles will be smooth, and the border between them will be slightly different. <br><br>  UV coordinates (uv) - consist of an array of data of type Vector2, that is, of a structure containing two variables of type float, which are the x and y coordinates of the "inside" texture.  Here you need to tell more.  The lower left corner of the texture corresponds to the uv coordinate (0, 0), the upper left is (0, 1), the upper right is (1, 1) and the lower right is (1, 0).  If you take coordinates in the range [0 ... 1], then the whole texture will be drawn partially or completely, depending on the values ‚Äã‚Äãyou specify.  You can take values ‚Äã‚Äãoutside the specified range, then the texture will be repeated as many times as you specify, for example, the uv coordinate is selected (2, 3.5), then the x axis will repeat the texture 2 times, and the y axis 3.5 times.  In order for the texture to be repeated, you need to set the necessary flags for this.  In many cases, flags are set by default.  The dimension of the array of uv coordinates is the same as the dimension of the vertex array, that is, each vertex corresponds to the texture coordinate uv. <br><br>  Summarize the above.  To create and draw a mesh, you need to create arrays of vertices, indexes of vertices, uv-coordinates and normals. <br><br>  Look at the figure below, it shows schematically the placement of the vertices of the rectangle relative to the center of coordinates.  The vertex indices are indicated near the corners of the rectangle, that is, their index in the array of vertices.  I recommend when building any shapes to create them with a "geometric center" at the origin.  This is useful if you need to rotate and / or scale your shape with a predictable result.  After creating a mesh, you can easily move all its vertices in the direction you want. <br><br><img src="https://habrastorage.org/files/fc1/cb0/606/fc1cb060690c412e99d57a49a8d1cbbe.jpg"><br><br>  Let's start creating a mesh so far only with vertices and indexes, change the above script by example: <br><br><div class="spoiler">  <b class="spoiler_title">MyTest.cs file</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] [ExecuteInEditMode] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyTest</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//        public Banner banner = new Banner();    void Start () {    }    //       public void DoRefresh()    {        //    3         //           //     3*1=3        Vector3[] v=new Vector3[3]; //         int[] f=new int[3]; //          //            Mesh tmpMesh;        //          float w2 = banner.bWidth / 2; //          float h2 = banner.bHeight / 2; //          //  , z           v [0] = new Vector3 (-w2, -h2, 0); //0-         v [1] = new Vector3 (-w2, h2, 0); //1-         v [2] = new Vector3 (w2, h2, 0); //2-         //          //     ,        //              f [0] = 0;        f [1] = 1;        f [2] = 2;        //          tmpMesh = new Mesh ();        //           tmpMesh.vertices = v; //         tmpMesh.triangles = f; // ,            //""           GetComponent&lt;MeshFilter&gt; ().mesh = tmpMesh;    } } [System.Serializable] public class Banner {    [Range(0.0f, 1.0f)]    public float bWidth=0.5f;    [Range(0.0f, 1.0f)]    public float bHeight=0.5f; }</span></span></code> </pre><br></div></div><br>  Create an "empty" component on the scene (GameObject-&gt; Create Empty menu) and attach a script to it, you should see a pink triangle, if the triangle is not visible, rotate the camera around the component.  Try to change the width and height of the banner in the inspector, you should immediately see the changes in the triangle.  Let's make a rectangle.  To do this, change the contents of the DoRefresh () method to the following: <br><br><div class="spoiler">  <b class="spoiler_title">MyTest.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoRefresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//    4        //    0-, 1-  2-     //   0-, 2-  3-     //   2 ,    //     3*2=6    Vector3[] v=new Vector3[4];    int[] f=new int[6];    Mesh tmpMesh;    float w2 = banner.bWidth / 2;    float h2 = banner.bHeight / 2;    v [0] = new Vector3 (-w2, -h2, 0);    v [1] = new Vector3 (-w2, h2, 0);    v [2] = new Vector3 (w2, h2, 0);    v [3] = new Vector3 (w2, -h2, 0); //3-     //      //    ,    //          //1-     f [0] = 0;    f [1] = 1;    f [2] = 2;    //2-     f [3] = 0;    f [4] = 2;    f [5] = 3;    tmpMesh = new Mesh ();    tmpMesh.vertices = v;    tmpMesh.triangles = f;    GetComponent&lt;MeshFilter&gt; ().mesh = tmpMesh; }</span></span></code> </pre><br></div></div><br>  After editing the script and switching to the Unity environment, our triangle will ‚Äúcomplete‚Äù to the rectangle.  Now let's change the color of the rectangle.  To do this, you need to change the script in 2 places, at the very top, where the public class Banner is created, you need to add the line public Material bannerMaterial;  i.e: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Banner banner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Banner(); <span class="hljs-comment"><span class="hljs-comment">//    public Material bannerMaterial;</span></span></code> </pre><br>  And also at the very end of the DoRefresh () method, add the line GetComponent &lt;MeshRenderer&gt; () .material = bannerMaterial;  i.e: <br><br><pre> <code class="cs hljs"> GetComponent&lt;MeshFilter&gt; ().mesh = tmpMesh; <span class="hljs-comment"><span class="hljs-comment">// ,     GetComponent&lt;MeshRenderer&gt; ().material = bannerMaterial;</span></span></code> </pre><br>  After this, a material type variable appears in the inspector, where you can assign a material, and if you change its value, the rectangle will immediately react to the material change, it will "repaint", but it will still be filled with one color (in Unity 4.5.0, texture coordinates).  This is due to the fact that the uv coordinates were not given to the mesh, let's fix it.  You will have to replace the DoRefresh () method again with the following text: <br><br><div class="spoiler">  <b class="spoiler_title">MyTest.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoRefresh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {    Vector3[] v=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">4</span></span>];    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] f=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>];    <span class="hljs-comment"><span class="hljs-comment">//  uv   4     Vector2[] uv=new Vector2[4];    Mesh tmpMesh;    float w2 = banner.bWidth / 2;    float h2 = banner.bHeight / 2;    v [0] = new Vector3 (-w2, -h2, 0);    v [1] = new Vector3 (-w2, h2, 0);    v [2] = new Vector3 (w2, h2, 0);    v [3] = new Vector3 (w2, -h2, 0);    f [0] = 0;    f [1] = 1;    f [2] = 2;    f [3] = 0;    f [4] = 2;    f [5] = 3;    //   uv        uv [0] = new Vector2 (0, 0); //0- ,        uv [1] = new Vector2 (0, 1); //1- ,        uv [2] = new Vector2 (1, 1); //2- ,        uv [3] = new Vector2 (1, 0); //3- ,        tmpMesh = new Mesh ();    tmpMesh.vertices = v;    tmpMesh.triangles = f;    tmpMesh.uv = uv; //       GetComponent&lt;MeshFilter&gt; ().mesh = tmpMesh;    GetComponent&lt;MeshRenderer&gt; ().material = bannerMaterial; }</span></span></code> </pre><br></div></div><br>  Now, if you have a picture attached to the material, it will stretch across the entire rectangle.  But still not enough realism.  To add realism, you need to take into account the lightness, and for this you need to create normals and add them to the mesh.  In our particular case, this is simple.  The mesh is drawn in the XOY plane, that is, perpendicular to the Z axis. It remains to determine the sign of the z-coordinate of the normal.  The normals must come from the vertices into that half-space (meaning the half-space of the front side of the triangle) from which they are visible.  Edit the DoRefresh () method again: <br><br><div class="spoiler">  <b class="spoiler_title">MyTest.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoRefresh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {    Vector3[] v=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">4</span></span>];    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] f=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>];    Vector2[] uv=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2[<span class="hljs-number"><span class="hljs-number">4</span></span>];    <span class="hljs-comment"><span class="hljs-comment">//      Vector3[] n = new Vector3[4];    Mesh tmpMesh;    float w2 = banner.bWidth / 2;    float h2 = banner.bHeight / 2;    v [0] = new Vector3 (-w2, -h2, 0);    v [1] = new Vector3 (-w2, h2, 0);    v [2] = new Vector3 (w2, h2, 0);    v [3] = new Vector3 (w2, -h2, 0);    f [0] = 0;    f [1] = 1;    f [2] = 2;    f [3] = 0;    f [4] = 2;    f [5] = 3;    uv [0] = new Vector2 (0, 0);    uv [1] = new Vector2 (0, 1);    uv [2] = new Vector2 (1, 1);    uv [3] = new Vector2 (1, 0);    //    ,  ,    //   ,   Z    for (int i=0; i&lt;4; i++) {        n[i]=new Vector3(0, 0, -1);    }    tmpMesh = new Mesh ();    tmpMesh.vertices = v;    tmpMesh.triangles = f;    tmpMesh.uv = uv;    tmpMesh.normals = n; //     GetComponent&lt;MeshFilter&gt; ().mesh = tmpMesh;    GetComponent&lt;MeshRenderer&gt; ().material = bannerMaterial; }</span></span></code> </pre><br></div></div><br>  Now, if you change the intensity of the light source, the direction of the light, you can immediately see the results on the rectangle. <br><br>  For this I will take my leave, the article has turned out to be quite large.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please send in a personal all noticed errors and inaccuracies. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: The artist from me is weak, so the schematic drawing was not entirely clear. </font><font style="vertical-align: inherit;">Also, I can not publish the full source code for the construction of buildings, as the project is commercial.</font></font></div><p>Source: <a href="https://habr.com/ru/post/304466/">https://habr.com/ru/post/304466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304456/index.html">What is creativity</a></li>
<li><a href="../304458/index.html">We pull the chain of certificates</a></li>
<li><a href="../304460/index.html">Announcement of the release of the SDcast podcast about OpenVZ</a></li>
<li><a href="../304462/index.html">The book about the development of applications for Firebird</a></li>
<li><a href="../304464/index.html">The best IT courses of Western universities according to the version of the habrasoobschestva 2016</a></li>
<li><a href="../304468/index.html">What you need to know about the IaaS-provider even before the start of cooperation</a></li>
<li><a href="../304470/index.html">How typography can save your life</a></li>
<li><a href="../304472/index.html">Vibration Management with jquery.vibrate.js Library</a></li>
<li><a href="../304474/index.html">How to level the Pyramid of death</a></li>
<li><a href="../304476/index.html">The base of free Github repositories is available through the interface BigQuery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>