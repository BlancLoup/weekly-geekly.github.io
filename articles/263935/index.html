<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Familiarity with the internal structure of the .NET Framework. Let's see how the CLR creates objects.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Attention of readers of "Habrakhabr" is the translation of the article to Khan Kommalapati and Tom Christian about the internal structure of .NET. The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Familiarity with the internal structure of the .NET Framework. Let's see how the CLR creates objects.</h1><div class="post__text post__text-html js-mediator-article">  Attention of readers of "Habrakhabr" is the translation of the article to Khan Kommalapati and Tom Christian about the internal structure of .NET.  There is an alternative translation on the <a href="https://msdn.microsoft.com/ru-ru/library/Dd335945.aspx">Microsoft</a> website. <br><br>  The article deals with: <br><br><ul><li>  System Domain (SystemDomain), SharedDomain Shared Domain and Default Domain (DefaultDomain) </li><li>  Object representation and other features of memory organization </li><li>  Method table view </li><li>  Method distribution </li></ul><br>  Technologies used: .NET Framework, C # 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Content </h1><br><ol><li>  Domains created by the bootloader </li><li>  System domain </li><li>  Shared Domain (shared) </li><li>  Default Domain </li><li>  Heap loader </li><li>  Type Basics </li><li>  Object instance </li><li>  Method table </li><li>  Base copy size </li><li>  Method Slot Table </li><li>  Method descriptor </li><li>  Map of virtual interface method tables and interface map </li><li>  Virtual distribution </li><li>  Static variables </li><li>  EEClass </li><li>  Conclusion </li></ol><br><a name="habracut"></a><br>  Common Runtime (CLR) is becoming (or has already become) the main infrastructure for building applications in Windows, so having a deep understanding of its internal structure will help create efficient, industrial-grade applications. <br><br>  In this article, we will explore the internal structure of the CLR, including the layout of an object instance, the layout of the method table, the distribution of methods, the interface distribution, and various data structures. <br><br>  We will use very simple fragments of C # code, any implicit use of the programming language syntax implies C #.  Some of the data structures and algorithms discussed will be changed in future versions of the Microsoft¬Æ .NET Framework, but the conceptual framework will remain the same.  We will use the Visual Studio¬Æ .NET 2003 debugger and the Son of Strike (SOS) debugger extension to view the data structures discussed in the article.  SOS loads internal CLR data, and allows you to view, save information of interest.  See the procedure for loading SOS.dll in the debugger process in the appropriate sources. <br>  See the "Son of Strike" sidebar for loading SOS.dll into the Visual Studio .NET 2003 debugger process. <br><br>  In the article we will describe the classes corresponding to the implementations in the Shared Source CLI (SSCLI). <br><br>  The table in Figure 1 will help in the study of megabytes of code in SSCLI while searching for the necessary structures. <br><br><div class="spoiler">  <b class="spoiler_title">Figure 1 SSCLI References</b> <div class="spoiler_text"><table><tbody><tr><th>  Component </th><th>  SSCLI Way </th></tr><tr><td>  AppDomain </td><td>  /sscli/clr/src/vm/appdomain.hpp </td></tr><tr><td>  AppDomainStringLiteralMap </td><td>  /sscli/clr/src/vm/stringliteralmap.h </td></tr><tr><td>  BaseDomain </td><td>  /sscli/clr/src/vm/appdomain.hpp </td></tr><tr><td>  Classloader </td><td>  /sscli/clr/src/vm/clsload.hpp </td></tr><tr><td>  EEClass </td><td>  /sscli/clr/src/vm/class.h </td></tr><tr><td>  FieldDescs </td><td>  /sscli/clr/src/vm/field.h </td></tr><tr><td>  Gcheap </td><td>  /sscli/clr/src/vm/gc.h </td></tr><tr><td>  GlobalStringLiteralMap </td><td>  /sscli/clr/src/vm/stringliteralmap.h </td></tr><tr><td>  Handletable </td><td>  /sscli/clr/src/vm/handletable.h </td></tr><tr><td>  InterfaceVTableMapMgr </td><td>  /sscli/clr/src/vm/appdomain.hpp </td></tr><tr><td>  Large Object Heap </td><td>  /sscli/clr/src/vm/gc.h </td></tr><tr><td>  LayoutKind </td><td>  /sscli/clr/src/bcl/system/runtime/interopservices/layoutkind.cs </td></tr><tr><td>  Loaderheaps </td><td>  /sscli/clr/src/inc/utilcode.h </td></tr><tr><td>  MethodDescs </td><td>  /sscli/clr/src/vm/method.hpp </td></tr><tr><td>  MethodTables </td><td>  /sscli/clr/src/vm/class.h </td></tr><tr><td>  OBJECTREF </td><td>  /sscli/clr/src/vm/typehandle.h </td></tr><tr><td>  Securitycontext </td><td>  /sscli/clr/src/vm/security.h </td></tr><tr><td>  Security descriptor </td><td>  /sscli/clr/src/vm/security.h </td></tr><tr><td>  SharedDomain </td><td>  /sscli/clr/src/vm/appdomain.hpp </td></tr><tr><td>  StructLayoutAttribute </td><td>  /sscli/clr/src/bcl/system/runtime/interopservices/attributes.cs </td></tr><tr><td>  SyncTableEntry </td><td>  /sscli/clr/src/vm/syncblk.h </td></tr><tr><td>  System namespace </td><td>  / sscli / clr / src / bcl / system </td></tr><tr><td>  Systemdomain </td><td>  /sscli/clr/src/vm/appdomain.hpp </td></tr><tr><td>  Typehandle </td><td>  /sscli/clr/src/vm/typehandle.h </td></tr></tbody></table><br></div></div><br>  The moment you should pay attention to before we go further is that the information provided in this article is valid only for the .NET Framework 1.1 (it also basically corresponds to the Shared Source CLI 1.0, taking into account a number of notable exceptions present in various interaction scenarios) performance on x86 platform.  The information has been changed in the next versions of the .NET Framework, so please do not build your applications with absolute references to these internal structures. <br><br><h2>  CLR-created domains </h2><br>  Before you run the first line of managed code, three application domains are created.  Two of them are not available in managed code and are not even visible to the CLR host.  They can only be created when booting the CLR with the mscoree.dll and mscorwks.dll bus (or mscorsvr.dll for multiprocessor systems).  As you can see in Figure 2, this is a system domain and a shared (shared) domain, they can only exist in one instance.  The third domain is the default, only an instance of this application domain has a name.  For a simple CLR host, such as a console application, the default application domain name contains the name of the executable image.  Additional domains can be created from managed code using the AppDomain.CreateDomain method or from an unmanaged code host using the ICORRuntimeHost interface. <br><br>  Complex hosts, such as ASP.NET, create the required number of domains, according to the number of applications running in the serviced Web site. <br><br><img src="https://habrastorage.org/files/82c/e6e/b1d/82ce6eb1d4874fd2a092751fd4f0b739.gif"><br>  <i>Figure 2. Domains created by the CLR loader</i> <br><br><h2>  System domain </h2><br>  The system domain creates and initializes the shared domain (SharedDomain) and the default domain (Default).  It also loads the system library mscorlib.dll in the domain shared. <br><br>  The system domain also contains string constants that are available internally, interned explicitly or not explicitly. <br><br>  String interning is optimization functionality, a bit totalitarian in the .NET Framework 1.1 environment, since the CLR does not allow assemblies to optimize this function.  In this case, the memory is used to store only one instance of the string for all string literals in all application domains. <br><br>  The system domain also serves to generate interface identifiers within the process boundaries, which are used when creating an Interface Map (InterfaceVtableMaps) in each application domain (AppDomain). <br><br>  The system domain tracks all domains in the process and provides the functionality of loading and unloading application domains. <br><br><h2>  SharedDomain Domain </h2><br>  The entire domain-neutral code is loaded into the shared domain.  Mscorlib, the system library, is required for user code in all application domains (AppDomains).  This library is automatically uploaded to the public domain.  Base types from the System namespace, such as Object, ValueType, Array, Enum, String, and Delegate, are preloaded into this domain during the CLR boot process.  The user code can also be loaded into this domain by setting the LoaderOptimization attributes by the CLR host during a CorBindToRuntimeEx call.  The console application can load the code into the public domain by adding the System.LoaderOptimizationAttribute attribute to the Main method of the application.  The shared domain also manages an assembly map indexed relative to the base address, the map acts as a table reference for managing the general dependencies of assemblies loaded into the default domain and other application domains created in managed code.  The default domain serves only to load a private user code, which should not be available to other applications. <br><br><h2>  Default Domain </h2><br>  The default domain is an instance of the application domain, where application code is usually executed.  While some applications require additional application domains to be created at runtime (such that they have plug-in architecture or applications that generate a significant amount of code at runtime), most applications create one domain at runtime.  All code executed in this domain is contextually limited at the domain level.  If an application has created multiple application domains, any cross-domain access will occur through the .NET Remoting proxy.  Additional intra-domain boundaries can be created using types inherited from System.ContextBoundObject. <br><br>  Each application domain has its own SecurityDescriptor, SecurityContext and DefaultContext, as well as its own heap loader (High-Frequency Heap, Low-Frequency Heap, and Stub Heap), <br>  Descriptor Tables (Handle Table, Large Object Heap Handle Table), Vtable Integration Card Manager, and Assembly Cache. <br><br><h2>  Heap loader </h2><br>  Loader headers (LoaderHeaps) are designed to load various CLR runtime artifacts and optimization artifacts that exist throughout the life of the domain.  These heaps are incremented by predictable fragments to minimize fragmentation.  Loader heaps are different from garbage collector heaps (GC) (or heap sets in the case of SMP symmetric multiprocessors) in that the garbage collector heap contains instances of objects, and the loader heaps contain system types.  Frequently requested structures, such as method tables, method descriptors (MethodDescs), field descriptors (FieldDescs), and an interface map, are located on a heap of frequent access (HighFrequencyHeap).  Structures to which calls are more rare, such as EEClass and class loader (ClassLoader), as well as their service tables, are located on a heap with a low frequency of calls (LowFrequencyHeap).  The service heap (StubHeap) contains blocks that provide support for access security in the code access security (CAS) code, COM call shell, and P / Invoke calls.  Having reviewed the domains and heaps of high-level loaders, we now take a closer look at their physical organization in the context of a simple application in Figure 3. Stop the program at ‚Äúmc.Method1 ();‚Äù and create a domain dump using the SOS debugger advanced command.  Below is the result: <br><br><pre><code class="hljs pgsql">!DumpDomain <span class="hljs-keyword"><span class="hljs-keyword">System</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Domain</span></span>: <span class="hljs-number"><span class="hljs-number">793e9</span></span>d58, LowFrequencyHeap: <span class="hljs-number"><span class="hljs-number">793e9</span></span>dbc, HighFrequencyHeap: <span class="hljs-number"><span class="hljs-number">793e9</span></span>e14, StubHeap: <span class="hljs-number"><span class="hljs-number">793e9</span></span>e6c, Assembly: <span class="hljs-number"><span class="hljs-number">0015</span></span>aa68 [mscorlib], ClassLoader: <span class="hljs-number"><span class="hljs-number">0015</span></span>ab40 &lt;/br&gt; Shared <span class="hljs-keyword"><span class="hljs-keyword">Domain</span></span>: <span class="hljs-number"><span class="hljs-number">793</span></span>eb278, LowFrequencyHeap: <span class="hljs-number"><span class="hljs-number">793</span></span>eb2dc, HighFrequencyHeap: <span class="hljs-number"><span class="hljs-number">793</span></span>eb334, StubHeap: <span class="hljs-number"><span class="hljs-number">793</span></span>eb38c, Assembly: <span class="hljs-number"><span class="hljs-number">0015</span></span>aa68 [mscorlib], ClassLoader: <span class="hljs-number"><span class="hljs-number">0015</span></span>ab40 &lt;/br&gt; <span class="hljs-keyword"><span class="hljs-keyword">Domain</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">149100</span></span>, LowFrequencyHeap: <span class="hljs-number"><span class="hljs-number">00149164</span></span>, HighFrequencyHeap: <span class="hljs-number"><span class="hljs-number">001491</span></span>bc, StubHeap: <span class="hljs-number"><span class="hljs-number">00149214</span></span>, <span class="hljs-type"><span class="hljs-type">Name</span></span>: Sample1.exe, Assembly: <span class="hljs-number"><span class="hljs-number">00164938</span></span> [Sample1], ClassLoader: <span class="hljs-number"><span class="hljs-number">00164</span></span>a78</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Figure 3 Sample1.exe</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">MyInterface1</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">MyInterface2</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method3</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> : <span class="hljs-title"><span class="hljs-title">MyInterface1</span></span>, <span class="hljs-title"><span class="hljs-title">MyInterface2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> str = <span class="hljs-string"><span class="hljs-string">"MyString"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> ui = <span class="hljs-number"><span class="hljs-number">0xAAAAAAAA</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Method1"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Method2"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method3</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Method3"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MyClass mc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass(); MyInterface1 mi1 = mc; MyInterface2 mi2 = mc; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = MyClass.str.Length; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> j = MyClass.ui; mc.Method1(); mi1.Method1(); mi1.Method2(); mi2.Method2(); mi2.Method3(); mc.Method3(); } }</code> </pre><br></div></div><br>  Our console application, Sample1.exe, is loaded into the application domain (AppDomain), which is named ‚ÄúSample1.exe‚Äù.  Mscorlib.dll is loaded into the shared domain (SharedDomain), but also appears in the system domain (SystemDomain), like the kernel system library.  A heap of high-frequency access (HighFrequencyHeap), low-frequency access (LowFrequencyHeap) and a stub-heap (StubHeap) are located in each domain.  The system domain and the shared domain use the same class loader (ClassLoader), while the Default AppDomain uses its own. <br><br>  The result of the command does not display the reserved and used size of the loader heaps.  A bunch of high-frequency access initially reserves 32K and uses 4K. <br><br>  A heap of low-frequency access stub heaps initially reserve 8Kb and occupy 4Kb. <br><br>  Also, the heap of interface cards is not shown (InterfaceVtableMap, hereinafter IVMap) Each domain has an interface card that is created on its own loader heap during the domain initialization phase.  The pile of interface cards (IVMap) reserves 4K and occupies 4K initially.  We will discuss the significance of the interface map when we explore the layout of the type in the following sections. <br><br>  Figure 2 shows the default heap process heap, the runtime compiler heap (JIT Code), the garbage collector heap (GC) for small objects (SOH) and the heap of large objects (LOH) (for objects with a size of 85,000 bytes or more ) to illustrate the semantic difference between them and the loader heaps.  The JIT or runtime compiler generates instructions for the x86 architecture and saves them on the heap for JIT code.  The heap of the garbage collector and the heap of large objects are heaps that are processed by the garbage collector, and managed objects are created on these heaps. <br><br><h2>  Type Basics </h2><br>  Type is a fundamental element of programming in .NET.  In C #, a type can be declared using the following keywords: class, struct, and interface.  Most types are created by the programmer explicitly, however, in special cases of interaction and in scripts of calling remote objects (.NET Remoting), the .NET CLR generates types implicitly.  These generated types include COM and Callable Wrappers runtime wrappers and Transparent Proxies end-to-end proxies. <br><br>  We explore the .NET fundamental types, starting with a stack structure that contains references to an object (as a rule, the stack is one of the places from which an instance of an object begins its existence). <br>  The code in Figure 4 contains a simple program with a console entry point, where a static method is called. <br><br>  Method1 creates an instance of the SmallClass type that contains an array of bytes used to demonstrate how to create an instance of an object on a heap of LOH large objects.  The code is trivial, but will be involved in our discussion. <br><br><div class="spoiler">  <b class="spoiler_title">Figure 4 Large and small objects</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SmallClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] _largeObj; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SmallClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size</span></span></span><span class="hljs-function">)</span></span> { _largeObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; _largeObj[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xAA</span></span>; _largeObj[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xBB</span></span>; _largeObj[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0xCC</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] LargeObj { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._largeObj; } } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleProgram</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { SmallClass smallObj = SimpleProgram.Create(<span class="hljs-number"><span class="hljs-number">84930</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SmallClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size5</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> objSize = size1 + size2 + size3 + size4 + size5; SmallClass smallObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SmallClass(objSize); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> smallObj; } }</code> </pre><br></div></div><br><br>  Figure 5 shows a snapshot of a typical fastcall call stack stopped at a breakpoint on the line ‚Äúreturn smallObj;‚Äù in the Create method.  (Fastcall is a .NET call convention that defines that arguments are passed to functions in registers, when possible, with the remaining arguments passed through the stack from right to left and then retrieved from the stack by the called function <br>  The local variable of a meaningful type or objSize value type is placed directly on the stack.  Variables of the reference type, such as smallObj, are stored with a fixed occupied size (4-bit double word DWORD) on the stack and contain the address of the instances of objects placed in the regular garbage collector heap. <br><br>  In traditional C ++, this is a pointer to an object;  in the controlled programming world, this is a reference or object reference.  However, it contains the address of the object instance.  We will use the term object instance (ObjectInstance) for the data structure located at the address specified in the object reference. <br><br><img src="https://habrastorage.org/files/062/89f/afb/06289fafb4674741a53ce9b047df516f.gif"><br>  <i>Figure 5. SimpleProgram stack and heap</i> <br><br>  An instance of the smallObj object on the regular garbage collector heap contains a Byte [] pointing to _largeObj, whose size is 85,000 bytes (note that the figure shows 85,016 bytes, which is the actual size of the occupied area).  The CLR handles objects larger than or equal to 85,000 bytes differently, unlike smaller objects.  Large objects are located in a heap of large objects (LOH), while small objects are created in the usual heap of garbage collection, which optimizes the placement of objects and garbage collection.  The LOH does not shrink, and the regular heap is compressed with each garbage collection.  Moreover, LOH is cleared only with complete garbage collection. <br><br>  An instance of smallObj contains a type handle pointing to the method table (MethodTable) of the corresponding type.  There will be one method table for each declared one and all instances of objects of the same type will point to the same method table.  The descriptor will also contain information about the type of type (interface, abstract class, specific class, COM wrapper, proxy), the number of implemented interfaces, the interface map for the distribution of methods, the number of slots in the method table, and a table of slots pointing to the implementation. <br><br>  One important data structure points to the EEClass.  The CLR class loader creates an EEClass from the metadata before the method table is formed.  In Figure 4, the SmallClass method table points to its EEClass.  These structures indicate their modules and assemblies.  The method table and EEClass are usually located in the domain-specific loader heaps.  Byte [] is a special case;  The method table and the EEClass are located in the public domain loader heaps.  Loader heaps refer to a specific domain (domain-specific) and any data structures mentioned earlier, once loaded, will not disappear until the domain is unloaded.  Also, the default domain cannot be unloaded and therefore the code exists until the CLR is stopped. <br><br><h2>  Object instance </h2><br>  As we noted, all instances of value types are either embedded in the thread stack or embedded in the garbage collector heap.  All reference types are created on a heap of a garbage collector or heap of large objects (LOH).  Figure 6 shows a typical object instance layout.  An object can be referenced by a local variable created on the stack, descriptor tables in external interaction situations and P / Invoke scripts, from registers (this can be this-specify and method arguments during the method execution) or from the finalizer queue for objects having final methods (finalizer methods).  OBJECTREF does not indicate the beginning of an object instance, but points at an offset of 4 bytes (DWORD) from the beginning.  A DWORD is called an object header and contains an index (the synblk number of the sync block starting with one) in the SyncTableEntry table.  Since distribution occurs through the index, the CLR can move the table in memory when increasing the size is necessary.  The SyncTableEntry maintains soft links back to the object, so possession of the sync block can be traced by the CLR.  Soft links allow the garbage collector to clean up when other hard links no longer exist.  SyncTableEntry also stores a pointer to a SyncBlock containing useful information, but less necessary for all instances of the object.  This information includes object locks, its hash code, any conversion data, and a domain index (AppDomainIndex).  For most instances of objects, there will be no space allocated for a sync block (SyncBlock) and the syncblock number will be zero.  This will change when the executing thread stumbles upon the expression lock (obj) or obj.GetHashCode, as shown below: <br><br><pre> <code class="cs hljs">SmallClass obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SmallClass() <span class="hljs-comment"><span class="hljs-comment">// Do some work here lock(obj) { /* Do some synchronized work here */ } obj.GetHashCode();</span></span></code> </pre><br><img src="https://habrastorage.org/files/980/4b9/658/9804b965867d43018dedfcebe7d7a51e.gif"><br>  <i>Figure 6. Object instance representation</i> <br><br>  In this code, smallObj will use zero (no syncblk) as its number in the Syncblk Entry Table.  The lock instruction causes the CLR to create a syncblock entry and write the corresponding number in the header.  Since the lock keyword in C # is expanded into a try-catch block using the Monitor class, a Monitor object is created in SyncBlock for synchronization.  Calling the GetHashCode () method fills the Hashcode field with the object hash code in SyncBlock. <br><br>  SyncBlock contains other fields used in the interaction with COM and marshaling delegates to unmanaged code, but not related to the typical use of objects. <br><br>  The type handler (TypeHandle) follows the syncblk number in the object instance.  In order to maintain continuity of reasoning, I will discuss the type handler after clarifying instances of variables.  A variable list of instance fields follows the type handle.  By default, the instance fields are arranged in such a way that the memory usage is efficient and the gaps in the alignment are minimal.  The code in Figure 7 contains a simple class SimpleClass having a set of instance variables contained in it, with different sizes. <br><br><div class="spoiler">  <b class="spoiler_title">Figure 7 SimpleClass with Instance Variables</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> b1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 byte private byte b2 = 2; // 1 byte private byte b3 = 3; // 1 byte private byte b4 = 4; // 1 byte private char c1 = 'A'; // 2 bytes private char c2 = 'B'; // 2 bytes private short s1 = 11; // 2 bytes private short s2 = 12; // 2 bytes private int i1 = 21; // 4 bytes private long l1 = 31; // 8 bytes private string str = "MyString"; // 4 bytes (only OBJECTREF) //Total instance variable size = 28 bytes static void Main() { SimpleClass simpleObj = new SimpleClass(); return; } }</span></span></code> </pre><br></div></div><br>  Figure 8 contains an example instance of a SimpleClass object displayed in the memory window of the Visual Studio debugger.  We set a breakpoint on the return statement, Figure 7, and used the address simpleObj contained in the ECX register to display an instance of the object in the memory browser.  The first 4-byte block is the syncblk number.  We do not use an instance in any code requiring synchronization (and do not use the HashCode method), therefore this field is set to 0. The object reference is stored in the stack variable, indicates 4 bytes located at offset 4. Byte variables b1, b2, b3 and b4 lie side by side.  Byte variables b1, b2, b3, and b4 are all placed in a row, next to each other.  Both variables of type short s1 and s2 are also placed side by side.  The string variable str is a 4-byte ODJECTREF indicating the current instance of the string located in the garbage collector heap.  A string (String) is a special type, all instances containing the same text will point to the same instance in the global string table ‚Äî this is done during the assembly loading process.  This process is called string interning and is designed to optimize memory usage.  As we noted earlier in the .NET Framework 1.1, the assembly cannot disable the process of internment; perhaps in future versions of the CLR runtime, this feature will be provided. <br><br><img src="https://habrastorage.org/files/1d7/957/96e/1d795796eac44a31b19273d8a1d83890.gif"><br>  <i>Figure 8. Debug window displaying an instance of an object in memory</i> <br><br>  Thus, the lexical sequence of variable members in the source code is not supported in the default memory.  In external interaction scenarios, where the lexical sequence is to be transferred to memory, the StructLayoutAttribute attribute can be used, which takes the value of the LayoutKind enumeration as an argument.  LayoutKind.Sequential will provide the lexical sequence for marshalized data.  In the .NET Framework, this will not affect the managed layout (in the .NET Framework 2.0, the use of the attribute will have an effect).  In external interaction scenarios where you actually need to have additional offset and explicit control over the sequence of fields, LayoutKind.Explicit can be used in conjunction with the FieldOffset attribute at the field level.  Looking at the immediate contents of the memory, let's use the SOS debugger to view the contents of the object instance.  One useful command is DumpHeap, which allows you to output all the contents of the heap and all instances of a particular type.  Instead of using registers, DumpHeap can show the address of the object we just created: <br><br><pre> <code class="hljs pgsql">!DumpHeap -<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> SimpleClass Loaded Son <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Strike data <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "C:/WINDOWS/Microsoft.NET/Framework/v1.1.4322/mscorwks.dll" Address MT Size <span class="hljs-number"><span class="hljs-number">00</span></span>a8197c <span class="hljs-number"><span class="hljs-number">00955124</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> Last good <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: <span class="hljs-number"><span class="hljs-number">00</span></span>a819a0 total <span class="hljs-number"><span class="hljs-number">1</span></span> objects <span class="hljs-keyword"><span class="hljs-keyword">Statistics</span></span>: MT Count TotalSize <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> <span class="hljs-number"><span class="hljs-number">955124</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> SimpleClass</code> </pre><br>  The total size of the object is 36 bytes.  It does not matter how long the string is, the SimpleClass instances contain only the DWORD OBJECTREF.  SimpleClass instance variables take up only 28 bytes.  The remaining 8 bytes include a TypeHandle type handler (4 bytes) and a syncblk sync block number (4 bytes).  After receiving the simpleObj instance address, let's dump the contents of this instance using the DumpObj command, as shown here: <br><br><pre> <code class="hljs pgsql">!DumpObj <span class="hljs-number"><span class="hljs-number">0x00a8197c</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span>: SimpleClass MethodTable <span class="hljs-number"><span class="hljs-number">0x00955124</span></span> EEClass <span class="hljs-number"><span class="hljs-number">0x02ca33b0</span></span> Size <span class="hljs-number"><span class="hljs-number">36</span></span>(<span class="hljs-number"><span class="hljs-number">0x24</span></span>) bytes FieldDesc*: <span class="hljs-number"><span class="hljs-number">00955064</span></span> MT Field <span class="hljs-keyword"><span class="hljs-keyword">Offset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Attr <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> <span class="hljs-number"><span class="hljs-number">00955124</span></span> <span class="hljs-number"><span class="hljs-number">400000</span></span>a <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Int64 instance <span class="hljs-number"><span class="hljs-number">31</span></span> l1 <span class="hljs-number"><span class="hljs-number">00955124</span></span> <span class="hljs-number"><span class="hljs-number">400000</span></span>b c <span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> instance <span class="hljs-number"><span class="hljs-number">00</span></span>a819a0 str &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> fields omitted <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the display <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> brevity &gt;&gt; <span class="hljs-number"><span class="hljs-number">00955124</span></span> <span class="hljs-number"><span class="hljs-number">4000003</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>e <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Byte instance <span class="hljs-number"><span class="hljs-number">3</span></span> b3 <span class="hljs-number"><span class="hljs-number">00955124</span></span> <span class="hljs-number"><span class="hljs-number">4000004</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>f <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Byte instance <span class="hljs-number"><span class="hljs-number">4</span></span> b4</code> </pre><br>  As noted, the default layout generated by the C # compiler for classes is LayoutType.Auto (for structures, LayoutType.Sequential is used);  thus, the class loader reorders the instance fields to minimize offsets.  We can use ObjSize to get the graph including the space occupied by the instance, str.  Here is the conclusion: <br><br>  ! ObjSize 0x00a8197c <br>  sizeof (00a8197c) = 72 (0x48) bytes (SimpleClass) <br><br>  Son of strike <br>  The SOS debug extension used to display the contents of the CLR data structures in this article.  This is part of the .NET Framework installation package and is located at% windir% \ Microsoft .NET \ Framework \ v1.1.4322.  Before loading SOS into the process, turn on controlled debugging in project properties in Visual Studio .NET.  Add the directory where SOS.dll is located in the PATH environment variable.  To boot SOS when stopping at a breakpoint, open Debug |  Windows |  Immediate.  In the immediate window, run .load sos.dll.  Use! Help to get a list of debugger commands.  For more information on SOS, see the msdn <a href="http://msdn2.microsoft.com/en-us/magazine/cc188721.aspx">Bugslayer column</a> documentation. <br><br>  If you subtract the size of the SimpleClass instance (36 bytes) from the entire size of the object graph (72 bytes), you will get the size of str, which is 36 bytes.  Let's check it out by removing the str instance dump.  Below is the output of the command: <br><br><pre> <code class="hljs pgsql">!DumpObj <span class="hljs-number"><span class="hljs-number">0x00a819a0</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.String MethodTable <span class="hljs-number"><span class="hljs-number">0x009742d8</span></span> EEClass <span class="hljs-number"><span class="hljs-number">0x02c4c6c4</span></span> Size <span class="hljs-number"><span class="hljs-number">36</span></span>(<span class="hljs-number"><span class="hljs-number">0x24</span></span>) bytes</code> </pre><br>  If you add the instance size of the string str (36 bytes) to the instance size of the SimpleClass (36 bytes), you get a total size of 72 bytes, which corresponds to the output of the ObjSize command.  Note that ObjSize will not include memory used by the syncblk infrastructure.  Also, in the .NET Framework 1.1, the CLR is not aware of the memory occupied by any unmanaged resources, such as GDI objects, COM objects, file handlers, and so on;  therefore, they will not be reflected by this command. <br>  A type handler (TypeHandle), a pointer to the method table (MethodTable), is located right after the syncblk number.  Before instantiating an object, the CLR looks at the loaded types and loads type information if the type is not found, gets the address of the method table, creates an object instance, and writes the value to the TypeHandle of the object instance.  JIT compiled code by the compiler uses a TypeHandle type handler to find the MethodTable method table for distributing methods.  The code compiled by the JIT compiler uses a type handler (TypeHandle) to position the method table (MethodTable) to distribute method calls.  The CLR uses the type handler (TypeHandle) when you need to find the loaded type through the MethodTable method table. <br><br><h2>  MethodTable Method Table </h2><br>  Each class and interface, when uploaded to the application domain, will be represented in memory by the MethodTable data structure.  This is the result of actions to load classes before creating the very first instance of an object.  While an instance of an ObjectInstance object stores a state, MethodTable stores behavior information.  MethodTable associates an object instance with in-memory metadata structures generated by the language compiler using the EEClass.  Information in the MethodTable method table and the data structures attached to it can be accessed from managed code via System.Type. A pointer to the method table can also be obtained even in managed code through the Type.RuntimeTypeHandle property.  A typeler handler contained in ObjectInstance indicates an offset from the beginning of the method table.  This offset is 12 bytes by default and contains information for the garbage collector, which will not be discussed here. <br><br>  Figure 9 shows a typical representation of a method table.  We will show some important henler type fields, but use a drawing for a more complete list.  Let's start with Base Instance Size, since it has a direct correlation with the runtime memory profile. <br><br><img src="https://habrastorage.org/files/a01/9aa/680/a019aa6803c2451084ab6ff1b75fb46c.gif"><br>  <i>Figure 9 Representation of the method table</i> <br><br><h2>  Base instance size Base Instance Size </h2><br>  The base size of an instance is the size of an object, calculated by the class loader, based on the field declarations in the code.  As discussed earlier, the current implementation of the garbage collector requires an object instance size of at least 12 bytes.  If the class does not have a single declared instance field, this will result in 4 bytes redundancy. <br><br>  The remaining 8 bytes will be occupied by the header (Object Header) (which may contain the syncblk block number) and the type handler (TypeHandle).  Again, the size of the object may be affected by the StructLayoutAttribute. <br><br>     (   Visual Studio .NET 2003 )    MyClass   3 (MyClass   )        SOS .   9,     4-      12 (0x0000000C) .    DumpHeap  SOS: <br><br><pre> <code class="hljs pgsql">!DumpHeap -<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyClass Address MT Size <span class="hljs-number"><span class="hljs-number">00</span></span>a819ac <span class="hljs-number"><span class="hljs-number">009552</span></span>a0 <span class="hljs-number"><span class="hljs-number">12</span></span> total <span class="hljs-number"><span class="hljs-number">1</span></span> objects <span class="hljs-keyword"><span class="hljs-keyword">Statistics</span></span>: MT Count TotalSize <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> <span class="hljs-number"><span class="hljs-number">9552</span></span>a0 <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> MyClass</code> </pre><br><h2>    </h2><br>            (MethodDesc),   .              :   ,   ,  ,  .       ,        .       ,     ,        .              vtable. ,        .MyClass    ,   (.cctor)    (.ctor).      C#        .            .  10      MyClass.   10        Method2  IVMap,    .  11   SOS     MyClass. <br><br><img src="https://habrastorage.org/files/348/b1c/82a/348b1c82a104447483392637b7fe96d9.gif"><br> <i> 10    MyClass</i> <br><br><div class="spoiler"> <b class="spoiler_title"> 11 SOS     MyClass</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">!DumpMT -MD <span class="hljs-number"><span class="hljs-number">0x9552a0</span></span> Entry MethodDesc <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> <span class="hljs-number"><span class="hljs-number">0097203</span></span>b <span class="hljs-number"><span class="hljs-number">00972040</span></span> String <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.ToString() <span class="hljs-number"><span class="hljs-number">009720</span></span>fb <span class="hljs-number"><span class="hljs-number">00972100</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.Equals(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>) <span class="hljs-number"><span class="hljs-number">00972113</span></span> <span class="hljs-number"><span class="hljs-number">00972118</span></span> I4 <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.GetHashCode() <span class="hljs-number"><span class="hljs-number">0097207</span></span>b <span class="hljs-number"><span class="hljs-number">00972080</span></span> <span class="hljs-type"><span class="hljs-type">Void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.Finalize() <span class="hljs-number"><span class="hljs-number">00955253</span></span> <span class="hljs-number"><span class="hljs-number">00955258</span></span> <span class="hljs-type"><span class="hljs-type">Void</span></span> MyClass.Method1() <span class="hljs-number"><span class="hljs-number">00955263</span></span> <span class="hljs-number"><span class="hljs-number">00955268</span></span> <span class="hljs-type"><span class="hljs-type">Void</span></span> MyClass.Method2() <span class="hljs-number"><span class="hljs-number">00955263</span></span> <span class="hljs-number"><span class="hljs-number">00955268</span></span> <span class="hljs-type"><span class="hljs-type">Void</span></span> MyClass.Method2() <span class="hljs-number"><span class="hljs-number">00955273</span></span> <span class="hljs-number"><span class="hljs-number">00955278</span></span> <span class="hljs-type"><span class="hljs-type">Void</span></span> MyClass.Method3() <span class="hljs-number"><span class="hljs-number">00955283</span></span> <span class="hljs-number"><span class="hljs-number">00955288</span></span> <span class="hljs-type"><span class="hljs-type">Void</span></span> MyClass..cctor() <span class="hljs-number"><span class="hljs-number">00955293</span></span> <span class="hljs-number"><span class="hljs-number">00955298</span></span> <span class="hljs-type"><span class="hljs-type">Void</span></span> MyClass..ctor()</code> </pre><br></div></div><br>  4      ToString, Equals, GetHashCode  Finalize.      System.Object.  Method2  ,          .   .cctor  .ctor        . <br><br><h2>   </h2><br>   (MethodDesc)        CLR.     ,        ,     .      ,   MethodDesc        3. MethodDesc             (IL).    MethodDesc   PreJitStub,     JIT .  12   .               MethodDesc.        5-    MethodDesc    8-  ,   .  5       PreJitStub.  5-        DumpMT ( MyClass   11) of SOS,  MethodDesc  5         .       JIT .    5           JIT     x86. <br><br><img src="https://habrastorage.org/files/5fb/cf3/975/5fbcf39758bc4d68afe5106e9b900fb1.gif"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 12 The method descriptor</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disassembling the code pointed to by the entry in the method slot table in Figure 12 will show the call to PreJitStub. </font><font style="vertical-align: inherit;">Here is the abbreviated disassembly output before JIT compilation for Method2 method:</font></font><br><br><pre> <code class="hljs pgsql">!u <span class="hljs-number"><span class="hljs-number">0x00955263</span></span> Unmanaged code <span class="hljs-number"><span class="hljs-number">00955263</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-number"><span class="hljs-number">003</span></span>C3538 ;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the jitted Method2() <span class="hljs-number"><span class="hljs-number">00955268</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> eax,<span class="hljs-number"><span class="hljs-number">68040000</span></span>h ;ignore this <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> the rest ;<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> !u thinks it <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> code</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now let's run the method and disassemble the same address: </font></font><br><br><pre> <code class="hljs pgsql">!u <span class="hljs-number"><span class="hljs-number">0x00955263</span></span> Unmanaged code <span class="hljs-number"><span class="hljs-number">00955263</span></span> jmp <span class="hljs-number"><span class="hljs-number">02</span></span>C633E8 ;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the jitted Method2() <span class="hljs-number"><span class="hljs-number">00955268</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> eax,<span class="hljs-number"><span class="hljs-number">0E8040000</span></span>h ;ignore this <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> the rest ;<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> !u thinks it <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> code</code> </pre><br>   5      ;     Method2  .  ¬ª!u"        ,        5-  . <br><br> CodeOrIL  JIT     (RVA)      (IL).          . CLR      JIT ‚Äì     .           MethodDesc   DumpMT    JIT : <br><br><pre> <code class="hljs pgsql">!DumpMD <span class="hljs-number"><span class="hljs-number">0x00955268</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> : [<span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span>] [hasThis] <span class="hljs-type"><span class="hljs-type">Void</span></span> MyClass.Method2() MethodTable <span class="hljs-number"><span class="hljs-number">9552</span></span>a0 Module: <span class="hljs-number"><span class="hljs-number">164008</span></span> mdToken: <span class="hljs-number"><span class="hljs-number">06000006</span></span> Flags : <span class="hljs-number"><span class="hljs-number">400</span></span> IL RVA : <span class="hljs-number"><span class="hljs-number">00002068</span></span></code> </pre><br>  , MethodDesc   : <br><br><pre> <code class="hljs pgsql">!DumpMD <span class="hljs-number"><span class="hljs-number">0x00955268</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> : [<span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span>] [hasThis] <span class="hljs-type"><span class="hljs-type">Void</span></span> MyClass.Method2() MethodTable <span class="hljs-number"><span class="hljs-number">9552</span></span>a0 Module: <span class="hljs-number"><span class="hljs-number">164008</span></span> mdToken: <span class="hljs-number"><span class="hljs-number">06000006</span></span> Flags : <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> VA : <span class="hljs-number"><span class="hljs-number">02</span></span>c633e8</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The flag field in the method descriptor is encoded to store information about the type of method, such as static, instance, interface method, or COM implementation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at another complex aspect of the method table: interface implementation. </font><font style="vertical-align: inherit;">It is designed to look simply at a manageable environment, understanding all the complexities in the presentation process. </font><font style="vertical-align: inherit;">Next, we consider how the interfaces are located and how the distribution of interface methods actually works.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IVMap and Interfaces Map </font></font></h2><br>   12      , IVMap.     9, IVMap       ,        .        IVMap.  MyInterface1   ,       IVMap.             (MethodTable) MyClass,     9.         . IVMap          .            .     ,  IVMap    .    28    (Interface Map )    InterfaceInfo    .   ,           MyClass.  4    InterfaceInfo     (TypeHandle)  MyInterface1 (  9   10).   (2 )   ( 0      1    ).        ,          .  MyInterface1   4,     5  6   .   MyInterface2,   6,    7  8   .          ,       ,        .   MyClass  MyInterface1.Method2   MyInterface2.Method2        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The distribution of the interface method is done through IVMap, while the distribution of direct methods occurs via the Address MethodDesc stored in the corresponding slot. As noted earlier, the .NET Framework uses the fastcall call convention. The first two arguments are usually passed through the ECX and EDX registers, if possible. The first argument of the instance method is always "this" pointer, which is passed through the ECX register, as shown by the instruction "mov ecx, esi":</font></font><br><br><pre> <code class="hljs pgsql">mi1.Method1(); mov ecx,edi ;<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> "this" pointer <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ecx mov eax,dword ptr [ecx] ;<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> "TypeHandle" <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> eax mov eax,dword ptr [eax+<span class="hljs-number"><span class="hljs-number">0</span></span>Ch] ;<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> IVMap address <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> eax at <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> mov eax,dword ptr [eax+<span class="hljs-number"><span class="hljs-number">30</span></span>h] ;<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> the ifc impl <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> slot <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> eax <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> dword ptr [eax] ;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span> Method1 mc.Method1(); mov ecx,esi ;<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> "this" pointer <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ecx cmp dword ptr [ecx],ecx ;compare <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> flags <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> dword ptr ds:[<span class="hljs-number"><span class="hljs-number">009552</span></span>D8h];directly <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> Method1</code> </pre><br>          MyClass   . JIT        .       IVMap     ,   .        IVMap,            . ,             .   2, ¬´mi1 = mc;¬ª      OBJECTREF  mc  mi1. <br><br><h2>   </h2><br>                .        MyClass.Method3   3: <br><br><pre> <code class="hljs pgsql">mc.Method3(); Mov ecx,esi ;<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> "this" pointer <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ecx Mov eax,dword ptr [ecx] ;acquire the MethodTable address <span class="hljs-keyword"><span class="hljs-keyword">Call</span></span> dword ptr [eax+<span class="hljs-number"><span class="hljs-number">44</span></span>h] ;dispatch <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> at <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-number"><span class="hljs-number">0x44</span></span></code> </pre><br>        ,             ().     ,         .  ,           .         8     (    10)       DumpMT. <br><br><h2>   </h2><br>         .            .     ,       ,         OBJECTREF    . OBJECTREF          .  , OBJECTREF          ,      .   9,    str,   OBJECTREF   ,    MyString    . <br><br><h2> EEClass </h2><br> EEClass             CLR   .   , EEClass         (    )      .        ,        EEClass.    (  ,   )  JIT     EEClass,       (   vtable    )    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each type of application uploaded to the domain, one EEClass will be created. This includes interfaces, classes, abstract classes, arrays, and structures. Each EEClass is a tree node tracked by the execution engine. The CLR uses this network to navigate through EEClass structures for such purposes as class loading, method table building, type checking and type casting. The relationship of the child to the parent between the EEClass is established on the basis of the inheritance hierarchy, in turn, the relationship of the parent to the child is established based on the combination of the inheritance hierarchy and the class loading sequence. New EEClass nodes are added, relationships between nodes are superimposed, and new relationships are established during the execution of managed code. There are also horizontal connections with EEClass twins on the net.EEClass has three fields for managing node relationships between loaded types: ParentClass parent class, SiblingChain twin chain, and ChildrenChain child chain. See Figure 13 for a schematic representation of the EEClass in the context of the MyClass class from Figure 4.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 13 shows only a few fields related to this discussion. Because we missed some fields in the view, we did not show the offset in this figure. EEClass has circular references to the method table. EEClass also points to method descriptor data blocks located in the default application access domain heap. A reference to the list of field descriptor objects located on the process heap provides information on the placement of fields during the construction of the method table. EEClass is located on a heap with a low frequency of access to the application domain, so that the operating system can more efficiently manage memory pages, and as a result, the workspace is reduced. </font></font><br><br><img src="https://habrastorage.org/files/401/329/376/4013293760224f2fa5fa6a4faa16a5e2.gif"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 13 EEClass view</font></font></i> <br><br>  ,    13         MyClass ( 3).         EEClass  SOS.     3       mc.Method1.     EEClass  MyClass   Name2EE: <br><br><pre> <code class="hljs pgsql">!Name2EE C:/Working/test/ClrInternals/Sample1.exe MyClass MethodTable: <span class="hljs-number"><span class="hljs-number">009552</span></span>a0 EEClass: <span class="hljs-number"><span class="hljs-number">02</span></span>ca3508 <span class="hljs-type"><span class="hljs-type">Name</span></span>: MyClass</code> </pre><br>    Name2EE   ,       DumpDomain.     EEClass,      EEClass: <br><br><pre> <code class="hljs pgsql">!DumpClass <span class="hljs-number"><span class="hljs-number">02</span></span>ca3508 <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> : MyClass, mdToken : <span class="hljs-number"><span class="hljs-number">02000004</span></span>, Parent <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> : <span class="hljs-number"><span class="hljs-number">02</span></span>c4c3e4 ClassLoader : <span class="hljs-number"><span class="hljs-number">00163</span></span>ad8, <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Table</span></span> : <span class="hljs-number"><span class="hljs-number">009552</span></span>a0, Vtable Slots : <span class="hljs-number"><span class="hljs-number">8</span></span> Total <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> Slots : a, NumInstanceFields: <span class="hljs-number"><span class="hljs-number">0</span></span>, NumStaticFields: <span class="hljs-number"><span class="hljs-number">2</span></span>,FieldDesc*: <span class="hljs-number"><span class="hljs-number">00955224</span></span> MT Field <span class="hljs-keyword"><span class="hljs-keyword">Offset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Attr <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> <span class="hljs-number"><span class="hljs-number">009552</span></span>a0 <span class="hljs-number"><span class="hljs-number">4000001</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>c <span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> static <span class="hljs-number"><span class="hljs-number">00</span></span>a8198c str <span class="hljs-number"><span class="hljs-number">009552</span></span>a0 <span class="hljs-number"><span class="hljs-number">4000002</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.UInt32 static aaaaaaaa ui</code> </pre><br>  13   DumpClass    .   (mdToken)   MyClass       PE ,     System.Object.   ( 13) ,        Program. <br><br> MyClass    vtable (     ).  ,   Method1 Method2   ,                .  .cctor  .ctor  ,     10(0xA) .        . MyClass    .     . <br><br><h2>  Conclusion </h2><br>          CLR. ,     ,        ,           .           CLR  .NET Framework.   ,          ,     . </div><p>Source: <a href="https://habr.com/ru/post/263935/">https://habr.com/ru/post/263935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263925/index.html">"Mindless" use of fonts</a></li>
<li><a href="../263927/index.html">Xamarin courses in Ciklum Interactive, Dnepropetrovsk</a></li>
<li><a href="../263929/index.html">Digest: VR and AR</a></li>
<li><a href="../263931/index.html">Sampling schemes</a></li>
<li><a href="../263933/index.html">The mini-detective is NOT a system administrator</a></li>
<li><a href="../263939/index.html">How we spent a couple of days working on Perl acceleration</a></li>
<li><a href="../263943/index.html">Channel Status Protocols and Single-Zone OSPF (Part 1)</a></li>
<li><a href="../263945/index.html">The story of one clone</a></li>
<li><a href="../263947/index.html">Visualization of static and dynamic networks on R, part 2</a></li>
<li><a href="../263951/index.html">Accelerated course on notations in the theory of programming languages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>