<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Draw thick lines in WebGL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ready examples 
 The examples are based on the OpenGlobus engine, which in this case is used as a wrapper over pure Javascript WebGL. 

 - Example for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Draw thick lines in WebGL</h1><div class="post__text post__text-html js-mediator-article"><h3>  Ready examples </h3><br>  The examples are based on the OpenGlobus engine, which in this case is used as a wrapper over pure Javascript WebGL. <br><br>  - <a href="http://openglobus.org/sandbox/polyline2d/polyline2d.html">Example for 2D case</a> <br>  - <a href="http://openglobus.org/sandbox/polyline3d/polyline3d.html">Example for the 3D case</a> <i>(use the W, S, A, D, Q, E keys and the cursor to move)</i> <br><br><h3>  Introduction </h3><br>  In the process of working on the map library, I needed a tool to draw lines of different thickness.  Of course, WebGL has a line drawing mechanism, but unfortunately you cannot set the line thickness.  Therefore, the lines have to draw polygons, it is better to say triangles. <a name="habracut"></a>  On the Internet you can find several excellent articles, how to ‚Äútriangulate‚Äù the line, what difficulties arise and how to solve them.  Unfortunately, I did not find such an article from which I could copy the code and use it in my shader. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      After many hours spent with a pencil and paper drawing an algorithm, and then many hours of debugging a completely not complicated glsl shader, I finally arrived at a result that could be achieved much faster.  Hopefully, the WebGL polygonal line rendering approach described below will save the time of your life, which otherwise would be spent on the implementation of this task! <br><br><h3>  Drawing a line in two-dimensional space </h3><br>  In my shader engine for drawing lines in two-dimensional and three-dimensional spaces, almost the same code is used.  The only difference is that for the three-dimensional case the projection of the three-dimensional coordinates of the line onto the screen is added, then the same algorithm. <br><br>  There is a common practice to make lines thick - to represent each line segment as a rectangle.  The simplest representation of the thick line looks like this <i>(Fig. 1)</i> : <br><br>  <i>(fig. 1)</i> <i><img src="https://habrastorage.org/getpro/habr/post_images/891/5d1/531/8915d153165b8ef73a1db66cffb9f8e4.png"></i> <br><br>  To get rid of visible segmentation at the nodal points, it is necessary to combine adjacent points of the neighboring segments, so as to maintain the thickness on both parts of the adjacent segments.  To do this, find the intersection of one-sided faces of the line, above and below <i>(Fig. 2)</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/148/bae/beb/148baebebda59e260be6cb9b150e7840.png"><br>  <i>(fig. 2)</i> <br><br>  However, the angle between adjacent segments can be so sharp that the intersection point can go far from the junction point of these lines <i>(Fig. 3)</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/384/9eb/be7/3849ebbe774e30706d4a104ef6cdcd4d.png"><br>  <i>(pic. 3)</i> <br><br>  In this case, this angle must somehow be processed <i>(Fig. 4)</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e4/d50/918/5e4d50918aadb2d2864f5025d90f448c.png"><br>  <i>(pic. 4)</i> <br><br>  I decided to fill such areas with the corresponding triangles.  The GL_LINE_STRING sequence came to my rescue, which, with the correct order, should, if the angle is too acute <i>(the threshold value is checked in the vertex shader),</i> create the effect of a neatly trimmed angle <i>(Fig. 5)</i> , or combine adjacent coordinates of adjacent segments according to the rule of intersection of one-sided faces <i>(Figure 2)</i> , as before. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45a/79e/5ae/45a79e5aedf83e4bec895a22fa64f304.png"><br>  <i>(pic. 5)</i> <br><br>  The numbers near the vertices are the indices of the vertices by which polygons are drawn in the graphics pipeline.  If the angle is obtuse, in this case the triangle for cutting will merge into an infinitely thin line and become invisible <i>(Fig. 6)</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d91/2ed/8cc/d912ed8cccbfd13ad48aebfe796ec4c6.png">  <i>(pic. 6)</i> <br><br><br>  We imagine the sequence in this way <i>(Fig. 7)</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/37f/9d1/9fa/37f9d19fa5b88df17358ea77a0e2cfea.png"><br>  <i>(fig. 7)</i> <br><br>  That's the whole secret.  Now let's see how to render it.  It is necessary to create a vertex buffer, an index buffer and an order buffer, which shows in which direction to thicken from the current vertex of the segment, as well as which part of the segment is currently being processed by the vertex shader, initial or final.  In order to find the intersection of faces, in addition to the coordinates of the current point, we also need to know the previous and next coordinates from it <i>(Fig. 8)</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/551/481/2bb/5514812bb34c3cd4dfae366ae13714f9.png"><br>  <i>(pic. 8)</i> <br><br>  So, for each coordinate in the shader, we should have, in fact, the coordinate itself, the previous and next coordinates, the order of the point, i.e.  whether the point is the beginning, or the end of a segment <i>(I denote -1, 1 is the beginning and -2, 2 is the end of the segment)</i> , how should it be located: above or below the current coordinate, as well as thickness and color. <br><br>  Since  WebGL allows you to use one buffer for different attributes, in the case that the element of this buffer is a coordinate, when you call <i>vertexAttribPointer,</i> each attribute is assigned in bytes the size of the buffer element, and the offset relative to the current attribute element.  This is clearly seen if you draw a sequence on paper <i>(fig. 9)</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f46/5d3/86e/f465d386e0b846791615775dc7725581.png"><br>  <i>(pic 9)</i> <br><br>  The top line is the indices in the array of vertices;  <i><b>8</b></i> - element size ( <i>coordinate type vec2)</i> i.e.  2x4 bytes;  <i><b>Xi, Yi</b></i> - coordinate values ‚Äã‚Äãat points <i><b>A, B, C</b></i> ;  <i><b>Xp = Xa - Xb, Yp = Ya - Yb, Xn = Xc - Xb, Yn = Xc - Xb</b></i>  vertices indicating the direction at the border points.  The color arcs depict a bunch of coordinates <i>(previous, current, and next)</i> for each index in the vertex shader, where <i><b>current</b></i> is the current coordinate of the bunch, <i><b>previous</b></i> is the previous coordinate of the bunch, and <i><b>next</b></i> is the next coordinate of the bunch.  A value of <i><b>32</b></i> bytes is an offset in the buffer in order to identify the current <i>(current)</i> relative to the previous <i>(previous)</i> coordinate values, <i><b>64</b></i> bytes is an offset in the buffer to identify the next <i>(next)</i> value.  Since  Since the index of the next coordinate begins with the previous <i>(previous)</i> value, then for it the offset in the array is zero.  The last line shows the order of each coordinate in the segment, <i><b>1</b></i> and <i><b>-1</b></i> is the beginning of the segment, <i><b>2</b></i> and <i><b>-2</b></i> respectively, the end of the segment. <br><br>  In code, it looks like this: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._verticesBuffer; gl.bindBuffer(gl.ARRAY_BUFFER, vb); gl.vertexAttribPointer(sha.prev._pName, vb.itemSize, gl.FLOAT, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gl.vertexAttribPointer(sha.current._pName, vb.itemSize, gl.FLOAT, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>); gl.vertexAttribPointer(sha.next._pName, vb.itemSize, gl.FLOAT, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>);  gl.bindBuffer(gl.ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ordersBuffer); gl.vertexAttribPointer(sha.order._pName, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ordersBuffer.itemSize, gl.FLOAT, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  This is a function that creates arrays of vertices and orders, where <i><b>pathArr is</b></i> an array of coordinate arrays for which arrays are filled to initialize buffers, <i><b>outVertices</b></i> is an array of coordinates, <i><b>outOrders</b></i> is an array of orders and <i><b>outIndexes</b></i> is an array of indices: <br><br><pre> <code class="javascript hljs">Polyline2d.createLineData = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathArr, outVertices, outOrders, outIndexes</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>;  outIndexes.push(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; pathArr.length; j++ ) {   path = pathArr[j];      <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startIndex = index;      <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> last = [path[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + path[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] - path[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>], path[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + path[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] - path[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]];      outVertices.push(last[<span class="hljs-number"><span class="hljs-number">0</span></span>], last[<span class="hljs-number"><span class="hljs-number">1</span></span>], last[<span class="hljs-number"><span class="hljs-number">0</span></span>], last[<span class="hljs-number"><span class="hljs-number">1</span></span>], last[<span class="hljs-number"><span class="hljs-number">0</span></span>], last[<span class="hljs-number"><span class="hljs-number">1</span></span>], last[<span class="hljs-number"><span class="hljs-number">0</span></span>], last[<span class="hljs-number"><span class="hljs-number">1</span></span>]);      outOrders.push(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     4       for ( var i = 0; i &lt; path.length; i++ ) {       var cur = path[i];          outVertices.push(cur[0], cur[1], cur[0], cur[1], cur[0], cur[1], cur[0], cur[1]);          outOrders.push(1, -1, 2, -2);          outIndexes.push(index++, index++, index++, index++);      }      var first = [path[path.length - 1][0] + path[path.length - 1][0] - path[path.length - 2][0], path[path.length - 1][1] + path[path.length - 1][1] - path[path.length - 2][1]];      outVertices.push(first[0], first[1], first[0], first[1], first[0], first[1], first[0], first[1]);      outOrders.push(1, -1, 2, -2);      outIndexes.push(index - 1, index - 1, index - 1, index - 1);      if ( j &lt; pathArr.length - 1 ) {      index += 8;          outIndexes.push(index, index);      }  } };</span></span></code> </pre><br>  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path = [[[<span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">-50</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>]]]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = [],  orders = [],  indexes = []; Polyline2d.createLineData(path, vertices, orders, indexes);</code> </pre><br>  We get: <br><br>  vertices: [-201, -102, -201, -102, -201, -102, -201, -102, -100, -50, -100, -50, -100, -50, -100, -50 , 1, 2, 1, 2, 1, 2, 1, 2, 200, 15, 200, 15, 200, 15, 200, 15, 399, 28, 399, 28, 399, 28, 399, 28] <br><br>  orders: [1, -1, 2, -2, 1, -1, 2, -2, 1, -1, 2, -2, 1, -1, 2, -2, 1, -1, 2, -2] <br><br>  indexes: [0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 11, 11, 11] <br><br>  Vertex shader: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> vec2 prev; //  <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> vec2 <span class="hljs-keyword"><span class="hljs-keyword">current</span></span>; //  <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> vec2 next; //  <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span>; //             uniform <span class="hljs-type"><span class="hljs-type">float</span></span> thickness; // uniform vec2 viewport; //  //    vec2 proj(vec2 coordinates){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coordinates / viewport; }             <span class="hljs-type"><span class="hljs-type">void</span></span> main() { vec2 _next = next;   vec2 _prev = prev; //   ,       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( prev == <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> ) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( next == <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> ){       _next = <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>);           _prev = <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> - next;       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       _prev = <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> + normalize(<span class="hljs-keyword"><span class="hljs-keyword">current</span></span> - next);       }  }   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( next == <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> ) {    _next = <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> + normalize(<span class="hljs-keyword"><span class="hljs-keyword">current</span></span> - _prev);   }                    vec2 sNext = _next,           sCurrent = <span class="hljs-keyword"><span class="hljs-keyword">current</span></span>,           sPrev = _prev; //   ,        vec2 dirNext = normalize(sNext - sCurrent);   vec2 dirPrev = normalize(sPrev - sCurrent);   <span class="hljs-type"><span class="hljs-type">float</span></span> dotNP = dot(dirNext, dirPrev);  //     vec2 normalNext = normalize(vec2(-dirNext.y, dirNext.x));   vec2 normalPrev = normalize(vec2(dirPrev.y, -dirPrev.x));   <span class="hljs-type"><span class="hljs-type">float</span></span> d = thickness * <span class="hljs-number"><span class="hljs-number">0.5</span></span> * sign(<span class="hljs-keyword"><span class="hljs-keyword">order</span></span>);                    vec2 m; //m -  ,           <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dotNP &gt;= <span class="hljs-number"><span class="hljs-number">0.99991</span></span> ) {   m = sCurrent - normalPrev * d;   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   vec2 dir = normalPrev + normalNext; //        (. <span class="hljs-number"><span class="hljs-number">2</span></span>)       m = sCurrent + dir * d / (dirNext.x * dir.y - dirNext.y * dir.x);      //            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dotNP &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span> &amp;&amp; dot(dirNext + dirPrev, m - sCurrent) &lt; <span class="hljs-number"><span class="hljs-number">0.0</span></span> ) {       <span class="hljs-type"><span class="hljs-type">float</span></span> occw = <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> * sign(dirNext.x * dirPrev.y - dirNext.y * dirPrev.x); //      LINE_STRING           <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( occw == <span class="hljs-number"><span class="hljs-number">-1.0</span></span> ) {           m = sCurrent + normalPrev * d;           } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( occw == <span class="hljs-number"><span class="hljs-number">1.0</span></span> ) {           m = sCurrent + normalNext * d;           } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( occw == <span class="hljs-number"><span class="hljs-number">-2.0</span></span> ) {           m = sCurrent + normalNext * d;           } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( occw == <span class="hljs-number"><span class="hljs-number">2.0</span></span> ) {           m = sCurrent + normalPrev * d;          } // ""  ,              } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( distance(sCurrent, m) &gt; min(distance(sCurrent, sNext), distance(sCurrent, sPrev)) ) {      m = sCurrent + normalNext * d;       }  }   m = proj(m);   gl_Position = vec4(mx, my, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre><br><h3>  A few words in conclusion </h3><br>  This approach is implemented for drawing <a href="http://openglobus.org/examples/Polylines/polylines.html">tracks, orbits</a> , <a href="http://openglobus.org/examples/VectorLayer/vectorLayer.html">vector data</a> . <br><br>  In conclusion, I want to add a few ideas on what can be done with the algorithm in order to improve the quality of the lines.  For example, you can pass a color in the colors attribute for each vertex, then the line will become multicolored.  Also, each vertex can transmit width, then the line will vary in width from point to point, and if we calculate the width at a point <i>(in the vertex shader)</i> relative to the distance from the observation point <i>(for the three-dimensional case)</i> , the effect can be achieved when the part of the line located closer to the point of observation is visually larger than the part of the line that is at a distance.  You can also implement anti-aliasing <i>(antialiasing)</i> by adding two passes for each of the edges of the thick line, in which thin lines are drawn <i>(a frame around the edges)</i> with little transparency relative to the central part. </div><p>Source: <a href="https://habr.com/ru/post/331164/">https://habr.com/ru/post/331164/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331152/index.html">The digest of interesting materials for the mobile developer # 208 (June 13 - June 18)</a></li>
<li><a href="../331154/index.html">Pygest # 11. Releases, articles, interesting projects from the world of Python [June 6, 2017 - June 19, 2017]</a></li>
<li><a href="../331158/index.html">Big data technologies in working with microbiota bacteria. Lecture in Yandex</a></li>
<li><a href="../331160/index.html">PHP user types</a></li>
<li><a href="../331162/index.html">‚ÄúMy most important test is not to break the driver‚Äù - Dave Cramer about developing a JDBC driver for PostgreSQL</a></li>
<li><a href="../331166/index.html">About Qt licenses (and a little about the company)</a></li>
<li><a href="../331168/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ267 (June 12 - 18, 2017)</a></li>
<li><a href="../331170/index.html">How to do static code analysis in Swift</a></li>
<li><a href="../331174/index.html">Fuzzy search by name</a></li>
<li><a href="../331176/index.html">Interactive credit card for payment input</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>