<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple classifier on PyBrain and PyQt4 (Python3)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Studying Python3, I ported (as I could) the PyBrain library. I already wrote about this here . 

 Now I want to play a little with this library. As I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple classifier on PyBrain and PyQt4 (Python3)</h1><div class="post__text post__text-html js-mediator-article">  Studying Python3, I ported (as I could) the PyBrain library.  I already wrote about this <a href="http://habrahabr.ru/post/148597/">here</a> . <br><img src="https://habrastorage.org/storage2/876/89c/c9b/87689cc9b163aa6ef8c555c797f4f398.png" alt="image"><br>  Now I want to play a little with this library.  As I said in the previous post, I just started to learn the python, so everything written in this article should not be taken as the Truth.  Learning is the way, and it is tortuous. <br><br>  The task is set before the artificial neural network (INS) is very simple - the classification, namely, the recognition of letters of the Latin alphabet. <br><br>  It seems to be a classic example, it has already been written about it many times in Habr√©: <a href="http://habrahabr.ru/post/134998/">‚ÄúWhat are artificial neural networks?‚Äù</a> , <a href="http://habrahabr.ru/post/113245/">‚ÄúNeural networks and character recognition‚Äù</a> , <a href="http://habrahabr.ru/search/%3Fq%3D%25D0%25BF%25D0%25B5%25D1%2580%25D1%2581%25D0%25B5%25D0%25BF%25D1%2582%25D1%2580%25D0%25BE%25D0%25BD">etc.</a> <br>  But my goal is to study python on the not so simple examples.  Those.  we learn at once on the complex and unfamiliar.  So we will find twice as many rakes, which will allow us to dig into the depths of the language, dealing with "why does not work?". 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Under habrakat you will find: a description of how to prepare data on <b>PyQt4</b> , the use of the module <b>argparse</b> , and of course <b>PyBrain</b> ! <br><a name="habracut"></a><br><br>  Having read articles here on Habr√© and not only, you understand that it is difficult not to write / create / design an INS, but to prepare for it a set of training and test data.  Therefore, our task is divided into two subtasks: <br><ul><li>  prepare training data; </li><li>  design and train ANN. </li></ul><br>  We will do it in this order.  So to speak on the rise. <br><br><h4>  Data preparation </h4><br><h5>  Technical task </h5><br>  Let's clarify the task: the size of the image with the letter will be, say, 64 by 64 pixels (a total of 4096 entries from the INS). <br>  For this we need to write a generator of these pictures.  And we will write it, naturally, in python. <br>  Training data will include: <br><ul><li>  lowercase latin letters </li><li>  Latin uppercase letters </li><li>  letters can be of different sizes (optional) </li><li>  the style may be different (different fonts may be used) </li></ul><br>  Based on this, we will write a generator, to which the parameters are fed to the input: <br><ul><li>  a list of letters, for example, abc or fx (range) </li><li>  font size for example 40 </li><li>  font used </li><li>  path to the folder where the generated images will be stored </li></ul><br><br><h5>  Search method of working with images </h5><br>  To write a generator, we need information on image processing methods in python.  Google didn't help us much.  I suggested using either the Python Imaging Library - <a href="http://ru.wikipedia.org/wiki/Python_Imaging_Library">PIL for</a> short, or <a href="http://www.pygame.org/docs/ref/font.html">PyGame</a> . <br>  But that's bad luck.  The first is only for python2, and the last release was in 2009.  Although on github.com there is its <a href="https://github.com/gpolo/pil-py3k">fork under the third python</a> .  After reading the manual, I realized that everything is not so simple. <br>  PyGame is a more interesting option, even the manual read it a little longer.  I understood that it was necessary to specifically understand the library, but something could not be done with a swoop.  And using a microscope for nailing is not an option either.  Not for this library is intended. <br>  Googled more.  There is pythonmagick, but it is only for UNIX-like systems.  And then it dawned on me!  <b><a href="http://www.riverbankcomputing.com/static/Docs/PyQt4/html/index.html">PyQt4</a></b> ! <br>  I am quite familiar with Qt4, I wrote a lot in C ++ / Qt.  Yes, this library is like a Swiss knife.  You want to open a bottle of beer, you want to cut a beautiful figure from a piece of wood.  The main thing - to be able to use a knife.  On Qt and stop. <br>  Search in a habr gave us very few information on <a href="http://habrahabr.ru/search/%3Fq%3Dpyqt">PyQt</a> .  Well, nothing - we'll figure it out. <br><br><h5>  We write generation and saving of the image </h5><br>  The first thing to do is install PyQt4.  With this, I hope the reader will cope - I will not dwell on this.  I will go straight to use. <br>  We import the necessary modules, and prepare the ‚Äúfish‚Äù for the program on PyQt4. <br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 import sys from PyQt4.QtGui import * from PyQt4.Qt import * def main(): app = QApplication([]) # some code here if __name__ == "__main__": sys.exit(main())</span></span></code> </pre> <br>  The line with <code>app = QApplication([])</code> very important.  Do not forget it.  Without it, python crashes with SIGFAULT and does not issue any warnings or errors. <br><br>  Now let's do the filling of the "fish" working logic.  Add the save function, which will save the image with the specified parameters. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(png_file, letter = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'A'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, font = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Arial"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, size = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">40</span></span></span></span><span class="hljs-function"><span class="hljs-params">, align = Qt.AlignCenter)</span></span></span><span class="hljs-function">:</span></span> img = QImage(<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">64</span></span>, QImage.Format_RGB32) img.fill(Qt.white) p = QPainter(img) p.setPen(Qt.black) p.setFont(QFont(font,size)) p.drawText(img.rect(), align, letter) p.end() img.save(png_file)</code> </pre><br><br>  With the parameters of the function - everything is clear.  But I will explain the contents. <br>  First, an object of the QImage class is created that allows you to create / process your images in your program.  Very powerful and flexible tool.  The whole image is 64 by 64 pixels in white. <br>  Then an object of type QPainter is created to which the img reference is passed.  This class allows you to draw on the device context or, more precisely, on the outline of any class inherited from QPaintDevice.  And just such a class is a QImage. <br>  Set the black pen, font and draw the letter.  The default size is 40 (which almost occupies the whole field of the image) and is centered. <br>  Well, then save the image to a file.  Everything is simple and obvious. <br><br><h5>  Finishing touches </h5><br>  It remains small.  Parsing command line options. <br>  This can be done in the forehead (with a bunch of if, or by hard-typing the format of the input data), or you can use any advanced modules like getopt or <a href="http://docs.python.org/dev/library/argparse.html">argparse</a> .  Last, I think we will study. <br>  Our program at the entrance will receive the following parameters: font, font size and directory where ready-made pictures will fall down. <br>  Alignment while we leave until better times. <br>  Reading this manual as if tells us that we just need to use this piece of code: <br><pre> <code class="python hljs"> p = argparse.ArgumentParser(description=<span class="hljs-string"><span class="hljs-string">'Symbols image generator'</span></span>) p.add_argument(<span class="hljs-string"><span class="hljs-string">'-f'</span></span>,<span class="hljs-string"><span class="hljs-string">'--font'</span></span>, default=<span class="hljs-string"><span class="hljs-string">'Arial'</span></span>, help=<span class="hljs-string"><span class="hljs-string">'Font name, default=Arial'</span></span>) p.add_argument(<span class="hljs-string"><span class="hljs-string">'-s'</span></span>,<span class="hljs-string"><span class="hljs-string">'--size'</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">40</span></span>, help=<span class="hljs-string"><span class="hljs-string">'Font size, default=40'</span></span>) p.add_argument(<span class="hljs-string"><span class="hljs-string">'-d'</span></span>,<span class="hljs-string"><span class="hljs-string">'--dir'</span></span>, default=<span class="hljs-string"><span class="hljs-string">'.'</span></span>, help=<span class="hljs-string"><span class="hljs-string">'Output directory, default=current'</span></span>) p.add_argument(<span class="hljs-string"><span class="hljs-string">'letters'</span></span>, help=<span class="hljs-string"><span class="hljs-string">'Array of letters(abc) or range (az)'</span></span>) args = p.parse_args()</code> </pre><br>  Thus, we describe our parameters, the <b>argparse</b> module will take care of the rest.  What I liked was the automatic showing of <i>usage</i> and the automatic generation of help for parameters.  Moreover, <b>argparse added</b> one more argument (-h) to our list.  For which he thanks a lot.  As a real and lazy programmer, I really do not like writing help and other documentation.  This is a point in favor of <b>argparse</b> .  I will use it more often. <br>  Help for the program we get this: <br><pre> usage: gen_pic.py [-h] [-f FONT] [-s SIZE] [-d DIR] letters<font></font>
<font></font>
 Symbols image generator<font></font>
<font></font>
 positional arguments:
   letters Array of letters (abc) or range (az)<font></font>
<font></font>
 optional arguments:
   -h, --help show this help message and exit
   -f FONT, --font FONT Font name, default = Arial
   -s SIZE, --size SIZE Font size, default = 40
   -d DIR, --dir DIR Output directory, default = current
</pre><br>  Now we add a check for the existence of the directory path and the expansion of a range of letters.  To do this, we use regular expressions.  They are not particularly needed in this case, but it is necessary to make the program more impressive!  For this, we need the modules <b>os</b> , <b>os.path</b> and <b>re</b> . <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.exists(args.dir): os.mkdir(args.dir) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> re.match(<span class="hljs-string"><span class="hljs-string">'^([az]-[az])|([AZ]-[AZ])$'</span></span>, args.letters): begin = args.letters[<span class="hljs-number"><span class="hljs-number">0</span></span>] end = args.letters[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ord(end)-ord(begin))&gt;<span class="hljs-number"><span class="hljs-number">26</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Error using letters. Only AZ or az available, not Az."</span></span>) p.print_help() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> letters = [chr(a) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(ord(begin),ord(end)+<span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: letters = args.letters</code> </pre><br>  Here you go.  It remains to organize the cycle and transfer all the letters in turn to the drawing. <br><br>  The final touch is to make a binding on top of the save () function and call it saveWrap ().  How original, isn't it?  Actually, it does nothing supernatural, it simply generates a name for the file based on the parameters passed to the save () function. <br><br>  In total, the entire generator took us only 55 lines (the code is given at the end of the article).  Isn't that great? <br>  And I am sure that the python gurus will surely find a lot of optimization possibilities.  But why?  Everything works, the code is quite simple and concise.  Straight eye rejoices. <br><br><h4>  INS development </h4><br><br>  Now we will start work on the ins.  First, <a href="http://habrahabr.ru/post/148407/">let's take a</a> look at the capabilities of <a href="http://habrahabr.ru/post/148407/">PyBrain</a> . <br><div class="spoiler">  <b class="spoiler_title">Lyrical digression about PyBrain and Python3</b> <div class="spoiler_text">  I want to clarify that I tested the program only for Python3 and used the PyBrain port, which you can find <a href="https://github.com/icoz/pybrain">here</a> .  While debugging the program I found a couple of jambs in the very port of the library. <br>  Very pleased comment in the place where the library fell out: <br><pre> # FIXME: the next line keeps arac from producing NaNs.  I don't
 # know why this is the __str__ method of the
 # ndarray class fixes something,
 # str (outerr)
</pre><br>  Apparently this hack in Python3 did not work. <br></div></div><br>  At the entrance we have an image (in shades of gray), given by the brightness values ‚Äã‚Äãof each pixel from 0 to 1. <br>  To begin with, we will make an INS that will recognize a limited set of characters and without different registers.  We will teach on data with one font and see how the network recognizes these characters with a different font (test set).  Take, for example, the characters <em>A, B, C, D, Z.</em> <br><br>  Since our network will learn letters, whose images are <b>64 by 64 pixels in</b> size, the number of entries in our network <b>will be 4096</b> . <br>  We have only 5 recognizable letters, respectively, and the <b>number of exits from the network is five</b> . <br>  Now the question is: do we need hidden layers?  And if so, how much? <br>  I decided to do without hidden layers, so to create a network object I make the following call: <br><pre> <code class="python hljs">net = buildNetwork(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre><br>  To create one hidden layer of 64 neurons in size and the type of hidden layer of SoftmaxLayer, you need to make the following call: <br><pre> <code class="python hljs">net = buildNetwork(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, hiddenclass=SoftmaxLayer)</code> </pre><br>  Unfortunately, the <a href="http://habrahabr.ru/post/148407/">article</a> was told about this function, but no description was given.  I will correct this defect. <br><div class="spoiler">  <b class="spoiler_title">Educational program about buildNetwork ()</b> <div class="spoiler_text">  The buildNetwork () function is designed to quickly create a FeedForward network and has the following format: <br><pre> <code class="python hljs">pybrain.tools.shortcuts.buildNetwork(*layers, **options)</code> </pre><br>  layers - a list or tuple of integers that contains the number of neurons in each layer <br>  Options are written as " <b>name = val</b> " and include: <br>  <b>bias</b> (default = True) - the displacement layer in hidden layers <br>  <b>outputbias</b> (default = True) - the beginning of the offset in the output layer <br>  <b>hiddenclass</b> and <b>outclass</b> - set types for hidden layers and output layer, respectively.  Must be a descendant of the NeuronLayer class.  Predefined values ‚Äã‚Äãare GaussianLayer, LinearLayer, LSTMLayer, MDLSTMLayer, SigmoidLayer, SoftmaxLayer, TanhLayer. <br>  If the <b>recurrent</b> flag is set, the RecurrentNetwork network will be created, otherwise FeedForwardNetwork. <br>  If the <b>fast</b> flag is set, then faster <b>arac</b> networks will be used, otherwise it will be the PyBrain's own implementation of the Python network. <br></div></div><br>  Those who are interested can choose other options by correcting / uncommenting the call to the <em>buildNetwork ()</em> function in the <em>brain.py</em> file. <br><br><h4>  Training ins </h4><br>  So it's time to start learning.  With the help of our program <b>gen_pic.py we</b> generate the necessary letters. <br>  I did it like this: <br><pre> ./gen_pic.py -d ./learn -f FreeMono ABCDZ
 ./gen_pic.py -d ./learn -f Times ABCDZ
 ./gen_pic.py -d ./learn -f Arial ABCDZ
 ./gen_pic.py -d ./test -f DroidMono ABCDZ
 ./gen_pic.py -d ./test -f Sans ABCDZ
</pre><br>  The process of loading data from the image and converting the RGB color to grayscale let me leave it behind the scenes.  There is nothing particularly interesting.  To whom it is still terribly interesting how it is done - it can see itself in the <b>brain.py</b> file in the <em>get_data ()</em> function. <br><br>  The learning itself is done in the <b>init_brain ()</b> function.  The training sample is transferred to this function, the maximum number of epochs for training and optionally the Trainer type, and the function itself returns the object of the already trained network. <br>  Key lines of network creation and training look like this (the full code is provided at the end of the article) <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_brain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(learn_data, epochs, TrainerClass=BackpropTrainer)</span></span></span><span class="hljs-function">:</span></span> ... net = buildNetwork(<span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, hiddenclass=LinearLayer) <span class="hljs-comment"><span class="hljs-comment"># fill dataset with learn data ds = ClassificationDataSet(4096, nb_classes=5, class_labels=['A', 'B', 'C', 'D', 'Z']) for inp, out in learn_data: ds.appendLinked(inp, [trans[out]]) ... ds._convertToOneOfMany(bounds=[0, 1]) ... trainer = TrainerClass(net, verbose=True) trainer.setData(ds) trainer.trainUntilConvergence(maxEpochs=epochs) return net</span></span></code> </pre><br>  Briefly explain that where. <br>  ClassificationDataSet is a special type of dataset for classification purposes.  The source data and the class number of the class (trans [out]) are enough for it to make a sample. <br>  The _convertToOneOfMany () function converts these same class numbers to the values ‚Äã‚Äãof the output layer. <br>  Next, we transfer the network to the ‚Äúteacher‚Äù and say that we are interested in displaying additional information (the library will print intermediate calculations to the console). <br>  We give the teacher a dataset with a training set (setData ()) and start the training (trainUntilConvergence ()), which will train either until the network converges or until the maximum number of learning epochs is released. <br><br><h4>  findings </h4><br>  So, the goal is achieved. <br>  The code is written and works.  The generator, however, can much more than the network we have built today, in its current form.  But there remains an uncultivated field for you, dear% username%!  There is something to fix, where to edit, what to rewrite ... <br><br>  I also add that I have tested two Trainer'a - <b>BackpropTrainer</b> and <b>RPropMinusTrainer</b> . <br>  The speed of the backpropagation algorithm (BackpropTrainer) is poor, converges very slowly.  Because of this, learning takes a lot of time. <br>  <b>By</b> changing one line in <b>brain.py,</b> you can look at the work of <b>RPropMinusTrainer</b> .  It is much faster and shows quite good results. <br>  I will also add that I <b>didn‚Äôt manage to</b> <b>achieve 100% recognition</b> even for a training sample, maybe I had to select the number of layers and the number of neurons in each - I don‚Äôt know.  There is no practical sense in this program, but for studying Python3 the task is quite good: here you can work with lists, and with dictionaries, and process command line parameters, work with images, regular expressions, work with the file system (modules os and os.path ). <br><br>  For those who want to play, I will say only one thing - the <b>brain.py</b> program will need some work if you want to change the number of letters or change them for others.  Improvements are small and simple. <br><br>  If you have any questions - write in a personal, but I think that you yourself will understand what, where and how. <br>  There will be time, maybe I will rewrite the prettier code and make it more customizable, I will enter more parameters. <br><br>  Source codes you can take in the spoilers below. <br><div class="spoiler">  <b class="spoiler_title">File code gen_pic.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 import sys import argparse import re import os import os.path from PyQt4.QtGui import * from PyQt4.Qt import * def saveWrap(dir='.', letter='A', font="Arial", size=40, align=Qt.AlignCenter): png_file = dir + "/" + font + "_" + letter + "_" + str(size) + ".png" save(png_file, letter, font, size, align) def save(png_file, letter='A', font="Arial", size=40, align=Qt.AlignCenter): img = QImage(64, 64, QImage.Format_RGB32) img.fill(Qt.white) p = QPainter(img) p.setPen(Qt.black) p.setFont(QFont(font, size)) p.drawText(img.rect(), align, letter) p.end() img.save(png_file) def main(): app = QApplication([]) p = argparse.ArgumentParser(description='Symbols image generator') p.add_argument('-f', '--font', default='Arial', help='Font name, default=Arial') p.add_argument('-s', '--size', type=int, default=40, help='Font size, default=40') p.add_argument('-d', '--dir', default='.', help='Output directory, default=current') p.add_argument('letters', help='Array of letters(abc) or range (az)') args = p.parse_args() path = os.path.abspath(args.dir) if not os.path.exists(path): print("Directory not exists, created!") os.makedirs(path) if re.match('^([az]-[az])|([AZ]-[AZ])$', args.letters): begin = args.letters[0] end = args.letters[2] if (ord(end) - ord(begin)) &gt; 26: print("Error using letters. Only AZ or az available, not Az.") p.print_help() return letters = [chr(a) for a in range(ord(begin), ord(end) + 1)] else: letters = args.letters for lett in letters: saveWrap(path, lett, args.font, args.size) return 0 if __name__ == "__main__": sys.exit(main())</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">The code of the brain.py file</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 import sys import argparse import re import os import os.path from PyQt4.QtGui import * from PyQt4.Qt import * from pybrain.tools.shortcuts import buildNetwork from pybrain.datasets import ClassificationDataSet from pybrain.structure.modules import SigmoidLayer, SoftmaxLayer, LinearLayer from pybrain.supervised.trainers import BackpropTrainer from pybrain.supervised.trainers import RPropMinusTrainer def init_brain(learn_data, epochs, TrainerClass=BackpropTrainer): if learn_data is None: return None print ("Building network") # net = buildNetwork(64 * 64, 8 * 8, 5, hiddenclass=TanhLayer) # net = buildNetwork(64 * 64, 32 * 32, 8 * 8, 5) net = buildNetwork(64 * 64, 5, hiddenclass=LinearLayer) # fill dataset with learn data trans = { 'A': 0, 'B': 1, 'C': 2, 'D': 3, 'Z': 4 } ds = ClassificationDataSet(4096, nb_classes=5, class_labels=['A', 'B', 'C', 'D', 'Z']) for inp, out in learn_data: ds.appendLinked(inp, [trans[out]]) ds.calculateStatistics() print ("\tNumber of classes in dataset = {0}".format(ds.nClasses)) print ("\tOutput in dataset is ", ds.getField('target').transpose()) ds._convertToOneOfMany(bounds=[0, 1]) print ("\tBut after convert output in dataset is \n", ds.getField('target')) trainer = TrainerClass(net, verbose=True) trainer.setData(ds) print("\tEverything is ready for learning.\nPlease wait, training in progress...") trainer.trainUntilConvergence(maxEpochs=epochs) print("\tOk. We have trained our network.") return net def loadData(dir_name): list_dir = os.listdir(dir_name) list_dir.sort() list_for_return = [] print ("Loading data...") for filename in list_dir: out = [None, None] print("Working at {0}".format(dir_name + filename)) print("\tTrying get letter name.") lett = re.search("\w+_(\w)_\d+\.png", dir_name + filename) if lett is None: print ("\tFilename not matches pattern.") continue else: print("\tFilename matches! Letter is '{0}'. Appending...".format(lett.group(1))) out[1] = lett.group(1) print("\tTrying get letter picture.") out[0] = get_data(dir_name + filename) print("\tChecking data size.") if len(out[0]) == 64 * 64: print("\tSize is ok.") list_for_return.append(out) print("\tInput data appended. All done!") else: print("\tData size is wrong. Skipping...") return list_for_return def get_data(png_file): img = QImage(64, 64, QImage.Format_RGB32) data = [] if img.load(png_file): for x in range(64): for y in range(64): data.append(qGray(img.pixel(x, y)) / 255.0) else: print ("img.load({0}) failed!".format(png_file)) return data def work_brain(net, inputs): rez = net.activate(inputs) idx = 0 data = rez[0] for i in range(1, len(rez)): if rez[i] &gt; data: idx = i data = rez[i] return (idx, data, rez) def test_brain(net, test_data): for data, right_out in test_data: out, rez, output = work_brain(net, data) print ("For '{0}' our net said that it is '{1}'. Raw = {2}".format(right_out, "ABCDZ"[out], output)) pass def main(): app = QApplication([]) p = argparse.ArgumentParser(description='PyBrain example') p.add_argument('-l', '--learn-data-dir', default="./learn", help="Path to dir, containing learn data") p.add_argument('-t', '--test-data-dir', default="./test", help="Path to dir, containing test data") p.add_argument('-e', '--epochs', default="1000", help="Number of epochs for teach, use 0 for learning until convergence") args = p.parse_args() learn_path = os.path.abspath(args.learn_data_dir) + "/" test_path = os.path.abspath(args.test_data_dir) + "/" if not os.path.exists(learn_path): print("Error: Learn directory not exists!") sys.exit(1) if not os.path.exists(test_path): print("Error: Test directory not exists!") sys.exit(1) learn_data = loadData(learn_path) test_data = loadData(test_path) # net = init_brain(learn_data, int(args.epochs), TrainerClass=RPropMinusTrainer) net = init_brain(learn_data, int(args.epochs), TrainerClass=BackpropTrainer) print ("Now we get working network. Let's try to use it on learn_data.") print("Here comes a tests on learn-data!") test_brain(net, learn_data) print("Here comes a tests on test-data!") test_brain(net, test_data) return 0 if __name__ == "__main__": sys.exit(main())</span></span></code> </pre><br></div></div><br><br>  At this acquaintance with PyBrain today I consider complete.  See you again! <br><br>  <b>upd:</b> at the request of <a href="https://habrahabr.ru/users/monolithed/" class="user_link">monolithed</a> corrected the regular expression. </div><p>Source: <a href="https://habr.com/ru/post/171937/">https://habr.com/ru/post/171937/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171915/index.html">Phalcon 1.0.0 First Beta</a></li>
<li><a href="../171919/index.html">Highlights $ in'y: MongoDB performance in ranges</a></li>
<li><a href="../171925/index.html">What is the difference between using MVC and MVP</a></li>
<li><a href="../171929/index.html">Caphaw Banking Trojan attacks European banks using web injects plugin</a></li>
<li><a href="../171935/index.html">The European program with a grant of 25 thousand euros: How to turn talent into the founder of a startup?</a></li>
<li><a href="../171941/index.html">10 devices that you can upgrade, a little digging with electronics</a></li>
<li><a href="../171945/index.html">Began beta testing of Unity 4 Game Engine with Windows 8 support</a></li>
<li><a href="../171947/index.html">Few woman-related English idioms</a></li>
<li><a href="../171949/index.html">Harlem Shake: USA vs. Russia</a></li>
<li><a href="../171953/index.html">Why should I redo it? After all, it's not difficult for me!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>