<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fat programs - speed factors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Picture from the movie ‚ÄúSize Matters‚Äù, 2009 

 This article was launched in April 2016 as a result of the fact that the computer again began to work m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fat programs - speed factors</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d7f/a9d/6cd/d7fa9d6cdeda49f2adc07a985b005f41.jpg">  <i>Picture from the movie ‚ÄúSize Matters‚Äù, 2009</i> <br><br>  This article was launched in April 2016 as a result of the fact that the computer again began to work more slowly than I click the mouse.  Actually, it is a compilation of many tests (some since 2010) and discussions with my participation.  It cannot be called fully completed, since these are not final conclusions, but some intermediate points, showing what to pay attention to and where to dig further. <br><br>  The name is partially borrowed from <a href="https://www.osp.ru/os/1996/06/179017/">Niklaus Wirth's</a> article <a href="https://www.osp.ru/os/1996/06/179017/">‚ÄúDown with the‚Äú Fat ‚ÄùPrograms‚Äù</a> , which was exactly 10 years old in 2016, and has not lost its relevance - but rather reached a new level, who do not know it - read it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider various aspects that affect the performance of systems and programs. <br><br>  <a href="https://habr.com/ru/post/326592/">Language aspect</a> <br>  <a href="https://habr.com/ru/post/326592/">Memory aspects</a> <br>  <a href="https://habr.com/ru/post/326592/">Aspects of the real world</a> <br>  <a href="https://habr.com/ru/post/326592/">Non-language factors</a> <br>  <a href="https://habr.com/ru/post/326592/">Human aspect</a> <br><a name="habracut"></a><br><h3>  Language aspect </h3><br><h4>  a) Influence of programming language and compiler </h4><br>  As I said earlier in the comments, using a ‚Äúgood‚Äù language gives a decent difference in speed. <br><br>  We take the good old S. as a point of reference. It is clear that by using enough diligence, you can do better in assembler, but let the assembler world and the associated fine settings of higher orders remain an unattainable ideal. <br><br>  Consider the evaluation of the aspect in two variants - a business application that is little dependent on floating-point calculations, and a purely computational problem. <br><br>  Next, go through the gradations between them. <br><br>  The test for integer calculations is Dhrystone (I know that it is old and bad, but it is quite suitable for estimating the depth of a hole ‚Äî it has a good set of fundamental operations of the language). <br><br>  Copies and modified sources I posted here <a href="https://github.com/Siemargl/FatProgs">github.com/Siemargl/FatProgs</a> <br>  The extreme points of the segment are an optimized C program and an interpreted Python3.6 program (not because I don‚Äôt like Python, but because I lost it all on previous similar tests and is point B, and there are already the necessary tests for it) <br><br><div class="spoiler">  <b class="spoiler_title">Dhrystone results</b> <div class="spoiler_text"><blockquote>  &gt; gcc -O2 -DTIME -DHZ = dhry_1.c dhry_2.c -o gcc_dry2 </blockquote><br><blockquote>  D: \ VSProjects \ _pl_benchmark \ Dhrystone&gt; gcc --version </blockquote><br>  gcc.EXE (tdm-1) 4.9.2 <br>  &gt; gcc_dry2 500000000 <br>  User time = 27 sec <br>  Microseconds for one run through Dhrystone: 0.1 <br>  Dhrystones per Second: 18518518.0 <br>  DMIPS 10539.9 <br><blockquote>  &gt; python.exe pystone.py </blockquote><br>  Pystone (1.2) time for 5000000 passes = 46.4937 <br>  This machine benchmarks at 107542 pystones / second <br><br>  The difference in speed is 172 times.  If you look at the source, then the pistons are the original in the original. <br><br>  To exclude fraud, take another TinyC - which does not know how to optimize in principle <br><blockquote>  &gt; cc_dry2.exe 500000000 </blockquote><br>  User time = 55 sec <br>  Microseconds for one run through Dhrystone: 0.1 <br>  Dhrystones per Second: 9090909.0 <br>  DMIPS 5174.1 <br>  ‚ÄúTotal‚Äù is 84 times faster than the interpreter, and twice as slow as the optimized version. <br></div></div><br>  The test of floating point calculations, for example Scimark2 (it is also old and is still used, for example, in the <a href="https://github.com/python/performance">performance</a> package <br><br><div class="spoiler">  <b class="spoiler_title">Scimark results</b> <div class="spoiler_text">  Running just this test looks like this. <br><blockquote>  D: \ VSProjects \ Python36 \ python.exe pyperformance run -o py3z.json -b = scimark </blockquote><br>  Python version: 3.6.0 (64-bit) revision 41df79263a11 <br>  Report on Windows-7-6.1.7601-SP1 <br>  Number of logical CPUs: 4 <br>  Start Date: 2017-01-19 03: 03: 35.583496 <br>  End date: 2017-01-19 03: 07: 00.042133 <br>  ### scimark_fft ### <br>  Median + - std dev: 863 ms + - 4 ms <br>  ### scimark_lu ### <br>  Median + - std dev: 462 ms + - 10 ms <br>  ### scimark_monte_carlo ### <br>  Median + - std dev: 247 ms + - 2 ms <br>  ### scimark_sor ### <br>  Median + - std dev: 577 ms + - 6 ms <br>  ### scimark_sparse_mat_mult ### <br>  Median + - std dev: 10.3 ms + - 0.1 ms <br><br>  Results for the same with Python by the number of iterations of the C test <br>  &gt; gcc -mfpmath = sse -march = native -O2 <br>  FFT ms * 50: 2.06 (N = 1024) <br>  SOR ms * 10: 0.59 (100 x 100) <br>  MonteCarlo: ms * 1e5: 1.51 <br>  Sparse matmult ms: 0.79 (N = 1000, nz = 50000) <br>  LU ms: 0.32 (M = 100, N = 100) <br><br>  Decoding - The Python test shows the time for one test execution, but which may contain a different number of identical iterations, for example, the Fourier transform is considered 50 times, which is reflected by a multiplier in the C-results. <br><br>  Here, the difference on different tests can reach 1500 times (I don‚Äôt like it, it looks suspiciously big - so those who want to find errors in testing are welcome) <br><br>  Turning off optimizations and SIMD on C gives 3-4 times slower result <br>  FFT ms * 50: 8.80 (N = 1024) <br>  SOR ms * 10: 0.66 (100 x 100) <br>  MonteCarlo: ms * 1e5: 4.04 <br>  Sparse matmult ms: 2.87 (N = 1000, nz = 50000) <br>  LU ms: 1.11 (M = 100, N = 100) <br></div></div><br>  Now about the gradation. <br><br>  If you do not take into account pure interpreters like python and old PHP, all compilers and most JIT machines fit into the x2-x4 range, with the best JIT in Java and lagging behind even in the worst cases less than 2 times, and wrong compilation options. -the program for calculating FFT, for example, slows down fivefold. <br><br>  On the other hand, if you look <a href="https://habrahabr.ru/company/mailru/blog/321748/">here</a> , in the modern world of Javascript, the interpreter is much closer to you than you think. <br><br>  The way to measure this factor is given above. <br><br>  Evaluation.  Since there are still many factors ahead, I would rate this speed factor as insignificant, except for a narrow circle of purely computational problems. <br><br><h4>  b) The influence of the programming paradigm </h4><br>  For example, C ++ / D.  These languages ‚Äã‚Äãadd two basic paradigms - OOP and template metaprogramming.  I will not sing praises to them - let's see how this affects performance. <br><br>  Using metaprogramming.  Templates, macros, partly generics (although objects belong to the worst karma).  The templates will unfold into code without loss of performance or even with a gain in speed, since the functions of inline and call losses disappear.  All that threatens to use them is code bloating due to the generation of copies of the code of the same algorithms for different types of data. <br><br>  Using OOP.  The problem here is that as soon as you took the object from the framework, it ‚Äúcalled‚Äù your dad, mom, and all relatives to join your program, even if they are not used in your program (linkers and class-loaders are not as smart as I would like to).  Together they will eat up the time to boot from disk, place in memory and in the cache of the processor.  This is also a memory aspect. <br><br>  I almost forgot - some technology introduced in addition to the PLO, such as exceptions, or other advanced, is also not entirely free. <br><br>  How to measure the aspect - there are Stepanova Tests, showing acceleration up to 2 times when deploying calls and losing up to 2% on virtual calls, but the impact of code bloating is extremely difficult to assess, see the memory aspect below. <br><br>  The estimation of this speed factor is from insignificant to noticeable. <br><br><h4>  c) Byte Code Machines (BCVM) </h4><br>  They are in the middle of performance between compilers into machine code and interpreters, close to the first. <br><br>  The essential difference here is whether the intermediate bytecode will be compiled by the JIT or AOT, or will be interpreted.  A mixed version is also possible, when BCVM was designed for another language and part of the code cannot be translated into the PI code of this machine. <br><br>  In any case, we pay either load time or memory.  For example, Java JIT costs about 100MB of memory, which is already significant, although the resulting code is very fast and uses SIMD (tested recently in the article about FFT) <br><br>  How to measure - use tests, it is often enough to look on the Internet for <a href="http://benchmarksgame.alioth.debian.org/">something like this</a> <br><br>  Evaluation of this factor of speed - if JIT is good, then it is insignificant, but the memory aspect is a plus, and if a byte machine is an interpreter or ‚Äúalien‚Äù, then alas. <br><br><h3>  Memory aspects </h3><br><h4>  a) Stacking placement </h4><br>  - it does not cost anything, but the reference to the dynamic memory manager often pulls the system call.  Coupled with garbage collection and memory fragmentation can be a problem for 24/7 systems. <br><br>  If your language allows temporary local objects to be created without using a heap, you will benefit. <br><br>  Measured by tests, by itself costs a little, but can pull the aspects below. <br><br><h4>  b) Garbage Collector (GC) </h4><br>  - it is not clear, a blessing for newcomers or a curse for the ‚Äúbig ones‚Äù - but since it is sometimes necessary to fight it, a negative factor. <br><br>  Measurement by tests is difficult, it requires complicated diagnosis of the behavior of GC using BCVM tools. <br><br>  Estimation of the factor - for large systems, significant unpredictable lags may occur. <br><br><h4>  c) dynamic loading </h4><br>  When we launch a new class - for example, we open a new window in the program, two things happen - we need to load a piece of related code in the case of machine code or a framework in the case of BCVM- (we look at OOP and the mother of all relatives) and run JIT on the loaded code. <br><br>  Check for BCVM in reality - you can do a simple test - we launch the file load and intensively climb the interface - and now your program works with swap speed. <br>  Full testing is difficult, it is easy to measure only the load time and look at the maximum potential appetites of the program - the size of the VSZ memory for Linux and the ‚ÄúAllocated Virtual Memory‚Äù counter in Windows.  A little more help learning statistics hard page faults. <br><br>  It seems that the problem should be solved by the amount of cheap memory and preloading, but if one program consumes an extra two or three or ten MB, then in a typical system there are dozens of them - and oh. <br>  Impact assessment - possible unpredictable lags. <br><br><h4>  d) CPU cache </h4><br>  The more code that is executed and the data is processed by yours and not only by your program, the stronger is the influence of the cache size of the processor.  And the cache is required for numerous templates and generics, and for JIT. <br><br>  Testing - you need to drive the same program on processors of the same type with different cache sizes, which is not available to everyone. <br><br>  Impact - difficult to assess.  <a href="https://habrahabr.ru/post/312078/">This article</a> argues that localization of data in the cache accelerates significantly. <br><br><h3>  Aspects of the real world </h3><br><h4>  a) System calls </h4><br>  On different platforms, a system call can have different costs, such as mutexes or thread creation.  Because the difference in speed can be at times only because of this factor.  One <a href="https://habrahabr.ru/company/mailru/blog/324466/">example</a> recently on Habr√©. <br><br>  Measurement - testing on different platforms.  Impact assessment - approximately as for choosing a programming language, as insignificant, except for specific tasks. <br><br><h4>  b) How important is abstract performance? </h4><br>  In most cases, the real iron that you have to work with is always slower.  Either the speed is quite enough for the user's reaction.  Or your site is not visited enough for delay. <br><br><h4>  c) Iron affects </h4><br>  Perhaps you have an ARM processor and everything is bad floating point. <br>  Perhaps you have tight memory limitations do not allow to accommodate a complex algorithm. <br>  Perhaps a slow or unstable network. <br>  Maybe the video accelerator is very specific in functionality. <br>  Requires preliminary testing on the layout. <br>  The impact can be very strong. <br>  Evaluation - for example, this is your battery in the phone, which has to feed the memory and gigahertz. <br><br><h3>  Non-language factors </h3><br>  Algorithms decide everything.  For example, SQL loses its linguistic computational characteristics (this is a common interpreter), but because of the good hardware and long data access time, it looks good overall.  However, in some specific cases, a too generalized SQL approach loses direct navigation such as M / Cache or NoSQL solutions. <br><br>  Good licked libraries negate the shortcomings of a particular language - they take most of the time to complete the task and allow you to almost not think about it - these are the mathematical libraries and, almost always, the runtime libraries. <br><br>  Verification and evaluation - here only a quality education will help to understand the algorithms. <br><br><h3>  Human aspect </h3><br>  Ignorance of the language, too lazy to write correctly, too high level of abstraction leads to bad decisions on all fronts - for example, it can be easier to sort through the entire array or database with a standard iterator than to reorganize the data structure, it is easier to copy a couple of tens of megabytes for temporary analysis ... <br>  Examples can be infinitely many. <br><br><h3>  And what is proposed to do with this? </h3><br>  The first answer is nothing.  In the event that you are constrained by the operating restrictions, the inherited code, or simply lack of experience. <br><br>  The second answer is to write in assembly language, use only the tools native to the system and the API. <br><br>  If you are too lazy, too difficult, then you have a choice - I will offer the following set of steps from the programmer's paradise to the fall: <br><br>  Null  Using C.  Pure C will increase your program only by the size of the run-time library (libc) in memory, and the modern optimizer will not spoil the executable code. <br><br>  In fact, it is not necessary to take C - any compiled language suits your taste - ADA, Modula, Oberon, even Pascal / Delphi, preferably optimizing <br><br>  -one.  Using metaprogramming.  Templates, macros, partly generics (although OOP already belong to the worst karma).  Templates will be developed in a code without loss in productivity.  All that their use threatens is code bloating due to the generation of copies of the code of the same algorithms for different data types. <br><br>  -2  Using compiled object languages ‚Äã‚ÄãC ++, D, Rust, Go.  What's bad about it?  On the one hand, the fashion for objects has already passed everywhere, and many sober-minded developers criticize the object approach, which does not give a decisive gain in development.  On the other hand, massive tried-and-true run-in and convenient frameworks.  The problem is that the objects in the most part of the framework will be linked, even if they are not used in your program.  Oops, and your executable file has exceeded a dozen megabytes.  These megabytes occupy your disk, your memory, and processor cache.  Although the overhead of function calls is measured by a couple of percent, it is difficult to measure the effect of CPU cache utilization. <br><br>  -1024.  Interpreted languages.  PHP, CPython, partly Javascript.  Thanks to them, the browser session has exceeded one hundred megabytes, and the loss at computing speed by 100 times is a normal matter. <br><br>  -Pi.  Virtual machines.  These are languages ‚Äã‚Äãwith intermediate byte code based on the .NET platform or on the Java platform, and PyPy and V8 can also be included here.  You always carry a byte with you - it is with you on the disk, it is with you in memory.  Although, if you believe the tests, it seems that everything is almost normal - a loss on the calculations of tens of percent, well, up to a maximum of 100% in the worst cases.  Only tests, as a rule, do not take into account the download speed of the virtual machine itself.  And this is memory, memory, and again memory, tens and hundreds of megabytes. <br>  Developers themselves know this problem and are moving towards compiling into native code.  This is ART instead of Dalvika for Android, and Microsoft's .NET Native. <br><br>  PS Well, for the final example - I have 3 user programs that are similar in functionality: <br><br>  One is written in C ++ / Qt / Webkit <br>  Another on C # .NET 4.5 <br>  Third on Python3 / wx <br><br>  Here is the most responsive of them - on the python, and the slowest on the dotnet. <br><br>  Conclusions - there are many aspects, and it is useless to take into account only one. </div><p>Source: <a href="https://habr.com/ru/post/326592/">https://habr.com/ru/post/326592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326580/index.html">Switch from bash to zsh</a></li>
<li><a href="../326582/index.html">The story of how the parser turned into a full-fledged IRCO bot for Telegrams</a></li>
<li><a href="../326584/index.html">Notes on Cisco Catalyst: VLAN setup, password reset, IOS operating system flashing</a></li>
<li><a href="../326588/index.html">How to make your IDEA IDE level</a></li>
<li><a href="../326590/index.html">Mail.Ru Group Online Course News: Restarting Advanced C ++ Programming</a></li>
<li><a href="../326594/index.html">Bash scripts, part 4: input and output</a></li>
<li><a href="../326596/index.html">Exoskeleton do it yourself</a></li>
<li><a href="../326600/index.html">Hello, who is calling or determining the number in Asterisk</a></li>
<li><a href="../326602/index.html">Terrible import kraken - how to use ES6-modules and not go crazy</a></li>
<li><a href="../326608/index.html">Personal vDisk in Citrix XenDesktop: what is the advantage and how it works</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>