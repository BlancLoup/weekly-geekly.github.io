<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Julia: functions and structure-as-functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despite the fact that the Julia language by design lacks ‚Äúclassical‚Äù object-oriented programming with classes and methods, the language provides abstr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Julia: functions and structure-as-functions</h1><div class="post__text post__text-html js-mediator-article">  Despite the fact that the Julia language by design lacks ‚Äúclassical‚Äù object-oriented programming with classes and methods, the language provides abstraction tools, in which the type system and elements of functional programming play a key role.  Consider the second paragraph in more detail. <br><a name="habracut"></a><br>  The concept of functions in Julia is probably the most similar to the languages ‚Äã‚Äãof the Lisp family (to be more precise, Lisp-1 branches), and functions can be viewed at three levels: as subroutines, as abstractions to a certain sequence of actions, and as data representing this abstraction . <br><br><h3>  Level 1. Functions as subroutines </h3><br>  Allocation of subroutines and assigning them their own names has been going on since prehistoric times, when Fortran was considered a high-level language, and C was not yet. <br><br>  In this understanding, the means of Julia are standard.  "Feature" can be called the fact that syntactically there is no division into procedures and functions.  Regardless of whether a subroutine is called to get some value or only to perform some actions on data, it is called a function. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The function definition begins with the <code>function</code> keyword, followed by the list of arguments in brackets, a sequence of commands, and the word <code>end</code> ends with the definition: <br><br><pre> <code class="julia hljs"><span class="hljs-string"><span class="hljs-string">""" sum_all(collection) Sum all elements of a collection and return the result """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> sum_all(collection) sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> collection sum += collection <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sum <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  The syntax is distinguished by the behavior inherited from Lisp: for a ‚Äúnormal‚Äù return of a value from a function, the word <code>return</code> not necessary: ‚Äã‚Äãthe value of the last expression calculated before <code>end</code> returned.  In the example above, the value of the variable variable will be returned.  Thus, <code>return</code> can be used as a marker for the special behavior of a function: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> safe_division(number, divisor) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> divisor == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> number / divisor <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">#    function safe_division1(number, divisor) if divisor == 0 0 #             else number / divisor end end</span></span></code> </pre><br>  For functions with a short definition, there is a shortened syntax, similar to a mathematical notation.  Thus, the calculation of the length of the hypotenuse by the length of the legs can be determined as follows: <br><br><pre> <code class="julia hljs">hypotenuse(a, b) = sqrt(a^<span class="hljs-number"><span class="hljs-number">2</span></span> + b^<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  "Safe" division using the ternary operator can be written as: <br><br><pre> <code class="julia hljs">safe_division(number, divisor) = divisor == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : number / divisor</code> </pre><br>  As you can see, it is not necessary to specify types for function arguments.  Taking into account how Julia's JIT compiler works, ‚Äúduck typing‚Äù will not even always lead to a drop in performance. <br><br>  As I tried to demonstrate in the <a href="https://habr.com/ru/post/450628/">previous article</a> , the Julia compiler can display the type of the returned result by the types of input arguments.  Therefore, for example, the <code>safe_division</code> function for quick work requires minimal modification: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> safe_division(number, divisor) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> divisor == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zero(number / divisor) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> number / divisor <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Now, if the types of both arguments are known at the compilation stage, the type of the returned result is also unambiguously derived, since  the <code>zero(x)</code> function returns a zero value of the same type as its argument (and the division by zero, according to <a href="https://en.wikipedia.org/wiki/IEEE_754-1985">IEEE 754</a> , has a quite representable value in the format of floating-point numbers). <br><br>  Functions can have a fixed number of positional arguments, positional arguments with default values, named arguments, and a variable number of arguments.  Syntax: <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#    function hello(name) println("Hello, ", name) end #      #           function greeting_d(name, greeting = "Hello") println(greeting, ", ", name) end #       #          #       function greeting_kw(name; greeting = "Hello") println(greeting, ", ", name) end #  greeting   ,        function greeting_oblkw(name; greeting) println(greeting, ", ", name) end #      #  ,   ,      names function greeting_nary(greeting, names...) print(greeting) for name in names print(", ", name) end print('\n') end julia&gt; hello("world") Hello, world julia&gt; greeting_d("world") Hello, world julia&gt; greeting_d("Mr. Smith", "How do you do") How do you do, Mr. Smith julia&gt; greeting_kw("Mr. Smith") Hello, Mr. Smith julia&gt; greeting_kw("mom", greeting = "Hi") Hi, mom julia&gt; greeting_oblkw("world") ERROR: UndefKeywordError: keyword argument greeting not assigned Stacktrace: [1] greeting_oblkw(::String) at ./REPL[23]:3 [2] top-level scope at none:0 julia&gt; greeting_oblkw("mom", greeting = "Hi") Hi, mom julia&gt; greeting_nary("Hi", "mom", "dad", "everyone") Hi, mom, dad, everyone</span></span></code> </pre><br><h3>  Level 2. Functions as data </h3><br>  The name of the function can be used not only in direct calls, but also as an identifier with which the procedure for obtaining a value is associated.  For example: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f_x_x(fn, x) fn(x, x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; f_x_x(+, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-comment"><span class="hljs-comment"># +(3, 3) = 3+3 = 6 julia&gt; f_x_x(*, 3) 9 # *(3, 3) = 9 julia&gt; f_x_x(^, 3) 27 # ^(3, 3) = 3^3 = 27 julia&gt; f_x_x(log, 3) 1.0 # log(3, 3) = 1</span></span></code> </pre><br>  The ‚Äúclassic‚Äù functions that take a functional argument are <code>map</code> , <code>reduce</code> and <code>filter</code> . <br><br>  <code>map(f, x...)</code> applies the function <code>f</code> to the values ‚Äã‚Äãof all elements from <code>x</code> (or tuples from the i-th elements) and returns the results as a new collection: <br><br><pre> <code class="julia hljs">julia&gt; map(cos, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>]) <span class="hljs-number"><span class="hljs-number">5</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">0.5000000000000001</span></span> <span class="hljs-number"><span class="hljs-number">6.123233995736766e-17</span></span> -<span class="hljs-number"><span class="hljs-number">0.4999999999999998</span></span> -<span class="hljs-number"><span class="hljs-number">1.0</span></span> julia&gt; map(+, (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br>  <code>reduce(f, x; init_val)</code> "reduces" the collection to a single value, "expanding" the chain <code>f(f(...f(f(init_val, x[1]), x[2])...), x[end])</code> : <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> myreduce(fn, values, init_val) accum = init_val <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> values accum = fn(accum, x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> accum <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Since it is not actually determined in what order the array will pass during the reduction, and also whether <code>fn(accum, x)</code> or <code>fn(x, accum)</code> will be <code>fn(x, accum)</code> , the reduction will give a predictable result only with commutative or associative operators, such as addition or multiplication. <br><br>  <code>filter(predicate, x)</code> returns an array of <code>x</code> elements that satisfy the predicate <code>predicate</code> : <br><br><pre> <code class="julia hljs">julia&gt; filter(isodd, <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">5</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> julia&gt; filter(iszero, [[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>:-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-literal"><span class="hljs-literal">im</span></span>]) <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-literal"><span class="hljs-literal">im</span></span></code> </pre><br>  Using higher-order functions for array operations instead of writing a loop has several advantages: <br><br><ol><li>  the code gets shorter </li><li>  <code>map()</code> or <code>reduce()</code> show the <i>semantics of</i> the operation being performed, then the semantics of what is happening in the cycle must also be understood </li><li>  <code>map()</code> allows the compiler to understand that operations on array elements are data-independent, which allows for additional optimizations </li></ol><br><h3>  Level 3. Functions as abstractions </h3><br>  Often in <code>map()</code> or <code>filter()</code> you need to use a function that has not been assigned its own name.  Julia in this case allows you to express an <i>abstraction of</i> performing operations on an argument without entering your own name for this sequence.  Such an abstraction is called <i>an anonymous function</i> , or a <i>lambda function</i> (since in the mathematical tradition such functions are denoted by the letter lambda).  The syntax for this view is: <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#   square(x) = x^2 #   x -&gt; x^2 #   hypot(a, b) = sqrt(x^2 + y^2) #   -    ,    , #              (x, y) -&gt; sqrt(x^2 + y^2) #   fortytwo() = 42 #   () -&gt; 42 julia&gt; map(i -&gt; map(x -&gt; x^i, 1:5), 1:5) 5-element Array{Array{Int64,1},1}: [1, 2, 3, 4, 5] [1, 4, 9, 16, 25] [1, 8, 27, 64, 125] [1, 16, 81, 256, 625] [1, 32, 243, 1024, 3125]</span></span></code> </pre><br>  Both named and anonymous functions can be assigned to variables and returned as values: <br><br><pre> <code class="julia hljs">julia&gt; double_squared = x -&gt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * x)^<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">#17 (generic function with 1 method) julia&gt; double_squared(5) 100</span></span></code> </pre><br><h3>  Variable scope and lexical closures </h3><br>  Normally, functions are attempted to be written in such a way that all the data necessary for the calculation are obtained through formal arguments, i.e.  Any variable names that are found in the body are either the names of formal arguments or the names of variables entered inside the function body. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> normal(x, y) z = x + y x + y * z <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> strange(x, y) x + y * z <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  About the <code>normal()</code> function, it can be said that in its body all variable names are <i>related</i> , i.e  if we everywhere (including the argument list) replace ‚Äúx‚Äù with ‚Äúm‚Äù (or any other identifier), ‚Äúy‚Äù with ‚Äún‚Äù, and ‚Äúz‚Äù with ‚Äúsum_of_m_and_n‚Äù - the meaning of the expression will not change.  In the function <code>strange()</code> name z is <i>unbound</i> , i.e.  a) the meaning may change if this name is replaced by another and b) the correctness of the function depends on whether a variable with the name ‚Äúz‚Äù was defined at the time of the function call. <br><br>  Generally speaking, the <code>normal()</code> function is also not so clean: <br><br><ol><li>  What happens if a variable with the name z is defined outside the function? </li><li>  The + and * characters are also unbound identifiers. </li></ol><br>  With paragraph 2, nothing can be done except to agree - it is logical that the definitions of all functions used in the system should exist, and we hope that their real meaning meets our expectations. <br><br>  Point 1 is less obvious than it seems.  The point is that the answer depends on where the function is defined.  If it is defined globally, then <code>z</code> inside <code>normal()</code> will be a local variable, i.e.  even if there is a global variable <code>z</code> its value will not be overwritten.  If the definition of a function is inside a block of code, then if there is an earlier definition of <code>z</code> in this block, the value of the external variable will be changed. <br><br>  If the function body contains the name of an external variable, then this name is associated with the value that existed in the environment where the function was created.  If the function itself is exported from this environment (for example, if it is returned from another function as a value), then it ‚Äúcaptures‚Äù the variable from the internal environment, to which the new environment no longer has access.  This is called lexical closure. <br><br>  Closures are mainly useful in two situations: when you need to create a function according to specified parameters and when you need a function that has some internal state. <br><br>  Consider the situation with the function that encapsulates the internal state: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f_with_counter(fn) call_count = <span class="hljs-number"><span class="hljs-number">0</span></span> ncalls() = call_count <span class="hljs-comment"><span class="hljs-comment"># invoke()  ,     #    ,  ncalls() function invoke(args...) call_count += 1 fn(args...) end #         # call_count     , #   invoke()  call_count()        (call = invoke, call_count = ncalls) end julia&gt; abscount = f_with_counter(abs) (call = getfield(Main, Symbol("#invoke#22")){typeof(abs)}(abs, Core.Box(0)), call_count = getfield(Main, Symbol("#ncalls#21"))(Core.Box(0))) julia&gt; abscount.call_count() 0 julia&gt; abscount.call(-20) 20 julia&gt; abscount.call_count() 1 julia&gt; abscount.call(im) 1.0 julia&gt; abscount.call_count() 2</span></span></code> </pre><br><h4>  Case study: all the same polynomials </h4><br>  In the <a href="https://habr.com/ru/post/450628/">last article</a> the presentation of polynomials as structures was considered.  In particular, one of the storage structures is a list of coefficients, starting with the youngest.  To calculate the polynomial <code>p</code> at the point <code>x</code> proposed to call the function <code>evpoly(p, x)</code> , which calculates the polynomial according to the Horner scheme. <br><br><div class="spoiler">  <b class="spoiler_title">Full definition code</b> <div class="spoiler_text"><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> AbstractPolynomial <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-string"><span class="hljs-string">""" Polynomial &lt;: AbstractPolynomial Polynomials written in the canonical form --- Polynomial(v::T) where T&lt;:Union{Vector{&lt;:Real}, NTuple{&lt;:Any, &lt;:Real}}) Construct a `Polynomial` from the list of the coefficients. The coefficients are assumed to go from power 0 in the ascending order. If an empty collection is provided, the constructor returns a zero polynomial. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Polynomial&lt;:AbstractPolynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Polynomial(v::T <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}) coeff = isempty(v) ? (<span class="hljs-number"><span class="hljs-number">0.0</span></span>,) : tuple([<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v]...) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new(length(coeff)-<span class="hljs-number"><span class="hljs-number">1</span></span>, coeff) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-string"><span class="hljs-string">""" InterpPolynomial &lt;: AbstractPolynomial Interpolation polynomials in Newton's form --- InterpPolynomial(xsample::Vector{&lt;:Real}, fsample::Vector{&lt;:Real}) Construct an `InterpPolynomial` from a vector of points `xsample` and corresponding function values `fsample`. All values in `xsample` must be distinct. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> InterpPolynomial&lt;:AbstractPolynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> xval::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> InterpPolynomial(xsample::X, fsample::F) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {X&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}, F&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !allunique(xsample) throw(<span class="hljs-built_in"><span class="hljs-built_in">DomainError</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot interpolate with duplicate X points"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> N = length(xsample) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> length(fsample) != N throw(<span class="hljs-built_in"><span class="hljs-built_in">DomainError</span></span>(<span class="hljs-string"><span class="hljs-string">"Lengths of X and F are not the same"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> coeff = [<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>(f) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fsample] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>:N <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>:(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) coeff[i] = (coeff[j] - coeff[i]) / (xsample[j] - xsample[i]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> new(N-<span class="hljs-number"><span class="hljs-number">1</span></span>, ntuple(i -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>(xsample[i]), N), tuple(coeff...)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> InterpPolynomial(fn, xsample::T) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}} InterpPolynomial(xsample, map(fn, xsample)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> evpoly(p::Polynomial, z::<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>) ans = p.coeff[<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx = p.degree:-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> ans = p.coeff[idx] + z * ans <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ans <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> evpoly(p::InterpPolynomial, z::<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>) ans = p.coeff[p.degree+<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx = p.degree:-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> ans = ans * (z - p.xval[idx]) + p.coeff[idx] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ans <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.:+(p1::Polynomial, p2::Polynomial) <span class="hljs-comment"><span class="hljs-comment">#    ,      deg = max(p1.degree, p2.degree) coeff = zeros(deg+1) coeff[1:p1.degree+1] .+= p1.coeff coeff[1:p2.degree+1] .+= p2.coeff Polynomial(coeff) end function Base.:+(p1::InterpPolynomial, p2::InterpPolynomial) xmax = max(p1.xval..., p2.xval...) xmin = min(p1.xval..., p2.xval...) deg = max(p1.degree, p2.degree) #         #       xmid = 0.5 * xmax + 0.5 * xmin dx = 0.5 * (xmax - xmin) / cos(0.5 * œÄ / (deg + 1)) chebgrid = [xmid + dx * cos((k - 0.5) * œÄ / (deg + 1)) for k = 1:deg+1] fsample = [evpoly(p1, x) + evpoly(p2, x) for x in chebgrid] InterpPolynomial(chebgrid, fsample) end function Base.:+(p1::InterpPolynomial, p2::Polynomial) xmax = max(p1.xval...) xmin = min(p1.xval...) deg = max(p1.degree, p2.degree) xmid = 0.5 * xmax + 0.5 * xmin dx = 0.5 * (xmax - xmin) / cos(0.5 * œÄ / (deg + 1)) chebgrid = [xmid + dx * cos((k - 0.5) * œÄ / (deg + 1)) for k = 1:deg+1] fsample = [evpoly(p1, x) + evpoly(p2, x) for x in chebgrid] InterpPolynomial(chebgrid, fsample) end function Base.:+(p1::Polynomial, p2::InterpPolynomial) p2 + p1 end</span></span></code> </pre><br></div></div><br>  The representation of a polynomial in the form of a structure does not quite correspond to its intuitive understanding as a mathematical function.  But with the help of returning a functional value, you can set polynomials and directly as functions.  So, it was: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Polynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Polynomial(v::T <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}) <span class="hljs-comment"><span class="hljs-comment">#     /     P(x) ‚â° 0 coeff = isempty(v) ? (0.0,) : tuple([Float64(x) for x in v]...) #   -   new #  -    return new(length(coeff)-1, coeff) end end """ evpoly(p::Polynomial, z::Real) Evaluate polynomial `p` at `z` using the Horner's rule """ function evpoly(p::Polynomial, z::Real) ans = p.coeff[end] for idx = p.degree:-1:1 ans = p.coeff[idx] + z * ans end return ans end</span></span></code> </pre><br>  Let us redo this definition into a function that accepts an array / tuple of coefficients and returns the function itself, which computes a polynomial: <br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Polynomial_as_closure(v::T <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}) <span class="hljs-comment"><span class="hljs-comment">#     /     P(x) ‚â° 0 if isempty(v) return x::Real -&gt; 0.0 end coeff = tuple(map(float, v)...) degree = length(coeff) - 1 function evpoly(z::Real) ans = coeff[end] for idx = degree:-1:1 ans = coeff[idx] + z * ans end return ans end evpoly end julia&gt; p = Polynomial_as_closure((0, 1, 1)) # x¬≤ + x (::getfield(Main, Symbol("#evpoly#28")){Tuple{Float64,Float64,Float64},Int64}) (generic function with 1 method) julia&gt; p(1) # ,    evpoly()! 2.0 julia&gt; p(11) 132.0</span></span></code> </pre><br>  Similarly, you can write a function for the interpolation polynomial. <br><br>  An important question: was there anything in the previous definition that was lost in the new one?  Unfortunately, yes - the task of a polynomial as a structure gave hints for the compiler, and for us the possibility of overloading arithmetic operators for this structure.  For the functions of such a powerful type system, Julia, alas, does not provide. <br><br>  Fortunately, in this case, we can take the best of both worlds, since Julia allows you to create so-called callable structs.  Those.  You can set a polynomial as a structure, but be able to call it as a function!  To the definitions of structures from the previous article you need only add: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (p::Polynomial)(z::<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>) evpoly(p, z) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> (p::InterpPolynomial)(z::<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>) evpoly(p, z) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  With the help of functional arguments, you can also add an external interpolation polynomial constructor for some function, built on a set of points: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> InterpPolynomial(fn, xsample::T) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> {T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}} InterpPolynomial(xsample, map(fn, xsample)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Check the definition</b> <div class="spoiler_text"><pre> <code class="julia hljs">julia&gt; psin = InterpPolynomial(sin, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>*<span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>]) <span class="hljs-comment"><span class="hljs-comment">#   InterpPolynomial(4, (0.0, 0.5235987755982988, 1.5707963267948966, 2.6179938779914944, 3.141592653589793), (0.0, 0.954929658551372, -0.30396355092701327, -0.05805276197975913, 0.036957536116863636)) julia&gt; pcos = InterpPolynomial(cos, [0, œÄ/6, œÄ/2, 5*œÄ/6, œÄ]) #   InterpPolynomial(4, (0.0, 0.5235987755982988, 1.5707963267948966, 2.6179938779914944, 3.141592653589793), (1.0, -0.2558726308373678, -0.36358673785585766, 0.1388799037738005, 5.300924469105863e-17)) julia&gt; psum = pcos + psin InterpPolynomial(4, (3.141592653589793, 2.5416018461576297, 1.5707963267948966, 0.5999908074321635, 0.0), (-1.0, -1.2354929267138448, 0.03888175053443867, 0.1969326657535598, 0.03695753611686364)) julia&gt; for x = range(0, œÄ, length = 20) println("Error at x = ", x, ": ", abs(psum(x) - (sin(x) + cos(x)))) end Error at x = 0.0: 0.0 Error at x = 0.3490658503988659: 0.002748366490382681 Error at x = 0.6981317007977318: 0.0031870524474437723 Error at x = 1.0471975511965976: 0.006538414090220712 Error at x = 1.3962634015954636: 0.0033647273630357244 Error at x = 1.7453292519943295: 0.003570894863996865 Error at x = 2.0943951023931953: 0.007820939854677023 Error at x = 2.443460952792061: 0.004305934583281101 Error at x = 2.792526803190927: 0.00420977797025246 Error at x = 3.141592653589793: 1.1102230246251565e-16</span></span></code> </pre><br></div></div><br><h4>  Conclusion </h4><br>  The features borrowed from functional programming in Julia give a greater expressiveness of the language compared to the purely imperative style.  Representation of structures in the form of functions is a way of more convenient and natural recording of mathematical concepts. </div><p>Source: <a href="https://habr.com/ru/post/451172/">https://habr.com/ru/post/451172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451160/index.html">Apache Kafka and Stream Processing with Spark Streaming</a></li>
<li><a href="../451162/index.html">Correction of errors - physical constants in the present and new versions of the International System of Units (SI)</a></li>
<li><a href="../451164/index.html">Looking for a free parking space with Python</a></li>
<li><a href="../451166/index.html">What will the new storages for AI and MO systems offer?</a></li>
<li><a href="../451170/index.html">Jeff Bezos announced plans to conquer the moon</a></li>
<li><a href="../451174/index.html">Adaptation programs for the ZX Spectrum to TR-DOS with modern tools. Part 1</a></li>
<li><a href="../451176/index.html">News from the world of OpenStreetMap ‚Ññ458 (04/23/2019-29.04.2019)</a></li>
<li><a href="../451178/index.html">Accident when testing the Crew Dragon parachute landing system</a></li>
<li><a href="../451180/index.html">PCB replaces two linear motors</a></li>
<li><a href="../451182/index.html">How the dimensions of C arrays became part of the library's binary interface</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>