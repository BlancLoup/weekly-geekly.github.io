<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Complicated Database</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The fact that the volume of data, the complexity of their structure, the complexity of the connections between them grow at an incredible pace, they h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Complicated Database</h1><div class="post__text post__text-html js-mediator-article">  The fact that the volume of data, the complexity of their structure, the complexity of the connections between them grow at an incredible pace, they have been writing on each fence for many years.  The question of what to do with this entire landfill usually hangs in the air.  Or, more precisely, rests on the concept of "data model". <a name="habracut"></a>  Although formally there are a lot of data models (network model of C. Bachmann, E. Codd's relational model, P. Chen's ER model, various object models, something specialized in temporal and spatial data, multidimensional cubes, etc.), all they, with the exception of the first two, are intended for presenting data to the end user and / or analyzing it by applied utilities, and at the data access level they rely on one of the basic (usually RMD). <br><br>  Nobody really knows what a data model is.  There are many definitions, but there is no universally accepted wording.  The author of the term ‚Äúdata model‚Äù, Edgar Codd (he is the author of the RMD), defines it as a combination of three components: <br><ol><li>  Collections of types of data objects that form the basic building blocks for any database of this model. </li><li>  Collections of general integrity rules that restrict a set of instances of these types of objects. </li><li>  Collections of operations applicable to such instances. </li></ol><br>  Modern definitions differ little from the above.  If we combine all the signs characterizing a concept into a general formulation, the definition looks like this: <i>‚ÄúA data model is a logical definition of objects, operators and rules, which together form an abstract data access machine for a user‚Äù.</i> <br><br>  Such a definition, in fact, does not mean anything at all.  No one.  Meanwhile, Christopher Date once said a wonderful phrase: <i>‚ÄúThe data model is a theory, or a modeling tool, while the database model (database schema) is the result of a simulation.</i>  <i>The relationship between these concepts is similar to the relationship between a programming language and a specific program in that language. ‚Äù</i>  As we see, Date, unwittingly, gave a completely brilliant definition of a data model, very compact and understandable even to a child: a model is a language! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now let's take a closer look at the two basic data models (Codd and Bachman), which, unlike other models, represent a fundamentally different view of the data. <br><br><h4>  Network model </h4><br>  The graph representation of the data (at first glance) is easy to implement on a computer and more naturally in many situations.  Websites, XML documents, relational and textual data can be modeled as a graph.  The universally recognized advantages of the network model are flexibility and variety of stored data structures, high access speed.  Its disadvantages include the need for element-by-element data processing, the greater complexity of developing procedures for their processing and, oddly enough, the complexity of modifying the database schema, due to the need to modify the edges of the graph when updating data or changing their structure. <br><br>  Perhaps the main complaints about the network model are that the logic of the data sampling procedure (supposedly) depends on their physical organization, and also that the integrity control of the data is weakened (supposedly) because of the admissibility of installing arbitrary links between elements.  These claims are valid only if the network model is its reference version, described in the report of the working group on database languages ‚Äã‚Äã(COnference on DAta SYstem Languages) CODASYL.  Meanwhile, the CODASYL approach is far from the only one: you can design many other implementations of the network model, including those that are free from most of the disadvantages attributed to it. <br><br>  It's funny, but the definition of the network data model was given by its main competitor, the same Codd.  Even more funny, when comparing these models so far, <b>abstract</b> RMD is contrasted to <b>specific</b> specifications of CODASYL (Codd himself called it ‚Äúcomparison of apples with oranges‚Äù!), Which is actually a scam and a degradation of the real possibilities of the network model, which can be much more serious competition RMD than now.  Unfortunately, this Kodd's ‚Äúslander‚Äù on the network model has got into almost all textbooks and is directly connected with the identification of the network model with the CODASYL approach.  If for the RDM <i>‚Äúobtaining physical access to a tuple is not a matter of the data model‚Äù</i> , then for the network model <i>‚Äúchanging the database structure requires a lot of effort and time, since the operations of modifying and deleting data require swapping the pointers‚Äù</i> is an obvious distortion.  Or one more thing: <i>‚ÄúPointers do not have to be presented at the physical storage level as pointers, however, users must treat them as real pointers - such is the network model.‚Äù</i>  Not "network model", but only an idea about her Codd! <br><br><h4>  Relational model </h4><br>  Since now almost all DBMSs are relational, it is natural to assume that the RDM has a number of important advantages (first of all, a high degree of data independence).  Especially since many clients find it convenient to present data in simple ways, with clear data structures and the usual Structured Query Language (SQL).  But there are many flaws in RMD too, and they are fairly obvious: the absence of direct references to the fields of the tuple, the indecently high level of costs for creating or upgrading the database schema, and changing the schema is sometimes impossible without abandoning old data, because  structural information in them is absent.  A widespread situation for real tabular data, when it is impossible to unambiguously identify an element according to its attributes, is simply forbidden in RMD.  A join operation on one or more attributes, the main mechanism used in the relational model to link data from different relationships, is always performed to the whole tuple, but not to its part.  Queries on multiple tables are executed for a very long time: conceptually, relational algebra operates with the concept of ‚ÄúCartesian product‚Äù, which is too expensive to use, therefore, different query optimization techniques are used.  Normal forms, hierarchical in nature, also limit the complexity of the supported data structures.  Meanwhile, the idea of ‚Äã‚ÄãCodd himself was that "when choosing logical data structures, there should be only one consideration - the convenience of the majority of users."  Such rigidity of the approach to the simplicity of data presentation (which all this time had a clear tendency to complication), supplemented by the appearance of normal forms, has already led to the situation that not a single (!) Real RDBMS actually supports RDBs.  In particular, the refusal to normalize tables became common. <br><br>  Codd himself promoted the three-valued logic (true, false, and NULL), and in 1990 even the four-valued logic, however, due to the high complexity (!) Of K. Date and H. Darwen's Third Manifesto, both ambiguous values ‚Äã‚Äãand many-valued logic are prohibited!  I quote: <br>  <i>Third manifesto</i> <i><br></i>  <i>H. Darwin and C. Date, Translation: M.R.</i>  <i>Kogalovsky</i> <i><br></i>  <i>RM bans</i> <i><br></i>  <i>4. Each attribute of each tuple of each relationship must have a value, which is a value from the corresponding domain.</i> <i><br></i>  <i>Comments (ibid.):</i> <i><br></i>  <i>In other words, no more ambiguous values ‚Äã‚Äãand no more multi-valued logic!</i> <br><br>  The tendency to simplify runs a red thread through the entire RMD, which inevitably leads to limitations and in the complexity of the data itself.  In other words, the data in the DDB is chronically primitive: at least no complicated structures can be kept there.  And neither the DBMS nor the database designers can bypass this limitation. <br><br>  Codd's goal is to ‚Äúmove application programming to a level where relationships are treated as operands, rather than processed elementwise.‚Äù  Remarkable goal: a language that allows you to work with sets is indisputably convenient.  The RMD, however, involves working <b>only</b> with sets: no tuple operations, a single tuple is just a special case of a set, the concept of a cursor is prohibited, etc.  And even in such ‚Äúshort pants‚Äù it becomes already close even to SQL ‚Äî the closest relative of the RMD, although in mathematics (and in SQL, with which relationals like Data struggle for life and death), the tuples are ordered, their duplicates are allowed.  Moreover, Codd himself originally defined tuples that way!  Waiver of the ordering is considered by Data as ‚Äúthe greatest contribution (!) Of Codd to the RMD‚Äù.  In OODB, however, for some reason, support for the individuality of objects is again required, i.e.  <i>"Objects must have a unique identifier that does not depend on the values ‚Äã‚Äãof their attributes</i> . <i>"</i>  Why?  Because the ‚Äúgreatest contribution‚Äù is complete fiction! <br><br>  Suppose we have an RDB consisting of only one relation.  Let's get an additional column, the values ‚Äã‚Äãof which will be the sequence numbers of tuples (from one).  The column names also set their sequence numbers (from scratch).  We define the zero column as the primary key (or ‚Äúsurrogate‚Äù, or ‚Äúsystem-generated‚Äù, as the authors of the Third Manifesto recommend ‚Äúvery strongly‚Äù).  Now we can access the columns and tuples by their number (as in SQL), but in strict accordance with the RMD.  What has changed?  We just lost the possibility of direct access to the fields and tuples (since the RM-prescriptions prohibit the ordering of attributes or tuples), and automatically ceased to be afraid of duplicate tuples and undefined values.  And where are the advantages of the fact that our attitude now perfectly meets the requirements of the Third Manifesto?  They are not!  Outside the RMD, we can refer to the tuples of this relation from others (or from itself) in the same way, we can calculate the physical address of the tuple by the surrogate key value (and control it if desired by the value of the zero column), i.e.  the foreign key really becomes a pointer.  Thus, concepts embodied in SQL are at least as good as RMD.  So why <i>‚Äúhopelessly follow the perversion of RDM, embodied in SQL‚Äù</i> , as Data wrote with Darwen?  Why should <i>‚Äúin order to withstand the test of time, we should unambiguously reject SQL‚Äù</i> ?  Something is wrong here! <br><br>  We believe that the abandonment of order is an inevitable consequence of the ‚Äústructural aspect‚Äù: RBD data is defined as a set of relationships, i.e.  primary element is a group.  A completely inevitable and terrible consequence of the lack of orderliness is also the concept of a key.  The concept of an identifier that is ‚Äúremoved from the data model in a‚Äú cheating ‚Äùmanner cannot in principle be removed from the RDBMS either; after all, even for a trivial reading of the key value, it is necessary to access the tuple in some other way.  As you can see, it is impossible to get rid of the concept of identifier - you can only pretend that it does not exist during group data processing.  In addition, talking about the speed of access to data with the concept of searching by key is a mockery of common sense.  However, the RMD was never interested in questions of implementation, of obtaining physical access to a tuple: it prescribes associative data access (based on values), and how this is implemented in a particular system is completely unimportant for the model. <br><br>  Database indexing not only does not provide direct access to data, but also causes a number of new problems.  Index maintenance for unstructured data is much more complicated than for relational data.  An attempt to index each element leads to the size of the indices, which is several times larger than the amount of the original data.  Indexing is too laborious (at worst) on strongly related graphs.  Thus, the indexes are too large to store, too resource intensive to build, and too complex to maintain.  Finally, and we see this as the main drawback, the data cease to be independent: the need to keep the indexes up to date automatically leads to the inheritance of all the problems of early graph databases, because  indexes are functionally equivalent to pointers. <br><br>  There is only one type of data access that is suitable for a real working DBMS, and it is called ‚Äúdirect‚Äù (and the key concept, by the way, is explicitly prohibiting it - unlike SQL).  <i>The third Manifesto: "RM-prescriptions and prohibitions cannot be the subject of compromise."</i>  Even the unfortunate cursor is "strictly forbidden", and more primitive navigation simply does not happen in nature!  RMD specifically forbids them to have, because the key concept immediately turns any navigation operations into a recursive SQL query: once the identifier tuples cannot have, we will have to scour the values, even if we call them the key.  And take out the obligatory primary key on the report, but put it.  And the same tuples can not start, it will be bad.  And no indexes, no crutches will save the ideologically defective design! <br><br><h4>  SQL </h4><br>  The relation to SQL for different users is very ambiguous, sometimes diametrically opposite.  Personally, I like his following characteristic: <i>"SQL is one of the poorest languages, the crooked offspring of Donald Chamberlain's associates."</i>  More precisely, their followers ‚Äî at least they understood that it was not a language: <i>‚ÄúThe development goal was to create a simple non-procedural language that could be used by any user, even without programming skills.‚Äù</i>  That is, it is a query language, and the end user!  To call it "programming language" then no one in a nightmare could dream!  And now the same Wiki blatantly asserts that <i>‚ÄúSQL can be called a programming language,‚Äù</i> shamefully adding that <i>‚Äúit is not turing-complete‚Äù.</i> <br><br>  Another phrase from the wiki: <i>‚ÄúSQL (structured query language) is a declarative programming language used to create, modify, and manage data in a relational database.</i>  <i>This is the only communication mechanism between application software and DDB. ‚Äù</i> <br><br>  Get stupid!  The decoding of the language itself says that it is the language of REQUESTS, and in the ‚Äúexplanation‚Äù it means that it is the language of PROGRAMMING! <br><br>  SQL standard.  Separate song.  First, it is indecently bloated in size with very weak language functionality (for example, the basic part of the SQL: 2003 standard consists of more than 1,300 pages of text).  Even the Great and Mighty C will require no more than a dozen pages!  And here what?  A single select statement?  What else?  CREATE - INSERT - DELETE - UPDATE?  GRANT - REVOKE?  COMMIT - ROLLBACK - SAVEPOINT?  Do not tell my slippers! <br><br>  Versions of the standard language of the great set.  They tried to push the graph emulation (the concept of primary and foreign keys), integrity control (poor to indecency) and somehow extend the functionality (support of regular expressions, recursive queries, triggers, non-scalar data types, some object-oriented features, extensions for working with XML data, window functions, the ability to share in SQL queries and XQuery, etc.), but without much success.  In addition, different DBMS vendors use different SQL dialects, which are generally incompatible with each other.  At the moment, all efforts to verify the DBMS for compliance with the standard fall on its manufacturer. <br><br>  SQL is not a true relational language: it resolves duplicate rows in tables, which in the framework of the relational data model (by the way, even more miserable than SQL) is impossible and unacceptable, supports null values ‚Äã‚Äã(NULL) and multi-valued logic, uses the order of columns and column references by numbers, resolves unnamed columns and duplicate column names.  Theorists such as Data and Darwen swear at him for this, which, in general, is understandable: it is well known from the school biology course that ‚Äúthe intraspecific struggle is the most cruel.‚Äù <br><br>  SQL initially did not offer any ways of manipulating even hierarchical structures, let alone general graphs.  Even recursive queries (which give an exponential slowdown in performance with an increase in the depth of connections) appeared in Microsoft SQL Server only in version 2005. SQL is not a familiar procedural programming language (that is, it does not provide means for building loops, branching, etc.), therefore DBMS vendors introduce various procedural extensions ‚Äî stored procedures and procedural languages ‚Äã‚Äã‚Äî add-ins.  Practically every DBMS uses its own procedural language (Oracle - PL / SQL, Interbase and Firebird - PSQL, in DB2 - SQL PL, in MS SQL Server - Transact-SQL, in PostgreSQL - PL / pgSQL, etc.).  And what for we standardize SQL with its actually unique SELECT statement, which, moreover, can hardly do anything? <br><br>  The remaining SQL tricks are inherited from the relation: a rigid and immutable database schema, tables for stored data structures, and no access speed (key concept).  The degree of data independence is really high, but it is precisely in this gap that data shoals crawl in the data, most of which users and database owners do not even suspect. <br><br><h4>  NoSQL </h4><br>  Recently, the term ‚ÄúNoSQL‚Äù has become very fashionable and popular, all sorts of software solutions under this sign are being actively developed and promoted, all sorts of ‚Äúsmart words‚Äù, like ‚Äúlinear scalability‚Äù, ‚Äúclusters‚Äù, ‚Äúfault tolerance‚Äù, non-relationality, are spoken. ‚ÄùNoSQL repository caught on as the main database for Instagram and Facebook social networks, but no ‚ÄúNoSQL revolution‚Äù happened - the relational databases consistently hold dominant positions. And the point is not even in the most powerful "relational lobby", but in the fact that this product  it‚Äôs quite raw, it lacks a lot of basic things - universality, reliability, integrity and predictability. Therefore, the interpretation of the term ‚ÄúNoSQL‚Äù is increasingly shifting towards ‚ÄúNot Only SQL‚Äù, although initially it was even suggested that ‚ÄúNonRel‚Äù as an alternative, but quickly calmed down and now more than 90% of existing databases and databases are built on the relational principle, which is based on a tabular data composition scheme - especially considering that the overwhelming majority of other solutions, although called NoSQL, actually operate with tabs anyway  by individuals.  Data both there and there IDEOLOGICALLY tabular!  In full accordance with the first of the ‚Äú12 Codd Rules‚Äù, which says: <i>‚ÄúAll information in a relational database at the logical level must be clearly represented in a single way: values ‚Äã‚Äãin tables‚Äù.</i> <br><br><h4>  Great Controversy </h4><br>  Today, thoroughly forgotten, the Great Controversy between Codd and Bachmann took place in 1974 at the ACM SIGMOD seminar, where each of the speakers sought to show the advantages of their approach.  Then contemporaries said that the dispute ended in a draw, because none of those present (including the debaters themselves) did not understand anything.  Now, in hindsight, it is considered that Codd won, because the actual DBMSs are now almost all relational.  But so far, as an echo of this dispute, when talking about data models they oppose element-by-element and group data processing.  In fact, such an opposition is simply nonsense. <br><br>  A commonly used (although not always explicitly defined) term in all models is the field ‚Äî the smallest, indivisible, atomic data element of a given type.  In this case, the term ‚Äúdata type‚Äù can carry a very diverse semantic load: it can determine the amount of memory occupied by an element, the set of acceptable values, the set of operations associated with this type, the device descriptor, the connection with other elements, and much more.  In addition to atomic, there are also data elements that are groups of fields, called by different authors "segments", "sets" and other terms.  There are two types of groups of homogeneous elements: an array (a set of elements of a given size) and a string (the size of this group is determined by the predetermined value of the terminator).  Groups of heterogeneous elements actually differ from each other only by name: node (graph model), tuple (relational model), class (object approach), structure (programming languages). <br><br>  After agreeing on the terms, it is easy to see all the absurdity of the subject of the Great Dispute: the problem is not at all in comparing the specific descriptions of CODASYL and abstract RMD.  And not that comparing the tabular and graphical representation of the data - in the end, it is just an abstraction.  And not in the fundamental differences between the concepts of a key and an index is only a direct consequence of the main mistake: the comparison of groups with atomic elements.  In the RMD, the primary element is a table, i.e.  Group.  But if we define the relation as an ‚Äúarray of tuples,‚Äù and the tuple itself as a ‚Äúcollection of fields,‚Äù then, indeed, it will be possible to make a real comparison of the fields and tuples of the RMD with nodes and edges of the network model. <br><br>  Now we will repeat an attempt to compare these two models, bearing in mind that a node can contain not only an atomic element, but also a structure, and the term tuple is equivalent to struct (that is, a member of a group can also be a group).  After that, we will not only be able to correctly compare data models, but also automatically obtain an object data model instead of relational (although at the cost of destroying relational algebra).  And such a comparison would not be in favor of the RMD: we will immediately see a set of unnecessarily stringent restrictions on the complexity of the data in the relationship.  In fact: why is it allowed to complete only homogeneous elements in a single relationship?  Why it is impossible to address directly to the internal elements of the tuple?  Why is a tuple not allowed to have its own data-independent identifier?  Why should we rest on this unfortunate concept of a ‚Äúkey‚Äù?  For which faults we were forbidden to have structures in a tuple more complex than a single-level tree?  And why do we need this Procrustean bed of normal forms?  For what?  For the sake of simplifying the formal apparatus of relation algebra and relational calculus?  And who actually needs them?  DBMS developers?  Administrators?  Users? <br><br>  If, on the contrary, we bring the terminology of the network model to the relational one (the primary element is a lot), we will also get the opportunity to correctly compare the two models, and it will again not be in favor of the RMD!  We will need to explicitly register links to the relevant metadata, since       ( , ,   )    .   ,          :    ,  ..       ,    ()    (,      ).     (   )            .  Fairy tale! <br><br><h4>  Search for information </h4><br>         ,      ,       . ,         ,     (-  FIND.CURRENT.ALL),         ( -  !)     .        .  ,  ‚Äî     ¬´¬ª,     ,   ,   ,    ,    ,       . ,      ‚Äî      ,   . <br> <i><b>:</b>    ¬´¬ª.   -   (  ),       : , , , ,  ,    , -,    (  ).       !</i> <br><br><h4>  </h4><br> ,   ,            ,      .         ( ),    ¬´  ¬ª   ¬´  ¬ª (   ),       ¬´ ¬ª  .   ,     -       , ,  ,        .  :         B (   b).      ! <br><br>       .   ‚Äî      : <i>¬´       (  ) ‚Äî      ,     ¬ª.</i> ?      !  ?   !       (  ). <br><br>    :   ,     ,         (, , ,     )   .     ,     . ,               .      ‚Äî    ,       ! <br><br><h4>  Conclusion </h4><br>     ¬´ ¬ª  ¬´ ¬ª  <b></b> ,  <b></b>         .    ,           ,       ,     .    ¬´   ¬ª,      ,        ?      :  <b></b> ! <br><br>        , , ,       ,    ,   ,       (),  .. ,         ¬´¬ª .     CODASYL,   ¬´--¬ª.        ,      ,   , ,    ,    ()     .    ,   ,      ,     .         ,   .          .       ,       ,  /     .        . ,    (BOOLEAN, FLOAT, URL)   ‚Äî       (   )     ,       .      (TUPLE, ENUM, RELATION)   ‚Äî  ,  !     (    ),      (    ). ,  ADDRESS      (, , , , )    ( -&gt;  -&gt;  -&gt;  -&gt; ).           ,       ADDRESS      :        , : ¬´     ¬ª. <br><br> ,    ,         ,          .        ¬´¬ª       ()        .           :       ¬´¬ª    ,   ,         .     ,       ,      ,    ,     ¬´¬ª   . <br><br>            :    ,    .       -      .           -        .     ,             (    ),     CODASYL (   ,                   ).            .     -        ,  -   !     ! </div><p>Source: <a href="https://habr.com/ru/post/454194/">https://habr.com/ru/post/454194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454184/index.html">KubeCon Europe 2019: How we first visited the main event on Kubernetes</a></li>
<li><a href="../454186/index.html">Create streaming processing pipeline. Part 1</a></li>
<li><a href="../454188/index.html">Alternative recruitment channels</a></li>
<li><a href="../45419/index.html">The .NET Framework will be available on Server Core R2</a></li>
<li><a href="../454190/index.html">What not to do if your phone was stolen</a></li>
<li><a href="../454196/index.html">3D printing of electronics on the example of a drone: wires and boards are no longer needed</a></li>
<li><a href="../454198/index.html">Creation of multi-module Gradle project SpringBoot + Angular in IDEA</a></li>
<li><a href="../4542/index.html">Seven Tips for Choosing a Name for a Web 2.0 Startup</a></li>
<li><a href="../454204/index.html">Behavioral crawling - not a panacea?</a></li>
<li><a href="../454206/index.html">PHDays 9: AI CTF Parsing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>