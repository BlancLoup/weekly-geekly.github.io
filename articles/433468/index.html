<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fault Injection: your system is unreliable if you have not tried to break it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! My name is Pavel Lipsky. I am an engineer, I work in the company Sberbank-Technology. My specialization is testing the fault tolerance and p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fault Injection: your system is unreliable if you have not tried to break it</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  My name is Pavel Lipsky.  I am an engineer, I work in the company Sberbank-Technology.  My specialization is testing the fault tolerance and performance of backends of large distributed systems.  Simply put, I break other people's programs.  In this post I will talk about fault injection - a testing method that allows you to find problems in the system by creating artificial failures.  To begin with, I came to this method, then we will talk about the method itself and how we use it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/593/a93/c50593a934415805dac00c5de3a07390.png"></div><a name="habracut"></a><br>  The article will be examples in Java.  If you don‚Äôt program in Java, that's okay, it‚Äôs enough to understand the approach and the basic principles.  Apache Ignite is used as a database, but the same approaches are applicable to any other DBMS.  All examples can be downloaded from my <a href="https://github.com/leapsky/FaultInjectionExamples">GitHub</a> . <br><br><h2>  Why do we need all this? </h2><br>  I'll start with the story.  In 2005, I worked at Rambler.  By that time, the number of Rambler users was rapidly growing, and our two-tier architecture ‚Äúserver - database - server - applications‚Äù could no longer cope.  We thought about how to solve performance problems, and paid attention to memcached technology. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/e4e/907/91e/e4e90791ef24ecaba4ec24a941f6e5ce.png" width="600" height="278"><br><br>  What is memcached?  Memcached is a hash table in RAM with access to stored objects by key.  For example, you need to get a user profile.  The application is drawn to memcached (2).  If there is an object in it, then it is immediately returned to the user.  If there is no object, then the database is accessed (3), the object is formed and put into memcached (4).  Then, during the next call, we no longer need to make a resource-intensive call to the database ‚Äî we will get the finished object from the RAM - memcached. <br><br>  Due to memcached, we noticeably unloaded the database, and our applications started to work much faster.  But, as it turned out, it was too early to rejoice.  Along with the increase in productivity, we have new problems. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42c/4f9/c03/42c4f9c03bf3a365e19b4cda2dc6562b.png" width="600" height="277"><br><br>  When you need to change data, the application first makes a correction to the database (2), creates a new object and then tries to put it into memcached (3).  That is, the old object must be replaced with a new one.  Imagine that at that moment a terrible thing happens - the connection between the application and memcached is broken, the memcached server or even the application itself crashes.  This means that the application could not update the data in memcached.  As a result, the user goes to the site page (for example, his profile), sees the old data and does not understand why this happened. <br><br>  Was it possible to detect this bug during functional testing or performance testing?  I think that, most likely, we would not have found it.  To search for such bugs there is a special type of testing - fault injection. <br><br>  Usually during fault injection testing there are bugs, which are popularly called <i>floating</i> .  They appear under load, when more than one user is working in the system, when abnormal situations occur - equipment fails, electricity is cut off, the network fails, etc. <br><br><h2>  New IT system of Sberbank </h2><br>  A few years ago, Sberbank began building a new IT system.  What for?  Here are the statistics from the Central Bank website: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/32c/1ab/05232c1ab18a23996d9172fcdc05d970.png" width="600" height="229"><br><br>  The green part of the column is the number of cash withdrawals at ATMs, the blue part is the number of transactions for payment for goods and services.  We see that the number of non-cash transactions is growing from year to year.  After a few years, we will have to be able to handle the growing workload and continue to offer new services to customers.  This is one of the reasons for creating a new IT system for Sberbank.  In addition, we would like to reduce our dependence on Western technologies and expensive mainframes, which cost millions of dollars, and switch to open source technologies and a low-end server. <br><br>  Initially, we laid the foundation for Apache Ignite technology at the heart of Sberbank.  More precisely, we use the paid Gridgain plugin.  The technology has a fairly rich functionality: combines the properties of a relational database (there is support for SQL queries), NoSQL, distributed processing and data storage in RAM.  Moreover, when you restart the data that were in RAM, will not be lost.  Starting with version 2.1, Apache Ignite introduced Apache Ignite Persistent Data Store distributed disk storage with SQL support. <br><br>  I will list some features of this technology: <br><br><ul><li>  Storage and processing of data in RAM <br></li><li>  Disk storage <br></li><li>  SQL support <br></li><li>  Distributed task execution <br></li><li>  Horizontal scaling <br></li></ul><br>  The technology is relatively new, and therefore requires special attention. <br><br>  The new IT system of Sberbank physically consists of many relatively small servers assembled into one cluster-cloud.  All nodes are identical in structure, equal to each other, perform the function of storing and processing data. <br><br>  Inside the cluster is divided into so-called cells.  One cell is 8 nodes.  Each data center has 4 nodes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a6/e18/2da/7a6e182daba502a73800093e18e1b4f7.png" width="600" height="343"><br>  Since we use Apache Ignite, in-memory data grid, then, accordingly, all this is stored in server-distributed caches.  And the caches, in turn, are divided into identical pieces - partitions.  On the servers they are presented as files.  Partitions of the same cache can be stored on different servers.  For each partition in the cluster there are primary (primary node) and backup nodes (backup node). <br><br>  The main nodes store the main partitions and process requests for them, replicate data to the backup nodes (backup node), where backup partitions are stored. <br><br>  When designing the Sberbank architecture, we came to the conclusion that the system components can and will fail.  Say, if you have a cluster of 1000 iron low-end servers, then from time to time you will have hardware failures.  RAM strips, network cards and hard drives, etc. will fail.  We will consider this behavior as completely normal behavior of the system.  Such situations should be handled correctly and our clients should not notice them. <br><br>  But it is not enough to design the system's stability to failure, it is necessary to test the systems during these failures.  As the well-known distributed systems researcher Caitie McCaffrey of Microsoft Research says: ‚ÄúYou will never know how the system behaves during an abnormal situation until you reproduce the failure.‚Äù <br><br><h2>  Lost updates </h2><br>  Let us examine a simple example, a banking application that simulates money transfers.  The application will consist of two parts: the Apache Ignite server and the Apache Ignite client.  The server part is a data storage. <br><br>  The client application connects to the Apache Ignite server.  Creates a cache, where the key is the account ID, and the value is the account object.  A total of ten such objects will be stored in the cache.  In this case, initially for each account we put $ 100 (so that there was something to transfer).  Accordingly, the total balance of all accounts will be equal to $ 1,000. <br><br><pre><code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Integer, Account&gt; cache = ignite.getOrCreateCache(cfg)) {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= ENTRIES_COUNT; i++)       cache.put(i, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Account(i, <span class="hljs-number"><span class="hljs-number">100</span></span>));   System.out.println(<span class="hljs-string"><span class="hljs-string">"Accounts before transfers"</span></span>);   printAccounts(cache);   printTotalBalance(cache);   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pairOfAccounts[] = getPairOfRandomAccounts();       transferMoney(cache, pairOfAccounts[<span class="hljs-number"><span class="hljs-number">0</span></span>], pairOfAccounts[<span class="hljs-number"><span class="hljs-number">1</span></span>]);   } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IgniteCache&lt;Integer, Account&gt; cache, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{   Account fromAccount = cache.get(fromAccountId);   Account toAccount = cache.get(toAccountId);   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance);   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;   }   fromAccount.withdraw(amount);   toAccount.deposit(amount);   cache.put(fromAccountId, fromAccount);   cache.put(toAccountId, toAccount); }</code> </pre> <br><br>  Then we make 100 random money transfers between these 10 accounts.  For example, from account A to another account B, $ 50 is transferred.  Schematically, this process can be depicted as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/526/dc8/626/526dc86262d11f823d0aabce90c2c429.png"><br><br>  The system is closed, transfers are made only inside, i.e.  The total balance must remain at $ 1000. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6d/afe/366/f6dafe3664e4f55c07515fde18d0e92e.png" width="600" height="268"><br><br>  Run the application. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/S8_UMhMwhb0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  We received the expected total balance value of $ 1000.  Now let's complicate our application a bit - let's make it multitask.  In reality, several client applications can work simultaneously with the same account.  We will launch two tasks that will simultaneously make money transfers between ten accounts. <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC); cfg.setCacheMode(CacheMode.PARTITIONED); cfg.setIndexedTypes(Integer.class, Account.class); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Integer, Account&gt; cache = ignite.getOrCreateCache(cfg)) {  <span class="hljs-comment"><span class="hljs-comment">// Initializing the cache.  for (int i = 1; i &lt;= ENTRIES_COUNT; i++)    cache.put(i, new Account(i, 100));  System.out.println("Accounts before transfers");  System.out.println();  printAccounts(cache);  printTotalBalance(cache);  IgniteRunnable run1 = new MyIgniteRunnable(cache, ignite,1);  IgniteRunnable run2 = new MyIgniteRunnable(cache, ignite,2);  List&lt;IgniteRunnable&gt; arr = Arrays.asList(run1, run2);  ignite.compute().run(arr); } ... private void transferMoney(int fromAccountId, int toAccountId) {  Account fromAccount = cache.get(fromAccountId);  Account toAccount = cache.get(toAccountId);  int amount = getRandomAmount(fromAccount.balance);  if (amount &lt; 1) {      return;  }  int fromAccountBalanceBeforeTransfer = fromAccount.balance;  int toAccountBalanceBeforeTransfer = toAccount.balance;  fromAccount.withdraw(amount);  toAccount.deposit(amount);  cache.put(fromAccountId, fromAccount);  cache.put(toAccountId, toAccount); }</span></span></code> </pre><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3RPeJlYNDFg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The total balance is $ 1296.  Customers are happy, the bank is suffering losses.  Why did this happen? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed1/636/2fd/ed16362fd78ed83f0ecb703941eb2596.png"><br><br>  Here we see how two tasks simultaneously change the state of account A. But the second task manages to record its changes before the first one does.  Then the first task records its changes, and all changes made by the second task disappear immediately.  This anomaly is called the problem of lost updates. <br><br>  In order for the application to work as needed, it is necessary that our database supports ACID transactions and our code takes this into account. <br><br>  Let's look at the ACID properties for our application to see why this is so important. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/210/b47/f2f210b470dc23068ac49e0b68b54de3.png" width="315" height="315"><br><br><ul><li>  <i>A - Atomicity, atomicity.</i>  Either all proposed changes will be made to the database, or nothing will be entered.  That is, if between steps 3 and 6 we had a failure, the changes should not get into the database <br></li><li>  <i>C - Consistency, integrity.</i>  After completing the transaction, the database must remain in a consistent state.  In our example, this means that the sum of A and B should always be the same, the total balance is $ 1000. <br></li><li>  <i>I - Isolation, isolation.</i>  Transactions should not affect each other.  If one transaction makes a transfer, and the other receives the value of account A and B after step 3 and before step 6, she thinks that the system has less money than necessary.  There are nuances here that I will focus on later. <br></li><li>  <i>D - Durability, stability.</i>  After the transaction has recorded changes in the database, these changes should not disappear as a result of failures. <br></li></ul><br>  So, in the transferMoney method, we will make a money transfer within a transaction. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart()) {      Account fromAccount = cache.get(fromAccountId);      Account toAccount = cache.get(toAccountId);      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fromAccountBalanceBeforeTransfer = fromAccount.balance;      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> toAccountBalanceBeforeTransfer = toAccount.balance;          fromAccount.withdraw(amount);      toAccount.deposit(amount);          cache.put(fromAccountId, fromAccount);      cache.put(toAccountId, toAccount);          tx.commit();  } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){      e.printStackTrace();  } }</code> </pre><br>  Run the application. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pEgyqAUAvM8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hm  Transactions did not help.  Total balance - $ 6951!  What is the problem with this behavior of the application? <br><br>  First, we chose the ATOMIC cache type, i.e.  without ACID transaction support: <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.TOMIC);</code> </pre> <br>  Secondly, the txStart method has two important parameters of the enum type, which it would be good to indicate: the blocking method (concurrency mode in Apache Ignite) and the isolation level.  Depending on the values ‚Äã‚Äãof these parameters, a transaction may read and write data in different ways.  In Apache Ignite, these parameters are set as follows: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart( ,  )) { Account fromAccount = cache.get(fromAccountId); Account toAccount = cache.get(toAccountId); ...  tx.commit(); }</code> </pre><br>  You can use PESSIMISTIC (pessimistic blocking) or OPTIMISTIC (optimistic blocking) as the value of the BLOCK METHOD parameter.  They differ in the moment of imposing of blocking.  When using PESSIMISTIC, the lock is imposed at the first reading / writing and is held until the transaction is committed.  For example, when a transaction with a pessimistic blocking makes a transfer from account A to account B, other transactions can neither read nor write the values ‚Äã‚Äãof these accounts until the transaction making the transfer is committed.  It is clear that if other transactions want to access accounts A and B, they have to wait for the transaction to complete, which has a negative effect on the overall performance of the application.  Optimistic locking does not limit access to data for other transactions, however, during the preparation phase of the transaction for commit (prepare phase, Apache Ignite uses the 2PC protocol), it will be checked whether the data was changed by other transactions?  And if changes took place, the transaction will be canceled.  In terms of performance, OPTIMISTIC will work faster, but is more suitable for applications where there is no competitive work with data. <br><br>  The INSULATION LEVEL parameter determines the degree of transaction isolation from each other.  The ANSI / ISO SQL standard defines 4 types of isolation, and for each isolation level the same transaction scenario can lead to different results. <br><br><ul><li>  READ_UNCOMMITED - the lowest level of isolation.  Transactions can see "dirty" uncommitted data. <br></li><li>  READ_COMMITTED - when a transaction sees inside itself only private data <br></li><li>  REPEATABLE_READ - means that if a read is performed within a transaction, this read must be repeatable. <br></li><li>  SERIALIZABLE - this level assumes the maximum degree of transaction isolation - as if there are no other users in the system.  The result of the work of concurrently running transactions will be as if they were executed in turn (orderly).  But together with a high degree of isolation, we get a decrease in performance.  Therefore, we must carefully approach the choice of this level of isolation. <br></li></ul><br>  For many modern DBMSs (Microsoft SQL Server, PostgreSQL and Oracle), the default isolation level is READ_COMMITTED.  For our example, this would be fatal, since it would not protect us from lost updates.  The result will be the same as if we did not use transactions at all. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32a/a26/0a6/32aa260a65aa3ad758dbecc220eef231.png"><br><br>  From the <a href="https://apacheignite.readme.io/docs/concurrency-modes-and-isolation-levels">Apache Ignite transaction documentation</a> , it follows that such combinations of blocking method and isolation level are suitable for us: <br><br><ul><li>  <b>PESSIMISTIC REPEATABLE_READ</b> - a lock is imposed when you first read or write data and is held until it is complete. <br></li><li>  <b>PESSIMISTIC SERIALIZABLE</b> - works in the same way as PESSIMISTIC REPEATABLE_READ <br></li><li>  <b>OPTIMISTIC SERIALIZABLE</b> - the version of the data obtained after the first reading is remembered, and if this version is different in the preparation phase for fixing (the data was changed by another transaction), then the transaction will be canceled.  Let's try this option. <br></li></ul><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart(OPTIMISTIC, SERIALIZABLE)) { Account fromAccount = cache.get(fromAccountId); Account toAccount = cache.get(toAccountId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fromAccountBalanceBeforeTransfer = fromAccount.balance; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> toAccountBalanceBeforeTransfer = toAccount.balance; fromAccount.withdraw(amount); toAccount.deposit(amount); cache.put(fromAccountId, fromAccount); cache.put(toAccountId, toAccount); tx.commit(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ e.printStackTrace(); } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/vPZcW7qbvvs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hurray, received $ 1000, as expected.  From the third attempt. <br><br><h2>  We test under load </h2><br>  Now we will make our test more realistic - we will test under load.  And add an additional server node.  There are many tools for load testing, in Sberbank we use HP Performance Center.  This is quite a powerful tool, supports more than 50 protocols, is designed for large teams and costs a lot of money.  I wrote my example on JMeter - it is free and solves our problem 100%.  I wouldn‚Äôt like to rewrite Java code, so I‚Äôll use the JSR223 sampler. <br><br>  Let's create a JAR archive from the classes of our application and load it into a test plan.  To create and fill the cache, run the class CreateCache.  After initializing the cache, you can run the JMeter script. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/i7jUnyfz_88" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  All cool, got $ 1000. <br><br><h2>  Emergency stop of the cluster node </h2><br>  Now we will be more destructive: during the operation of the cluster, we will abort one of the two server nodes.  Through the Visor utility, which is included in the Gridgain distribution, we can monitor the Apache Ignite cluster and make different data samples.  In the SQL Viewer tab, we execute a SQL query to get the total balance for all accounts. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/phUdYiMrPLg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  What is the result?  553 dollars.  Customers are terrified, the bank suffers a reputational loss.  What did we do wrong this time? <br><br>  It turns out that Apache Ignite has cache types: <br><br><ul><li>  partitioned - one or several backup copies are stored within the cluster <br></li><li>  replicated caches - all partitions (all cache pieces) are stored within one server.  Such caches are suitable primarily for reference books - something that rarely changes and is often read. <br></li><li>  local - all on one site <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/032/23e/360/03223e3607e052fe4f0e3f24aca15837.png" width="600" height="344"><br><br>  We will frequently change our data, so we will select a partitioned cache and add an additional backup to it.  That is, we will have two copies of the data - the main and backup. <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL); cfg.setCacheMode(CacheMode.PARTITIONED); cfg.setBackups(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Run the application.  I remind you that before transfers we have $ 1000.  We launch and, during operation, ‚Äúextinguish‚Äù one of the nodes <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Y0C9eaTXFk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In the Visor utility, we make a SQL query to get the total balance - $ 1000.  Everything worked great! <br><br><h2>  Reliability cases </h2><br>  Two years ago, we were just starting to test the new IT system of Sberbank.  Somehow we went to our support engineers and asked: what could possibly break?  We were answered: everything can break, test everything!  Of course, this answer did not suit us.  We sat down together, analyzed the statistics of failures and realized that the most likely case we could encounter was node failure. <br><br>  Moreover, this can happen for completely different reasons.  For example, it may fail an application, crash the JVM, crash the OS, or fail the hardware. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/ea2/035/68cea2035db5f01d47e48943a2c8797a.png" width="600" height="197"><br><br>  We divided all possible cases of failures into 4 groups: <br><br><ol><li>  Equipment <br></li><li>  Network <br></li><li>  Software <br></li><li>  Other <br></li></ol><br>  They invented tests for them and called them reliability cases.  A typical case of reliability consists of a description of the state of the system before the tests, the steps to reproduce the failure, and a description of the expected behavior during the failure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/bc5/484/201bc5484c7811d1a70bb8da502e3ad9.png" width="600" height="313"><br><br><h4>  Reliability cases: equipment </h4><br>  This group includes such cases as: <br><br><ul><li>  Power failure <br></li><li>  Complete loss of access to the hard disk <br></li><li>  Failure of one hard disk access path <br></li><li>  CPU, RAM, disk, network load <br></li></ul><br>  The cluster stores 4 identical copies of each partition: one main partition (primary) and three backup partitions (backup).  Suppose, due to a hardware failure, a node is coming out of the cluster.  In this case, the main partitions should move to the other surviving nodes. <br><br>  What else can happen?  Loss of rack in the cell. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44d/2b8/132/44d2b81324d9a0d91ee63a5508652456.png" width="600" height="251"><br><br>  All nodes in the cell are in different racks.  Those.  rack output will not cause cluster failure or data loss.  We will have three copies of the four.  But even if we lose the whole data center, this also will not be a big problem for us, because  we still have two copies of the data from four. <br><br>  Part of the cases are performed directly in the data center itself, with the participation of maintenance engineers.  For example, shutting down the hard drive, turning off the power to the server or rack. <br><br><h4>  Reliability Cases: Network </h4><br>  To test cases related to network fragmentation, use iptables.  And with the help of the utility NetEm we emulate: <br><br><ul><li>  network delays with different distribution functions <br></li><li>  packet loss <br></li><li>  repeat packets <br></li><li>  reordering of packets <br></li><li>  packet distortion <br></li></ul><br>  Another interesting network case we are testing is split-brain.  This is when all cluster nodes are live, but due to network segmentation they cannot communicate with each other.  The term came from medicine and means that the brain is divided into two hemispheres, each of which considers itself unique.  The same can happen with a cluster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/cc0/58e/778cc058e68e7d552b612f9389af7499.png"><br>  It happens that the connection between the data centers is lost.  For example, last year, due to damage to the fiber optic cable by an excavator, the client of the banks ‚ÄúTochka‚Äù, ‚ÄúOtkritie‚Äù and ‚ÄúRoketbank‚Äù did not perform operations over the Internet for several hours, the terminals did not accept cards and the ATMs did not work.  About this accident, a lot has been written to Twitter. <br><br>  In our case, the split-brain situation should be handled correctly.  The grid identifies the split-brain - the division of a cluster into two parts.  One of the halves is translated into read mode.  This is half where there are more live nodes or there is a coordinator (the oldest node in the cluster). <br><br><h4>  Reliability Cases: Software </h4><br>  These are cases related to the failure of various subsystems: <br><br><ul><li>  DPL ORM - data access module, type Hibernate ORM <br></li><li>  Intermodular transport - messaging between modules (microservices) <br></li><li>  Logging system <br></li><li>  Access granting system <br></li><li>  Apache Ignite Cluster <br></li><li>  ... <br></li></ul><br>  Since most of the software is written in Java, we are subject to all the problems inherent in Java applications.  Tests various garbage collector settings.  We perform tests with the fall of the java virtual machine. <br><br>  For the Apache Ignite cluster, there are special cases for off-heap - this is such a memory area that Apache Ignite controls.  It is much more than java heap and is intended for storing data and indexes.  Here you can, for example, test overflow.  We overflow the off-heap and see how the cluster works in the case where some of the data did not fit into the RAM, i.e.  read from disk. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d97/cb0/29a/d97cb029adf7075f155c3f68332b3a80.png" width="600" height="374"><br><br><h4>  Other cases </h4><br>  These are cases that are not included in the first three groups.  These include utilities that allow you to recover data in the event of a major crash or when migrating data to another cluster. <br><br><ul><li>  The utility for creating snapshots (backup) of data is testing full and incremental snapshots. <br></li><li>  Recovery to a specific point in time is the PITR (Point in-time recovery) mechanism. <br></li></ul><br><h2>  Utilities for fault injection </h2><br>  I recall a <a href="https://github.com/leapsky/FaultInjectionExamples">link</a> to examples from my report.  You can download the Apache Ignite distribution from the official site - <a href="https://ignite.apache.org/download.cgi">Apache Ignite Downloads</a> .  And now I will share the utilities that we use at Sberbank, if you are suddenly interested in the topic. <br><br>  Framework: <br><br><ul><li>  <a href="https://github.com/jepsen-io/jepsen">Jepsen</a> <br></li><li>  <a href="https://github.com/Netflix/SimianArmy/wiki/Chaos-Monkey">Chaos monkey</a> <br></li></ul><br>  Configuration Management: <br><br><ul><li>  <a href="https://docs.ansible.com/">Ansible</a> <br></li><li>  <a href="https://puppet.com/">Puppet</a> <br></li></ul><br>  Linux Utilities: <br><br><ul><li>  <a href="https://wiki.linuxfoundation.org/networking/netem">NetEm (tc)</a> <br></li><li>  <a href="https://manned.org/stress-ng/fd34c972">stress-ng</a> <br></li><li>  <a href="https://iperf.fr/">Iperf</a> <br></li><li>  kill -9 <br></li><li>  iptables <br></li></ul><br>  Load testing tools: <br><br><ul><li>  <a href="https://jmeter.apache.org/">JMeter</a> <br></li></ul><br>  And in the modern world, and in Sberbank, all changes occur dynamically and it is difficult to predict which technologies will be used in the next couple of years.  But I know for sure that we will use the Fault Injection method.  The universal method is suitable for testing any technologies, it really works, it helps to catch a lot of bugs and make the products that we develop better. </div><p>Source: <a href="https://habr.com/ru/post/433468/">https://habr.com/ru/post/433468/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433458/index.html">Some unobvious Serverless benefits for DevOps</a></li>
<li><a href="../433460/index.html">Simplify build builds in Unity3D</a></li>
<li><a href="../433462/index.html">Performance checks and gradual degradation of distributed systems</a></li>
<li><a href="../433464/index.html">Subcosmic race</a></li>
<li><a href="../433466/index.html">Compare pages. Simple plugin for Atlassian Confluence</a></li>
<li><a href="../433472/index.html">Unity 2018.3 has been released</a></li>
<li><a href="../433474/index.html">Pylint from the inside. How he does it</a></li>
<li><a href="../433476/index.html">50 shades of celery</a></li>
<li><a href="../433480/index.html">Holivarny story about the linter</a></li>
<li><a href="../433486/index.html">What's again? Reviving Non-Bank Debit Cards</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>