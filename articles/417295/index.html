<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Summary of the previous parts 
 Due to limitations on the ability to use C ++ 11 compilers and from the lack of alternatives to boost, there was a des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 3</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="We continue the adventure." width="300" height="350" align="left"><h3>  Summary of the previous parts </h3><br>  Due to limitations on the ability to use C ++ 11 compilers and from the lack of alternatives to boost, there was a desire to write our own implementation of the C ++ 11 standard library on top of the C ++ 98 / C ++ 03 library supplied with the compiler. <br><br>  Were implemented <b>static_assert</b> , <b>noexcept</b> , <b>countof</b> , as well as, after considering all the non-standard defines and features of the compilers, there was information about the functionality that is supported by the current compiler.  This is where <b>core.h is</b> almost complete, but it would not be complete without <b>nullptr</b> . <br><br>  Link to GitHub with the result today for the impatient and non-readers: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  <b><a href="https://github.com/oktonion/stdex">Commits and constructive criticism are welcome</a></b> </blockquote><br>  So let's continue. <br><a name="habracut"></a><br><h4>  Table of contents </h4><br>  <a href="https://habr.com/post/417027/">Introduction</a> <br>  <a href="https://habr.com/post/417027/">Chapter 1. Viam supervadet vadens</a> <br>  <a href="https://habr.com/post/417099/">Chapter 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <b>Chapter 3. Finding the perfect implementation of nullptr</b> <br>  <a href="https://habr.com/post/417547/">Chapter 4. C ++ Template "Magic"</a> <br>  .... <a href="https://habr.com/post/417547/">4.1 Starting small</a> <br>  .... <a href="https://habr.com/post/417949/">4.2 How many we get wonderful errors are compiled by the log</a> <br>  .... <a href="https://habr.com/post/418347/">4.3 Pointers and all-all-all</a> <br>  .... <a href="https://habr.com/post/420365/">4.4 What else is needed for the template library</a> <br>  Chapter 5 <br>  ... <br><br><h3>  Chapter 3. Finding the perfect implementation of nullptr </h3><br>  After the whole epic with nonstandard compiler macros and discoveries of the ‚Äúwonderful‚Äù they presented, I could finally add <b>nullptr</b> and it even warmed my soul.  Finally, it will be possible to get rid of all these comparisons with 0 or even with <b>NULL</b> . <br><br><img src="https://habrastorage.org/webt/t_/jt/wb/t_jtwbjyvuah5tw2ehe-gvy0fxe.jpeg" alt="image" width="300" height="200" align="left">  Most programmers implement <b>nullptr</b> as <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> nullptr 0</span></span></code> </pre> <br>  and this could be the end of this chapter.  If you want <b>nullptr</b> for <b>yourself</b> , then just replace 0 with such a define, because in fact this is all that is required for correct operation. <br><br>  Do not forget to really write a check, and then suddenly someone else will be with the following definition: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> nullptr #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> nullptr 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"nullptr defined already"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  The <a href="http://eel.is/c%2B%2Bdraft/cpp.error">#error</a> preprocessor <a href="http://eel.is/c%2B%2Bdraft/cpp.error">directive</a> will <a href="http://eel.is/c%2B%2Bdraft/cpp.error">generate an</a> error with human-readable text when compiled, and yes, this is a standard directive, the use of which is rare but can be found. <br><br>  But in this implementation, we miss one of the important points described in the standard, namely <i>std :: nullptr_t</i> - a separate type, of which <b>nullptr</b> is a constant instance.  And the developers of chromium, when they also <a href="https://stackoverflow.com/questions/19526466/simulating-nullptr-nullptr-t-for-gcc-4-5-3">tried to</a> solve this problem (now there is already a newer compiler and a normal <b>nullptr</b> ), defining it as a class that can convert to a pointer to any type.  Since according to the standard, the size of <b>nullptr</b> should be equal to the size of a pointer to <b>void</b> (and <b>void *</b> should also contain any pointer, except for pointers to a member of the class), we slightly ‚Äústandardize‚Äù this implementation by adding an unused null pointer: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: nullptr_t_as_class_impl() { } nullptr_t_as_class_impl(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { } <span class="hljs-comment"><span class="hljs-comment">// Make nullptr convertible to any pointer type. template&lt;typename T&gt; operator T*() const { return 0; } // Make nullptr convertible to any member pointer type. template&lt;typename C, typename T&gt; operator TC::*() { return 0; } bool operator==(nullptr_t_as_class_impl) const { return true; } bool operator!=(nullptr_t_as_class_impl) const { return false; } private: // Do not allow taking the address of nullptr. void operator&amp;(); void *_padding; }; typedef nullptr_t_as_class_impl nullptr_t; #define nullptr nullptr_t(0)</span></span></code> </pre><br>  The conversion of this class to any pointer is due to a generic type operator, which is called if something is compared with <b>nullptr</b> .  Ie expression <i>char * my_pointer;</i>  <i>if (my_pointer == nullptr)</i> will actually be converted to <i>if (my_pointer == nullptr.operator char * ())</i> , which compares the pointer with 0. The second type operator is needed to convert <b>nullptr</b> to pointers to class members.  And here Borland C ++ Builder 6.0 has already ‚Äúdistinguished itself‚Äù, which unexpectedly decided that these two operators are identical and it can easily compare pointers to a member of a class and ordinary pointers to each other, therefore uncertainty arises every time such a <b>nullptr is</b> compared with pointer (this is a bug, and perhaps it is not only in this compiler).  We write a separate implementation for this case: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_impl1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: nullptr_t_as_class_impl1() { } nullptr_t_as_class_impl1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { } <span class="hljs-comment"><span class="hljs-comment">// Make nullptr convertible to any pointer type. template&lt;typename T&gt; operator T*() const { return 0; } bool operator==(nullptr_t_as_class_impl1) const { return true; } bool operator!=(nullptr_t_as_class_impl1) const { return false; } private: // Do not allow taking the address of nullptr. void operator&amp;(); void *_padding; }; typedef nullptr_t_as_class_impl1 nullptr_t; #define nullptr nullptr_t(0)</span></span></code> </pre><br>  The advantages of this representation of <b>nullptr are</b> that now there is a separate type for <i>std :: nullptr_t</i> .  Disadvantages?  The <b>nullptr is</b> lost during compilation and comparison through a ternary operator; the compiler cannot resolve it. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>* case5 = argc &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,     ':'    STATIC_ASSERT(nullptr == nullptr &amp;&amp; !(nullptr != nullptr), nullptr_should_be_equal_itself); //  , nullptr     </span></span></code> </pre><br>  And I want "and checkered and go."  The decision comes to mind only one thing: <b>enum</b> .  The members of an enumeration in C ++ will have their own separate type, and will also be converted to <b>int</b> without problems (and in fact are integer constants).  This property of an enumeration member will help us, because the very ‚Äúspecial‚Äù 0, which is used instead of <b>nullptr</b> for pointers, is the most common <b>int</b> .  I haven‚Äôt met such implementation of <b>nullptr</b> on the Internet, and, perhaps, it is also something bad, but I haven‚Äôt found ideas with what.  We write the implementation: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> NULL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STDEX_NULL NULL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STDEX_NULL 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> namespace ptrdiff_detail { using namespace std; } template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;bool&gt; struct nullptr_t_as_ulong_type { typedef unsigned long type; }; template&lt;&gt; struct nullptr_t_as_ulong_type&lt;false&gt; { typedef unsigned long type; }; template&lt;bool&gt; struct nullptr_t_as_ushort_type { typedef unsigned short type; }; template&lt;&gt; struct nullptr_t_as_ushort_type&lt;false&gt; { typedef nullptr_t_as_long_type&lt;sizeof(unsigned long) == sizeof(void*)&gt;::type type; }; template&lt;bool&gt; struct nullptr_t_as_uint_type { typedef unsigned int type; }; template&lt;&gt; struct nullptr_t_as_uint_type&lt;false&gt; { typedef nullptr_t_as_short_type&lt;sizeof(unsigned short) == sizeof(void*)&gt;::type type; }; typedef nullptr_t_as_uint_type&lt;sizeof(unsigned int) == sizeof(void*)&gt;::type nullptr_t_as_uint; enum nullptr_t_as_enum { _nullptr_val = ptrdiff_detail::ptrdiff_t(STDEX_NULL), _max_nullptr = nullptr_t_as_uint(1) &lt;&lt; (CHAR_BIT * sizeof(void*) - 1) }; typedef nullptr_t_as_enum nullptr_t; #define nullptr nullptr_t(STDEX_NULL)</span></span></span></span></code> </pre><br>  As you can see here, a bit more code than just the <b>enum</b> <i>nullptr_t declaration</i> with the member <i>nullptr = 0</i> .  First, the definition of <b>NULL</b> may not be.  It should be defined in a <a href="https://ru.cppreference.com/w/cpp/types/NULL">fairly solid list of standard headers</a> , but as practice has shown, it is better to be safe and check for the presence of this macro.  Secondly, <b>enum</b> representation in C ++ according to the implementation-defined standard, i.e.  the type of an enumeration can be represented by any integer types (with the proviso that these types cannot be greater than <b>int</b> , if only <b>enum</b> values <b>fit</b> into it).  For example, if you declare <i>enum test {_1, _2} the</i> compiler can easily present it as <b>short</b> and then it is quite possible that <b>sizeof (</b> <i>test</i> <b>)</b> <i>! =</i> <b>Sizeof (void *)</b> .  In order for the implementation of <b>nullptr to</b> meet the standard, you need to make sure that the size of the type that the compiler selects for <i>nullptr_t_as_enum</i> will match the size of the pointer, i.e.  essentially equal to <b>sizeof (void *)</b> .  To do this, use the <i>nullptr_t_as</i> templates <i>...</i> select an integer type that will be equal to the pointer size, and then set the maximum element value in our enumeration to the maximum value of this integer type. <br><blockquote>  I want to draw attention to the macro <b>CHAR_BIT</b> defined in the standard <b>climits</b> header.  This macro is set to the number of bits in one <b>char</b> , i.e.  The number of bits per byte on the current platform.  A useful <u>standard</u> definition, which is undeservedly bypassed by developers sticking eights everywhere, although <a href="https://stackoverflow.com/questions/5516044/system-where-1-byte-8-bit">here and there in one byte there is anything but 8 bits</a> . </blockquote><br>  And another feature is the assignment of <b>NULL</b> as the value of the element <b>enum</b> .  Some compilers provide warning (and their concern can be understood) about the fact that <b>NULL is</b> assigned to a ‚Äúnon-index‚Äù.  We take out the standard <b>namespace</b> to our local <i>ptrdiff_detail</i> so as not to clutter up the rest of the namespace with them, and further, to reassure the compiler, we explicitly convert <b>NULL</b> to <i>std :: ptrdiff_t</i> - another for some reason little-used type in C ++, which serves to represent the result of arithmetic actions (subtraction) with pointers and is usually an alias of type <i>std :: size_t</i> ( <i>std :: intptr_t</i> in C ++ 11). <br><br><h4>  SFINAE </h4><br>  Here, for the first time in my narration, we encounter the phenomenon of C ++ as <a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error (SFINAE)</a> .  Briefly, the essence of it is that when the compiler enumerates the appropriate function overloads for a particular call, it should check them all, and not stop after the first failure or after the first overload that was found.  Hence, his <a href="https://www.quora.com/What-is-ambiguity-in-C%2B%2B">ambiguity</a> messages appear when there are two overloads of the called function that are identical from the compiler's point of view, and also the ability of the compiler to select the most appropriate function overload for a particular call with specific parameters.  This feature of the compiler allows you to do the lion's share of the whole template "magic" (by the way hello <i>std :: enable_if</i> ), as well as being the basis of both boost and my library. <br><br>  Since, as a result, we have several implementations of <b>nullptr,</b> we use SFINAE to ‚Äúselect‚Äù the best at the compilation stage.  We declare the types "yes" and "no" to check through the <b>sizeof</b> probe functions declared below. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> nullptr_detail { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _yes_type; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no_type</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> padding[<span class="hljs-number"><span class="hljs-number">8</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_class</span></span></span><span class="hljs-class"> {</span></span>}; _yes_type _is_convertable_to_void_ptr_tester(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); _no_type _is_convertable_to_void_ptr_tester(...); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nullptr_detail::dummy_class::*dummy_class_f)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nullptr_detail::dummy_class::*dummy_class_f_const)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; _yes_type _is_convertable_to_member_function_ptr_tester(dummy_class_f); _no_type _is_convertable_to_member_function_ptr_tester(...); _yes_type _is_convertable_to_const_member_function_ptr_tester(dummy_class_f_const); _no_type _is_convertable_to_const_member_function_ptr_tester(...); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yes_type</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_ptr_tester</span></span></span><span class="hljs-class">(_</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">*);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no_type</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_ptr_tester</span></span></span><span class="hljs-class">(...);</span></span> }</code> </pre><br><blockquote>  Here we will use the same principle as in the <a href="https://habr.com/post/417099/">second chapter</a> with the <b>countof</b> and its definition in terms of the <b>sizeof of the</b> return value (array of elements) of the template function <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> . </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_void_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_void_ptr_tester((T) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)); };</code> </pre><br>  What is going on here?  First, the compiler ‚Äú <i>iterates</i> ‚Äù overloading the function <i>_is_convertable_to_void_ptr_tester</i> with an argument of type <i>T</i> and a value of <b>NULL</b> (the value does not play a role, just <b>NULL</b> must be reducible to type <i>T</i> ).  There are only two overloads - with the <b>void *</b> type and with a <a href="https://en.cppreference.com/w/cpp/utility/variadic">variable argument list (...)</a> .  Substituting the argument into each of these overloads, the compiler will choose the first if the type is cast to a pointer to <b>void</b> , and the second if the cast cannot be performed.  With the overload selected by the compiler, we will determine by <b>sizeof</b> the size of the return value of the function, and since they are guaranteed to be different ( <b>sizeof (</b> <i>_no_type</i> <b>)</b> <i>== 8</i> , <b>sizeof (</b> <i>_yes_type</i> <b>)</b> <i>== 1</i> ), we can determine what overload the compiler has picked up and consequently converted whether our type is <b>void *</b> or not. <br><br>  We will continue to use the same programming pattern in order to determine whether the object of the chosen type for the representation <i>nullptr_t</i> is <i>converted</i> to any pointer (essentially <i>(T) (</i> <b>STDEX_NULL</b> <i>)</i> and there is a future definition for <b>nullptr</b> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_member_function_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_member_function_ptr_tester((T) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)) &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_const_member_function_ptr_tester((T) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullPtrType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_any_ptr_impl_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_ptr_tester&lt;T&gt;((NullPtrType) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_any_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, nullptr_detail::dummy_class&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = ( _is_convertable_to_void_ptr_impl&lt;T&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; _is_convertable_to_any_ptr_impl&lt;T&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; _is_convertable_to_member_function_ptr_impl&lt;T&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) ); };</code> </pre><br>  Of course, it is not possible to sort through all imaginable and inconceivable pointers and their combinations with <b>volatile</b> and <b>const</b> <b>modifiers</b> , so I limited myself to these 9 checks (two for class function pointers, one for <b>void</b> pointer, seven for different type pointers), which is quite enough. <br><br>  As mentioned above, some (* khe-khe * ... Borland Builder 6.0 ... * khe *) compilers do not distinguish between pointers to a type and a member of a class, so we will write a further check for this case and then select the desired implementation of <i>nullptr_t</i> if need be. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">member_ptr_is_same_as_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test::*member_ptr_type)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _is_convertable_to_void_ptr_impl&lt;member_ptr_type&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_chooser</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_class_impl type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_chooser</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_class_impl1 type; };</code> </pre><br>  And then it remains only to check the different implementations of <i>nullptr_t</i> and select the appropriate compiler compiler. <br><br><div class="spoiler">  <b class="spoiler_title">Select the implementation of nullptr_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_int</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_int type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_enum</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_enum type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_class</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _nullptr_t_as_class_chooser&lt;_member_ptr_is_same_as_ptr::value&gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_int</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_void type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_enum</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">as_int</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_int nullptr_t_as_int; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _is_convertable_to_ptr = _is_convertable_to_ptr_impl&lt;nullptr_t_as_int&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _equal_void_ptr = _is_equal_size_to_void_ptr&lt;nullptr_t_as_int&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _nullptr_choose_as_int&lt;as_int::_is_convertable_to_ptr == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; as_int::_equal_void_ptr == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)&gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_class</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">as_enum</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_enum nullptr_t_as_enum; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _is_convertable_to_ptr = _is_convertable_to_ptr_impl&lt;nullptr_t_as_enum&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _equal_void_ptr = _is_equal_size_to_void_ptr&lt;nullptr_t_as_enum&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _can_be_ct_constant = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;<span class="hljs-comment"><span class="hljs-comment">//_nullptr_can_be_ct_constant_impl&lt;nullptr_t_as_enum&gt;::value; }; typedef _nullptr_choose_as_enum&lt;as_enum::_is_convertable_to_ptr == bool(true) &amp;&amp; as_enum::_equal_void_ptr == bool(true) &amp;&amp; as_enum::_can_be_ct_constant == bool(true)&gt;::type type; }; struct _nullptr_chooser { struct as_class { typedef _nullptr_t_as_class_chooser&lt;_member_ptr_is_same_as_ptr::value&gt;::type nullptr_t_as_class; static const bool _equal_void_ptr = _is_equal_size_to_void_ptr&lt;nullptr_t_as_class&gt;::value; static const bool _can_be_ct_constant = _nullptr_can_be_ct_constant_impl&lt;nullptr_t_as_class&gt;::value; }; typedef _nullptr_choose_as_class&lt;as_class::_equal_void_ptr == bool(true) &amp;&amp; as_class::_can_be_ct_constant == bool(true)&gt;::type type; };</span></span></code> </pre><br></div></div><br>  First, we check for the ability to represent <i>nullptr_t</i> as a class, but since I did not find a universal compiler- <i>independent</i> solution of how to check that an object of type can be a compile-time constant (by the way, I am open to suggestions for this account, because it is quite possible that this is possible), This option is always <i>checked</i> ( <i>_can_be_ct_constant is</i> always <b>false</b> ).  Next, switch to checking the option with the view through the <b>enum</b> .  If it was not possible to submit this way either (the compiler cannot provide a pointer or <b>enum</b> for some reason), then we try to represent it as an integer type (whose size will be equal to the size of the pointer to <b>void</b> ).  Well, if it didn‚Äôt work either, then select the implementation of the type <i>nullptr_t</i> via <b>void *</b> . <br><br>  This place reveals much of the power of SFINAE in combination with C ++ templates, due to which it is possible to choose the necessary implementation, without resorting to compiler-dependent macros, and indeed to macros (as opposed to the boost where all this would be stuffed with <b>#ifdef #else checks endif</b> ). <br><br>  It only remains to define the type alias for <i>nullptr_t</i> in the <b>namespace stdex</b> and define for <b>nullptr</b> (in order to meet another requirement of the standard that the address of <b>nullptr</b> cannot be taken, and also that you can use <b>nullptr</b> as a compile time constant). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdex { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> detail::_nullptr_chooser::type <span class="hljs-keyword"><span class="hljs-keyword">nullptr_t</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> nullptr (stdex::nullptr_t)(STDEX_NULL)</span></span></code> </pre><br>  The end of the third chapter.  In the <a href="https://habr.com/post/417547/">fourth chapter,</a> I finally get to type_traits and what other bugs in the compilers I came across while developing. <br><br>  Thank you for attention. </div><p>Source: <a href="https://habr.com/ru/post/417295/">https://habr.com/ru/post/417295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417283/index.html">Disney introduced its own hair animation system HairControl</a></li>
<li><a href="../417285/index.html">Where to insert quotation mark in IPv6</a></li>
<li><a href="../417287/index.html">"Calendar of the tester" for July. Analytics testing</a></li>
<li><a href="../417289/index.html">Internship Diary: Day 1. From intern to junior</a></li>
<li><a href="../417293/index.html">Password recovery and primary storage in the cloud, or What's new in Zimbra 8.8.9</a></li>
<li><a href="../417297/index.html">Fear and Loath Threat Intelligence or 8 TI Practical Tips</a></li>
<li><a href="../417299/index.html">Online, offline and P2P: how to buy bitcoin in Russia</a></li>
<li><a href="../417301/index.html">Smooth release recipe: PMy to note</a></li>
<li><a href="../417303/index.html">Hack to support buttons Android-headset under Windows</a></li>
<li><a href="../417305/index.html">Ultima Online: a look from behind the scenes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>