<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Internal DSL & Expression Trees - dynamic creation of serialize, copy, clone, equals functions (Part I)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is devoted to the dual use of Expression Trees API - for parsing expressions and for generating code. Parsing expressions helps build repr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Internal DSL & Expression Trees - dynamic creation of serialize, copy, clone, equals functions (Part I)</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/_c/m3/gr/_cm3grewmg9yewpcch1nqkl2ho8.png"></p><br><p>  The article is devoted to the dual use of <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/">Expression Trees</a> API - for parsing expressions and for generating code.  Parsing expressions helps build representation structures (they are also representation structures of the problem-oriented <a href="https://martinfowler.com/books/dsl.html">Internal DSL</a> language), and code generation allows you to dynamically create effective functions ‚Äî sets of instructions specified by representation structures. </p><br><p>  I will demonstrate the dynamic creation of <strong>property iterators: serialize, copy, clone, equals</strong> .  Using the example of serialize, I‚Äôll show how to optimize serialization (as compared to stream serializers) in a classic situation where prior knowledge is used to improve performance.  The idea is that the call to a streaming serializer always loses the "non-streaming" function that knows exactly which nodes in the tree need to be circumvented.  At the same time, such a serializer is created "not by hand" but dynamically, but according to predetermined bypass rules.  <strong>The proposed Inernal DSL solves the problem of a compact description of rules for traversing tree structures of objects by their properties / properties (and, in general, bypassing the tree of computations with the naming of nodes)</strong> .  The serializer's benchmark is modest, but it is important in that it adds an approach built around the use of a particular Internal <strong>DSL Includes</strong> (the dialect of that Include / ThenInclude from <a href="https://docs.microsoft.com/en-us/ef/">EF Core</a> ) and the application of Internal DSL as a whole, the necessary persuasiveness. </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  Compare: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(){X=<span class="hljs-number"><span class="hljs-number">-1</span></span>,Y=<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var json2 = $"{{\"X\":{pX}, \"Y\":{pY}}}";</span></span></code> </pre> <br><p>  The second method is obviously faster (the nodes are known and ‚Äúcrammed into code‚Äù), while the method is of course more complicated.  But when you get this code as a function (dynamically generated and compiled) - the complexity is hidden (even what is becoming unclear is hidden <br>  where is the reflection, and where is the runtime code generation). </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point(){X=<span class="hljs-number"><span class="hljs-number">-1</span></span>,Y=<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var formatter = JsonManager.ComposeFormatter&lt;Point&gt;(); var json2 = formatter(p);</span></span></code> </pre> <br><p>  Here <code>JsonManager.ComposeFormatter</code> is a <a href="https://www.nuget.org/packages/DashboardCode.Routines/">real tool</a> .  The rule on which the structure traversal is generated during serialization is not obvious, but it sounds like "with the default parameters, go around all the first level fields for custom value type".  If it is set explicitly: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    var formatter2 = JsonManager.ComposeFormatter&lt;Point&gt;( chain=&gt;chain .Include(e=&gt;eX) .Include(e=&gt;eY) // DSL Includes )</span></span></code> </pre> <br><p>  This is the metadata description by DSL Includes.  The analysis of the pros and cons of metadata descriptions by DSL is enlightened, but now ignoring the metadata entry form, I emphasize that C # provides the ability to compile and compile the ‚Äúperfect serializer‚Äù using Expression Trees. </p><br><div class="spoiler">  <b class="spoiler_title">How he does it - a lot of code and a guide for code generation Expression Trees ...</b> <div class="spoiler_text"><p>  transition from <code>formatter</code> to <code>serilizer</code> (for now without expression trees): </p><br><pre> <code class="cs hljs"> Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer = ... <span class="hljs-comment"><span class="hljs-comment">// later string formatter(Point p) { var stringBuilder = new StringBuilder(); serializer(stringBuilder, p); return stringBuilder.ToString(); }</span></span></code> </pre> <br><p>  In turn, the <code>serializer</code> is built like this (if specified with a static code): </p><br><pre> <code class="cs hljs">Expression&lt;Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; serializerExpression = SerializeAssociativeArray(sb, p, (sb1, t1) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString) ); Func&lt;StringBuilder, Point, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer = serializerExpression.Compile();</code> </pre> <br><p>  Why so "functionally", why it is impossible to set the serialization of two fields through a "semicolon"?  In short: because this expression can be assigned to a variable of type <code>Expression&lt;Func&lt;StringBuilder, Box, bool&gt;&gt;</code> , and a "semicolon" is impossible. <br>  Why was it impossible to directly write <code>Func&lt;StringBuilder, Point, bool&gt; serializer = (sb,p)=&gt;SerializeAssociativeArray(sb,p,...</code> ? It's possible, but I‚Äôm demonstrating not the creation of a delegate, but an assembly (in this case, a static code) expression tree, with the next compilation to the delegate, in practical use of the <code>serializerExpression</code> will be set completely differently - dynamically (below). </p><br><p>  But what is important in the solution itself: <code>SerializeAssociativeArray</code> accepts an array of <code>params Func&lt;..&gt; propertySerializers</code> for the number of nodes that must be bypassed.  Some of them can be traversed by the SerializeValueProperty "leaf" <code>SerializeValueProperty</code> (accepting the <code>SerializeValueToString</code> formatter), and the <code>SerializeAssociativeArray</code> (i.e. branches) can be set again, and thus the bypass iterator is built. </p><br><p>  If Point contained a NextPoint property: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> = SerializeAssociativeArray(sb, p, (sb1, t1) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb1, t1, <span class="hljs-string"><span class="hljs-string">"NextPoint"</span></span>, o =&gt; o.NextPoint, (sb4, t4) =&gt;SerializeAssociativeArray(sb1, p1, (sb1, t1) =&gt; SerializeValueProperty(sb2, t2, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, o =&gt; oX, SerializeValueToString), (sb4, t4) =&gt; SerializeValueProperty(sb2, t2, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, o =&gt; oY, SerializeValueToString) ) ) );</code> </pre> <br><p>  The structure of the three functions <code>SerializeAssociativeArray</code> , <code>SerializeValueProperty</code> , <code>SerializeValueToString</code> not complicated: </p><br><div class="spoiler">  <b class="spoiler_title">Serialize ...</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeAssociativeArray&lt;T&gt;(StringBuilder stringBuilder, T t, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Func&lt;StringBuilder, T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;[] propertySerializers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'{'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertySerializer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> propertySerializers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notEmpty = propertySerializer(stringBuilder, t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (notEmpty) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!@<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">','</span></span>); } }; stringBuilder.Length--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (@<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'}'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeValueProperty&lt;T, TProp&gt;(StringBuilder stringBuilder, T t, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Func&lt;T, TProp&gt; getter, Func&lt;StringBuilder, TProp, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; serializer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TProp : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stringBuilder.Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Append(propertyName).Append(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Append(<span class="hljs-string"><span class="hljs-string">':'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = getter(t); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notEmpty = serializer(stringBuilder, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!notEmpty) stringBuilder.Length -= (propertyName.Length + <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> notEmpty; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SerializeValueToString&lt;T&gt;(StringBuilder stringBuilder, T t) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stringBuilder.Append(t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> </div></div><br><p>  Many details are not given here (lists support, reference type and nullable).  And yet it is clear that I will really get <em>json</em> on output, and the rest is even more typical functions of <code>SerializeArray</code> , <code>SerializeNullable</code> , <code>SerializeRef</code> . </p><br><p>  It was a static Expression Tree, not dynamic, not <em>eval in C #</em> . </p><br><p>  See how the Expression Tree is built dynamically in two steps: </p><br><h4 id="shag-1---decompilerom-posmotret-na-kod-prisvoennyy-expressiont">  Step 1 - decompiler look at the code assigned by <code>Expression&lt;T&gt;</code> </h4><br><p><img src="https://habrastorage.org/webt/ox/p3/g2/oxp3g2newr9bhr3oba5bajcrkco.png"></p><br><p>  It certainly will surprise for the first time.  Nothing is clear, but you can see how the first four lines put together something like: </p><br><pre> <code class="cs hljs">(<span class="hljs-string"><span class="hljs-string">"sb"</span></span>,<span class="hljs-string"><span class="hljs-string">"t"</span></span>) .. SerializeAssociativeArray..</code> </pre> <br><p>  Then the connection with the source code is captured.  And it should become clear that if you learn such a record (by combining 'Expression.Const', 'Expression.Parameter', 'Expression.Call', 'Expression.Lambda' <a href="https://msdn.microsoft.com/en-us/library/system.linq.expressions.expression(v%3Dvs.110).aspx">etc</a> ...) you can really dynamically assemble - any bypass of the nodes (based on metadata).  This is <em>eval in C #</em> . </p><br><h4 id="shag-2----shodit-po-etoy-ssylkehttpsgithubcomdashboardcoderoutinesblobmastertestsconsoleappsclrmdautomationprogramcsl99-l194">  Step 2 - go to <a href="">this link</a> , </h4><br><p>  The same decompiler code, but compiled by man. </p><br><p>  Be drawn into this embroidery with beads is only necessary to the author of the interpreter.  All these artworks remain inside <a href="https://www.nuget.org/packages/DashboardCode.Routines/">the serialization library</a> .  It is important to grasp the idea that libraries can provide dynamically generating compiled efficient functions in C # (and. NET Standard). </p></div></div><br><p>  However, the stream serializer will overtake the dynamically generated function if the compilation is invoked every time before serialization (compilation inside <code>ComposeFormatter</code> is a costly operation), but you can save the link and reuse it: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Func&lt;Point, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; formatter = JsonManager.ComposeFormatter&lt;Point&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Point p</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// which has better performance ? var json1 = JsonConvert.SerializeObject(p); var json2 = formatter(p); return json2; }</span></span></code> </pre> <br><p>  If, however, you need to build and save a serializer of anonymous types for reuse, then additional infrastructure is needed: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Point&gt; list</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// there json formatter will be build only for first call // and assigned to cachedFormatter.Formatter // in all next calls cachedFormatter.Formatter will be used. // since building of formatter is determenistic it is lock free var json3 = list.Select(e=&gt; {X:eX, Sum:e.X+EY}) .ToJson(cachedFormatter, e=&gt;e.Sum); return json3; }</span></span></code> </pre> <br><p>  After that, we confidently count the first micro-optimization for ourselves and accumulate, accumulate, accumulate ... To whom is the joke, who does not, but before turning to the question that the new serializer knows how new - I fix the obvious advantage - it will be faster. </p><br><h2 id="chto-vzamen">  What in return? </h2><br><p>  The DSL Includes interpreter in serilize (and in the same way it is possible in iterators equals, copy, clone - and this will also be the case) required the following costs: </p><br><p>  <strong>1</strong> - costs of the infrastructure for storing references to compiled code. </p><br><p>  These costs are generally not necessary, as is the use of Expression Trees with compilation - the interpreter can also create a serializer on reflections and even lick it so much that it approaches speed to streaming serializers (by the way, shown at the end of the article copy, clone and equals and do not gather through expression trees, and they didn‚Äôt lick, there is no such task, in contrast to ‚Äúovertake‚Äù ServiceStack and Json.NET in the framework of the universally understood json optimization problem - a necessary condition for presenting a new solution). </p><br><p>  <strong>2</strong> - you need to keep abstractions leaking in your head as well as a similar problem: changes in semantics compared to existing solutions. </p><br><p>  For example, Point and IEnumerable need two different serializers to serialize. <br></p><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter1 = JsonManager.ComposeFormatter&lt;Point&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter2 = JsonManager.ComposeEnumerableFormatter&lt;Point&gt;(); <span class="hljs-comment"><span class="hljs-comment">// but not // var formatter2 = JsonManager.ComposeEnumerableFormatter&lt;List&lt;Point&gt;&gt;();</span></span></code> </pre> <br><p>  Or: "Does closure work / closure?".  It works, only the node must be given a name (unique): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> DATEFORMAT= <span class="hljs-string"><span class="hljs-string">"YYYY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatter3 = JsonManager.ComposeFormatter&lt;Record&gt;( chain =&gt; chain .Include(i =&gt; i.RecordId) .Include(i =&gt; i.CreatedAt.ToString(DATEFORMAT) , <span class="hljs-string"><span class="hljs-string">"CreatedAt"</span></span>); );</code> </pre> <br><p>  This behavior is dictated by the internal device-specific interpreter <code>ComposeFormatter</code> . </p><br><p>  The costs of this type are inevitable evil.  Moreover, it is found that by increasing the functionality and expanding the scope of Internal DSL, leaks of abstraction are also increasing.  The developer of the Internal DSL will of course be oppressed, here you need to stock up on a philosophical mood. </p><br><p>  For a user, abstraction leaks are overcome by knowing the technical details of the Internal DSL ( <em>what to expect?</em> ) And the wealth of functionality of a particular DSL and its interpreters ( <em>which in return?</em> ).  Therefore, the answer to the question: ‚Äúis it worth creating and using the Internal DSL?‚Äù Can only be a story about the functionality of a particular DSL - about all its small things and amenities, and application possibilities (interpreters), i.e.  story about overcoming costs. </p><br><p>  Having all this in mind, I return to the effectiveness of a particular DSL Includes. </p><br><p>  Much greater efficiency is achieved when the replacement of a triple (DTO, transformation to DTO, serialization of DTO) becomes one at the place of a detailed instructed and generated serialization function.  At the end-ends, the dualism of the object-object allows you to state "DTO is such a function" and set a goal: learn how to set the DTO function. </p><br><p>  Serialization must be configured: </p><br><ol><li>  Bypass tree (describe the nodes that will be serialized, by the way it solves the problem of circular links), in the case of leaves - assign a formatter (by type). </li><li>  Leaf inclusion rule (if not specified) - property vs fields?  readonly? </li><li>  To be able to set both a branch (a node with navigation) and a sheet is not just MemberExpression ( <code>e=&gt;e.Name</code> ), but generally by any function (`e =&gt; e.Name.ToUpper ()," MyMemberName ") - set the formatter to a specific node. </li></ol><br><p>  Other features that increase flexibility: </p><br><ol><li>  serialize the sheet containing the line json "as is" (special formatter of strings); </li><li>  set formatters for groups, i.e.  whole branches, in this branch so - in another differently (for example, here dates with time, and in this one without time). </li></ol><br><p>  Everywhere such constructions participate: walk tree, branch, leaf, and all this can be written using DSL Includes. </p><br><h2 id="dsl-includes">  DSL Includes </h2><br><p>  Since everyone is familiar with EF Core - the meaning of subsequent expressions should be captured immediately (this is a subset of xpath). </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// DSL Includes Include&lt;User&gt; include1 = chain=&gt; chain .IncludeAll(e =&gt; e.Groups) .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) // EF Core syntax // https://docs.microsoft.com/en-us/ef/core/querying/related-data var users = context.Users .Include(blog =&gt; blog.Groups) .Include(blog =&gt; blog.Roles) .ThenInclude(blog =&gt; blog.Privileges);</span></span></code> </pre> <br><p>  Here are the nodes "with navigation" - "branches". <br>  The answer to the question of which nodes "leaves" (fields / properties) are included in the so specified tree is none.  To include the leaves, you must either list them explicitly: </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include2 = chain=&gt; chain .Include(e =&gt; e.UserName) <span class="hljs-comment"><span class="hljs-comment">// leaf member .IncludeAll(e =&gt; e.Groups) .ThenInclude(e =&gt; e.GroupName) // leaf member .IncludeAll(e =&gt; e.Roles) .ThenInclude(e =&gt; e.RoleName) // leaf member .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) .ThenInclude(e =&gt; e.PrivilegeName) // leaf member</span></span></code> </pre><br><p>  Or add dynamically according to the rule, through a specialized interpreter: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Func&lt;ChainNode, MemberInfo&gt; rule = ... var include2 = IncludeExtensions.AppendLeafs(include1, rule);</span></span></code> </pre> <br><p>  Here the rule is a rule that can be selected by ChainNode. Type ie  by the type of expression returned by the node (ChainNode is an internal representation of DSL Includes what else will be said) properties (MemberInfo) for participation in serialization, for example.  only property, or only read / write property, or only those for which there is a formatter, can be selected by the list of types, and even the include expression itself can specify a rule (if it lists leaf nodes ‚Äî that is, the form of the tree association) . </p><br><p>  Or ... leave it to the discretion of the user interpreter, who decides what to do with the nodes.  DSL Includes is just a metadata entry - how to interpret this entry depends on the interpreter.  He can interpret the metadata as he wants, even ignoring it.  Some interpreters will perform the action themselves, others build a function ready to perform them (via the Expression Tree, or even Reflection.Emit).  A good Internal DSL is designed for universal use and the existence of many interpreters, each of which has its own specifics, its own leaks of abstraction. <br>  Code using Internal DSL can be very different from what it was before. </p><br><h4 id="out-of-the-box">  Out of the box </h4><br><p>  Integration with EF Core. <br>  The running task is to ‚Äúcut off circular references‚Äù, to allow only what is specified in the include expression to be serialized: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = GetEfCoreContext()) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> json = EfCoreExtensions.ToJsonEf&lt;User&gt;(cachedFormatter1, dbContext, chain=&gt;chain .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges)); } }</code> </pre> <br><p>  The <code>ToJsonEf</code> interpreter accepts the navigation sequence, when serialized it uses it (selects the leaves for the "default for EF Core" rule, that is, public read / write property), is interested in the model - where string / json to insert as is, uses field formatters default (byte [] to string, datetime in ISO, etc.).  Therefore, he must perform IQuaryable from under him. </p><br><p>  In the case when the result is transformed, the rules change - there is no need to use DSL Includes to set the navigation (if there is no re-use of the rule), a different interpreter is used, and the configuration occurs locally: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CachedFormatter cachedFormatter1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachedFormatter(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbContext = GetEfCoreContext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = dbContext.ParentRecords <span class="hljs-comment"><span class="hljs-comment">// back to EF core includes // but .Include(include1) also possible .IncludeAll(e =&gt; e.Roles) .ThenIncludeAll(e =&gt; e.Privileges) .Select(e =&gt; new { FieldA: e.FieldA, FieldJson:"[1,2,3]", Role: e.Roles().First() }) .ToJson(cachedFormatter1, chain =&gt; chain.Include(e =&gt; e.Role), LeafRuleManager.DefaultEfCore, config: rules =&gt; rules .AddRule&lt;string[]&gt;(GetStringArrayFormatter) .SubTree( chain =&gt; chain.Include(e =&gt; e.FieldJson), stringAsJsonLiteral: true) // json as is .SubTree( chain =&gt; chain.Include(e =&gt; e.Role), subRules =&gt; subRules .AddRule&lt;DateTime&gt;( dateTimeFormat: "YYYMMDD", floatingPointFormat: "N2" ) ), ), useToString: false, // no default ToString for unknown leaf type (throw exception) dateTimeFormat: "YYMMDD", floatingPointFormat: "N2" } }</span></span></code> </pre> <br><p>  It is clear that all these details, all this "by default", can be remembered only if it is very necessary and / or if this is your own interpreter.  On the other hand, we once again return to the pluses: DTO is not smeared over the code, given by a specific function, interpreters are universal.  The code becomes less - it is already good. </p><br><p>  <strong>You need to be warned</strong> : although it would seem in ASP and prior knowledge is always available, and streaming serializer is not a necessary thing in the world of the web, where even databases send data to json, but the use of DSL Includes in ASP MVC <a href="https://stackoverflow.com/questions/42360139/asp-net-core-return-json-with-status-code">is not the most simple</a> .  How to combine functional programming with ASP MVC - deserves a separate study. </p><br><p>  In this article I will limit myself to the subtleties of DS Includes, I will show both new functionality and the leakage of abstractions, in order to show that the problem of analyzing "costs and acquisitions" is generally exhausted. </p><br><h2 id="esche-bolshe-dsl-includes">  More DSL Includes </h2><br><pre> <code class="cs hljs">Include&lt;Point&gt; include = chain =&gt; chain.Include(e=&gt;eX).Include(e=&gt;eY);</code> </pre> <br><p>  This is different from EF Core Includes built on static functions that cannot be assigned to variables and passed as parameters.  DSL Includes itself was born from the need to pass "include" into my implementation of the Repository template without degrading information about the types that would appear if they were translated into strings in the standard way. </p><br><p>  The most fundamental difference is still in the appointment.  EF Core Includes ‚Äî enables navigation properties (branch nodes), DSL Includes ‚Äî a record of the computation tree traversal, assigning the name (path) to the result of each calculation. </p><br><p>  Internal view EF Core Includes - the list of strings received by MemberExpression.Member (Expression set by <code>e=&gt;User.Name</code> can only be [MemberExpression] ( <a href="https://msdn.microsoft.com/en-us/library/system.linq.expressions.memberexpression(v%3Dvs.110).aspx">https://msdn.microsoft.com/en-us/library/system.linq.expressions. memberexpression (v = vs.110) .aspx</a> and in the internal representations only the <code>Name</code> line is preserved. </p><br><p>  In DSL, the internal representation includes the <a href="">ChainNode and ChainMemberNode</a> classes that <a href="">store the entire</a> expression (eg <code>e=&gt;User.Name</code> ), which can be embedded in the Expression Tree as it is.  From this it follows that DSL Includes supports both fields and custom value types and function calls: </p><br><p>  Execution of functions: </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .Include(i =&gt; i.Email.ToUpper(),<span class="hljs-string"><span class="hljs-string">"EAddress"</span></span>);</code> </pre> <br><p>  What to do with it depends on the interpreter.  CreateFormatter- will display {"UserName": "John", "EAddress": "JOHN@MAIL.COM"} </p><br><p>  Execution can also be useful for setting traversal on nullable structures. </p><br><pre> <code class="cs hljs">Include&lt;StrangePointF&gt; include = chain =&gt; chain .Include(e =&gt; e.NextPoint) <span class="hljs-comment"><span class="hljs-comment">// NextPoint is nullable struct .ThenIncluding(e =&gt; e.Value.X) .ThenInclude(e =&gt; e.Value.Y); // but not this way (abstraction leak) // Include&lt;StrangePointF&gt; include // = chain =&gt; chain // now this can throw an exception // .Include(e =&gt; e.NextPoint.Value) // .ThenIncluding(e =&gt; eX) // .ThenInclude(e =&gt; eY);</span></span></code> </pre> <br><p>  In DSL Includes there is also a short record of the multi-level traversal ThenIncluding. </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .IncludeAll(i =&gt; i.Groups) <span class="hljs-comment"><span class="hljs-comment">// ING-form - doesn't change current node .ThenIncluding(e =&gt; e.GroupName) // leaf .ThenIncluding(e =&gt; e.GroupDescription) // leaf .ThenInclude(e =&gt; e.AdGroup); // leaf</span></span></code> </pre> <br><p>  compare with </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain =&gt; chain .Include(i =&gt; i.UserName) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.GroupName) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.GroupDescription) .IncludeAll(i =&gt; i.Groups) .ThenInclude(e =&gt; e.AdGroup);</code> </pre> <br><p>  And here, too, there is a leak of abstraction.  If I recorded a similar form of navigation, I need to know how the interpetor that will call QuaryableExtensions works.  And it translates calls to Include and ThenInclude to Include "string".  What may matter (must be borne in mind). </p><br><p>  <strong>Algebra include expressions</strong> . </p><br><p>  Include expressions can be: </p><br><div class="spoiler">  <b class="spoiler_title">Match</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b1 = InlcudeExtensions.IsEqualTo(include1, include2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b2 = InlcudeExtensions.IsSubTreeOf(include1, include2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b3 = InlcudeExtensions.IsSuperTreeOf(include1, include2);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Clone</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> include2 = InlcudeExtensions.Clone(include1);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Merge</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> include3 = InlcudeExtensions.Merge(include1, include2);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Convert to XPath lists - all the way to the leaves</b> <div class="spoiler_text"><pre> <code class="cs hljs">IReadOnlyCollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; paths1 = InlcudeExtensions.ListLeafXPaths(include); <span class="hljs-comment"><span class="hljs-comment">// as xpaths IReadOnlyCollection&lt;string[]&gt; paths2 = InlcudeExtensions.ListLeafKeyPaths(include); // as string[]</span></span></code> </pre> </div></div><br><p>  etc. </p><br><p>  The good news is that there are no leaks of abstractions here, a level of pure abstraction has been reached.  There is metadata and work with metadata. </p><br><h2 id="dialektika">  Dialectics </h2><br><p>  DSL Includes allows you to reach a new level of abstraction, but at the moment of achievement a need is formed to go to the next level: to generate the Include expressions themselves. </p><br><p>  In this case, generating DSLs as fluent chains is not necessary, you just need to create structures for the internal representation. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainNode(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Point)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChainPropertyNode( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), expression: <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Point).CreatePropertyLambda(<span class="hljs-string"><span class="hljs-string">"X"</span></span>), memberName:<span class="hljs-string"><span class="hljs-string">"X"</span></span>, isEnumerable:<span class="hljs-literal"><span class="hljs-literal">false</span></span>, parent:root ); root.Children.Add(<span class="hljs-string"><span class="hljs-string">"X"</span></span>, child); <span class="hljs-comment"><span class="hljs-comment">// or there is number of extension methods eg: var child = root.AddChild("X"); Include&lt;Point&gt; include = ChainNodeExtensions.ComposeInclude&lt;Point&gt;(root);</span></span></code> </pre> <br><p>  The interpreters can also be passed to the interpreters.  Why, then, does the fluent DSL record include at all?  This is a purely speculative question, the answer to which is: because in practice, to develop an internal representation (and it also develops) is obtained only with the development of DSL (that is, a brief expressive recording convenient for a static code).  Once again this will be discussed closer to the conclusion. </p><br><h2 id="copy-clone-equals">  Copy, Clone, Equals </h2><br><p>  All of the above is also true for interpreters of include expressions that implement iterators <strong>copy</strong> , <strong>clone</strong> , <strong>equals</strong> . </p><br><div class="spoiler">  <b class="spoiler_title">Equals</b> <div class="spoiler_text"><p>  Comparison only on leaves from an Include expression. <br>  Hidden semantic problem: evaluate or not the order in the list </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.Include(e=&gt;e.UserId).IncludeAll(e=&gt;e.Groups).ThenInclude(e=&gt;e.GroupId) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b1 = ObjectExtensions.Equals(user1, user2, include); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b2 = ObjectExtensions.EqualsAll(userList1, userList2, include);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Clone</b> <div class="spoiler_text"><p>  Pass through expression nodes.  The properties that match the rule are copied. </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.Include(e=&gt;e.UserId).IncludeAll(e=&gt;e.Groups).ThenInclude(e=&gt;e.GroupId) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUser = ObjectExtensions.Clone(user1, include, leafRule1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newUserList = ObjectExtensions.CloneAll(userList1, leafRule1);</code> </pre> <br><p>  There may be an interpreter that will select leaf from includes.  Why is it done through a separate rule?  What was similar to the semantics of ObjectExtensions.Copy </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Copy</b> <div class="spoiler_text"><p>  Passage through the nodes-branch of expression and identification by nodes-leaves.  Properties matching the rule are copied (similar to Clone). </p><br><pre> <code class="cs hljs">Include&lt;User&gt; include = chain=&gt;chain.IncludeAll(e=&gt;e.Groups); ObjectExtensions.Copy(user1, user2, include, supportedLeafsRule); ObjectExtensions.CopyAll(userList1, userList2, include, supportedLeafsRule);</code> </pre> <br><p>  There may be an interpreter that will select leaf from includes.  Why is it done through a separate rule?      ObjectExtensions.Copy (   ‚Äî  include   ,  supportedLeafsRule ‚Äî   ). </p></div></div><br><p>  copy / clone   : </p><br><ol><li>   readonly ,     Tuple&lt;,&gt;  Anonymous Type.    ,     . </li><li>   (. IEnumerable   ) ‚Äî  public   . </li><li>  expression  include-,       ‚Äî  . </li><li> "  "    . </li></ol><br><p>  DSL                   , ..               . ,     <code>Tuple&lt;,&gt;</code> , ..  c readonly ,   <code>ValueTuple&lt;,&gt;</code> c writabale      (      ). </p><br><p>  ,         (    Expression Trees) Includes  ‚Äî  .     Include DSL  . </p><br><p>    Detach, FindDifferences  .. </p><br><h2 id="pochemu-run-time-a-ne-cs-sgenerirovannyy-do-nachala-kompilyacii">  run-time,   .cs    ? </h2><br><p>    .cs  ,   ,   <em>run-time</em>   : </p><br><ol><li>       ( ,  , source control). </li><li>     , ,  ,   ‚Äî     . </li><li>         . </li><li>   "  ".  dev time   ,     : ""      ""   ,  ""    , ,  ""   . </li></ol><br><p>   Roslyn',          .    Typescript  (  DTO  , ..   ) ‚Äî   DSL Includes  Roslyn' ( ) ‚Äî      typescript ( ).  " "    " "  .cs (   Expression Trees). </p><br><p> :   run time ‚Äî   ,  .             (        Expression Trees). </p><br><h2 id="problemy-s-effektivnostyu-skompilirovannyh-funkciy-expression-trees">      Expression Trees </h2><br><p>   Internal DSL   Expression Tree    : </p><br><ol><li><p> <a href="https://msdn.microsoft.com/en-us/library/system.linq.expressions.lambdaexpression.compile(v%3Dvs.110).aspx"><code>LambdaExpression.Compile</code></a>    <em>Lambda</em> .     ,  .    ,   "" expression tree,   CallExpression    ‚Äî  LambdaExpression,   (.  LambdaExpression)    ConstantExpression.    ,  " /" ‚Äî      ,    Expression Trees. </p><br></li><li><p>       <em>ssmbly</em> ,     ( 10    )    ( assembly  ,    ‚Äî  ). , ,  ,      ‚Äî  . </p><br></li></ol><br><p>     ,        (  ),     ,       .    :       .   ‚Äî  ‚Äî   .cs     . </p><br><h2 id="benchmark-serializacii">   </h2><br><p>  ‚Äî     600   15   .  JSON.NET, ServiceStack    reflection' GetProperties(). </p><br><p> dslComposeFormatter ‚Äî ComposeFormatter   ,   <a href=""></a> . </p><br><p> <a href="https://benchmarkdotnet.org/articles/overview.html">BenchmarkDotNet</a> =v0.10.14, OS=Windows 10.0.17134 <br> Intel Core i5-2500K CPU 3.30GHz (Sandy Bridge), 1 CPU, 4 logical and 4 physical cores <br> .NET Core SDK=2.1.300 </p><br><table><thead><tr><th>  Method </th><th>  Mean </th><th>  Error </th><th> StdDev </th><th> Min </th><th>  Max </th><th>  Median </th><th> Allocated </th></tr></thead><tbody><tr><td> dslComposeFormatter </td><td> 2.208 ms </td><td> 0.0093 ms </td><td> 0.0078 ms </td><td> 2.193 ms </td><td> 2.220 ms </td><td> 2.211 ms </td><td> 849.47 KB </td></tr><tr><td> JsonNet_Default </td><td> 2.902 ms </td><td> 0.0160 ms </td><td> 0.0150 ms </td><td> 2.883 ms </td><td> 2.934 ms </td><td> 2.899 ms </td><td> 658.63 KB </td></tr><tr><td> JsonNet_NullIgnore </td><td> 2.944 ms </td><td> 0.0089 ms </td><td> 0.0079 ms </td><td> 2.932 ms </td><td> 2.960 ms </td><td> 2.942 ms </td><td> 564.97 KB </td></tr><tr><td> JsonNet_DateFormatFF </td><td> 3.480 ms </td><td> 0.0121 ms </td><td> 0.0113 ms </td><td> 3.458 ms </td><td> 3.497 ms </td><td> 3.479 ms </td><td> 757.41 KB </td></tr><tr><td> JsonNet_DateFormatSS </td><td> 3.880 ms </td><td> 0.0139 ms </td><td> 0.0130 ms </td><td> 3.854 ms </td><td> 3.899 ms </td><td> 3.877 ms </td><td> 785.53 KB </td></tr><tr><td> ServiceStack_SerializeToString </td><td> 4.225 ms </td><td> 0.0120 ms </td><td> 0.0106 ms </td><td> 4.201 ms </td><td> 4.243 ms </td><td> 4.226 ms </td><td> 805.13 KB </td></tr><tr><td> fake_expressionManuallyConstruted </td><td> 54.396 ms </td><td> 0.1758 ms </td><td> 0.1644 ms </td><td> 54.104 ms </td><td> 54.629 ms </td><td> 54.383 ms </td><td> 7401.58 KB </td></tr></tbody></table><br><p> fake_expressionManuallyConstruted ‚Äî expression      ( ). </p><br><h2 id="formalizaciya">  </h2><br><p>   DSL   : <strong>   DSL      ;    Internal DSL   run-time</strong> . </p><br><p> Expression Tree         <em></em>   .NET Standard . </p><br><p>     Expression Trees  <em> </em>     Internal DSL    Fluent API.      #      . </p><br><p>         fluent   (   Expression Trees),      Internal DSL  #     fluent,      ""   Expression Trees. </p><br><p> <strong>Expression Trees</strong>  <strong>DSL Includes</strong>      (  ,      ),      /  run-time ‚Äî  (run-time ). </p><br><p>  <strong>Internal DSL</strong>       :   -  <strong>serialize</strong> , <strong>copy</strong> , <strong>clone</strong> , <strong>equals</strong>        <strong>       ""</strong> .   ,      " ",      .    :  includes    (   ) ,       (       ,  ). </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>   DSL Includes    DTO           ‚Äî   ( json).        ,    ,    ,   " ",        .   =   . </p><br><p>       Internal DSL       ,   DSL,      Internal DSL (    Expression)         (     Expression Tree). </p><br><p>  DSL Includes  json  ComposeFormatter    <a href="https://www.nuget.org/packages/DashboardCode.Routines/">DashboardCodes.Routines</a>   nuget  GitHub. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/419759/">https://habr.com/ru/post/419759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419747/index.html">DJI Ronin S - the first start and the main functions</a></li>
<li><a href="../419749/index.html">Functions for documenting PostgreSQL databases. Ending</a></li>
<li><a href="../419751/index.html">Design trends in 2018: forecast and reality</a></li>
<li><a href="../419753/index.html">10 fastest supercomputers in the world 2018</a></li>
<li><a href="../419757/index.html">Translation of Andrew Un‚Äôs Passion for Machine Learning, Chapter 1-14</a></li>
<li><a href="../419761/index.html">Create a 2D game in Python with the library Arcade</a></li>
<li><a href="../419763/index.html">Examples of calculating the "availability factor" for sets of network equipment</a></li>
<li><a href="../419765/index.html">The course "Web programming languages" (based on Ruby) from MSTU. N. E. Bauman on Tehnostrim channel</a></li>
<li><a href="../419767/index.html">The creator of Wikipedia answers the questions: programming, sleep, books, tips "for life"</a></li>
<li><a href="../419769/index.html">WireGuard will ‚Äúcome‚Äù to the Linux kernel - why?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>