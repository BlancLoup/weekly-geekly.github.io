<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GPU Ray Tracing in Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Amazing times have come for ray tracing. NVIDIA sells accelerated noise reduction using AI , Microsoft announces native support for DirectX 12 , and P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GPU Ray Tracing in Unity</h1><div class="post__text post__text-html js-mediator-article">  Amazing times have come for ray tracing.  NVIDIA sells <a href="http://research.nvidia.com/publication/interactive-reconstruction-monte-carlo-image-sequences-using-recurrent-denoising">accelerated noise reduction using AI</a> , Microsoft announces <a href="https://blogs.msdn.microsoft.com/directx/2018/03/19/announcing-microsoft-directx-raytracing/">native support for DirectX 12</a> , and Peter Shirley <a href="https://twitter.com/Peter_shirley/status/985561344555417600">sells his books</a> at a free price ( <em>pay what you want</em> ).  It seems that ray tracing finally got a chance to be taken at court.  It may be too early to talk about the beginning of the revolution, but it is definitely worth starting to learn and accumulate knowledge in this area. <br><br>  In this article, we will write from scratch in Unity a very simple ray tracer using compute shaders.  We will write scripts in C #, and shaders in HLSL.  All code is laid out on <a href="https://bitbucket.org/Daerst/gpu-ray-tracing-in-unity/src/Tutorial_Pt1/">Bitbucket</a> . <br><br>  As a result, we can render something like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/fe4/fdc/44bfe4fdc9a29b74a393a921f846710f.png"></div><a name="habracut"></a><br><h1>  Ray tracing theory </h1><br>  I want to start with a brief overview of the fundamentals of ray tracing.  If you are familiar with it, you can safely skip this section. <br><br>  Let's imagine how photographs appear in the real world ‚Äî very simply, but this will be enough to explain the rendering.  It all starts with a light source that emits photons.  The photon flies in a straight line until it collides with the surface, after which it is reflected or refracted, and then continues its journey, losing some of the energy absorbed by the surface.  Sooner or later, some of the photons get into the camera's sensor, which, in turn, creates the finished image.  In essence, the ray tracing procedure imitates these steps to create photo-realistic images. <br><br>  In practice, the camera will reach only a small fraction of the photons emitted by the light source.  Therefore, thanks to the use of the <a href="https://en.wikipedia.org/wiki/Helmholtz_reciprocity">Heimholz</a> principle of <a href="https://en.wikipedia.org/wiki/Helmholtz_reciprocity">reversibility,</a> calculations are performed in the reverse order: instead of emitting photons from light sources, rays are emitted into the scene from the camera, reflected or refracted, and finally reach the light source. <br><br>  The ray tracer that we will create is based on <a href="https://dl.acm.org/citation.cfm%3Fid%3D358882">a 1980 article by Turner Whittedt</a> .  We can imitate sharp shadows and perfectly correct reflections.  In addition, the tracer will serve as the basis for more complex effects, such as refraction, diffuse global illumination, brilliant reflections and soft shadows. <br><br><h1>  The basics </h1><br>  Let's start by creating a new Unity project.  Create a C # <code>RayTracingMaster.cs</code> script and a <code>RayTracingMaster.cs</code> compute shader.  Paste the following base code into the C # script: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RayTracingMaster</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ComputeShader RayTracingShader; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RenderTexture _target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRenderImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RenderTexture source, RenderTexture destination</span></span></span><span class="hljs-function">)</span></span> { Render(destination); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RenderTexture destination</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Make sure we have a current render target InitRenderTexture(); // Set the target and dispatch the compute shader RayTracingShader.SetTexture(0, "Result", _target); int threadGroupsX = Mathf.CeilToInt(Screen.width / 8.0f); int threadGroupsY = Mathf.CeilToInt(Screen.height / 8.0f); RayTracingShader.Dispatch(0, threadGroupsX, threadGroupsY, 1); // Blit the result texture to the screen Graphics.Blit(_target, destination); } private void InitRenderTexture() { if (_target == null || _target.width != Screen.width || _target.height != Screen.height) { // Release render texture if we already have one if (_target != null) _target.Release(); // Get a render target for Ray Tracing _target = new RenderTexture(Screen.width, Screen.height, 0, RenderTextureFormat.ARGBFloat, RenderTextureReadWrite.Linear); _target.enableRandomWrite = true; _target.Create(); } } }</span></span></code> </pre> <br>  The <code>OnRenderImage</code> function <code>OnRenderImage</code> automatically called by Unity after the camera has finished rendering.  To render, we first need to create a target render (render target) with the appropriate sizes and report this to the compute shader.  0 is the index of the compute shader kernel function - we have only one. <br><br>  Then we <em>pass the</em> shader.  This means that we ask the GPU to do groups of threads that execute the code of our shader.  Each stream group consists of several streams, the number of which is specified in the shader itself.  The size and number of groups of threads can be specified in three dimensions, so you can simply apply compute shaders to tasks of any dimension.  In our case, we need to create one thread per pixel of the target render.  The default thread group size specified in the compute shader Unity template is <code>[numthreads(8,8,1)]</code> , so we will stick to it and create one thread group for every 8 √ó 8 pixels.  At the end we will write the result to the screen using <code>Graphics.Blit</code> . <br><br>  Let's check the program.  Add a <code>RayTracingMaster</code> component to the scene <code>RayTracingMaster</code> (this is important when calling <code>OnRenderImage</code> ), assign a compute shader and start the play mode.  You should see the output of the compute shader Unity template as a beautiful triangular fractal. <br><br><h1>  Camera </h1><br>  Now that we can display images on the screen, let's generate camera rays.  Since Unity provides us with a fully functional camera, we can simply use the calculated matrices for this.  Let's start by setting the matrices in the shader.  Add the following lines to the <code>RayTracingMaster.cs</code> script: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Camera _camera; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _camera = GetComponent&lt;Camera&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetShaderParameters</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayTracingShader.SetMatrix(<span class="hljs-string"><span class="hljs-string">"_CameraToWorld"</span></span>, _camera.cameraToWorldMatrix); RayTracingShader.SetMatrix(<span class="hljs-string"><span class="hljs-string">"_CameraInverseProjection"</span></span>, _camera.projectionMatrix.inverse); }</code> </pre> <br>  Before rendering, call <code>SetShaderParameters</code> from <code>OnRenderImage</code> . <br><br>  In the shader, we define the matrices, the structure of the <code>Ray</code> and the function to construct.  It should be noted that in HLSL, unlike C #, the declaration of a function or variable must be performed <em>before</em> they are used.  For the center of each screen pixel, we calculate the source and direction of the beam, and display the latter as a color.  Here is what the whole shader looks like: <br><br><pre> <code class="hljs rust">#pragma kernel CSMain RWTexture2D&lt;float4&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>; float4x4 _CameraToWorld; float4x4 _CameraInverseProjection; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ray</span></span></span></span> { float3 origin; float3 direction; }; Ray CreateRay(float3 origin, float3 direction) { Ray ray; ray.origin = origin; ray.direction = direction; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ray; } Ray CreateCameraRay(float2 uv) { <span class="hljs-comment"><span class="hljs-comment">// Transform the camera origin to world space float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz; // Invert the perspective projection of the view-space position float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz; // Transform the direction from camera to world space and normalize direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz; direction = normalize(direction); return CreateRay(origin, direction); } [numthreads(8,8,1)] void CSMain (uint3 id : SV_DispatchThreadID) { // Get the dimensions of the RenderTexture uint width, height; Result.GetDimensions(width, height); // Transform pixel to [-1,1] range float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f); // Get a ray for the UVs Ray ray = CreateCameraRay(uv); // Write some colors Result[id.xy] = float4(ray.direction * 0.5f + 0.5f, 1.0f); }</span></span></code> </pre> <br>  Try to rotate the camera in the inspector.  You will see that the "colored sky" behaves accordingly. <br><br>  Now let's replace the colors with a real skybox.  In my examples, I will use <a href="https://hdrihaven.com/hdri/%3Fc%3Doutdoor%26amp%3Bh%3Dcape_hill">Cape Hill</a> from the HDRI Haven website, but you can of course choose any other.  Download and drag it into Unity.  In the import parameters, do not forget to increase the maximum resolution if the resolution of the downloaded file is more than 2048. Now add <code>public Texture SkyboxTexture</code> to the script, assign the texture in the inspector and set it in the shader by adding this line to the <code>SetShaderParameters</code> function: <br><br><pre> <code class="hljs objectivec">RayTracingShader.SetTexture(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"_SkyboxTexture"</span></span>, SkyboxTexture);</code> </pre> <br>  In the shader, determine the texture and the corresponding sampler, as well as the constant that we will soon use: <br><br><pre> <code class="hljs objectivec">Texture2D&lt;float4&gt; _SkyboxTexture; SamplerState sampler_SkyboxTexture; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159265</span></span>f;</code> </pre> <br>  Now, instead of recording the color of the direction, we will sample the skybox.  To do this, we transform the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2584%25D0%25B5%25D1%2580%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BA%25D0%25BE%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582">Cartesian direction vector into spherical coordinates</a> and associate it with the texture coordinates.  <code>CSMain</code> last part of <code>CSMain</code> following: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Sample the skybox and write it float theta = acos(ray.direction.y) / -PI; float phi = atan2(ray.direction.x, -ray.direction.z) / -PI * 0.5f; Result[id.xy] = _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0);</span></span></code> </pre> <br><h1>  Tracing </h1><br>  So far so good.  Now we get down to the ray tracing itself.  Mathematically, we can calculate the intersection between the beam and the scene's geometry, and save the collision parameters (position, normal and distance along the beam).  If our beam collides with several objects, we will select the closest one.  Let's define in the shader struct <code>RayHit</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> RayHit { float3 position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance; float3 normal; }; <span class="hljs-function"><span class="hljs-function">RayHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRayHit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RayHit hit; hit.position = float3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); hit.distance = <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-meta"><span class="hljs-meta">#INF; hit.normal = float3(0.0f, 0.0f, 0.0f); return hit; }</span></span></code> </pre> <br>  Usually scenes consist of many triangles, but we start with a simple one: from the intersection of the infinite plane of the earth and several spheres! <br><br><h2>  Ground plane </h2><br>  Calculate the intersection of a line with an infinite plane as <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>y</mi><mo>=</mo><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.416ex" height="2.298ex" viewBox="0 -728.2 2332.1 989.6" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-79" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-3D" x="775" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-30" x="1831" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>y</mi><mo>=</mo><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> y = 0 </script>  - simple enough task.  However, we consider only collisions in the positive direction of the beam and discard all collisions that are no closer than a potential previous collision. <br><br>  By default, parameters in HLSL are passed by value, not by reference, so we will work only with a copy and will not be able to transfer changes to the calling function.  We pass <code>RayHit bestHit</code> with the <code>inout</code> qualifier to be able to modify the original struct.  This is what the shader code looks like: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> IntersectGroundPlane(Ray ray, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> RayHit bestHit) { // Calculate distance along the ray <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> the ground plane <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> intersected <span class="hljs-type"><span class="hljs-type">float</span></span> t = -ray.origin.y / ray.direction.y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = float3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f); } }</code> </pre> <br>  To use it, let's add the frame function <code>Trace</code> (as we expand it): <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">RayHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { RayHit bestHit = CreateRayHit(); IntersectGroundPlane(ray, bestHit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestHit; }</code> </pre> <br>  In addition, we need a basic shading function.  Here we transfer <code>Ray</code> to <code>inout</code> again - we will change it later when we talk about reflections.  For debugging purposes, we will return the normal when colliding with the geometry, and otherwise return to the skybox sampling code: <br><br><pre> <code class="hljs pgsql">float3 Shade(<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> Ray ray, RayHit hit) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hit.distance &lt; <span class="hljs-number"><span class="hljs-number">1.</span></span>#INF) { // <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> the normal <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hit.normal * <span class="hljs-number"><span class="hljs-number">0.5</span></span>f + <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Sample the skybox <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> it <span class="hljs-type"><span class="hljs-type">float</span></span> theta = acos(ray.direction.y) / -PI; <span class="hljs-type"><span class="hljs-type">float</span></span> phi = atan2(ray.direction.x, -ray.direction.z) / -PI * <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), <span class="hljs-number"><span class="hljs-number">0</span></span>).xyz; } }</code> </pre> <br>  We will use both functions in <code>CSMain</code> .  Delete the skybox sampling code, if you have not already done so, and add the following lines to trace the ray and shade the collision: <br><br><pre> <code class="hljs pgsql">// Trace <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> shade RayHit hit = Trace(ray); float3 result = Shade(ray, hit); Result[id.xy] = <span class="hljs-type"><span class="hljs-type">float4</span></span>(result, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><h2>  Sphere </h2><br>  The plane is not the most interesting object in the world, so let's immediately add a sphere.  Mathematical calculations of the intersection of a line and a sphere can be found on <a href="https://en.wikipedia.org/wiki/Line%25E2%2580%2593sphere_intersection">Wikipedia</a> .  This time we will have only two variants of the beam collisions: the input point <code>p1 - p2</code> and the output point <code>p1 + p2</code> .  First we will check the entry point, and use the exit point if the other does not fit.  In our case, the sphere is defined as the value <code>float4</code> , consisting of the position (xyz) and the radius (w).  Here is what the code looks like: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntersectSphere</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray, inout RayHit bestHit, float4 sphere</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Calculate distance along the ray where the sphere is intersected float3 d = ray.origin - sphere.xyz; float p1 = -dot(ray.direction, d); float p2sqr = p1 * p1 - dot(d, d) + sphere.w * sphere.w; if (p2sqr &lt; 0) return; float p2 = sqrt(p2sqr); float t = p1 - p2 &gt; 0 ? p1 - p2 : p1 + p2; if (t &gt; 0 &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(bestHit.position - sphere.xyz); } }</span></span></code> </pre> <br>  To add a sphere, simply call this function from <code>Trace</code> , like this: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Add a floating unit sphere IntersectSphere(ray, bestHit, float4(0, 3.0f, 0, 1.0f));</span></span></code> </pre> <br><h1>  Smoothing </h1><br>  The approach used has one problem: we check only the center of each pixel, so as a result, distortions will be noticeable (ugly "ladders").  To get around this problem, we will trace not one, but several rays per pixel.  Each beam receives a random offset within the pixel region.  To maintain an acceptable level of frame rate, we will perform progressive sampling, that is, trace one ray per pixel per frame and average the value over time if the camera is not moving.  Every time the camera moves (or changes to any other parameters ‚Äî the scope, scene geometry, or lighting) we‚Äôll have to start all over again. <br><br>  Let's create a very simple image effect shader, which we apply to add together several results.  <code>AddShader</code> call this shader <code>AddShader</code> and check that there is a <code>Shader "Hidden/AddShader"</code> in the first line.  After <code>Cull Off ZWrite Off ZTest Always</code> add <code>Blend SrcAlpha OneMinusSrcAlpha</code> to enable alpha blending.  Then replace the <code>frag</code> function with the following lines: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> _Sample; <span class="hljs-type"><span class="hljs-type">float4</span></span> frag (v2f i) : SV_Target { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">float4</span></span>(tex2D(_MainTex, i.uv).rgb, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f / (_Sample + <span class="hljs-number"><span class="hljs-number">1.0</span></span>f)); }</code> </pre> <br>  Now this shader will simply draw the first sample with opacity <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  following with opacity <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.469ex" height="2.419ex" viewBox="0 -780.1 3216 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-63" x="1781" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-31" x="2215" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-32" x="2715" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ frac {1} {2} </script>  then <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>3</mn></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.469ex" height="2.419ex" viewBox="0 -780.1 3216 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-63" x="1781" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-31" x="2215" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-33" x="2715" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mn>3</mn></mrow></math></span></span><script type="math/tex" id="MathJax-Element-4"> \ frac {1} {3} </script>  and so on, averaging all samples with equal weight. <br><br>  In the script, we need to count samples and apply an image effect shader: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> _currentSample = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Material _addMaterial;</code> </pre> <br>  Also, when rebuilding the target render in <code>InitRenderTexture</code> we need to reset <code>_currentSamples = 0</code> and add the <code>Update</code> function that recognizes the change in camera transformations: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transform.hasChanged) { _currentSample = <span class="hljs-number"><span class="hljs-number">0</span></span>; transform.hasChanged = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  To use our shader, we need to initialize the material, inform it about the current sample and use it to insert it into the screen in the <code>Render</code> function: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Blit the result texture to the screen if (_addMaterial == null) _addMaterial = new Material(Shader.Find("Hidden/AddShader")); _addMaterial.SetFloat("_Sample", _currentSample); Graphics.Blit(_target, destination, _addMaterial); _currentSample++;</span></span></code> </pre> <br>  So, we are already performing progressive sampling, but still use the center of the pixel.  In the compute shader, set the <code>float2 _PixelOffset</code> and use it in <code>CSMain</code> instead of the hard-coded offset <code>float2(0.5f, 0.5f)</code> .  Let's <code>SetShaderParameters</code> back to the script and create a random offset by adding the following line to <code>SetShaderParameters</code> : <br><br><pre> <code class="cs hljs">RayTracingShader.SetVector(<span class="hljs-string"><span class="hljs-string">"_PixelOffset"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>));</code> </pre> <br>  If you move the camera, you can see that the image is still visible distortion, but they quickly disappear, if you stand still a couple of frames.  Here is a comparison of what we did: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/009/7ea/1760097eafddf684da7b6e80e4264ac3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b1/510/6be/9b15106beb041c8abff7e94ffac9901c.png"></div><br><h1>  Reflection </h1><br>  The foundation for our ray tracer is ready, so we can proceed to the difficult things that actually distinguish ray tracing compared to other rendering techniques.  First on this list are perfect reflections.  The idea is simple: when we encounter a surface, we reflect the beam in accordance with the law of reflection, which you may remember from school (angle of incidence = angle of reflection), reduce its energy and repeat the process until the beam hits the sky, or he will not run out of energy after a specified number of reflections. <br><br>  In the shader, add the <code>float3 energy</code> variable to the ray and initialize it in the <code>CreateRay</code> function as <code>ray.energy = float3(1.0f, 1.0f, 1.0f)</code> .  Initially, the beam will have maximum values ‚Äã‚Äãin all color channels, which will decrease with each reflection. <br><br>  We will perform a maximum of 8 traces (source beam plus 7 reflections), and add the results in the <code>Shade</code> function calls, but multiplied by the beam energy.  For example, imagine that the beam was reflected once and lost <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>3</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>4</mn></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.469ex" height="2.419ex" viewBox="0 -780.1 3216 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-63" x="1781" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-33" x="2215" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-34" x="2715" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mn>3</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mn>4</mn></mrow></math></span></span><script type="math/tex" id="MathJax-Element-5"> \ frac {3} {4} </script>  its energy.  Then it continues to move and collides with the sky, so we only transfer to the pixel <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>4</mn></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.469ex" height="2.419ex" viewBox="0 -780.1 3216 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-63" x="1781" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-31" x="2215" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-34" x="2715" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mn>4</mn></mrow></math></span></span><script type="math/tex" id="MathJax-Element-6"> \ frac {1} {4} </script>  energy of the sky.  Modify <code>CSMain</code> as follows, replacing previous calls to <code>Trace</code> and <code>Shade</code> : <br><br><pre> <code class="hljs pgsql">// Trace <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> shade float3 result = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { RayHit hit = Trace(ray); result += ray.energy * Shade(ray, hit); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>(ray.energy)) break; }</code> </pre> <br>  Our <code>Shade</code> function now also performs energy updating and generating a reflected beam, which is why <code>inout</code> becomes important here.  To refresh the energy, we perform elementwise multiplication by the reflected color of the surface.  For example, for gold, the specular reflection coefficient is approximately equal to <code>float3(1.0f, 0.78f, 0.34f)</code> , that is, it reflects 100% red, 78% green and only 34% blue, giving the reflection a characteristic golden hue.  Be careful, none of these values ‚Äã‚Äãshould exceed 1, because otherwise the energy will be created from nowhere.  In addition, reflectivity is often lower than one might think.  For example, see some values ‚Äã‚Äãon slide 64 in the article by <a href="http://blog.selfshadow.com/publications/s2015-shading-course/hoffman/s2015_pbs_physics_math_slides.pdf">Physics and Math of Shading by</a> Netie Hofman. <br><br>  HLSL has a built-in function to reflect the beam with a given normal, and this is convenient.  Because of the inaccuracy of floating-point numbers, it may happen that the reflected beam is blocked by the surface from which it is reflected.  To avoid this, we slightly shift the position along the normal direction.  This is what the new <code>Shade</code> feature looks like: <br><br><pre> <code class="hljs pgsql">float3 Shade(<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> Ray ray, RayHit hit) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hit.distance &lt; <span class="hljs-number"><span class="hljs-number">1.</span></span>#INF) { float3 specular = float3(<span class="hljs-number"><span class="hljs-number">0.6</span></span>f, <span class="hljs-number"><span class="hljs-number">0.6</span></span>f, <span class="hljs-number"><span class="hljs-number">0.6</span></span>f); // Reflect the ray <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> multiply energy <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> specular reflection ray.origin = hit.position + hit.normal * <span class="hljs-number"><span class="hljs-number">0.001</span></span>f; ray.direction = reflect(ray.direction, hit.normal); ray.energy *= specular; // <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Erase the ray<span class="hljs-string"><span class="hljs-string">'s energy - the sky doesn'</span></span>t reflect anything ray.energy = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; // Sample the skybox <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> it <span class="hljs-type"><span class="hljs-type">float</span></span> theta = acos(ray.direction.y) / -PI; <span class="hljs-type"><span class="hljs-type">float</span></span> phi = atan2(ray.direction.x, -ray.direction.z) / -PI * <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), <span class="hljs-number"><span class="hljs-number">0</span></span>).xyz; } }</code> </pre> <br>  You can try to slightly increase the brightness of the skybox by multiplying it by a factor of more than 1. Now experiment with the <code>Trace</code> function.  Put several spheres into the loop and the result will be as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/538/dbc/b1f/538dbcb1fbc9669f19a1a2df582e08a9.png"></div><br><h1>  Directional light source </h1><br>  So, we can trace the specular reflections, which allows us to render smooth metal surfaces, but for non-metallic surfaces we need another property: diffuse reflection.  In short, metals only reflect the incident light with a hint of their reflection color, and non-metals allow the light to be refracted on the surface, diffuse and leave it in a random direction, colored in the color of its albedo.  In the case of an ideal <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%259B%25D0%25B0%25D0%25BC%25D0%25B1%25D0%25B5%25D1%2580%25D1%2582%25D0%25B0">Lamberto surface</a> , which is commonly used, the probability is proportional to the cosine of the angle between the above direction and the normal of the surface.  This topic is discussed in more detail <a href="https://computergraphics.stackexchange.com/questions/1513/how-physically-based-is-the-diffuse-and-specular-distinction">here</a> . <br><br>  To get started with ambient lighting, let's add a <code>public Light DirectionalLight</code> to <code>RayTracingMaster</code> and set a directional light source in the scene.  You may also need to recognize changes to the light source transformations in the <code>Update</code> function, as we did with the camera transformations.  Now add the following lines to the <code>SetShaderParameters</code> function: <br><br><pre> <code class="cs hljs">Vector3 l = DirectionalLight.transform.forward; RayTracingShader.SetVector(<span class="hljs-string"><span class="hljs-string">"_DirectionalLight"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(lx, ly, lz, DirectionalLight.intensity));</code> </pre> <br>  In the shader, define <code>float4 _DirectionalLight</code> .  In the <code>Shade</code> function, determine the color of the albedo immediately after the specular color: <br><br><pre> <code class="hljs go">float3 albedo = float3(<span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>);</code> </pre> <br>  Replace returned black values ‚Äã‚Äãwith simple diffuse shading: <br><br><pre> <code class="hljs lisp">// Return a diffuse-shaded color return saturate(<span class="hljs-name"><span class="hljs-name">dot</span></span>(<span class="hljs-name"><span class="hljs-name">hit</span></span>.normal, _DirectionalLight.xyz) * -1) * _DirectionalLight.w * albedo;</code> </pre> <br>  Do not forget that the scalar product is defined as <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mi>b</mi><mo>=</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mtext>&amp;#xA0;</mtext><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>b</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>o</mi><mi>s</mi><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>h</mi><mi>e</mi><mi>t</mi><mi>a</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="27.797ex" height="2.66ex" viewBox="0 -832 11968.1 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-61" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-63" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-64" x="1213" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-6F" x="1736" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-74" x="2222" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-62" x="2583" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-3D" x="3290" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-7C" x="4347" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-7C" x="4625" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-61" x="4904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-7C" x="5433" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-7C" x="5712" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-7C" x="6240" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-7C" x="6519" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-62" x="6797" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-7C" x="7227" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-7C" x="7505" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-63" x="8034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-6F" x="8467" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-73" x="8953" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-74" x="9672" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-68" x="10034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-65" x="10610" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-74" x="11077" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMATHI-61" x="11438" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mtext>&nbsp;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mi>b</mi><mo>=</mo><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mtext>&nbsp;</mtext><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mi>b</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">|</mo></mrow><mtext>&nbsp;</mtext><mi>c</mi><mi>o</mi><mi>s</mi><mtext>&nbsp;</mtext><mi>t</mi><mi>h</mi><mi>e</mi><mi>t</mi><mi>a</mi></math></span></span><script type="math/tex" id="MathJax-Element-7"> a \ cdot b = || a || \ || b || \ cos \ theta </script>  .  Since both our vectors (the normal and the direction of light) are of unit length, we need exactly the scalar product: the cosine of the angle.  The beam and the light have opposite directions, so under direct illumination the scalar product returns not 1, but -1.  To accommodate this, we must change the sign.  Finally, we saturate this value (for example, we limit it in the interval <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.653ex" height="2.66ex" viewBox="0 -832 2003.2 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-5B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-30" x="278" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-2C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-31" x="1224" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/355018/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiNP6VA44OHqS0qt5FMASHpIBXiYg#MJMAIN-5D" x="1724" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></math></span></span><script type="math/tex" id="MathJax-Element-8"> [0,1] </script>  ) to avoid negative energy. <br><br>  In order for the directional light source to cast shadows, we need to trace the shadow beam.  It begins at the surface position considered (also with a very small offset to avoid self-shadowing), and points in the direction from which the light came.  If something blocks its path to infinity, then we will not use ambient lighting.  Add these lines above the diffuse color return: <br><br><pre> <code class="hljs pgsql">// Shadow test ray <span class="hljs-type"><span class="hljs-type">bool</span></span> shadow = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Ray shadowRay = CreateRay(hit.position + hit.normal * <span class="hljs-number"><span class="hljs-number">0.001</span></span>f, <span class="hljs-number"><span class="hljs-number">-1</span></span> * _DirectionalLight.xyz); RayHit shadowHit = Trace(shadowRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shadowHit.distance != <span class="hljs-number"><span class="hljs-number">1.</span></span>#INF) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f); }</code> </pre> <br>  Now we can trace the glossy plastic spheres with sharp shadows!  If you set 0.04 for specular and 0.8 for albedo, then we get the following results: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af5/029/f17/af5029f17bffce5f7489ff5e8420b26b.png"></div><br><h1>  Scene and materials </h1><br>  Let's now start creating more complex and colorful scenes!  Instead of a hard task of everything in the shader, for greater versatility, we will set the scene in C #. <br><br>  To begin, we expand the <code>RayHit</code> structure in the shader.  Instead of the global setting of material properties in the <code>Shade</code> function, we will define them for each object and store them in <code>RayHit</code> .  Add <code>float3 albedo</code> and <code>float3 specular</code> to struct <code>float3 albedo</code> and initialize them with <code>float3(0.0f, 0.0f, 0.0f)</code> <code>CreateRayHit</code> in <code>CreateRayHit</code> .  Also, change the <code>Shade</code> function so that it uses these values ‚Äã‚Äãfrom <code>hit</code> instead of the hard-coded values. &lt; <br><br>  In order to understand in general what a sphere is in a CPU and a GPU, we define the struct <code>Sphere</code> in the shader and in the script in C #.  From the side of the shader, it looks like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> float3 position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; float3 albedo; float3 specular; };</code> </pre> <br>  Copy this structure into a script in C #. <br><br>  In the shader, we need to make the <code>IntersectSphere</code> function work with our struct, and not with <code>float4</code> .  This is easy to do: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> IntersectSphere(Ray ray, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> RayHit bestHit, Sphere sphere) { // Calculate distance along the ray <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> the sphere <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> intersected float3 d = ray.origin - sphere.position; <span class="hljs-type"><span class="hljs-type">float</span></span> p1 = -dot(ray.direction, d); <span class="hljs-type"><span class="hljs-type">float</span></span> p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p2sqr &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> p2 = sqrt(p2sqr); <span class="hljs-type"><span class="hljs-type">float</span></span> t = p1 - p2 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? p1 - p2 : p1 + p2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; t &lt; bestHit.distance) { bestHit.distance = t; bestHit.position = ray.origin + t * ray.direction; bestHit.normal = normalize(bestHit.position - sphere.position); bestHit.albedo = sphere.albedo; bestHit.specular = sphere.specular; } }</code> </pre> <br>  Also set <code>bestHit.albedo</code> and <code>bestHit.specular</code> in the <code>IntersectGroundPlane</code> function to customize its material. <br><br>  Then define the <code>StructuredBuffer&lt;Sphere&gt; _Spheres</code> .  In this place the CPU will store all the spheres that make up the scene.  Remove all hard-coded spheres from the <code>Trace</code> function and add the following lines: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Trace spheres uint numSpheres, stride; _Spheres.GetDimensions(numSpheres, stride); for (uint i = 0; i &lt; numSpheres; i++) IntersectSphere(ray, bestHit, _Spheres[i]);</span></span></code> </pre> <br>  Now we breathe some life into the scene.  Let's add common parameters to the C # script to control the location of the spheres and the compute buffer: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 SphereRadius = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">3.0f</span></span>, <span class="hljs-number"><span class="hljs-number">8.0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> SpheresMax = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SpherePlacementRadius = <span class="hljs-number"><span class="hljs-number">100.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ComputeBuffer _sphereBuffer;</code> </pre> <br>  We will set up the scene in <code>OnEnable</code> and free the buffer in <code>OnDisable</code> .  Thus, each time the component is turned on, a random scene will be generated.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><code>SetUpScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will try to position the spheres in a certain radius and discard those that intersect existing ones. </font><font style="vertical-align: inherit;">Half of the spheres are metallic (black albedo, colored specular), the other half is non-metallic (colored albedo, 4% specular):</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _currentSample = <span class="hljs-number"><span class="hljs-number">0</span></span>; SetUpScene(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sphereBuffer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) _sphereBuffer.Release(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetUpScene</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;Sphere&gt; spheres = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Sphere&gt;(); <span class="hljs-comment"><span class="hljs-comment">// Add a number of random spheres for (int i = 0; i &lt; SpheresMax; i++) { Sphere sphere = new Sphere(); // Radius and radius sphere.radius = SphereRadius.x + Random.value * (SphereRadius.y - SphereRadius.x); Vector2 randomPos = Random.insideUnitCircle * SpherePlacementRadius; sphere.position = new Vector3(randomPos.x, sphere.radius, randomPos.y); // Reject spheres that are intersecting others foreach (Sphere other in spheres) { float minDist = sphere.radius + other.radius; if (Vector3.SqrMagnitude(sphere.position - other.position) &lt; minDist * minDist) goto SkipSphere; } // Albedo and specular color Color color = Random.ColorHSV(); bool metal = Random.value &lt; 0.5f; sphere.albedo = metal ? Vector3.zero : new Vector3(color.r, color.g, color.b); sphere.specular = metal ? new Vector3(color.r, color.g, color.b) : Vector3.one * 0.04f; // Add the sphere to the list spheres.Add(sphere); SkipSphere: continue; } // Assign to compute buffer _sphereBuffer = new ComputeBuffer(spheres.Count, 40); _sphereBuffer.SetData(spheres); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The magic number 40 </font></font><code>new ComputeBuffer(spheres.Count, 40)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the step of our buffer, i.e. </font><font style="vertical-align: inherit;">the size of one sphere in memory in bytes. </font><font style="vertical-align: inherit;">To calculate it, let's calculate the number of float in a struct </font></font><code>Sphere</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and multiply it by the byte size of float (4 bytes). </font><font style="vertical-align: inherit;">Finally, set the shader buffer in the function </font></font><code>SetShaderParameters</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cs hljs">RayTracingShader.SetBuffer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"_Spheres"</span></span>, _sphereBuffer);</code> </pre> <br><h1>  results </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Congratulations, we did it! </font><font style="vertical-align: inherit;">Now we have a ready-built Whitted ray tracer on the GPU, capable of rendering many spheres with specular reflections, simple diffused lighting and sharp shadows. </font><font style="vertical-align: inherit;">The full source code is uploaded to </font></font><a href="https://bitbucket.org/Daerst/gpu-ray-tracing-in-unity/src/Tutorial_Pt1/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitbucket</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Experiment with the parameters of the placement of the spheres and watch the beautiful views:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c77/4fc/7bc/c774fc7bc40c87c6c93552481e3c514e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/823/912/96a/82391296a8247aec68737d4998b60e18.png"></div><br><h1>  What's next? </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Today we have achieved a lot, but much more can be realized: diffuse global illumination, soft shadows, partially transparent materials with refractions and, obviously, using triangles instead of spheres. </font><font style="vertical-align: inherit;">In the next article, we will expand our Whitted ray tracer into the path tracer to master some of the listed phenomena.</font></font></div><p>Source: <a href="https://habr.com/ru/post/355018/">https://habr.com/ru/post/355018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../355006/index.html">RIPE distributed the last block / 22 of the last block / 8. What's next?</a></li>
<li><a href="../355008/index.html">May 19, welcome to Badoo Techleads Meetup # 3</a></li>
<li><a href="../355010/index.html">Check Point Dashboards - that's what I love</a></li>
<li><a href="../355014/index.html">Telegram bot development for Instagram</a></li>
<li><a href="../355016/index.html">Common mistakes made by developers in the UX</a></li>
<li><a href="../355020/index.html">Signal processing in PHP, or cooking delicious</a></li>
<li><a href="../355022/index.html">Project Arena - webinar for creators of serious VR projects</a></li>
<li><a href="../355024/index.html">Rethinking Conference</a></li>
<li><a href="../355026/index.html">Approaches to connecting Internet of Things to the network</a></li>
<li><a href="../355088/index.html">How to demoralize employees: A guide for bad companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>