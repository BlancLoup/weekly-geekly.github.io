<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write fast and economical JavaScript code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A JS engine like Google‚Äôs V8 (Chrome, Node) is designed to run large applications quickly. If during development you are concerned about efficient use...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write fast and economical JavaScript code</h1><div class="post__text post__text-html js-mediator-article">  A JS engine like Google‚Äôs <a href="http://code.google.com/p/v8/">V8</a> (Chrome, Node) is designed to run large applications quickly.  If during development you are concerned about efficient use of memory and speed, you need to know something about the processes running in the JS browser engine. <br><br>  Whatever it is - V8, <a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey">SpiderMonkey</a> (Firefox), <a href="http://my.opera.com/ODIN/blog/carakan-faq">Carakan</a> (Opera), <a href="http://en.wikipedia.org/wiki/Chakra_(JScript_engine)">Chakra</a> (IE) or something else, knowing the internal processes will help you optimize the performance of your applications.  But do not urge you to optimize the engine for a single browser or engine - do not do so. <br><br>  Ask yourself a question: <br>  - can something in my code be made more efficient? <br>  - what optimization is performed by popular JS engines? <br>  - that the engine cannot compensate, and can garbage collection clean up everything the way I expect from it? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/c1d/a94/5ae/c1da945ae17641d1b3eb709b46fb1a1b.jpg"><br><br>  There are many traps associated with efficient memory use and speed, and in this article we will explore some approaches that have shown themselves well in tests. <br><a name="habracut"></a><br><h4>  And how does JS work in V8? </h4><br>  Although it is possible to develop large applications without a proper understanding of the JS engine, any car owner will tell you that he has ever looked under the hood of a car.  Since I like the Chrome browser, I‚Äôll tell you about its JavaScript engine.  V8 consists of several main parts. <br><br>  - <b>The main compiler</b> , which processes the JS and issues the machine code before its execution, instead of executing bytecode or simply interpreting it.  This code is usually not very optimized. <br>  - V8 converts objects into an <b>object model</b> .  In JS, objects are implemented as associative arrays, but in V8 they are represented by <a href="https://developers.google.com/v8/design">hidden classes</a> , which are an internal type system for optimized search. <br>  - a <b>runtime profiler</b> that monitors system operation and defines ‚Äúhot‚Äù functions (code that takes a long time to execute) <br>  - an <b>optimizing compiler</b> that recompiles and optimizes hot code, and does other optimizations, such as inlining <br>  - V8 supports <b>deoptimization</b> when the optimizing compiler rolls back if it detects that it has made some too optimistic assumptions when parsing the code <br>  - <b>garbage collection</b> .  The idea of ‚Äã‚Äãits work is just as important as the idea of ‚Äã‚Äãoptimization. <br><br><h4>  Garbage collection </h4><br>  This is one form of memory management.  The collector tries to reclaim the memory occupied by objects that are no longer in use.  In a language with garbage collection support, objects that still have links are not cleared. <br><br>  Almost always you can not delete links to objects manually.  Simply placing the variables where they are needed (ideally, the more local, the better - inside the functions that use them, and not in the external scope), you can achieve normal operation. <br><br><img src="https://habrastorage.org/files/b51/a90/cd0/b51a90cd06be4a28a9bb305661bbb976.jpg"><br><br>  In JS, you can't force garbage collection to work.  This does not need to be done, because this process is controlled at runtime, and he knows better when and what to clean. <br><br><h5>  Errors with deleting references to objects </h5><br>  In some disputes online about returning memory to JS, the delete keyword appears.  Although initially it is intended to delete keys, some developers believe that it can be used to force the removal of links.  Avoid using delete.  In the example below, delete ox does more harm than good, because it changes the hidden class of o and makes it a slow object. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ox; <span class="hljs-comment"><span class="hljs-comment">// true ox; // undefined</span></span></code> </pre> <br><br>  You will definitely find references to delete in many popular JS libraries, because it makes sense.  The main thing that needs to be learned is that there is no need to change the structure of ‚Äúhot‚Äù objects during program execution.  JS engines can recognize such ‚Äúhot‚Äù objects and try to optimize them.  It will be easier to do if the structure of the object does not change much, and delete just leads to such changes. <br><br>  There is also a lack of understanding about how null works.  Setting an object reference to null does not reset an object.  Writing ox = null is better than using delete, but it doesn't make sense. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; o = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; o; <span class="hljs-comment"><span class="hljs-comment">// null ox // TypeError</span></span></code> </pre><br><br>  If this link was the last object reference, then the garbage collector will clean it up.  If this was not the last link, it can be reached, and the collector will not pick it up. <br><br>  One more note: global variables are not cleaned up by the garbage collector while the page is running.  No matter how long it is open, variables in the scope of the global object will exist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myGlobalNamespace = {};</code> </pre><br><br>  Global variables are cleared when the page is reloaded, moving to another page, closing a bookmark, or exiting the browser.  Variables from the scope of a function are cleared when the scope disappears ‚Äî when the function exits and there are no more references to them. <br><br><h5>  Simple rules </h5><br>  In order for garbage collection to work as early as possible and to collect as many objects as possible, do not hold onto objects that you do not need.  Usually this happens automatically, but this is what you need to remember: <br><br>  - A good alternative to manually deleting links is to use variables with the correct scope.  Instead of assigning a global variable to null, use a variable local to the function that disappears when the scope disappears.  The code gets cleaner and less worries arise. <br>  - Ensure that you remove event handlers when they are no longer needed, especially before removing the DOM elements to which they are attached. <br>  - When using a local data cache, make sure that you have cleared it, or used an aging mechanism, so as not to store large unnecessary pieces of data. <br><br><h5>  Functions </h5><br>  Now let's turn to the functions.  As we have already said, garbage collection frees the used memory blocks (objects), which cannot be reached.  To illustrate - a few examples. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LargeObject(); bar.someCall(); }</code> </pre><br><br>  Upon returning from foo, the object pointed to by bar will be cleared by the garbage collector, since nothing is referenced to it. <br><br>  Compare with: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LargeObject(); bar.someCall(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar; } <span class="hljs-comment"><span class="hljs-comment">// -    var b = foo();</span></span></code> </pre><br><br>  Now we have a reference to an object that persists until the code that called the function assigns anything else to b (or until b goes out of scope). <br><br><h5>  Closures </h5><br>  When you meet a function that returns an internal function, then the internal one has access to the field of view outside of it, even after the end of the external function.  This is the closure - an expression that can work with variables from the selected context.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumIt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumIt; } <span class="hljs-comment"><span class="hljs-comment">//  var sumA = sum(4); var sumB = sumA(3); console.log(sumB); //  7</span></span></code> </pre><br><br>  The garbage collector cannot tidy up the created functional object, since it still has access, for example, through sumA (n).  Here is another example.  Can we get access to largeStr? <br><br>  var a = function () { <br>  var largeStr = new Array (1000000) .join ('x'); <br>  return function () { <br>  return largeStr; <br>  }; <br>  } (); <br><br>  Yes - through a (), so it, too, is not eliminated by the collector.  How about this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> smallStr = <span class="hljs-string"><span class="hljs-string">'x'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> largeStr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000000</span></span>).join(<span class="hljs-string"><span class="hljs-string">'x'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> smallStr; }; }();</code> </pre><br><br>  We no longer have access to it, so it can be cleaned up. <br><br><h5>  Timers </h5><br>  One of the worst places for leaks is a loop, or in a pair of setTimeout () / setInterval (), although this is a common problem.  Consider an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myObj = { <span class="hljs-attr"><span class="hljs-attr">callMeMaybe</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myRef = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' !'</span></span>); myRef.callMeMaybe(); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); } };</code> </pre><br><br>  If we do <br><br><pre> <code class="javascript hljs">myObj.callMeMaybe();</code> </pre><br><br>  to start the timer, every second ‚ÄúTime is up!‚Äù will be displayed.  If we do: <br><br><pre> <code class="javascript hljs">myObj = <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre><br><br>  the timer will continue to work anyway.  myObj cannot be cleaned up since the closure passed to setTimeout continues to exist.  In turn, it stores references to myObj via myRef.  This is the same as if we passed the closure to any other function, leaving references to it. <br><br>  It must be remembered that the links inside setTimeout / setInterval calls, such as functions, must be executed and terminated before they can be cleared. <br><br><h4>  Fear performance traps </h4><br>  It is important not to optimize the code prematurely.  You can get carried away with micro tests that say that N is faster than M in V8, but the real contribution of these things to the finished module may be much less than you think. <br><br><img src="https://habrastorage.org/files/2e8/e8e/3df/2e8e8e3df09145d3957483fd4b13c332.jpg"><br><br>  Let's say we need a module that: <br>  - reads from the local source data having numerical id; <br>  - draws a plate with this data; <br>  - adds event handlers for cell clicks. <br><br>  Immediately there are questions.  How to store data?  How to effectively draw a label and insert it into the DOM?  How to handle events in an optimal way? <br><br>  The first and naive approach is to store each piece of data in an object that can be grouped into an array.  You can use jQuery to crawl data and draw a table, and then add it to the DOM.  Finally, you can use event binding to add click behavior. <br><br>  <b>Here's how you should NOT do it:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleA = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: dataArrayObject, <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addTable(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addEvents(); }, <span class="hljs-attr"><span class="hljs-attr">addTable</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rows; i++) { $tr = $(<span class="hljs-string"><span class="hljs-string">'&lt;tr&gt;&lt;/tr&gt;'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length; j++) { $tr.append(<span class="hljs-string"><span class="hljs-string">'&lt;td&gt;'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data[j][<span class="hljs-string"><span class="hljs-string">'id'</span></span>] + <span class="hljs-string"><span class="hljs-string">'&lt;/td&gt;'</span></span>); } $tr.appendTo($tbody); } }, <span class="hljs-attr"><span class="hljs-attr">addEvents</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $(<span class="hljs-string"><span class="hljs-string">'table td'</span></span>).on(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).toggleClass(<span class="hljs-string"><span class="hljs-string">'active'</span></span>); }); } }; }();</code> </pre><br><br>  Cheap and angry. <br><br>  However, in this example, we pass only by id, by numeric properties, which could be represented more simply as an array.  In addition, direct use of DocumentFragment and native DOM methods is more optimal than using jQuery to create a table, and of course, processing events through the parent element will be much faster. <br><br>  jQuery behind the scenes directly uses DocumentFragment, but in our example, the code calls append () in a loop, and each of the calls does not know about the others, so the code may not be optimized.  Maybe it's not scary, but it's better to check it through tests. <br><br>  Adding the following changes will speed up the script. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleD = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: dataArray, <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addTable(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addEvents(); }, <span class="hljs-attr"><span class="hljs-attr">addTable</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> td, tr; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frag = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createDocumentFragment(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> frag2 = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createDocumentFragment(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rows; i++) { tr = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'tr'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length; j++) { td = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'td'</span></span>); td.appendChild(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createTextNode(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data[j])); frag2.appendChild(td); } tr.appendChild(frag2); frag.appendChild(tr); } tbody.appendChild(frag); }, <span class="hljs-attr"><span class="hljs-attr">addEvents</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $(<span class="hljs-string"><span class="hljs-string">'table'</span></span>).on(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-string"><span class="hljs-string">'td'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).toggleClass(<span class="hljs-string"><span class="hljs-string">'active'</span></span>); }); } }; }();</code> </pre><br><br>  Let's look at other ways to improve performance.  You could read somewhere that the prototype model is more optimal than the module model.  Or, that frameworks for working with templates are highly optimized.  Sometimes this is true, but mostly they are useful because the code becomes more readable.  And still it is necessary to do precompilation.  Let's check these statements: <br><br><pre> <code class="javascript hljs">moduleG = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; moduleG.prototype.data = dataArray; moduleG.prototype.init = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addTable(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addEvents(); }; moduleG.prototype.addTable = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> template = _.template($(<span class="hljs-string"><span class="hljs-string">'#template'</span></span>).text()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> html = template({<span class="hljs-string"><span class="hljs-string">'data'</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data}); $tbody.append(html); }; moduleG.prototype.addEvents = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $(<span class="hljs-string"><span class="hljs-string">'table'</span></span>).on(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-string"><span class="hljs-string">'td'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).toggleClass(<span class="hljs-string"><span class="hljs-string">'active'</span></span>); }); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modG = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> moduleG();</code> </pre><br><br>  It turns out that in this case the advantages in speed are negligible.  These things are not used because of speed, but because of readability, inheritance model and maintainability. <br><br>  More complex problems - drawing pictures on canvas and working with pixels.  Always check what speed tests do before using them.  It is possible that their checks and restrictions will be so artificial that they will not be useful to you in the world of real applications.  All optimization is better to test in the complete code. <br><br><h4>  Optimization Tips for V8 </h4><br>  We will not give absolutely all the tips, but dwell on the most necessary. <br><br>  - Some models interfere with optimization, for example a bunch of try-catch.  Details on which functions can or cannot be optimized can be extracted from the d8 utility with the help of the command --trace-opt file.js <br>  - try to keep your functions monomorphic, i.e.  so that the variables (including properties, arrays, and function parameters) always contain only objects from the same hidden class.  For example, do not do this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); add(<span class="hljs-string"><span class="hljs-string">'a'</span></span>,<span class="hljs-string"><span class="hljs-string">'b'</span></span>); add(my_custom_object, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>);</code> </pre><br><br>  - do not boot from non-initialized or deleted items <br>  - do not write huge functions, since  they are harder to optimize <br><br><h5>  Objects or arrays? </h5><br>  - to store a heap of numbers or a list of similar objects, use an array <br>  - if semantics requires an object with properties (of different types), use an object.  This is quite effective in terms of memory, and quite quickly. <br>  - on elements with integer indices, iteration will be faster than on object properties <br>  - properties of objects - a complex thing, they can be created through setters, with different numbering and recording capabilities.  Elements of arrays cannot be configured this way - they are either there or they are not.  From the point of view of the engine, this helps optimize performance.  Especially if the array contains numbers.  For example, when working with vectors, use an array instead of an object with x, y, z properties. <br><br>  There is one major difference between arrays and objects in JS - the length property.  If you track this parameter yourself, then objects will be about as fast as arrays. <br><br><h5>  Tips for using objects </h5><br>  Create objects through the constructor.  Then all objects will have one hidden class.  Also, it is slightly faster than Object.create (). <br><br>  There are no restrictions on the number of different types of objects and their complexity (within reasonable limits - long chains of prototypes are harmful, and objects with a small number of properties are represented by the engine somewhat differently and slightly faster than large ones).  For ‚Äúhot‚Äù objects, try to make short chains of inheritance and a small number of properties. <br><br><h5>  Cloning objects </h5><br>  A common problem.  Be careful about copying big things - it usually happens slowly.  It is especially bad to use for this cycles for..in, which work slowly in any engines. <br><br>  When you really need to quickly copy an object, use an array or a special function that directly copies each property.  This will be the fastest: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">original</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foo = original.foo; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bar = original.bar; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> copy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> clone(original);</code> </pre><br><br><h5>  Caching Functions in the Modular Model </h5><br>  This technique can improve performance.  Those variants of the example below, which you probably met, are likely to work more slowly, because  they create member functions all the time. <br><br><img src="//habrastorage.org/files/c02/98c/7cf/c0298c7cfda341e89d6863357d16a6da.png"><br><br>  Here is a test for the performance of prototypes against modules: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   Klass1 = function () {} Klass1.prototype.foo = function () { log('foo'); } Klass1.prototype.bar = function () { log('bar'); } //   Klass2 = function () { var foo = function () { log('foo'); }, bar = function () { log('bar'); }; return { foo: foo, bar: bar } } //     var FooFunction = function () { log('foo'); }; var BarFunction = function () { log('bar'); }; Klass3 = function () { return { foo: FooFunction, bar: BarFunction } } //   //  var i = 1000, objs = []; while (i--) { var o = new Klass1() objs.push(new Klass1()); o.bar; o.foo; } //  var i = 1000, objs = []; while (i--) { var o = Klass2() objs.push(Klass2()); o.bar; o.foo; } //     var i = 1000, objs = []; while (i--) { var o = Klass3() objs.push(Klass3()); o.bar; o.foo; } //     </span></span></code> </pre><br><br>  If you do not need a class, do not create it.  Here is an example of how you can improve performance by getting rid of the overlays associated with the classes <a href="http://jsperf.com/prototypal-performance/54">jsperf.com/prototypal-performance/54</a> . <br><br><h5>  Array Tips </h5><br>  Do not remove items.  If empty spaces are formed in the array, the V8 switches to the dictionary method of working with arrays, which makes the script even slower. <br><br><h6>  Array literals </h6><br>  Useful because  hint V8 about the types and number of elements in the array.  Suitable for small and medium sized arrays. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// V8 ,       4 : var a = [1, 2, 3, 4]; //   : a = []; // V8      -     for(var i = 1; i &lt;= 4; i++) { a.push(i); }</span></span></code> </pre><br><br><h6>  Single or mixed types </h6><br>  Do not mix different types in the same array (var arr = [1, ‚Äú1‚Äù, undefined, true, ‚Äútrue‚Äù]) <br><br>  <a href="http://jsperf.com/type-inference-performance/2">Testing performance of mixed types</a> <br><br>  From the test you can see that the array of integers works the fastest. <br><br><h6>  Sparse arrays </h6><br>  In such arrays, access to the elements is slower - V8 does not take up memory for all elements if only a few are used.  She works with him with the help of dictionaries, which saves memory, but affects speed. <br><br>  <a href="http://jsperf.com/sparse-arrays-vs-full-arrays">Sparse Array Testing</a> <br><br><h6>  Leaky Arrays </h6><br>  Avoid leaky arrays resulting from the removal of elements, or assigning a [x] = foo, where x&gt; a.length).  If you delete only one element, the work with the array slows down. <br><br>  <a href="http://jsperf.com/packed-vs-holey-arrays">Test of holey arrays</a> <br><br><h6>  Pre-filling arrays or filling on the fly </h6><br>  You should not pre-fill large arrays (more than 64K elements).  Nitro (Safari) works better with pre-filled arrays.  But other engines (V8, SpiderMonkey) work differently. <br><br><img src="//habrastorage.org/files/41a/823/824/41a823824a374c33bbb23c26ef759445.jpg"><br><br>  <a href="http://jsperf.com/pre-allocated-arrays">Prefilled Array Test</a> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var arr = []; for (var i = 0; i &lt; 1000000; i++) { arr[i] = i; } //   var arr = new Array(1000000); for (var i = 0; i &lt; 1000000; i++) { arr[i] = i; }</span></span></code> </pre><br><br><h4>  Application optimization </h4><br>  For web applications, speed is paramount.  Users do not like to wait, so it is critical to try to squeeze all possible speed from the script.  This is quite a difficult task, and here are our recommendations for its implementation: <br><br><img src="//habrastorage.org/files/d5c/2fa/1be/d5c2fa1bef584b7facd9113fa9eb28ae.jpg"><br><br>  - measure (find bottlenecks) <br>  - understand (find what the problem is) <br>  - forgive fix <br><br><h5>  Speed ‚Äã‚Äãtests (benchmarks) </h5><br>  The usual principle of measuring speed is to measure the execution time and compare.  One comparison model was proposed by the <a href="http://jsperf.com/">jsPerf</a> team and is used in <a href="http://www.webkit.org/perf/sunspider/sunspider.html">SunSpider</a> and <a href="http://krakenbenchmark.mozilla.org/">Kraken</a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalTime, start = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, iterations = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (iterations--) { <span class="hljs-comment"><span class="hljs-comment">//     } // totalTime ‚Üí  , //     1000  totalTime = new Date - start;</span></span></code> </pre><br><br>  The code is placed in a loop and executed several times, then the start time is subtracted from the end time. <br><br>  But this is too simple an approach - especially for testing work in different browsers or environments.  Even garbage collection can affect performance.  This should be remembered even when using window.performance <br><br>  For serious immersion in code testing, I recommend reading JavaScript Benchmarking. <br><br><h5>  Profiling </h5><br>  Chrome Developer Tools support profiling.  You can use it to find out which functions are being uploaded most of the time, and optimize them. <br><br><img src="//habrastorage.org/files/0ea/38b/d4d/0ea38bd4d4aa410793d5e3df74293bdb.jpg"><br><br>  Profiling begins with determining the point of reference for the speed of your code ‚Äî the Timeline is used for this.  It indicates how long our code was executed.  The ‚ÄúProfiles‚Äù tab shows in more detail what is happening in the application.  The JavaScript CPU profile shows how much CPU time the code took, the CSS selector took how much time it took to process selectors, and Heap snapshots shows the memory usage. <br><br>  Using these tools, you can isolate, tweak and repurpose code by measuring how program performance changes. <br><br><img src="//habrastorage.org/files/7e3/424/157/7e3424157ac046a297ec7fc918345234.jpg"><br><br>  Good profiling instructions are here: <a href="http://www.smashingmagazine.com/2012/06/12/javascript-profiling-chrome-developer-tools/">JavaScript Profiling With The Chrome Developer Tools</a> . <br><br>  Ideally, the installed extensions and programs should not affect profiling, so run Chrome with the - user-data-dir &lt;empty_directory&gt; option. <br><br><h5>  Avoid memory leaks - a technique of three snapshots of memory </h5><br>  Google Chrome Developer Tools are actively used in projects like Gmail to detect and fix leaks. <br><br><img src="//habrastorage.org/files/ed7/680/b5d/ed7680b5d9c5433785abe1d63fd919d2.jpg"><br><br>  Some of the parameters that our teams pay attention to are private memory usage, JS heap size, number of DOM nodes, storage cleanup, event handler counter, garbage collection.  Familiar with event-based architectures will be interested in the fact that we encountered the most frequent problems when listen () does not have unlisten () (closure) and when there is no dispose () for objects that create event handlers. <br><br>  There is a wonderful presentation of the ‚Äú <a href="https://docs.google.com/presentation/d/1wUVmf78gG-ra5aOxvTfYdiLkdGaR9OhXRnOlIcEmu2s/pub%3Fstart%3Dfalse%26loop%3Dfalse%26delayms%3D3000">3 pictures</a> ‚Äù technique, which helps to find leaks through DevTools. <br><br>  The idea is that you record several actions in your application, start garbage collection, check if the number of DOM nodes returns to the expected value, and then analyze three heap snapshots to determine if there are leaks. <br><br><h5>  Memory management in one-page applications </h5><br>  In modern single-page applications, it is important to manage memory (AngularJS, Backbone, Ember frameworks) because they do not reboot.  Therefore, memory leaks can quickly manifest themselves.  This is a big trap for such applications, because memory is limited, and applications run for a long time (email clients, social networks).  Big power is big responsibility. <br><br>  In Backbone, make sure you get rid of the old views and references through dispose ().  This function has been added recently, it removes all handlers added to the events object, and all handler collections when the view is passed as the third argument (in callbacks).  dispose () is also called in the view remove () function, which solves most simple memory cleanup problems.  In Ember, clear browsers when they discover that an item has been removed from view. <br><br>  Advice from Derik Bailey :: <br><br><blockquote>  Understand how, from the point of view of links, events work, and otherwise follow the standard rules for working with memory, and everything will be OK.  If you upload data to the Backbone collection, in which there are many User objects, this collection must be cleaned up so that it does not use more memory, you need to remove all references to it and all objects separately.  When you delete all the links, everything will be cleared. </blockquote><br><br>  In <a href="http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/">this article,</a> Derrick describes a lot of memory errors when working with Backbone.js, and also offers solutions to these problems. <br><br>  Another good <a href="https://github.com/felixge/node-memory-leak-tutorial">debugging tutorial on Node</a> . <br><br><h5>  Minimize the recalculation of the positions and sizes of elements when updating the page appearance </h5><br>  Such recalculations block the page for the user, so you need to figure out how to reduce the recalculation time.  Methods that cause recalculation should be collected in one place and rarely used.  You need to do as little as possible directly with the DOM.    DocumentFragment ‚Äì     .      DOM,        ,       DOM. <br><br><img src="//habrastorage.org/files/6ad/e6d/4fb/6ade6d4fbfdd4b30803c4687bcca73d1.jpg"><br><br>  ,  20 div  .    div  20  . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDivs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; i ++) { div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'div'</span></span>); div.innerHTML = <span class="hljs-string"><span class="hljs-string">'Heya!'</span></span>; element.appendChild(div); } }</code> </pre><br><br>     DocumentFragment,  div  ,      DOM  appendChild.           . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDivs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div; <span class="hljs-comment"><span class="hljs-comment">// Creates a new empty DocumentFragment. var fragment = document.createDocumentFragment(); for (var i = 0; i &lt; 20; i ++) { div = document.createElement('a'); div.innerHTML = 'Heya!'; fragment.appendChild(div); } element.appendChild(fragment); }</span></span></code> </pre><br><br>  ‚Äì   <a href="https://developers.google.com/speed/articles/javascript-dom">Make the Web Faster</a> , <a href="http://blog.tojicode.com/2012/03/javascript-memory-optimization-and.html">JavaScript Memory Optimization</a>  <a href="http://gent.ilcore.com/2011/08/finding-memory-leaks.html">Finding Memory Leaks</a> . <br><br><h5>    JavaScript </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To help with leak detection, a utility for Chrome Developer Tools was developed, working through a remote work protocol that takes heaps of images and finds out which objects are causing the leak. </font></font><br><br><img src="//habrastorage.org/files/d30/246/e7a/d30246e7a9654dc89daf011b1db9643d.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I recommend to read the </font></font><a href="http://google-opensource.blogspot.de/2012/08/leak-finder-new-tool-for-javascript.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">post</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on this topic or read </font></font><a href="http://code.google.com/p/leak-finder-for-javascript/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the project page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V8 flags to optimize debugging and garbage collection </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimization tracking: </font></font><br><br><pre> <code class="bash hljs">chrome.exe --js-flags=<span class="hljs-string"><span class="hljs-string">"--trace-opt --trace-deopt"</span></span></code> </pre><br><br>  More details: <br><br> trace-opt ‚Äì        ,      <br> trace-deopt ‚Äì  ,      <br> trace-gc ‚Äì      <br><br>     (*),    ‚Äì  (~). <br><br>        V8   <a href="http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html">  </a> . <br><br><h5>     Navigation Timing API </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High resolution time ( </font></font><a href="http://www.w3.org/TR/hr-time/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High Resolution Time The</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the HRT) - JS is an interface to access a timer with a resolution of less than a millisecond, which is independent of the user's time shifts. Useful for writing performance tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Available in Chrome (stable) as window.performance.webkitNow (), and in Chrome Canary without the prefix -window.performance.now (). Paul Irish wrote about this in detail in his </font></font><a href="http://updates.html5rocks.com/2012/08/When-milliseconds-are-not-enough-performance-now"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">post on HTML5Rocks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we need to measure the work of the application on the web, the </font></font><a href="http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/NavigationTiming/Overview.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation Timing API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will help us </font><font style="vertical-align: inherit;">. With it, you can get accurate and detailed measurements performed when loading the page. Available through window.performance.timing, which can be used directly in the console:</font></font><br><br><img src="//habrastorage.org/files/224/92d/428/22492d42869e4f1681cb22096803ed86.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From this data you can learn a lot of useful information. </font><font style="vertical-align: inherit;">For example, the network delay responseEnd-fetchStart; </font><font style="vertical-align: inherit;">the time it took to load the page after receiving from the server loadEventEnd-responseEnd; </font><font style="vertical-align: inherit;">the time between loading the page and starting the loadEventEnd-navigationStart navigation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For details, see </font></font><a href="http://www.html5rocks.com/en/tutorials/webperformance/basics/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Measuring Page Load with Speed ‚Äã‚ÄãNavigation Timing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about: memory and about: tracing </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about: tracing in Chrome shows intimate details about the speed of the browser, recording all its activities in each of the threads, bookmarks and processes. </font></font><br><br><img src="//habrastorage.org/files/017/cbe/ad6/017cbead65fc4fe0a1d31b786e6a9c4e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can see all the details needed for profiling the script and correct the JS extension to optimize downloads. </font></font><br><br> <a href="http://www.html5rocks.com/en/tutorials/games/abouttracing/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about using about: tracing for profiling WebGL games. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about: memory in Chrome is also a useful thing that shows how much memory each tab uses - this can be used to search for leaks.</font></font><br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the amazing and mysterious world of JS engines there are a lot of pitfalls associated with speed. There is no universal recipe for improving performance. By combining various optimization techniques and testing applications in a real environment, you can see how to optimize your application. Understanding how engines process and optimize your code can help you tweak applications. Measure, understand, correct and repeat. </font></font><br><br><img src="//habrastorage.org/files/e93/715/1a4/e937151a48284df1af145940650cf251.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget about optimization, but do not micro-optimize at the expense of convenience. Think about what optimization is important for the application, and without what it can do.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keep in mind that as the JS engines get faster, the next bottleneck is the DOM. </font><font style="vertical-align: inherit;">Recalculation and redrawing should also be minimized - touch the DOM only if absolutely necessary. </font><font style="vertical-align: inherit;">Do not forget about the network. </font><font style="vertical-align: inherit;">HTTP requests also need to be minimized and cached, especially for mobile applications.</font></font></div><p>Source: <a href="https://habr.com/ru/post/248111/">https://habr.com/ru/post/248111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248097/index.html">Ethernet over USB to STM32F4</a></li>
<li><a href="../248099/index.html">Pointer Checker: check our pointers</a></li>
<li><a href="../248101/index.html">Simple bot for Skype on C ++ Qt (ActiveX)</a></li>
<li><a href="../248103/index.html">How to make QML friends with someone else's OpenGL context. Part II: Loading QML</a></li>
<li><a href="../248105/index.html">Internet test drive "Mechatronics and Robotics". Need help from the Community</a></li>
<li><a href="../248113/index.html">Krita: Green coordinates or how to make a kangaroo from a dragon</a></li>
<li><a href="../248115/index.html">The sound on the chip AY-3-8910 (or Yamaha YM2149F) comes from the ZX Spectrum on the PC via USB</a></li>
<li><a href="../248117/index.html">evalidate: secure processing of custom expressions</a></li>
<li><a href="../248119/index.html">3D to D</a></li>
<li><a href="../248121/index.html">Apple has blocked developer accounts in Crimea</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>