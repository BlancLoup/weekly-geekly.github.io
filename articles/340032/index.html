<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of one Russian RTOS, part 8. Work with interruptions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am publishing the latest article from the first volume of the ‚ÄúBook of Knowledge‚Äù of the MAKS RTOS. I hope this informal guide will help you, collea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of one Russian RTOS, part 8. Work with interruptions</h1><div class="post__text post__text-html js-mediator-article">  I am publishing the latest article from the first volume of the ‚ÄúBook of Knowledge‚Äù of the MAKS RTOS.  I hope this informal guide will help you, colleagues, in case you have to work with this RTOS. <br><br>  Previous articles: <br>  <a href="https://habrahabr.ru/post/336308/">Part 1. General information</a> <br>  <a href="https://habrahabr.ru/post/336696/">Part 2. Core MAX MAX</a> <br>  <a href="https://habrahabr.ru/post/336944/">Part 3. The structure of the simplest program</a> <br>  <a href="https://habrahabr.ru/post/337476/">Part 4. Useful theory</a> <br>  <a href="https://habrahabr.ru/post/337974/">Part 5. The first application</a> <br>  <a href="https://habrahabr.ru/post/338682/">Part 6. Thread synchronization tools</a> <br>  <a href="https://habrahabr.ru/post/339498/">Part 7. Means of data exchange between tasks</a> <br>  Part 8. Work with interruptions (this article) <br><br><h2>  Why interruptions are vital </h2><br>  Computer science teachers love to talk about the fact that there is work on the survey, as well as on interruption, after which they usually give a small example of interrupt handling and forget about the topic.  Further, with real programming, you have to comprehend the basics of this business not with your own skin. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When programming in single-tasking systems, it is often possible to "get out" by working with equipment according to the survey.  In multitasking systems, it becomes more difficult. <br><br>  Consider the simplest example.  Let there be a reception from a serial port with a terribly low speed of 9600 AML.  Real speeds have long been in the region of 250 KBDO, but in order to avoid the desire to simply slow down to solve a problem, let's consider the very slow option. <a name="habracut"></a><br><br>  In the serial port, one byte is at my favorite port setting of 10 bits (8 data bits, as well as start and stop).  Total, comes 960 bytes per second.  Round up to 1000. This is 1 byte per millisecond.  Place events on the time axis. <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f791be12219024192.png"><br><br>  If the typical controller does not have time to process the next byte before the next one arrives, it will be overwritten by the new value coming from the line.  Consider the essence of this on the diagram from the description of the controller STM32. <br><br><img src="https://habrastorage.org/webt/59/e4/8f/59e48f680e559470010932.png"><br><br>  By default, tasks are switched 1 time in 1 millisecond.  We will place on the time axis a case of sequential switching of five tasks. <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f795a251532407401.png"><br><br>  Let the COM port be queried in task 1. Let's combine two pictures ... <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f79601e2648925131.png"><br><br>  As you can see, 4 bytes from the serial port will come when the task waiting for them is inactive.  There are controllers with a large hardware queue.  For example, ESP8266 can accept 128 bytes in a hardware buffer.  Such controllers consider the situation at all - task 1 will receive the data accumulated by the equipment.  But, for example, all STM32 input buffer can take no more than one byte.  And for them, working with a serial port in a multitasking environment, according to the death survey, is similar even at such ‚Äúfunny‚Äù speeds as 9600 bits per second. <br><br>  The correct decision will be to add the bytes to the buffer memory so that the processing task takes everything that has been accumulated in bulk.  As an option, perform some kind of preprocessing (for example, initial analysis of packets, if this is possible without any special delays) and transfer the already preprocessed parameters to the processing task. <br><br>  Of course, the example of a serial port was chosen as the one closest to most readers.  In fact, there are many more cases where polling is poorly acceptable even in a single-task environment and impossible in a multi-tasking environment.  The first thing that comes to mind is maintaining engine speed.  The real case is that the engine rotates at a speed of up to 5 thousand revolutions per minute, from it comes two feedback pulses per revolution. <br><br>  One of the typical algorithms for measuring the rotational speed, requires measuring the period of the following pulses using a timer.  That is, you need to take a timer reading at the time of arrival, and then restart the timer for a new measurement.  If from the moment of arrival of the pulse to the moment of taking the readings random time passes, the measurement accuracy will drop significantly.  Most often - not just significantly, but unacceptably fall. <br><br>  Let us estimate our situation - 10,000 feedback pulses per minute.  Divide by 60 - we get 167 Hz.  1 pulse in 5 milliseconds, which should be processed as close as possible to the moment of its occurrence, in order not to lose measurement accuracy.  The arrival time of the impulse cannot be predicted - the engine rotates the way it likes.  With five tasks, the time of possible waiting for the transfer of control to the tracking task is more than half of the pulse repetition period.  For example, this is the situation: <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f7978b4a472943020.png"><br><br>  How much time has passed from the arrival of the impulse to the activation of the task producing the survey is unknown.  As you can see, here too, the implementation of any reasonable data processing is possible only by interrupts.  The impulse came, the time of his arrival was remembered, and the processing task can already use this time anytime. <br><br>  From the foregoing it follows that <br><br><blockquote>  Interrupts in a multitasking environment are not only powerful, but often the only possible mechanism for working with hardware. </blockquote><br><h2>  Main interrupt handling mechanism in RTOS MAX </h2><br>  When working with the MAKS RTOS, interruptions are allowed to be processed in two ways - ‚Äúconvenient‚Äù and ‚Äúfast‚Äù.  Consider first the one that is considered the main option ("convenient"). <br><br>  As part of the OS, a standard task is developed, but it should be inherited not from <b>Task</b> , but from <b>TaskIrq</b> .  This task is given a high priority, as it will have to force out all other tasks as soon as an interrupt occurs.  The TaskIrq class contains the virtual function IrqHandler (), which should be blocked by placing all actions related to interrupt processing there. <br><br>  During initialization, the interrupt should be resolved through the programming of the interrupt controller (I myself get scared how many times the word "interrupt" was said in the last two paragraphs, but alas, without this in any way).  When setting the planning task, since it is inherited from a particular class, the number of the interrupt request that it processes should be specified as a parameter. <br><br>  Ideologically, the challenge for this task can be represented as follows: <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f7981430823904242.png"><br><br>  That is why its priority must be high - it is no different from other tasks, therefore, it must oust them, and this is done with the help of priority.  Now consider a practical example.  Here is a typical task - the handler of the radio module connected to the serial port.  As you can see, it is actually inherited from TaskIrq, and the IrqHandler () function is really overridden in it. <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f79935f5044573857.png"><br><br><div class="spoiler">  <b class="spoiler_title">Text</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortRadioTask</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TaskIrq { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PortRadioTask() : TaskIrq(<span class="hljs-string"><span class="hljs-string">"Radio"</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IrqHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br></div></div><br>  This is how this task is added: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Radio_IrqNumber = EXTI15_10_IRQn; ... result = TaskIrq::Add(radio_task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortRadioTask, Radio_IrqNumber, Task::PriorityRealtime);</code> </pre> <br>  NVIC configuration for the radio module example will be moved out of this section.  In my opinion, in this example, it is not very illustrative.  Purely for illustration, let us show how NVIC is configured for a specific processor in another example (the option with a priority change was specifically chosen, although you can not change the priority). <br><br><pre> <code class="cpp hljs"> NVIC_EnableIRQ(EXTI9_5_IRQn); NVIC_SetPriority(EXTI9_5_IRQn,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  So.  The task is described, its TaskIrq function is overlapped, the task is added to the scheduler, what next?  And then - the care of the OS.  When an interrupt occurs, the internal interrupt handler will call the scheduler itself.  That - activates the task.  <font color="red">Here it is important that the task has a high priority</font> , so that it is guaranteed to supplant other tasks.  Well, after some time (required to switch tasks), the function IrqHandler () will get control.  What should be placed in the body of this function are the problems of the application programmer (in the next part of the document, typical solutions will be described for cases of work through low-level drivers). <br><br>  Standard solutions: <br><br><ul><li>  you can accept data, preprocess it, put in a message queue for a task with normal priority, </li><li>  or you can coax the semaphore for a task with normal priority </li></ul><br>  A simple example of an interrupt handler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Semaphore </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_sema_radio_irq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//       void PortRadioTask::IrqHandler() { s_sema_radio_irq.Signal(); }</span></span></code> </pre> <br><h2>  Possible problems when using the main mechanism </h2><br>  All possible problems from using the main interrupt handling mechanism are related to one: in order to wake up the task handler, the task context must be switched.  It takes time.  During practical work in a system with two tasks, we saw on the oscillogram that the switching took place in 4.7 microseconds.  In general, the time depends on the build options, on the number of tasks, on other conditions.  Let's take as a basis for further estimations a rather real and rather round value of 10 microseconds. <br><br>  Let's look at a few typical scenarios of the equipment serviced by the microcontroller.  Let's start with the simple.  A CNC machine receiving G-CODE commands via a serial port at a speed of 250 kilobits.  As already mentioned, the serial port bytes is 10 bits (8 data bits, plus the start and stop bits).  Total, the frequency of arrival of bytes is 25 kHz.  One byte in 40 microseconds.  And the context switch takes 10 microseconds. <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f799e8d8541535363.png"><br><br>  A quarter of the microcontroller's working time (a powerful 32-bit microcontroller) will only go to the context switch, since the G-Code lines go one after another, quite a dense stream.  Is it acceptable?  More likely no than yes. <br><br>  Further, work with a stepper motor, which requires 200 steps per millimeter on a 3D printer that prints at a speed of 150 mm / s, requires work at a frequency of 30 KHz.  This is even more than a quarter. <br><br>  G-Code is adopted by the same controller that controls the stepper motors.  In total, more than half of the CPU time is required for entering an interrupt. <br><br>  Of course, this option is <font color="red">unacceptable</font> . <br><br>  But in other way.  Take the same serial port, at the same speed, but connect to it the radio module from which 32-byte packets come 4 times per second.  Thus, the load on the processor will increase in areas of 1200 microseconds long, and in a second such peak load periods will occur within 4800 microseconds.  This is 4.8% of the time.  Acceptable?  More often than not.  That is, we consider that this option is <font color="green">acceptable</font> for processing in the standard way. <br><br>  In the same way, it is possible to estimate that the already mentioned mechanism for determining the rotational speed of an engine from feedback signals will be unacceptable - the timer readings should be taken as close as possible to the moment of arrival of the signal.  And the reading from the humidity sensor is quite acceptable.  At the same time, data processing from the serial port at a speed of 921 kilobits per second will take 100% of the time to switch tasks, therefore it is unacceptable ... Well, and so on.  The game "acceptable-unacceptable" can be played for a long time.  Let's formulate the general principles. <br><br>  If interrupts come rarely - the option is acceptable. <br><br>  If interrupts come so often that a context switch takes 100 or more percent of the time, the option is unacceptable. <br><br>  If a high percentage of time goes to the context switch, but this will happen quite rarely and in short enough packets - the option is acceptable. <br><br>  If switching with high frequency will be permanent - the option is unacceptable. <br><br>  What kind of replacement can I offer?  Of course, direct interrupt handling. <br><br><h2>  Why you should not abandon the main mechanism </h2><br>  You may ask: ‚ÄúWhy not offer direct interrupt handling in all cases?‚Äù.  I asked the exact same question for the developers of the MAX RTOS.  Alas, their answer was categorical: there are reasons why standard processing is still more convenient. <br><br>  Let's start with the simple.  Interrupt Handler Names  Even within the ARM families, they are different.  Here are the most striking differences between the STM32 and Milandr families. <br><table><tbody><tr><td>  <b>STM32</b> </td><td>  <b>"Milander"</b> </td></tr><tr><td>  USART1_IRQHandler </td><td>  UART1_IRQHandler </td></tr><tr><td>  TIM1_UP_TIM10_IRQHandler </td><td>  Timer1_IRQHandler </td></tr><tr><td>  TIM2_IRQHandler </td><td>  Timer2_IRQHandler </td></tr></tbody></table><br>  When migrating, they will need to be rewritten.  Under the basic mechanism, the names of the handlers are the concern of the OS.  They are hidden from the application programmer (it‚Äôs a pity that the names of the vectors are still not hidden, but you can‚Äôt do without it). <br><br>  Further, when using the standard handler, the usual task is called.  A real interrupt handler is hidden from the eyes of the application programmer.  It merely awakens the task handler and tells the scheduler to switch context.  Everything else is a common task.  But with interruptions - everything is different there.  If you look at the description of any OS (at least in real time, even though Windows), then it will be seen that many mechanisms do not work in the interrupt handler.  A quick look at the mechanisms of the MAKS RTOS. <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f79afd3c704118665.png"><br><br>  Let's see why a couple of records, it would seem, could be yellow (after all, under certain conditions, the mechanism is available), but it is marked in red.  When implementing these mechanisms, it is required to exclude the possibility of re-entering the function.  To do this, it contains a critical section, which, as we remember, blocks all interrupts whose priority is lower than MAX_SYSCALL_INTERRUPT_PRIORITY.  Actually, that says it all.  Interruptions are temporarily prohibited.  That is, we do not benefit from direct interrupt handling.  On the other hand, we are losing all the facilities available in the main interrupt handling mechanism.  In general, in situations for which they abandon the main interrupt handling mechanism in favor of direct, semaphores cannot be set and message queues cannot be used.  Therefore, in the table they are marked in red. <br><br><blockquote>  So, if you have the opportunity to use all the features of the OS, then it is better and easier to use them, and go to the direct processing of interrupts only if there is an urgent need. <br></blockquote><br><h2>  Direct Interrupt Handling </h2><br>  With direct interrupt processing, the reaction rate is determined only by the capabilities of the microcontroller.  The list of interrupt handlers is conveniently taken from the startupXXXX.s file found in each project.  In the demo application PinListAndTimerDemo, interrupt from timer 2 is processed, let's see how to quickly find the name of its handler. <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f79d02e0234335021.png">  0 <br><br>  Knowing the name of the handler, it is very easy to make it using the following rules: <br><br><ul><li>  If it is located in the cpp file (C ++ code), you should definitely add the <b>extern ‚ÄúC‚Äù</b> prefix.  Without this, the function name will be formed according to the rules of C ++ and the system will not understand that we are replacing the interrupt handler. </li><li>  The return type is void. </li><li>  Arguments are not. </li></ul><br>  Thus, in the already mentioned example, the interrupt handler from timer 2 in the start code is named like this: <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f79cc865107488302.png"><br><br>  And the processing function, respectively, <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIM2_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ...</code> </pre> <br>  It is important to remember that the handler of such an interrupt should be executed as quickly as possible.  While the program is in the handler, all other tasks are not working, and interrupts with lower priority are blocked. <br><br>  The interrupt handler must quickly accept the data, put it in for further processing and immediately stop its work.  No complicated calculations, no other extra work in the interrupt handler should be located. <br><br>  A convenient mechanism for associating interrupts with the main tasks is a ring buffer.  An interrupt places received data into it as it arrives, and a task removes and uses it without worrying about processing speed. <br><br><h2>  Mcucpp ring buffer </h2><br>  The mcucpp library of Konstantin Chizhov, used as an auxiliary, already contains an implementation of ring buffers.  A lot of the library itself will be discussed in the next part of the document, but for now let's consider the ring_buffer.h file. <br><br>  The RingBuffer class uses the new operator to add each element in its work, so it cannot be used in real-time applications (and, moreover, in interrupts).  But the same header file contains the class RingBufferPO2 - a ring buffer whose size is a multiple of a power of two.  This class not only works with a pre-provisioned buffer, but is still so thread-safe for the ‚Äúone writer, one reader‚Äù scheme, as far as the microcontroller command system allows (dangerous counters are recorded through the atomic access class, and security is determined by that class). <br><br>  The class is defined as follows: <br><br>  <b>template &lt;size_t SIZE, class T, class Atomic = VoidAtomic&gt;</b> <b><br></b>  <b>class RingBufferPO2</b> <br><br>  <b>SIZE</b> - the number of elements.  Must be a multiple of the power of two, otherwise, the compiler will generate an error. <br><br>  <b>T</b> is the type of stored data.  Both scalars and structures are allowed. <br><br>  <b>Atomic</b> - a class to ensure atomicity of operations (if not specified, atomicity is not provided). <br><br><blockquote>  The buffer for storing data is a member variable of the class.  Therefore, the class object should be placed in the pool in which there is enough free space (stack, heap, global memory, a specially defined memory pool, etc.) </blockquote><br>  Example declaration for the byte buffer received from the COM port (64 characters): <br><br><pre> <code class="cpp hljs">Mcucpp::Containers::RingBufferPO2&lt;<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>, Mcucpp::Atomic&gt; bufFromUart;     ,   &lt;b&gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push_back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; value)</span></span></span><span class="hljs-function">&lt;/b&gt;</span></span></code> </pre> <br>  if the result is false, then the data was not placed because the buffer is full. <br><br>  Usually, a function is used to retrieve data, which simultaneously pushes them out of the queue.  For the case of scalar values, this is justified, but for the case of structures ‚Äî an extra copy operation is performed ‚Äî the data is copied to the new location, since they will be deleted from the old one.  Most likely, to prevent copying, the author of the mcucpp library went a little different way.  Data from the queue is not pushed, but read (it turns out a link to them).  To delete data, use a separate function. <br><br>  The main function of reading data can be called the following: <br><br>  <b>const T &amp; front () const</b> <br>  <b>T &amp; back ()</b> <br><br>  As you can see, it returns a link to the data, that is, <b>does not perform copying.</b> <br><br>  You can get a link to the very last item in the queue: <br><br>  <b>const T &amp; back () const</b> <b><br></b>  <b>T &amp; front ()</b> <br><br>  You can even work with the queue by index: <br><br>  <b>const T &amp; operator [] (size_type i) const</b> <b><br></b>  <b>T &amp; operator [] (size_type i)</b> <br><br>  Well, and when the need is no longer in the element, <font color="red">it should be removed from the queue</font> using the function: <br><br>  <b>bool pop_front ()</b> <br><br>  If the queue is empty, the function will return false. <br><br>  There are also auxiliary functions to check the queue for overcrowding and emptiness: <br><br>  <b>bool full () const</b> <b><br></b>  <b>bool empty () const</b> <br><br>  You can find out how many specific items are currently in the queue: <br><br>  <b>size_type size () const</b> <br><br>  Finally, you can find out the capacity of the queue (although it is equal to the constant and is set at the program development stage, but for compatibility with dynamic buffers, these functions may be useful): <br><br>  <b>size_type max_size ()</b> <b><br></b>  <b>size_type capacity ()</b> <br><br>  Let's check how bad the approach of calling two functions instead of one is.  To get good reper, let's frame a code fragment with clearly defined calls (we cross out the corresponding lines). <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f79e9cf0932718135.png"><br><br><div class="spoiler">  <b class="spoiler_title">Text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> txtOuter.ShowSymbol(<span class="hljs-string"><span class="hljs-string">'A'</span></span>); txtOuter.ShowSymbol(bufFromUart.front()); bufFromUart.pop_front(); txtOuter.ShowSymbol(<span class="hljs-string"><span class="hljs-string">'B'</span></span>);</code> </pre> <br></div></div><br>  The corresponding assembly code looks like this: <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f79eeeeb264843541.png"><br><br><div class="spoiler">  <b class="spoiler_title">Text</b> <div class="spoiler_text"> <code>00025c 2141 MOVS r1,#0x41 ;288 <br> 00025e a801 ADD r0,sp,#4 ;288 <br> 000260 f7fffffe BL _ZN9TextOuter10ShowSymbolEwb ; TextOuter::ShowSymbol(wchar_t, bool) <br> 000264 484b LDR r0,|L4.916| <br> 000266 2201 MOVS r2,#1 ;290 <br> 000268 f8901044 LDRB r1,[r0,#0x44] ;290 <br> 00026c f001013f AND r1,r1,#0x3f ;290 <br> 000270 5c09 LDRB r1,[r1,r0] ;290 <br> 000272 a801 ADD r0,sp,#4 ;290 <br> 000274 f7fffffe BL _ZN9TextOuter10ShowSymbolEwb ; <br> 000278 f3bf8f4f DSB ;290 <br> 00027c 4845 LDR r0,|L4.916| <br> 00027e 6c02 LDR r2,[r0,#0x40] ;290 <br> 000280 6c41 LDR r1,[r0,#0x44] ;290 <br> 000282 428a CMP r2,r1 ;290 <br> 000284 d001 BEQ |L4.650| <br> 000286 1c49 ADDS r1,r1,#1 ;290 <br> 000288 6441 STR r1,[r0,#0x44] ;290 <br> |L4.650| <br> 00028a 2201 MOVS r2,#1 ;293 <br> 00028c 2142 MOVS r1,#0x42 ;293 <br> 00028e a801 ADD r0,sp,#4 ;293 <br> 000290 f7fffffe BL _ZN9TextOuter10ShowSymbolEwb ;</code> <br> </div></div><br>  As you can see, the optimizer did not make function calls, but placed everything linearly.  And the quality of the code is such that if there is one or two functions, there will be no difference.  Nor will there be copying if structures are used. <br><br><h2>  Ring Buffer Example </h2><br>  Actually, the example is simple.  Consider it on the example of buffering data coming from the COM port.  In the third part of the document we will try to consider working with the COM port and its interruptions in more detail.  We declare a buffer for 64 elements (I intuitively decided that such a buffer would not overflow if lines with an average length of 30 characters were processed). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ring_buffer.h&gt; #include &lt;atomic.h&gt; ... Mcucpp::Containers::RingBufferPO2&lt;64, uint8_t, Mcucpp::Atomic&gt; bufFromUart;</span></span></span></span></code> </pre> <br>  In the interrupt handler, put the data in the buffer: <br><br><pre> <code class="cpp hljs">bufFromUart.push_back (Buf[i]);</code> </pre><br>  And in one of the tasks, among other things, we perform some actions, for example, such: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!bufFromUart.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = bufFromUart.front(); bufFromUart.pop_front(); ...</code> </pre> <br>  without fear of data being overwritten (of course, the queue size should be sufficient so that it does not overflow).  Well, and we make certain actions with the received ch character.  If the queue is empty, entry into the specified loop simply will not occur. <br><br><h2>  Mixed interrupt handling </h2><br>  In order not to confuse you, let's start with a simple phrase: everything that is necessary to start working with interrupts has already been described.  Everything else is already aerobatics.  Probably the most correct thing is to first master the two extremes (slowly and conveniently, and also quickly and not very conveniently), and then return to reading this part of the section. <br><br>  There is a mixed way to handle interrupts.  First, the handler is rewritten, critical actions are performed at the beginning, and then the normal high-priority task is activated from it.  In particular, for the case of frequency measurement - in this handler, the actual timer value can be obtained at the moment of arrival of the interrupt from the leg, then the timer is started for the next measurement, after which the problem of processing the value obtained from the timer is delegated to the normal task.  Well, any other things.  If the instant response is important, and the fact that the context switch takes time is not critical, then you can use this method. <br><br>  So, we created a task spawned from TaskIrq, we created our own interrupt handler, in it we performed time-critical actions ... What next? <br><br>  And then you should call the function <b>MaksIrqHandler ()</b> .  This function initiates context switching and control transfer to the function associated with the interrupt. <br><br><img src="https://habrastorage.org/webt/59/e0/8f/59e08f7a1800b212641410.png"><br><br><div class="spoiler">  <b class="spoiler_title">Text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaksIrqHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EXTI15_10_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXTI_GetITStatus(EXTI_Line13) != RESET) { <span class="hljs-comment"><span class="hljs-comment">/* Clear interrupt flag - ,   ! */</span></span> EXTI_ClearITPendingBit(EXTI_Line13); <span class="hljs-comment"><span class="hljs-comment">//      MaksIrqHandler (); } } }</span></span></code> </pre><br></div></div><br><h2>  Virtual interrupts </h2><br>  And finally, consider a mechanism that does not relate directly to interrupts, but is associated with them.  This mechanism simply provides the programmer with additional, expressive information, without being mandatory. <br><br>  When creating a task, the heir from <b>TaskIRQ</b> can be assigned an actually non-existent interrupt number.  It must be greater than the <b>FIRST_VIRT_IRQ</b> value (for ARM, this value is 0x100, but for other architectures it may be different). <br><br>  Such a task is not associated with any real interruption and will never be automatically activated by the kernel.  But a programmer can always call a function: <br><br>  <b>void ProceedIrq (int irq_num);</b> <br><br>  after which the task will be activated according to all principles of the activation of the task associated with the interruption.  What for?  Variants are possible the most fantastic.  For example, you can call several different handler tasks from one physical interrupt handler, if several devices are ‚Äúhanging‚Äù on one vector (no matter how wide the range of IRQ lines is, and even on this, the controller developers manage to combine calls).  In general, as one of the OS developers explained: ‚ÄúThe mechanism went for nothing, why not use it?‚Äù.  The <b>ProceedIrq (</b> ) function is in any case necessary for the internal needs of the system. <br><br>  At this point, the consideration of the core can be considered rough.  Drivers are ahead, but about them - in the second volume of the manual. </div><p>Source: <a href="https://habr.com/ru/post/340032/">https://habr.com/ru/post/340032/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340022/index.html">DoubleLocker: the first encryptor using the accessibility service of the Android Accessibility Service</a></li>
<li><a href="../340024/index.html">Business wants boxed solutions for everything. Does anyone care about the law of Spring?</a></li>
<li><a href="../340026/index.html">Machine learning: where is the money?</a></li>
<li><a href="../340028/index.html">Configure two-way RSA and GOST authentication in the application on JBoss EAP 7</a></li>
<li><a href="../340030/index.html">DELL EMC Networking N1100 Switch Overview</a></li>
<li><a href="../340034/index.html">React, built-in functions and performance</a></li>
<li><a href="../340036/index.html">Using the advantages of TypeScript in JavaScript development</a></li>
<li><a href="../340038/index.html">10 tools for parsing information from websites, including competitors' prices + legal assessment for Russia</a></li>
<li><a href="../340040/index.html">‚ÄúInformation sciences can be taught only by young people‚Äù - Interview with A.A. Shalyto, a professor at ITMO University</a></li>
<li><a href="../340042/index.html">OSSIM + SEC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>