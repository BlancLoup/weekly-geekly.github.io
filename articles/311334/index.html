<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Manage dependencies in Swift iOS apps with peace of mind</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day to all. In our difficult time, constantly have to deal with stressful situations and writing code is no exception. Everyone copes with stress...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Manage dependencies in Swift iOS apps with peace of mind</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c6d/c89/5d0/c6dc895d02324b96bc679f41228ab6bf.png" align="right" width="240" alt="library icon">  Good day to all.  In our difficult time, constantly have to deal with stressful situations and writing code is no exception.  Everyone copes with stress in different ways: someone goes to the bar, someone meditates on the contrary in silence, but everyone wants this stress to be as little as possible, and tries to avoid obviously stressful situations. <br><br>  When I started writing in Swift, I had to face many problems, and one of them is the lack of competition in IoC containers in this language.  In fact, there are only two: Typhoon and Swinject.  Swinject has few features, and Typhoon is written for Obj-C, which is a problem, and working with him turned out to be a lot of stress for me. <br><br>  <s>And then Ostap suffered,</s> I decided to write my IoC container for Swift, what came out of it to read under the cut: <br><a name="habracut"></a><br>  So, get acquainted - <a href="https://github.com/ivlevAstef/DITranquillity">DITranquility</a> , IoC container for iOS on Swift, integrated with Storyboard. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      An interesting story about the name - after hundreds of different ideas, stopped at the "calm".  When I came up with the name, I was repelled by the fact that the main reason for writing the IoC container was <a href="http://typhoonframework.org/">Typhoon</a> .  Initially, there were thoughts to call the library a natural disaster stronger than a typhoon, but I understood that it was necessary to think differently: a typhoon is stress, and my library should provide the opposite, that is, calm. <br><br>  It was planned to check everything statically (unfortunately, it wasn‚Äôt completely possible), and not to fall in the middle of the application for unknown reasons <s>that when using a typhoon in large applications it doesn‚Äôt happen so rarely, and xcode sometimes doesn‚Äôt collect a project because of a typhoon, but falls during assembly</s> . <br><br>  Typhoon lovers may be a little upset, but, in my opinion, the naming of certain entities is different from the typhoon's view.  It is the same as <a href="https://autofac.org/">Autofac</a> , but taking into account the peculiarities of the language. <br><br><h1>  Special features </h1><br>  I will begin with a description of the features of the library: <br><br><ul><li>  The library works with pure Swift classes.  No need to inherit from NSObject and declare protocols as Obj-C, with the help of this library, you can write in pure Swift; </li><li>  Nativeness - the description of dependencies occurs in the native language, which allows for easy refactoring and ... </li><li>  Most of the compile checks are a bit like paradise after Typhoon, since many typos are revealed at compile time, not at runtime.  Unfortunately, they cannot boast that during execution, the library cannot fail, but be sure that some of the problems will be cut off; </li><li>  Support for all patterns of Dependency Injection: Initializer Injection, Property Injection, and Method Injection.  <s>I do not know why this is cool, but everyone writes about it</s> ; </li><li>  Support for cyclic dependencies - the library supports many different variants of cyclic dependencies, without the intervention of a programmer; </li><li>  Integration with Storyboard - allows you to embed dependencies directly in ViewControllers. </li></ul><br>  And: <br><br><ul><li>  Support for the lifetime of objects; </li><li>  Specifying alternative types; </li><li>  Resolving dependencies by type and name; </li><li>  Multiple registration; </li><li>  Resolving dependencies with initialization parameters; </li><li>  A short entry to resolve dependencies; </li><li>  Special mechanisms for "modularity"; </li><li>  CocoaPods support; </li><li>  Documentation in Russian (in fact, it is more correct to say the rough documentation, there are many errors). </li></ul><br>  And all this in 1500 lines of code, with about 400 lines of them, this is automatically generated code for typed dependency resolution with a different number of initialization parameters. <br><br><h1>  And what to do with all this? </h1><br><h2>  Briefly </h2><br>  I <s>will begin</s> with a small example of syntax: <s>may Autofac forgive me for writing an example adapted for my library</s> . <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Classes class TaskRepository: TaskRepositoryProtocol { ... } class LogManager: LoggerProtocol { ... } class TaskController { var logger: LoggerProtocol? = nil private let repository: TaskRepositoryProtocol init(repository:TaskRepository) { self.repository = repository } ... } // Register let builder = DIContainerBuilder() builder.register(TaskRepository.self) .asType(TaskRepositoryProtocol.self) .initializer { TaskRepository() } builder.register(LogManager.self) .asType(LoggerProtocol.self) .initializer { LogManager(Date()) } builder.register(TaskController.self) .initializer { (scope) in TaskController(repository: *!scope) } .dependency { (scope, taskController) in taskController.logger = try? scope.resolve() } let container = try! builder.build() // Resolve let taskController: TaskController = container.resolve()</span></span></code> </pre> <br><h2>  And now in order </h2><br><h3>  Basic integration into the project </h3><br>  Unlike Typhoon, the library does not support ‚Äúautomatic‚Äù initialization from plist, or similar ‚Äúfeatures‚Äù.  In principle, despite the fact that the typhoon supports such opportunities, I am not sure about their expediency. <br><br>  To integrate with a project that is planned more or less large, we need: <br><br><ol><li>  Integrate the library itself into the project.  This can be done using Cocoapods: <br><br><pre> <code class="bash hljs">pod <span class="hljs-string"><span class="hljs-string">'DITranquillity'</span></span></code> </pre><br></li><li>  Declare the base assembly using the library (optional): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppAssembly</span></span></span><span class="hljs-class">:</span></span> DIAssembly { <span class="hljs-comment"><span class="hljs-comment">//    var publicModules: [DIModule] = [ ] var intermalModules: [DIModule] = [ AppModule() ] var dependencies: [DIAssembly] = [ // YourAssembly2(), YourAssembly3() -     ] }</span></span></code> </pre> <br></li><li>  Declare the base module (optional): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class">:</span></span> DIModule { <span class="hljs-comment"><span class="hljs-comment">//    func load(builder: DIContainerBuilder) { //     //   } }</span></span></code> </pre><br></li><li>  Register the types in the module (see the first example above). <br><br></li><li>  Register the base assembly in the builder and collect the container: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity @UIApplicationMain <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppDelegate</span></span></span><span class="hljs-class">:</span></span> UIResponder, UIApplicationDelegate { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationDidFinishLaunching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ application: UIApplication)</span></span></span><span class="hljs-function"> </span></span>{ ... let builder = DIContainerBuilder() builder.<span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(assembly: AppAssembly()) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! builder.build() <span class="hljs-comment"><span class="hljs-comment">//   //      ,   ,    ,    } }</span></span></code> </pre></li></ol><br><h3>  Storyboard </h3><br>  The next step, after writing a pair of classes, is created by the Storyboard <s>, if it hasn‚Äôt been there before</s> .  We integrate it into our dependencies.  To do this, we will need to edit the base module a bit: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class">:</span></span> DIModule { <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: DIContainerBuilder)</span></span></span><span class="hljs-function"> </span></span>{ builder.<span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(UIStoryboard.self) .asName(<span class="hljs-string"><span class="hljs-string">"Main"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//            .instanceSingle() //         .initializer { scope in DIStoryboard(name: "Main", bundle: nil, container: scope) } //    } }</span></span></code> </pre><br>  And change the AppDelegate: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationDidFinishLaunching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ application: UIApplication)</span></span></span><span class="hljs-function"> </span></span>{ .... let container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! builder.build() <span class="hljs-comment"><span class="hljs-comment">//    window = UIWindow(frame: UIScreen.main.bounds) let storyboard: UIStoryboard = try! container.resolve(Name: "Main") //   Main storyboard window!.rootViewController = storyboard.instantiateInitialViewController() window!.makeKeyAndVisible() }</span></span></code> </pre><br><h3>  ViewControllers on Storyboard </h3><br>  And so we launched our code <s>, we were glad that nothing had fallen</s> and we were convinced that we had created our ViewController.  It's time to create some class and embed it in the ViewController. <br><br>  Create a Presenter: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourPresenter</span></span></span><span class="hljs-class"> {</span></span> ... }</code> </pre><br>  We will also need to give a name (type) to our ViewController, and add an injection through properties or a method, but in our code we will use an injection through properties: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourViewController</span></span></span><span class="hljs-class">:</span></span> UIViewController { var presenter: YourPresenter! ... }</code> </pre><br>  Also do not forget to indicate in the Storyboard that the ViewController is not just a UIViewController, but YourViewController. <br><br>  And now you need to register our types in our module: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: DIContainerBuilder)</span></span></span><span class="hljs-function"> </span></span>{ ... builder.<span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(YourPresenter.self) .instancePerScope() <span class="hljs-comment"><span class="hljs-comment">// ,    scope    Presenter .initializer { YourPresenter() } builder.register(YourViewController.self) .instancePerRequest() //     ViewController' .dependency { (scope, self) in self.presenter = try! scope.resolve() } //   }</span></span></code> </pre><br>  Run the program, and see that our ViewController has a Presenter. <br><br>  But, wait a minute, what is the strange time of an instancePerRequest, and where did the initializer go?  Unlike all other types of ViewControllers that are not placed on the Storyboard, we create the Storyboard, so we do not have an initializer and they do not support injection through the initialization method.  Since the presence of initializer is one of the check points when trying to create a container, we need to declare that this type is not created by us, but by someone else - for this we have the `instancePerRequest` modifier. <br><br><h3>  We add work with data </h3><br>  Further, the project must do something, and for frequent, mobile applications will receive information from the network, process it and display it.  For the sake of simplicity, we omit the data processing step and will not go into the details of receiving data from the network.  Just assume that we have the Server protocol, with the `get` method and, accordingly, there is an implementation of this protocol.  That is, the following code appears in our program: <br><br><pre> <code class="cpp hljs">protocol Server { <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method: String)</span></span></span><span class="hljs-function"> -&gt; Data? } class ServerImpl: Server </span></span>{ init(domain: String) { ... } <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method: String)</span></span></span><span class="hljs-function"> -&gt; Data? </span></span>{ ... } }</code> </pre><br>  Now we can write another module that would register our new class.  Of course, you can go ahead and create a new assembly, and transfer the work with the server to another project, but this will complicate the example, although it will show more aspects and possibilities of the library.  Or, conversely, embed already in the existing module. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerModule</span></span></span><span class="hljs-class">:</span></span> DIModule { <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: DIContainerBuilder)</span></span></span><span class="hljs-function"> </span></span>{ builder.<span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(ServerImpl.self) .asSelf() .asType(Server.self) .instanceSingle() .initializer { ServerImpl(domain: <span class="hljs-string"><span class="hljs-string">"https://your_site.com/"</span></span>) } } }</code> </pre><br>  We have registered the ServerImpl type, while in the program it will be known by two types: ServerImpl and Server.  This is some peculiarity of registration behavior - if an alternative type is specified, then the main type is not used, unless you explicitly indicate this.  We also indicated that the server in our program is one. <br><br>  We also slightly modify our build so that it knows about the new module: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppAssembly</span></span></span><span class="hljs-class">:</span></span> DIAssembly { var publicModules: [DIModule] = [ ServerModule() ] }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">The difference between publicModules and internalModules</b> <div class="spoiler_text">  There are two levels of module visibility: Internal and Public.  Public - means that this module will be visible, and in other assemblies that use this assembly, the Internal - module will be visible only inside our assembly.  However, it is necessary to clarify that since the assembly is just an announcement, this rule on the visibility of modules applies to the container, according to the principle: all modules from assemblies that were directly added to the builder will be included in the container they assembled, and the module from dependent assemblies be included in the container only if it is declared public. </div></div><br>  Now let's fix a little Presenter - let's add him information that he needs a server: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YourPresenter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> let server: <span class="hljs-function"><span class="hljs-function">Server </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(server: Server)</span></span></span><span class="hljs-function"> </span></span>{ self.server = server } }</code> </pre><br>  We implemented the dependency through the initialization method, but could do it, as in the ViewController, through properties, or a method. <br><br>  And we add the registration of our Presenter - we say that we will implement the Server in the Presenter: <br><br><pre> <code class="cpp hljs"> builder.<span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(YourPresenter.self) .instancePerScope() <span class="hljs-comment"><span class="hljs-comment">// ,    scope    Presenter .initializer { (scope) in YourPresenter(server: *!scope) }</span></span></code> </pre><br>  Here, to get dependencies, we used the ‚Äúfast‚Äù syntax `*!` Which is equivalent to the record: `try!  scope.resolve () ` <br><br>  We start our program and see that our Presenter has a Server.  Now you can use it. <br><br><h3>  Implement a logger </h3><br>  Our program works, but for some users it suddenly began to work incorrectly.  We cannot reproduce the problem in ourselves and solve it - all the time, we need a logger.  But since we have already awakened faith in the paranormal, the logger must write data to a file, to the console, to the server, and to the sea of ‚Äã‚Äãplaces, and all this should be easily turned on / off and used. <br><br>  And so, we create the basic protocol `Logger`, with the function` log (message: String) `and implement several implementations: ConsoleLogger, FileLogger, ServerLogger ... Create a basic logger that pulls everyone else, and we call it MainLogger.  Then we are in those classes in which we are going to log add a line on the similarity: `var log: Logger?  = nil`, and ... And now we need to register all the actions that we performed. <br><br>  First, create a new module `LoggerModule`: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DITranquillity <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoggerModule</span></span></span><span class="hljs-class">:</span></span> DIModule { <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: DIContainerBuilder)</span></span></span><span class="hljs-function"> </span></span>{ builder.<span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(ConsoleLogger.self) .asType(Logger.self) .instanceSingle() .initializer { ConsoleLogger() } builder.<span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(FileLogger.self) .asType(Logger.self) .instanceSingle() .initializer { FileLogger(file: <span class="hljs-string"><span class="hljs-string">"file.log"</span></span>) } builder.<span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(ServerLogger.self) .asType(Logger.self) .instanceSingle() .initializer { ServerLogger(server: <span class="hljs-string"><span class="hljs-string">"http://server.com/"</span></span>) } builder.<span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(MainLogger.self) .asType(Logger.self) .asDefault() .instanceSingle() .initializer { <span class="hljs-function"><span class="hljs-function">scope in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loggers: **!scope)</span></span></span><span class="hljs-function"> } } }</span></span></code> </pre><br>  And do not forget, add the introduction of our logger, to all classes where we declared it, for example, like this: <br><br><pre> <code class="cpp hljs">builder.<span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(YourPresenter.self) .instancePerScope() <span class="hljs-comment"><span class="hljs-comment">// ,    scope    Presenter .initializer { scope in try YourPresenter(server: *!scope) } .dependency { (scope, obj) in obj.log = *?scope }</span></span></code> </pre><br>  And after we add it to our assembly.  Now it is worth analyzing what we have just written. <br><br>  Initially, we registered 3 of our loggers, which will be accessible by the name of the Logger - that is, we performed multiple registrations.  Moreover, if we remove MainLogger, then the program will not have a single logger, since if we want to get one logger, the library will not be able to understand what kind of logger the programmer wants from it.  Next to MainLogger, we do two things: <br><br><ol><li>  We say that this is a standard logger.  That is, if we need a single logger, it will be MainLogger, and not some other. <br><br></li><li>  In the MainLogger, we transfer the list of all our loggers, except for ourselves (this is one of the library's capabilities, recursive calls are excluded in case of multiple dependency resolution. But if we do the same in the dependency block, then all loggers will be issued, including MainLogger). This uses the quick syntax `**!`, which is the equivalent of `try!  scope.resolveMany () ` </li></ol><br><h3>  Results </h3><br>  With the help of the library, we were able to build dependencies between several layers: Router, ViewController, Presenter, Data.  Such things were shown: dependency injection through properties, dependency injection through initializer, alternative types, modules, a little touched the lifetime and assemblies. <br><br>  Many opportunities were missed: cyclic dependencies, getting dependencies by name, lifetime, build.  You can see them in the <a href="">documentation.</a> <br><br>  This example is available at <a href="https://github.com/ivlevAstef/DITranquillity/tree/master/Swift/SampleHabr">this link</a> . <br><br><h1>  Plans </h1><br><ul><li>  Adding detailed logging, with the ability to specify external functions, in which logs come </li><li>  Support for other systems (MacOS, WatchOS) </li></ul><br><h1>  Alternatives </h1><br><ul><li>  <a href="http://typhoonframework.org/">Typhoon</a> - does not support pure swift types, and its syntax is bulky in my opinion </li><li>  <a href="https://github.com/Swinject/Swinject">Swinject</a> - the lack of alternative types, and multiple registration.  Less developed mechanisms for "modularity", but this is a good alternative. </li></ul><br><div class="spoiler">  <b class="spoiler_title">PS</b> <div class="spoiler_text">  At the moment, the project is in a prerelease state, and I would like to, before giving it version 1.0.0, know the opinions of other people, since after the ‚Äúofficial‚Äù release, it will become more difficult to change something drastically. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/311334/">https://habr.com/ru/post/311334/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311322/index.html">Sunset stack overflow</a></li>
<li><a href="../311324/index.html">How to stop worrying and conquer Windows Update?</a></li>
<li><a href="../311328/index.html">Artificial Intelligence in Excel predicts the gold medal winner in the men's tournament at Rio 2016</a></li>
<li><a href="../311330/index.html">We harness R for business service at "1-2-3"</a></li>
<li><a href="../311332/index.html">Moscow Droidcon 2016: a side view</a></li>
<li><a href="../311336/index.html">8 tips on lead generation from Khalisi</a></li>
<li><a href="../311338/index.html">Mobile trade on the example of Mobi-S</a></li>
<li><a href="../311340/index.html">Neuromarketing: how brain research helps brands sell</a></li>
<li><a href="../311342/index.html">SAP F & R: Order Creation Process. Part 2</a></li>
<li><a href="../311344/index.html">‚ÄúThe best performance is a story about a painful struggle and victory over evil‚Äù, - Vladimir Krasilshchik about technical reports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>