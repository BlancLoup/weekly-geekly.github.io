<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Loading a dynamic library from memory in Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In one of my cross-platform projects, I needed the ability to verify the digital signatures of plug-ins before downloading. None of the options for cr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Loading a dynamic library from memory in Linux</h1><div class="post__text post__text-html js-mediator-article">  In one of my cross-platform projects, I needed the ability to verify the digital signatures of plug-ins before downloading.  None of the options for creating a file is safe, since you can replace the file between the signature verification and its loading; you also cannot verify the signature after the download, because the static constructors have already been executed.  Therefore it is necessary to download the plugin without creating a file. <br><br>  It is impossible to intercept the open, mmap and other functions, since ld.so is linked to the library statically, the executable files loaded by its own loader are ‚Äúinferior‚Äù (even with the interception of functions in libdl): they are not registered in the list of loaded libraries and / or their characters are not visible through dlsym.  Consequently, there remains only the interception of system calls. <br><a name="habracut"></a><br>  Entry point to bootloader: <br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dlopen_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *base, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *(*custom_dlopen)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span></span>;</code> </pre> <br>  Options: <br><ul><li>  <b>base</b> - the base address where the image is loaded.  After completing this function is no longer needed and can be released. </li><li>  <b>size</b> - image size in bytes. </li><li>  <b>custom_dlopen</b> - custom wrapper over dlopen.  It can be used if you want to load a library from memory using some library function that calls a dlopen.  If not needed, pass NULL. </li><li>  <b>arg</b> is an optional parameter for custom_dlopen. </li></ul><br>  The return value is the same as the dlopen: library handle or NULL and the error description via dlerror (). <br><br>  It works as follows: <br><ol><li>  A pseudo-random library name is generated.  I needed exactly this, if you need readable - pass extra.  filename parameter. </li><li>  An empty SIGQUIT signal handler is installed, the old one is saved.  This signal is used later when the download is complete. </li><li>  A child process is created that will actually perform the download. </li><li>  Waiting to set the ready flag of the child process. </li><li>  Library is being loaded via dlopen or custom_dlopen. </li><li>  SIGQUIT is sent to its own process. </li><li>  Expecting completion of the child process. </li><li>  The SIGQUIT handler is restored. </li></ol><br>  The child process performs the following actions: <br><ol><li>  Starts tracing its parent.  This leads to some interesting consequences, for example, he becomes the parent of his parent. </li><li>  Sets the ready flag in the parent process. </li><li>  While the parent process is running and the stop has not been requested: <br><ol><li>  The parent process is executed prior to entering the system call.  If the system call is not the mmap of the pseudo file, then the process is also performed before the call is terminated. </li><li>  Retrieves child process registers. </li><li>  If this call is a SIGQUIT call to the parent process, then the trace is terminated. </li><li>  If this call is the opening of a library pseudo file, then the output descriptor is replaced with a special descriptor, which is used to identify pseudo file operations. </li><li>  If this call is a read from a pseudo file, then it reads from the library image into the buffer of the parent process and the call succeeds. </li><li>  If this call is the receipt of file attributes, then information about the pseudo-file is formed and placed in the buffer of the parent process (only the size makes sense in it). </li><li>  If this call is file closing, then the call succeeds. </li><li>  If this call is a pseudo file mapping to memory, then the following actions are performed: <br><ol><li>  The MAP_ANONYMOUS flag is set (a region of memory that is not mapped to the file is requested). </li><li>  Call mmap. </li><li>  The requested part of the pseudo file is copied to the created region in the parent process. </li></ol></li></ol></li><li>  The process is disconnected from the parent and completes its work. </li></ol><br>  This code is not portable and will work only on Linux and only on processors of the IA-32 architecture in 32-bit mode.  For systems of another architecture, it is necessary (by wrapping in # if / # end) to implement system call emulation, for systems with a different word length, it is also necessary to change the peekstring procedure.  If the call to ptrace or waitpid fails, then the work of the parent and child processes will be terminated.  If you need a different behavior - rewrite the handler for the label fail. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The code is available for free use without any restrictions. <br><pre> <code class="hljs mel">#include &lt;sys/mman.h&gt; #include &lt;sys/ptrace.h&gt; #include &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #include &lt;time.h&gt; #include &lt;stdio.h&gt; #include &lt;sched.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;sys/wait.h&gt; #include &lt;sys/user.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;dlfcn.h&gt; #include &lt;errno.h&gt; #include &lt;limits.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #define <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(a, b) ((a) &lt; (b) ? (a) : (b)) static void generate_name(char *name, size_t length) { assert(length &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>); strcpy(name + length - <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">".so"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; length - <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) name[i] = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>() % (<span class="hljs-string"><span class="hljs-string">'Z'</span></span> - <span class="hljs-string"><span class="hljs-string">'A'</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-string"><span class="hljs-string">'A'</span></span>; name[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'/'</span></span>; } static void quit_handler(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sig) { (void) sig; } static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> peekstring(pid_t pid, void *base, char *dest, size_t length) { unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> word; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { word = ptrace(PTRACE_PEEKDATA, pid, base + offset, NULL); memcpy(dest + offset, &amp;word, sizeof(unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); offset += sizeof(unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((word &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) &amp;&amp; (word &amp; <span class="hljs-number"><span class="hljs-number">0xFF00</span></span>) &amp;&amp; (word &amp; <span class="hljs-number"><span class="hljs-number">0xFF0000</span></span>) &amp;&amp; (word &amp; <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>) &amp;&amp; offset &lt; length); dest[length - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pokedata(pid_t pid, void *address, const void *data, size_t length) { length = (length + sizeof(unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; ~(sizeof(unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>); const unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *src = data; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; offset &lt; length; offset += sizeof(unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptrace(PTRACE_POKEDATA, pid, address + offset, (void *) *src++) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } void *dlopen_memory(void *base, size_t <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>, void *(*custom_dlopen)(const char *filename, void *arg), void *arg) { char fakename[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ready = <span class="hljs-number"><span class="hljs-number">0</span></span>; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; generate_name(fakename, sizeof(fakename)); struct sigaction old_handler, new_handler = { .sa_handler = quit_handler, .sa_flags = <span class="hljs-number"><span class="hljs-number">0</span></span>, .sa_restorer = NULL }; sigfillset(&amp;new_handler.sa_mask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigaction(SIGQUIT, &amp;new_handler, &amp;old_handler) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NULL; pid_t child = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(child == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { sigaction(SIGQUIT, &amp;old_handler, NULL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NULL; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(child == <span class="hljs-number"><span class="hljs-number">0</span></span>) { pid_t <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> = getppid(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptrace(PTRACE_ATTACH, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, NULL, NULL) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { kill(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, SIGKILL); _exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } ready = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptrace(PTRACE_POKEDATA, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, &amp;ready, (void *)ready) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; char path[PATH_MAX]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> handle = getdtablesize(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { struct user_regs_struct regs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptrace(PTRACE_SYSCALL, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, NULL, NULL) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(waitpid(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!WIFSTOPPED(status)) goto outer_break; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptrace(PTRACE_GETREGS, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, NULL, ¬Æs) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(regs.orig_eax == SYS_mmap2 &amp;&amp; regs.edi == handle) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(regs.orig_eax == SYS_kill &amp;&amp; regs.ebx == <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> &amp;&amp; regs.ecx == SIGQUIT) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(regs.orig_eax == SYS_open) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(peekstring(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, (void *) regs.ebx, path, PATH_MAX) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">strcmp</span></span>(path, fakename) != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; regs.eax = handle; offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(regs.orig_eax == SYS_read &amp;&amp; regs.ebx == handle) { unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>((unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) regs.edx, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> - offset); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pokedata(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, (void *) regs.ecx, base + offset, bytes) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; offset += bytes; regs.eax = bytes; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(regs.orig_eax == SYS_close &amp;&amp; regs.ebx == handle) { regs.eax = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(regs.orig_eax == SYS_fstat64 &amp;&amp; regs.ebx == handle) { struct stat statbuf = { .st_dev = <span class="hljs-number"><span class="hljs-number">0</span></span>, .st_ino = <span class="hljs-number"><span class="hljs-number">1</span></span>, .st_mode = <span class="hljs-number"><span class="hljs-number">0444</span></span>, .st_nlink = <span class="hljs-number"><span class="hljs-number">1</span></span>, .st_uid = <span class="hljs-number"><span class="hljs-number">0</span></span>, .st_gid = <span class="hljs-number"><span class="hljs-number">0</span></span>, .st_rdev = <span class="hljs-number"><span class="hljs-number">0</span></span>, .st_size = <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>, .st_blksize = <span class="hljs-number"><span class="hljs-number">512</span></span>, .st_blocks = (<span class="hljs-keyword"><span class="hljs-keyword">size</span></span> + <span class="hljs-number"><span class="hljs-number">511</span></span>) &amp; ~<span class="hljs-number"><span class="hljs-number">511</span></span>, .st_atim = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, .st_mtim = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, .st_ctim = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pokedata(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, (void *) regs.ecx, &amp;statbuf, sizeof(struct stat)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; regs.eax = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(regs.orig_eax == SYS_mmap2 &amp;&amp; regs.edi == handle) { regs.esi |= MAP_ANONYMOUS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptrace(PTRACE_SETREGS, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, NULL, ¬Æs) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptrace(PTRACE_SYSCALL, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, NULL, NULL) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(waitpid(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, &amp;status, <span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!WIFSTOPPED(status)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptrace(PTRACE_GETREGS, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, NULL, ¬Æs) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = regs.ebp * <span class="hljs-number"><span class="hljs-number">4096</span></span>; unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size</span></span> - offset, (unsigned <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) regs.ecx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pokedata(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, (void *) regs.eax, base + offset, bytes) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { regs.eax = -errno; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptrace(PTRACE_SETREGS, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, NULL, ¬Æs) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; } <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(regs.orig_eax == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptrace(PTRACE_SETREGS, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, NULL, ¬Æs) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) goto fail; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); outer_break: ptrace(PTRACE_DETACH, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, NULL, NULL); _exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); fail: ptrace(PTRACE_KILL, <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>, NULL, NULL); _exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ready == <span class="hljs-number"><span class="hljs-number">0</span></span>) sched_yield(); void *handle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(custom_dlopen) handle = custom_dlopen(fakename, arg); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> handle = dlopen(fakename, RTLD_NOW); kill(<span class="hljs-keyword"><span class="hljs-keyword">getpid</span></span>(), SIGQUIT); waitpid(child, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); sigaction(SIGQUIT, &amp;old_handler, NULL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handle; }</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/131725/">https://habr.com/ru/post/131725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../131714/index.html">Javascript inheritance for dummies</a></li>
<li><a href="../131715/index.html">MonoDevelop 2.8.2 released</a></li>
<li><a href="../131716/index.html">Waiting for user reaction to Dialog in Android</a></li>
<li><a href="../131720/index.html">Progress bar on CSS3</a></li>
<li><a href="../131724/index.html">Ainol Novo 8 Tablet Review</a></li>
<li><a href="../131727/index.html">Google service to check the display of sites on mobile devices</a></li>
<li><a href="../131729/index.html">Goodbye, <time></a></li>
<li><a href="../131730/index.html">Whiteboard DIY</a></li>
<li><a href="../131732/index.html">Google has updated the design of Gmail</a></li>
<li><a href="../131733/index.html">Recharge for The Humble Voxatron Debut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>