<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a first-level in-memory cache for StackExchange.Redis .NET clients</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jonathan Cardy has written the open source StackRedis.L1 .NET library that allows you to create a first-level cache for Redis. In other words, using t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a first-level in-memory cache for StackExchange.Redis .NET clients</h1><div class="post__text post__text-html js-mediator-article">  Jonathan Cardy has written the open source StackRedis.L1 .NET library that allows you to create a first-level cache for Redis.  In other words, using the StackExchange.Redis library in a .NET application, you can connect StackRedis.L1 to it to speed up work due to local caching of data in RAM.  This avoids unnecessary redis calls in cases where the data has not been altered.  The library is available on GitHub and NuGet. <br>  This article describes how and why it was created. <br><br><img src="https://habrastorage.org/files/67b/6b9/7ca/67b6b97cacd146f2805bcbeac8b54825.jpg"><br><a name="habracut"></a><br>  <b>Prehistory</b> <br><br>  For the past couple of years I have been working on the <a href="http://www.repstor.com/products-for-ecm-adoption/repstor-custodian">Repsor custodian</a> application <a href="http://www.repstor.com/products-for-ecm-adoption/repstor-custodian">managed by SharePoint.</a>  If you are familiar with SharePoint, you know that its model requires running applications on a separate server.  This makes it possible to increase the stability and simplify the architecture.  However, this model works to the detriment of performance, since you have to go to the SharePoint server for data every time, and network delays in this case do not play in your favor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For this reason, we decided to add Redis caching to the application using StackExchange.Redis as a .NET client.  For full caching of all application data models, we use sets, ordered sets, and hash tables. <br>  As expected, this greatly accelerated the work of the application.  Now the pages returned in about 500 ms instead of 2 s, as before.  But the analysis showed that even from these 500 ms a considerable part of the time was spent on sending or receiving data from Redis.  Moreover, the main part of the data received each time on request from the page has not been changed. <br><br>  <b>Cache cache</b> <br><br>  Redis is not only an incredibly fast caching tool, but also a set of tools for managing cached data.  This system is well developed and very widely supported.  StackExchange.Redis is free and open source, and its community is growing rapidly.  Stack Exchange aggressively caches all Redis data, even though it is one of the busiest sites on the Internet.  But the main advantage is that it performs in-memory caching of all available data on the Redis server and, thus, it usually does not even have to turn to Redis. <br><br>  The following quote explains to some extent how the caching mechanism works in the Stack Exchange: <br>  <a href="http://meta.stackexchange.com/questions/69164/does-stack-exchange-use-caching-and-if-so-how">http://meta.stackexchange.com/questions/69164/does-stack-exchange-use-caching-and-if-so-how</a> <br><br><blockquote>  ‚ÄúUndoubtedly, the most optimal amount of data that can be sent most quickly over the network is 0 bytes.‚Äù </blockquote><br><br>  When you cache data before it enters another cache, you create several cache levels.  If you perform in-memory caching of data before caching it in Redis, the in-memory <a href="https://en.wikipedia.org/wiki/CPU_cache">cache is assigned the first L1 level.</a> <br><br>  Therefore, if Redis is the slowest part of your application, you are on the right track and can definitely speed up this flaw further. <br><br>  <b>In-memory caching</b> <br><br>  In the simplest situation when using Redis, your code will look like this: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Try and retrieve from Redis RedisValue redisValue = _cacheDatabase.StringGet(key); if(redisValue.HasValue) { return redisValue; //It's in Redis - return it } else { string strValue = GetValueFromDataSource(); //Get the value from eg. SharePoint or Database etc _cacheDatabase.StringSet(key, strValue); //Add to Redis return strValue; }</span></span></code> </pre> <br><br>  And if you decide to use in-memory caching (i.e. L1 cache), the code will be a bit more complicated: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Try and retrieve from memory if (_memoryCache.ContainsKey(key)) { return key; } else { //It isn't in memory. Try and retrieve from Redis RedisValue redisValue = _cacheDatabase.StringGet(key); if (redisValue.HasValue) { //Add to memory cache _memoryCache.Add(key, redisValue); return redisValue; //It's in redis - return it } else { string strValue = GetValueFromDataSource(); //Get the value from eg. SharePoint or Database etc _cacheDatabase.StringSet(key, strValue); //Add to Redis _memoryCache.Add(key, strValue); //Add to memory return strValue; } }</span></span></code> </pre><br><br>  And although it is not so difficult to implement, everything becomes much more difficult, you should try to do the same steps for other data models in Redis.  In addition, the following problems will arise: <br><br>  ‚Ä¢ Redis allows us to manipulate data through functions like StringAppend.  In this case, we will have to declare the in-memory element invalid. <br>  ‚Ä¢ If you delete a key via KeyDelete, it must also be deleted from the in-memory cache. <br>  ‚Ä¢ If another client changes or deletes a value, it becomes obsolete in our client's in-memory cache. <br>  ‚Ä¢ When a key expires, it must be removed from the in-memory cache. <br><br>  Methods for accessing and updating data in the StackExchange.Redis library are defined in the IDatabase interface.  It turns out that we can rewrite the implementation of IDatabase to solve all the above problems.  Here's how to do it: <br><br>  ‚Ä¢ StringAppend - add data to the in-memory string, and then pass the same operation to Redis.  For more complex data operations, you will need to remove the in-memory key. <br>  ‚Ä¢ KeyDelete, KeyExpire, etc. ‚Äî deletes in-memory data. <br>  ‚Ä¢ Operations through another client - keyspace notifications in Redis are designed to detect changes to the data and declare them invalid accordingly. <br>  The beauty of this approach is that you continue to use the same interface as before.  It turns out that the introduction of L1-cache does not require any changes in the code. <br><br>  <b>Architecture</b> <br><br><img src="https://habrastorage.org/files/235/db7/7a1/235db77a160940088459160151245ae4.png"><br><br>  I chose the following solution with these basic elements: <br><br>  <b>Static MemoryCache Register</b> <br><br>  You can create new RedisL1Database entities by passing a ready-made entity to Redis IDatabase, and it will continue to use any in-memory cache that it has previously created for this database. <br><br>  <b>Notification level</b> <br><br>  ‚Ä¢ <b>NotificationDatabase</b> - publishes special keyspace events necessary to maintain the in-memory cache.  Standard keyspace notifications in Redis do not allow to achieve the same result, since they do not provide enough information to invalidate the necessary part of the cache.  For example, if you delete a hash key, you get a HDEL notification with information about which hash it was deleted from.  But it does not indicate which element of the hash it was.  In turn, special events also contain information about the hash element itself. <br>  ‚Ä¢ <b>NotificationListener</b> ‚Äî Subscribes to special keyspace events and accesses static cache to invalidate the required key.  It also subscribes to the built-in Redis keyspace event called expire.  This allows you to quickly delete from memory all expired Redis keys. <br><br>  Next we look at how to cache various data models in Redis. <br><br>  <b>Line</b> <br><br>  Working with a string is relatively simple.  The IDatabase StringSet method looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StringSet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RedisKey key, RedisValue </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, TimeSpan? expiry = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default</span></span></span></span><span class="hljs-function"><span class="hljs-params">(TimeSpan?</span></span></span><span class="hljs-function">), When when</span></span> = When.Always, CommandFlags flags = CommandFlags.None)</code> </pre><br>  ‚Ä¢ Key and Value - the names speak for themselves. <br>  ‚Ä¢ Expiry - an arbitrary period of time, and therefore we need to use in-memory cache with a validity period. <br>  ‚Ä¢ When - allows you to define the conditions for creating a string: set a string only if it already exists or does not exist yet. <br>  ‚Ä¢ Flags - allows you to specify the details of the Redis cluster (not relevant). <br><br>  For data storage, we use System.Runtime.Caching.MemoryCache, which allows for the automatic expiration of keys.  The StringSet method looks like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StringSet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RedisKey key, RedisValue </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, TimeSpan? expiry = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default</span></span></span></span><span class="hljs-function"><span class="hljs-params">(TimeSpan?</span></span></span><span class="hljs-function">), When when</span></span> = When.Always, CommandFlags flags = CommandFlags.None) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (when == When.Exists &amp;&amp; !_cache.Contains(key)) { <span class="hljs-comment"><span class="hljs-comment">//We're only supposed to cache when the key already exists. return; } if (when == When.NotExists &amp;&amp; _cache.Contains(key)) { //We're only supposed to cache when the key doesn't already exist. return; } //Remove it from the memorycache before re-adding it (the expiry may have changed) _memCache.Remove(key); CacheItemPolicy policy = new CacheItemPolicy() { AbsoluteExpiration = DateTime.UtcNow.Add(expiry.Value) }; _memCache.Add(key, o, policy); //Forward the request on to set the string in Redis return _redisDb.StringSet(key, value, expiry, when, flags);</span></span></code> </pre><br><br>  Then StringGet can read the in-memory cache before attempting to access Redis: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RedisValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StringGet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RedisKey key, CommandFlags flags = CommandFlags.None</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cachedItem = _memCache.Get&lt;redisvalue&gt;(key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cachedItem.HasValue) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedItem; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> redisResult = _redisDb.StringGet(key, flags); <span class="hljs-comment"><span class="hljs-comment">//Cache this key for next time _memCache.Add(key, redisResult); return redisResult; } } &lt;/redisvalue&gt;</span></span></code> </pre><br><br>  Redis supports many operations for strings.  In each case, their use is associated with either updating the in-memory value or declaring it invalid.  In general, the second option is better, because otherwise you risk in vain complicate many operations Redis. <br><br>  ‚Ä¢ StringAppend is a very simple operation.  Data is added to the in-memory line, if one exists and is not declared inactive. <br>  ‚Ä¢ StringBitCount, StringBitOperation, StringBitPosition - the operation is performed in Redis, in-memory activation is not required. <br>  ‚Ä¢ StringIncrement, StringDecrement, StringSetBit, StringSetRange - the in-memory string is declared invalid until the operation is redirected to Redis. <br>  ‚Ä¢ StringLength - returns the length of a string if it is in the in-memory cache.  If not, the operation gets it from Redis. <br><br>  <b>Lots of</b> <br><br>  The sets are a bit more difficult to handle.  The SetAdd method is executed as follows: <br><br>  1. Check MemoryCache on HashSet with this key <br>  ‚Ä¢ If one does not exist, create it. <br>  2. Add each Redis value to the set. <br><br>  Adding and removing values ‚Äã‚Äãfrom sets is quite simple.  The SetMove method is SetRemove followed by SetAdd. <br>  Most other set requests can be cached.  For example: <br><br>  ‚Ä¢ <b>SetMembers</b> - returns all elements of a set so that the result is stored in memory. <br>  ‚Ä¢ <b>SetContains, SetLength</b> - checks in-memory sets before accessing Redis. <br>  ‚Ä¢ <b>SetPop</b> - pushes a data item from the Redis set and then removes this item from the in-memory set, if there is one. <br>  ‚Ä¢ <b>SetRandomMember</b> - receives a random set element from Redis, then in-memory caches it and returns it. <br>  ‚Ä¢ <b>SetCombine, SetCombineAndStore</b> - in-memory <b>activation</b> is not required. <br>  ‚Ä¢ <b>SetMove</b> ‚Äî Removes a data item from an in-memory set, adds it to another in-memory set, and redirects it to Redis. <br><br>  <b>Hash tables</b> <br><br>  Hash tables are also relatively simple, since their in-memory implementation is just a Dictionary &lt;string, RedisValue&gt;, which, in principle, is very similar to a string. <br><br>  Basic operation: <br><br>  1. If the hash table is not available in in-memory, you need to create a Dictionary &lt;string, RedisValue&gt; and save it. <br>  2. Perform operations on the in-memory dictionary, if possible. <br>  3. Redirect the request to Redis, if necessary. <br>  ‚Ä¢ Cache the result. <br><br>  The following operations are available for hash tables: <br><br>  ‚Ä¢ HashSet ‚Äî saves values ‚Äã‚Äãin a dictionary stored in the key, and then redirects the request to Redis. <br>  ‚Ä¢ HashValues, HashKeys, HashLength - there is no in-memory application. <br>  ‚Ä¢ HashDecrement, HashIncrement, HashDelete - deletes the value from the dictionary and redirects to Redis. <br>  ‚Ä¢ HashExists - returns true if the value is in the in-memory cache.  Otherwise, it redirects the request to Redis. <br>  ‚Ä¢ HashGet - requests data from the in-memory cache.  Otherwise, it redirects the request to Redis. <br>  ‚Ä¢ HashScan - get results from Redis and add them to the in-memory cache. <br><br>  <b>Ordered set</b> <br><br>  Ordered sets are undoubtedly the most complex data model in terms of creating an in-memory cache.  In this case, the in-memory caching process involves the use of so-called "disjoint ordered sets."  That is, each time the local cache sees a small fragment of an ordered Redis set, this fragment is added to the ‚Äúdisjoint‚Äù ordered set.  If a subsection of an ordered set is later requested, the non-intersecting ordered set will be checked first.  If it contains the entire section, it can be returned with full confidence that there are no missing components. <br><br>  Ordered in-memory sets are sorted not by value, but by a special parameter score.  Theoretically, it would be possible to expand the implementation of disjoint ordered sets so that it is possible to sort them by value, but at the moment this is not yet implemented. <br><br>  Operations use disjoint sets as follows: <br><br>  ‚Ä¢ <b>SortedSetAdd</b> - values ‚Äã‚Äãare added to the in-memory set discretely, which means we do not know whether they are related in terms of score. <br>  ‚Ä¢ <b>SortedSetRemove</b> - the value is deleted both from memory and from Redis. <br>  ‚Ä¢ <b>SortedSetRemoveRangeByRank</b> - all in-memory sets are declared invalid. <br>  ‚Ä¢ <b>SortedSetCombineAndStore, SortedSetLength, SortedSetLengthByValue, SortedSetRangeByRank, SortedSetRangeByValue, SortedSetRank</b> - the request is sent directly to Redis. <br>  ‚Ä¢ <b>SortedSetRangeByRankWithScores, SortedSetScan</b> - <b>data</b> is requested from Redis and then discretely cached. <br>  ‚Ä¢ <b>SortedSetRangeByScoreWithScores</b> is the most cached feature, as scores are returned in order.  The cache is checked, and if it can process the request, it is returned.  Otherwise, a request is sent to Redis, after which scores are cached in memory as a continuous data set. <br>  ‚Ä¢ <b>SortedSetRangeByScore</b> - data is taken from the cache, if possible.  Otherwise, they are taken from Redis and are not cached, since scores are not returned. <br>  ‚Ä¢ <b>SortedSetIncrement, SortedSetDecrement</b> - in-memory data is updated, and the request is redirected to Redis. <br>  ‚Ä¢ <b>SortedSetScore</b> - the value is taken from memory, if possible.  Otherwise, a request is sent to Redis. <br><br>  The complexity of working with ordered sets is due to two reasons: first, the characteristic difficulty of constructing in-memory implementations for existing subsets of ordered sets (that is, building discontinuous sets).  And secondly, due to the number of operations available in Redis that require execution.  To some extent, complexity is reduced by the ability to implement targeted caching of queries, including Score.  Either way, you need serious unit testing of all components. <br><br>  <b>List</b> <br><br>  Lists are not so easy to cache in RAM.  The reason is that operations with them, as a rule, imply work either with the head or with the tail of the list.  And this is not as easy as it may seem at first glance, because we do not have one hundred percent opportunity to make sure that the in-memory list has the same data at the beginning and at the end as the list in Redis.  Partially this difficulty could be solved with the help of key space notifications, but so far this possibility has not been realized. <br><br>  <b>Updates from other customers</b> <br><br>  Up to this point, we proceeded from the consideration that we have only one Redis database client.  In fact, customers can be many.  Under such conditions, it is quite possible that one client has data in the in-memory cache, and another one updates it, which makes the data of the first client invalid.  There is only one way to solve this problem - to set up communication between all clients.  Fortunately, Redis provides a publisher-subscriber messaging mechanism.  This template has 2 types of notifications. <br><br>  <b>Key Space Notifications</b> <br><br>  These notifications are published to Redis automatically when the key changes. <br><br>  <b>Specially published notices</b> <br><br>  They are published at the notification level, implemented as part of the caching mechanism for the client.  Their goal is to reinforce the key space notifications with additional information necessary to invalidate certain small parts of the cache. <br>  Working with multiple clients is a major cause of caching problems. <br><br>  <b>Risks and problems</b> <br><br>  <b>Lost Notifications</b> <br><br>  Redis does not guarantee delivery of key space notifications.  Accordingly, notifications can be lost, and invalid data will remain in the cache.  This is one of the most basic risks, but, fortunately, such situations rarely occur.  However, when working with two or more clients, this danger must be taken into account. <br><br>  <b>Solution:</b> use a reliable messaging mechanism between customers with guaranteed delivery.  Unfortunately, this is not yet, so see the alternative solution. <br>  <b>Alternative solution:</b> perform in-memory caching only for a short time, say, for one hour.  In this case, all data that we access within an hour will load faster.  And if any notification is lost, this omission will soon be filled.  Call the Dispose method on the database, and then instantiate it again to clear it. <br><br>  <b>Uses one - use all</b> <br>  If one client uses this caching level (L1), all other clients must use it to notify each other when data changes. <br><br>  <b>No limit for in-memory data</b> <br>  At the moment, everything that can be cached will be sent to the cache.  In such a situation, you can quickly run out of memory.  In my case, this is not a problem, but just keep this in mind. <br><br>  <b>Conclusion</b> <br>  They say there are only 10 complex problems in programming: cache invalidation, naming and the binary system ... I am sure this project can be useful in many situations.  The source code for the library is available on <a href="https://github.com/johnnycardy/redis-l1">GitHub</a> .  Follow the project and take part in it! </div><p>Source: <a href="https://habr.com/ru/post/301222/">https://habr.com/ru/post/301222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301212/index.html">How to enter the "stream": a magic scheme that will suit everyone</a></li>
<li><a href="../301214/index.html">Count the invisible: reliably determine vocabulary</a></li>
<li><a href="../301216/index.html">Google does not refuse Flash</a></li>
<li><a href="../301218/index.html">GrabDuck: From Newton to Website</a></li>
<li><a href="../301220/index.html">SAP Innovation Forum for development companies in Moscow</a></li>
<li><a href="../301224/index.html">Preparing mine infrastructure for the implementation of the RealTrac local positioning and voice communication system</a></li>
<li><a href="../301226/index.html">The creators of the TeslaCrypt Trojan encoder closed the project and published the master key for unlocking</a></li>
<li><a href="../301230/index.html">Six Myths of Product Development</a></li>
<li><a href="../301234/index.html">How are the backups of customers in our TierIII data center</a></li>
<li><a href="../301236/index.html">Technosphere Mail.Ru: student projects, laboratory and championships in Data Science</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>