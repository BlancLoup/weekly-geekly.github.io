<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Close contacts of ADL degree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How to put your name in history forever? The first to fly to the moon? The first to meet with an alien mind? We have a simpler way - you can write you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Close contacts of ADL degree</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/zb/i1/7h/zbi17hhfyu9_oqqmwgpzijon0d8.jpeg"></p><br><p>  How to put your name in history forever?  The first to fly to the moon?  The first to meet with an alien mind?  We have a simpler way - you can write yourself into the standard of the C ++ language. </p><br><p>  A good example is Eric Nibler, author of C ++ Ranges.  ‚ÄúRemember this.  February 19, 2019 is the day when the term ‚Äúnibloid‚Äù was first pronounced at the WG21 meeting, ‚Äùhe <a href="https://twitter.com/ericniebler/status/1098044731773267968">wrote</a> on Twitter. </p><br><p>  And indeed, if you go to the CppReference, in the <a href="https://en.cppreference.com/mwiki/index.php%3Ftitle%3Dcpp/algorithm/ranges">section cpp / algorithm / rangescpp / algorithm / ranges</a> , you can find there many references (niebloid).  To do this, even made a separate wiki template <a href="https://en.cppreference.com/w/Template:dsc_niebloid">dsc_niebloid</a> . </p><br><p>  Unfortunately, I did not find any official full-fledged article on this topic and decided to write my own.  This is a small, but fascinating journey into the abyss of architectural astronautics, in which we can plunge into the abyss of ADL madness and meet with nibloids. </p><br><p>  Important: I am not a real welder, but a javist, who sometimes corrects errors in C ++ code as needed.  If you spend a little time to help find errors in reasoning, it will be nice.  "Help Dasha the traveler to collect something reasonable." </p><a name="habracut"></a><br><h2 id="lookup">  Lookup </h2><br><p>  First you need to decide on the terms.  These are well-known things, but ‚Äúthe obvious is better than the implicit,‚Äù so let's talk them separately.  I do not use real Russian terminology, but instead use Englishism.  This is necessary because even the word ‚Äúrestriction‚Äù in the context of this article can be compared with at least three English versions, the difference between which is important for understanding. </p><br><p>  For example, in C ++ there is the concept of <a href="https://en.cppreference.com/w/cpp/language/lookup">searching for names</a> or otherwise - lukapa: when a program encounters a <a href="https://en.cppreference.com/w/cpp/language/identifiers">name</a> , it is associated with its <a href="https://en.cppreference.com/w/cpp/language/declarations">declaration</a> at compile time. </p><br><p> Lucap is <a href="https://en.cppreference.com/w/cpp/language/qualified_lookup">qualified</a> , (if the name is to the right of the Scop permit operator <code>::</code> :), and <a href="https://en.cppreference.com/w/cpp/language/unqualified_lookup">unqualified</a> in other cases.  If the lookup is qualified, then we bypass the appropriate members of the class, namespace, or enumeration.  One could call it the ‚Äúfull‚Äù version of the record (as it seems to be done in the Stroustrup translation), but it is better to leave the original spelling, because it means a very specific kind of completeness. </p><br><h2 id="adl">  ADL </h2><br><p>  If Lukap is not qualified, then we need to understand exactly where to look for the name.  And here comes a special feature called ADL: <a href="https://en.cppreference.com/w/cpp/language/adl">argument-dependent lookup</a> , or else, a search for <a href="https://en.wikipedia.org/wiki/Andrew_Koenig_%2528programmer%2529">Koenig</a> (the one who coined the term ‚Äúanti-pattern‚Äù, which is a bit symbolic in the light of the following text).  Nicolai Josuttis in his book ‚ÄúThe C ++ Standard Library: A Tutorial and Reference‚Äù describes it like this: ‚ÄúThe point is that you don‚Äôt need to qualify the namespace function if at least one of the argument types is defined in the namespace of this function.‚Äù </p><br><p>  What should it look like? </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { //  . //   , operator&lt;&lt;    ,  ADL , //    std    std::operator&lt;&lt;(std::ostream&amp;, const char*) std::cout &lt;&lt; "Test\n"; //    .      -     . operator&lt;&lt;(std::cout, "Test\n"); // same, using function call notation //    : // Error: 'endl' is not declared in this namespace. //      endl(),  ADL  . std::cout &lt;&lt; endl; //  . //    ,       ADL. //     std,   endl      std. endl(std::cout); //    : // Error: 'endl' is not declared in this namespace. //  ,  - (endl) -     . (endl)(std::cout); }</span></span></span></span></code> </pre> <br><h2 id="spuskaemsya-v-ad-s-adl">  Get down to hell with ADL </h2><br><p>  It would seem simple.  Or not?  First, depending on the type of argument, ADL works in <a href="https://en.cppreference.com/w/cpp/language/adl">nine different ways</a> , get killed with a broom. </p><br><p>  Secondly, purely practically, imagine that we have a certain function swap.  It turns out that <code>std::swap(obj1,obj2);</code>  and <code>using std::swap; swap(obj1, obj2);</code> <code>using std::swap; swap(obj1, obj2);</code>  may behave completely differently.  If ADL is included, then from several different swaps the necessary one is selected based on the namespaces of the arguments!  Depending on the point of view, this idiom can be considered both a positive and negative example :-) </p><br><p>  If it seems to you that this is not enough, you can throw the wood into the stove heyta.  This was recently well <a href="https://quuxplusone.github.io/blog/2019/04/08/adl-insanity/">written by Arthur O'Dwyer</a> .  I hope he does not punish me for using my example. </p><br><p>  Imagine that you have a program of this type: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  Of course, it does not compile with an error: </p><br><pre> <code class="plaintext hljs">error: use of undeclared identifier 'call'; did you mean 'A::call'? call(f); ^~~~ A::call</code> </pre> <br><p>  But if we add a <strong>completely unused overload of the</strong> function <code>f</code> , then everything will work! </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace A { struct A {}; void call(void (*f)()) { f(); } } void f() { puts("Hello world"); } void f(A::A); // UNUSED int main() { call(f); }</span></span></span></span></code> </pre> <br><p>  At Visual Studio it will still break, but such is its fate, not to work. </p><br><p>  How did it happen?  Let's dig <a href="http://eel.is/c%2B%2Bdraft/basic.lookup.argdep">in the standard</a> (without translation, because such a translation would be an extremely monstrous mix of buzzwords): </p><br><blockquote>  This is a list of the rules of the association. types and return type.  [...] Additionally, it‚Äôs also possible to use it. </blockquote><p>  Now take a code like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; namespace B { struct B {}; void call(void (*f)()) { f(); } } template&lt;class T&gt; void f() { puts("Hello world"); } int main() { call(f&lt;B::B&gt;); }</span></span></span></span></code> </pre> <br><p>  In both cases, arguments are obtained that have no type.  <code>f</code> and <code>f&lt;B::B&gt;</code> are the names of the sets of overloaded functions (from the definition above), and such a set has no type.  To minimize the overload into a single function, you need to understand which type of function pointer is best suited to the best overload <code>call</code> .  So, you need to collect a set of candidates for <code>call</code> , it means - to launch the <code>call</code> name <code>call</code> .  And for this ADL will start! </p><br><p>  But usually, for ADL, we need to know the types of arguments!  And here Clang, ICC, and MSVC mistakenly break like this (GCC doesn't): </p><br><pre> <code class="cpp hljs">[build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): error: use of undeclared identifier <span class="hljs-string"><span class="hljs-string">'call'</span></span>; did you mean <span class="hljs-string"><span class="hljs-string">'B::call'</span></span>? [build] call(f&lt;B::B&gt;); [build] ^~~~ [build] B::call [build] ..\..\main.cpp(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>): note: <span class="hljs-string"><span class="hljs-string">'B::call'</span></span> declared here [build] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)())</span></span></span><span class="hljs-function"> </span></span>{ [build] ^</code> </pre> <br><p>  Even the creators of the compilers with ADL have some strained relationships. </p><br><p>  Well, ADL still seems like a good idea to you?  On the one hand, we no longer need to write such slave code in a way that looks like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>);</code> </pre> <br><p>  On the other hand, we traded for brevity the fact that now there is a system that works in a completely non-humanoid manner.  The tragic and magnificent story of how the convenience of writing Hello World can affect the entire language across decades. </p><br><h2 id="renzhi-i-koncepty">  Rengi and concepts </h2><br><p>  If you open the description of the <a href="https://en.cppreference.com/mwiki/index.php%3Ftitle%3Dcpp/algorithm/ranges">library Nibblera</a> , then before mentioning nibloidov stumble on many other markers called <strong>(concept)</strong> .  This is already a pretty raspiarennaya thing, but just in case (for the Old and Javista) I remind you <a href="https://en.cppreference.com/w/cpp/language/constraints">what it is</a> . </p><br><p>  Concepts are called named sets of constraints that apply to template arguments to select the best function overloads and the most appropriate template specializations. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasStringFunc = requires(T a) { { to_string(a) } -&gt; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HasStringFunc a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; to_string(a) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Here we have imposed the restriction that the argument must have a function <code>to_string</code> , which returns a string.  If we try to shove any game into <code>print</code> that does not fall under the restrictions, then such code simply will not compile. </p><br><p>  This is great code simplification.  For example, see how Niebler did the <a href="">sorting in ranges-v3</a> , which works on C ++ 11/14/17.  There is a wonderful code like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT_(X, Y) X ## Y #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCEPT_PP_CAT(X, Y) CONCEPT_PP_CAT_(X, Y) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/// \addtogroup group-concepts /// @{ #define CONCEPT_REQUIRES_(...) \ int CONCEPT_PP_CAT(_concept_requires_, __LINE__) = 42, \ typename std::enable_if&lt; \ (CONCEPT_PP_CAT(_concept_requires_, __LINE__) == 43) || (__VA_ARGS__), \ int \ &gt;::type = 0 \ /**/</span></span></span></span></code> </pre> <br><p>  So that you can do it later: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sortable_</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> I = <span class="hljs-keyword"><span class="hljs-keyword">iterator_t</span></span>&lt;Rng&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requires_() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( concepts::valid_expr( concepts::model_of&lt;concepts::ForwardRange, Rng&gt;(), concepts::is_true(ranges::Sortable&lt;I, C, P&gt;()) )); }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Sortable = concepts::models&lt;Sortable_, Rng, C, P&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C = ordered_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P = ident, CONCEPT_REQUIRES_(!Sortable&lt;Rng, C, P&gt;())&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(Rng &amp;&amp;, C &amp;&amp; = C{}, P &amp;&amp; = P{}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { ...</code> </pre> <br><p>  I hope you already wanted to sort it all out and just use ready-made concepts in a fresh compiler. </p><br><h2 id="tochki-kastomizacii">  Customization points </h2><br><p>  The next interesting thing that can be found in the standard is <a href="http://eel.is/c%2B%2Bdraft/customization.point.object">customization.point.object</a> .  They are actively used in the library of Nibbler. </p><br><p>  The customization point is a function used by the standard library so that it can be reloaded for user types in the user's namespace, and these overloads are found using ADL. </p><br><p>  The customization points have been developed taking into account the following architectural principles ( <code>cust</code> here is the name for some imaginary customization point): </p><br><ul><li>  The code that calls <code>cust</code> written either in a qualified form <code>std::cust(a)</code> , or unqualified: <code>using std::cust; cust(a);</code> <code>using std::cust; cust(a);</code>  .  Both entries must behave identically.  In particular, they must find any user overloads in the namespaces associated with the arguments. </li><li>  Code that uses <code>cust</code> in the form of <code>std::cust; cust(a);</code> <code>std::cust; cust(a);</code>  should not be able to bypass the restrictions imposed on <code>std::cust</code> . </li><li>  The challenges of customization points should work efficiently and optimally on any sufficiently modern compiler. </li><li>  The decision should not create any new violations of the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D0%25BE%25D0%25B4%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25BE%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">Rules for a single definition (ODR)</a> . </li></ul><br><p>  To understand what it is, you can take a look at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html">N4381</a> .  At first glance, they look like a way to write your own versions of <code>begin</code> , <code>swap</code> , <code>data</code> , and the like, and the standard library picks them up with ADL. </p><br><p>  The question arises, how is this different from the old practice when the user writes an overload for some <code>begin</code> for his own type and namespace?  And why are they objects at all? </p><br><p>  In fact, these are instances of <a href="https://en.cppreference.com/w/cpp/utility/functional">functional objects</a> in the <code>std</code> .  Their purpose is to first pull type checks (designed as concepts) on all arguments in a row, and then dispatch the call to the correct function in <code>std</code> or redeem it to ADL. </p><br><p>  In fact, this is not the thing that you would use in a regular non-library program.  This is a feature of the standard library, which will allow you to add concept checking on future extension points, which in turn will lead to displaying more beautiful and understandable errors if you have messed up something in the templates. </p><br><p>  The current approach to customization points has a couple of problems.  First, it is very easy to break everything.  Imagine this code: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t2</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap(t1, t2); }</code> </pre> <br><p>  If we accidentally make a qualified call to <code>std::swap(t1, t2)</code> then our own version of the <code>swap</code> will never start, which we would not push there.  But what is more important, there is no way to centrally check concept checks on such custom implementations of functions.  In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html">N4381</a> write: </p><br><p>  ‚ÄúImagine that sometime in the future, <code>std::begin</code> will require its argument to be modeled as a <code>Range</code> concept.  Adding such a restriction simply will not have any effect on the code idiomatically using <code>std::begin</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin; begin(a);</code> </pre> <br><p>  After all, if the <code>begin</code> call is dispatched to the overloaded version created by the user, then the restrictions on <code>std::begin</code> simply ignored. ‚Äù </p><br><p>  The solution described in propozale solves both problems, for this the approach from the following speculative implementation of <code>std::begin</code> (you can look <a href="https://godbolt.org/z/7IWwic">at godbolt</a> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt; namespace my_std { namespace detail { struct begin_fn { /*   ,         begin(arg)  arg.begin().  -   . */ template &lt;class T&gt; auto operator()(T&amp;&amp; arg) const { return impl(arg, 1L); } template &lt;class T&gt; auto impl(T&amp;&amp; arg, int) const requires requires { begin(std::declval&lt;T&gt;()); } { return begin(arg); } // ADL template &lt;class T&gt; auto impl(T&amp;&amp; arg, long) const requires requires { std::declval&lt;T&gt;().begin(); } { return arg.begin(); } // ... }; } //        inline constexpr detail::begin_fn begin{}; }</span></span></span></span></code> </pre> <br><p>  A qualified call to some kind of <code>my_std::begin(someObject)</code> always passes through <code>my_std::detail::begin_fn</code> - and that's good.  What happens to the unqualified call?  Let's read our paper again: </p><br><p>  ‚ÄúIn the case when begin is called without qualification immediately after the appearance of <code>my_std::begin</code> inside the loop, the situation changes somewhat.  In the first stage of the lukap, the name <code>begin</code> resolve to the global object <code>my_std::begin</code> .  Since lukap found an object, not a function, the second phase of the lukap is not performed.  In other words, if <code>my_std::begin</code> is an object, then use the construction <code>my_std::detail::begin_fn begin; begin(a);</code> <code>my_std::detail::begin_fn begin; begin(a);</code>  equivalent to just <code>std::begin(a);</code>  - and as we have already seen, it launches a custom ADL. ‚Äù </p><br><p>  That is why concept checking can be done in a functional object in <code>std</code> , before ADL calls the function provided by the user.  There is no way to fool this behavior. </p><br><h2 id="kak-kastomiziruyut-tochki-kastomizacii">  How to customize customization points? </h2><br><p>  In fact, ‚Äúcustomization point object‚Äù (CPO) is not a very good name.  From the name it is not clear how they expand, what mechanisms lie under the hood, what functions they prefer ... </p><br><p>  Which leads us to the term "nibloid".  A nibloid is such a CPO that calls function X if it is defined in a class, otherwise it calls function X, if there is a suitable free function, otherwise it tries to perform some fallback of function X. </p><br><p>  So for example, the nibloid <code>ranges::swap</code> when calling <code>ranges::swap(a, b)</code> will first try to call <code>a.swap(b)</code> .  If there is no such method, it will try to call <code>swap(a, b)</code> using ADL.  If that doesn't work either, it will try <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code>  <code>auto tmp = std::move(a); a = std::move(b); b = std::move(tmp)</code> . </p><br><h1 id="itogi">  Results </h1><br><p>  As Matt <a href="https://twitter.com/CppSage/status/1098120484011429888">joked</a> on Twitter, <a href="https://twitter.com/DaveAbrahams">Dave</a> once offered to make functional objects "work" with ADL in the same way as regular functions do, for consistency reasons.  The irony is that their property to disable ADL and being invisible to it has now become their main advantage. </p><br><p>  This whole article was a preparation for this. </p><br><p>  " <i><b>I just understood everything, that's all. Will you <a href="https://habr.com/ru/company/jugru/blog/438260/">listen</a> ?</b></i> </p><br><p>  <i><b>Have you ever looked at something, and it seemed insane, and then in a different light on</b></i> <i><b><br></b></i>  <i><b>crazy things seeing them normal?</b></i> </p><br><p><img src="https://habrastorage.org/webt/-f/us/rh/-fusrhpdssngql8nlfx2qn0gdd8.jpeg"></p><br><p>  <i><b>Do not be afraid.</b></i>  <i><b>Do not be afraid.</b></i>  <i><b>I'm so good at heart.</b></i>  <i><b>Everything will be fine.</b></i>  <i><b>I have not felt so good for many years.</b></i>  <i><b>Everything will be fine.</b></i> </p><br><p><img src="https://habrastorage.org/webt/pe/ca/az/pecaazhixdkr6dsdxv67ewlvte8.jpeg"></p><br><blockquote>  Minute advertising.  Already <b>this week</b> , April 19-20, C ++ Russia 2019 will be held - a conference full of hardcore presentations both on the language itself and on practical issues like multithreading and performance.  By the way, the conference is <a href="https://cppconf.ru/talks/75xt7yxs4phphnnxq0rygs/%3Futm_source%3Dhabr%26utm_medium%3D447900">opened by</a> Nicolai Josuttis mentioned in the article, the author of "The C ++ Standard Library: A Tutorial and Reference".  You can view the program and purchase tickets <a href="https://cppconf.ru/talks/75xt7yxs4phphnnxq0rygs/%3Futm_source%3Dhabr%26utm_medium%3D447900">on the official website</a> .  There is very little time left, this is the last chance. </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/447900/">https://habr.com/ru/post/447900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447886/index.html">Analyzing Nginx Logs with Amazon Athena and Cube.js</a></li>
<li><a href="../447890/index.html">Thank god i'm not a manager</a></li>
<li><a href="../447892/index.html">Two new PHDays contests: IDS bypass and factory hacking</a></li>
<li><a href="../447894/index.html">MODX Digest # 3 (March 25 - April 8, 2019)</a></li>
<li><a href="../447896/index.html">Photos from rough sketches: how exactly does the NVIDIA GauGAN neural network work?</a></li>
<li><a href="../447902/index.html">GitHub has completely ‚Äúdeleted‚Äù the utility repository for circumventing locks and the entire creator account.</a></li>
<li><a href="../447904/index.html">Positive Technologies Experts Revealed Attempts to Mass Exploit Critical Threats to Confluence</a></li>
<li><a href="../447906/index.html">Actual innovation: what to expect from the data center market in 2019?</a></li>
<li><a href="../447908/index.html">Two ways to collect awards for advertising in mobile games, or robots should work</a></li>
<li><a href="../447910/index.html">The "oil" of the modern economy and the war for personnel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>