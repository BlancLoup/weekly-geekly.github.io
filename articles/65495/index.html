<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tree Management Module Nested Sets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Task 
 Yeah, you have collected a boat that would ride on the ponds and enjoy life. I went to the next lake to rest, and they tell you that they say t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tree Management Module Nested Sets</h1><div class="post__text post__text-html js-mediator-article"><h4>  Task </h4><br>  Yeah, you have collected a boat that would ride on the ponds and enjoy life.  I went to the next lake to rest, and they tell you that they say that dogs and boats are forbidden to enter, and in general we have a lake that is always frozen, so you can enjoy your skates.  <i>"Welcome to the Virtual Hosting lake".</i> <a name="habracut"></a>  Somehow I didn‚Äôt notice that triggers in <i>MySQL</i> can only be created by the <i>SUPER</i> user, which is somewhat surprising, but we‚Äôll leave it to the developers ‚Äôconscience.  <a href="http://doc.prototypes.ru/database/nestedsets/sql/mysql_trigger/">Triggers</a> , of course, are good, but for now we will put them on the shelf. I <a href="http://doc.prototypes.ru/database/nestedsets/perl/module/">have a</a> solution for Perl, but when I created it, there were completely different tasks and requirements.  Therefore, this article does not cancel the previous developments, but only offers an additional solution. So what is and what needs to be done.  I have a certain set of objects and a certain "wrapper" for working with the database.  In this ‚Äúwrapper‚Äù I will include this module as an extension of its functionality.  Wrap samopisnaya.  I will make a reservation in advance, I am not an opponent of <i>DBIx :: Class</i> and other ready-made solutions, I use them in my work and am satisfied.  The question rests on <i>Virtual Hosting and</i> others like it: the absence of mod_perl and the installation of additional modules.  The solution for the same <i>DBIx :: Class is</i> in development, but not very fast due to the fact that there is no need, I have enough triggers. Therefore, I need only three procedures: <i>insert</i> , <i>update</i> and <i>delete</i> .  It is procedures that in turn are examined as methods of the ‚Äúwrapper‚Äù object.  However, in this article, I will make it almost self-sufficient.  I didn‚Äôt include transactions in this module, since I‚Äôm using them to a higher level, it‚Äôs easy to include them into the code, I think, it‚Äôs not difficult. Bugs and inaccuracies are possible, because the module is fresh and hasn‚Äôt been ‚Äúbaptized‚Äù , although some functional testing was done. <br><br><h4>  Basic procedures and variables </h4><br>  Procedures for connecting to the database, of course, but there is an object package $ dbh, which is determined from the outside.  Also, to ensure universality, we will create an array in which we will define for each table our own set of fields responsible for the tree structure, you never know who wants to call them. <br>  Perl code (1) <pre> package MY :: NestedSets;
 # All for an adult, without compromise ;-)
 use strict;
 use warnings;
 our $ VERSION = '0.0.1';
 # Determine the variables that will be used inside the package
 our $ dbh = undef;
 our $ tables = {
                 default =&gt; {# Table name
                     fields =&gt; {# Table fields
                         id =&gt; 'id', # Actually ID, you never know who will call
                         left_key =&gt; 'left_key', # Left key
                         right_key =&gt; 'right_key', # Right key
                         level =&gt; 'level', # Level
                         parent_id =&gt; 'parent_id', # parent ID
                         tree =&gt; 'tree' # tree id
                                 },
                     multi =&gt; 1, # Tells us that there are several trees in the table
                             },
                };

 sub dbh {
 # The first value can be the name of the package or the class of the package, if we still manage to create it
 # therefore we cut it off now and then, we don‚Äôt have a class.
     shift if $ _ [0] &amp;&amp; ($ _ [0] eq __PACKAGE__ || (ref $ _ [0] &amp;&amp; ref $ _ [0] eq __PACKAGE__));
     $ dbh = $ _ [0] if $ _ [0];
     return $ dbh;
 }

 sub set_table_params {
     shift if $ _ [0] &amp;&amp; ($ _ [0] eq __PACKAGE__ || (ref $ _ [0] &amp;&amp; ref $ _ [0] eq __PACKAGE__));
 # Set our fields for a specific table
     my ($ table_name, $ params) = @_;
     $ tables -&gt; {$ table_name} = $ params;
     return $ tables;
 }
    </pre><br>  In parallel, I will write the use script itself, which is also a test one.  So, we use our module and define its basic data. <br>  Perl code (2) <pre> #! / usr / bin / perl
 use strict;  use warnings;
 use lib '../lib';
 use MY :: NestedSets;
 use DBI;
 use Data :: Dumper;

 # ------------------------------------------------- -------------------------------------------------- -----
 # INIT

 my $ dbh = DBI-&gt; connect ('dbi: mysql: database = test; host = localhost; port = 3306', 'user', 'pass');
 my $ table_name = 'test_nested_sets';
 my% f = (
         id =&gt; 'ids',
         left_key =&gt; 'lk',
         right_key =&gt; 'rk',
         level =&gt; 'lv',
         parent_id =&gt; 'pi',
         tree =&gt; 'tr',
         );
 $ dbh-&gt; do ("DROP TABLE` $ table_name`; ");
 my $ query = "CREATE TABLE` $ table_name` (
     `$ f {id}` int (11) NOT NULL auto_increment,
     `$ f {left_key}` int (11) NOT NULL default '0',
     `$ f {right_key}` int (11) NOT NULL default '0',
     `$ f {level}` int (11) NOT NULL default '0',
     `$ f {parent_id}` int (11) NOT NULL default '0',
     `$ f {tree}` int (11) NOT NULL default '1',
     `field1` VARCHAR (100),
     PRIMARY KEY (`$ f {id}`)
 ) ENGINE = MyISAM; ";
 $ dbh-&gt; do ($ query);

 MY :: NestedSets-&gt; dbh ($ dbh);
 MY :: NestedSets-&gt; set_table_params ($ table_name =&gt; {fields =&gt; \% f, multi =&gt; 1});
 ...
    </pre><br><br><h4>  Insert node </h4><br>  The logic of operation is the same as for the trigger. <br>  Perl code (3) <pre> sub insert {
 # We distribute the incoming data in places, and, accordingly, we check if we have enough
     shift if $ _ [0] &amp;&amp; ($ _ [0] eq __PACKAGE__ || (ref $ _ [0] &amp;&amp; ref $ _ [0] eq __PACKAGE__));
     my ($ table_name, $ new) = @_;
     return {success =&gt; 0, error =&gt; 'Bad income data!'} unless $ dbh &amp;&amp; $ table_name &amp;&amp; $ new &amp;&amp; ref $ new &amp;&amp; ref $ new eq 'HASH';
 # We find that for the table and take its additional attributes and synonyms of the fields
     my $ table = $ tables -&gt; {$ table_name} ||  $ tables -&gt; {default};
     my $ f = $ table -&gt; {fields};
     my $ result_flags = {is_last_unit =&gt; undef};
 # Determine the initial data of the keys of the tree
     $ new -&gt; {$ f -&gt; {left_key}} || = 0;
     $ new -&gt; {$ f -&gt; {right_key}} = undef;
     $ new -&gt; {$ f -&gt; {level}} = undef;
     $ new -&gt; {$ f -&gt; {parent_id}} || = 0;
 # Determine the keys if we have set or changed the parent node
     if ($ new -&gt; {$ f -&gt; {parent_id}}) {
         my $ sql = 'SELECT'.
                         ($ table -&gt; {multi}? $ f -&gt; {tree}. 'AS tree,': '').
                         $ f -&gt; {right_key}. '  AS left_key, '.
                         $ f -&gt; {level}. '  + 1 AS level '.
                  'FROM'. $ Table_name.
                  'WHERE'. $ F -&gt; {id}. '  = '. $ new -&gt; {$ f -&gt; {parent_id}};
 # That would be clear, this is a request (in square brackets is not a mandatory expression):
 # SELECT [tree AS tree,] right_key AS left_key, level + 1 AS level FROM $ table_name WHERE id = $ parent_id;
         my $ sth = $ dbh-&gt; prepare ($ sql);  $ sth-&gt; execute ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
         my $ row = $ sth-&gt; fetchrow_hashref ();
         $ sth-&gt; finish;
 # Parent node found, means overriding key values
         if ($ row) {
             $ new -&gt; {$ f -&gt; {tree}} = $ row -&gt; {tree} ||  undef;
             $ new -&gt; {$ f -&gt; {left_key}} = $ row -&gt; {left_key};
             $ new -&gt; {$ f -&gt; {level}} = $ row -&gt; {level};
         } else {
 # Parent node not found, then parent_id is left, reset it
             $ new -&gt; {$ f -&gt; {parent_id}} = 0;
             $ new -&gt; {$ f -&gt; {level}} = 0;
         }
     }
 # Determine the keys if we have the left key, but the parent node is not specified, or not found
     if (! $ new -&gt; {$ f -&gt; {parent_id}} &amp;&amp; $ new -&gt; {$ f -&gt; {left_key}}) {
 # It is important!  $ tree parameter is required if multi-trees
         return {success =&gt; 0, error =&gt; 'No tree value!'} unless $ new -&gt; {$ f -&gt; {tree}} &amp;&amp; $ table -&gt; {multi};
 # At first I wanted to use SQL :: Abstract, but I didn‚Äôt like it, describing complex queries is more difficult and longer
 # Find a node by the left or right key
         my $ sql = 'SELECT'.
                         $ f -&gt; {id}. '  AS id, '.
                         $ f -&gt; {left_key}. '  AS left_key, '.
                         $ f -&gt; {right_key}. '  AS right_key, '.
                         $ f -&gt; {level}. '  AS level, '.
                         $ f -&gt; {parent_id}. '  AS parent_id '.
                  'FROM'. $ Table_name.
                  'WHERE'.
                  ($ table -&gt; {multi}? $ f -&gt; {tree}. '='. $ new -&gt; {$ f -&gt; {tree}}. 'AND': '').
                  '('. $ f -&gt; {left_key}. '='. $ new -&gt; {$ f -&gt; {left_key}}. 'OR'.
                  $ f -&gt; {right_key}. '  = '. $ new -&gt; {$ f -&gt; {left_key}}.') LIMIT 1 ';
 # Request is readable:
 # SELECT
 # id AS id,
 # left_key AS left_key,
 # right_key AS right_key,
 # level AS level,
 # parent_id AS parent_id
 # FROM $ table_name
 # WHERE
 # [tree = $ tree AND]
 # (left_key = $ left_key OR right_key = $ left_key)
 # LIMIT 1;
         my $ sth = $ dbh-&gt; prepare ($ sql);  $ sth-&gt; execute ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
         my $ row = $ sth-&gt; fetchrow_hashref ();
         $ sth-&gt; finish;
 # We found the node by the left key, therefore, we will have a new node in front of the found one
         if ($ row &amp;&amp; $ row -&gt; {left_key} == $ new -&gt; {$ f -&gt; {left_key}}) {
             $ new -&gt; {$ f -&gt; {parent_id}} = $ row -&gt; {parent_id};
             $ new -&gt; {$ f -&gt; {level}} = $ row -&gt; {level};
 # We found the node by the right key, therefore, we will have a new node under the found
         } elsif ($ row) {
             $ new -&gt; {$ f -&gt; {parent_id}} = $ row -&gt; {id};
             $ new -&gt; {$ f -&gt; {level}} = $ row -&gt; {level} + 1;
         } else {
 # Again such a crap, indicated completely left data.  It would be nice to swear, but for now we ignore these shoals,
 # as we can handle ourselves without this data
             $ new -&gt; {$ f -&gt; {left_key}} = undef;
         }
     }
 # Actually, we could not get the insertion point, or simply it was not specified.
 # We will insert at the end of the tree, so updating the existing nodes is not required, therefore we will make the appropriate flag:
     unless ($ new -&gt; {$ f -&gt; {left_key}}) {
         $ result_flags -&gt; {is_last_unit} = 1;
 # This is important again!  $ tree parameter is required if multi-trees.
 # In general, it was possible to check this at the very beginning, but this parameter is not necessary if we specified parent_id,
 # then the value of the key tree is determined by it.
         return {success =&gt; 0, error =&gt; 'No tree value!'} unless $ new -&gt; {$ f -&gt; {tree}} &amp;&amp; $ table -&gt; {multi};
 # It's all simple, determine the maximum right key and enjoy
         my $ sql = 'SELECT MAX ('. $ f -&gt; {right_key}. ') + 1 AS left_key
             FROM '. $ Table_name.
             ($ table -&gt; {multi}? 'WHERE'. $ f -&gt; {tree}. '='. $ new -&gt; {$ f -&gt; {tree}: '');
 # Request is readable:
 # SELECT MAX (right_key) + 1 AS left_key,
 # FROM $ table_name
 # [WHERE tree = $ tree];
         my $ sth = $ dbh-&gt; prepare ($ sql);  $ sth-&gt; execute ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
         my $ row = $ sth-&gt; fetchrow_hashref ();
         $ sth-&gt; finish;
 # But the joy may not be complete, since there may be no nodes at all
         $ new -&gt; {$ f -&gt; {left_key}} = $ row -&gt; {left_key} ||  one;
         $ new -&gt; {$ f -&gt; {parent_id}} = 0;
         $ new -&gt; {$ f -&gt; {level}} = 0;
     }
 # Well, we have decided on the destination, you can do the key breaking in the tree:
     unless ($ result_flags -&gt; {is_last_unit}) {
         my $ query = 'UPDATE'. $ table_name.
                        'SET'. $ F -&gt; {left_key}. '  = CASE
                                     WHEN '. $ F -&gt; {left_key}.'  &gt; = '. $ new -&gt; {$ f -&gt; {left_key}}.'
                                     THEN '. $ F -&gt; {left_key}.'  + 2 ELSE '. $ F -&gt; {left_key}.'  END,
                             '. $ f -&gt; {right_key}.'  = '. $ f -&gt; {right_key}.'  + 2
                      WHERE '.
                      ($ table -&gt; {multi}? $ f -&gt; {tree}. '='. $ new -&gt; {$ f -&gt; {tree}}. 'AND': '').
                       $ f -&gt; {right_key}. '  &gt; = '. $ new -&gt; {$ f -&gt; {left_key}};
 # Request is readable:
 # UPDATE $ table_name
 # SET
 # left_key = CASE WHEN left_key&gt; = $ left_key 
 # THEN left_key + 2 
 # ELSE left_key
 # END,
 # right_key = right_key + 2
 # WHERE [tree = $ tree AND] right_key&gt; = $ left_key;
         $ dbh-&gt; do ($ query) ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
     }
 # Now, actually, why did we come here:
 # The right key is calculated
     $ new -&gt; {$ f -&gt; {right_key}} = $ new -&gt; {$ f -&gt; {left_key}} + 1;
 # Putting keys
     $ new -&gt; {$ f -&gt; {tree}} = $ new -&gt; {$ f -&gt; {tree}} if $ table -&gt; {multi};
 # It is necessary to display the fields in a certain order
     my @fields = keys% {$ new};
 # here we quota non numeric and empty lines and push in the order of @fields
 # and yes, they still need to be checked before they got here, at least for the presence of double quotes
     my @values ‚Äã‚Äã= map {defined $ new -&gt; {$ _} &amp;&amp; $ new -&gt; {$ _} = ~ / ^ \ d + $ /?  $ new -&gt; {$ _}: '"'. $ new -&gt; {$ _}. '"'} @fields;
 # Actually INSERT
     my $ query = 'INSERT INTO'. $ table_name. '  ('. (join', ', @fields).') VALUES ('. (join', ', @values).') ';
     $ dbh-&gt; do ($ query) ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
 # And here's what to return - a separate question, we, alas, cannot return the inserted row without a sample,
 # since the table may contain default field values, and we did not specify them in INSERT.
 # Do the same SELECT
     my $ sql = 'SELECT * FROM'. $ table_name. '  ORDER BY '. $ F -&gt; {id}.'  DESC LIMIT 1 ';
     my $ sth = $ dbh-&gt; prepare ($ sql);  $ sth-&gt; execute ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
     my $ row = $ sth-&gt; fetchrow_hashref;
     $ sth-&gt; finish;
     return {success =&gt; 1, row =&gt; $ row};
 }
    </pre><br>  It turned out a lot of code, yes ... But if you remove the comments, it will be two times less lines ;-), but it is clear, I hope.  Essentially: again, the priority is to set the parent.  If a parent is specified and the left key is specified, the latter will be ignored in a valid tree.  So keep in mind, if you want to create a node in submission to something, and at the same time indicate its place in the list of children, then parent_id is not necessary to transfer. Use: <br>  Perl code (4) <pre> ...
 my $ tree = 1;
 # ------------------------------------------------- -------------------------------------------------- --------------------
 # INSERT
     # Record without coordinates
     my $ insert = MY :: NestedSets-&gt; insert ($ table_name, {field1 =&gt; 'row1 -'. $ tree, tr =&gt; $ tree});
         warn Dumper $ insert;
     # Record with parent
     $ insert = MY :: NestedSets-&gt; insert ($ table_name, {field1 =&gt; 'row2 -'. $ tree, pi =&gt; $ insert -&gt; {row} -&gt; {ids}, tr =&gt; $ tree});
         warn Dumper $ insert;
     # Records with left_key
     $ insert = MY :: NestedSets-&gt; insert ($ table_name, {field1 =&gt; 'row3 -'. $ tree, lk =&gt; 1, tr =&gt; $ tree});
         warn Dumper $ insert;
     $ insert = MY :: NestedSets-&gt; insert ($ table_name, {field1 =&gt; 'row4 -'. $ tree, lk =&gt; 4, tr =&gt; $ tree});
         warn Dumper $ insert;
     # Incorrect settings
     $ insert = MY :: NestedSets-&gt; insert ($ table_name, {field1 =&gt; 'row5 -'. $ tree, pi =&gt; 1000, tr =&gt; $ tree});
         warn Dumper $ insert;
     $ insert = MY :: NestedSets-&gt; insert ($ table_name, {field1 =&gt; 'row6 -'. $ tree, lk =&gt; 100, tr =&gt; $ tree});
         warn Dumper $ insert;
 ...
    </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Node change </h4><br>  In addition to changing the tree structure itself (if necessary), changes to other fields will also be applied, as needed. <br>  Perl code (5) <pre> sub update {
 # We distribute the incoming data in places, well, and, accordingly, we check if we have enough
     shift if $ _ [0] &amp;&amp; ($ _ [0] eq __PACKAGE__ || (ref $ _ [0] &amp;&amp; ref $ _ [0] eq __PACKAGE__));
     my ($ table_name, $ new) = @_;
     return {success =&gt; 0, error =&gt; 'Bad income data!'} unless $ dbh &amp;&amp; $ table_name &amp;&amp; $ new &amp;&amp; ref $ new &amp;&amp; ref $ new eq 'HASH';
 # We find that for the table and take its additional attributes and synonyms of the fields
     my $ table = $ tables -&gt; {$ table_name} ||  $ tables -&gt; {default};
     my $ f = $ table -&gt; {fields};
     return {success =&gt; 0, error =&gt; 'Bad income data!'} unless $ new -&gt; {$ f -&gt; {id}};
 # Remove fields that can not be changed independently
     delete $ new -&gt; {$ f -&gt; {right_key}};
     delete $ new -&gt; {$ f -&gt; {tree}};
     delete $ new -&gt; {$ f -&gt; {level}};
     my $ tmp_left_key = $ new -&gt; {$ f -&gt; {left_key}};
     my $ result_flags = {it_is_moving =&gt; undef};
 # Further dilemma.  To accept the changes, we need to have the raw data.
 # In this case, we don‚Äôt know what source data we had, and what fields really changed,
 # therefore we do a selection of our variable node
     my $ sql = 'SELECT * FROM'. $ table_name. '  WHERE '. $ F -&gt; {id}.'  = '. $ new -&gt; {$ f -&gt; {id}};
     my $ sth = $ dbh-&gt; prepare ($ sql);  $ sth-&gt; execute ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
     my $ old = $ sth-&gt; fetchrow_hashref;
     $ sth-&gt; finish;
     return {success =&gt; 0, error =&gt; 'No old unit!'} unless $ old;
 # Calculate new node coordinates
 # Determine keys if we have a parent node changed
     if (defined $ new -&gt; {$ f -&gt; {parent_id}} &amp;&amp; $ new -&gt; {$ f -&gt; {parent_id}}! = $ old -&gt; {$ f -&gt; {parent_id}}) {
         if ($ new -&gt; {$ f -&gt; {parent_id}}&gt; 0) {
             my $ sql = 'SELECT'.
                             ($ table -&gt; {multi}? $ f -&gt; {tree}. 'AS tree,': '').
                             $ f -&gt; {right_key}. '  AS left_key, '.
                             $ f -&gt; {level}. '  + 1 AS level '.
                      'FROM'. $ Table_name.
                      'WHERE'. $ F -&gt; {id}. '  = '. $ new -&gt; {$ f -&gt; {parent_id}};
 # That would be clear, this is a request (in square brackets is not a mandatory expression):
 # SELECT [tree AS tree,] right_key AS left_key, level + 1 AS level FROM $ table_name WHERE id = $ parent_id;
             my $ sth = $ dbh-&gt; prepare ($ sql);  $ sth-&gt; execute ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
             my $ row = $ sth-&gt; fetchrow_hashref ();
             $ sth-&gt; finish;
 # Parent node found, means override key values
             if ($ row) {
                 $ new -&gt; {$ f -&gt; {tree}} = $ row -&gt; {tree} if $ table -&gt; {multi};
                 $ new -&gt; {$ f -&gt; {left_key}} = $ row -&gt; {left_key};
                 $ new -&gt; {$ f -&gt; {level}} = $ row -&gt; {level};
                 $ result_flags -&gt; {it_is_moving} = 1;
             } else {
 # Parent node not found, then parent_id is left, reset it
                 $ new -&gt; {$ f -&gt; {parent_id}} = $ old -&gt; {$ f -&gt; {parent_id}};
             }
         } else {
 # Transfer to the top level
 # It's all simple, determine the maximum right key and enjoy
             my $ sql = 'SELECT MAX ('. $ f -&gt; {right_key}. ') + 1 AS left_key
                 FROM '. $ Table_name.
                 ($ table -&gt; {multi}? 'WHERE'. $ f -&gt; {tree}. '='. $ old -&gt; {$ f -&gt; {tree}: '');
 # Request is readable:
 # SELECT MAX (right_key) + 1 AS left_key,
 # FROM $ table_name
 # [WHERE tree = $ tree];
             my $ sth = $ dbh-&gt; prepare ($ sql);  $ sth-&gt; execute ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
             my $ row = $ sth-&gt; fetchrow_hashref ();
             $ sth-&gt; finish;
             $ new -&gt; {$ f -&gt; {left_key}} = $ row -&gt; {left_key};
             $ new -&gt; {$ f -&gt; {parent_id}} = 0;
             $ new -&gt; {$ f -&gt; {level}} = 0;
         }
     }
 # Determine the keys if we have the left key set but the parent node is not specified, or not found
     if ($ tmp_left_key &amp;&amp; $ new -&gt; {$ f -&gt; {left_key}} &amp;&amp; # left_key was specified
          $ new -&gt; {$ f -&gt; {left_key}} == $ tmp_left_key &amp;&amp; # parent_id has not changed
          $ tmp_left_key! = $ old -&gt; {$ f -&gt; {left_key}}) {# left_key changed
 # At first I wanted to use SQL :: Abstract, but I didn‚Äôt like it, describing complex queries is more difficult and longer
 # Find a node by the left or right key
         my $ sql = 'SELECT'.
                         $ f -&gt; {id}. '  AS id, '.
                         $ f -&gt; {left_key}. '  AS left_key, '.
                         $ f -&gt; {right_key}. '  AS right_key, '.
                         $ f -&gt; {level}. '  AS level, '.
                         $ f -&gt; {parent_id}. '  AS parent_id '.
                  'FROM'. $ Table_name.
                  'WHERE'.
                  ($ table -&gt; {multi}? $ f -&gt; {tree}. '='. $ old -&gt; {$ f -&gt; {tree}}. 'AND': '').
                  '('. $ f -&gt; {left_key}. '='. $ new -&gt; {$ f -&gt; {left_key}}. 'OR'.
                  $ f -&gt; {right_key}. '  = '. $ new -&gt; {$ f -&gt; {left_key}}.') LIMIT 1 ';
 # Request is readable:
 # SELECT
 # id AS id,
 # left_key AS left_key,
 # right_key AS right_key,
 # level AS level,
 # parent_id AS parent_id
 # FROM $ table_name
 # WHERE
 # [tree = $ tree AND]
 # (left_key = $ left_key OR right_key = $ left_key)
 # LIMIT 1;
         my $ sth = $ dbh-&gt; prepare ($ sql);  $ sth-&gt; execute ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
         my $ row = $ sth-&gt; fetchrow_hashref ();
         $ sth-&gt; finish;
 # We found the node by the left key, therefore, we will have a new node in front of the found one
         if ($ row &amp;&amp; $ row -&gt; {left_key} == $ new -&gt; {$ f -&gt; {left_key}}) {
             $ new -&gt; {$ f -&gt; {parent_id}} = $ row -&gt; {parent_id};
             $ new -&gt; {$ f -&gt; {level}} = $ row -&gt; {level};
 # We found the node by the right key, therefore, we will have a new node under the found
         } elsif ($ row) {
             $ new -&gt; {$ f -&gt; {parent_id}} = $ row -&gt; {id};
             $ new -&gt; {$ f -&gt; {level}} = $ row -&gt; {level} + 1;
         } else {
 # Again such a crap, indicated completely left data.  Although there is an option that we put the node the very first
 # then this is not a mistake.  But in other cases, just ignore the movement.
             $ new -&gt; {$ f -&gt; {left_key}} = $ new -&gt; {$ f -&gt; {left_key}} &amp;&amp; $ new -&gt; {$ f -&gt; {left_key}} == 1?  1: $ old -&gt; {$ f -&gt; {left_key}};
         }
     }
 # Now that we know what our left key is, we can check if we are sending inside
     if ($ new -&gt; {$ f -&gt; {left_key}}&gt; $ old -&gt; {$ f -&gt; {left_key}} &amp;&amp; $ new -&gt; {$ f -&gt; {left_key}} &lt;$ old -&gt; {$ f -&gt; {right_key}}) {
         return {success =&gt; 0, error =&gt; 'Can not move unit inside'};
     }
 # We figured out the coordinates, the only thing is, We look, and do we even have changes on the tree?
     if ($ new -&gt; {$ f -&gt; {left_key}} &amp;&amp; $ new -&gt; {$ f -&gt; {left_key}}! = $ old -&gt; {$ f -&gt; {left_key}}) {
 # Determine level and tree offsets
         my $ skew_level = $ new -&gt; {$ f -&gt; {level}} - $ old -&gt; {$ f -&gt; {level}};
         my $ skew_tree = $ old -&gt; {$ f -&gt; {right_key}} - $ old -&gt; {$ f -&gt; {left_key}} + 1;
 # Move down the tree
         if ($ new -&gt; {$ f -&gt; {left_key}}&gt; $ old -&gt; {$ f -&gt; {left_key}}) {
             my $ skew_edit = $ new -&gt; {$ f -&gt; {left_key}} - $ old -&gt; {$ f -&gt; {left_key}} - $ skew_tree;
             my $ query = 'UPDATE'. $ table_name.
                            'SET'. $ F -&gt; {left_key}. '  = CASE WHEN '. $ F -&gt; {right_key}.'  &lt;= '. $ old -&gt; {$ f -&gt; {right_key}}.'
                                      THEN '. $ F -&gt; {left_key}.'  + '. $ skew_edit.'
                                      ELSE CASE WHEN '. $ F -&gt; {left_key}.'  &gt; '. $ old -&gt; {$ f -&gt; {right_key}}.'
                                                THEN '. $ F -&gt; {left_key}.'  - '. $ skew_tree.'
                                                ELSE '. $ F -&gt; {left_key}.'
                                           END
                                END,
                     '. $ f -&gt; {level}.'  = CASE WHEN '. $ F -&gt; {right_key}.'  &lt;= '. $ old -&gt; {$ f -&gt; {right_key}}.'
                                     THEN '. $ F -&gt; {level}.'  + '. $ skew_level.'
                                     ELSE '. $ F -&gt; {level}.'
                                END,
                     '. $ f -&gt; {right_key}.'  = CASE WHEN '. $ F -&gt; {right_key}.'  &lt;= '. $ old -&gt; {$ f -&gt; {right_key}}.'
                                      THEN '. $ F -&gt; {right_key}.'  + '. $ skew_edit.'
                                      ELSE CASE WHEN '. $ F -&gt; {right_key}.'  &lt;'. $ new -&gt; {$ f -&gt; {left_key}}.'
                                                THEN '. $ F -&gt; {right_key}.'  - '. $ skew_tree.'
                                                ELSE '. $ F -&gt; {right_key}.'
                                           END
                                 END
                 WHERE
                     '. ($ table -&gt; {multi}? $ f -&gt; {tree}.' = '. $ old -&gt; {$ f -&gt; {tree}.' AND ':' ').
                      $ f -&gt; {right_key}. '  &gt; '. $ old -&gt; {$ f -&gt; {left_key}}.'  AND '.
                      $ f -&gt; {left_key}. '  &lt;'. $ new -&gt; {$ f -&gt; {left_key}}.'; ';
             $ dbh-&gt; do ($ query) ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
             $ new -&gt; {$ f -&gt; {left_key}} = $ new -&gt; {$ f -&gt; {left_key}} - $ skew_tree;
         } else {
 # Move up the tree
             my $ skew_edit = $ new -&gt; {$ f -&gt; {left_key}} - $ old -&gt; {$ f -&gt; {left_key}};
             my $ query = 'UPDATE'. $ table_name. '
                 SET
                     '. $ f -&gt; {right_key}.'  = CASE WHEN '. $ F -&gt; {left_key}.'  &gt; = '. $ old -&gt; {$ f -&gt; {left_key}}.'
                                      THEN '. $ F -&gt; {right_key}.'  + '. $ skew_edit.'
                                      ELSE CASE WHEN '. $ F -&gt; {right_key}.'  &lt;'. $ old -&gt; {$ f -&gt; {left_key}}.'
                                                THEN '. $ F -&gt; {right_key}.'  + '. $ skew_tree.'
                                                ELSE '. $ F -&gt; {right_key}.'
                                           END
                                 END,
                     '. $ f -&gt; {level}.'  = CASE WHEN '. $ F -&gt; {left_key}.'  &gt; = '. $ old -&gt; {$ f -&gt; {left_key}}.'
                                      THEN '. $ F -&gt; {level}.'  + '. $ skew_level.'
                                      ELSE '. $ F -&gt; {level}.'
                                 END,
                     '. $ f -&gt; {left_key}.'  = CASE WHEN '. $ F -&gt; {left_key}.'  &gt; = '. $ old -&gt; {$ f -&gt; {left_key}}.'
                                      THEN '. $ F -&gt; {left_key}.'  + '. $ skew_edit.'
                                      ELSE CASE WHEN '. $ F -&gt; {left_key}.'  &gt; = '. $ new -&gt; {$ f -&gt; {left_key}}.'
                                                THEN '. $ F -&gt; {left_key}.'  + '. $ skew_tree.'
                                                ELSE '. $ F -&gt; {left_key}.'
                                           END
                                 END
                 WHERE
                     '. ($ table -&gt; {multi}? $ f -&gt; {tree}.' = '. $ old -&gt; {$ f -&gt; {tree}.' AND ':' ').
                     $ f -&gt; {right_key}. '  &gt; = '. $ new -&gt; {$ f -&gt; {left_key}}.'  AND '.
                     $ f -&gt; {left_key}. '  &lt;'. $ old -&gt; {$ f -&gt; {right_key}}.'; ';
             $ dbh-&gt; do ($ query) ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
         }
     }
 # To start, leave in $ new only those fields that have really changed, and which we generally have:
     my @sets = ();
     foreach my $ key (keys% {$ new}) {
         # There is no such field
         delete $ new -&gt; {$ key}, next exists $ old -&gt; {$ key};
         # The content field has not changed
         delete $ new -&gt; {$ key}, next if $ old -&gt; {$ key} &amp;&amp; $ new -&gt; {$ key} &amp;&amp; $ new -&gt; {$ key} eq $ old -&gt; {$ key};
         # The field without content and did not change
         delete $ new -&gt; {$ key}, next if! $ old -&gt; {$ key} &amp;&amp;! $ new -&gt; {$ key};
         # ID will not change, but remove just in case
         delete $ new -&gt; {$ key}, next if $ key eq $ f -&gt; {id};
 # same, no value check
         push @sets, $ key.  '='.  (defined $ new -&gt; {$ key} &amp;&amp; $ new -&gt; {$ key} = ~ / ^ \ d + $ /? $ new -&gt; {$ key}: '"'. $ new -&gt; {$ key}. '"');
     }
 # Update modified fields
     my $ query = 'UPDATE'. $ table_name.
                    'SET'. (Join ',', @sets).
                    'WHERE'. $ F -&gt; {id}. '  = '. $ old -&gt; {$ f -&gt; {id}};
     $ dbh-&gt; do ($ query) ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
 # Again, we request a string after UPDATE, is it anyway what triggers have been updated?
     $ sql = 'SELECT * FROM'. $ table_name. '  WHERE '. $ F -&gt; {id}.'  = '. $ old -&gt; {$ f -&gt; {id}}.'  LIMIT 1 ';
     $ sth = $ dbh-&gt; prepare ($ sql);  $ sth-&gt; execute ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
     my $ row = $ sth-&gt; fetchrow_hashref;
     $ sth-&gt; finish;
     return {success =&gt; 1, row =&gt; $ row};
 }
    </pre><br>  Same priorities as during insertion.  Well, also that the walking data is also not checked for validity, keep in mind. Use: <br>  Perl code (6) <pre> # ------------------------------------------------- -------------------------------------------------- --------------------
 # UPDATE
    
     # Move down the tree
     my $ update = MY :: NestedSets-&gt; update ($ table_name, {field1 =&gt; 'row-u-1 -'. $ tree, ids =&gt; 1, lk =&gt; 10, tr =&gt; $ tree});
         warn Dumper $ update;
     # Move up the tree
     $ update = MY :: NestedSets-&gt; update ($ table_name, {field1 =&gt; 'row-u-4 -'. $ tree, ids =&gt; 6, lk =&gt; 1, tr =&gt; $ tree});
         warn Dumper $ update;
     # Change parent
     $ update = MY :: NestedSets-&gt; update ($ table_name, {field1 =&gt; 'row-u-8 -'. $ tree, ids =&gt; 2, pi =&gt; 5, tr =&gt; $ tree});
         warn Dumper $ update;
    </pre><br><br><h4>  Deleting a node </h4><br>  Immediately code, comments inside: <br>  Perl code (7) <pre> sub delete {
 # We distribute the incoming data in places, and, accordingly, we check if we have enough
     shift if $ _ [0] &amp;&amp; ($ _ [0] eq __PACKAGE__ || (ref $ _ [0] &amp;&amp; ref $ _ [0] eq __PACKAGE__));
     my ($ table_name, $ id, $ flag) = @_;
     return {success =&gt; 0, error =&gt; 'Bad income data!'} unless $ dbh &amp;&amp; $ table_name &amp;&amp; $ id;
 # We find that for the table and take its additional attributes and synonyms of the fields
     my $ table = $ tables -&gt; {$ table_name} ||  $ tables -&gt; {default};
     my $ f = $ table -&gt; {fields};
 # Since we are not limited, as in triggers, in the number and volume of transmitted parameters,
 # implementation of deletion will be double: deleting the entire branch and deleting one tree node
 # by default, delete the entire branch
     $ flag = {cascade =&gt; 'cascade', one =&gt; 'one'} -&gt; {$ flag ||  'cascade'} ||  'cascade';
 # Select the node to be deleted, and we need only 3 fields: tree, left_key and right_key
 # Although we can pass it as a parameter, but you never know, we could have changed the keys before that,
 # a tree from this crumble.
     my $ sql = 'SELECT'.
             ($ table -&gt; {multi}? $ f -&gt; {tree}. 'AS tree,': '').
             $ f -&gt; {parent_id}. '  AS parent_id, '.
             $ f -&gt; {level}. '  AS level, '.
             $ f -&gt; {left_key}. '  AS left_key, '.
             $ f -&gt; {right_key}. '  AS right_key '.
              'FROM'. $ Table_name.
              'WHERE'. $ F -&gt; {id}. '  = '. $ id;
     my $ sth = $ dbh-&gt; prepare ($ sql);  $ sth-&gt; execute ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
     my $ old = $ sth-&gt; fetchrow_hashref ();
     $ sth-&gt; finish;
     return {success =&gt; 0, error =&gt; 'No old unit!'} unless $ old;
     if ($ flag eq 'cascade') {
 # Remove branch
         my $ query = 'DELETE FROM'. $ table_name.
                    'WHERE'.
                         ($ table -&gt; {multi}? $ f -&gt; {tree}. '='. $ old -&gt; {tree}. 'AND': '').
                         $ f -&gt; {left_key}. '  &gt; = '. $ old -&gt; {left_key}.'  AND '.
                         $ f -&gt; {right_key}. '  &lt;= '. $ old -&gt; {right_key};
         $ dbh-&gt; do ($ query) ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
 # Remove the gap in the keys:
         my $ skew_tree = $ old -&gt; {right_key} - $ old -&gt; {left_key} + 1;
         $ query = 'UPDATE'. $ table_name.
                     'SET'. $ F -&gt; {left_key}. '  = CASE WHEN '. $ F -&gt; {left_key}.'  &gt; '. $ old -&gt; {left_key}.'
                                                     THEN '. $ F -&gt; {left_key}.'  - '. $ skew_tree.'
                                                     ELSE '. $ F -&gt; {left_key}.'
                                                END, '.
                             $ f -&gt; {right_key}. '  = '. $ f -&gt; {right_key}.'  - '. $ skew_tree.
                     'WHERE'.
                         ($ table -&gt; {multi}? $ f -&gt; {tree}. '='. $ old -&gt; {tree}. 'AND': '').
                         $ f -&gt; {right_key}. '  &gt; '. $ old -&gt; {right_key}.'; ';
 # Request in readable form:
 # UPDATE $ table_name
 # SET left_key = CASE WHEN left_key&gt; OLD.left_key
 # THEN left_key - $ skew_tree
 # ELSE left_key
 # END,
 # right_key = right_key - $ skew_tree
 # WHERE
 # [tree = OLD.tree AND]
 # right_key&gt; OLD.right_key;
         $ dbh-&gt; do ($ query) ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
     } else {
 # Remove the node
         my $ query = 'DELETE FROM'. $ table_name. '  WHERE '. $ F -&gt; {id}.'  = '. $ id.'  LIMIT 1 ';  it is not enough
         $ dbh-&gt; do ($ query) ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
 # Remove the gap and rebuild the subordinate branch
         $ query = 'UPDATE'. $ table_name.
                     'SET'. $ F -&gt; {left_key}. '  = CASE WHEN '. $ F -&gt; {left_key}.'  &lt;'. $ old -&gt; {left_key}.'
                                                     THEN '. $ F -&gt; {left_key}.'
                                                     ELSE CASE WHEN '. $ F -&gt; {right_key}.'  &lt;'. $ old -&gt; {right_key}.'
                                                               THEN '. $ F -&gt; {left_key}.'  - one 
                                                               ELSE '. $ F -&gt; {left_key}.'  - 2
                                                          END
                                                END, '.
                             $ f -&gt; {parent_id}. '  = CASE WHEN '. $ F -&gt; {right_key}.'  &lt;'. $ old -&gt; {right_key}.
                                                           'AND'. $ F -&gt; {level}. '  = '. $ old -&gt; {level}.'  + 1
                                                      THEN '. $ Old -&gt; {parent_id}.'
                                                      ELSE '. $ F -&gt; {parent_id}.'
                                                 END, '.
                             $ f -&gt; {level}. '  = CASE WHEN '. $ F -&gt; {right_key}.'  &lt;'. $ old -&gt; {right_key}.'
                                                  THEN '. $ F -&gt; {level}.'  - one
                                                  ELSE '. $ F -&gt; {level}.'
                                             END, '.
                             $ f -&gt; {right_key}. '  = CASE WHEN '. $ F -&gt; {right_key}.'  &lt;'. $ old -&gt; {right_key}.'
                                                      THEN '. $ F -&gt; {right_key}.'  - one 
                                                      ELSE '. $ F -&gt; {right_key}.'  - 2
                                                 END
                       WHERE '.
                             ($ table -&gt; {multi}? $ f -&gt; {tree}. '='. $ old -&gt; {tree}. 'AND': '').
                            '('. $ f -&gt; {right_key}. '&gt;'. $ old -&gt; {right_key}. 'OR
                             ('. $ f -&gt; {left_key}.'&gt; '. $ old -&gt; {left_key}.' AND '. $ f -&gt; {right_key}.' &lt;'. $ old -&gt; {right_key}.')) ; ';
 # Request in readable form:
 # UPDATE $ table_name
 # SET left_key = CASE WHEN left_key &lt;OLD.left_key
 # THEN left_key
 # ELSE CASE WHEN right_key &lt;OLD.right_key
 # THEN left_key - 1 
 # ELSE left_key - 2
 # END
 # END,
 # parent_id = CASE WHEN right_key &lt;OLD.right_key AND `level` = OLD.level + 1
 # THEN OLD.parent_id
 # ELSE parent_id
 # END,
 # `level` = CASE WHEN right_key &lt;OLD.right_key
 # THEN `level` - 1 
 # ELSE `level`
 # END,
 # right_key = CASE WHEN right_key &lt;OLD.right_key
 # THEN right_key - 1 
 # ELSE right_key - 2
 # END
 # WHERE
 # [tree = OLD.tree AND]
 # (right_key&gt; OLD.right_key OR
 # (left_key&gt; OLD.left_key AND right_key &lt;OLD.right_key));
         $ dbh-&gt; do ($ query) ||  return {success =&gt; 0, error =&gt; $ dbh-&gt; errstr};
     }
     return {sucess =&gt; 1};
 }
    </pre><br>  To be honest, I have not yet figured out what would be the right way to return as a result, although just a flag of a successful completion, it seems to me more than enough. The use of: <br>  Perl code (8) <pre>     my $ delete = MY :: NestedSets-&gt; delete ($ table_name, 2);
     $ delete = MY :: NestedSets-&gt; delete ($ table_name, 3, 'one');
     $ delete = MY :: NestedSets-&gt; delete ($ table_name, 4);
    </pre><br>  Actually that's all.  Wipe the flannel rag that would shine, and go. </div><p>Source: <a href="https://habr.com/ru/post/65495/">https://habr.com/ru/post/65495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../65483/index.html">42 floppy disks</a></li>
<li><a href="../65487/index.html">Yandex announced a test of the next update of the algorithm - Arzamas 1.2</a></li>
<li><a href="../65491/index.html">Split Stick - two in one flash drive</a></li>
<li><a href="../65492/index.html">Did not like</a></li>
<li><a href="../65493/index.html">Habr's update</a></li>
<li><a href="../65498/index.html">Overview of ways to withdraw electronic money in Russia</a></li>
<li><a href="../65499/index.html">ASUS Eee PC 1004DN - sales of the first netbook with a DVD-drive began</a></li>
<li><a href="../65501/index.html">Twitter birds</a></li>
<li><a href="../65503/index.html">Sorting a million 32-bit ints in 2 megabytes of memory on Python</a></li>
<li><a href="../65504/index.html">Transformer Headset</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>