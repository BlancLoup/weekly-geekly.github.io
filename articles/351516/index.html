<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kotlin's current development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last week, with the support of Redmadrobot SPB , the SPB Kotlin User Group hosted a meeting with Stanislav Erokhin, a developer from JetBrains. At the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kotlin's current development</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/tk/v5/ik/tkv5ikqmxu-d91g3kgs7ljsrv88.jpeg"></p><br><p>  Last week, with the support of <strong>Redmadrobot SPB</strong> , the <strong>SPB Kotlin User Group</strong> hosted a meeting with Stanislav Erokhin, a developer from JetBrains.  At the meeting, he shared information about the possibilities being developed for the next major version of Kotlin (numbered 1.3). </p><br><p>  In this article, we will summarize the material received, tell you about the plans. </p><a name="habracut"></a><br><p>  Important.  The design of all the features that will be discussed may be changed beyond recognition.  Everything below is the current plans of the team, but the developers do not give any guarantees. </p><br><p>  View the report can be on the <a href="https://www.youtube.com/watch%3Fv%3Dgwk4rdgr36E">link to YouTube</a> . </p><br><h2 id="vvedenie">  Introduction </h2><br><p>  In the upcoming major version of Kotlin (1.3), many changes are expected.  Told us only about some of them. </p><br><p>  Main directions: </p><br><ul><li>  Korutiny </li><li>  Inline classes </li><li>  Unsigned arithmetic </li><li>  Default methods for Java </li><li>  Meta-information for DFA (Data Flow Analysis) and smartcasts </li><li>  Annotations to control type inference </li><li>  SAM for Java methods </li><li>  SAM for Kotlin methods and interfaces </li><li>  Smart inference for builders </li><li>  Compiler Schema Changes </li></ul><br><h2 id="korutiny">  Korutiny </h2><br><p>  In version 1.3, the long-awaited release of Korutin in Kotlin is planned, with the result that they will move from the <em>kotlin.coroutines.experimental</em> package to <em>kotlin.coroutines</em> . </p><br><p>  Later it is planned to release the <em>support library</em> to support the existing API korutin. </p><br><h3 id="osnovnye-izmeneniya-v-korutinah">  Major Changes in the Quercines </h3><br><ul><li>  JetBrains are actively working on performance.  For example, it is planned that in the new version <em>state-machine</em> will not be generated where they are not needed.  Due to this, the number of generated objects will decrease. </li><li>  Work is underway to fully support <em>suspend</em> for <em>inline</em> functions. </li><li>  Support <em>callable reference will be added</em> for <em>suspend</em> functions. </li><li> <code>Continuation</code> interface will <code>Continuation</code> </li></ul><br><p>  At the moment, <code>Continuation</code> contains two methods that allow you to forward either a result or an error. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Continuation</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resumeWithException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exception: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  In the new version, we plan to use a typed <code>Result</code> class containing a value or error in some form, and in <code>Continuation</code> leave one <code>resume(result: Result&lt;T&gt;)</code> method <code>resume(result: Result&lt;T&gt;)</code> : </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: T? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exception: Throwable? } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Continuation</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Result</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> }</code> </pre> <br><p>  Such an implementation will make it more convenient to develop libraries for corutin, since developers will not have to perform checks before each value / error forwarding.  The API of this solution will definitely be changed, but the meaning will be preserved. </p><br><p>  Unfortunately, this solution has a problem.  For everything to work in the current Kotlin implementation, it is necessary to wrap each value in a wrapper <code>Result</code> , which leads to the creation of an extra object for each call to <code>resume</code> .  The solution to this problem will be <em>inline</em> classes. </p><br><h2 id="inline-klassy">  Inline classes </h2><br><p>  Example for <code>Result</code> : </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Result&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> T&gt;(val o: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>?) { val <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">Box</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T val <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>: Throwable? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = (o <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Box</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> } private <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Box(val <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>: Throwable)</code> </pre> <br><p>  The advantage of <em>inline</em> classes is that at runtime the object will be stored simply as <code>val o</code> , passed in the constructor, according to the example above, and the <code>exception</code> will remain in the wrapper <code>Box</code> .  This is due to the fact that errors are thrown quite rarely, and the generation of the wrapper will not affect performance.  The <code>value</code> and <code>exception</code> getters will be generated into static methods, and the wrapper itself will disappear.  This solves the problem of creating unnecessary objects when calling <code>Continuation.resume</code> . </p><br><h3 id="ogranicheniya-inline-klassov">  Inline class restrictions </h3><br><ul><li>  While it is possible to create an <em>inline</em> class with only one field, because at run time, the wrapper is erased and only the field value remains </li><li>  If <em>generics</em> are used, the <code>Result</code> will still be wrapped, since it is not known after unpacking whether the object is wrapped or returned (for example, if we use <code>List&lt;Result&gt;</code> ) </li></ul><br><h2 id="bezznakovaya-arifmetika">  Unsigned arithmetic </h2><br><p>  One of the possible consequences of the appearance of <em>inline</em> classes are <em>unsigned</em> types: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UInt</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ULong</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> l: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>) ...</code> </pre> <br><p>  The standard library for each primitive will describe the corresponding unsigned variants in which work with arithmetic operators will be implemented, as well as basic methods, such as <code>toString()</code> . </p><br><p>  Literal support and implicit conversion will also be added. </p><br><h2 id="default-metody">  Default methods </h2><br><p>  In Kotlin's interfaces, methods with a standard implementation appeared earlier than in Java. <br>  If the interface is written in Kotlin, and the implementation is in Java 8, then for methods with a standard implementation, you can use the <code>@JvmDefault</code> annotation, so that from the Java point of view this method is marked as <code>default</code> . </p><br><h2 id="metainformaciya-dlya-dfa-i-smartkastov">  Meta-information for DFA and smartkastov </h2><br><p>  Another interesting piece of development is contracts, with which you can add meta information for DFA (Data Flow Analysis) and smartkastov.  Consider an example: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { check(x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> String) println(x.length) }</code> </pre> <br><p>  The <code>check(Boolean)</code> function is passed the result of checking that <code>x</code> belongs to the <code>String</code> type.  At this level, it is not known what this function does inside, so the next line of code will cause an error (a <em>smart-cast</em> is not possible in this case).  The compiler cannot be sure that <code>x</code> is a <code>String</code> .  Contracts will help explain it to him. </p><br><p>  Here is the implementation of the <code>check</code> with the contract: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { contract { returns() implies value } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ... }</code> </pre> <br><p>  Here is added a call to the <code>contract</code> function with a rather specific syntax, which says that if this method returns a result, this result is exactly <code>true</code> .  Otherwise, an exception will be thrown. </p><br><p>  Thanks to such a contract, the compiler will be able to perform a <em>smart cast</em> for <code>x</code> , and there will be no error when calling <code>println(x.length)</code> . </p><br><p>  In addition to resolving situations with unknown types, contracts will also solve other problems.  For example: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: String run { x = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span> } println(x.length) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: ()</span></span></span></span> -&gt; R): R { contract { callsInPlace(block, EXACTLY_ONCE) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> block() }</code> </pre> <br><p>  The contract in the <code>run</code> function tells the compiler that the passed <code>block</code> will be called exactly once, the constant <code>x</code> correctly initialize and <code>x.length</code> will run without error. </p><br><p>  Contracts are used by the compiler, but do not affect the resulting compilation code.  All contracts are converted to meta-information, which informs the compiler about some assumptions in certain functions. </p><br><p>  The IDE is planning a certain highlight of contracts and autogeneration, where it will be possible. </p><br><h2 id="annotacii-dlya-upravleniya-type-inference">  Annotations to control type inference </h2><br><p>  In <em>Stdlib</em> Kotlin there are already various features that are used only inside.  Some of them are ready to share developers.  Consider the new annotations and the features they provide: </p><br><h3 id="noinfer"> <code>@NoInfer</code> </h3> <br><p>  The <code>@NoInfer</code> is designed to make <em>type inference a</em> little smarter. </p><br><p>  Suppose we want to filter a collection using the <code>filterIsInstance</code> method.  In this method, it is important to specify the type by which the filtering will be performed, but the compiler can allow the call without setting the type (trying to infer it).  If the signature uses <code>@NoInfer</code> , then a call without a type is highlighted as an error. </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Collection</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c: Collection&lt;Any&gt; print(c.filterIsInstance()) <span class="hljs-comment"><span class="hljs-comment">// print(c.filterIsInstance&lt;String&gt;()) fun &lt;R&gt; Iterable&lt;*&gt;.filterIsInstance(): List&lt;@NoInfer R&gt;</span></span></code> </pre> <br><h3 id="exact"> <code>@Exact</code> </h3> <br><p>  This annotation is very similar to <code>@NoInfer</code> .  She says that the type must be exactly equal to the specified one, that is, not a "subtype" and not a "overtype." </p><br><h3 id="onlyinputtypes"> <code>@OnlyInputTypes</code> </h3> <br><p>  This annotation indicates that only the types that the user had in the arguments or in the receiver should be <em>inference</em> results. </p><br><h2 id="sam-dlya-java-metodov">  SAM for Java methods </h2><br><p>  Another feature being developed makes it easy to work with SAM.  Consider an example: </p><br><pre> <code class="hljs cmake">//Java static void <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>(Factory f, Runnable r) interface Factory { <span class="hljs-keyword"><span class="hljs-keyword">String</span></span> produce(); } //Kotlin fun use(f: Factory) { <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>(f) { } // Factory != () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">String</span></span> }</code> </pre> <br><p>  In Java, a method is declared that accepts two functional interfaces.  It is logical that at the Kotlin level we should be able to call this method, passing both interface implementation objects and lambda expressions corresponding to the signatures of the methods of these interfaces in any combination: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-number"><span class="hljs-number">1.</span></span> test(Factory, Runnable) <span class="hljs-number"><span class="hljs-number">2.</span></span> test(Factory, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Unit) <span class="hljs-number"><span class="hljs-number">3.</span></span> test(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> String, Runnable) <span class="hljs-number"><span class="hljs-number">4.</span></span> test(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> String, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> Unit)</code> </pre> <br><p>  Now options 2. and 3. impossible.  Kotlin compiler allows only two options: accepting two interfaces and accepting two lambda. </p><br><p>  Making all 4 options possible with the current implementation of the compiler is a difficult task, but not impossible.  The new <em>type inference</em> system will support such situations.  In the environment, only one <code>fun test(Factory, Runnable)</code> function will be visible, but it will be possible to transmit both lambdas and interface implementation objects in any combination. </p><br><h2 id="sam-dlya-kotlin-metodov-i-interfeysov">  SAM for Kotlin methods and interfaces </h2><br><p>  If a method accepting the Kotlin interface is defined in Kotlin, then automatic conversion takes place (you can transfer both the interface implementation and the lambda), you must mark the interface with the <code>sam</code> keyword. </p><br><pre> <code class="hljs kotlin">sam <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predicate</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Collection</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Predicate</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Collection&lt;T&gt; { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { test { println(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> l = listOf(-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) l.filter { it &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><p>  For Java interfaces, conversion will always work. </p><br><h2 id="smart-inference-dlya-bilderov">  Smart inference for builders </h2><br><p>  Imagine that we want to write a builder: </p><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MutableList</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): List&lt;T&gt; { ... }</code> </pre> <br><p>  And we want to use it like this: </p><br><pre> <code class="hljs cs">val list = buildList { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-string"><span class="hljs-string">"one"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-string"><span class="hljs-string">"two"</span></span>) }</code> </pre> <br><p>  This is currently not possible, since type <code>T</code> not derived from calls to <code>add(String)</code> .  Therefore you have to write like this: </p><br><pre> <code class="hljs cs">val list = buildList&lt;String&gt; { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-string"><span class="hljs-string">"one"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-string"><span class="hljs-string">"two"</span></span>) }</code> </pre> <br><p>  It is planned that it will be possible to use the first option (without explicitly indicating the type). </p><br><h2 id="izmeneniya-v-sheme-kompilyatora">  Compiler Schema Changes </h2><br><p>  JetBrains is actively working on Kotlin Native.  As a result, another link in the compiler scheme appeared - <em>Back-end Internal Representation (BE IR)</em> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sr/zu/mm/srzummtuvybc0n8fvdobg3c0mme.png" width="70%"></div><br><p>  BE IR is an intermediate representation that contains all the semantics of the source code, which can be compiled for executable files of any platform, including the binary code of the system.  Now BE IR is used only in Kotlin Native, but it is planned to be used for all platforms, instead of <em>PSI</em> with additional information on semantics.  For JVM and JS, there are already prototypes, and they are being actively developed. </p><br><p>  As a result, the entire source code will be converted to BE IR, and then to target platform executable files. </p><br><h2 id="rezyume">  Summary </h2><br><p>  As it was written above, it is not known what innovations will reach the release, in what form and in which version of the language.  There are only the current plans of the Kotlin team, but the <strong>developers do not give any guarantees</strong> : </p><br><ul><li>  API Corutin Release and Finalization - 1.3 </li><li>  Inline classes - an experimental feature in 1.3 </li><li>  Unsigned arithmetic - an experimental feature in 1.3 or 1.4 </li><li>  @JvmDefault - experimental feature in 1.2.x, release in 1.3 </li><li>  Meta-information for DFA and smartkastov - partly release in 1.3 </li><li>  Annotations for type inference control - an experimental feature in 1.2.x </li><li>  New type inference engine (including SAM and Smart inference for builders) - an experimental feature in 1.3 </li></ul><br><p>  Kotlin is undoubtedly a programming language, but with the increase in the user base, the range of its application is expanding.  There are new requirements, platforms and use cases.  Old code accumulates that needs to be maintained.  The language developers understand the difficulties and problems and work with them; as a result, the new versions will make it even more convenient to use it in more situations. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351516/">https://habr.com/ru/post/351516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351504/index.html">Introduction to Angular Modules - Root Module</a></li>
<li><a href="../351506/index.html">Where worlds are created: jobs 22 game developers</a></li>
<li><a href="../351510/index.html">Rather simple and effective algorithm for recognition and tracking of movement</a></li>
<li><a href="../351512/index.html">A note about the new linux kernel interface - gpio uapi</a></li>
<li><a href="../351514/index.html">Restore Microsoft Money online features. Account authentication</a></li>
<li><a href="../351518/index.html">Listen Top 50 Developer Podcasts</a></li>
<li><a href="../351520/index.html">We count servers, workstations, licenses, spill updates and automate IT processes.</a></li>
<li><a href="../351522/index.html">We invite to MiniAiCup # 2. This time we messed up the AgarIO</a></li>
<li><a href="../351524/index.html">Koteyki against the Black Lord: statistics online NeoQUEST-2018</a></li>
<li><a href="../351526/index.html">How we lost and found cars in a 9-story car park</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>