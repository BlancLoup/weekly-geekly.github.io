<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Classic JavaScript inheritance. Parsing the implementation in Babel, BackboneJS and Ember</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will talk about classical inheritance in JavaScript, common patterns of its use, features and frequent application errors. Consider...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Classic JavaScript inheritance. Parsing the implementation in Babel, BackboneJS and Ember</h1><div class="post__text post__text-html js-mediator-article">  In this article we will talk about classical inheritance in JavaScript, common patterns of its use, features and frequent application errors.  Consider the examples of inheritance in Babel, Backbone JS and Ember JS and try to deduce from them the key principles of object-oriented inheritance to create your own implementation in EcmaScript 5. <br><br>  The article is for those who are familiar with inheritance in other languages ‚Äã‚Äãand have encountered attempts to emulate such behavior in JavaScript, as well as for those who are interested in looking under the hood of various libraries and frameworks, comparing their implementation.  It turns out that the simple <b>extend</b> function can be implemented very differently.  Often, mistakes are made (see ‚ÄúThe most common mistake‚Äù below). <br><a name="habracut"></a><br><blockquote>  This article is available in English with a short video presentation on the site <a href="https://www.todaysoftmag.com/article/2578/front-end-architecture-common-patterns-of-classical-inheritance-in-javascript">Today Software Magazine</a> </blockquote><br><br><h3>  About classical inheritance </h3><br>  Classical is understood as OOP-style inheritance.  As you know, in pure JavaScript there is no classic inheritance.  Moreover, it lacks the notion of classes.  And although the modern EcmaScript specification adds syntactic constructions for working with classes, this does not change the fact that it actually uses constructor functions and prototyping.  Therefore, this technique is often called "pseudo-classical" inheritance.  It pursues perhaps the only goal - to represent the code in the usual OOP-style. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are various inheritance techniques, in addition to the classical: functional, prototype (in its pure form), factory-made, using mixins.  The very concept of inheritance, which has gained high popularity among developers, is criticized and in many cases contrasted with a reasonable alternative - <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">composition</a> . <br><br>  Inheritance, moreover, in the classical style, is not a panacea.  Its feasibility depends on the specific situation in a particular project.  However, in this article we will not go into the question of the advantages and disadvantages of this approach, but focus on how to properly apply it. <br><br><h3>  Comparison criteria </h3><br>  So, we decided to apply OOP and classical inheritance in a language that does not support it initially.  This decision is often made in large projects by developers who are accustomed to PLO in other languages.  It is, moreover, used by many large frameworks: Backbone, Ember JS, etc, as well as the modern EcmaScript specification. <br><br><blockquote>  The best advice for applying inheritance is to use it as described in EcmaScript 6, with the keywords class, extends, constructor, etc.  If you have such an opportunity, <s>you can not read further,</s> then this is the best option in terms of code readability and performance.  All the following description will be useful for the case of using the old specification, when the project has already been started using ES5 and the transition to the new version is not available. </blockquote>  Consider some popular examples of the implementation of classical inheritance. <br><br>  Let's analyze them in five aspects: <br><br><ol><li>  Memory efficiency. </li><li>  Performance. </li><li>  Static properties and methods. </li><li>  Link to the superclass. </li><li>  Cosmetic details. </li></ol><br>  Of course, first of all, you should make sure that the template used is efficient in terms of memory and performance.  There are no special complaints regarding the examples from popular frameworks in this regard, however, in practice there are often erroneous examples leading to memory leaks and stack sprawl, as we will discuss below. <br>  The remaining listed criteria relate to usability and readability of the code. <br><br>  More ‚Äúconvenient‚Äù we will consider those implementations that are closer in syntax and functionality to classical inheritance in other languages.  So, the reference to the superclass (the keyword super) is optional, but its presence is desirable for full emulation of inheritance.  By cosmetic details we mean the general design of the code, the convenience of debugging, use with the <code>instanceof</code> operator, etc. <br><br><h3>  "_Inherits" function in Babel </h3><br>  Consider inheritance in EcmaScript 6 and what we get at the output when compiling code in ES5 using Babel. <br><br>  The following is an example of a class extension in ES6. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasicClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> staticMethod() {} <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } someMethod() {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasicClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> staticMethod() {} <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(x); } someMethod() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.someMethod(); } }</code> </pre> <br>  As you can see, the syntax is similar to other OOP languages, with the possible exception of the lack of types and access modifiers.  And this is the uniqueness of using ES6 with the compiler: we can afford a convenient syntax, and at the same time get working code on ES5 at the output.  None of the following examples can boast such syntactic simplicity, since  in them, the inheritance function is implemented immediately in finished form, without syntax transformations. <br><br>  The Babel compiler implements inheritance using a simple <code>_inherits</code> function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_inherits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subClass, superClass</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> superClass !== <span class="hljs-string"><span class="hljs-string">"function"</span></span> &amp;&amp; superClass !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">"Super expression must either be null or a function, not "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> superClass); } subClass.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(superClass &amp;&amp; superClass.prototype, { <span class="hljs-attr"><span class="hljs-attr">constructor</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: subClass, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (superClass) <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.setPrototypeOf ? <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }</code> </pre> <br>  The main point here can be reduced to this line: <br><br><pre> <code class="javascript hljs">subClass.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(superClass.prototype);</code> </pre> <br>  This call creates an object with the specified prototype.  The <code>prototype</code> property of the <code>subClass</code> constructor points to a new object, the prototype of which is the <code>prototype</code> parent class <code>superclass</code> .  Thus, this is a simple prototypal inheritance disguised as classical in the source code. <br><br>  The following line of code implements the inheritance of static class fields: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.setPrototypeOf ? <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;</code> </pre> <br>  The parent class constructor (that is, the function) becomes the prototype of the new class constructor (that is, another function).  All static properties and methods of the parent class are thus made accessible from the inheriting class.  In the absence of the <code>setPrototypeOf</code> function <code>setPrototypeOf</code> Babel provides for direct recording of the prototype into the hidden <code>__proto__</code> property - a technique that is not recommended, but suitable for extreme cases when using old browsers. <br><br>  The very recording of methods, both static and dynamic, occurs separately from the <code>_inherits</code> call <code>_inherits</code> simply copying the references into the constructor or its <code>prototype</code> .  When writing your own implementation of inheritance, you can use this example as a basis and add objects with dynamic and static fields to it as additional arguments to the <code>_inherits</code> function. <br><br>  The ‚Äúsuper‚Äù keyword is simply replaced by a direct prototype call when compiled.  For example, the call to the parent constructor from the example above is replaced by the following line: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _possibleConstructorReturn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, (DerivedClass.__proto__ || <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(DerivedClass)).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, x));</code> </pre> <br>  Babel uses many helper functions that we will not cover here.  The point is that in this call the interpreter receives the prototype of the constructor of the current class, which is just the constructor of the base class (see above), and calls it in the current context of <code>this</code> . <br><br>  In our own implementation on pure ES5, the compilation stage is not available to us, so you can add <code>_super</code> fields to the constructor and its <code>prototype</code> to have a convenient reference to the parent class, for example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subClass, superClass</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... subClass._super = superClass; subClass.prototype._super = superClass.prototype; }</span></span></code> </pre> <br><h3>  The "extend" function in Backbone JS </h3><br>  Backbone JS provides the <code>extend</code> function for extending library classes: Model, View, Collection, etc.  If you wish, you can borrow it for your own purposes.  Below is the <code>extend</code> function code from Backbone 1.3.3. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> extend = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">protoProps, staticProps</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parent = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> child; <span class="hljs-comment"><span class="hljs-comment">// The constructor function for the new subclass is either defined by you // (the "constructor" property in your `extend` definition), or defaulted // by us to simply call the parent constructor. if (protoProps &amp;&amp; _.has(protoProps, 'constructor')) { child = protoProps.constructor; } else { child = function(){ return parent.apply(this, arguments); }; } // Add static properties to the constructor function, if supplied. _.extend(child, parent, staticProps); // Set the prototype chain to inherit from `parent`, without calling // `parent`'s constructor function and add the prototype properties. child.prototype = _.create(parent.prototype, protoProps); child.prototype.constructor = child; // Set a convenience property in case the parent's prototype is needed // later. child.__super__ = parent.prototype; return child; };</span></span></code> </pre> <br>  The usage example is as follows: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyModel = Backbone.Model.extend({ <span class="hljs-attr"><span class="hljs-attr">constructor</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ;   , //   ,      Backbone.Model.apply(this, arguments); }, toJSON: function() { //  ,      ¬´__super__¬ª MyModel.__super__.toJSON.apply(this, arguments); } }, { staticMethod: function() {} });</span></span></code> </pre> <br>  This function implements the extension of the base class with the support of its own constructor and static fields.  It returns the class constructor function.  Actually inheritance is implemented by the following line, similar to the example from Babel: <br><br><pre> <code class="javascript hljs">child.prototype = _.create(parent.prototype, protoProps);</code> </pre><br>  The <code>_.create()</code> function is an analogue of <code>Object.create()</code> from ES6, implemented by the Underscore JS library.  Its second argument allows you to immediately write to the prototype the properties and methods of <code>protoProps</code> passed when you call the <code>extend</code> function. <br><br>  Inheritance of static class fields is implemented by simply copying links (or values) from the parent class and an object with static fields, passed as the second argument to the extend function, to the created constructor: <br><br><pre> <code class="javascript hljs">_.extend(child, parent, staticProps);</code> </pre><br>  Specifying a constructor is optional and is done inside the class declaration as a constructor method.  When using it, it is necessary to call the parent class constructor (as in other languages), so instead, developers more often use the <code>initialize</code> method, which is called automatically from within the parent constructor. <br><br>  The keyword "__super__" is just a handy addition, because  the parent method call all the same happens with the indication of the name of the specific method and with the transfer of the context <code>this</code> .  Without this, such a call would lead to looping in the case of a multilevel chain of inheritance.  The superclass method, whose name is usually known in the current context, can also be invoked directly, so this keyword is only an abbreviation for: <br><br><pre> <code class="javascript hljs">Backbone.Model.prototype.toJSON.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);</code> </pre><br>  In terms of code, the extension classes in Backbone are pretty succinct.  You do not have to manually create a class constructor and separately associate it with the parent class.  This convenience comes at a price - debugging difficulties.  In the browser debugger, all instances of classes inherited in this way have the same constructor name, declared within the <code>extend</code> function - ‚Äúchild‚Äù.  This drawback may seem insignificant until you come across it in practice when debugging a chain of classes, when it becomes difficult to understand which class is the object and which class it inherits from: <br><br><img src="https://habrastorage.org/webt/zb/jn/xx/zbjnxxtg4kifl1kr2_bpxp7l86s.png" alt="image"><br><br>  This chain is much more convenient to be debugged using the inheritance from Babel: <br><br><img src="https://habrastorage.org/webt/yd/kh/hd/ydkhhds_t6znqw4i9vpnpltmbpu.png" alt="image"><br><br>  Another disadvantage is that the <code>constructor</code> property is enumerable, i.e.  enumerated when traversing an instance of a class in a for-in loop.  Not significant, however, Babel took care of this, declaring the constructor with the enumeration of the necessary modifiers. <br><br><h3>  Link to the super class in Ember JS </h3><br>  Ember JS uses both the <code>inherits</code> function implemented by Babel and its own <code>extend</code> implementation, which is very complex and sophisticated, with support for mixins and so on.  There is simply not enough room to bring the code of this function in this article, which already casts doubt on its performance when used for its own needs outside the framework. <br><br>  What is of particular interest is the implementation of the ‚Äúsuper‚Äù keyword in Ember.  It allows you to call the parent method without specifying a specific method name, for example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyClass = MySuperClass.extend({ <span class="hljs-attr"><span class="hljs-attr">myMethod</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._super(x); } });</code> </pre> <br>  Note: when calling the super-class method ( <code>this._super(x)</code> ) we do not specify the name of the method.  And no code transformations occur during compilation. <br><br>  How it works?  How does Ember <code>_super</code> which method to call when accessing the <code>_super</code> universal property without code conversion?  It is all about the complex work with classes and the clever function <code>_wrap</code> , the code of which is given below: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_wrap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func, superFunc</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">superWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orig = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._super; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._super = superFunc; <span class="hljs-comment"><span class="hljs-comment">// &lt;---   var ret = func.apply(this, arguments); this._super = orig; return ret; } //      return superWrapper; }</span></span></code> </pre> <br>  When inheriting a class, Ember passes through all its methods and calls for each given wrapper function, replacing each original function with a <code>superWrapper</code> . <br><br>  Pay attention to the line marked with a comment.  In the <code>_super</code> property, a <code>_super</code> written to the parent method corresponding to the name of the method being called (the work on determining correspondences occurred at the stage of creating a class when invoking <code>extend</code> ).  Next, the original function is called, from inside of which you can access <code>_super</code> as the parent method.  Then the <code>_super</code> property <code>_super</code> assigned the original value, which allows its use in deep call chains. <br><br>  The idea is undoubtedly interesting, and it can be applied in its implementation of inheritance.  But it is important to note that all this has a negative impact on performance.  Each class method (at least, of those that override the parent method), regardless of whether the <code>_super</code> property is <code>_super</code> in it, is wrapped in a separate function.  Therefore, with a deep chain of calls to methods of the same class, a stack will grow.  This is especially critical for methods that are called regularly in a loop or when drawing the user interface.  Therefore, it can be said that this implementation is too cumbersome and does not justify the advantage obtained in the form of an abbreviated form of recording. <br><br><h3>  The most common mistake </h3><br>  One of the most common and dangerous mistakes in practice is to create an instance of the parent class when it is extended.  Here is an example of such a code, the use of which should always be avoided: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initializeX(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.runSomeBulkyCode(); } <span class="hljs-comment"><span class="hljs-comment">// ...  BasicClass  ... function SubClass() { BaseClass.apply(this, arguments); this.y = this.initializeY(); } //   SubClass.prototype = new BaseClass(); SubClass.prototype.constructor = SubClass; // ...  SubClass  ... new SubClass(); //  </span></span></code> </pre> <br>  Noticed a mistake? <br><br>  This code will work, it will allow the <i>SubClass</i> class <i>to</i> inherit the properties and methods of the parent class.  However, during the class binding through <code>prototype</code> , an instance of the parent class is created, its constructor is called, which leads to unnecessary actions, especially if the constructor does a lot of work when creating the object ( <i>runSomeBulkyCode</i> ).  So you <b>can not</b> do: <br><br><pre> <code class="javascript hljs">SubClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass();</code> </pre> <br><br>  This can lead to hard-to-find errors when properties initialized in the parent constructor ( <code>this.x</code> ) are written not to the new instance, but to the prototype of all instances of the class <i>SubClass</i> .  In addition, the same <i>BaseClass</i> constructor is then called again from the subclass constructor.  If the parent constructor requires some parameters to be called, it is hard to make such an error, but if they are not available, it is quite possible. <br><br>  Instead, create an empty object, the prototype of which is the prototype property of the parent class: <br><br><pre> <code class="javascript hljs">SubClass.prototype = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(BasicClass.prototype);</code> </pre><br><h3>  Results </h3><br>  We gave examples of the implementation of pseudo-classical inheritance in the Babel compiler (ES6-to-ES5) and in the Backbone JS, Ember JS frameworks.  Below is a comparative table of all three implementations by the criteria described earlier. <br><br><table><thead><tr><th></th><th align="center">  Babel </th><th align="center">  Backbone js </th><th align="center">  Ember js </th></tr></thead><tbody><tr><th>  Memory </th><td colspan="3" align="center">  Equivalently </td></tr><tr><th>  Performance </th><td align="center">  Higher </td><td align="center">  Average </td><td align="center">  Lower </td></tr><tr><th>  Static fields </th><td align="center">  + <i>(only in ES6) *</i> </td><td align="center">  + </td><td align="center">  - <i>(except for the internal use of inheritance from Babel)</i> </td></tr><tr><th>  Superclass reference </th><td align="center">  <code>super.methodName()</code> <i>(only in ES6)</i> </td><td align="center"> <code>Constructor.__super__.prototype <br> .methodName.apply(this)</code> </td> <td align="center"> <code>this._super()</code> </td> </tr><tr><th>  Cosmetic items </th><td align="center">  Ideal with ES6; <br>  needs some work in its own implementation under ES5 </td><td align="center">  Convenience ads;  debugging issues </td><td align="center">  Depends on the mode of inheritance;  same debugging problems as in backbone </td></tr></tbody></table>  <i>* - Babel is ideal when using ES6;</i>  <i>if you write your own implementation based on it under ES5, static fields and the link to the superclass will have to be added independently.</i> <br><br>  The performance criterion was evaluated not in absolute values, but relative to the other implementations, based on the number of operations and cycles in each variant.  In general, differences in performance are not significant, since  the extension of classes usually occurs once at the initial stage of the application and is not called again. <br><br>  All the above examples have their advantages and disadvantages, but the implementation of Babel can be considered the most practical.  As mentioned above, if possible, use the inheritance specified in EcmaScript 6 with compilation in ES5.  In the absence of such an opportunity, it is recommended to write your own implementation of the <code>extend</code> function based on an example from the Babel compiler, taking into account the comments and additions from other examples.  So inheritance can be implemented in the most flexible and appropriate way for this project. <br><br><h3>  Sources </h3><br><ol><li>  <a href="http://javascript.ru/tutorial/object/inheritance">JavaScript.ru: Inheritance</a> </li><li>  <a href="http://davidshariff.com/blog/javascript-inheritance-patterns/">David Shariff.</a>  <a href="http://davidshariff.com/blog/javascript-inheritance-patterns/">JavaScript Inheritance Patterns</a> </li><li>  <a href="https://medium.com/javascript-scene/3-different-kinds-of-prototypal-inheritance-es6-edition-32d777fa16c9">Eric Elliott.</a>  <a href="https://medium.com/javascript-scene/3-different-kinds-of-prototypal-inheritance-es6-edition-32d777fa16c9">3 Different Kinds of Prototypal Inheritance: ES6 + Edition</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">Wikipedia: Composition over inheritance</a> </li><li>  <a href="https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">Mozilla Developer Network: Object.prototype</a> </li><li>  <a href="http://backbonejs.org/">Backbone js</a> </li><li>  <a href="https://www.emberjs.com/">Ember js</a> </li><li>  <a href="https://babeljs.io/">Babel</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/353778/">https://habr.com/ru/post/353778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353766/index.html">Flash starts and wins: the future of SSD</a></li>
<li><a href="../353770/index.html">[Habra-offtopic] Maratona di Roma, or the first marathon for an IT person</a></li>
<li><a href="../353772/index.html">Tutu PHP Meetup # 1: Video Speeches</a></li>
<li><a href="../353774/index.html">How to improve the UX product? Epic Growth Story with CEO Maps.me</a></li>
<li><a href="../353776/index.html">We invite you to a workshop on React Native from the developer GeekBrains</a></li>
<li><a href="../353780/index.html">Comparison of the speed of different variants of Unity3D script interaction</a></li>
<li><a href="../353782/index.html">Video from the first Badoo PHP Meetup 04/07/2018</a></li>
<li><a href="../353784/index.html">ReactOS 0.4.8: We lured Dr. Watson</a></li>
<li><a href="../353790/index.html">Go: Good, bad, angry</a></li>
<li><a href="../353792/index.html">Final of the International Student Programming Olympiad Live</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>