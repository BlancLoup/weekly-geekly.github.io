<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIT course "Computer Systems Security". Lecture 12: "Network Security", part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Lecture course # 6.858. "Security of computer systems". Nikolai Zeldovich, James Mykens. year 2014 
 Computer S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIT course "Computer Systems Security". Lecture 12: "Network Security", part 2</h1><div class="post__text post__text-html js-mediator-article"><h3>  Massachusetts Institute of Technology.  Lecture course # 6.858.  "Security of computer systems".  Nikolai Zeldovich, James Mykens.  year 2014 </h3><br>  Computer Systems Security is a course on the development and implementation of secure computer systems.  Lectures cover threat models, attacks that compromise security, and security methods based on the latest scientific work.  Topics include operating system (OS) security, capabilities, information flow control, language security, network protocols, hardware protection and security in web applications. <br><br>  Lecture 1: "Introduction: threat models" <a href="https://habr.com/company/ua-hosting/blog/354874/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/354894/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/354896/">Part 3</a> <br>  Lecture 2: "Control of hacker attacks" <a href="https://habr.com/company/ua-hosting/blog/414505/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/416047/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/416727/">Part 3</a> <br>  Lecture 3: "Buffer overflow: exploits and protection" <a href="https://habr.com/company/ua-hosting/blog/416839/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418093/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418099/">Part 3</a> <br>  Lecture 4: "Separation of privileges" <a href="https://habr.com/company/ua-hosting/blog/418195/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418197/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418211/">Part 3</a> <br>  Lecture 5: "Where Security Errors Come From" <a href="https://habr.com/company/ua-hosting/blog/418213/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418215/">Part 2</a> <br>  Lecture 6: "Opportunities" <a href="https://habr.com/company/ua-hosting/blog/418217/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418219/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418221/">Part 3</a> <br>  Lecture 7: "Sandbox Native Client" <a href="https://habr.com/company/ua-hosting/blog/418223/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418225/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418227/">Part 3</a> <br>  Lecture 8: "Model of network security" <a href="https://habr.com/company/ua-hosting/blog/418229/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/423155/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/423423/">Part 3</a> <br>  Lecture 9: "Web Application Security" <a href="https://habr.com/company/ua-hosting/blog/424289/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/424295/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/424297/">Part 3</a> <br>  Lecture 10: "Symbolic execution" <a href="https://habr.com/company/ua-hosting/blog/425557/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/425561/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/425559/">Part 3</a> <br>  Lecture 11: "Ur / Web programming language" <a href="https://habr.com/company/ua-hosting/blog/425997/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/425999/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/426001/">Part 3</a> <br>  Lecture 12: "Network Security" <a href="https://habr.com/company/ua-hosting/blog/426325/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/427087/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/427093/">Part 3</a> <a name="habracut"></a><br><br>  <b>Student:</b> Perhaps you still have a conflict of interest problem because you could use 32 bits for the peer addresses and you have a lot of ports for each of them.  Probably, you have a conflict of ordinal numbers of all these connections that you get? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Professor: it</b> turns out that these sequence numbers are specific to the IP address and port number of the source / destination pair.  So if these are different ports, then they do not interfere with each other at all.  Specifically, ports have lower sequence numbers. <br><br><img src="https://habrastorage.org/webt/ln/rp/sm/lnrpsmdw6g-ionqcpock0lqzf-s.jpeg"><br><br>  <b>Student:</b> if the sequence numbers are global, then can not an attacker get into a connection between other clients? <br><br>  <b>Professor:</b> yes, that's a good point.  In fact, if the server increases the sequence number, for example, by 64k for each connection, you connect to the server, and then 5 more people connect to it, and here you can organize an attack.  So to some extent, you are right, it is a bit troublesome.  On the other hand, you could probably make it so that the packet from the last row of S-&gt; A would be delivered immediately before this packet in the first row of C-&gt; S.  If you send your packages one after the other, there is a good chance that they will arrive at the server also one by one. <br><br>  The server will receive S-&gt; A and respond with this sequence number (SNs).  It will be different than (SNs) in the second line, but with the sequence number immediately following it.  And then you will know exactly which sequence number (SNs) should be invested in the third packet of your sequence. <br>  Therefore, I think that this is not a very reliable way to connect to the server, it is based on assumptions.  But if you carefully arrange your packages as needed, you can easily guess the sequence.  Or maybe you try several times and you are lucky. <br><br>  <b>Student:</b> even if the numbers are generated completely randomly, you need to guess one of the 4 billion possible numbers.  It is not too much, right?  I think that within a year you can probably get into this network. <br><br>  <b>Professor:</b> yes, you are absolutely right.  You should not rely too heavily on TCP in terms of security.  Because you're right, it's only 4 billion guesses.  And you will probably be able to send a lot of packages during the day if you have a fairly fast connection. <br><br>  So here we have a kind of interesting argument about the unreliability of TCP, because we only have 32 bits.  We can not protect it.  But I think that many applications that rely sufficiently on this protocol do not even think about security at all, and this is indeed becoming a problem. <br><br>  But you are absolutely right.  In practice, you want to use some kind of encryption on top of this in order to get more serious guarantees that no one has forged your data, since you use encryption keys longer than 32 bits.  In most cases, this is still effective in preventing tampering with the TCP connection. <br><br>  Let's now see why it‚Äôs bad if people can forge TCP connections from arbitrary addresses? <br><br>  One of the reasons why this is bad is that it can influence the authorization based on the IP address when the server checks from which address the request came.  If a server decides, based on the IP address, whether to allow or deny the connection, this could potentially be a problem for the attacker who forged the connection from an arbitrary source address. <br><br>  So, one example where this was a problem, today this problem is mostly solved, it is the use of a family of r commands, such as rlogin.  It used to be that you could run something like rlogin for a computer at, say, athena.dialup.mit.edu.  And if your connection comes from the MIT host, then this rlogin command will succeed if you say: "Yes, I am Alice user on this computer, let me log in as Alice user on another computer."  And this operation will be allowed, since all the computers on the mit.edu network are trustworthy to make such statements. <br><br>  I have to say that dial-up never had this problem.  This compound used "Cerberus" from the very beginning.  But other systems, of course, had such problems.  And this is an example of using an IP address in a connection authentication mechanism when the system checks whether the client calling the server is trustworthy.  So what used to be a problem now is not.  But relying on IP still seems like a bad plan. <br><br><img src="https://habrastorage.org/webt/xp/zi/_1/xpzi_1guskiwnqi-52aokxflicq.jpeg"><br><br>  Now rlogin is no longer used, it has recently been replaced by the secure SSH shell, which is an excellent network layer protocol.  On the other hand, there are many other examples of protocols that rely on IP-based authorization.  One of them is SMTP.  When you send an email, you use SMTP to talk to some mail server in order to send messages.  To prevent spam, many SMTP servers only accept incoming messages from a specific source IP address.  For example, the Comcast mail server accepts mail only from Comcast IP addresses.  The same is true for MIT mail servers - they will only accept mail from MIT IP addresses.  But we had at least one server that did not work as it should, using IP authentication. <br><br>  Everything is not so bad here.  In the worst case, you send some spam through your mail server.  So probably, therefore, they still use rlogin, while the things that allow you to log into a random account have stopped using IP-based identification. <br><br>  So why is such an authentication mechanism a bad plan?  As an assumption, assume that some server used rlogin.  What would you do to attack?  What is wrong with this can happen? <br><br>  <b>Student:</b> an attacker can simply get into your computer, fake a user who is going to log into the network with your login, and gain access to the network. <br><br>  <b>Professor:</b> yes, mostly the attacker is hijacking the computer.  It synthesizes data that looks like a valid set of rlogin commands that say: "Log in as this user and execute this command in my Unix shell." <br><br>  You synthesize this data data (SNc +1), mount the entire attack, and send this data as if the legitimate user was interacting with the rlogin client, and then you can proceed. <br><br><img src="https://habrastorage.org/webt/8v/b-/ws/8vb-ws9vmaat0zscptpwoh8-cze.jpeg"><br><br>  Well, this is one of the reasons why you do not want your TCP sequence numbers to be guessed.  Another problem is these reset attack reset attacks.  Just as we could send a SYN packet if we know someone‚Äôs sequence number, we can also send a reset packet. <br><br>  We briefly mentioned a legal client that sends a bogus reset packet that the attacker has installed.  An attacker can also attempt to send reset packets for an existing connection, if he somehow knows that your sequence number is on that connection.  In fact, it is unclear how big the problem is. <br><br>  At some level, you must assume that all your TCP connections can be broken anyway and at any time, that is, it doesn't seem like your network is secure.  Therefore, perhaps you should expect connections to break. <br><br>  In the case when routers ‚Äútalk‚Äù with each other, this assumption is especially critical.  If you have a lot of routers that communicate with each other using some routing protocols, then there are some physical connections between them.  But on top of these physical connections, they communicate over a network protocol that works over TCP.  In fact, in each of these physical links that routers use to exchange routing information, a TCP session is started.  This uses the BGP protocol, which we'll talk about later. <br><br>  This BGP protocol uses the fact that if a TCP connection is alive, then the physical connection is alive.  So if a TCP connection is broken, the router considers that the connection is broken and begins to recalculate all of its routing tables. <br><br><img src="https://habrastorage.org/webt/v6/wj/cc/v6wjccjolqvci5pvynpn_uui-pm.jpeg"><br><br>  Therefore, if an adversary wants to do some kind of a DoS denial of service attack here, he can try to guess the sequence numbers of these routers and reset these sessions.  If a TCP session between two routers goes down, both routers assume that this connection is dead and they have to recalculate all routing tables, which causes the routes to change.  After that, the attacker can drop another connection, and so on. <br><br>  Thus, it is a somewhat disturbing attack, and not because it violates someone‚Äôs secret and so on, at least not directly, but because it does cause many access problems for other users of the system. <br><br>  <b>Student:</b> if you are an attacker and want to organize a targeted attack against a specific user, could you just keep sending requests to connect to the server on behalf of its IP address and force it to reset the connection to the server? <br><br>  <b>Professor:</b> Suppose I use Gmail and you want to prevent me from receiving any information from Gmail, so you just send the packages to my machine, pretending that they come from the Gmail server.  In this case, you must guess the correct source port and destination port numbers. <br><br>  The destination port number is probably 443, because I use HTTPS.  But the source port number will be some random 16-bit thing.  In addition, the sequence numbers will vary.  Therefore, if you do not guess the sequence number, which is in my TCP window and which is tens of kilobytes, you will not succeed. <br><br>  So you have to guess a fair amount of things.  There is no Oracle access.  You can‚Äôt just request the server's sequence number from the server.  That's the reason why that won't work either. <br><br>  So many of these problems have been fixed, including this thing based on RST, especially for BGP routers.  There were actually two funny fixes.  One really shows how you can exploit existing things or use them to fix specific problems.  It uses the property that these routers communicate only with each other, and not with anyone else on this network.  As a result, if a packet does not arrive from a router located at the other end of the connection, then this packet is discarded. <br><br>  A successful implementation of the developers of these protocols is a wonderful area in the package, which is called "lifetime", or TTL.  This is an 8-bit field that is reduced by each router to ensure that packets do not fall into an infinite loop.  The maximum TTL value is 255 and further decreases. <br><br>  So, what are these smart protocols doing?  They drop any packet with a TTL value that is not equal to 255. Because if the packet has a value of 255, then it can only come from the router on the other side of the connection.  And if an adversary tries to inject any other packet into an existing BGP connection, it will have a TTL value less than 255, because this value will be reduced by other routers along the routing path, including this router.  Therefore, this package will simply be rejected by the recipient. <br><br>  So this is one example of the smart combination of backward-compatible techniques that solve this very specific problem. <br><br><img src="https://habrastorage.org/webt/k4/ix/mo/k4ixmopv2goqdgdhy48-lh1wol4.jpeg"><br><br>  <b>Student:</b> Doesn't the bottom right router send something with a TTL of 255? <br><br>  <b>Professor:</b> this is a physical router.  And he knows that these are separate links, so he looks at both TTL and where the package came from.  So if a packet came from the top left router, it will not accept it for a TCP connection between it and the top right router. <br><br>  For the most part, these routers trust their immediate neighbors, and this process can be controlled using the AutoPath multi-path routing mechanism. <br><br>  Other fixes for BGP are to implement some form of authentication header, including the MD5 authentication header.  But in reality, the developers focused on this particular application, for which a reset attack is particularly critical. <br><br>  This problem persists today.  If there is any long-existing connection and I want to interrupt it, I just have to send a large number of RST packets, approximately hundreds of thousands, but probably not 4 billion.  Because the servers are actually somewhat vulnerable to what sequence number they take to reset. <br><br>  This can be any package in a specific window.  In this case, the attacker could break this connection, without making special efforts.  This is still a problem for which there is no really good solution. <br><br>  And the last bad thing that can happen because of the predictability of sequence numbers is the injection of data into existing connections.  Suppose we have a hypothetical protocol, similar to rlogin, which does not actually perform IP-based authentication, so you must enter your password to log in. <br><br>  The problem is that once you have entered your password, it is possible that your TCP connection is simply established and can accept arbitrary data.  So the attacker just needs to wait until one of you guys log in to your computer by entering your password. <br><br>  The attacker does not know what the password is, but as soon as you have established a TCP connection, he will immediately try to guess your sequence number and enter some data into your existing connection.  So if I can correctly guess your sequence number, it will allow me to pretend that it was not me, but you entered some command after you were correctly authenticated with a password. <br><br><img src="https://habrastorage.org/webt/ao/0n/xw/ao0nxw7zfmyfhjhmb56s6ht7l7s.jpeg"><br><br>  All this suggests why you really do not want to rely on these 32-bit sequence numbers in terms of security.  But let's see what modern TCP stacks actually do to mitigate this problem.  One approach to the problem, which we will consider in the next 2 lectures, is to implement some degree of security at the application level.  At this level, we will use cryptography to authenticate, encrypt, sign, and validate messages without special input from TCP. <br><br>  Some of the existing applications also help solve security problems or at least make it more difficult for an attacker to use these problems.  People put this into practice today, for example, in Linux and Windows, supporting different initial sequence numbers for each source / destination pair. <br><br>  Thus, most TCP SYN implementations still compute this initial ISN sequence number just as we did before.  So this is an old style isn, let's say.  And in order to actually generate a sequence number for any particular connection, we add to this old-fashioned ISN a random 32-bit offset.  That is, we add a function to it - something like a hash function or SHA-1, or something better. <br><br><img src="https://habrastorage.org/webt/lm/wp/fm/lmwpfmcij_lsb9m2hggzeic9duy.jpeg"><br><br>  This feature includes the source IP address, source port number, destination IP address, destination port number, and some secret key that only the server knows.  Thus, we create a good opportunity for any particular connection to determine the IP address and port for a source / destination pair, while retaining all the good features of this old style sequence number assignment algorithm. <br><br>  But if you have connections from different source / destination sets, then there is nothing that allows you to find out the exact value of the sequence number of another connection set.  In fact, you have to guess this key in order to calculate this value. <br><br>  I hope that the OS kernel of the server stores this key somewhere in its memory and does not give it to anyone.  This is how most TCP stacks solve today this particular problem in the area of ‚Äã‚Äãcommon 32-bit sequence numbers.  This is not too cool, but it works. <br><br>  <b>Student:</b> could you repeat that again?  What about the uniqueness of the key ... <br><br>  <b>Professor:</b> when my machine boots, or when any machine boots, it generates a random key.  Every time you reboot it, it generates a new key.  This means that each time the sequence numbers of a particular source / destination pair change with the same frequency offset.  Thus, for a given source / destination pair, the function parameters are fixed.  So you follow the sequence when the numbers evolve according to your initial sequence numbers for new compounds, varying according to a certain algorithm.  In this way, protection is provided against the injection of old packages from previous compounds into new compounds, as well as protection against the reassignment of packages. <br><br>  The only thing for which we need this serial number of the old sample is the choice of an algorithm to prevent problems with these duplicate packages.  Earlier, we considered that if you get a sequence number for a single connection A: A -&gt; S: SYN (...), then you can conclude about the sequence number for an ACK connection (SNs). <br><br><img src="https://habrastorage.org/webt/a0/w1/-x/a0w1-xenwugh56twqvkfkgzkai0.jpeg"><br><br>    ,         32-   ,     F.  ,         ,      . <br><br> <b>:</b>       ? <br><br> <b>:</b>     ,      .      F,    ,    F  ,   ,   ,       . <br><br> <b>:</b>      ,        ‚Ä¶ <br><br> <b>:</b>  ,     F  -    -,     .            -,   ,         .  , ,  ,   ,        .       ,     F     . <br><br> ,           TCP,      .          ,    ,   -  . <br><br>   ,        .   ,   TCP    ,       DNS,        .    ,  DNS   UDP ‚Äì   . UDP ‚Äî     ,      ,     .  UDP         .  ,    ,       ,        .     ,              ,       .         DNS-.       DNS? <br><br><img src="https://habrastorage.org/webt/zg/um/eo/zgumeoz-kafodeqfjnjyhkjotjs.jpeg"><br><br> ,   DNS-  C: C53 -&gt; S53     mit.edu,        53. <br><br>      S: S53 -&gt; C53       IP-,      ‚Äì  . <br><br>    ,         ,  ,     ,      .   ,      mit.edu,         . <br><br>   ,  DNS-   .     IP-,       ,    .        IP-  mit.edu  IP-.        ,     ,   ,      ,       .      ,                . <br><br><img src="https://habrastorage.org/webt/n0/f3/6e/n0f36e0r8uoipzszlz4mdtywwcm.jpeg"><br><br>   ,      ,   .           IP-. ,   ,   DNS-  .  ,       ,          IP- mit.edu. <br><br> <b>:</b>            ,    ,    ? <br><br> <b>:</b>   ,   . ,    ,    .       DNS-,    ,       .    2  .  ‚Äî    ,   16  .           ,    16 .      ID,    16 ,      . <br><br>  ,     ,        32  . ,  ,    ,          ,        . <br><br><img src="https://habrastorage.org/webt/py/ca/my/pycamyquozaz7jj41b01zovow7q.jpeg"><br><br>  ,    ,         . <br><br>  ,         DNS    DNS   .  ,          ,  DNS     . ,  DNS SEC,       .  ,         ,  ,   DNS-     .    ,  ,        . <br><br>           origin.  DNS    ,       IP-,  : ‚Äû,     ‚Äú.  ,     ,   ,     ,     ,     ,    .      ,        ,        ? <br><br>  ,    ‚Äì    DNS- ,     . , ,   .    -,    DNS-,    .   ,    DNS SEC,   ,         ,    DNS-   .  DNS-     , ,     ,      ‚Äì     ,      . <br><br>  DNS SEC       ,   NSEC.   ,     . , NSEC  ,     foo.mit.edu,         goo.mit.edu,          ,    . <br><br><img src="https://habrastorage.org/webt/vy/w6/a1/vyw6a1qrruintd6iwnsg8exluzs.jpeg"><br><br> ,    ,      ,    ,        ,       ,         ‚Äû,     ‚Äú. <br><br>         .       ,    foo.mit.edu -&gt; goo.mit.edu ‚Äî &gt;‚Ä¶.  : ¬ª ,    ,       gooa.mit.edu".    , ,         . <br><br>          ,       DNS          .        NSEC3,       ‚Äì -  , -  . <br><br> 52:00  <br><br>  <a href="https://habr.com/company/ua-hosting/blog/427093/">MIT course "Computer Systems Security".</a> <a href="https://habr.com/company/ua-hosting/blog/427093/"> 12: ¬´ ¬ª,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BZTWXl9QNK8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Full version of the course is available <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/">here</a> . <br><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps until December for free</b> if you pay for a period of six months, you can order <a href="https://ua-hosting.company/vpsnl">here</a> . <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/427087/">https://habr.com/ru/post/427087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427069/index.html">Local NPM repository in 5 minutes with its packages and caching</a></li>
<li><a href="../427075/index.html">History of one development</a></li>
<li><a href="../427077/index.html">Laplace Blur - Is it possible to blur Laplace instead of Gauss, how many times is it faster, and is it worth the loss of 1/32 accuracy</a></li>
<li><a href="../427079/index.html">NetApp Insight 2018</a></li>
<li><a href="../427081/index.html">Criteria of the human mind, from the point of view of one programmer</a></li>
<li><a href="../427091/index.html">Numerical test of abc hypothesis (yes, the one)</a></li>
<li><a href="../427093/index.html">MIT course "Computer Systems Security". Lecture 12: "Network Security", part 3</a></li>
<li><a href="../427095/index.html">Antimony - CAD from a parallel world</a></li>
<li><a href="../427097/index.html">Mobile application helps to detect depression and other psychological problems at the earliest stages.</a></li>
<li><a href="../427101/index.html">Google plans to charge mobile device manufacturers up to $ 40 for each device sold.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>