<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL Partitioning - What? What for? How?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unfortunately, not many people actively use the table partitioning feature in PostgreSQL. In my opinion, it is very worthy of her talks in his work Hu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL Partitioning - What? What for? How?</h1><div class="post__text post__text-html js-mediator-article">  <i>Unfortunately, not many people actively use the table partitioning feature in PostgreSQL.</i>  <i>In my opinion, it is very worthy of her talks in his work Hubert Lubaczewski ( <a href="http://www.depesz.com/2015/06/07/partitioning-what-why-how/">depesz.com</a> ).</i>  <i>I offer you another translation of his article!</i> <br><img src="https://habrastorage.org/files/030/c86/70f/030c8670f3c74df587363c6855546fea.png"><br>  Recently, I noticed that more and more often I come across case studies where partitioning could be used.  And although, theoretically, most people know about its existence, in fact, this feature is not well understood, and some are even afraid of it. <br><br>  So I will try to explain to the best of my knowledge and capabilities, what it is, why it should be used and how to do it. <br><a name="habracut"></a><br>  As you probably know, there are tables in PostgreSQL, and there are data in the tables.  Sometimes it's just a few lines, and sometimes it's billions. <br><br>  Partitioning is a method of dividing large (based on the number of records, not columns) tables into many small ones.  And it is desirable that this happens in a transparent way for the application. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of the rarely used features of PostgreSQL is the fact that it is an object-relational database.  And ‚Äúobject‚Äù is a keyword here, because objects (or, rather, classes) know what is called ‚Äúinheritance‚Äù.  This is what is used for partitioning. <br><br>  Let's see what it is about. <br><br>  I will create a regular users table: <br><br><pre><code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">serial</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, username <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, created_on timestamptz <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, last_logged_on timestamptz <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> );</code> </pre> <br>  Now, for completeness, let's add a few lines and an additional index: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> (username, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>, created_on, last_logged_on) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> random_string( (random() * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">5</span></span>)::int4), random_string( <span class="hljs-number"><span class="hljs-number">20</span></span> ), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'2 years'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * random(), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'2 years'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * random() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>); $ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> newest_users <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> (created_on);</code> </pre><br>  So, we have a test table: <br><br><pre> <code class="sql hljs">$ \d Table "public.users" Column | Type | Modifiers <span class="hljs-comment"><span class="hljs-comment">----------------+--------------------------+---------------------------------------------------- id | integer | not null default nextval('users_id_seq'::regclass) username | text | not null password | text | created_on | timestamp with time zone | not null last_logged_on | timestamp with time zone | not null Indexes: "users_pkey" PRIMARY KEY, btree (id) "users_username_key" UNIQUE CONSTRAINT, btree (username) "newest_users" btree (created_on)</span></span></code> </pre><br>  With some random data: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; id | username | password | created_on | last_logged_on <span class="hljs-comment"><span class="hljs-comment">----+----------+----------------------+-------------------------------+------------------------------- 1 | ityfce3 | 2ukgbflj_l2ndo3vilt2 | 2015-01-02 16:56:41.346113+01 | 2015-04-15 12:34:58.318913+02 2 | _xg_pv | u8hy20aifyblg9f3_rf2 | 2014-09-27 05:41:05.317313+02 | 2014-08-07 14:46:14.197313+02 3 | uvi1wo | h09ae85v_f_cx0gf6_8r | 2013-06-17 18:48:44.389313+02 | 2014-06-03 06:53:49.640513+02 4 | o6rgs | vzbrkwhnsucxco5pjep0 | 2015-01-30 11:33:25.150913+01 | 2013-11-05 07:18:47.730113+01 5 | nk61jw77 | lidk_mnpe_olffmod7ed | 2014-06-15 07:18:34.597313+02 | 2014-03-21 17:42:44.763713+01 6 | 3w326_2u | pyoqg87feemojhql7jrn | 2015-01-20 05:41:54.133313+01 | 2014-09-07 20:33:23.682113+02 7 | m9rk9mnx | 6pvt94s6ol46kn0yl62b | 2013-07-17 15:13:36.315713+02 | 2013-11-12 10:53:06.123713+01 8 | adk6c | egfp8re0z492e6ri8urz | 2014-07-23 11:41:11.883713+02 | 2013-10-22 07:19:36.200513+02 9 | rsyaedw | ond0tie9er92oqhmdj39 | 2015-05-11 16:45:40.472513+02 | 2013-08-31 17:29:18.910913+02 10 | prlobe46 | _3br5v97t2xngcd7xz4n | 2015-01-10 20:13:29.461313+01 | 2014-05-04 06:25:56.072513+02 (10 rows)</span></span></code> </pre><br>  Now that the table is ready, I can create partitions, which means inherited tables: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_1 () inherits (<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>); $ \d users_1 Table "public.users_1" Column | Type | Modifiers <span class="hljs-comment"><span class="hljs-comment">----------------+--------------------------+---------------------------------------------------- id | integer | not null default nextval('users_id_seq'::regclass) username | text | not null password | text | created_on | timestamp with time zone | not null last_logged_on | timestamp with time zone | not null Inherits: users</span></span></code> </pre><br>  Thus, we have a new table, which has certain interesting properties: <br><br><ul><li>  it uses the same sequence as the main table for its id column; </li><li>  all columns have the same definition, including non null constraints; </li><li>  there is no primary key, no uniqueness restrictions for the user name, no index for created_on. </li></ul><br>  Let's try again, but this time with a more ‚Äúexplosive‚Äù effect: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_1; $ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_1 ( <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> all ); $ \d users_1 Table "public.users_1" Column | Type | Modifiers <span class="hljs-comment"><span class="hljs-comment">----------------+--------------------------+---------------------------------------------------- id | integer | not null default nextval('users_id_seq'::regclass) username | text | not null password | text | created_on | timestamp with time zone | not null last_logged_on | timestamp with time zone | not null Indexes: "users_1_pkey" PRIMARY KEY, btree (id) "users_1_username_key" UNIQUE CONSTRAINT, btree (username) "users_1_created_on_idx" btree (created_on)</span></span></code> </pre><br>  Now we have all the indices and restrictions, but we have lost the information about inheritance.  But we can add it later with: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_1 inherit <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>; $ \d users_1 Table "public.users_1" Column | Type | Modifiers <span class="hljs-comment"><span class="hljs-comment">----------------+--------------------------+---------------------------------------------------- id | integer | not null default nextval('users_id_seq'::regclass) username | text | not null password | text | created_on | timestamp with time zone | not null last_logged_on | timestamp with time zone | not null Indexes: "users_1_pkey" PRIMARY KEY, btree (id) "users_1_username_key" UNIQUE CONSTRAINT, btree (username) "users_1_created_on_idx" btree (created_on) Inherits: users</span></span></code> </pre><br>  We could do it in one step, but then there are various unpleasant notifications: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_1; $ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_1 ( <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> all ) inherits (<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>); NOTICE: merging column "id" <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> inherited definition <span class="hljs-keyword"><span class="hljs-keyword">NOTICE</span></span>: merging <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-string"><span class="hljs-string">"username"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> inherited definition <span class="hljs-keyword"><span class="hljs-keyword">NOTICE</span></span>: merging <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-string"><span class="hljs-string">"password"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> inherited definition <span class="hljs-keyword"><span class="hljs-keyword">NOTICE</span></span>: merging <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-string"><span class="hljs-string">"created_on"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> inherited definition <span class="hljs-keyword"><span class="hljs-keyword">NOTICE</span></span>: merging <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-string"><span class="hljs-string">"last_logged_on"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> inherited definition $ \d users_1 <span class="hljs-keyword"><span class="hljs-keyword">Table</span></span> <span class="hljs-string"><span class="hljs-string">"public.users_1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Column</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> | Modifiers <span class="hljs-comment"><span class="hljs-comment">----------------+--------------------------+---------------------------------------------------- id | integer | not null default nextval('users_id_seq'::regclass) username | text | not null password | text | created_on | timestamp with time zone | not null last_logged_on | timestamp with time zone | not null Indexes: "users_1_pkey" PRIMARY KEY, btree (id) "users_1_username_key" UNIQUE CONSTRAINT, btree (username) "users_1_created_on_idx" btree (created_on) Inherits: users</span></span></code> </pre><br>  In any case, we now have two tables - the main and the first partition. <br><br>  If I perform any action ‚Äî select / update / delete ‚Äî with users, both tables will be scanned: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------------------------------------------------------------- Append (cost=0.29..16.47 rows=2 width=66) (actual time=0.008..0.009 rows=1 loops=1) -&gt; Index Scan using users_pkey on users (cost=0.29..8.30 rows=1 width=48) (actual time=0.008..0.008 rows=1 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_1_pkey on users_1 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) Planning time: 0.327 ms Execution time: 0.031 ms (7 rows)</span></span></code> </pre><br>  But if I turn to the partition directly, the request will be executed only on it: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> users_1 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------------------------------------------------------- Index Scan using users_1_pkey on users_1 (cost=0.15..8.17 rows=1 width=84) (actual time=0.002..0.002 rows=0 loops=1) Index Cond: (id = 123) Planning time: 0.162 ms Execution time: 0.022 ms (4 rows)</span></span></code> </pre><br>  If we wanted, we could only refer to the user table without its partitions using the ONLY keyword: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------- Index Scan using users_pkey on users (cost=0.29..8.30 rows=1 width=48) (actual time=0.008..0.008 rows=1 loops=1) Index Cond: (id = 123) Planning time: 0.229 ms Execution time: 0.031 ms (4 rows)</span></span></code> </pre><br>  You may have noticed that I said that fetch / update / delete works on all partitions.  What about inserts?  The insert needs to add some data somewhere, so it always works as if ONLY was used.  Therefore, if I need to add a line to users_1, I have to do this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> users_1 ...</code> </pre><br>  It doesn‚Äôt look too good, but don‚Äôt worry, there are ways around it. <br><br>  Let's try to do real partitioning.  First we need to decide what the partitioning key will be - in other words, by which algorithm the partitions will be selected. <br><br>  There are a couple of the most obvious: <br><br><ul><li>  partition by date - for example, select partitions based on the year in which the user was created; </li><li>  partitioning by range of identifiers ‚Äî for example, the first million users, the second million users, and so on; </li><li>  partitioning on something else - for example, on the first letter of the user name. </li></ul><br>  There are a couple of other, not so often used options, like "partitioning by hash on behalf of the user." <br><br>  Why it is worth using one scheme, but not another?  Let's understand their advantages and disadvantages: <br><br><ul><li>  partitioning by date: <br><ul><li>  merits: <br><ul><li>  easy to understand; </li><li>  the number of rows in this table will be fairly stable; </li></ul><br></li><li>  limitations: <br><ul><li>  requires support - from time to time we will have to add new partitions; </li><li>  searching by username or id will require scanning all partitions; </li></ul><br></li></ul><br></li><li>  id partitioning: <br><ul><li>  merits: <br><ul><li>  easy to understand; </li><li>  the number of rows in the partition will be 100% stable; </li></ul><br></li><li>  limitations: <br><ul><li>  requires support - from time to time we will have to add new partitions; </li><li>  searching by username or id will require scanning all partitions; </li></ul><br></li></ul><br></li><li>  partitioning by first letter of username: <br><ul><li>  merits: <br><ul><li>  easy to understand; </li><li>  no support - there is a strictly defined set of partitions and we will never have to add new ones; </li></ul><br></li><li>  limitations: <br><ul><li>  the number of rows in the partitions will grow steadily; </li><li>  in some partitions there will be significantly more lines than in others (more people with nicknames starting with ‚Äút *" than with ‚Äúy *"); </li><li>  searching by id will require scanning all partitions; </li></ul><br></li></ul><br></li><li>  username hash partitioning: <br><ul><li>  merits: <br><ul><li>  no support - there is a strictly defined set of partitions and we will never have to add new ones; </li><li>  lines will be equally distributed between partitions; </li></ul><br></li><li>  limitations: <br><ul><li>  the number of rows in the partitions will grow steadily; </li><li>  searching by id will require scanning all partitions; </li><li>  searching by user name will scan only one partition, but only if additional conditions are used. </li></ul><br></li></ul><br></li></ul><br>  The last drawback of the hashed username approach is quite interesting.  Let's see what happens there. <br><br>  First I need to create more partitions: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_2 ( <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> all ); $ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_2 inherit <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>; ... $ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_10 ( <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">including</span></span> all ); $ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_10 inherit <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre><br>  Now the users table has 10 partitions: <br><br><pre> <code class="sql hljs">$ \d users Table "public.users" Column | Type | Modifiers <span class="hljs-comment"><span class="hljs-comment">----------------+--------------------------+---------------------------------------------------- id | integer | not null default nextval('users_id_seq'::regclass) username | text | not null password | text | created_on | timestamp with time zone | not null last_logged_on | timestamp with time zone | not null Indexes: "users_pkey" PRIMARY KEY, btree (id) "users_username_key" UNIQUE CONSTRAINT, btree (username) "newest_users" btree (created_on) Number of child tables: 10 (Use \d+ to list them.)</span></span></code> </pre><br>  PostgreSQL has the constraint_exclusion option.  And if you configure it to ‚Äúon‚Äù or ‚Äúpartition‚Äù, PostgreSQL will skip partitions that cannot contain matching lines. <br><br>  In my Pg, this is the default: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> constraint_exclusion; constraint_exclusion <span class="hljs-comment"><span class="hljs-comment">---------------------- partition (1 row)</span></span></code> </pre><br>  So, since all my partitions and the base table have no meaningful restrictions, so any query will scan all 11 tables at once (the main one and 10 partitions): <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------------------- Append (cost=0.29..89.98 rows=11 width=81) (actual time=0.009..0.013 rows=1 loops=1) -&gt; Index Scan using users_pkey on users (cost=0.29..8.30 rows=1 width=48) (actual time=0.007..0.007 rows=1 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_1_pkey on users_1 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_2_pkey on users_2 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_3_pkey on users_3 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_4_pkey on users_4 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_5_pkey on users_5 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_6_pkey on users_6 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_7_pkey on users_7 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_8_pkey on users_8 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_9_pkey on users_9 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_10_pkey on users_10 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (id = 123) Planning time: 1.321 ms Execution time: 0.087 ms (25 rows)</span></span></code> </pre><br>  This is not very effective, but we can put a limit. <br><br>  Suppose our partitions were formed by partisation by id, and 100,000 identifiers are stored in each partition. <br><br>  We can add a few restrictions: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_1 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>); $ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_2 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt; <span class="hljs-number"><span class="hljs-number">200000</span></span>); ... $ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_10 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">900000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>);</code> </pre><br>  Now we repeat the previous query: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------------------------------------------------------------- Append (cost=0.29..16.47 rows=2 width=66) (actual time=0.008..0.009 rows=1 loops=1) -&gt; Index Scan using users_pkey on users (cost=0.29..8.30 rows=1 width=48) (actual time=0.008..0.009 rows=1 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_1_pkey on users_1 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (id = 123) Planning time: 1.104 ms Execution time: 0.031 ms (7 rows)</span></span></code> </pre><br>  It scans only 2 tables: the main one (in which all data are now, and there are no restrictions, so it cannot be excluded) and a suitable partition. <br><br>  Great, right? <br><br>  We can easily add such partitioning conditions by username or created_on.  But look what happens when the partitioning key is more complex: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_1 <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check, <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>( hashtext(username) ) % <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>); $ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_2 <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check, <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>( hashtext(username) ) % <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>); ... $ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_10 <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check, <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>( hashtext(username) ) % <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre><br>  In case you do not know, hashtext () takes a string and returns an integer in the range from -2147483648 to 2147483647. <br>  Thanks to simple arithmetic, we know that abs (hashtext (string))% 10 will always produce a value in the range of 0..9, and is easy to calculate for any parameter. <br><br>  Does PostgreSQL know about this? <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> username = <span class="hljs-string"><span class="hljs-string">'depesz'</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------------------------------------- Append (cost=0.29..89.98 rows=11 width=81) (actual time=0.023..0.023 rows=0 loops=1) -&gt; Index Scan using users_username_key on users (cost=0.29..8.30 rows=1 width=48) (actual time=0.016..0.016 rows=0 loops=1) Index Cond: (username = 'depesz'::text) -&gt; Index Scan using users_1_username_key on users_1 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (username = 'depesz'::text) -&gt; Index Scan using users_2_username_key on users_2 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (username = 'depesz'::text) -&gt; Index Scan using users_3_username_key on users_3 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (username = 'depesz'::text) -&gt; Index Scan using users_4_username_key on users_4 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (username = 'depesz'::text) -&gt; Index Scan using users_5_username_key on users_5 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (username = 'depesz'::text) -&gt; Index Scan using users_6_username_key on users_6 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (username = 'depesz'::text) -&gt; Index Scan using users_7_username_key on users_7 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (username = 'depesz'::text) -&gt; Index Scan using users_8_username_key on users_8 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (username = 'depesz'::text) -&gt; Index Scan using users_9_username_key on users_9 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (username = 'depesz'::text) -&gt; Index Scan using users_10_username_key on users_10 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (username = 'depesz'::text) Planning time: 1.092 ms Execution time: 0.095 ms (25 rows)</span></span></code> </pre><br>  Not.  Does not know.  Essentially, PostgreSQL can only automatically exclude partitions for range-based (or equality) checks.  Nothing based on features.  Even a simple module from a number is already a search: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_1 <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check, <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> % <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>); $ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_2 <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check, <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> % <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>); ... $ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_10 <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check, <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> partition_check <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> % <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">9</span></span>); $ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------------------- Append (cost=0.29..89.98 rows=11 width=81) (actual time=0.009..0.016 rows=1 loops=1) -&gt; Index Scan using users_pkey on users (cost=0.29..8.30 rows=1 width=48) (actual time=0.009..0.009 rows=1 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_1_pkey on users_1 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_2_pkey on users_2 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_3_pkey on users_3 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_4_pkey on users_4 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_5_pkey on users_5 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_6_pkey on users_6 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_7_pkey on users_7 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_8_pkey on users_8 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_9_pkey on users_9 (cost=0.15..8.17 rows=1 width=84) (actual time=0.000..0.000 rows=0 loops=1) Index Cond: (id = 123) -&gt; Index Scan using users_10_pkey on users_10 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) Planning time: 0.973 ms Execution time: 0.086 ms (25 rows)</span></span></code> </pre><br>  It is sad.  Because partition keys based on number modules have one huge (in my opinion) advantage - a stable number of partitions.  You do not have to create them in the future, unless you decide to re-partition when you reach some higher amount of data. <br><br>  Does this mean that you cannot use complex (based on functions or modules on numbers) partitioning keys?  Not.  You can use them, but then the requests are more complex: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> % <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span> % <span class="hljs-number"><span class="hljs-number">10</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------------------------------------------------------------- Append (cost=0.29..16.48 rows=2 width=66) (actual time=0.010..0.011 rows=1 loops=1) -&gt; Index Scan using users_pkey on users (cost=0.29..8.31 rows=1 width=48) (actual time=0.010..0.010 rows=1 loops=1) Index Cond: (id = 123) Filter: ((id % 10) = 3) -&gt; Index Scan using users_4_pkey on users_4 (cost=0.15..8.17 rows=1 width=84) (actual time=0.001..0.001 rows=0 loops=1) Index Cond: (id = 123) Filter: ((id % 10) = 3) Planning time: 1.018 ms Execution time: 0.033 ms (9 rows)</span></span></code> </pre><br>  Here I added another condition, like this: <br><br><pre> <code class="sql hljs">id % 10 = 123 % 10</code> </pre><br>  PostgreSQL can rewrite it in the process of parsing an expression: <br><br><pre> <code class="sql hljs">id % 10 = 3</code> </pre><br>  because it knows that the% operator for integers is immutable.  And now, as part of the query, I have the exact partitioning key - id% 10 = 3. Thus, Pg can use only those partitions that either do not have a partitioning key (that is, the base table), or have a key corresponding to the query . <br><br>  Is it worth it to introduce additional complication - you decide. <br><br>  If you prefer not to change requests, and it doesn‚Äôt make it difficult for you to add new partitions from time to time, then you should familiarize yourself with the <a href="https://github.com/keithf4/pg_partman">PG Partition Manger</a> written by my former colleague Keith Fiske - this is a set of functions that you manually start to define partitions which you run over the crown, and it takes on the creation of new partitions for future data. <br><br>  I already mentioned the inserts, but did not explain how to get around the problem with inserts that should be added to the partitions. <br><br>  In general, this is a trigger job.  Pg_partman from Kita creates such triggers for you, but I want you to understand what is happening and not use pg_partman as a black box, but rather as an auxiliary tool that does the tedious work for you. <br><br>  Now my partitioning scheme is based on the module of the number (as far as I know, partman cannot do this), so let's write the appropriate trigger function.  It will be called when inserting data into the users table and should redirect the insert to the appropriate partition without errors.  So, we write: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> partition_for_users() <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> v_parition_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> v_parition_name := <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">'users_%s'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> + NEW.id % <span class="hljs-number"><span class="hljs-number">10</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-string"><span class="hljs-string">'INSERT INTO '</span></span> || v_parition_name || <span class="hljs-string"><span class="hljs-string">' VALUES ( ($1).* )'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NEW</span></span>; return NULL; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $$ language plpgsql;</code> </pre><br>  And now the definition of a trigger: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> partition_users <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> partition_for_users();</code> </pre><br>  Let's try to add a line: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> (username, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>, created_on, last_logged_on) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ( <span class="hljs-string"><span class="hljs-string">'depesz'</span></span>, random_string( <span class="hljs-number"><span class="hljs-number">20</span></span> ), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'2 years'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * random(), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'2 years'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * random() ); $ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> currval(<span class="hljs-string"><span class="hljs-string">'users_id_seq'</span></span>); currval <span class="hljs-comment"><span class="hljs-comment">--------- 10003 (1 row)</span></span></code> </pre><br>  Let's see if the data is visible: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> username = <span class="hljs-string"><span class="hljs-string">'depesz'</span></span>; id | username | password | created_on | last_logged_on <span class="hljs-comment"><span class="hljs-comment">-------+----------+----------------------+-------------------------------+------------------------------- 10003 | depesz | bp7zwy8k3t3a37chf1hf | 2014-10-24 02:45:51.398824+02 | 2015-02-05 18:24:57.072424+01 (1 row)</span></span></code> </pre><br>  It looks good, but where are they?  In the main table? <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> username = <span class="hljs-string"><span class="hljs-string">'depesz'</span></span>; id | username | password | created_on | last_logged_on <span class="hljs-comment"><span class="hljs-comment">----+----------+----------+------------+---------------- (0 rows)</span></span></code> </pre><br>  Not.  So maybe in the right partitions? <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> users_4 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> username = <span class="hljs-string"><span class="hljs-string">'depesz'</span></span>; id | username | password | created_on | last_logged_on <span class="hljs-comment"><span class="hljs-comment">-------+----------+----------------------+-------------------------------+------------------------------- 10003 | depesz | bp7zwy8k3t3a37chf1hf | 2014-10-24 02:45:51.398824+02 | 2015-02-05 18:24:57.072424+01</span></span></code> </pre><br>  Yes.  The trigger worked.  But this method has one drawback.  Namely - ‚ÄúRETURNING" does not work: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> (username, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>, created_on, last_logged_on) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ( <span class="hljs-string"><span class="hljs-string">'test'</span></span>, random_string( <span class="hljs-number"><span class="hljs-number">20</span></span> ), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'2 years'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * random(), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'2 years'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * random() ) <span class="hljs-keyword"><span class="hljs-keyword">returning</span></span> *; id | username | password | created_on | last_logged_on <span class="hljs-comment"><span class="hljs-comment">----+----------+----------+------------+---------------- (0 rows)</span></span></code> </pre><br>  This happens because, from the point of view of the performer, the insertion did not return anything - the trigger returned NULL. <br><br>  I have not managed to find a successful solution to this problem.  In my cases, I just prefer to get the original key value in advance, using nextval (), and then insert the finished value - so that it already exists after the insert: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nextval</span></span>(<span class="hljs-string"><span class="hljs-string">'users_id_seq'</span></span>); nextval <span class="hljs-comment"><span class="hljs-comment">--------- 10005 (1 row) $ insert into users (id, username, password, created_on, last_logged_on) values ( 10005, 'test', random_string( 20 ), now() - '2 years'::interval * random(), now() - '2 years'::interval * random() );</span></span></code> </pre><br>  To all this there is one clarification.  Routing all inserts via a trigger slows them down, because for each PG line you will need to perform another ‚Äúinsert". <br><br>  For urgent bulk inserts, the best solution would be to get them to work directly with partitions.  Therefore, for example, instead of <br><br><pre> <code class="sql hljs">COPY users FROM stdin; .... \.</code> </pre><br>  you first find out how many identifiers you need, for example, in this way: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nextval</span></span>(<span class="hljs-string"><span class="hljs-string">'users_id_seq'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br>  And then you issue the appropriate ones: <br><br><pre> <code class="sql hljs">COPY users_p1 FROM stdin; .... \. COPY users_p2 FROM stdin; .... \. ...</code> </pre><br>    ,     ,         . <br><br> ,    ,   ,    .     : ? <br><br>     :      . <br><br>    ,   users,   1   (1,000,000,000). <br><br>          ,  ,     . <br>        . <br><br>       : <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_1; $ <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_2; ... $ <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> users_10; $ <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> partition_users <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre><br>    users 10,000 .       0.020 ‚Äì      . <br><br>     : <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> (username, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>, created_on, last_logged_on) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> random_string( (random() * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">5</span></span>)::int4), random_string( <span class="hljs-number"><span class="hljs-number">20</span></span> ), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'2 years'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * random(), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'2 years'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * random() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>);</code> </pre><br>     0.025.     0.005   ,    -   110,000 ,      ,         . <br><br> ,     . ,        ,      id ‚Äì Pg      (     ,         ). <br><br>       ,     ‚Äì     -  , ,      ?    ,    ,  Pg  . <br><br>  ,      ,         ,  .     ( , vacuum, pg_reorg/pg_repack, pg_dump)       ,     .              20          ,  ,  ,    ! <br><br> ,     .      :       ,    . <br><br>    .      ,    ,   ()  . <br><br>       ,    .  ,    ,        ,    ,    ,        .   ,           ¬´¬ª . <br><br>   ,   ,      .   :     . ,       ‚Äì      . , ,    -       : ¬´      ¬ª. <br><br>   ,      ,    ?   ? <br>  Let's get a look.       pgbench  97 .   , 83 ,    pgbench_accounts,   666,600,000 . <br><br>      : <br><br><pre> <code class="sql hljs"> Table "public.pgbench_accounts" Column | Type | Modifiers <span class="hljs-comment"><span class="hljs-comment">----------+---------------+----------- aid | integer | not null bid | integer | abalance | integer | filler | character(84) | Indexes: "pgbench_accounts_pkey" PRIMARY KEY, btree (aid)</span></span></code> </pre><br>         aid,     1  666,600,000. <br><br>     ,     aid. <br><br> ,      10  ,    67 . <br><br>     ,      ?  Very simple.   pgbench  .       ,    ,       ,   pgbench. <br><br>      : <br><br><pre> <code class="sql hljs">$ while true <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> pgbench -T <span class="hljs-number"><span class="hljs-number">10</span></span> -c <span class="hljs-number"><span class="hljs-number">2</span></span> bench done <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> | tee pgbench.log</code> </pre><br>    10-       ,             . <br><br>   ,        : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> i int4; aid_min INT4; aid_max INT4; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.67</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> aid_min := (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">10000000</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; aid_max := i * 10000000; <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>(<span class="hljs-string"><span class="hljs-string">'CREATE TABLE pgbench_accounts_p_%s ( like pgbench_accounts including all )'</span></span>, i ); <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>(<span class="hljs-string"><span class="hljs-string">'ALTER TABLE pgbench_accounts_p_%s inherit pgbench_accounts'</span></span>, i); <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>(<span class="hljs-string"><span class="hljs-string">'ALTER TABLE pgbench_accounts_p_%s add constraint partitioning_check check ( aid &gt;= %s AND aid &lt;= %s )'</span></span>, i, aid_min, aid_max ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; $$;</code> </pre><br>  ,    ,   : <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgbench_accounts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> aid = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------------------------------------------------------------------------------- Append (cost=0.57..16.75 rows=2 width=224) (actual time=6.468..6.473 rows=1 loops=1) -&gt; Index Scan using pgbench_accounts_pkey on pgbench_accounts (cost=0.57..8.59 rows=1 width=97) (actual time=6.468..6.469 rows=1 loops=1) Index Cond: (aid = 123) -&gt; Index Scan using pgbench_accounts_p_1_pkey on pgbench_accounts_p_1 (cost=0.14..8.16 rows=1 width=352) (actual time=0.004..0.004 rows=0 loops=1) Index Cond: (aid = 123) Planning time: 3.475 ms Execution time: 6.497 ms (7 rows)</span></span></code> </pre><br>    -‚Äù‚Äù: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> partition_for_accounts() <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> v_parition_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> v_parition_name := <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">'pgbench_accounts_p_%s'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> + ( NEW.aid - <span class="hljs-number"><span class="hljs-number">1</span></span> ) / <span class="hljs-number"><span class="hljs-number">10000000</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-string"><span class="hljs-string">'INSERT INTO '</span></span> || v_parition_name || <span class="hljs-string"><span class="hljs-string">' VALUES ( ($1).* )'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NEW</span></span>; return NULL; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $$ language plpgsql; $ <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> partition_users <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pgbench_accounts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> partition_for_accounts();</code> </pre><br>   ,       ,     666     .     ? <br><br>    .     ,     : <br><br><ol><li>                ( ,      ). </li><li>           ,          . </li></ol><br>    ,     .        SQL. <br>    -   ,            sql,      .       :   ‚Äì  .  ,    ,     .      . <br><br>       psql ( ruby, perl, python ‚Äì  ),         ,  ,       . <br><br>  ,     : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> pgbench_accounts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> aid <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">returning</span></span> *) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> appropriate_partition <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> x;</code> </pre><br>     ‚Äì 1000,    ,    ,   ,        (666 ). <br><br>     : <br><br><pre> <code class="sql hljs">\pset format unaligned \pset tuples_only true \o /tmp/run.batch.migration.sql <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>( <span class="hljs-string"><span class="hljs-string">'with x as (DELETE FROM ONLY pgbench_accounts WHERE aid &gt;= %s AND aid &lt;= %s returning *) INSERT INTO pgbench_accounts_p_%s SELECT * FROM x;'</span></span>, i, i + <span class="hljs-number"><span class="hljs-number">999</span></span>, ( i - <span class="hljs-number"><span class="hljs-number">1</span></span> ) / <span class="hljs-number"><span class="hljs-number">10000000</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">666600000</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span> ) i; \o</code> </pre><br>      psql,    /tmp/run.batch.migration.sql,    (97 ),   666,600 ,  : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> pgbench_accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> aid &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> aid &lt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returning</span></span> *) <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pgbench_accounts_p_1 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> pgbench_accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> aid &gt;= <span class="hljs-number"><span class="hljs-number">1001</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> aid &lt;= <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returning</span></span> *) <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pgbench_accounts_p_1 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> pgbench_accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> aid &gt;= <span class="hljs-number"><span class="hljs-number">2001</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> aid &lt;= <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returning</span></span> *) <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pgbench_accounts_p_1 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> x;</code> </pre><br> ,   ,     (,   ¬´screen¬ª   ¬´tmux¬ª,    ,  ssh    ): <br><br><pre> <code class="sql hljs">$ psql -d bench -f /tmp/run.batch.migration.sql</code> </pre><br>    .            ~ 92,  ,    17   . <br><br>     7 .  Not bad. <br><br>    pgbench_accounts    ~ 83 (,     ,    pgbench,   vacuum). <br><br>    , ,      : <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> pgbench_accounts; count <span class="hljs-comment"><span class="hljs-comment">------- 0 (1 row)</span></span></code> </pre><br>    pgbench    ? <br><br>  4 : <br><br><ol><li>     . </li><li>   . </li><li>   . </li><li>   . </li></ol><br>  Results? <br><br><pre> <code class="sql hljs"> phase | min | avg | max <span class="hljs-comment"><span class="hljs-comment">---------+-----------+------------------+----------- Phase 1 | 28.662223 | 64.0359512839506 | 87.219148 Phase 2 | 21.147816 | 56.2721418360656 | 75.967217 Phase 3 | 23.868018 | 58.6375074477612 | 75.335558 Phase 4 | 5.222364 | 23.6086916565574 | 65.770852 (4 rows)</span></span></code> </pre><br> ,   .  , ,       SATA ,   SSD,      ‚Äì pgbench    ,  . <br><br>  ,    - ,  vacuum      . -,   . <br><br>      : <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">truncate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> pgbench_accounts;</code> </pre><br>  ,  ,   : <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgbench_accounts; count <span class="hljs-comment"><span class="hljs-comment">----------- 666600000 (1 row)</span></span></code> </pre><br>      -      ¬´ ¬ª. <br><br>   ,    ()   .    <a href="http://www.depesz.com/2015/04/02/waiting-for-9-5-allow-foreign-tables-to-participate-in-inheritance/">      </a> .     (        9.6)  ,      ,     . <br><br> ,     . <br><br> <i>      PostgreSQL    ?       <a href="http://pgday.ru/ru/2016/request/registration%3Futm_source%3Dhabrahabr%26utm_medium%3Dpost%26utm_campaign%3Dhabr_partitioning">PG Day'16 Russia</a>     !     <a href="http://pgday.ru/ru/2016/request/registration%3Futm_source%3Dhabrahabr%26utm_medium%3Dpost%26utm_campaign%3Dhabr_partitioning">early bird </a> ,      !</i> </div><p>Source: <a href="https://habr.com/ru/post/273933/">https://habr.com/ru/post/273933/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273919/index.html">Non-standard top events in the field of IT-security 2015</a></li>
<li><a href="../273921/index.html">The return of the prodigal hubs</a></li>
<li><a href="../273923/index.html">Adding sorting animation to jQuery UI</a></li>
<li><a href="../273929/index.html">Unique Setun based on ternary code</a></li>
<li><a href="../273931/index.html">Digest of the game industry: November</a></li>
<li><a href="../273937/index.html">Fintech and Blockchain: sum up the year and make a forecast for the next</a></li>
<li><a href="../273939/index.html">How flash memory will change the structure of data centers</a></li>
<li><a href="../273941/index.html">Servers based on Intel Xeon E3v5 processors</a></li>
<li><a href="../273943/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 26. "What's in Your Wallet?"</a></li>
<li><a href="../273945/index.html">Sberbank shares the experience of creating an application in Material Design: styles and themes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>