<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Discrete Mathematics for Freshmen: Teacher Experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I have an unusual text that is completely unrelated to machine learning (for new readers: this text is part of the blog of Surfingbird , in whic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Discrete Mathematics for Freshmen: Teacher Experience</h1><div class="post__text post__text-html js-mediator-article">  Today I have an unusual text that is completely unrelated to machine learning (for new readers: this text is part of the <a href="http://habrahabr.ru/company/surfingbird/">blog of Surfingbird</a> , in which I talked about different machine learning devices in the last few years in the annex to recommender systems).  In this post there will be almost no mathematical part, but there will be a description of a very simple program that I wrote for my students.  It is unlikely that someone will learn a lot of new content from this post, but it seems to me that the idea itself is of some value - many people simply don‚Äôt think that "it‚Äôs possible anyway."  So‚Ä¶ <br><br><a name="habracut"></a><br><br><h4>  Formulation of the problem </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this semester, I began a somewhat unusual activity: I teach <a href="http://logic.pdmi.ras.ru/~sergey/index.php%3Fpage%3Ddmhse13">discrete mathematics for freshmen</a> in the St. Petersburg branch of the Higher School of Economics;  I have been teaching for a long time, but it seems that I have never had students under the fourth or fifth year before.  Under the link you can find a summary of the course, and even that is incomplete (the course is still under way), but this is not really about that. <br><br>  I think most of the inhabitants of Habra even approximately remember what ‚Äúdiscrete mathematics is for freshmen‚Äù: propositional logic, conjunctive and disjunctive normal forms, bases of Boolean functions, binary relations, partial orders ... In general, nothing is conceptually complex, but these are all things which must be mastered very firmly, any mathematical education rests on them, and the need to consciously think about them will quickly become an unaffordable luxury.  Therefore, you need a lot of practical examples and tasks to "get a hand". <br><br>  As one of the forms of reporting, I chose the ‚Äúbig homework‚Äù: several practical examples that need to be solved.  This form has many advantages: students work at their own pace, I can also check how much you need, everything happens in writing, which is always convenient.  But there are also disadvantages;  the main disadvantage is simple - it is difficult to make and test fifty options for fifty students (there are about as many on the stream).  And if you give one option to a large group, it is clear that you will get beautifully rewritten correct answers at the output, especially considering that in such basic discrete mathematics the ‚Äúsolution course‚Äù is often simply absent (how to build the SDNF ‚Äî well, look at the truth table and write ...). <br><br>  To get around this problem, I decided to write a simple program that will generate an individual homework for each student at random.  The idea is extremely simple, but for some reason I never met her when I was a student, or in a later teaching experience - actually, that's why I am writing this post.  I will give a minimal working example, and then I will show what I got as a result. <br><br><h4>  Templates in .tex and boost :: format </h4><br><br>  The basic technology is clear - you need to make a LaTeX-blank into which to insert specific tasks for each student.  It doesn‚Äôt matter what language to do it, I am historically accustomed to writing small programs in C ++, so I‚Äôll use it here.  The easiest way to do this in C ++, which I know, is <a href="http://www.boost.org/doc/libs/1_53_0/libs/format/">boost :: format</a> : it is enough to make blanks with placeholders like% 1%,% 2%, and then you can insert anything there (boost :: format has other possibilities , but we do not need them now). <br><br>  So, we make templates.  First, the general template of the "abstract LaTeX document": <br><br><div class="spoiler">  <b class="spoiler_title">Little TeX</b> <div class="spoiler_text"><pre><code class="tex hljs"><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">documentclass</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">[a4paper]</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{article}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">usepackage</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">[utf8]</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{inputenc}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">usepackage</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{amsthm,amsmath,amsfonts, amssymb}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">usepackage</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">[english,russian]</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{babel}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">usepackage</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{concrete}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">usepackage</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{enumerate}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">usepackage</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{euler}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">usepackage</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{fullpage}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pagestyle</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{empty}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">selectlanguage</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{russian}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">begin</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{document}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">selectlanguage</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{russian}</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">%1% \end{document}</span></span></code> </pre> </div></div><br><br>  Then a specific template of the actual task - we will substitute it instead of% 1%.  I here, as promised, give a minimal example.  We will generate only one task: according to a given Boolean formula, translate it into several other forms. <br><br><div class="spoiler">  <b class="spoiler_title">Little TeX</b> <div class="spoiler_text"><pre> <code class="tex hljs">  <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hfill</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">%1%  $2013$ \hfill  %2% \section*{ } \begin{enumerate} \item     $$ \varphi = %3%: $$ \begin{enumerate}[(i)] \item   ; \item  $\varphi$        ; \item  $\varphi$    ; \item $[\ast]$  $\varphi$     $x\mid y = \lnot(x\land y)$. \end{enumerate} \pagebreak</span></span></code> </pre></div></div><br><br>  And now we just need to generate, than fill in% 3% (instead of% 1% and% 2% the student‚Äôs name and group number will be substituted).  For this you need to learn how to generate formulas.  Immediately I warn you that I am a bad programmer, and the code below probably resembles spaghetti - in principle, it works, if someone advises an elegant refactoring, I will say thank you. <br><br>  First you need to have a structure that will store different bundles and types of nodes in the formula;  for our minimal example, this is unnecessary, but I had to do another task about formulas for algebra of sets (union, intersection and symmetric differences), and I wanted to reuse the code about formula trees.  Therefore, here is a global object that stores basic information: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Globals</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> TypesNo; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> VarType; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; TypesLatex; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt; TypesArity; boost::random::uniform_int_distribution&lt;&gt; RandomNodeType; boost::random::uniform_int_distribution&lt;&gt; RandomNodeNoVar; boost::random::uniform_int_distribution&lt;&gt; RandomNodeBinary; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> VarsNo; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; VarNames; boost::random::uniform_int_distribution&lt;&gt; RandomVarType; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> current_varnum; Globals(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> types_num, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; types_latex, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt; types_arity, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> var_num, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; var_names) : TypesNo(types_num), VarType(types_num - <span class="hljs-number"><span class="hljs-number">1</span></span>), TypesLatex(types_latex), TypesArity(types_arity), RandomNodeType(<span class="hljs-number"><span class="hljs-number">0</span></span>, types_num - <span class="hljs-number"><span class="hljs-number">1</span></span>), RandomNodeNoVar(<span class="hljs-number"><span class="hljs-number">0</span></span>, types_num - <span class="hljs-number"><span class="hljs-number">2</span></span>), RandomNodeBinary(<span class="hljs-number"><span class="hljs-number">0</span></span>, types_num - <span class="hljs-number"><span class="hljs-number">3</span></span>), VarsNo(var_num), VarNames(var_names), RandomVarType(<span class="hljs-number"><span class="hljs-number">0</span></span>, var_num - <span class="hljs-number"><span class="hljs-number">1</span></span>), current_varnum(var_num - <span class="hljs-number"><span class="hljs-number">1</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> get_next_var() { current_varnum++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_varnum == VarsNo) current_varnum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current_varnum; } }; <span class="hljs-function"><span class="hljs-function">Globals </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GBoolean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">, { </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\land"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\lor"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\rightarrow"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\oplus"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\equiv"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\lnot"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\var"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }, { </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">, { </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"x"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"y"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"z"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"t"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span></span>;</code> </pre></div></div><br><br>  Here we created the ‚Äúlanguage of Boolean formulas‚Äù, which has five binary bundles (conjunction, disjunction, implication, XOR and equivalence) and one unary (negation).  The seventh type of node is a variable, it has an arity of 0. In my homework, I limited myself to the formulas of four variables: less is not enough, and more is becoming too cumbersome.  It is also convenient to write here the generators of a random type of a node, a random variable, a random binary connection (I used the distributions from <a href="http://www.boost.org/doc/libs/1_53_0/doc/html/boost_random.html">boost :: random</a> - again, very conveniently, although there is not much that is implemented, but we don‚Äôt need much now). <br><br>  This structure will be easily reused for set algebra formulas (this is just for comparison, no further GSet will be used): <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Globals </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, { </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\cap"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\cup"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\triangle"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\overline"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\\var"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }, { </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, { </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"A"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"B"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"C"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span></span>;</code> </pre></div></div><br><br>  Now create a formula class.  A Boolean formula is a tree whose leaves are variables, and the internal vertices are logical connectives.  We want to be able to generate formulas of a given depth, so we will pass to the constructor if it‚Äôs time to make this node a leaf or, on the contrary, necessarily a binary bundle.  If you need to create a random node, we will pass the type g-&gt; TypesNo.  If the node turns out to be a sheet, it needs to generate a variable (so that the variables are likely to fall into everything, we just take them in a circle - formulas, of course, are not completely random, but this is not terrible). <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BNode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Globals *glob; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> varnum; BNode * left; BNode * right; BNode(Globals *g, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> t, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> must_be_leaf = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> must_not_be_leaf = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> must_be_binary = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) : glob(g), type(t), left(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>), right(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == g-&gt;TypesNo) { <span class="hljs-comment"><span class="hljs-comment">// this means we want a random node type = must_be_leaf ? g-&gt;VarType : (must_be_binary ? g-&gt;RandomNodeBinary(gen) : (must_not_be_leaf ? g-&gt;RandomNodeNoVar(gen) : g-&gt;RandomNodeType(gen) )); } varnum = (type == g-&gt;VarType) ? g-&gt;get_next_var() : 0; } ~BNode() { if (left != NULL) delete left; if (right != NULL) delete right; } };</span></span></code> </pre></div></div><br><br>  Now we begin to fill the class BNode.  The main thing for us is that the formula is successfully printed in LaTeX: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TypeString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == glob-&gt;VarType) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> glob-&gt;VarNames[varnum]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> glob-&gt;TypesLatex[type]; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (glob-&gt;TypesArity[type] == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TypeString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (glob-&gt;TypesArity[type] == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TypeString() + <span class="hljs-string"><span class="hljs-string">"{"</span></span> + left-&gt;ToString() + <span class="hljs-string"><span class="hljs-string">"}"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> + left-&gt;ToString() + <span class="hljs-string"><span class="hljs-string">" "</span></span> + TypeString() + <span class="hljs-string"><span class="hljs-string">" "</span></span> + right-&gt;ToString() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; }</code> </pre></div></div><br><br>  In addition, you will need to be able to calculate the value of the formula on a given set of variables: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_truth_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp; vals)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left-&gt;get_truth_value(vals) &amp;&amp; right-&gt;get_truth_value(vals); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left-&gt;get_truth_value(vals) || right-&gt;get_truth_value(vals); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!left-&gt;get_truth_value(vals)) || right-&gt;get_truth_value(vals); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left-&gt;get_truth_value(vals) != right-&gt;get_truth_value(vals); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left-&gt;get_truth_value(vals) == right-&gt;get_truth_value(vals); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !left-&gt;get_truth_value(vals); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vals[varnum]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre></div></div><br><br>  Let's leave BNode class for now (we'll return to it);  now we can write a random formula generator.  We will generate a formula with a specified minimum and maximum depth (to maintain the minimum depth, we added the must_not_be_leaf field to the constructor earlier): <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BNode *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Globals &amp; g, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min_depth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max_depth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> must_be_binary = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max_depth == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; BNode *node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BNode(&amp;g, g.TypesNo, max_depth == <span class="hljs-number"><span class="hljs-number">1</span></span>, min_depth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, must_be_binary); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g.TypesArity[node-&gt;type] == <span class="hljs-number"><span class="hljs-number">1</span></span>) { node-&gt;left = generate_tree(g, min_depth, max_depth, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g.TypesArity[node-&gt;type] == <span class="hljs-number"><span class="hljs-number">2</span></span>) { node-&gt;left = generate_tree(g, min_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>, max_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>); node-&gt;right = generate_tree(g, min_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>, max_depth - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; }</code> </pre></div></div><br><br>  Everything is self-evident;  the only solution I took here was to make the unary functions (ie, negations) ‚Äúfree‚Äù, not considered for depth, otherwise the formulas would turn out to be too simple.  In addition, in the Boolean formula it is logical to prohibit putting two negatives in a row, it is meaningless;  for this we needed the must_be_binary flag in the constructor. <br><br>  And you can write a file handler with a list of students: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_one_student_file_boolean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dir, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fname, boost::format &amp; general_tmpl, boost::format &amp; problem_tmpl, boost::format &amp; solution_tmpl)</span></span></span><span class="hljs-function"> </span></span>{ BNode *node_bool; <span class="hljs-built_in"><span class="hljs-built_in">ostringstream</span></span> s; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; students = readAllLinesFromFile(dir + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + fname + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\t "</span></span> &lt;&lt; fname &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;students.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (students[i].size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">// empty line cout &lt;&lt; "\t\t[ " &lt;&lt; students[i] &lt;&lt; " ]" &lt;&lt; endl; node_bool = generate_tree(GBoolean, 2, 4); string group_string = "$" + fname + "$"; s &lt;&lt; problem_tmpl % students[i] % group_string % node_bool-&gt;ToString(); delete node_bool; } ofstream ofs(dir + "/" + fname + ".tex"); ofs &lt;&lt; general_tmpl % s.str() &lt;&lt; endl; ofs.close(); }</span></span></code> </pre></div></div><br><br>  and then main, which reads files with formats and processes files with student lists: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> students_dir = <span class="hljs-string"><span class="hljs-string">"2013"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; students_files = { <span class="hljs-string"><span class="hljs-string">"BoTR"</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ boost::<span class="hljs-function"><span class="hljs-function">format </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boolean_tpml</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( read_file_as_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"boolean_problem_minimal.tex"</span></span></span></span><span class="hljs-function"><span class="hljs-params">) )</span></span></span></span>; boost::<span class="hljs-function"><span class="hljs-function">format </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">general_tmpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( read_file_as_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"general_template.tex"</span></span></span></span><span class="hljs-function"><span class="hljs-params">) )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; students_files.size(); ++i) { process_one_student_file_boolean(students_dir, students_files[i], general_tmpl, boolean_tpml); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></div></div><br><br>  But wait, I hear the voice of the attentive reader.  It will be nonsense to turn out - I suppose, a good half of the random formulas thus generated will turn out to be trivial!  What is true is true - I don‚Äôt know about half, but even one randomly generated formula of the form \ varphi = x will considerably tarnish the reputation of our method.  Let's learn how to check this.  To do this, we simply calculate how many bundles and different variables are found in the formula, and demand that the variables meet all, and the bundles - at least two different.  Add a formula traversal to BNode: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">depth_first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BNode * n)&gt; do_with_node)</span></span></span><span class="hljs-function"> </span></span>{ do_with_node(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) left-&gt;depth_first(do_with_node); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) right-&gt;depth_first(do_with_node); }</code> </pre></div></div><br><br>  and enter the validation of the formula for reasonableness: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity_check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BNode * node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; vars_present(node-&gt;glob-&gt;VarsNo, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; connectors_present(node-&gt;glob-&gt;TypesNo, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); node-&gt;depth_first([&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BNode * n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n-&gt;type == n-&gt;glob-&gt;VarType) { vars_present[ n-&gt;varnum ] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { connectors_present[ n-&gt;type ] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> all_of( vars_present.begin(), vars_present.end(), [](<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b) {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b;} ) &amp;&amp; (accumulate(connectors_present.begin(), connectors_present.end(), <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre></div></div><br><br>  You may still want to check whether the formula is, say, always true, but I consciously decided not to do this - if a complex-looking formula suddenly turns out to be identically true, the more interesting this task will be for the student.  And obvious subformulas of the type ‚Äúx or not x‚Äù in our generator will not be obtained, because the variables are sorted out in turn, and not by chance. <br><br>  Running the resulting program on a file with a list of students, we obtain a .tex file with quite adequately executed tasks (here is an example <a href="http://logic.pdmi.ras.ru/~sergey/teaching/hsedm13/BoTR.minimal.pdf">pdf compiled from such a file</a> ). <br><br><h4>  Solutions </h4><br><br>  A skeptical reader at this place will reasonably argue: well, of course, you can generate over 9000 different tasks, but you will be tortured to check them later!  Indeed, checking each student‚Äôs truth table is an exercise for very strong-minded people, whom I do not consider myself to be.  Therefore, our program must be modified so that it can facilitate the verification process.  It won't be possible to automate it completely (students will still hand over works written in free format by hand), so it will be enough just to do the most nasty part of this work in advance. <br><br>  We get another LaTeX-template for the document with the answers: <br><br><div class="spoiler">  <b class="spoiler_title">LaTeX document template with answers</b> <div class="spoiler_text"><pre> <code class="tex hljs">{<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">footnotesize</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">subsection*</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{%1%,  %2%}</span></span></span></span>     <span class="hljs-formula"><span class="hljs-formula">$%3%$</span></span>: <span class="hljs-formula"><span class="hljs-formula">$$ %4% $$</span></span> } <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pagebreak</span></span></span></span></code> </pre></div></div><br><br>  I, again, limit myself to a minimal example ‚Äî let's just derive a truth table.  To do this, go through all the possible values ‚Äã‚Äãof the variables, calculate the truth value of the formula and beautifully draw the result in TeX.  Add two methods to the BNode class: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_counter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=v.size()<span class="hljs-number"><span class="hljs-number">-1</span></span>; i&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!v[i]) { v[i] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j=i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j&lt;v.size(); ++j) v[j] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">latex_truthtable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">ostringstream</span></span> os; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; counter(glob-&gt;VarsNo, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\\begin{array}{"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;counter.size(); ++i) os &lt;&lt; <span class="hljs-string"><span class="hljs-string">'c'</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"|c}\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;counter.size(); ++i) os &lt;&lt; glob-&gt;VarNames[i] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" &amp; "</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" \\\\\\hline\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;counter.size(); ++i) os &lt;&lt; counter[i] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" &amp; "</span></span>; os &lt;&lt; get_truth_value(counter) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\\\\\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (increment_counter(counter)); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\\end{array}\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os.str(); }</code> </pre></div></div><br><br>  and then add it to the process_one_student_file_boolean: <br><br><div class="spoiler">  <b class="spoiler_title">C ++ code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_one_student_file_boolean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dir, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fname, boost::format &amp; general_tmpl, boost::format &amp; problem_tmpl, boost::format &amp; solution_tmpl)</span></span></span><span class="hljs-function"> </span></span>{ BNode *node_bool; <span class="hljs-built_in"><span class="hljs-built_in">ostringstream</span></span> s, ssolution; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; students = readAllLinesFromFile(dir + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + fname + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\t "</span></span> &lt;&lt; fname &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;students.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (students[i].size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">// empty line cout &lt;&lt; "\t\t[ " &lt;&lt; students[i] &lt;&lt; " ]" &lt;&lt; endl; do { node_bool = generate_tree(GBoolean, 2, 4); } while (!sanity_check(node_bool)); string group_string = "$" + fname + "$"; s &lt;&lt; problem_tmpl % students[i] % group_string % node_bool-&gt;ToString(); ssolution &lt;&lt; solution_tmpl % students[i] % group_string % node_bool-&gt;ToString() % node_bool-&gt;latex_truthtable(); delete node_bool; } ofstream ofs; open_for_writing(dir + "/" + fname + ".tex", ofs); ofs &lt;&lt; general_tmpl % s.str() &lt;&lt; endl; ofs.close(); open_for_writing(dir + "/" + fname + ".sol.tex", ofs); ofs &lt;&lt; general_tmpl % ssolution.str() &lt;&lt; endl; ofs.close(); } string students_dir = "2013"; vector&lt;string&gt; students_files = { "BoTR" }; int main(int argc, char *argv[]) { boost::format boolean_tpml( read_file_as_string("boolean_problem_minimal.tex") ); boost::format solution_tpml( read_file_as_string("boolean_solution_minimal.tex") ); boost::format general_tmpl( read_file_as_string("general_template.tex") ); for (size_t i = 0; i &lt; students_files.size(); ++i) { process_one_student_file_boolean(students_dir, students_files[i], general_tmpl, boolean_tpml, solution_tpml); } return 0; }</span></span></code> </pre></div></div><br><br>  As a result, the corresponding decision file ( <a href="http://logic.pdmi.ras.ru/~sergey/teaching/hsedm13/BoTR.minimal.sol.pdf">the same example, solutions</a> ) is obtained in a pair to the task file ( <a href="http://logic.pdmi.ras.ru/~sergey/teaching/hsedm13/BoTR.minimal.pdf">example</a> ), with which it becomes much easier to check. <br><br><h4>  Conclusion </h4><br><br>  And here's the result - half a day of work, and at the exit, as many tasks as you like with ready-made answers, everything is beautifully decorated and ready to be issued to students.  If you are interested in how the real task turned out, <a href="http://logic.pdmi.ras.ru/~sergey/teaching/hsedm13/BoTR.full.pdf">here is an example of the final result</a> .  I will not post the answer file so as not to prompt the students once more - they are now solving this homework.  I think that if my teaching at the HSE continues, this program will serve me more than once;  The closest chance to apply it is tickets for the written exam in the same groups. <br><br>  PS When I was preparing an article for Habr, I found a small bug in my formula generator;  but did not correct.  Exercise for the attentive reader: what formulas, in which, in principle, there is nothing bad, my generator will never be able to generate?  (in addition to the notes on the selection of variables in order, which I have already done above) </div><p>Source: <a href="https://habr.com/ru/post/171279/">https://habr.com/ru/post/171279/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171269/index.html">How to create a new product for the electronics market. Part 1</a></li>
<li><a href="../171271/index.html">A look at the ‚Äúcomputation graph‚Äù section of the Intel Threading Building Blocks Library from the point of view of a BPMS system developer</a></li>
<li><a href="../171273/index.html">Myths of our time: genetically modified organisms. Is the devil so terrible?</a></li>
<li><a href="../171275/index.html">The main novelties of the MWC 2013 - hodgepodge</a></li>
<li><a href="../171277/index.html">Boat for checkers (part 1)</a></li>
<li><a href="../171281/index.html">Friday datamining</a></li>
<li><a href="../171287/index.html">Poll. How well do you remember your code?</a></li>
<li><a href="../171289/index.html">New zero-day vulnerability in Java browser applets</a></li>
<li><a href="../171291/index.html">ITShare # 4: Kama Sutra Retrospective</a></li>
<li><a href="../171299/index.html">Introduction to the ASP.NET Web API platform from ASP.NET MVC 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>