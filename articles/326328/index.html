<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bash scripts, part 3: command line options and keys</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bash scripts: start 
 Bash scripts, part 2: loops 
 Bash scripts, part 3: command line options and keys 
 Bash scripts, part 4: input and output 
 Bas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bash scripts, part 3: command line options and keys</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <a href="https://habrahabr.ru/company/ruvds/blog/325522/">Bash scripts: start</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/325928/">Bash scripts, part 2: loops</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326328/">Bash scripts, part 3: command line options and keys</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326594/">Bash scripts, part 4: input and output</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/326826/">Bash Scripts, Part 5: Signals, Background Tasks, Script Management</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327248/">Bash scripts, part 6: functions and library development</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327530/">Bash scripts, part 7: sed and word processing</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327754/">Bash scripts, part 8: awk data processing language</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/327896/">Bash scripts, part 9: regular expressions</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/328346/">Bash scripts, part 10: practical examples</a> <br>  <a href="https://habrahabr.ru/company/ruvds/blog/328436/">Bash scripts, part 11: expect and automate interactive utilities</a> </blockquote><br>  Having mastered the previous parts of this series of materials, you learned what bash scripts are, how to write them, how to manage the flow of program execution, how to work with files.  Today we will talk about how to add interactivity to scripts, equipping them with opportunities for receiving data from the user and for processing this data. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/326328/"><img src="https://habrastorage.org/files/803/892/bfe/803892bfe548499aa763df324d40fd01.png" alt="image"></a> <br><a name="habracut"></a><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br>  The most common way to transfer data to scripts is to use command line parameters.  Calling the script with the parameters, we give him some information with which it can work.  It looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs ruby">$ ./myscript <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre> <br>  In this example, the script passed two parameters - "10" and "20".  All this is good, but how to read the data in the script? <br><br><h2>  <font color="#3AC1EF">Reading command line parameters</font> </h2><br>  The bash shell assigns special variables, called positional parameters, to the command line parameters entered when the script is called: <br><br><ul><li>  <code>$0 ‚Äî</code> name of the script. <br></li><li>  <code>$1 ‚Äî</code> first parameter. <br></li><li>  <code>$2 ‚Äî</code> second parameter - and so on, right down to the <code>$9</code> variable, in which the ninth parameter falls. <br></li></ul><br>  Here's how to use command line parameters in a script using these variables: <br><br><pre> <code class="hljs pgsql">#!/bin/bash echo <span class="hljs-meta"><span class="hljs-meta">$0</span></span> echo <span class="hljs-meta"><span class="hljs-meta">$1</span></span> echo <span class="hljs-meta"><span class="hljs-meta">$2</span></span> echo <span class="hljs-meta"><span class="hljs-meta">$3</span></span></code> </pre> <br>  Run the script with the parameters: <br><br><pre> <code class="hljs">./myscript 5 10 15</code> </pre> <br>  This is what it will bring to the console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb5/f9f/b80/fb5f9fb80361a4083e31d7225fa3cdbf.png"></div><br>  <i><font color="#999999">Output of parameters with which the script is started</font></i> <br><br>  Note that the command line parameters are separated by spaces. <br><br>  Take a look at another example of using parameters.  Here we find the sum of the numbers passed to the script: <br><br><pre> <code class="hljs mel">#!/bin/bash total=$[ $1 + $2 ] echo The first parameter is $1. echo The second parameter is $2. echo The sum is $total.</code> </pre> <br>  Run the script and check the result of the calculation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/db1/42c/646db142c4fe6ebfc41f66b2a65534e6.png"></div><br>  <i><font color="#999999">A script that finds the sum of the numbers passed to it.</font></i> <br><br>  Command line parameters do not have to be numbers.  Scripts can also pass strings.  For example, here's the script that works with the string: <br><br><pre> <code class="hljs pgsql">#!/bin/bash echo Hello <span class="hljs-meta"><span class="hljs-meta">$1</span></span>, how <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> you <span class="hljs-keyword"><span class="hljs-keyword">do</span></span></code> </pre> <br>  Run it: <br><br><pre> <code class="hljs">./myscript Adam</code> </pre> <br>  He will bring what we expect from him. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f45/0d1/b03/f450d1b0337e0533990d1a25f2890e43.png"></div><br>  <i><font color="#999999">Script working with string parameter</font></i> <br><br>  What if the parameter contains spaces, and we need to treat it as a separate data fragment?  We believe that if you have mastered the previous parts of this guide, you already know the answer.  It consists in the use of quotes. <br><br>  If the script needs more than nine parameters, when referring to them, the number in the variable name must be enclosed in curly brackets, for example: <br><br><pre> <code class="hljs perl">${10}</code> </pre> <br><h2>  <font color="#3AC1EF">Parameter check</font> </h2><br>  If the script is called without parameters, but for the normal operation of the code, their presence is assumed, an error will occur.  Therefore, it is recommended to always check for the presence of parameters passed to the script during the call.  For example, it can be organized like this: <br><br><pre> <code class="hljs pgsql">#!/bin/bash <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ -n "$1" ] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> echo Hello <span class="hljs-meta"><span class="hljs-meta">$1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> echo "No parameters found. " fi</code> </pre> <br>  Call the script first with a parameter, and then without parameters. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8c/9ce/15f/b8c9ce15f6793d007f1d5460a7a20078.png"></div><br>  <i><font color="#999999">Calling the script that checks for the presence of command line parameters</font></i> <br><br><h2>  <font color="#3AC1EF">Parameter counting</font> </h2><br>  In the script, you can calculate the number of parameters passed to it.  The bash shell provides a special variable for this.  Namely, the <code>$#</code> variable contains the number of parameters passed to the script when invoked. <br><br>  Let's try it out: <br><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#!/bin/bash echo There were $# parameters passed.</span></span></code> </pre> <br>  Call the script. <br><br><pre> <code class="hljs">./myscript 1 2 3 4 5</code> </pre> <br>  As a result, the script will report that 5 parameters have been passed to it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b49/19f/e68/b4919fe68032df326b43cc39a88e718d.png"></div><br>  <i><font color="#999999">Counting the number of parameters in the script</font></i> <br><br>  This variable provides an unusual way to get the last parameter passed to the script, not requiring knowledge of their number.  Here's what it looks like: <br><br><pre> <code class="hljs erlang-repl">#!/bin/bash echo The last parameter was ${!#}</code> </pre> <br>  Call the script and see what it displays. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/7ed/0e7/e7f7ed0e751be4c5156ae49b7e8ea86d.png"></div><br>  <i><font color="#999999">Referring to the last parameter</font></i> <br><br><h2>  <font color="#3AC1EF">Capture all command line options</font> </h2><br>  In some cases, you need to capture all the parameters passed to the script.  To do this, you can use the variables <code>$*</code> and <code>$@</code> .  Both contain all command line parameters, which makes it possible to access what is passed to the script, without using positional parameters. <br><br>  The variable <code>$*</code> contains all parameters entered on the command line as a single ‚Äúword‚Äù. <br><br>  The variable <code>$@</code> parameters are divided into separate "words".  These parameters can be iterated in cycles. <br><br>  Consider the difference between these variables in the examples.  First, take a look at their contents: <br><br><pre> <code class="hljs smalltalk">#!/bin/bash echo <span class="hljs-comment"><span class="hljs-comment">"Using the \$* method: $*"</span></span> echo <span class="hljs-comment"><span class="hljs-comment">"-----------"</span></span> echo <span class="hljs-comment"><span class="hljs-comment">"Using the \$@ method: $@"</span></span></code> </pre> <br>  Here is the output of the script. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee1/579/f3d/ee1579f3d1c96830d6c2484f6124c89e.png"></div><br>  <i><font color="#999999">Variables $ * and $ @</font></i> <br><br>  As you can see, the output of both variables is the same.  Now we will try to go through the contents of these variables in cycles in order to see the difference between them: <br><br><pre> <code class="hljs swift">#!/bin/bash <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"$*"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"\$* Parameter #$count = $param"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"$@"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"\$@ Parameter #$count = $param"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done</code> </pre> <br>  Take a look at what the script brought to the console.  The difference between the variables is quite obvious. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bd/369/c4c/4bd369c4cecd29ae7b221dcdbf669fbb.png"></div><br>  <i><font color="#999999">Parsing $ * and $ @ variables in a loop</font></i> <br><br>  The <code>$*</code> variable contains all parameters passed to the script as a single piece of data, while in the <code>$@</code> variable they are represented by independent values.  Which variable to use depends on what exactly is needed in a particular scenario. <br><br><h2>  <font color="#3AC1EF">Shift command</font> </h2><br>  Use the <code>shift</code> command in bash scripts with caution, since it literally shifts the values ‚Äã‚Äãof the positional parameters. <br><br>  When you use this command, it defaults the values ‚Äã‚Äãof the positional parameters to the left.  For example, the value of the variable <code>$3</code> becomes the value of the variable <code>$2</code> , the value of <code>$2</code> becomes <code>$1</code> , and what was before in <code>$1,</code> is lost.  Note that the value of the <code>$0</code> variable that contains the name of the script does not change. <br><br>  Using the <code>shift</code> command, we will consider another way to iterate through the parameters passed to the script: <br><br><pre> <code class="hljs swift">#!/bin/bash <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ -n <span class="hljs-string"><span class="hljs-string">"$1"</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Parameter #$count = $1"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) shift done</code> </pre> <br>  The script uses a <code>while</code> , checking the length of the value of the first parameter.  When the length is equal to zero, the loop is exited.  After checking the first parameter and displaying it on the screen, the <code>shift</code> command is called, which shifts the parameter values ‚Äã‚Äãby one position. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db1/2d9/1f9/db12d91f92f7e8bc7d62a30471638ed3.png"></div><br>  <i><font color="#999999">Using the shift command to iterate through parameters</font></i> <br><br>  Using the <code>shift</code> command, keep in mind that each time it is called, the value of the <code>$1</code> variable is permanently lost. <br><br><h2>  <font color="#3AC1EF">Command line keys</font> </h2><br>  Command line switches usually look like letters, before which a dash is placed.  They are used to manage scripts.  Consider this example: <br><br><pre> <code class="hljs swift">#!/bin/bash echo <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ -n <span class="hljs-string"><span class="hljs-string">"$1"</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"$1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> -a) echo <span class="hljs-string"><span class="hljs-string">"Found the -a option"</span></span> ;; -b) echo <span class="hljs-string"><span class="hljs-string">"Found the -b option"</span></span> ;; -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) echo <span class="hljs-string"><span class="hljs-string">"Found the -c option"</span></span> ;; *) echo <span class="hljs-string"><span class="hljs-string">"$1 is not an option"</span></span> ;; esac shift done</code> </pre> <br>  Run the script: <br><br><pre> <code class="hljs swift">$ ./myscript ‚Äìa ‚Äìb ‚Äì<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> ‚Äìd</code> </pre> <br>  And analyze what it will bring to the terminal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/a18/5da/2efa185daf65a2171852f56b40c182fb.png"></div><br>  <i><font color="#999999">Handling keys in the script</font></i> <br><br>  This code uses the <code>case</code> construction, which compares the key passed to it with the list of keys processed by the script.  If the transferred value was in this list, the corresponding branch of the code is executed.  If at the call of the script any key is used, the processing of which is not provided for, the ‚Äú*‚Äù branch will be executed. <br><br><h2>  <font color="#3AC1EF">How to distinguish between keys and parameters</font> </h2><br>  Often when writing bash scripts, a situation arises when you need to use both command line parameters and keys.  The standard way to do this is to use a special sequence of characters that tells the script when the keys end and the usual parameters begin. <br><br>  This sequence is a double dash (-).  The shell uses it to indicate the position at which the list of keys ends.  After the script detects the end of the keys, what is left can be treated as parameters, and not as keys, without fear of errors.  Consider an example: <br><br><pre> <code class="hljs swift">#!/bin/bash <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ -n <span class="hljs-string"><span class="hljs-string">"$1"</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"$1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> -a) echo <span class="hljs-string"><span class="hljs-string">"Found the -a option"</span></span> ;; -b) echo <span class="hljs-string"><span class="hljs-string">"Found the -b option"</span></span>;; -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) echo <span class="hljs-string"><span class="hljs-string">"Found the -c option"</span></span> ;; --) shift <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> ;; *) echo <span class="hljs-string"><span class="hljs-string">"$1 is not an option"</span></span>;; esac shift done <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> $@ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Parameter #$count: $param"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done</code> </pre> <br>  This script uses the <code>break</code> command to interrupt the <code>while</code> when it detects a double dash in the string. <br><br>  That's what happens after you call it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/806/fe1/e06806fe1b4bb8c750896fdaa3767f4a.png"></div><br>  <i><font color="#999999">Handling keys and command line parameters</font></i> <br><br>  As you can see, when the script, parsing the data transmitted to it, finds a double dash, it completes the key processing and considers everything that has not been processed yet as parameters. <br><br><h2>  <font color="#3AC1EF">Handling keys with values</font> </h2><br>  As your scripts become more complex, you will encounter situations where ordinary keys are no longer enough, which means you will need to use keys with certain values.  For example, calling a script that uses this feature looks like this: <br><br><pre> <code class="hljs swift">./myscript -a test1 -b -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> test2</code> </pre> <br>  The script should be able to determine when additional parameters are used with the command line keys: <br><br><pre> <code class="hljs swift">#!/bin/bash <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> [ -n <span class="hljs-string"><span class="hljs-string">"$1"</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"$1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> -a) echo <span class="hljs-string"><span class="hljs-string">"Found the -a option"</span></span>;; -b) param=<span class="hljs-string"><span class="hljs-string">"$2"</span></span> echo <span class="hljs-string"><span class="hljs-string">"Found the -b option, with parameter value $param"</span></span> shift ;; -<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) echo <span class="hljs-string"><span class="hljs-string">"Found the -c option"</span></span>;; --) shift <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> ;; *) echo <span class="hljs-string"><span class="hljs-string">"$1 is not an option"</span></span>;; esac shift done <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"$@"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Parameter #$count: $param"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done</code> </pre> <br>  Call this script in this form: <br><br><pre> <code class="hljs">./myscript -a -b test1 -d</code> </pre> <br>  Let's look at the results of his work. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a8/867/258/8a8867258b53425258e90111f9763ddb.png"></div><br>  <i><font color="#999999">Handling key parameters</font></i> <br><br>  In this example, the <code>case</code> construction handles three keys.  The <code>-b</code> switch requires an additional parameter.  Since the key being processed is in the <code>$1</code> variable, the corresponding parameter will be in <code>$2</code> (the <code>shift</code> command is used here, therefore, as it is processed, everything that is passed to the script is shifted to the left).  When we dealt with this, it remains only to extract the value of the <code>$2</code> variable and we will have the parameter of the desired key.  Of course, we need another <code>shift</code> command here so that the next key will fall into <code>$1</code> . <br><br><h2>  <font color="#3AC1EF">Using standard keys</font> </h2><br>  When writing bash scripts, you can choose any letters for command line keys and arbitrarily set the script response to these keys.  However, in the Linux world, the values ‚Äã‚Äãof some keys have become something of a standard that is useful to follow.  Here is a list of these keys: <br><br><blockquote>  <code>-a</code> Display all objects. <br>  <code>-c</code> Perform a count. <br>  <code>-d</code> Specify the directory. <br>  <code>-e</code> Expand the object. <br>  <code>-f</code> Specify the file from which to read the data. <br>  <code>-h</code> Print help on the command. <br>  <code>-i</code> Ignore case. <br>  <code>-l</code> Perform full-format output. <br>  <code>-n</code> Use non-interactive (batch) mode. <br>  <code>-o</code> Allows you to specify the file to which to redirect the output. <br>  <code>-q</code> Run the script in quiet mode. <br>  <code>-r</code> Process folders and files recursively. <br>  <code>-s</code> Run the script in silent mode. <br>  <code>-v</code> Run verbose output. <br>  <code>-x</code> Exclude object. <br>  <code>-y</code> Answer ‚Äúyes‚Äù to all questions. </blockquote><br>  If you are running Linux, you most likely know many of these keys.  By using them in the common meaning in your scripts, you will help users interact with them without worrying about reading the documentation. <br><br><h2>  <font color="#3AC1EF">Receive data from the user</font> </h2><br>  The command line switches and parameters are a great way to get data from the person using the script, but in some cases more interactivity is needed. <br><br>  Sometimes scripts need data that a user must enter during program execution.  It is for this purpose that the bash shell contains the <code>read</code> command. <br><br>  This command allows you to accept entered data either from standard input (from the keyboard) or using other file descriptors.  After receiving the data, this command puts them into a variable: <br><br><pre> <code class="hljs pgsql">#!/bin/bash echo -n "Enter your name: " <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> echo "Hello $name, welcome to my program."</code> </pre> <br>  Notice that the <code>echo</code> command, which displays the prompt, is invoked with the <code>-n</code> key.  This leads to the fact that at the end of the invitation does not display a newline character, which allows the script user to enter data in the same place where the invitation is located, and not on the next line. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53d/1ca/2de/53d1ca2de0cdddb76571125d44c79697.png"></div><br>  <i><font color="#999999">Processing user input</font></i> <br><br>  When calling <code>read</code> you can specify several variables: <br><br><pre> <code class="hljs kotlin">#!/bin/bash read -p <span class="hljs-string"><span class="hljs-string">"Enter your name: "</span></span> first last echo <span class="hljs-string"><span class="hljs-string">"Your data for </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$last</span></span></span><span class="hljs-string">, </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string">‚Ä¶"</span></span></code> </pre> <br>  This is what the script will display after launch. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db7/d56/484/db7d564840726149b098fad0545da7e6.png"></div><br>  <i><font color="#999999">Several variables in the read command</font></i> <br><br>  If, by calling <code>read</code> , you do not specify a variable, the data entered by the user will be placed in a special environment variable <code>REPLY</code> : <br><br><pre> <code class="hljs smalltalk">#!/bin/bash read -p <span class="hljs-comment"><span class="hljs-comment">"Enter your name: "</span></span> echo <span class="hljs-type"><span class="hljs-type">Hello</span></span> <span class="hljs-string"><span class="hljs-string">$R</span></span>EPLY, welcome to my program.</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/fae/752/e7afae7525869d3a0d64ec8d99637fda.png"></div><br>  <i><font color="#999999">Using the REPLY environment variable</font></i> <br><br>  If the script should continue execution regardless of whether the user enters any data or not, by calling the <code>read</code> command, you can use the <code>-t</code> key.  Namely, the key parameter sets the input wait time in seconds: <br><br><pre> <code class="hljs pgsql">#!/bin/bash <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> -t <span class="hljs-number"><span class="hljs-number">5</span></span> -p "Enter your name: " <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> echo "Hello $name, welcome to my script" <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> echo "Sorry, too slow! " fi</code> </pre> <br>  If the data is not entered within 5 seconds, the script will execute the branch of the conditional operator <code>else</code> , displaying an apology. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/68e/907/65c68e9078b67feec2bbddd94c3729b9.png"></div><br>  <i><font color="#999999">Time limit on data entry</font></i> <br><br><h2>  <font color="#3AC1EF">Enter passwords</font> </h2><br>  Sometimes what the user enters in response to a script question is better not to show on the screen.  For example, this is usually done by requesting passwords.  The <code>-s</code> key of the <code>read</code> command prevents the display of data entered from the keyboard.  In fact, the data is output, but the <code>read</code> command makes the text color the same as the background color. <br><br><pre> <code class="hljs smalltalk">#!/bin/bash read -s -p <span class="hljs-comment"><span class="hljs-comment">"Enter your password: "</span></span> pass echo <span class="hljs-comment"><span class="hljs-comment">"Is your password really $pass? "</span></span></code> </pre> <br>  This is how this script will work. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/fd4/3bd/3c3fd43bd63034b4d7dc7159ad06da75.png"></div><br>  <i><font color="#999999">Enter confidential data</font></i> <br><br><h2>  <font color="#3AC1EF">Reading data from a file</font> </h2><br>  The <code>read</code> command can, on every call, read one line of text from a file.  When there are no more unread lines in the file, it will simply stop.  If you need to get all the contents of the file in the script, you can use the pipeline to transfer the results of calling the <code>cat</code> for the file, the <code>while</code> construct that contains the <code>read</code> command (of course, using the <code>cat</code> looks primitive, but our goal is to show everything as simple as possible, newbies; experienced users sure will understand this). <br><br>  Let's write a script that uses the approach just described for reading files. <br><br><pre> <code class="hljs swift">#!/bin/bash <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=<span class="hljs-number"><span class="hljs-number">1</span></span> cat myfile | <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> read line <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> echo <span class="hljs-string"><span class="hljs-string">"Line $count: $line"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>=$(( $<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> )) done echo <span class="hljs-string"><span class="hljs-string">"Finished"</span></span></code> </pre> <br>  Look at him in action. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/893/246/07c/89324607c6c7c11435ad782d88950d6f.png"></div><br>  <i><font color="#999999">Reading data from a file</font></i> <br><br>  Here we transferred to the <code>while</code> contents of the file and went through all the lines of this file, displaying the number and contents of each of them. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Today we have analyzed the work with the keys and command line parameters.  Without these tools, the use of scripts is extremely narrow.  Even if the script is written, as they say, "for myself."  Immediately we looked at approaches to receiving data from the user during program execution ‚Äî this makes the scripts interactive. <br><br>  Next time, let's talk about input and output operations. <br><br>  Dear readers!  Thank you for sharing your experience in the comments to the previous parts of this series of materials.  If you have something to say about processing everything that can be transferred to the script at startup or during its operation, we are sure that many will be interested in reading about it. <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/326328/">https://habr.com/ru/post/326328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326316/index.html">Useful Plugins and Security Tips for WordPress</a></li>
<li><a href="../326318/index.html">In the Canadian airport discovered devices to spy on smartphones</a></li>
<li><a href="../326320/index.html">(Not) for protothreads lovers dedicated to: High-level functions for working with 1-Wire</a></li>
<li><a href="../326322/index.html">5 stages of implementation of a CRM system. Fascinating about the important</a></li>
<li><a href="../326324/index.html">Implement a custom UI element for timing. Part 1</a></li>
<li><a href="../326330/index.html">First steps to the web SCADA-system. We animate the mnemonic in the browser using AngularJS</a></li>
<li><a href="../326332/index.html">Results of the first round of the Russian Code Cup 2017</a></li>
<li><a href="../326334/index.html">The logic of consciousness. Part 12. The search for patterns. Combinatorial space</a></li>
<li><a href="../326336/index.html">Antifraud. Law. Cellular: my questions</a></li>
<li><a href="../326338/index.html">Data Visualization: Oracle BI Data Discovery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>