<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Macros and quasiquotes in Scala 2.11.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not long ago, the release of Scala 2.11.0 . One of the remarkable innovations of this version are quasiquotes - a convenient mechanism for describing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Macros and quasiquotes in Scala 2.11.0</h1><div class="post__text post__text-html js-mediator-article">  Not long ago, the <a href="http://habrahabr.ru/post/220469/">release of Scala 2.11.0</a> .  One of the remarkable innovations of this version are quasiquotes - a convenient mechanism for describing Scala syntax trees using strings compiled during compilation;  Obviously, this mechanism is primarily intended for use with macros. <br><br>  Surprisingly, in Habr√©, while the topic of macros in Scala is not considered very actively;  <a href="http://habrahabr.ru/post/176285/">last post</a> <br>  with serious consideration of macros was already a whole year ago. <br><br>  This post will discuss in detail the writing of a simple macro, designed to generate JSON deserialization code into the class hierarchy. <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  There is a wonderful JSON library for working with Scala - <a href="https://github.com/spray/spray-json">spray.json</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Usually, in order to deserialize some JSON object using this library, a couple of imports are enough: <br><br><pre><code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   : case class MyClass(field: String) //   spray.json: import spray.json._ import DefaultJsonProtocol._ implicit val myClassFormat = jsonFormat1(MyClass) val json = """{ "field\": "value" }""" val obj = json.parseJson.convertTo[MyClass] // ok</span></span></code> </pre> <br>  Simple enough, isn't it?  And if we want to deserialize the entire class hierarchy?  I will give an example of the hierarchy, which we will consider further: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleMessage</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldMessage</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">field: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NestedMessage</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">nested: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiMessage</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">field: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, nested: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span></code> </pre><br>  As you can see, several deserializable classes with different numbers of arguments of different types are inherited from the abstract parent.  A completely natural desire when deserializing such entities is to add a <code>type</code> field to a JSON object, and when deserializing, dispatch over this field.  The idea can be expressed by the following pseudocode: <br><br><pre> <code class="scala hljs">json.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"SimpleMessage"</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">SimpleMessage</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"FieldMessage"</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">FieldMessage</span></span>(json.field) <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  The spray.json library provides the ability to determine the conversion of JSON to any types by user-defined rules through the formatter extension <code>RootJsonFormat</code> .  It sounds quite like what we need.  The core of our formatter should look like this: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> typeName = ... typeName <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"FieldMessage"</span></span> =&gt; map.getFields(<span class="hljs-string"><span class="hljs-string">"field"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Seq</span></span>(field) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FieldMessage</span></span>(field.convertTo[<span class="hljs-type"><span class="hljs-type">String</span></span>]) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"NestedMessage"</span></span> =&gt; map.getFields(<span class="hljs-string"><span class="hljs-string">"nested"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Seq</span></span>(nested) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">NestedMessage</span></span>(nested.convertTo[<span class="hljs-type"><span class="hljs-type">Message</span></span>]) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"MultiMessage"</span></span> =&gt; map.getFields(<span class="hljs-string"><span class="hljs-string">"field"</span></span>, <span class="hljs-string"><span class="hljs-string">"nested"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Seq</span></span>(field, nested) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MultiMessage</span></span>(field.convertTo[<span class="hljs-type"><span class="hljs-type">Int</span></span>], nested.convertTo[<span class="hljs-type"><span class="hljs-type">Message</span></span>]) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"SimpleMessage"</span></span> =&gt; map.getFields() <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Seq</span></span>() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SimpleMessage</span></span>() } }</code> </pre><br>  This code looks a bit ... patterned.  This is a great task for the macro!  The rest of the article is devoted to the development of a macro that can generate such code, having only the <code>Message</code> type as a starting point. <br><br><h5>  Project organization </h5><br>  The first obstacle that a programmer encounters when developing macros is that SBT does not want to compile both the macro and the code using it at the same time.  This problem is discussed in the SBT documentation and I recommend the solution described below. <br><br>  It is necessary to divide the macro code and the main application code into two projects, which should be referred to in the main <code>project/Build.sbt</code> .  In the code accompanying the article, these preparations have already been made, here are links to the resulting files: <br><br><ul><li>  <a href="https://github.com/ForNeVeR/macrojson/blob/master/project/Build.scala">main <code>project/Build.sbt</code> file <code>project/Build.sbt</code></a> ; </li><li>  <a href="">macro project: <code>macro/build.sbt</code></a> ; </li><li>  <a href="">main project: <code>main/build.sbt</code></a> . </li></ul><br>  Another subtlety is that if you want the macro to work with the class hierarchy, this hierarchy should be known when the macro is expanded.  This causes some problems, because  the sequence of file processing by the compiler is not always obvious.  The solution to this issue is either to have the classes with which the macro should work in the same project with the macro (the macro should still be in another project), or simply place the necessary classes in the same file in which the macro is expanded. <br><br>  When debugging macros, the <code>-Ymacro-debug-lite</code> compiler option helps you to display the results of deploying all macros in a project to the console (these results are very similar to Scala code, and can often be compiled manually without any changes when passed to the compiler, which can help debugging non-trivial cases). <br><br><h4>  Macros </h4><br>  Scala's macros work almost like reflection.  Please note that the Scala reflection API is significantly different from Java reflection, since not all Scala concepts are known to the standard Java library. <br><br>  The macro mechanism in Scala provides the ability to create portions of code at compile time.  This is done using a strongly typed API that generates syntax trees corresponding to the code you want to create.  Scala macros are significantly different from all the usual C macros, so they should not be confused. <br><br>  At the heart of Scala macros is the <code>Context</code> class.  An instance of this class is always passed to the macro when expanded.  Then you can import the internals of the <code>Universe</code> object from it and use them in the same way as in runtime reflection ‚Äî request from there descriptors of types, methods, properties, etc.  The same context allows you to create syntax trees using classes like <code>Literal</code> , <code>Constant</code> , <code>List</code> , etc. <br><br>  In essence, a macro is a function that accepts and returns syntax trees.  Let's write our macro template: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.language.experimental.macros <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.reflect.macros.blackbox.<span class="hljs-type"><span class="hljs-type">Context</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> spray.json._ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parsers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">impl</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>: c.<span class="hljs-type"><span class="hljs-type">WeakTypeTag</span></span>](c: <span class="hljs-type"><span class="hljs-type">Context</span></span>)(typeName: c.<span class="hljs-type"><span class="hljs-type">Expr</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>], map: c.<span class="hljs-type"><span class="hljs-type">Expr</span></span>[<span class="hljs-type"><span class="hljs-type">JsObject</span></span>]): c.<span class="hljs-type"><span class="hljs-type">Expr</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> c.universe._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cls = weakTypeOf[<span class="hljs-type"><span class="hljs-type">T</span></span>].typeSymbol.asClass <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tree = ??? <span class="hljs-comment"><span class="hljs-comment">//       c.Expr[T](tree) } def parseMessage[T](typeName: String, map: JsObject): T = macro Parsers.impl[T] }</span></span></code> </pre><br>  The <code>parseMessage[T]</code> macro takes type <code>T</code> , which is the base for the hierarchy of classes being deserialized, and a syntax tree to get the type of the <code>map</code> deserialized, and returns a syntax tree to get the deserialized object converted to the base type <code>T</code> <br><br>  The argument of type <code>T</code> described in a special way: it is indicated that the compiler must attach an implicitly generated object of type <code>c.WeakTypeTag</code> .  Generally speaking, the implicit <code>TypeTag</code> argument <code>TypeTag</code> used in Scala to work with generic argument types that are usually not available at runtime due to <a href="http://en.wikipedia.org/wiki/Generics_in_Java">type erasure</a> .  For macro arguments, the compiler requires using not just <code>TypeTag</code> , but <code>WeakTypeTag</code> , which, as far as I understand, is related to the features of the compiler's work (it does not have a ‚Äúfull-fledged‚Äù <code>TypeTag</code> for a type that may not yet be fully generated during macro expansion).  The type associated with a <code>TypeTag</code> can be obtained using the <code>typeOf[T]</code> method of the <code>Universe</code> object;  accordingly, for <code>WeakTypeTag</code> there is a <code>weakTypeOf[T]</code> method. <br><br>  One of the drawbacks of macros is the non-obvious description of syntax trees.  For example, the code snippet <code>2 + 2</code> should look like <code>Apply(Select(Literal(Constant(2)), TermName("$plus")), List(Literal(Constant(2))))</code> when generated;  even more serious cases begin when we need to present larger pieces of code with pattern substitution.  Naturally, we do not like this complexity and we will overcome it. <br><br><h4>  Quasiquotes </h4><br>  The aforementioned lack of macros from version Scala 2.11.0 can be easily resolved with quasi-quotation.  For example, the above construction, describing the expression <code>2 + 2</code> , in the form of quasiquotes will look just like <code>q"2 + 2"</code> , which is very convenient.  In general, quasiquotes in Scala are a set of string interpolators that are located in the <code>Universe</code> object.  After importing these interpolators in the current scope, it is possible to use a series of characters before the string constant, which determine its processing by the compiler.  In particular, the interpolators <code>pq</code> for patterns, <code>cq</code> for branches of the <code>match</code> expression, and <code>q</code> for complete expressions of the language will be useful to us when implementing the problem in question. <br><br>  As well as for other string interpolators of the Scala language, from quasiquote you can refer to the variables of their surrounding scope.  For example, to generate the expression <code>2 + 2</code> you can use the following code: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-string"><span class="hljs-string">q"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$a</span></span></span><span class="hljs-string"> + </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$a</span></span></span><span class="hljs-string">"</span></span></code> </pre><br>  For variables of different types, interpolation can occur in different ways.  For example, variables of string type in generated trees become <i>string constants</i> .  In order to refer to a variable by name, you need to create a <code>TermName</code> object. <br><br>  As you can see from the example of the generated code given at the beginning of the article, we need to be able to generate the following elements: <br><ul><li>  <code>match</code> <code>typeName</code> variable with <code>case</code> branches corresponding to each type of hierarchy; </li><li>  in each branch - the transfer of the list of the names of the arguments of the constructor of the corresponding class to the <code>map.getFields</code> method; </li><li>  ibid - deconstruction of the obtained sequence (using the same <code>match</code> expression) on variables and passing these variables to the type constructor. </li></ul><br>  First of all, we consider the generation of a common tree of the whole <code>match</code> expression.  To do this, you have to use interpolation of variables in the context of quasiquotes: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clauses: <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">Tree</span></span>] = ??? <span class="hljs-comment"><span class="hljs-comment">// .  val tree = q"$typeName match { case ..$clauses }"</span></span></code> </pre><br>  In this section of the code, a special kind of interpolation is used.  The <code>case ..$clauses</code> expression <code>case ..$clauses</code> inside the <code>match</code> block will be expanded as a list of <code>case</code> branches.  As we remember, each branch should look like this: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"FieldMessage"</span></span> =&gt; map.getFields(<span class="hljs-string"><span class="hljs-string">"field"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Seq</span></span>(field) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FieldMessage</span></span>(field.convertTo[<span class="hljs-type"><span class="hljs-type">String</span></span>]) }</code> </pre><br>  In the form of quasi such a branch can be written as follows: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tpe: <span class="hljs-type"><span class="hljs-type">Type</span></span> <span class="hljs-comment"><span class="hljs-comment">//   val constructorParameters: List[Symbol] //    val parameterNames = constructorParameters.map(_.name) val parameterNameStrings = parameterNames.map(_.toString) //         pq: val parameterBindings = parameterNames.map(name =&gt; pq"$name") //   ,     : val args = constructorParameters.map { param =&gt; val parameterName = TermName(param.name.toString) val parameterType = param.typeSignature q"$parameterName.convertTo[$parameterType]" } //     case: val typeName = tpe.typeSymbol val typeNameString = typeName.name.toString cq"""$typeNameString =&gt; $map.getFields(..$parameterNameStrings) match { case Seq(..$parameterBindings) =&gt; new $typeName(..$args) }"""</span></span></code> </pre><br>  In this code fragment, several quasiquotes are used: the <code>pq"$name"</code> expression creates a set of patterns, which are subsequently substituted into the <code>Seq(...)</code> expression.  Each of these expressions is of type <code>JsValue</code> , which must be converted to the appropriate type before passing to the constructor;  for this, a quasiquote is used that generates a call to the <code>convertTo</code> method.  Note that this method can recursively call our formatter if necessary (that is, you can nest <code>Message</code> objects into each other. <br><br>  Finally, the resulting syntax tree, consisting of a <code>match</code> expression with the <code>case</code> branches generated by us, can also be constructed using interpolation: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tree = <span class="hljs-string"><span class="hljs-string">q"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$typeName</span></span></span><span class="hljs-string"> match { case ..</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$clauses</span></span></span><span class="hljs-string"> }"</span></span></code> </pre><br>  This tree will be built in by the compiler at the place of application of the macro. <br><br><h4>  findings </h4><br>  Throughout the development of technology, metaprogramming has become an increasingly important element of programming languages, and it is increasingly being used in everyday code to implement various concepts.  Scala macros are an actual tool that can save us from various routine work, which in the JVM world was previously decided to be implemented through reflection or code generation. <br><br>  Certainly, macros are a powerful tool that should be used with caution: if used improperly, it is enough to simply shoot off your leg and fall into the abyss of unsupported code.  However, you should always try to automate routine activities, and if macros can help us in this task, they will be used and will benefit the community. <br><br><h4>  Used materials </h4><br><ol><li>  <a href="http://docs.scala-lang.org/overviews/macros/overview.html">Overview of macros from Scala documentation</a> . </li><li>  <a href="http://docs.scala-lang.org/overviews/quasiquotes/intro.html">An overview of quasiquotes from the Scala documentation</a> . </li><li>  <a href="http://docs.scala-lang.org/overviews/core/string-interpolation.html">An overview of string interpolation from the Scala documentation</a> . </li><li>  <a href="http://www.scala-sbt.org/0.13.2/docs/Detailed-Topics/Macro-Projects.html">Guide to Macro Projects for SBT</a> . </li><li>  <a href="https://github.com/ForNeVeR/macrojson">Source code and tests for the article</a> . </li></ol></div><p>Source: <a href="https://habr.com/ru/post/224229/">https://habr.com/ru/post/224229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224217/index.html">Announcement - Artem Gavrichenkov from Qrator will tell in Moscow about DDoS attacks</a></li>
<li><a href="../22422/index.html">Karma loan</a></li>
<li><a href="../224221/index.html">Learning through lectures is inefficient, scientists say</a></li>
<li><a href="../224223/index.html">[libGDX] Writing a full game for Android. Part 2</a></li>
<li><a href="../224227/index.html">One source and two components of video surveillance</a></li>
<li><a href="../22423/index.html">Wordpress 2.5: Design Redesign</a></li>
<li><a href="../224231/index.html">Games as reality simulation</a></li>
<li><a href="../224233/index.html">DevConf :: Mobi 2014 - We vote today for interesting reports - we form the conference program ourselves</a></li>
<li><a href="../224235/index.html">V conference of web developers ‚ÄúWebCamp 2014‚Äù. Odessa. July 21 - 24</a></li>
<li><a href="../22424/index.html">Cartoon about hares;)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>