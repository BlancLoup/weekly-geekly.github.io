<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Win the Android Camera2 API with RxJava2 (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, RxJava is ideal for solving two tasks: processing event streams and working with asynchronous methods. In one of the previous posts, I sh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Win the Android Camera2 API with RxJava2 (Part 1)</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/342/d66/230/342d6623018f4d7b8d0392137429a5ba.jpg"></p><br><p>  As you know, RxJava is ideal for solving two tasks: processing event streams and working with asynchronous methods.  In one of the <a href="https://habrahabr.ru/company/badoo/blog/304488/">previous posts,</a> I showed how you can build a chain of operators that processes the flow of events from the sensor.  And today I want to demonstrate how RxJava is used to work with a substantially asynchronous API.  As such an API, I chose the Camera2 API. </p><br><p>  Below is an example of using the Camera2 API, which is still rather poorly documented and studied by the community.  To tame it, RxJava2 will be used.  The second version of this popular library was released relatively recently, and there are not many examples on it either. </p><br><p>  Who is this post for?  I hope that the reader is an experienced, but still an inquisitive Android developer.  Basic knowledge of reactive programming (a <a href="https://habrahabr.ru/company/badoo/blog/328434/">good introduction is here</a> ) and understanding of Marble Diagrams are highly desirable.  The post will be useful to those who want to penetrate the reactive approach, as well as those who want to use the Camera2 API in their projects.  I warn you, there will be a lot of code! </p><br><p>  Project sources <a href="https://github.com/ArkadyGamza/Camera2API_rxJava2">can be found on GitHub</a> . </p><a name="habracut"></a><br><h3 id="podgotovka-proekta">  Project preparation </h3><br><p>  Add third-party dependencies to our project. </p><br><h4 id="retrolambda">  Retrolambda </h4><br><p>  When working with RxJava, lambda support is absolutely necessary - otherwise the code will look just awful.  So if you haven't switched to Android Studio 3.0 yet, add Retrolambda to our project. </p><br><pre><code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">buildscript</span></span> { <span class="hljs-section"><span class="hljs-section">dependencies</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">classpath</span></span> <span class="hljs-string"><span class="hljs-string">'me.tatarka:gradle-retrolambda:3.6.0'</span></span> } } apply plugin: <span class="hljs-string"><span class="hljs-string">'me.tatarka.retrolambda'</span></span></code> </pre> <br><p>  Now you can raise the language version to 8, which will provide support for the lambda. </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">android</span></span> { <span class="hljs-section"><span class="hljs-section">compileOptions</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">sourceCompatibility</span></span> JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } }</code> </pre> <br><p>  Full <a href="https://github.com/evant/gradle-retrolambda">instructions</a> . </p><br><h4 id="rxjava2">  Rxjava2 </h4><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'io.reactivex.rxjava2:rxjava:2.1.0'</span></span></code> </pre> <br><p>  The current version, full instructions and documentation are available <a href="https://github.com/ReactiveX/RxJava">here</a> . </p><br><h4 id="rxandroid">  RxAndroid </h4><br><p>  Useful library when using RxJava on Android.  Mainly used for AndroidSchedulers.  <a href="https://github.com/ReactiveX/RxAndroid">Repository</a> </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'io.reactivex.rxjava2:rxandroid:2.0.1'</span></span></code> </pre> <br><h3 id="camera2-api">  Camera2 API </h3><br><p>  At one time, I participated in the code review module written using the Camera1 API, and was unpleasantly surprised by the inevitable because of the design of the API concurrency issues.  Apparently, Google also realized the problem and stopped the first version of the API.  Instead, it is proposed to use the Camera2 API.  The second version is available on Android Lollipop and newer. </p><br><p>  Let's <a href="https://developer.android.com/reference/android/hardware/camera2/package-summary.html">take a</a> look <a href="https://developer.android.com/reference/android/hardware/camera2/package-summary.html">at it</a> . </p><br><h4 id="pervye-vpechatleniya">  First impressions </h4><br><p>  Google did a good job of making mistakes in terms of streamlining.  All operations are performed asynchronously, notifying the results through callbacks.  Moreover, by passing the appropriate Handler, you can select the stream in which the callback methods will be called. </p><br><h4 id="referensnaya-implementaciya">  Reference implementation </h4><br><p>  Google offers an example of the <a href="https://github.com/googlesamples/android-Camera2Basic">Camera2Basic</a> application. </p><br><p>  This is a rather naive implementation, but it helps to get started with the API.  See if we can make a more elegant solution using a reactive approach. </p><br><h4 id="shagi-dlya-polucheniya-snimka">  Steps for taking a snapshot </h4><br><p>  In short, the sequence of actions for taking a picture is as follows: </p><br><ul><li>  select a device </li><li>  open the device </li><li>  open session </li><li>  run preview </li><li>  by clicking on the button to take a picture </li><li>  close the session </li><li>  close the device. </li></ul><br><h4 id="vybor-ustroystva">  Device selection </h4><br><p>  First we need the <a href="https://developer.android.com/reference/android/hardware/camera2/CameraManager.html">CameraManager</a> . </p><br><pre> <code class="java hljs">mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);</code> </pre> <br><p>  This class allows you to receive information about existing cameras in the system and connect to them.  There may be several cameras, smartphones usually have two of them: front and rear. </p><br><p>  Get the list of cameras. </p><br><pre> <code class="java hljs">String[] cameraIdList = mCameraManager.getCameraIdList();</code> </pre> <br><p>  That's so severe - just a list of string aydishnikov. </p><br><p>  Now we get a list of characteristics for each camera. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String cameraId : cameraIdList) { CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(cameraId); ... }</code> </pre> <br><p>  <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCharacteristics.html">CameraCharacteristics</a> contains a huge number of keys by which you can get information about the camera. </p><br><p>  Most often at the stage of selecting the camera look at where the camera is directed.  To do this, you need to get the value for the key <code>CameraCharacteristics.LENS_FACING</code> . </p><br><pre> <code class="java hljs">Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);</code> </pre> <br><p>  The camera can be front ( <code>CameraCharacteristics.LENS_FACING_FRONT</code> ), rear ( <code>CameraCharacteristics.LENS_FACING_BACK</code> ) or connectable ( <code>CameraCharacteristics.LENS_FACING_EXTERNAL</code> ). </p><br><p>  The camera selection function with orientation preference might look something like this: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCameraWithFacing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraManager manager, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lensFacing)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> CameraAccessException </span></span>{ String possibleCandidate = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; String[] cameraIdList = manager.getCameraIdList(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cameraIdList.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String cameraId : cameraIdList) { CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId); StreamConfigurationMap map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (map == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (facing != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; facing == lensFacing) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cameraId; } <span class="hljs-comment"><span class="hljs-comment">//just in case device don't have any camera with given facing possibleCandidate = cameraId; } if (possibleCandidate != null) { return possibleCandidate; } return cameraIdList[0]; }</span></span></code> </pre><br><p>  Great, now we have the camera id of the desired orientation (or any other, if the desired one was not found).  So far, it's pretty simple, no asynchronous actions. </p><br><h3 id="sozdaem-observable">  Create Observable </h3><br><p>  We approach asynchronous API methods.  We will convert each of them into Observable using the <code>create</code> method. </p><br><h4 id="opencamera">  openCamera </h4><br><p>  The device must be opened using the <a href="https://developer.android.com/reference/android/hardware/camera2/CameraManager.html">CameraManager.openCamera</a> method before use. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openCamera</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String cameraId, CameraDevice.StateCallback callback, Handler handler)</span></span></span></span></code> </pre> <br><p>  In this method, we pass the id of the selected camera, the callback for obtaining the asynchronous result, and the Handler, if we want the callback methods to be called in the stream of this Handler. </p><br><p>  Here we are faced with the first asynchronous method.  It is understandable, because the initialization of the device is a long and expensive process. </p><br><p>  Let's take a look at <a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice.StateCallback.html"><code>CameraDevice.StateCallback</code></a> . </p><br><p><img src="https://habrastorage.org/web/42b/a4d/4b1/42ba4d4b1c0a42b4bdce864ef9d15fc9.png"></p><br><p>  In the reactive world, these methods will correspond to events.  Let's do an Observable that will generate events when the camera API <code>onOpened</code> , <code>onClosed</code> , <code>onDisconnected</code> .  So that we can distinguish these events, create an enum: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DeviceStateEvents { ON_OPENED, ON_CLOSED, ON_DISCONNECTED }</code> </pre> <br><p>  And in order to have a jet stream (hereinafter I will call a jet stream a sequence of reactive operators - not to be confused with Thread) to have an opportunity to do something with the device, we will add a link to <code>CameraDevice</code> in the generated event.  The easiest way is to generate <code>Pair&lt;DeviceStateEvents, CameraDevice&gt;</code> .  To create an <code>Observable</code> , we use the <code>create</code> method (remember, we use RxJava2, so now we are not ashamed to do this). </p><br><p>  Here is the signature of the <code>create</code> method: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Observable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObservableOnSubscribe&lt;T&gt; source)</span></span></span></span></code> </pre> <br><p>  That is, we need to pass into it an object that implements the <code>ObservableOnSubscribe&lt;T&gt;</code> interface.  This interface contains only one method. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull ObservableEmitter&lt;T&gt; e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>;</code> </pre> <br><p>  which is called every time <code>Observer</code> subscribes to our <code>Observable</code> . </p><br><p>  Let's see what <code>ObservableEmitter</code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableEmitter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Emitter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setDisposable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Disposable d)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCancellable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Cancellable c)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isDisposed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ObservableEmitter&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Already good.  Using the methods <code>setDisposable/setCancellable</code> you can set the action that will be executed when our <code>Observable</code> unsubscribed.  This is extremely useful if, when creating the <code>Observable</code> we opened a resource that needs to be closed.  We could create <code>Disposable</code> in which to close the device when <code>unsubscribe</code> , but we want to respond to the <code>onClosed</code> event, so we will not do this. </p><br><p>  The <code>isDisposed</code> method allows <code>isDisposed</code> to check if someone else is subscribed to our Observable. </p><br><p>  Note that <code>ObservableEmitter</code> extends the <code>Emitter</code> interface. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Emitter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull T value)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Throwable error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  These are the methods we need!  We will call <code>onNext</code> every time the Camera API calls the <a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice.StateCallback.html">CameraDevice.StateCallback</a> <code>onOpened</code> / <code>onClosed</code> / <code>onDisconnected</code> ;  and we will call <code>onError</code> when the Camera API calls an <code>onError</code> . </p><br><p>  So, apply our knowledge.  The method that creates the <code>Observable</code> may look like this (for the sake of readability, I removed the checks on <code>isDisposed()</code> , the full code with boring checks is on GitHub): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Observable&lt;Pair&lt;DeviceStateEvents, CameraDevice&gt;&gt; openCamera( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> String cameraId, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> CameraManager cameraManager ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.create(observableEmitter -&gt; { cameraManager.openCamera(cameraId, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CameraDevice.StateCallback() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOpened</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraDevice cameraDevice)</span></span></span><span class="hljs-function"> </span></span>{ observableEmitter.onNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(DeviceStateEvents.ON_OPENED, cameraDevice)); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClosed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraDevice cameraDevice)</span></span></span><span class="hljs-function"> </span></span>{ observableEmitter.onNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(DeviceStateEvents.ON_CLOSED, cameraDevice)); observableEmitter.onComplete(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDisconnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraDevice cameraDevice)</span></span></span><span class="hljs-function"> </span></span>{ observableEmitter.onNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(DeviceStateEvents.ON_DISCONNECTED, cameraDevice)); observableEmitter.onComplete(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraDevice camera, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error)</span></span></span><span class="hljs-function"> </span></span>{ observableEmitter.onError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCameraException(OpenCameraException.Reason.getReason(error))); } }, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }); }</code> </pre> <br><p>  Super!  We just got a little more reactive! </p><br><p>  As I said before, all Camera2 API methods accept <code>Handler</code> as one of the parameters.  By passing <code>null</code> , we will receive callback calls in the current stream.  In our case, this is the thread in which the <code>subscribe</code> was called, that is, the main thread. </p><br><h4 id="createcapturesession">  createCaptureSession </h4><br><p>  Now that we have <code>CameraDevice</code> , we can open the <code>CaptureSession</code> .  We will not hesitate! </p><br><p>  To do this, we use the <a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice.html">CameraDevice.createCaptureSession</a> method.  Here is its signature: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCaptureSession</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull List&lt;Surface&gt; outputs, @NonNull CameraCaptureSession.StateCallback callback, @Nullable Handler handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> CameraAccessException</span></span>;</code> </pre> <br><p>  A list of the <code>Surface</code> (where to get it, <code>CameraCaptureSession.StateCallback</code> later) and <code>CameraCaptureSession.StateCallback</code> .  Let's see what <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession.StateCallback.html">methods</a> it has. </p><br><p><img src="https://habrastorage.org/web/1f7/553/d9c/1f7553d9c8c641efbb1f32b1be751052.png"></p><br><p>  Richly  But we already know how to win Kolbeks.  Create an <code>Observable</code> that will generate events when the Camera API calls these methods.  To distinguish them, create an enum. </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CaptureSessionStateEvents { ON_CONFIGURED, ON_READY, ON_ACTIVE, ON_CLOSED, ON_SURFACE_PREPARED }</code> </pre> <br><p>  And in order to have a <code>CameraCaptureSession</code> object in the jet stream, we will generate not just the <code>CaptureSessionStateEvent</code> , but the <code>Pair&lt;CaptureSessionStateEvents, CameraCaptureSession&gt;</code> .  Here is how the code of the method creating such an <code>Observable</code> might look like (checks are again removed for readability): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Observable&lt;Pair&lt;CaptureSessionStateEvents, CameraCaptureSession&gt;&gt; createCaptureSession( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> CameraDevice cameraDevice, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> List&lt;Surface&gt; surfaceList ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.create(observableEmitter -&gt; { cameraDevice.createCaptureSession(surfaceList, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CameraCaptureSession.StateCallback() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ observableEmitter.onNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(CaptureSessionStateEvents.ON_CONFIGURED, session)); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigureFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ observableEmitter.onError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreateCaptureSessionException(session)); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReady</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ observableEmitter.onNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(CaptureSessionStateEvents.ON_READY, session)); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ observableEmitter.onNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(CaptureSessionStateEvents.ON_ACTIVE, session)); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClosed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ observableEmitter.onNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(CaptureSessionStateEvents.ON_CLOSED, session)); observableEmitter.onComplete(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfacePrepared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session, @NonNull Surface surface)</span></span></span><span class="hljs-function"> </span></span>{ observableEmitter.onNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pair&lt;&gt;(CaptureSessionStateEvents.ON_SURFACE_PREPARED, session)); } }, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }); }</code> </pre> <br><h4 id="setrepeatingrequest">  setRepeatingRequest </h4><br><p>  In order for a live picture from the camera to appear on the screen, you need to constantly receive new images from the device and transfer them for display.  For this API there is a convenient method <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession.html">CameraCaptureSession.setRepeatingRequest</a> . </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRepeatingRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CaptureRequest request, @Nullable CaptureCallback listener, @Nullable Handler handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> CameraAccessException</span></span>;</code> </pre> <br><p>  We use the technique already familiar to us to make this operation reactive.  We look at the interface <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession.CaptureCallback.html">CameraCaptureSession.CaptureCallback</a> . </p><br><p><img src="https://habrastorage.org/web/e4a/583/074/e4a58307495b4c3f84c538eca95778a3.png"></p><br><p>  Again, we want to distinguish the generated events and for this we create an <code>enum</code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CaptureSessionEvents { ON_STARTED, ON_PROGRESSED, ON_COMPLETED, ON_SEQUENCE_COMPLETED, ON_SEQUENCE_ABORTED }</code> </pre> <br><p>  We see that quite a lot of information that we want to have in the jet stream is transferred to the methods, including the <code>CameraCaptureSession</code> , <code>CaptureRequest</code> , <code>CaptureResult</code> , so just <code>Pair&lt;&gt;</code> will no longer suit us - we will create a POJO: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CaptureSessionData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CaptureSessionEvents event; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CameraCaptureSession session; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CaptureRequest request; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CaptureResult result; CaptureSessionData(CaptureSessionEvents event, CameraCaptureSession session, CaptureRequest request, CaptureResult result) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.event = event; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.session = session; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.request = request; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.result = result; } }</code> </pre><br><p>  Creating the <code>CameraCaptureSession.CaptureCallback</code> to a separate method. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CameraCaptureSession.<span class="hljs-function"><span class="hljs-function">CaptureCallback </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCaptureCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ObservableEmitter&lt;CaptureSessionData&gt; observableEmitter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CameraCaptureSession.CaptureCallback() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCaptureStarted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timestamp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> frameNumber)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCaptureProgressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureResult partialResult)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCaptureCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!observableEmitter.isDisposed()) { observableEmitter.onNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CaptureSessionData(CaptureSessionEvents.ON_COMPLETED, session, request, result)); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCaptureFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureFailure failure)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!observableEmitter.isDisposed()) { observableEmitter.onError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CameraCaptureFailedException(failure)); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCaptureSequenceCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sequenceId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> frameNumber)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCaptureSequenceAborted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession session, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sequenceId)</span></span></span><span class="hljs-function"> </span></span>{ } }; }</code> </pre> <br><p>  Of all these messages, we are interested in <code>onCaptureCompleted</code> / <code>onCaptureFailed</code> , ignoring the rest of the events.  If you need them in your projects, they are easy to add. </p><br><p>  Now everything is ready to create an <code>Observable</code> . </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;CaptureSessionData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromSetRepeatingRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession captureSession, @NonNull CaptureRequest request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable .create(observableEmitter -&gt; captureSession.setRepeatingRequest(request, createCaptureCallback(observableEmitter), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)); }</code> </pre> <br><h4 id="capture">  capture </h4><br><p>  In fact, this step is completely analogous to the previous one, only we make not a repeated request, but a single one.  To do this, use the <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession.html">CameraCaptureSession.capture</a> method. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">capture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CaptureRequest request, @Nullable CaptureCallback listener, @Nullable Handler handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> CameraAccessException</span></span>;</code> </pre> <br><p>  It takes exactly the same parameters, so that we can use the function defined above to create the <code>CaptureCallback</code> . </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;CaptureSessionData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromCapture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession captureSession, @NonNull CaptureRequest request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable .create(observableEmitter -&gt; captureSession.capture(request, createCaptureCallback(observableEmitter), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)); }</code> </pre> <br><h3 id="podgotovka-surface">  Surface Preparation </h3><br><p>  Cameara2 API allows in the request to transfer the list of Surfaces that will be used to record data from the device.  We need two Surfaces: </p><br><ul><li>  to display the preview on the screen, </li><li>  to capture a snapshot to a jpeg file. </li></ul><br><h4 id="textureview">  Textureview </h4><br><p>  To display the preview on the screen, we will use <a href="https://developer.android.com/reference/android/view/TextureView.html">TextureView</a> .  In order to get Surface from TextureView, we suggest using the <a href="https://developer.android.com/reference/android/view/TextureView.html">TextureView.setSurfaceTextureListener</a> method. <br>  <code>TextureView</code> will notify the listener when <code>Surface</code> is ready for use. </p><br><p>  Let's create a <code>PublishSubject</code> this time that will generate events when <code>TextureView</code> calls <code>listener</code> methods. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PublishSubject&lt;SurfaceTexture&gt; mOnSurfaceTextureAvailable = PublishSubject.create(); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle saveState)</span></span></span></span>{ mTextureView.setSurfaceTextureListener(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextureView.SurfaceTextureListener(){ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceTextureAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceTexture surface,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span></span>{ mOnSurfaceTextureAvailable.onNext(surface); } }); ... }</code> </pre> <br><p>  Using <code>PublishSubject</code> , we avoid possible problems with multiple <code>subscribe</code> .  We install <code>SurfaceTextureListener</code> once in <code>onCreate</code> and continue to live peacefully.  <code>PublishSubject</code> allows <code>PublishSubject</code> to subscribe to it as many times as you like and distributes events to all those who subscribe. </p><br><p><img src="https://habrastorage.org/web/bc1/e86/522/bc1e865226a840ac85d2c2e162324983.png"></p><br><p>  When using the Camera2 API, there is a subtlety associated with the inability to explicitly set the image size, the camera itself chooses one of the resolutions it supports based on the size transferred to it by the <code>Surface</code> .  Therefore, we have to go for such a trick: find out the list of image sizes supported by the camera, choose the one you like the most and then set the buffer size exactly the same. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupSurface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull SurfaceTexture surfaceTexture)</span></span></span><span class="hljs-function"> </span></span>{ surfaceTexture.setDefaultBufferSize(mCameraParams.previewSize.getWidth(), mCameraParams.previewSize.getHeight()); mSurface = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Surface(surfaceTexture); }</code> </pre> <br><p>  At the same time, if we want to see the image with preservation of proportions, it is necessary to set the necessary proportions to our <code>TextureView</code> .  To do this, we expand it and override the <code>onMeasure</code> method: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoFitTextureView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextureView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mRatioWidth = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mRatioHeight = <span class="hljs-number"><span class="hljs-number">0</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAspectRatio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ mRatioWidth = width; mRatioHeight = height; requestLayout(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMeasure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> widthMeasureSpec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> heightMeasureSpec)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = MeasureSpec.getSize(widthMeasureSpec); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = MeasureSpec.getSize(heightMeasureSpec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == mRatioWidth || <span class="hljs-number"><span class="hljs-number">0</span></span> == mRatioHeight) { setMeasuredDimension(width, height); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (width &lt; height * mRatioWidth / mRatioHeight) { setMeasuredDimension(width, width * mRatioHeight / mRatioWidth); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { setMeasuredDimension(height * mRatioWidth / mRatioHeight, height); } } } }</code> </pre> <br><h4 id="zapis-v-fayl">  Write to file </h4><br><p>  To save an image from Surface to a file, let's use the <a href="https://developer.android.com/reference/android/media/ImageReader.html">ImageReader</a> class. <br>  A few words about choosing the size for the <code>ImageReader</code> .  First, we have to select it from those supported by the camera.  Secondly, the aspect ratio should coincide with what we chose to preview. </p><br><p>  So that we can receive notifications from <code>ImageReader</code> about image readiness, we will use the <a href="https://developer.android.com/reference/android/media/ImageReader.html">setOnImageAvailableListener</a> method </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOnImageAvailableListener</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ImageReader.OnImageAvailableListener listener, Handler handler)</span></span></span></span></code> </pre> <br><p>  The <code>listener</code> passed in implements just one <code>onImageAvailable</code> method. <br>  Every time the Camera API will record an image in <code>Surface</code> provided by our <code>ImageReader</code> , it will call this callback. </p><br><p>  Let's make this operation reactive: create an <code>Observable</code> that will generate a message every time <code>ImageReader</code> is ready to provide an image. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;ImageReader&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createOnImageAvailableObservable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull ImageReader imageReader)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.create(subscriber -&gt; { ImageReader.OnImageAvailableListener listener = reader -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isDisposed()) { subscriber.onNext(reader); } }; imageReader.setOnImageAvailableListener(listener, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); subscriber.setCancellable(() -&gt; imageReader.setOnImageAvailableListener(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//remove listener on unsubscribe }); }</span></span></code> </pre> <br><p>  Notice that here we used the <code>ObservableEmitter.setCancellable</code> method to remove the <code>listener</code> when unsubscribing from the Observable. </p><br><p>  Writing to a file is a lengthy operation; we will make it reactive using the <code>fromCallable</code> method. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Single&lt;File&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Image image, @NonNull File file)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Single.fromCallable(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (FileChannel output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(file).getChannel()) { output.write(image.getPlanes()[<span class="hljs-number"><span class="hljs-number">0</span></span>].getBuffer()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> file; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { image.close(); } }); }</code> </pre> <br><p>  Now we can specify the following sequence of actions: when the finished image appears in <code>ImageReader</code> , we write it to a file in the workflow <code>Schedulers.io()</code> , then switch to UI thread and notify the UI that the file is ready. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initImageReader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Size sizeForImageReader = CameraStrategy.getStillImageSize(mCameraParams.cameraCharacteristics, mCameraParams.previewSize); mImageReader = ImageReader.newInstance(sizeForImageReader.getWidth(), sizeForImageReader.getHeight(), ImageFormat.JPEG, <span class="hljs-number"><span class="hljs-number">1</span></span>); mCompositeDisposable.add( ImageSaverRxWrapper.createOnImageAvailableObservable(mImageReader) .observeOn(Schedulers.io()) .flatMap(imageReader -&gt; ImageSaverRxWrapper.save(imageReader.acquireLatestImage(), mFile).toObservable()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(file -&gt; mCallback.onPhotoTaken(file.getAbsolutePath(), getLensFacingPhotoType())) ); }</code> </pre><br><h3 id="zapuskaem-preview">  We start preview </h3><br><p>  So, we are thoroughly prepared.  We can already create <code>Observable</code> for the main asynchronous actions that are required for the application to work.  Ahead the most interesting is the configuration of reactive flows. </p><br><p>  To warm up, let's make the camera open after <code>SurfaceTexture</code> ready for use. </p><br><pre> <code class="java hljs"> Observable&lt;Pair&lt;CameraRxWrapper.DeviceStateEvents, CameraDevice&gt;&gt; cameraDeviceObservable = mOnSurfaceTextureAvailable .firstElement() .doAfterSuccess(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::setupSurface) .doAfterSuccess(__ -&gt; initImageReader()) .toObservable() .flatMap(__ -&gt; CameraRxWrapper.openCamera(mCameraParams.cameraId, mCameraManager)) .share();</code> </pre> <br><p>  The key operator here is <code>flatMap</code> . </p><br><p><img src="https://habrastorage.org/web/f32/2eb/2e7/f322eb2e739948a9a763eac0b3b4de53.png"></p><br><p>  In our case, when receiving the readiness <code>SurfaceTexture</code> it will execute the <code>openCamera</code> function and <code>openCamera</code> events from the <code>Observable</code> created by it further into the jet stream. </p><br><p>  It is also important to understand why the <code>share</code> statement is used at the end of the chain.  It is equivalent to the chain of <code>publish().refCount()</code> . </p><br><p><img src="https://habrastorage.org/web/be7/e58/d65/be7e58d659744d9aa15d7bc0766a9da5.png"></p><br><p>  If you look at this Marble Diagram for a long time, you can see that the result is very similar to the result of using <code>PublishSubject</code> .  Indeed, we solve a similar problem: if we subscribe to our <code>Observable</code> several times, we do not want to re-open the camera every time. </p><br><p>  For convenience, let's introduce a couple more Observable. </p><br><pre> <code class="java hljs"> Observable&lt;CameraDevice&gt; openCameraObservable = cameraDeviceObservable .filter(pair -&gt; pair.first == CameraRxWrapper.DeviceStateEvents.ON_OPENED) .map(pair -&gt; pair.second) .share(); Observable&lt;CameraDevice&gt; closeCameraObservable = cameraDeviceObservable .filter(pair -&gt; pair.first == CameraRxWrapper.DeviceStateEvents.ON_CLOSED) .map(pair -&gt; pair.second) .share();</code> </pre> <br><p>  <code>openCameraObservable</code> will generate events when the camera is successfully open, and <code>closeCameraObservable</code> when it is closed. </p><br><p>  Let's take one more step: after successfully opening the camera, we will open the session. </p><br><pre> <code class="java hljs"> Observable&lt;Pair&lt;CameraRxWrapper.CaptureSessionStateEvents, CameraCaptureSession&gt;&gt; createCaptureSessionObservable = openCameraObservable .flatMap(cameraDevice -&gt; CameraRxWrapper .createCaptureSession(cameraDevice, Arrays.asList(mSurface, mImageReader.getSurface())) ) .share();</code> </pre> <br><p>  And by analogy, we will create a couple more <code>Observable</code> , signaling the successful opening or closing of the session. </p><br><pre> <code class="java hljs"> Observable&lt;CameraCaptureSession&gt; captureSessionConfiguredObservable = createCaptureSessionObservable .filter(pair -&gt; pair.first == CameraRxWrapper.CaptureSessionStateEvents.ON_CONFIGURED) .map(pair -&gt; pair.second) .share(); Observable&lt;CameraCaptureSession&gt; captureSessionClosedObservable = createCaptureSessionObservable .filter(pair -&gt; pair.first == CameraRxWrapper.CaptureSessionStateEvents.ON_CLOSED) .map(pair -&gt; pair.second) .share();</code> </pre> <br><p>  Finally, we can set a repeating query to display a preview. </p><br><pre> <code class="java hljs"> Observable&lt;CaptureSessionData&gt; previewObservable = captureSessionConfiguredObservable .flatMap(cameraCaptureSession -&gt; { CaptureRequest.Builder previewBuilder = createPreviewBuilder(cameraCaptureSession, mSurface); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CameraRxWrapper.fromSetRepeatingRequest(cameraCaptureSession, previewBuilder.build()); }) .share();</code> </pre> <br><p>  Now it is enough to execute <code>previewObservable.subscribe()</code> - and a live picture from the camera will appear on the screen! </p><br><p>  A small digression.  If you collapse all intermediate <code>Observable</code> , you get this chain of operators: </p><br><pre> <code class="java hljs"> mOnSurfaceTextureAvailable .firstElement() .doAfterSuccess(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::setupSurface) .toObservable() .flatMap(__ -&gt; CameraRxWrapper.openCamera(mCameraParams.cameraId, mCameraManager)) .filter(pair -&gt; pair.first == CameraRxWrapper.DeviceStateEvents.ON_OPENED) .map(pair -&gt; pair.second) .flatMap(cameraDevice -&gt; CameraRxWrapper .createCaptureSession(cameraDevice, Arrays.asList(mSurface, mImageReader.getSurface())) ) .filter(pair -&gt; pair.first == CameraRxWrapper.CaptureSessionStateEvents.ON_CONFIGURED) .map(pair -&gt; pair.second) .flatMap(cameraCaptureSession -&gt; { CaptureRequest.Builder previewBuilder = createPreviewBuilder(cameraCaptureSession, mSurface); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CameraRxWrapper.fromSetRepeatingRequest(cameraCaptureSession, previewBuilder.build()); }) .subscribe();</code> </pre> <br><p>  And this is enough to show preview.  Impressive, isn't it? </p><br><p>  In fact, this solution has problems with closing resources, and snapshots cannot be made yet.   ,     .   <code>Observable</code>          . </p><br><p>        ,     <code>subscribe</code> <code>Disposable</code> .    <code>CompositeDisposable</code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CompositeDisposable mCompositeDisposable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeDisposable(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mCompositeDisposable.clear(); }</code> </pre> <br><p>       <code>mCompositeDisposable.add(...subscribe())</code> ,      ,     . </p><br><h4 id="kak-sostavlyat-zaprosy-capturerequest">    CaptureRequest </h4><br><p>  , ,  ,     <code>createPreviewBuilder</code> ,    .   ,    . </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> CaptureRequest.<span class="hljs-function"><span class="hljs-function">Builder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPreviewBuilder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CameraCaptureSession captureSession, Surface previewSurface)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> CameraAccessException </span></span>{ CaptureRequest.Builder builder = captureSession.getDevice().createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); builder.addTarget(previewSurface); setup3Auto(builder); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builder; }</code> </pre><br><p>          preview,     Surface  ,   Auto Focus, Auto Exposure  Auto White Balance ( A).   ,    . </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup3Auto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CaptureRequest.Builder builder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Enable auto-magical 3A run by camera device builder.set(CaptureRequest.CONTROL_MODE, CaptureRequest.CONTROL_MODE_AUTO); Float minFocusDist = mCameraParams.cameraCharacteristics.get(CameraCharacteristics.LENS_INFO_MINIMUM_FOCUS_DISTANCE); // If MINIMUM_FOCUS_DISTANCE is 0, lens is fixed-focus and we need to skip the AF run. boolean noAFRun = (minFocusDist == null || minFocusDist == 0); if (!noAFRun) { // If there is a "continuous picture" mode available, use it, otherwise default to AUTO. int[] afModes = mCameraParams.cameraCharacteristics.get(CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES); if (contains(afModes, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)) { builder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE); } else { builder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_AUTO); } } // If there is an auto-magical flash control mode available, use it, otherwise default to // the "on" mode, which is guaranteed to always be available. int[] aeModes = mCameraParams.cameraCharacteristics.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_MODES); if (contains(aeModes, CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH)) { builder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH); } else { builder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON); } // If there is an auto-magical white balance control mode available, use it. int[] awbModes = mCameraParams.cameraCharacteristics.get(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES); if (contains(awbModes, CaptureRequest.CONTROL_AWB_MODE_AUTO)) { // Allow AWB to run auto-magically if this device supports this builder.set(CaptureRequest.CONTROL_AWB_MODE, CaptureRequest.CONTROL_AWB_MODE_AUTO); } }</span></span></code> </pre> <br><h4 id="delaem-snimok">   </h4><br><p>        ,     <a href="https://github.com/JakeWharton/RxBinding">RxBinding</a> ,    . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PublishSubject&lt;Object&gt; mOnShutterClick = PublishSubject.create(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takePhoto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mOnShutterClick.onNext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><p>    .       ,    preview ( ,     ).     combineLatest. </p><br><pre> <code class="java hljs">Observable.combineLatest(previewObservable, mOnShutterClick, (captureSessionData, o) -&gt; captureSessionData)</code> </pre> <br><p>            previewObservable,    . </p><br><pre> <code class="java hljs"> .firstElement().toObservable()</code> </pre> <br><p> ,     . </p><br><pre> <code class="java hljs"> .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::waitForAf) .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::waitForAe)</code> </pre> <br><p> , ,  . </p><br><pre> <code class="java hljs">.flatMap(captureSessionData -&gt; captureStillPicture(captureSessionData.session))</code> </pre> <br><p>     : </p><br><pre> <code class="java hljs"> Observable.combineLatest(previewObservable, mOnShutterClick, (captureSessionData, o) -&gt; captureSessionData) .firstElement().toObservable() .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::waitForAf) .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::waitForAe) .flatMap(captureSessionData -&gt; captureStillPicture(captureSessionData.session)) .subscribe(__ -&gt; { }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::onError)</code> </pre> <br><p> ,   <code>captureStillPicture</code> . </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Observable&lt;CaptureSessionData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">captureStillPicture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraCaptureSession cameraCaptureSession)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable .fromCallable(() -&gt; createStillPictureBuilder(cameraCaptureSession.getDevice())) .flatMap(builder -&gt; CameraRxWrapper.fromCapture(cameraCaptureSession, builder.build())); }</code> </pre> <br><p>      :  ,  capture ‚Äì   .     <code>STILL_PICTURE</code> ,    <code>Surface</code>    ,     ,  ,       .     ,     JPEG. </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CaptureRequest.<span class="hljs-function"><span class="hljs-function">Builder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createStillPictureBuilder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CameraDevice cameraDevice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> CameraAccessException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CaptureRequest.Builder builder; builder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE); builder.set(CaptureRequest.CONTROL_CAPTURE_INTENT, CaptureRequest.CONTROL_CAPTURE_INTENT_STILL_CAPTURE); builder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CameraMetadata.CONTROL_AE_PRECAPTURE_TRIGGER_IDLE); builder.addTarget(mImageReader.getSurface()); setup3Auto(builder); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rotation = mWindowManager.getDefaultDisplay().getRotation(); builder.set(CaptureRequest.JPEG_ORIENTATION, CameraOrientationHelper.getJpegOrientation(mCameraParams.cameraCharacteristics, rotation)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builder; }</code> </pre> <br><h4 id="zakryvaem-resursy">   </h4><br><p>     ,   ,  .     <code>onPause</code>   . </p><br><pre> <code class="java hljs"> Observable.combineLatest(previewObservable, mOnPauseSubject, (state, o) -&gt; state) .firstElement().toObservable() .doOnNext(captureSessionData -&gt; captureSessionData.session.close()) .flatMap(__ -&gt; captureSessionClosedObservable) .doOnNext(cameraCaptureSession -&gt; cameraCaptureSession.getDevice().close()) .flatMap(__ -&gt; closeCameraObservable) .doOnNext(__ -&gt; closeImageReader()) .subscribe(__ -&gt; unsubscribe(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::onError);</code> </pre> <br><p>       ,    API. </p><br><h3 id="vyvody">  findings </h3><br><p>   ,      preview   .       .         .        . </p><br><p> [ <strong>Update</strong> : <a href="https://habrahabr.ru/company/badoo/blog/352318/">  </a> ] </p><br><p>   RxJava           API.   ,   Callback Hell   ,     .     ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330080/">https://habr.com/ru/post/330080/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330070/index.html">Load optimization in the ‚ÄúRemains in warehouses‚Äù task using partitioning in SQL Server</a></li>
<li><a href="../330072/index.html">Zen will not call</a></li>
<li><a href="../330074/index.html">Check Point Security CheckUP - R80.10. Part 3</a></li>
<li><a href="../330076/index.html">Remote work in numbers and diagrams</a></li>
<li><a href="../330078/index.html">How we improved TFS</a></li>
<li><a href="../330082/index.html">Rethinking JavaScript: break and functional approach</a></li>
<li><a href="../330084/index.html">How old are you? I'm 11</a></li>
<li><a href="../330086/index.html">Preview RamblerFront & # 1</a></li>
<li><a href="../330088/index.html">All Flash Isilon NAS: Scalable Storage for Unstructured Data</a></li>
<li><a href="../330090/index.html">How did the intro on 64k</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>