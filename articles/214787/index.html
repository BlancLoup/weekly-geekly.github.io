<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About customization of information systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The main activity of our company is the development of corporate information systems. In addition to custom systems, we make two replicable products. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About customization of information systems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e24/13c/568/e2413c5688d4e5a056282c2e50d70795.jpg" width="600" height="399"><br><br>  The main activity of our company is the development of corporate information systems.  In addition to custom systems, we make two replicable products.  Of course, we try to ensure that our products are as comfortable and functional as possible.  However, in real life, each business has its own characteristics and is not always ready to put up with the standard features of the system.  There is a task of finalizing the solution for a specific client and his further support.  What are the approaches to the organization of the scalable product architecture?  What problems may arise during development?  What did we do?  All of this below. <br><a name="habracut"></a><br><h2>  Possible approaches </h2><br>  To begin with, let us clarify that we call a ‚Äúproject-extension‚Äù or simply ‚Äúextension‚Äù a product with modifications made for a specific customer.  Now consider some of the possible approaches to product expansion: <br><div class="spoiler">  <b class="spoiler_title">Separate brunch in the repository for each expansion project</b> <div class="spoiler_text">  Perhaps this thought is the first one that comes to mind, because branching off from the main product and making changes to the new brunch is the fastest way to achieve the desired result.  The only question is the price that will have to be paid for this speed. <br><br>  After the development and implementation of an information system, the longest and often the most painful phase of the life cycle begins - support.  In the case of an expansion project, this phase can become doubly unpleasant, because the customer will have to supply not only new features, which are implemented specifically for him, but also new versions of the product on which the extension is based.  In order for the project to have changes from the new version of the product, one way is seen - merge changes from the main branch to the expansion brunch.  But imagine how hard it will be, and how many potential errors can occur if the same code segment has changed a lot in both branches. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You can, of course, immediately think about future transfers to the new version of the product and organize the code in such a way that all specific changes will be located as far as possible from the code of the main product.  In an ideal world, this would have worked, but you and I live in a harsh reality, where the deadline for completing a task can often be announced as ‚Äúyesterday‚Äù, and the project is not a compact team of class professionals, but a battalion of yesterday‚Äôs students.  In such situations, people rarely think about architecture and follow the path of least resistance - I found a place to be corrected, deleted the old, wrote a new one.  This, by the way, leads to another big problem - the logic of expansion is mixed with the logic of the product. <br><br>  Bottom line: this approach is the most flexible, as it allows you to change absolutely any part of the product, but only the first couple of updates will have to rejoice at flexibility.  Subsequently, the enormous difficulties will be delivered by the support of the extension and its translation to new versions of the product.  Moreover, the longer the information system lives, the more time-consuming support will become. </div></div><br><div class="spoiler">  <b class="spoiler_title">Using dynamic attributes (Entity-Attribute-Value model)</b> <div class="spoiler_text">  The Entity-Attribute-Value (or Open Schema) model can be used with the standard relational model to dynamically define and store the values ‚Äã‚Äãof new entity attributes.  When using the EAV model, attribute values ‚Äã‚Äãare usually written in one table of three columns.  As you can guess, their names are Entity, Attribute and Value: <br><ul><li>  Entity - stores the link to the object, the field of which we describe.  This is usually an entity identifier; </li><li>  Attribute - link to attribute definition (about it below); </li><li>  Value - the actual value of the attribute. </li></ul><br>  A mandatory component of the schema is also a table that stores the description of the metadata for the attributes: <br><ul><li>  attribute type; </li><li>  restrictions (field length, regular expression to which the value must correspond, etc.); </li><li>  component to display in the UI; </li><li>  The order of the component in the UI </li></ul><br>  To use this model in a product, you need to do 2 things: <br><ol><li>  Implement the metadata task mechanism, with which we can, for example, specify that a new attribute ‚ÄúDate of termination‚Äù is added to entities of the ‚ÄúContract‚Äù type, the field type is ‚ÄúDate‚Äù, the component to be displayed is DateField. </li><li>  Implement mechanisms for displaying and entering dynamic attribute values ‚Äã‚Äãon the required product screens.  The mechanism should find a possible set of attributes for a given entity in a table with a description of metadata, display components for editing them, and then search for and display their values ‚Äã‚Äãin the data table, saving them when the screen is closed. </li></ol><br>  The most important advantage of the approach is the absence of the need to create an expansion project.  The basic product is delivered to the customer and at the stage of setting up or even operating, any number of dynamic attributes in the entities are established. <br><br>  Further on the disadvantages.  First, it is the limited application.  The EAV model will only add attributes to the entity and display them in a predetermined location on the screen.  No more.  About changing the functionality, tricky UI-components are out of the question. <br><br>  Secondly, the EAV model creates a large additional load on the database server.  To load a single instance of an entity without links, you need to read instead of one or several rows of a table.  To load a list of instances, for example, into a table on a UI, you generally need N + 1 queries, or joins by the number of columns of the table.  Considering that the database in corporate systems is often the slowest and most poorly scalable element, such additional load can simply kill the system. <br><br>  Third, again, because of the structure of the database, it will be quite difficult to sample data for reports ‚Äî instead of writing ordinary SQL, relational data will require much more complex queries. </div></div><br><div class="spoiler">  <b class="spoiler_title">Plug-in architecture</b> <div class="spoiler_text">  This architecture allows you to store additional functionality in separate artifacts - plug-ins.  If your customer wants some new specifics, then you give him a base product, write a plug-in, plug it in and be done.  To use plug-ins in the product must be declared extension points.  What it is?  If it is simple, then these are certain places in the code.  In these places, loaded plug-ins are sorted out, it is analyzed whether there is logic in the plug-ins intended for this extension point, and if such logic is found, it is executed.  Examples of extension points: menu item, command command, button on toolbar, new screen. <br><br>  Such a frequently used option of extending the functionality, such as the description of logic and event handlers in external scripts, can also be attributed to variations of plug-ins, since  Scripts are called and executed by certain points of the program. <br><br>  Plug-in architecture allows you to store all the new functionality separately from the product, which is an important advantage of it.  The complete physical separation of the product and the plug-ins makes the process of updating the product version or the plug-in very simple - just replace the updated component. <br><br>  But here, unfortunately, there are drawbacks.  For some products, they will be insignificant, for some may cause the impossibility of using the plug-in architecture.  The fact is that the plugin can expand the system only in the place where the extension point is defined.  Undoubtedly, there is a class of products, where in principle there are few such places and all of them are predetermined, but there is also a huge group for which it is almost impossible to predict what will need to be expanded tomorrow.  An analysis of potential expandable sites can be a very resource-intensive exercise, and as a result, it still turns out to be not entirely accurate.  In addition, extension points are a complication of the main code, which is always fraught with errors and maintenance complexity.  Approach to the definition of expansion points in the main product must be very thoughtful. </div></div><br><h2>  How we do it </h2><br>  We have launched two replicable products on the market: ECM (or in more usual terms, electronic document management system, EDMS) <a href="http://www.tezis-doc.ru/">THESIS</a> and the system for automating the <a href="http://www.sherlocktaxi.com/">Sherlock</a> taxi business.  From the very beginning it was obvious: in order to provide a specific client with the most convenient system, product refinements will be required, and therefore the product should be based on an easily extensible architecture. <br><br>  Starting work on a new extension, we often did not even anticipate into which ‚Äúmonster‚Äù (in a good sense of the word) this project could escalate.  A common occurrence is when what began as a small customization ends with almost completely rewritten business processes and additional logic on a good half of the screens.  In addition, the product can be expanded with new functionality, quite sufficient for an independent system.  As an example - in the project expansion TEZIS for a large distributed company, automation of the treasury activity, evaluation of the performance of employees and some more difficult modules appeared. <br><br>  The variety of requirements, their volume and unpredictability did not allow using any of the methods described above.  On top of that, product versions are coming out fairly regularly.  This makes it imperative that you maximize the transfer of an expansion project to a new version of the product. <br><br>  How do we solve the problem of creating and maintaining extensions? <br><br><h3>  Our expansion project </h3><br>  Most of our company's projects were created using the CUBA platform.  We have already written about it in one of the past <a href="http://habrahabr.ru/company/haulmont/blog/204834/">articles</a> .  In order to understand how the expansion projects are organized, you first need to deal with the device of the platform itself. <br><br>  In short, CUBA is a set of modules, each of which provides a specific functionality: <br><ul><li>  cuba - the core of the application, contains all the infrastructure, tools for organizing business logic, a library of visual components, a security subsystem, etc. </li><li>  reports - report generation subsystem </li><li>  fts - full-text search subsystem </li><li>  charts - chart output subsystem </li><li>  workflow - business process management subsystem </li><li>  ccpayments - credit card subsystem </li></ul><br>  Each subsystem can contain persistent entities, screens and services with business logic. <br><br>  When creating a new project, in its build script, the dependencies of those basic modules of the platform, the functionality of which is necessary, are written.  After that, using entities, screens and services of the connected modules, we begin to implement the project.  Physically, platform modules are jar files, and the project installed on the server is a regular Java web application. <br><br>  When you need to expand an existing product on the platform, we do this: we create a new project, but in its build script we indicate the dependence not on the platform modules, but on the product being expanded.  The product itself actually acts as a platform for development. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/705/88a/089/70588a089fbe8c73973564e56d4e67e5.png"><br>  Now inside the project-extension you can create new objects of the domain model, describe the new user interface as in the most ordinary project on the CUBA platform.  All the functionality of the underlying modules to the developer is still available. <br><br>  The most obvious advantage is that all new logic is stored in a separate expansion project.  You can always see exactly what and when you wrote in the current extension.  The approach does not limit the developer in any way in the type of new functionality, as the plug-in architecture and EAV do. <br><br>  The process of upgrading the extension to a new version of the product is as follows: <ul><li>  you specify a new version of the product in the build scripts and reassemble the extension; </li><li>  if only a stable product API was used in the extension, then that's it - launch your advanced product and go ahead; </li><li>  If there are significant changes in the product at those points that you have expanded, then you may need to change the extension code.  As a rule, this happens infrequently, and it is easy to localize the problem.  Bugfix product releases always maintain compatibility with extensions. </li></ul><br>  It is clear that in the expansion it is easy to create new entities, business logic and screens for them.  But how to change what is already in the product?  For example, add a field to a product entity and display it in existing screens? <br><br><h3>  Adding a new attribute to the base product essence </h3><br>  We define a task for ourselves: in the <code>User</code> entity of the base product, we need to add a field for storing the address.  Such requirements are perhaps the most common among our customers.  At once we say that the platform supports the model of dynamic attributes about which it was written above, but in practice this option is rarely used - the speed of data sampling and the ease of generating reports are almost always an important requirement. <br>  Actually about the alternative method of adding an attribute.  OpenJPA is used as the ORM platform.  The entity declaration in the product is as follows: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span>(name = <span class="hljs-string"><span class="hljs-string">"product$User"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"PRODUCT_USER"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StandardEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"LOGIN"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String login; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"PASSWORD"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String password; <span class="hljs-comment"><span class="hljs-comment">//getters and setters }</span></span></code> </pre><br>  As you can see, this is a standard description for JPA of the entity and mapping for the table and database columns. <br><br>  Create an entity heir in an extension project: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span>(name = <span class="hljs-string"><span class="hljs-string">"ext$User"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Extends</span></span>(User.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExtUser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"ADDRESS"</span></span>, length = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String address; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> address; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String address)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.address = address; } }</code> </pre><br>  The inheritance mechanism is standard for OpenJPA with the exception of the <code>@Extends</code> annotation, which is of most interest.  It is she who declares that the <code>ExtUser</code> class will be universally used instead of the User class. <br><br>  Now all operations for creating a <code>User</code> entity will create an instance of an extended entity: <br><br><pre> <code class="java hljs">User user = metadata.create(User.class); <span class="hljs-comment"><span class="hljs-comment">//  ExtUser</span></span></code> </pre><br>  The operations of extracting data from the database will also return instances of the new entity.  For example, in the base product, a user search service is declared by name, which returns the result of the following JPQL query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> product$<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.name = :<span class="hljs-keyword"><span class="hljs-keyword">name</span></span></code> </pre><br>  Without the <code>@Extends</code> annotation <code>@Extends</code> we would have a collection of <code>User</code> objects as output, and in order to get the address from <code>ExtUser</code> would have to re-read the result of the previous query from the database.  But using the override information provided by the <code>@Extends</code> annotation, the platform mechanisms will pre-transform the query and return us the collection of objects of the <code>ExtUser</code> extended entity.  Moreover, if some other entities had references to <code>User</code> , then when the extension is connected, these links will return objects of the <code>ExtUser</code> type, without any change in the source code. <br><br>  Entity redefined.  Now it would be nice to display the new field to the user. <br><br>  The platform screen is a bundle of XML + Java.  XML declaratively describes the UI, the Java controller determines the response to events.  It is clear that there will be no special problems with the redefinition of the Java controller, but with the XML extension a bit more complicated.  Returning to the previous example, adding the <code>address</code> field to the <code>User</code> entity. <br>  The description of the simplest screen layout looks like this: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">window</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datasource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"userDs"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">caption</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"msg://caption"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.haulmont.cuba.gui.app.security.user.edit.UserEditor"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">messagesPack</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.haulmont.cuba.gui.app.security.user.edit"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dsContext</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">datasource</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"userDs"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.haulmont.cuba.security.entity.User"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">view</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user.edit"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">datasource</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dsContext</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">spacing</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fieldGroup</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fieldGroup"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datasource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"userDs"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">column</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"250px"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"login"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">column</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fieldGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"windowActions"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">screen</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"editWindowActions"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">window</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  We see a link to the UserEditor screen controller, the data source declaration (datasource), the fieldGroup component displaying the entity fields, and the frame with the standard actions ‚ÄúOK‚Äù and ‚ÄúCancel‚Äù (windowActions). <br><br>  I don‚Äôt want to duplicate the base screen code in the extension project, so we added the ability to inherit screen XML descriptors to the platform.  This is how the screen heir from the base project looks like: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">window</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">extends</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/com/haulmont/cuba/gui/app/security/user/edit/user-edit.xml"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fieldGroup</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fieldGroup"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">column</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">field</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"address"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">column</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fieldGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">layout</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">window</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In the successor screen, the ancestor is specified (the extends attribute) and only those components are described that should be added to or redefined in the base screen.  It remains only to declare the screen in the configuration file with the identifier of the basic screen: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">screen</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sec$User.edit"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">template</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com/sample/sales/gui/extuser/extuser-edit.xml"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre><br>  Result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e99/f0b/094/e99f0b09440cb7c3c4e90cf54eb6d32c.png"><br><br><h2>  Redefine business logic </h2><br>  As for the redefinition of functionality, everything is quite trivial.  The platform infrastructure is implemented on Spring.  Accordingly, the business logic layer of services is spring-driven beans.  The expansion capabilities provided by the framework are more than enough to override the desired business logic.  To demonstrate this clearly, again a small example.  Suppose there is a component on the middle layer in the base product that performs the price calculation: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ManagedBean</span></span>(<span class="hljs-string"><span class="hljs-string">"product_PriceCalculator"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PriceCalculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//price calculation } }</span></span></code> </pre><br>  In order to replace the pricing algorithm in the expansion project, we take 2 simple steps: <br><br>  Create a descendant of the component to be redefined: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExtPriceCalculator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PriceCalcuator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//modified logic goes here } }</span></span></code> </pre><br>  Register the class in the Spring configuration file with the ID of the bean from the base product: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"product_PriceCalculator"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.sample.extension.core.ExtPriceCalculator"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre><br>  Now the Spring container will always return an ExtPriceCalculator instance. <br><br><h2>  Topic Override </h2><br>  We have dealt with the modification of entities, screen components and business logic.  Next in line is the visual theme. <br><br>  Screens created using the platform work in web and desktop clients.  At the moment, the use of web clients prevails in our country; therefore, speaking of customization of the topic, we will consider them. <br><br>  To implement the web UI, we have chosen the popular framework Vaadin.  Vaadin allows you to describe threads on SCSS.  The description of styles for a new theme on SCSS is in itself much more pleasant than on pure CSS.  We have made the process of creating a topic even less time consuming, taking out a lot of parameters to variables. <br><br>  Procurement for a new theme is created in 2 clicks with the help of our development studio.  The new theme imports the styles of the base theme of the platform, the developer only needs to redefine the necessary styles and variables.  Many customers want to see the information system in the corporate colors of their company.  Our approach to expanding themes allows them to easily achieve this. <br><br>  In the expansion project, the developer is able to connect new visual components.  A large number of components are available in the Vaadin addon repository.  If the necessary component was not found there, then you can write it yourself. <br><br>  Examples of various visual topics: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/111/ed3/627/111ed36276060d5bfb6c9c156e742fc0.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/443/118/3b5/4431183b58b01bffe44d727ed7d65e22.jpg"><br><br><h2>  Conclusion </h2><br>  If you found our approach interesting, you can try the <a href="http://www.cuba-platform.com/">CUBA</a> platform yourself.  Creating a product on the platform, you automatically get the opportunity to customize it in the manner described.  Always welcome feedback and comments! <br><br>  PS The author of the title photo - Ilya Varlamov.  You can find even more luxury Pakistani trucks on his <a href="http://zyalt.livejournal.com/496563.html">blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/214787/">https://habr.com/ru/post/214787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../214775/index.html">Free HTML5 Font Editor</a></li>
<li><a href="../214777/index.html">Sochi 2014 mobile apps: how to show megabytes of results to users</a></li>
<li><a href="../214779/index.html">Automate mouse clicks on Linux: xdotool</a></li>
<li><a href="../214781/index.html">Collect millions of likes or task queues in Node.js</a></li>
<li><a href="../214783/index.html">PhD thesis. Instructions for clearing scientific stubs. Part 2</a></li>
<li><a href="../214789/index.html">Configure the Site-to-Site IPsec tunnel between the Windows Azure cloud and the D-Link DFL-210</a></li>
<li><a href="../214793/index.html">This post is written by the author who does not read the comments, please do not write them.</a></li>
<li><a href="../214795/index.html">Inside stories Mt. Gox</a></li>
<li><a href="../214797/index.html">The logic of thinking. Part 6. The system of projections</a></li>
<li><a href="../214799/index.html">Creating a game on your eyes - part 5: Subtotal (prototype)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>