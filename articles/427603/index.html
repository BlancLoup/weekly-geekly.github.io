<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to finally start writing tests and not regret it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Coming to a new project, I regularly come across one of the following situations: 



1. There are no tests at all. 
2. There are few tests, they are ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to finally start writing tests and not regret it</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/company/custis/blog/427603/"><img src="https://habrastorage.org/webt/vr/v7/q_/vrv7q_kwfiqd5f7qx7jxwukv62g.jpeg"></a> <br><br>  Coming to a new project, I regularly come across one of the following situations: <br><br><ol><li>  There are no tests at all. </li><li>  There are few tests, they are rarely written and do not run on an ongoing basis. </li><li>  Tests are present and included in CI (Continuous Integration), but they do more harm than good. </li></ol><br>  Unfortunately, it is precisely the latter scenario that is often led by serious attempts to begin to introduce testing in the absence of appropriate skills. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What can be done to change the situation?  The idea of ‚Äã‚Äãusing tests is not new.  At the same time, most of the tutorials resemble the famous picture about how to draw an owl: connect JUnit, write the first test, use the first mock - and go!  Such articles do not answer questions about what tests you need to write, what you should pay attention to and how to live with all this.  Hence the idea of ‚Äã‚Äãthis article.  I tried to briefly summarize my experience in implementing tests in different projects in order to facilitate this path for everyone. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/7v/m-/ra7vm-kgn__gsmaeg6xg7aud4ey.jpeg"></div><br>  There are more than enough introductory articles on this topic, so we will not repeat and try to enter from the other side.  In the first part, we will dispel the myth that testing bears only additional costs.  It will show how creating quality tests can in turn speed up the development process.  Then, using the example of a small project, the basic principles and rules that should be followed in order to realize this benefit will be considered.  Finally, the final section will give specific recommendations for implementation: how to avoid typical problems when tests begin, on the contrary, to significantly slow down the development. <br><br>  Since my main specialization is Java backend, the examples will use the following technology stack: Java, JUnit, H2, Mockito, Spring, Hibernate.  In this case, a significant part of the article is devoted to general issues of testing and tips in it are applicable to a much wider range of tasks. <br><br>  However, be careful!  Tests are very addictive: once you learn how to use them, you can no longer live without them. <br><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  <a href="https://habr.com/ru/company/custis/blog/427603/">Tests vs development speed</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Running code in any place</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Re-run tests</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Debugging</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Efficiency</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">From theory to practice</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Task</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Domain model</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Project structure</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Integration tests</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Unit tests</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Recommendations for implementation</a> <br>  <a href="https://habr.com/ru/company/custis/blog/427603/">Conclusion</a> </div></div><br><a name="TestsVsSpeed"></a><h2>  Tests vs development speed </h2><br>  The main questions that arise when discussing the introduction of testing: how long will it take to write tests and what advantages will it have?  Testing, like any other technology, will require serious efforts for development and implementation, so at first no significant benefit should be expected.  As for time, they are highly dependent on a specific team.  However, it is not worth counting on less than 20‚Äì30% of additional coding costs.  Less is simply not enough to achieve at least some result.  Waiting for instant returns is often the main reason for curtailing this activity even before the tests benefit. <br><br>  But what kind of efficiency then?  Let's discard the lyrics about the difficulties of implementation and see what specific time-saving opportunities are opened up by testing. <br><br><a name="CodeRun"></a><h3>  Running code in any place </h3><br>  In the absence of tests in the project, the only way to start is to raise the entire application.  It is good if it takes about 15‚Äì20 seconds, but cases of large projects in which a full launch can take from several minutes are far from rare.  What does this mean for developers?  A substantial part of their working time will be composed of these short waiting sessions, during which it is impossible to continue working on the current task, but at the same time there is too little time to switch to something else.  Many have come across such projects at least once, where the code written in an hour requires many hours of debugging due to long restarts between corrections.  In tests, you can limit the launch of small parts of the application, which will significantly reduce the waiting time and increase the productivity of work on the code. <br><br>  In addition, the ability to run code in an arbitrary location leads to more thorough debugging.  Often, verification of even the main positive usage scenarios through the application interface requires serious efforts and time.  The presence of tests allows for detailed verification of specific functionality much easier and faster. <br><br>  Another plus is the ability to control the size of the unit being tested.  Depending on the complexity of the logic being tested, you can limit yourself to one method, a class, a group of classes that implement some functionality, a service, and so on, up to automating the testing of the application as a whole.  This flexibility allows you to unload high-level tests from many parts due to the fact that they will be tested at lower levels. <br><br><a name="RepeatedRun"></a><h3>  Re-run tests </h3><br>  This plus is often cited as the essence of test automation, but let's look at it from a less common angle.  What new opportunities for developers it opens? <br><br>  First, every new developer who comes to the project will be able to easily run the available tests in order to understand the logic of the application using examples.  Unfortunately, the importance of this is greatly underestimated.  In modern conditions, the same people rarely work on a project for more than 1-2 years.  And since teams consist of several people, the appearance of a new participant every 2-3 months is a typical situation for relatively large projects.  Particularly difficult projects are experiencing the change of entire generations of developers!  The ability to easily run any part of the application and look at the behavior of the system at times simplifies immersing new programmers into the project.  In addition, a more detailed study of the logic of the code reduces the number of errors at the output and the time to debug them in the future. <br><br>  Secondly, the ability to easily verify that the application is working correctly, opens the way for continuous refactoring (Continuous Refactoring).  This term, unfortunately, is much less popular than CI.  It means that refactoring can and should be done with every revision of the code.  It is the regular adherence to the notorious scout rule ‚Äúleave the parking space cleaner than it was before your arrival‚Äù, allows you to avoid degradation of the code base and guarantees the project a long and happy life. <br><br><a name="Debugging"></a><h3>  Debugging </h3><br>  Debugging has already been mentioned in the preceding paragraphs, but this point is so important that it deserves more careful consideration.  Unfortunately, there is no reliable way to measure the relationship between the time spent writing code and debugging it, since these processes are almost inseparable.  Nevertheless, the availability of high-quality tests in the project significantly reduces debugging time, up to the almost complete absence of the need to run a debugger. <br><br><a name="Efficiency"></a><h3>  Efficiency </h3><br>  All of the above can provide significant time savings for the initial debugging of the code.  With the right approach, this alone will pay for all additional development costs.  The remaining testing bonuses - improving the quality of the code base (a poorly designed code is hard to test), reducing the number of defects, being able to make sure that the code is correct at any time, etc. - will get almost free. <br><br><a name="FromTheoryToPractice"></a><h2>  From theory to practice </h2><br>  In words, it all looks good, but let's get down to business.  As mentioned earlier, there is more than enough information on how to perform the initial setup of the test environment.  Therefore, we will immediately proceed to the finished project.  <a href="https://github.com/achuzhmarov/test-tutorial">Sources here.</a> <br><br><a name="Task"></a><h3>  Task </h3><br>  As a sample problem, consider a small fragment of the online store backend.  Let's write a typical API for working with products: creating, receiving, editing.  As well as a couple of methods for working with clients: changing the "favorite product" and calculating bonus points on request. <br><br><a name="DomainModel"></a><h3>  Domain model </h3><br>  In order not to overload the example, we restrict ourselves to the minimum set of fields and classes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wc/pn/pz/wcpnpz94fmrb-av0-wkkuu4l2wi.jpeg"></div><br><br>  Customer has a login, a link to a favorite product and a flag indicating whether it is a premium customer. <br><br>  A product (Product) has a name, price, discount, and a flag indicating whether it is currently advertised. <br><br><a name="ProjectStructure"></a><h3>  Project structure </h3><br>  The structure of the main project code is as follows. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/qa/m3/ksqam31c3vwkzdfwkmi8r7o3ggk.jpeg"></div><br><br>  Classes are divided into layers: <br><br><ul><li>  Model - domain model of the project; </li><li>  Jpa - repositories for working with databases based on Spring Data; </li><li>  Service - application business logic; </li><li>  Controller - controllers that implement the API. </li></ul><br>  Structure of unit tests. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/_1/mi/i3_1micxy4kvvlb6dlgihfmmng0.jpeg"></div><br><br>  Classes of tests are in the same packages as the original code.  Additionally, a package was created with builders for the preparation of test data, but more on that below. <br><br>  Conveniently separate unit tests and integration tests.  They often have different dependencies, and for comfortable development it should be possible to run either one or the other.  This can be achieved in different ways: convention naming, modules, packages, sourceSets.  The choice of a particular method is only a matter of taste.  In this project, integration tests lie in a separate sourceSet - integrationTest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/1w/z7/qq1wz7n9tq77_zromu01ofx9cns.jpeg"></div><br><br>  Like unit tests, classes with integration tests are in the same packages as the original code.  Additionally, there are base classes that help get rid of duplication of configuration and, if necessary, contain useful universal methods. <br><br><a name="IntegrationTests"></a><h3>  Integration tests </h3><br>  There are different approaches to what tests to start with.  If the checked logic is not very complicated, you can immediately move on to integration (they are sometimes called acceptance).  Unlike unit tests, they make sure that the application as a whole is working correctly. <br><br>  <b>Architecture</b> <br><br>  First you need to decide on what level of integration checks will be performed.  Spring Boot provides complete freedom of choice: you can raise part of the context, the entire context, and even a full-fledged server accessible from tests.  As the size of the application increases, this issue becomes more complex.  Often you have to write different tests at different levels. <br><br>  A good starting point would be controller tests without starting the server.  In relatively small applications, it is quite acceptable to raise the entire context as a whole, since by default it is reused between tests and initialized only once.  Consider the basic methods of the <code>ProductController</code> class: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"new"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.createProduct(product); } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.getProduct(productId); } <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}/edit"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId, @RequestBody Product product) </span></span>{ productService.updateProduct(productId, product); }</code> </pre> <br>  The question of error handling leave aside.  Suppose that it is implemented outside based on the analysis of the exceptions thrown out.  The code of the methods is very simple, their implementation in the <code>ProductService</code> service is not much more complicated: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span>(readOnly = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(product)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId, Product product)</span></span></span><span class="hljs-function"> </span></span>{ Product dbProduct = productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); dbProduct.setPrice(product.getPrice()); dbProduct.setDiscount(product.getDiscount()); dbProduct.setName(product.getName()); dbProduct.setIsAdvertised(product.isAdvertised()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(dbProduct); }</code> </pre> <br>  The <code>ProductRepository</code> repository does not contain its own methods at all: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Everything hints at the fact that unit tests are not needed by these classes simply because the whole chain can be easily and efficiently checked with several integration tests.  Duplication of the same checks in different tests makes debugging more difficult.  In the event of an error in the code, not one test will now fall, but 10‚Äì15 at once.  This in turn will require further analysis.  If there is no duplication, then the only dropped test is likely to immediately indicate an error. <br><br>  <b>Configuration</b> <br><br>  For convenience, select the base class <code>BaseControllerIT</code> , which contains the Spring configuration and a pair of fields: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span>(webEnvironment = SpringBootTest.WebEnvironment.NONE) <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseControllerIT</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ProductRepository productRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> CustomerRepository customerRepository; }</code> </pre> <br>  Repositories are moved to the base class in order not to clutter up the test classes.  Their role is only auxiliary: preparing data and checking the state of the database after the controller is working.  If you increase the size of the application, this may cease to be convenient, but for a start it is quite suitable. <br><br>  The basic configuration of Spring is defined by the following lines: <br><br>  <code>@SpringBootTest</code> - used to set the context of the application.  <code>WebEnvironment.NONE</code> means that the web context should not be raised. <br><br>  <code>@Transactional</code> - wraps all class tests in a transaction with automatic rollback to save the state of the database. <br><br>  <b>Test structure</b> <br><br>  Let's move on to the minimalist test suite for the <code>ProductController</code> class - <code>ProductControllerIT</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct_productSaved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); Product createdProduct = productController.createProduct(product); Product dbProduct = productRepository.getOne(createdProduct.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  The test code should be extremely simple and clear at first glance.  If this is not the case, then most of the advantages of the tests described in the first section of the article are lost.  It is good practice to divide the test body into three parts that are visually separated from each other: data preparation, calling the method under test, validation of results.  It is very desirable that the test code be placed on the screen entirely. <br><br>  Personally, it seems to me more visual when the test values ‚Äã‚Äãfrom the data preparation section are used later in the checks.  Alternatively, one could explicitly compare objects, like this: <br><br><pre> <code class="java hljs">assertEquals(product, dbProduct);</code> </pre> <br>  In another test for updating product information ( <code>updateProduct</code> ) it is clear that creating data has become a bit more difficult and to preserve the visual integrity of the three parts of the test, they are separated by two line breaks in a row: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct_productUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product updatedProduct = product(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); updatedProduct.setId(product.getId()); productController.updateProduct(product.getId(), updatedProduct); Product dbProduct = productRepository.getOne(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  Each of the three parts of the test can be simplified.  Test builders are great for preparing data. They contain logic for creating objects that is convenient for use from tests.  Too complex method calls can be made into helper methods inside test classes, hiding some of the parameters that are irrelevant for this class.  To simplify complex checks, you can also write auxiliary functions or implement your own matchers.  The main thing with all these simplifications is not to lose the visibility of the test: everything should be clear at a glance at the main method, without the need to go deeper. <br><br>  <b>Test builders</b> <br><br>  Test builders deserve special attention.  Encapsulation of object creation logic simplifies test maintenance.  In particular, filling in the non-relevant fields of this test model can be hidden inside the builder.  To do this, you do not need to create it directly, but use a static method that fills the missing fields with default values.  For example, in the case of the emergence of new required fields in the model, they can be easily added to this method.  In <code>ProductBuilder</code> it looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ProductBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProductBuilder() .name(name) .advertised(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .price(<span class="hljs-string"><span class="hljs-string">"0.00"</span></span>); }</code> </pre> <br>  <b>Test name</b> <br><br>  It is extremely important to understand what is specifically tested in this test.  For clarity, it is best to answer this question in its title.  Using the example of tests for the <code>getProduct</code> method, <code>getProduct</code> consider the naming convention used: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_oneProductInDb_productReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product result = productController.getProduct(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, result.getName()); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_twoProductsInDb_correctProductReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Product result = productController.getProduct(product1.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>, result.getName()); }</code> </pre> <br>  In general, the test method header consists of three parts, separated by an underscore: the name of the test method, the script, the expected result.  However, common sense has not been canceled, and it may be justified to drop some parts of the name if they are not needed in this context (for example, the script in a single test for creating a product).  The purpose of such naming is to ensure that the essence of each test is understandable without studying the code.  This makes the test results window as clear as possible, and it usually starts working with tests. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/0k/p9/gu0kp9p5hdbswo4i8d6ti2sy1qi.jpeg"></div><br><br>  <b>findings</b> <br><br>  That's all.  For the first time, a minimalist set of four tests is enough to test the methods of the <code>ProductController</code> class.  In the case of bugs, you can always add the missing tests.  In this case, the minimum number of tests significantly reduces the time and effort to support them.  In turn, this is critical in the process of testing implementation, since the first tests usually are not of the best quality and create many unexpected problems.  At the same time, such a test set is quite enough to get the bonuses described in the first part of the article. <br><br>  It is worth noting that such tests do not check the web layer of the application, but often this is not required.  If necessary, you can write separate tests for a web layer with a stub instead of a base ( <code>@WebMvcTest</code> , <code>MockMvc</code> , <code>@MockBean</code> ) or use a full-fledged server.  The latter may make debugging more difficult and difficult to work with transactions, since the test will not be able to control the server‚Äôs transaction.  An example of such an integration test can be viewed in the class <code>CustomerControllerServerIT</code> . <br><br><a name="UnitTests"></a><h3>  Unit tests </h3><br>  Unit tests have several advantages over integration tests: <br><br><ul><li>  The run takes milliseconds; </li><li>  The small size of the tested unit; </li><li>  It is easy to implement a check of a large number of variants, since when you call a method directly, the preparation of data is greatly simplified. </li></ul><br>  Despite this, unit tests by their nature cannot guarantee the performance of the application as a whole and do not allow to avoid writing integration ones.  If the logic of the tested unit is simple, duplication of integration checks with unit tests will not bring any benefits, but will only add more code for support. <br><br>  The only class in this example that deserves unit testing is <code>BonusPointCalculator</code> .  Its distinctive feature is a large number of branches of business logic.  For example, it is assumed that the buyer receives, with bonuses, 10% of the value of the product, multiplied by no more than 2 multipliers from the following list: <br><br><ul><li>  The product costs more than 10,000 (√ó 4); </li><li>  The product participates in an advertising campaign (√ó 3); </li><li>  The product is a customer‚Äôs favorite product (√ó 5); </li><li>  The client has a premium status (√ó 2); </li><li>  If the client has a premium status and buys a ‚Äúfavorite‚Äù product, instead of the two designated multipliers, one is used (√ó 8). </li></ul><br>  In real life, of course, it would be worthwhile to design a flexible universal mechanism for calculating these bonuses, but to simplify the example we restrict ourselves to a fixed implementation.  The code for calculating multipliers looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;BigDecimal&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateMultipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, Product product)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;BigDecimal&gt; multipliers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.getFavProduct() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; customer.getFavProduct().equals(product)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_FAVORITE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { multipliers.add(FAVORITE_MULTIPLIER); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.isAdvertised()) { multipliers.add(ADVERTISED_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.getPrice().compareTo(EXPENSIVE_THRESHOLD) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { multipliers.add(EXPENSIVE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multipliers; }</code> </pre> <br>  A large number of options leads to the fact that two or three integration tests are no longer limited here.  A minimalist set of unit tests is perfect for debugging such functionality. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bk/jw/ai/bkjwai9dy1mrxxarxncx6jgfehq.jpeg"></div><br><br>  The corresponding test suite can be viewed in the <code>BonusPointCalculatorTest</code> class.  Here are some of them: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_oneProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); assertEquals(expectedBonus, bonus); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_favProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).favProduct(product).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).addMultiplier(FAVORITE_MULTIPLIER).build(); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  It is worth noting that the tests refer to the public API of the class, the <code>calculate</code> method.  Testing a class contract, rather than implementing it, allows you to avoid test failures due to non-functional changes and refactoring. <br><br>  Finally, when we checked the internal logic with unit tests, we don‚Äôt have to take all these details into the integration logic.  In this case, one more or less representative test is enough, for example: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateBonusPoints_twoProductTypes_correctValueCalculated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"10.00"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); customerRepository.save(customer); Map&lt;Long, Long&gt; quantities = mapOf(product1.getId(), <span class="hljs-number"><span class="hljs-number">1L</span></span>, product2.getId(), <span class="hljs-number"><span class="hljs-number">2L</span></span>); BigDecimal bonus = customerController.calculateBonusPoints( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalculateBonusPointsRequest(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, quantities) ); BigDecimal bonusPointsProduct1 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); BigDecimal bonusPointsProduct2 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).quantity(<span class="hljs-number"><span class="hljs-number">2</span></span>).build(); BigDecimal expectedBonus = bonusPointsProduct1.add(bonusPointsProduct2); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  As in the case of integration tests, the set of unit tests used is very small and does not guarantee the complete correctness of the application.  Nevertheless, its presence significantly increases confidence in the code, facilitates debugging and gives other bonuses listed in the first part of the article. <br><br><a name="ImplementationConsiderations"></a><h2>  Recommendations for implementation </h2><br>  I hope the previous sections were enough to convince at least one developer to try to start using tests in your project.  This chapter will briefly list the main recommendations that will help to avoid serious problems and lead to a reduction in the initial costs of implementation. <br><br>  <b>Try to start the implementation of tests on the new application.</b>  To write the first tests in a large legacy project will be much more difficult and will require greater qualification than in the newly created one.  Therefore, if possible, it is better to start with a small new application.  If new high-grade applications are not expected, you can try to develop some useful utility for internal use.  The main thing is that the task be more or less realistic - the invented examples will not give a full-fledged experience. <br><br>  <b>Set up a regular test run.</b>  If tests do not run on a regular basis, then they not only cease to perform their main function - checking the correctness of the code - but also quickly become obsolete.  Therefore, it is extremely important to set up at least a minimal CI pipeline with automatic start of tests each time the code is updated in the repository. <br><br>  <b>Do not chase the cover.</b>  As in the case of any other technology, the first time the tests will be not very good quality.  Relevant literature (links at the end of the article) or a competent mentor can help here, but this does not negate the need for self-stuffing cones.  Tests in this regard are similar to the rest of the code: to understand how they will affect the project, it will only work after being with them for a while.  Therefore, in order to minimize damage, at first it is better not to chase after the number and beautiful figures like one hundred percent coverage.  Instead, it should be limited to the main positive scenarios for its own functionality of the application. <br><br>  <b>Do not get carried away with unit tests.</b>  In continuation of the topic ‚Äúquantity vs quality‚Äù, it should be noted that at first you should not get carried away with honest unit tests, because this can easily lead to excessive specification of the application.  In turn, this will become a serious inhibiting factor in the subsequent refactoring and refinement of the application.  Unit tests should be used only if there is a complex logic in a particular class or group of classes, which is inconvenient to check at the level of integration. <br><br>  <b>Do not get carried away with the stubs of the classes and methods of the application.</b>  Stubs (stub, mock) is another tool that requires a balanced approach and balance.  On the one hand, the complete isolation of the unit allows you to focus on the logic being tested and not think about the rest of the system.  On the other hand, this will require additional development time and, as with the use of unit tests, may lead to excessive specification of behavior. <br><br>  <b>Untie the integration tests from external systems.</b>  A very common mistake in integration tests is the use of a real database, message queues, and other systems external to the application.  Of course, the ability to run a test in a real environment is useful for debugging and development.  Such tests in small quantities can make sense, especially to run interactively.  However, their widespread use leads to a number of problems: <br><br><ol><li>  To run the tests will need to customize the external environment.  For example, install a database on each machine where the application will be built.  This will make it more difficult for new developers to enter the project and set up CI. </li><li>  The state of external systems may differ on different machines before running the tests.  For example, the database may already contain tables needed by the application with data that are not expected in the test.  This will lead to unpredictable test failures, and their removal will take a considerable amount of time. </li><li>  If there is a parallel work on several projects, it is possible that some projects have an unobvious effect on others.  For example, the specific database settings made for one of the projects can help the functionality of another project to work correctly, which, however, will break when running on a clean database on another machine. </li><li>  Tests are carried out for a long time: a full run can reach tens of minutes.  This leads to the fact that developers no longer run tests locally and look at their results only after sending changes to the remote repository.  This behavior negates most of the advantages of the tests, which were discussed in the first part of the article. </li></ol><br>  <b>Clear the context between integration tests.</b>  Often, in order to speed up the work of integration tests, it is necessary to reuse the same context between them.  This recommendation is given even by the official Spring documentation.  At the same time, the influence of tests on each other should be avoided.  Since they are launched in a random order, the presence of such links can lead to random, unrepeatable errors.  To avoid this, tests should not leave behind any changes in context.  For example, when using a database, for isolation it is usually enough to roll back all the transactions performed in the test.  If the changes in the context cannot be avoided, you can customize its re-creation using the <code>@DirtiesContext</code> annotation. <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensure that tests are performed in a reasonable time.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Even if tests do not depend on real external systems, the time to complete them can easily get out of control. To prevent this from happening, you need to constantly monitor this indicator and take action if necessary. The least that can be done is to single out the slow tests into a separate group so that they do not interfere with work on tasks not related to them. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Try to make the tests as clear and readable as possible.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As already shown in the example, tests should be written in such a way that they do not need to be understood. Time spent learning the test could be spent learning the code. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not focus on TDD (Test-Driven Development).</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TDD is a fairly popular practice, but I do not consider it mandatory, especially in the early stages of implementation. </font><font style="vertical-align: inherit;">In general, the ability to write good tests is not related to the moment at which they are written. </font><font style="vertical-align: inherit;">What is really important is to do primary debugging of the code already on tests, since this is one of the main ways to save time.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The first tests are written, what next? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, you need to carefully monitor the life of the tests in the project and periodically ask yourself questions like the following: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What tests interfere with refactoring and rework (require constant fixes)? </font><font style="vertical-align: inherit;">Such tests need to be rewritten or completely removed from the project and replaced with higher level ones.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What tests often and unpredictably break upon repeated or parallel launch, when running in different environments (computer colleagues, server CI)? </font><font style="vertical-align: inherit;">They also require recycling.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What errors pass by tests? </font><font style="vertical-align: inherit;">For each such bug, it is advisable to add a new test and in the future keep them in mind when writing tests for the same functionality.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What tests work too long? </font><font style="vertical-align: inherit;">We must try to rewrite them. </font><font style="vertical-align: inherit;">If this is not possible, then separate them from the faster ones in order to preserve the possibility of an on-line local run.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additionally, you should pay attention to the advantages of the tests, which were described at the beginning of the article. </font><font style="vertical-align: inherit;">If you don't get them, then something went wrong. </font><font style="vertical-align: inherit;">Regular retrospective is the cheapest way to a steady increase in the quality and effectiveness of the tests used.</font></font><br><br><a name="Conclusion"></a><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At first it is better not to chase the number of tests, but focus on their quality. A huge number of inappropriate unit tests can easily become an anchor pulling a project to the bottom. In addition, the presence of unit tests does not relieve the need to write integration. Therefore, the most effective strategy for the first time is to start with covering the main positive scenarios with integration tests and, if this is not enough, add local checks with unit tests. Over time, feedback will accumulate to help correct errors and get a clearer picture of the effective use of various automated test methods.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope, among those who have read, there will be those whose delicate strings of the soul will be touched by my graphomania, and several more projects with good and effective tests will appear in the world! </font></font><br><br> <a href="https://github.com/achuzhmarov/test-tutorial"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project sources on GitHub</font></font></a> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Useful literature</font></font></b> <div class="spoiler_text"> <a href="https://books.google.ru/books/about/Growing_Object_Oriented_Software_Guided.html%3Fid%3DQJA3dM8Uix0C%26source%3Dkp_cover%26redir_esc%3Dy"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Object-Oriented Growing Software, the Guided by the Tests</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , by Steve Freeman, Nat the Pryce </font></font><br> <a href="https://books.google.ru/books/about/The_Art_of_Unit_Testing.html%3Fid%3D2GRRmgEACAAJ%26source%3Dkp_cover%26redir_esc%3Dy"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of The Art of Unit Testing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , of Roy Osherove </font></font><br> <a href="https://books.google.ru/books/about/Test_driven_Development.html%3Fid%3DgFgnde_vwMAC%26redir_esc%3Dy"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Test-driven Development: By Example The</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Kent Beck </font></font><br> <a href="https://books.google.ru/books%3Fid%3DHmrDHwgkbPsC%26dq%3DRefactoring:%2BImproving%2Bthe%2BDesign%2Bof%2BExisting%2BCode%26hl%3Dru%26source%3Dgbs_navlinks_s"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Refactoring: Improving the Design of the Existing Code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , by Martin Fowler</font></font><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/427603/">https://habr.com/ru/post/427603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427589/index.html">Asynchronous WEB in 2018. We write chat on Websocket using Swoole</a></li>
<li><a href="../427591/index.html">Architecture as a burden</a></li>
<li><a href="../427593/index.html">The magic of fast teams in Vivaldi 2.1</a></li>
<li><a href="../427595/index.html">Try Micronaut or Honey, I have reduced the framework</a></li>
<li><a href="../427601/index.html">5 + 1 case where the REST API specification plays a huge role</a></li>
<li><a href="../427605/index.html">How the crowdsourcing platform of Yandex helps train drones and evaluate the quality of services</a></li>
<li><a href="../427607/index.html">Data Center in Switzerland: to work like a clock</a></li>
<li><a href="../427609/index.html">Solving an equation with integer division without enumeration</a></li>
<li><a href="../427611/index.html">A tale about how I updated Yandex MapKit on iOS or maps, money, 2 mapkits</a></li>
<li><a href="../427613/index.html">10 useful blogs for programmers in English</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>