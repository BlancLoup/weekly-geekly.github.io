<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Brochure about Ecto - an interface for working with databases on Elixir</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 Ecto written in Elixir DSL for communication with databases. Ecto is not ORM. Why? Yes, because Elixir is not an object-oriented lang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Brochure about Ecto - an interface for working with databases on Elixir</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/f7e/975/104/f7e975104dc54192bae8157576b895e2.jpg" alt="ecto"></p><br><h2 id="vstuplenie">  Introduction </h2><br><p>  Ecto written in Elixir DSL for communication with databases.  Ecto is not ORM.  Why?  Yes, because Elixir is not an object-oriented language, so Ecto cannot be Object-Relational Mapping (object-relational mapping).  Ecto is an abstraction over databases consisting of several large modules that allow you to create migrations, declare models (schemas), add and update data, and send requests to them. </p><br><p>  If you are familiar with Rails, then for you the closest analogy, of course, is its ORM ActiveRecord.  But these two systems are not copies of each other, and are good at using within their basic languages.  Currently, the current version of Ecto 2 is compatible with PostgreSQL and MySQL.  An earlier version additionally has compatibility with MSSQL, SQLite3 and MongoDB.  Regardless of which DBMS is used, the format of the Ecto functions will always be the same.  Ecto also comes out of the box with Phoenix and is a good standard solution. </p><br><p>  If you decide to expand the brochure, then you are welcome to join the development of this repository <a href="https://github.com/wunsh/ecto-book-ru">https://github.com/wunsh/ecto-book-ru</a> </p><br><h2 id="novshestva-ecto-2x">  Innovation Ecto 2.X </h2><a name="habracut"></a><br><ul><li>  <a href="https://habr.com/ru/post/318358/">Updated Ecto.Changeset Module</a> </li><li>  <a href="https://habr.com/ru/post/318358/">New Subquery / 1 function in the Ecto.Query module</a> </li><li>  <a href="https://habr.com/ru/post/318358/">New insert_all / 3 function in the Ecto.Repo module</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Added many-to-many association</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Improved work with associations</a> </li><li>  <a href="https://habr.com/ru/post/318358/">New preload feature of the assoc / 2 associations in the Ecto module</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Upsert</a> </li><li>  <a href="https://habr.com/ru/post/318358/">New sample conditions or_where and or_having</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Added the ability to stepwise build a query</a> </li></ul><br><h3 id="obnovlyonnyy-modul-ectochangeset">  Updated Ecto.Changeset Module </h3><br><ol><li>  changeset.model renamed to changeset.data (from now on there is no "models" in Ecto). </li><li> It is considered obsolete to pass the required fields and options for them in <code>cast/4</code> , henceforth you should use <code>cast/3</code> and <code>validate_required/3</code> . </li><li>  Atom <code>:empty</code> in <code>cast(source, :empty, required, optional)</code> become obsolete, it is advisable to use <code>empty map</code> or <code>:invalid</code> instead. </li></ol><br><p>  As a result, instead: </p><br><pre> <code class="hljs pgsql">def changeset(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, params \\ :empty) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> |&gt; cast(params, [:<span class="hljs-type"><span class="hljs-type">name</span></span>], [:age]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  It is recommended to do better like this: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user, params \\ </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">%{}</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> user <span class="hljs-params"><span class="hljs-params">|&gt; cast(params, [:name, :age]) |</span></span>&gt; validate_required([<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h3 id="novaya-funkciya-subquery1-v-module-ectoquery">  New Subquery / 1 function in the Ecto.Query module </h3><br><p>  The <code>Ecto.Query.subquery/1</code> function makes it possible to convert any queries into subqueries.  For example, if you want to calculate the average number of views of publications, you can write: </p><br><pre> <code class="hljs pgsql">query = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: avg(p.visits) TestRepo.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(query) #=&gt; [#<span class="hljs-type"><span class="hljs-type">Decimal</span></span>&lt;<span class="hljs-number"><span class="hljs-number">1743</span></span>&gt;]</code> </pre> <br><p>  However, if you want to calculate the average number of views for only the 10 most popular posts, you will need a subquery: </p><br><pre> <code class="hljs pgsql">query = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: [:visits], order_by: [<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>: :visits], <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> TestRepo.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> subquery(query), <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: avg(p.visits)) #=&gt; [#<span class="hljs-type"><span class="hljs-type">Decimal</span></span>&lt;<span class="hljs-number"><span class="hljs-number">4682</span></span>&gt;]</code> </pre> <br><p>  For a practical example, if you use the <code>Repo.aggregate</code> function to calculate aggregated data: </p><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#  -     TestRepo.aggregate(Post, :avg, :visits) #=&gt; #Decimal</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1743&gt;</span></span></span></span></code> </pre> <br><pre> <code class="hljs pgsql">#  -   <span class="hljs-number"><span class="hljs-number">10</span></span>    query = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Post, order_by: [<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>: :visits], <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> TestRepo.<span class="hljs-keyword"><span class="hljs-keyword">aggregate</span></span>(query, :avg, :visits) #=&gt; #<span class="hljs-type"><span class="hljs-type">Decimal</span></span>&lt;<span class="hljs-number"><span class="hljs-number">4682</span></span>&gt;</code> </pre> <br><p>  In <code>subquery/1</code> is possible to set the names of the fields in the subqueries.  That will allow to handle tables with conflicting names: </p><br><pre> <code class="hljs cs">posts_with_private = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: %{title: p.title, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: not p.<span class="hljs-keyword"><span class="hljs-keyword">private</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">from</span></span></span><span class="hljs-function"> p </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subquery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">posts_with_private</span></span></span><span class="hljs-function">), </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">where</span></span></span><span class="hljs-function">: p.</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function">, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">select</span></span></span><span class="hljs-function">: p</span></span></code> </pre> <br><h3 id="novaya-funkciya-insert_all3-v-module-ectorepo">  New insert_all / 3 function in the Ecto.Repo module </h3><br><p>  The <code>Ecto.Repo.insert_all/3</code> function is intended for multiple insertion of records within a single query: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Ecto</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Repo</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.insert_all</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Post</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[%{title: "foo"}, %{title: "bar"}]</span></span></code> </pre> <br><p>  It is worth considering that when inserting rows through <code>insert_all/3</code> , auto- <code>insert_all/3</code> fields, such as <code>inserted_at</code> or <code>updated_at</code> , are not processed.  Also <code>insert_all/3</code> allows you to insert rows into the database, bypassing <code>Ecto.Schema</code> , simply by specifying the name of the table: </p><br><pre> <code class="hljs objectivec">Ecto.Repo.insert_all <span class="hljs-string"><span class="hljs-string">"some_table"</span></span>, [%{hello: <span class="hljs-string"><span class="hljs-string">"foo"</span></span>}, %{hello: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>}]</code> </pre> <br><h3 id="dobavlena-many-to-many-associaciya">  Added many-to-many association </h3><br><p>  Ecto now supports <code>many_to_many</code> associations: </p><br><pre> <code class="hljs pgsql">defmodule Post <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Ecto.<span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span> <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> "posts" <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> many_to_many :tags, Tag, join_through: "posts_tags" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  The value in the <code>join_through</code> option can be the name of a table that contains the <code>post_id</code> and <code>tag_id</code> , or it can be a schema, such as <code>PostTag</code> , which contains foreign keys and auto-generated columns. </p><br><h3 id="uluchshena-rabota-s-associaciyami">  Improved work with associations </h3><br><p>  From now on, Ecto makes it possible to insert and modify lines to the <code>belongs_to</code> and <code>many_to_many</code> associations via the <code>changeset</code> .  In addition, Ecto supports defining associations directly in the data structure to be inserted.  For example: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Repo</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.insert</span></span>! %<span class="hljs-selector-tag"><span class="hljs-selector-tag">Permalink</span></span>{ <span class="hljs-attribute"><span class="hljs-attribute">url</span></span>: <span class="hljs-string"><span class="hljs-string">"//root"</span></span>, post: %Post{ title: <span class="hljs-string"><span class="hljs-string">"A permalink belongs to a post which we are inserting"</span></span>, comments: [ %Comment{text: <span class="hljs-string"><span class="hljs-string">"child 1"</span></span>}, %<span class="hljs-selector-tag"><span class="hljs-selector-tag">Comment</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">text</span></span>: <span class="hljs-string"><span class="hljs-string">"child 2"</span></span>}, ] } }</code> </pre> <br><p>  This improvement makes it easier to insert tree structures into the database. </p><br><h3 id="novaya-funkciya-predzagruzki-associaciy-assoc2-v-module-ecto">  New preload feature of the assoc / 2 associations in the Ecto module </h3><br><p>  The <code>Ecto.assoc/2</code> function allows you to define second-order links that must be loaded to selectable records.  As an example, you can get authors and comments on selected publications: </p><br><pre> <code class="hljs pgsql">posts = Repo.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: is_nil(p.published_at) Repo.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> assoc(posts, [:comments, :author])</code> </pre> <br><p>  It is better to load links through associations, since it does not require the addition of fields to the sampling scheme. </p><br><h3 id="upsert">  Upsert </h3><br><p>  The functions <code>Ecto.Repo.insert/2</code> and <code>Ecto.Repo.insert_all/3</code> began to support upserts (insert and update) through the options <code>:on_conflict</code> and <code>:conflict_target</code> . </p><br><p>  The <code>:on_conflict</code> determines how the database should behave if the primary key matches. <br>  The <code>:conflict_target</code> option determines which fields need to be checked for conflicts when inserting new lines. </p><br><pre> <code class="hljs pgsql">#   {:ok, inserted} = MyRepo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(%Post{title: "inserted"}) #     . {:ok, upserted} = MyRepo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(%Post{id: inserted.id, title: "updated"}, on_conflict: :<span class="hljs-keyword"><span class="hljs-keyword">nothing</span></span>) #  ,    title. on_conflict = [<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: [title: "updated"]] {:ok, updated} = MyRepo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(%Post{id: inserted.id, title: "updated"}, on_conflict: on_conflict, conflict_target: :id)</code> </pre> <br><h3 id="novye-usloviya-vyborki-or_where-i-or_having">  New sample conditions or_where and or_having </h3><br><p>  In Ecto, we added the expression <code>Ecto.Query.or_where/3</code> and <code>Ecto.Query.or_having</code> , which add new filters to the already existing conditions through the "OR". </p><br><pre> <code class="hljs swift">from(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">City</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: [state: <span class="hljs-string"><span class="hljs-string">"Sweden"</span></span>], or_where: [state: <span class="hljs-string"><span class="hljs-string">"Brazil"</span></span>])</code> </pre> <br><h3 id="dobavlena-vozmozhnost-poshagovogo-postroeniya-zaprosa">  Added the ability to stepwise build a query </h3><br><p>  This technique allows you to create expressions bit by bit in order to interpolate them later into a general query. </p><br><p>  For example, you have a set of conditions from which you want to build your query, but you need to select only some of them depending on the context: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> params[<span class="hljs-string"><span class="hljs-string">"is_public"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span>([p], p.is_public or ^<span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> end <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> params[<span class="hljs-string"><span class="hljs-string">"allow_reviewers"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span>([p, a], a.reviewer == <span class="hljs-literal"><span class="hljs-literal">true</span></span> or ^<span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> end from query, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: ^<span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span></code> </pre> <br><p>  The example above shows how to build a query step by step, taking into account external conditions, and at the end interpolate everything inside one query. </p><br><p>  A dynamic expression can always be interpolated inside another dynamic expression or inside a <code>where</code> , <code>having</code> , <code>update</code> or in the <code>join</code> condition. </p><br><h2 id="interfeys-zaprosov">  Query interface </h2><br><p>  Analysis of the documentation of the modules Ecto.Query and Ecto.Repo from HexDocs is done in the manner <a href="http://rusrails.ru/active-record-query-interface">of the ActiveRecord Query Interface from RusRailsGuide</a> .  The text below reveals various ways to get data from a database using Ecto.  The code examples in the following text will apply to some of these models: </p><br><pre> <code class="hljs css">   <span class="hljs-selector-tag"><span class="hljs-selector-tag">id</span></span>   ,    . <span class="hljs-selector-tag"><span class="hljs-selector-tag">defmodule</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Showcase</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Client</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">do</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">use</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ecto</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Schema</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ecto</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Query</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">schema</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">clients</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">do</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">field</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:name</span></span>, <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:string</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">field</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:age</span></span>, <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:integer</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>: 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">field</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:sex</span></span>, <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:integer</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>: 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">field</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:state</span></span>, <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:string</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>: "<span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">has_many</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:orders</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Showcase</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Order</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">end</span></span> # ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">end</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">defmodule</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Showcase</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Order</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">do</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">use</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ecto</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Schema</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ecto</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Query</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">schema</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">orders</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">do</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">field</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:description</span></span>, <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:text</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">field</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:total_cost</span></span>, <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:integer</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">field</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:state</span></span>, <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:string</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>: "<span class="hljs-selector-tag"><span class="hljs-selector-tag">pending</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">belongs_to</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:client</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Showcase</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Client</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">has_many</span></span> <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:products</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Showcase</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Product</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">end</span></span> # ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">end</span></span></code> </pre> <br><ul><li>  <a href="https://habr.com/ru/post/318358/">Getting single line</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Getting multiple lines</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Row fetch conditions</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Row sorting</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Select specific row fields</a> </li><li>  <a href="https://habr.com/ru/post/318358/">String grouping</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Limiting and offsetting selectable rows</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Join tables</a> </li><li>  <a href="https://habr.com/ru/post/318358/">Override condition</a> </li></ul><br><p>  Ecto provides several search functions for retrieving objects from the database.  Arguments can be passed to each search function to perform certain queries to the database without having to write in pure SQL.  Ecto provides two styles for building queries: using a keyword and through an expression (function / macro). </p><br><p>  Below are some expressions provided by Ecto, they are declared in two modules: </p><br><p>  Ecto.Repo: </p><br><ul><li>  get / 3 </li><li>  get_by / 3 </li><li>  one / 2 </li><li>  all / 3 </li></ul><br><p>  Ecto.Query: </p><br><ul><li>  where / 3 </li><li>  or_where / 3 </li><li>  order_by / 3 </li><li>  select / 3 </li><li>  group_by / 3 </li><li>  limit / 3 </li><li>  offset / 3 </li><li>  join / 5 </li><li>  exclude / 2 </li></ul><br><h3 id="1-poluchenie-odinochnoy-stroki">  1. Getting a single line </h3><br><h4 id="get3">  get / 3 </h4><br><p>  Using the <code>get/3</code> function, you can get a record corresponding to a specific primary key.  For example: </p><br><pre> <code class="hljs pgsql">#      (id) <span class="hljs-number"><span class="hljs-number">10.</span></span> client = Ecto.Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(Client, <span class="hljs-number"><span class="hljs-number">10</span></span>) =&gt; %Client{id: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>: "Cain Ramirez", age: <span class="hljs-number"><span class="hljs-number">34</span></span>, sex: <span class="hljs-number"><span class="hljs-number">1</span></span>, state: "good"}</code> </pre> <br><p>  The <code>get/3</code> function will return <code>nil</code> if no records are found.  If the request does not have a <code>primary key</code> or there are more than one, then the function will cause an error <code>argument error</code> . </p><br><p>  The <code>get!/3</code> function behaves like <code>get/3</code> , except that it will call <code>Ecto.NoResultsError</code> if no matching records are found. </p><br><p>  The closest analogue of this function in ActiveRecord is the <code>find</code> method. </p><br><h4 id="get_by3">  get_by / 3 </h4><br><p>  Using the <code>get_by/3</code> function, you can get an entry that matches the provided sample conditions.  For example: </p><br><pre> <code class="hljs pgsql">#     (<span class="hljs-type"><span class="hljs-type">name</span></span>) "Cain Ramirez". client = Ecto.Repo.get_by(Client, <span class="hljs-type"><span class="hljs-type">name</span></span>: "Cain Ramirez") =&gt; %Client{id: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>: "Cain Ramirez", age: <span class="hljs-number"><span class="hljs-number">34</span></span>, sex: <span class="hljs-number"><span class="hljs-number">1</span></span>, state: "good"}</code> </pre> <br><p>  The <code>get_by/3</code> function <code>get_by/3</code> return <code>nil</code> if no records are found. </p><br><p>  The <code>get_by!/3</code> function behaves like <code>get_by/3</code> , except that it will cause an <code>Ecto.NoResultsError</code> error if no matching records were found. </p><br><p>  The closest analogue of this function in ActiveRecord is the <code>find_by_*</code> method. </p><br><h4 id="one2">  one / 2 </h4><br><p>  Using the <code>one/2</code> function, you can get one record that matches the provided sample conditions.  For example: </p><br><pre> <code class="hljs pgsql">#     . query = Ecto.Query.<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: c.name == "Jean Rousey") client = Ecto.Repo.one(query) =&gt; %Client{id: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>: "Jean Rousey", age: <span class="hljs-number"><span class="hljs-number">29</span></span>, sex: <span class="hljs-number"><span class="hljs-number">-1</span></span>, state: "good"}</code> </pre> <br><p>  The <code>one/2</code> function will return <code>nil</code> if no records are found.  And the function will cause an error if there is more than one entry on request. </p><br><p>  The <code>one!/2</code> function behaves like <code>one/2</code> , except that it will cause an <code>Ecto.NoResultsError</code> error if no matching records are found. </p><br><p>  The closest analogue of this function in <code>ActiveRecord</code> is the <code>first</code> method from the &lt;4 version, which accepted the sample conditions, and not the limit as now. </p><br><h3 id="2-poluchenie-neskolkih-strok">  2. Getting multiple lines </h3><br><h4 id="all3">  all / 3 </h4><br><p>  Using the function <code>all/3</code> , you can get all the records that match the provided query conditions.  For example: </p><br><pre> <code class="hljs mel">#     . query = Ecto.Query.from(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client) clients = Ecto.Repo.all(query) =&gt; [%Client{id: <span class="hljs-number"><span class="hljs-number">1</span></span>, name: <span class="hljs-string"><span class="hljs-string">"Jean Rousey"</span></span>, age: <span class="hljs-number"><span class="hljs-number">29</span></span>, sex: <span class="hljs-number"><span class="hljs-number">-1</span></span>, state: <span class="hljs-string"><span class="hljs-string">"good"</span></span>}, ..., %Client{id: <span class="hljs-number"><span class="hljs-number">10</span></span>, name: <span class="hljs-string"><span class="hljs-string">"Cain Ramirez"</span></span>, age: <span class="hljs-number"><span class="hljs-number">34</span></span>, sex: <span class="hljs-number"><span class="hljs-number">1</span></span>, state: <span class="hljs-string"><span class="hljs-string">"good"</span></span>}]</code> </pre> <br><p>  The <code>all/3</code> function will return <code>Ecto.QueryError</code> if the request fails validation. </p><br><p>  The closest analogue of this function in ActiveRecord is the <code>all</code> method from the &lt;4 version, which accepted the sample conditions. </p><br><h3 id="3-usloviya-vyborki-strok">  3. Conditions for fetching rows </h3><br><h4 id="where3">  where / 3 </h4><br><p>  The <code>where/3</code> expression allows you to define conditions for restricting the returned records that the WHERE part of the SQL expression represents.  If several sampling conditions are transmitted, they are combined by the <code>AND</code> operator. </p><br><p>  Calling the <code>where:</code> keyword <code>where:</code> is an integral part of the <code>from/2</code> macro: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: c.name == "Cain Ramirez") <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: [<span class="hljs-type"><span class="hljs-type">name</span></span>: "Cain Ramirez"])</code> </pre> <br><p>  It is possible to interpolate lists with sampling conditions, which allows you to pre-assemble the necessary restrictions. </p><br><pre> <code class="hljs pgsql">filters = [<span class="hljs-type"><span class="hljs-type">name</span></span>: "Cain Ramirez"] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: ^filters)</code> </pre> <br><p>  Calling the <code>where/3</code> macro: </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Client</span></span> |&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>([<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.name == <span class="hljs-string"><span class="hljs-string">"Cain Ramirez"</span></span>) <span class="hljs-type"><span class="hljs-type">Client</span></span> |&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Cain Ramirez"</span></span>)</code> </pre> <br><h4 id="or_where3">  or_where / 3 </h4><br><p>  The <code>or_where/3</code> expression allows you to define more flexible conditions for restricting the returned records, which represents the WHERE part of the SQL expression.  The difference between <code>where/3</code> and <code>or_where/3</code> minimal, but crucial.  The transferred condition joins the already existing ones through the <code>OR</code> operator.  If several sample conditions are transferred to <code>or_where/3</code> , then they are combined with the <code>AND</code> operator between them. </p><br><p>  The call by keyword <code>or_where:</code> is an integral part of the <code>from/2</code> macro: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: [<span class="hljs-type"><span class="hljs-type">name</span></span>: "Cain Ramirez"], or_where: [<span class="hljs-type"><span class="hljs-type">name</span></span>: "Jean Rousey"])</code> </pre> <br><p>  It is possible to interpolate lists with sampling conditions, which allows you to pre-assemble the necessary restrictions.  The conditions in the list are combined with each other through <code>AND</code> , and will join the existing conditions through <code>OR</code> : </p><br><pre> <code class="hljs pgsql">filters = [sex: <span class="hljs-number"><span class="hljs-number">1</span></span>, state: "good"] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: [<span class="hljs-type"><span class="hljs-type">name</span></span>: "Cain Ramirez"], or_where: ^filters)</code> </pre> <br><p>  ... this expression is equivalent to: </p><br><pre> <code class="hljs swift">from <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Client</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: (<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.name == <span class="hljs-string"><span class="hljs-string">"Cain Ramirez"</span></span>) or (<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.sex == <span class="hljs-number"><span class="hljs-number">1</span></span> and <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.state == <span class="hljs-string"><span class="hljs-string">"good"</span></span>)</code> </pre> <br><p>  Calling the <code>or_where/3</code> macro: </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Client</span></span> |&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>([<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.name == <span class="hljs-string"><span class="hljs-string">"Jean Rousey"</span></span>) |&gt; or_where([<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.name == <span class="hljs-string"><span class="hljs-string">"Cain Ramirez"</span></span>)</code> </pre> <br><h3 id="4-sortirovka-strok">  4. Sort Rows </h3><br><p>  The expression <code>order_by/3</code> allows you to define the condition for sorting records obtained from the database.  <code>order_by/3</code> sets the <code>ORDER BY</code> part of the SQL query. </p><br><p>  It is possible to sort by several fields at once.  The default sorting direction for ascending ( <code>:asc</code> ) can be overridden by descending ( <code>:desc</code> ).  For each field, you can specify your own sorting direction. </p><br><p>  Calling <code>order_by:</code> is an integral part of the <code>from/2</code> macro: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, order_by: c.name, order_by: c.age) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, order_by: [c.name, c.age]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, order_by: [<span class="hljs-keyword"><span class="hljs-keyword">asc</span></span>: c.name, <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>: c.age]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, order_by: [:<span class="hljs-type"><span class="hljs-type">name</span></span>, :age]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, order_by: [<span class="hljs-keyword"><span class="hljs-keyword">asc</span></span>: :<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>: :age])</code> </pre> <br><p>  It is possible to interpolate lists with sort fields, which allows you to pre-assemble the necessary sampling conditions. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">values</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">asc</span></span>: :<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>: :age] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, order_by: ^<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>)</code> </pre> <br><p>  Call <code>order_by/3</code> macro: </p><br><pre> <code class="hljs pgsql">Client |&gt; order_by([c], <span class="hljs-keyword"><span class="hljs-keyword">asc</span></span>: c.name, <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>: c.age) Client |&gt; order_by(<span class="hljs-keyword"><span class="hljs-keyword">asc</span></span>: :<span class="hljs-type"><span class="hljs-type">name</span></span>)</code> </pre> <br><h3 id="5-vybor-opredelennyh-poley-strok">  5. Select specific row fields </h3><br><p>  The <code>select/3</code> statement allows you to define table fields that you need to return for the records you receive from the database.  <code>select/3</code> sets the <code>SELECT</code> part of the SQL query.  By default, <code>Ecto</code> selects the entire set of result fields using <code>select *</code> . </p><br><p>  A call to the <code>select:</code> keyword <code>select:</code> is an integral part of the <code>from/2</code> macro: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: c) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: {c.name, c.age}) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: [c.name, c.state]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: {c.name, ^to_string(<span class="hljs-number"><span class="hljs-number">40</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">43</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: %{<span class="hljs-type"><span class="hljs-type">name</span></span>: c.name, order_counts: <span class="hljs-number"><span class="hljs-number">42</span></span>})</code> </pre> <br><p>  The macro call <code>select/3</code> : </p><br><pre> <code class="hljs pgsql">Client |&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>([c], c) Client |&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>([c], {c.name, c.age}) Client |&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>([c], %{"name" =&gt; c.name}) Client |&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>([:<span class="hljs-type"><span class="hljs-type">name</span></span>]) Client |&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>([c], struct(c, [:<span class="hljs-type"><span class="hljs-type">name</span></span>])) Client |&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>([c], map(c, [:<span class="hljs-type"><span class="hljs-type">name</span></span>]))</code> </pre> <br><p>  <strong>Important:</strong> When limiting selection fields for associations, it is important to select foreign key relationships, otherwise <code>Ecto</code> will not be able to find related objects. </p><br><h3 id="6-gruppirovka-strok">  6. Grouping rows </h3><br><p>  To determine the <code>GROUP BY</code> in a SQL query, the <code>group_by/3</code> macro is intended.  All columns mentioned in <code>SELECT</code> must be passed to <code>group_by/3</code> .  This is a general rule for aggregate functions. </p><br><p>  Calling the keyword <code>group_by:</code> is an integral part of the <code>from/2</code> macro: </p><br><pre> <code class="hljs swift">from(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Client</span></span>, group_by: <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.age, select: {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.age, <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.id)}) from(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Client</span></span>, group_by: :sex, select: {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.sex, <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.id)})</code> </pre> <br><p>  Call macro <code>group_by/3</code> : </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Client</span></span> |&gt; group_by([<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.age) |&gt; select([<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.id))</code> </pre> <br><h3 id="7-limitirovanie-i-smeschenie-vybiraemyh-strok">  7. Limiting and offsetting selectable lines </h3><br><p>  To define LIMIT in a SQL query, use the expression <code>limit/3</code> , it will determine the number of required records to be received. </p><br><p>  If <code>limit/3</code> transmitted twice, then the first value will be overlapped by the second. </p><br><pre> <code class="hljs swift">from(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Client</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.age == <span class="hljs-number"><span class="hljs-number">29</span></span>, limit: <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-type"><span class="hljs-type">Client</span></span> |&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>([<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.age == <span class="hljs-number"><span class="hljs-number">29</span></span>) |&gt; limit(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  To define OFFSET in a SQL query, use the expression <code>offset/3</code> , it will determine the number of records that will be skipped before the start of the returned records. </p><br><p>  If <code>offset/3</code> transmitted twice, then the first value will be overlapped by the second. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span>) Client |&gt; <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) |&gt; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>)</code> </pre> <br><h3 id="8-soedinenie-tablic">  8. Joining tables </h3><br><p>  Queries often refer to multiple tables, such queries are built using the <code>JOIN</code> .  In Ecto, to define such a construct, the <code>join/5</code> expression is intended.  The default table join strategy is INNER JOIN, which can be overridden to <code>:inner</code> ,: left,: right,: <code>:cross</code> or <code>:full</code> .  In the case of building a query by key, <code>:join</code> can be replaced by:: <code>:inner_join</code> <code>:left_join</code> <code>:right_join</code> <code>:cross_join</code> or <code>:full_join</code> . </p><br><p>  The call by the <code>join:</code> keyword <code>join:</code> is an integral part of the <code>from/2</code> macro: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>: p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>: p.id == c.post_id, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: {p.title, c.text} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, left_join: c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assoc(p, :comments), <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: {p, c} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>: p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>: [id: c.post_id], <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: {p.title, c.text}</code> </pre> <br><p>  All keys transferred to <code>on</code> will be considered as connection conditions. </p><br><p>  It is possible to interpolate the right side relative to <code>in</code> .  For example: </p><br><pre> <code class="hljs pgsql">posts = Post <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>: p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ^posts, <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>: [id: c.post_id], <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: {p.title, c.text}</code> </pre> <br><p>  Call <code>join/5</code> macro: </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Comment</span></span> |&gt; <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(:inner, [<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>], p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Post</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.post_id == p.id) |&gt; select([<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, p], {p.title, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.text}) <span class="hljs-type"><span class="hljs-type">Post</span></span> |&gt; <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, [p], <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assoc(p, :comments)) |&gt; select([p, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>], {p, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>}) <span class="hljs-type"><span class="hljs-type">Post</span></span> |&gt; <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, [p], <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">Comment</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.post_id == p.id and <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.is_visible == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) |&gt; select([p, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>], {p, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>})</code> </pre> <br><h3 id="9-pereopredelyayuschee-uslovie">  9. Overriding condition </h3><br><p>  Ecto allows you to remove already defined conditions in the query or return default values. To do this, use the <code>exclude/2</code> expression. </p><br><pre> <code class="hljs pgsql">query |&gt; Ecto.Query.<span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span>(:<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>) Ecto.Query.<span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span>(query, :<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>)</code> </pre> <br><h2 id="komandy-dlya-massovyh-operaciy-so-strokami">  Commands for bulk operations with strings </h2><br><h3 id="massovaya-vstavka">  Bulk insert </h3><br><p>  The <code>Ecto.Repo.insert_all/3</code> function will insert all transferred records. </p><br><pre> <code class="hljs pgsql">Repo.insert_all(Client, [[<span class="hljs-type"><span class="hljs-type">name</span></span>: "Cain Ramirez", age: <span class="hljs-number"><span class="hljs-number">34</span></span>], [<span class="hljs-type"><span class="hljs-type">name</span></span>: "Jean Rousey", age: <span class="hljs-number"><span class="hljs-number">29</span></span>]]) Repo.insert_all(Client, [%{<span class="hljs-type"><span class="hljs-type">name</span></span>: "Cain Ramirez", age: <span class="hljs-number"><span class="hljs-number">34</span></span>}, %{<span class="hljs-type"><span class="hljs-type">name</span></span>: "Jean Rousey", age: <span class="hljs-number"><span class="hljs-number">29</span></span>}])</code> </pre> <br><p>  The <code>insert_all/3</code> function does not handle auto- <code>insert_all/3</code> fields, such as <code>inserted_at</code> or <code>updated_at</code> . </p><br><h3 id="massovoe-obnovlenie">  Bulk update </h3><br><p>  The <code>Ecto.Repo.update_all/3</code> function <code>Ecto.Repo.update_all/3</code> update all rows subject to the query condition for the field values ‚Äã‚Äãpassed. </p><br><pre> <code class="hljs sql">Repo.update_all(Client, <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: [state: <span class="hljs-string"><span class="hljs-string">"new"</span></span>]) Repo.update_all(<span class="hljs-keyword"><span class="hljs-keyword">Client</span></span>, inc: [age: <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Client</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: p.sex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) |&gt; Repo.update_all(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: [state: <span class="hljs-string"><span class="hljs-string">"new"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Client</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: p.sex &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: [state: <span class="hljs-string"><span class="hljs-string">"new"</span></span>]]) |&gt; Repo.update_all([]) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Client</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: c.id &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: [state: fragment(<span class="hljs-string"><span class="hljs-string">"?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>)]]) |&gt; Repo.update_all([])</code> </pre> <br><h3 id="massovoe-udalenie">  Bulk removal </h3><br><p>  The <code>Ecto.Repo.delete_all/2</code> function deletes all rows that fall under the query condition. </p><br><pre> <code class="hljs cs">Repo.delete_all(Client) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Client, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: p.age == <span class="hljs-number"><span class="hljs-number">0</span></span>) |&gt; Repo.delete_all</code> </pre> <br><h2 id="prakticheskie-primery">  Practical examples </h2><br><h3 id="kompoziciya-zaprosov">  Query composition </h3><br><pre> <code class="hljs pgsql">query = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> App.Product, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: p query2 = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> query, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: p.state == "published" App.Repo.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(query2)</code> </pre> <br><h3 id="funkciya-dlya-postranichnogo-vyvoda">  Paginated function </h3><br><pre> <code class="hljs sql">defmodule Finders.Common.Paging <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto.Query <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> page(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: page(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> page(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span>, page), <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>: page(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span>, page, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> page(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span>, page, per_page) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = per_page * (page<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> |&gt; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>([_], ^<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>) |&gt; <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>([_], ^per_page) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">With</span></span> Posts: second page, five per page posts = Post |&gt; Finders.Common.Paging.page(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) |&gt; Repo.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> # <span class="hljs-keyword"><span class="hljs-keyword">With</span></span> Tags: third page, <span class="hljs-number"><span class="hljs-number">10</span></span> per page tags = Tag |&gt; Finders.Common.Paging.page(<span class="hljs-number"><span class="hljs-number">3</span></span>) |&gt; Repo.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span></code> </pre> <br><h3 id="queryapi">  Query.API </h3><br><p>  Comparison Operators: <code>==</code> <code>!=</code> , <code>&lt;=</code> , <code>&gt;=</code> , <code>&lt;</code> , <code>&gt;</code> <br>  Boolean operators: <code>and</code> , <code>or</code> , <code>not</code> <br>  Inclusion operator: <code>in/2</code> <br>  Search functions: <code>like/2</code> and <code>ilike/2</code> <br>  Check for <em>null</em> : <code>is_nil/1</code> <br>  Aggregators: <code>count/1</code> , <code>avg/1</code> , <code>sum/1</code> , <code>min/1</code> , <code>max/1</code> <br>  Function for arbitrary SQL subqueries: <code>fragment/1</code> </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: p.published_at &gt; ago(<span class="hljs-number"><span class="hljs-number">3</span></span>, "month") <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Payment, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: avg(p.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: p.published_at &gt; datetime_add(^Ecto.DateTime.utc, <span class="hljs-number"><span class="hljs-number">-1</span></span>, "month") <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: is_nil(p.published_at) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">ilike</span></span>(p.body, "Chapter%") <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Post, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: is_nil(p.published_at) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> fragment("lower(?)", p.title) == "title"</code> </pre> <br><h2 id="dopolnenie-iz-ectoadapterssql">  Supplement from Ecto.Adapters.SQL </h2><br><h3 id="ectoadapterssqlquery4"> <code>Ecto.Adapters.SQL.query/4</code> </h3> <br><p>  Runs an arbitrary SQL query within the transferred repository. </p><br><pre> <code class="hljs pgsql">Ecto.Adapters.<span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>.query(Showcase, "SELECT $1::integer + $2", [<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) =&gt; {:ok, %{<span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>: [{<span class="hljs-number"><span class="hljs-number">42</span></span>}], num_rows: <span class="hljs-number"><span class="hljs-number">1</span></span>}}</code> </pre> <br><p>  The closest analogue of this function in ActiveRecord is the <code>find_by_sql</code> method. </p><br><h3 id="ectoadapterssqlto_sql3"> <code>Ecto.Adapters.SQL.to_sql/3</code> </h3> <br><p>  Converts a query built from expressions to SQL. </p><br><pre> <code class="hljs pgsql">Ecto.Adapters.<span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>.to_sql(:<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>, repo, Showcase.Client) =&gt; {"SELECT c.id, c.name, c.age, c.sex, c.state, c.inserted_at, c.created_at FROM clients as c", []} Ecto.Adapters.<span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>.to_sql(:update_all, repo, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>(c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Showcase.Client, <span class="hljs-keyword"><span class="hljs-keyword">update</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: [state: ^"new"]])) =&gt; {"UPDATE clients AS c SET state = $1", ["new"]}</code> </pre> <br><p>  This function is a similar method from ActiveRecord :: Relation. </p><br><h2 id="literatura">  Literature </h2><br><p>  <a href="http://guides.rubyonrails.org/active_record_querying.html">http://guides.rubyonrails.org/active_record_querying.html</a> </p><br><p>  <a href="https://hexdocs.pm/ecto/Ecto.html">https://hexdocs.pm/ecto/Ecto.html</a> </p><br><p>  <a href="https://github.com/elixir-ecto/ecto">https://github.com/elixir-ecto/ecto</a> </p><br><p>  <a href="https://blog.drewolson.org/composable-queries-ecto/">https://blog.drewolson.org/composable-queries-ecto/</a> </p><br><p>  <a href="http://learningwithjb.com/posts">Learning with JB</a> </p><br><p>  <a href="http://blog.plataformatec.com.br/2016/05/ectos-insert_all-and-schemaless-queries/">http://blog.plataformatec.com.br/2016/05/ectos-insert_all-and-schemaless-queries/</a> </p><br><h2 id="posleslovie">  Afterword </h2><br><p>  If you are interested in the functional programming language <em>Elixir</em> or you are just sympathetic, then I advise you to join the <a href="https://t.me/joinchat/AAAAAEII11x65Zz9-Y-daw">Wunsh &amp;&amp; Elixir</a> and <a href="https://telegram.me/proelixir">ProElixir</a> Telegram chat rooms. </p><br><p>  In the domestic Elixir community, a single platform begins to appear in the face of the <a href="http://wunsh.ru/">Wunsh.ru</a> project.  Now the project has a thematic newsletter, in which there is nothing illegal, once a week will receive a letter with a collection of articles about Elixir in Russian. </p><br><h2 id="upd">  UPD: </h2><br><p>  Update from <a href="https://habrahabr.ru/users/pure_evil/" class="user_link">pure_evil</a> - c MongoDB second version of Ecto works, though it‚Äôs still in the form of a fork: <a href="https://github.com/michalmuskala/mongodb_ecto/pull/91">https://github.com/michalmuskala/mongodb_ecto/pull/91</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/318358/">https://habr.com/ru/post/318358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318340/index.html">Burnout freelancer on Upwork. Causes, tools, solutions</a></li>
<li><a href="../318342/index.html">The release of the alpha version of the Internet of Things protocol stack</a></li>
<li><a href="../318350/index.html">How to teach salespeople to speak with developers</a></li>
<li><a href="../318352/index.html">First steps with STM32 and mikroC compiler for ARM architecture - Part 2, start ...</a></li>
<li><a href="../318354/index.html">Release Python 3.6 - yes, now it‚Äôs with us</a></li>
<li><a href="../318362/index.html">How will your personal data be sold to a startup, in which he invested 70m rubles of IIDF</a></li>
<li><a href="../318364/index.html">Developing a game for Android on Unity 5. From idea to monetization. Part 2 (Live)</a></li>
<li><a href="../318366/index.html">Creating an editor quests and dialogues for the Unreal engine, Part 1 plugin description</a></li>
<li><a href="../318368/index.html">MiniATS at home</a></li>
<li><a href="../318370/index.html">Office 2 - Search Approach</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>