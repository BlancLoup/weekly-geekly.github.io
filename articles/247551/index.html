<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Five popular myths about C ++, part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 

 4.2 Shared ownership shared_ptr 
 Not every object may have one owner. We need to make sure that the object is destroyed and freed when the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Five popular myths about C ++, part 2</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/247401/"><i>Part 1</i></a> <br><br><h5>  4.2 Shared ownership shared_ptr </h5><br>  Not every object may have one owner.  We need to make sure that the object is destroyed and freed when the last link to it disappears.  Thus, we need a model of shared ownership of the object.  Suppose we have a synchronous queue, sync_queue, for communication between tasks.  The sender and recipient receive a pointer to sync_queue: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ sync_queue* p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> sync_queue{<span class="hljs-number"><span class="hljs-number">200</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ! thread t1 {task1,iqueue,p}; // task1   *iqueue    *p thread t2 {task2,p,oqueue}; // task2   *p    *oqueue t1.detach(); t2.detach(); }</span></span></code> </pre> <br><a name="habracut"></a><br>  It is assumed that task1, task2, iqueue and oqueue have already been appropriately defined somewhere and I apologize for the thread going through the scope where they were created (using detatch ()).  Question: who will remove the sync_queue created in startup ()?  Answer: the last person to use sync_queue.  This is a classic case when garbage collection is required.  Initially, the assembly counted the pointers: you need to store the number of uses of the object, and at the moment when the counter is reset, delete it.  Many modern languages ‚Äã‚Äãwork like this, and C ++ 11 supports this idea through shared_ptr.  The example turns into: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = make_shared&lt;sync_queue&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  sync_queue    stared_ptr   thread t1 {task1,iqueue,p}; // task1   *iqueue    *p thread t2 {task2,p,oqueue}; // task2   *p    *oqueue t1.detach(); t2.detach(); }</span></span></code> </pre><br><br>  Now, task1 and task2 destructors can destroy them shared_ptr (and in most properly built systems they will), and the last thing to do is destroy sync_queue.  It is simple and quite effective.  No complicated system.  Importantly, it does not just return the memory associated with sync_queue.  It returns a synchronization object (mutex, lock, whatever) embedded in sync_queue to synchronize two threads performing two tasks.  This is not just memory management, it is resource management.  This ‚Äúhidden‚Äù synchronization object is handled in the same way as file and stream handles in the previous example.  You can try to get rid of the use of shared_ptr by entering a unique owner in any scope that encompasses the task, but this is not always easy to do - therefore C ++ 11 has unique_ptr (for single ownership) and shared_ptr (for shared ownership) . <br><br><h5>  4.3 Type Safety </h5><br>  I have talked so far about garbage collection in the context of resource management.  But there is also type safety.  We have a delete operation that can be applied incorrectly.  Example: <br><br><pre> <code class="cpp hljs">X* p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X; X* q = p; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> p; <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ q-&gt;do_something(); // ,  *p,   </span></span></code> </pre><br><br>  Don't do that.  The direct use of delete is dangerous and not necessary in ordinary cases.  Leave the deletions to the classes that manage the resources ‚Äî string, ostream, thread, unique_ptr, and shared_ptr.  There the deletion is neatly tracked. <br><br><h5>  4.4 Outcome: Resource Management Ideals </h5><br>  From my point of view, garbage collection is the last resort for resource management, not a solution to a problem or an ideal. <br><br>  1. Use suitable abstractions that serve their resources recursively and implicitly.  Give preference to them, rather than variables in a certain scope. <br>  2. When you need to use pointers and links, use smart pointers - unique_ptr and shared_ptr <br>  3. If all else fails (for example, your code is part of a program that gets tangled in pointers and does not use a language-supported strategy for managing resources and handling errors), try processing non-memory resources manually and turn on assembly garbage to handle inevitable memory leaks. <br><br><h4>  5. Myth 4: for efficiency, it is necessary to write low-level code </h4><br>  Many believe that an effective code must be low-level.  Some even believe that low-level code is necessarily effective.  (‚ÄúIf it‚Äôs so ugly, surely it‚Äôs fast! Someone spent a lot of time and talent to create this thing!‚Äù).  Of course, you can write effective code at a low level, and you need to make some code low-level to work with machine resources.  Measure, however, whether it is worth your effort.  Modern C ++ compilers are very efficient, and the architecture of modern machines is extremely complex.  If necessary, such a low-level code should be hidden behind the interface for convenience.  Often, hiding a low-level code behind a high-level interface contributes to optimization.  Where efficiency is important, first try to reach it, having expressed the idea at a high level, do not immediately rush to bits and pointers. <br><br><h5>  5.1 qsort () in C </h5><br>  A simple example.  If you need to sort a set of floating-point numbers in descending order, you could write code for this.  But if you do not have extreme requirements (for example, there are more numbers than can fit in memory), that would be naive.  Over the decades, we have made libraries with sorting algorithms with acceptable speed.  I least like qsort () from the ISO standard C library: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greater</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* q)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   { double x = *(double*)p; //   double   p double y = *(double*)q; if (x&gt;y) return 1; if (x&lt;y) return -1; return 0; } void do_my_sort(double* p, unsigned int n) { qsort(p,n,sizeof(*p),greater); } int main() { double a[500000]; // ‚Ä¶ fill a ‚Ä¶ do_my_sort(a,sizeof(a)/sizeof(*a)); //      // ‚Ä¶ }</span></span></span></span></code> </pre><br><br>  If you are not programming in C, or if you haven‚Äôt recently used qsort, you need to explain something;  qsort takes 4 arguments <br>  - pointer to a sequence of bytes <br>  - amount of elements <br>  - item size <br>  - a function that compares two elements that are passed as pointers to their first bytes <br><br>  This interface hides information.  We do not sort bytes - we sort double, but qsort does not know this, so we need to provide information on how to compare double, and how many bytes in double.  Of course, the compiler knows such things.  But the low-level qsort interface does not allow the compiler to use this information.  The need to specify such simple information leads to errors.  Am I confusing two whole qsort arguments?  If confused, the computer will not notice.  Is my compare () agreement in C for a three-way comparison?  If you look at the industrial implementation of qsort (I recommend), you will see how much effort is made to compensate for the lack of information.  For example, it is rather difficult to swap the elements specified as a number of bytes, so that it is as effective as swapping a double pair.  Costly indirect calls to the comparison function can be eliminated by the compiler only if it uses constant distribution for function pointers. <br><br><h5>  5.2 sort () in C ++ </h5><br>  Compare qsort with its equivalent of sort from C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_my_sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ sort(v,[](<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x&gt;y; }); <span class="hljs-comment"><span class="hljs-comment">//  v   } int main() { vector&lt;double&gt; vd; // ‚Ä¶ fill vd ‚Ä¶ do_my_sort(v); // ‚Ä¶ }</span></span></code> </pre><br><br>  It requires less explanation.  The vector knows its size, and we do not need to explicitly indicate the number of elements.  The type of elements is not lost, and it is not necessary to remember their size.  By default, sort sorts in ascending order, so I had to set a comparison criterion, just like for qsort.  Here it is passed as a lambda expression comparing two doubles with&gt;.  And it so happens that this lambda is trivially inline by all C ++ compilers, which I know, so the comparison turns into a single machine operation ‚Äúmore than‚Äù - no ineffective function calls. <br><br>  I used the container version of sort to not explicitly set iterators, that is, not to write: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(v.begin(),v.end(),[](<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x&gt;y; });</code> </pre><br><br>  You can go ahead and use the C ++ 14 comparison object: <br><br><pre> <code class="cpp hljs">sort(v,greater&lt;&gt;()); <span class="hljs-comment"><span class="hljs-comment">//  v  </span></span></code> </pre><br><br>  Which version is faster?  You can compile qsort versions of both C and C ++ without any differences in speed, so this will be more like a comparison of programming styles, rather than languages.  Library implementations use the same algorithm for sort and qsort, so this is a comparison of programming styles, not algorithms.  Of course, different libraries and compilers will have different results, but for each implementation a reasonable response to different levels of abstraction will be visible. <br><br>  I recently ran out the examples, and saw that sort is 2.5 times faster than qsort.  This may vary from compiler to compiler and from computer to computer, but never qsort has won a sort with me.  Sometimes sort was performed 10 times faster.  Why?  In the standard C ++ library, sort is clearly higher than qsort, while being more flexible and general.  It is type safe and parameterized on the storage type, item type and sorting criteria.  No pointers, sizes, bytes.  The STL library to which sort belongs belongs tries not to throw out any information.  This leads to excellent inlining and good optimization. <br><br>  Generalization and high-level code can outperform low-level code.  Not always, but sort / qsort comparison is not a single example.  Always start with a high-level, accurate, and type-safe version of the solution.  Optimize as needed. <br><br><h4>  6. Myth 5: C ++ is designed for large and complex programs. </h4><br>  C ++ is a voluminous language.  The size of the definitions is similar to C # and Java.  But this does not mean that you need to know every detail in order to use it, or use all the functions directly in each program.  Here is an example of using basic components from the standard library: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; get_addresses(istream&amp; is) { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; addr; regex pat { <span class="hljs-string"><span class="hljs-string">R"((\w+([.-]\w+)*)@(\w+([.-]\w+)*))"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  -  smatch m; for (string s; getline(is,s); ) //   if (regex_search(s, m, pat)) //   addr.insert(m[0]); //     return addr; }</span></span></code> </pre><br><br>  I assume that you are familiar with regulars.  If not - it's time to get acquainted.  Notice that I rely on move semantics to simply and effectively return a potentially large set of strings.  All standard library containers provide displacement constructors, so there is no need to mess around with new. <br><br>  For the example to work, you need to include components: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include&lt;set&gt; #include&lt;iostream&gt; #include&lt;sstream&gt; #include&lt;regex&gt; using namespace std;</span></span></span></span></code> </pre><br><br>  Check: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">istringstream</span></span> test { <span class="hljs-comment"><span class="hljs-comment">//   ,   "asasasa\n" "bs@foo.com\n" "ms@foo.bar.com$aaa\n" "ms@foo.bar.com aaa\n" "asdf bs.ms@x\n" "$$bs.ms@x$$goo\n" "cft foo-bar.ff@ss-tt.vv@yy asas" "qwert\n" }; int main() { auto addr = get_addresses(test); // get the email addresses for (auto&amp; s : addr) // write out the addresses cout &lt;&lt; s &lt;&lt; '\n'; }</span></span></code> </pre><br><br>  Just an example.  It is easy to change get_addresses () so that it takes a regular list as an argument, so that it can search for a URL or whatever.  It is easy to change get_addresses () so that it recognizes more than one occurrence of a pattern in a string.  C ++ is intended for flexibility and generalization, but not every program must be a framework.  The bottom line is that the task of retrieving emails from a stream is simply expressed and simply checked. <br><br><h5>  6.1 Libraries </h5><br>  In any language, writing a program only through the built-in language features (if, for, and +) is tiring.  Conversely, if there are suitable libraries (graphics, route planning, database), any task can be accomplished with reasonable effort.  The standard ISO C ++ library is relatively small (compared to commercial ones), but besides it there are a lot of libraries with both source code and commercial ones.  For example, using the Boost, POCO, AMP, TBB, Cinder, vxWidgets, CGAL libraries, complex things become easier.  For example, let our program retrieve a URL from a web page.  To begin with, we will generalize get_addresses () to find any string that matches the pattern. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; get_strings(istream&amp; is, regex pat) { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; res; smatch m; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; getline(is,s); ) <span class="hljs-comment"><span class="hljs-comment">//   if (regex_search(s, m, pat)) res.insert(m[0]); //     return res; }</span></span></code> </pre><br><br>  This is a simplified version.  Now you need to somehow read the file from the web.  Boost has an asio library for working with the web: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/asio.hpp&gt; //  boost.asio</span></span></span></span></code> </pre><br><br>  Communication with the web server is quite difficult: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">try</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> server = <span class="hljs-string"><span class="hljs-string">"www.stroustrup.com"</span></span>; boost::asio::ip::tcp::iostream s {server,<span class="hljs-string"><span class="hljs-string">"http"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//   connect_to_file(s,server,"C++.html"); //     regex pat {R"((http://)?www([./#\+-]\w*)+)"}; // URL for (auto x : get_strings(s,pat)) //   cout &lt;&lt; x &lt;&lt; '\n'; } catch (std::exception&amp; e) { std::cout &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; "\n"; return 1; }</span></span></code> </pre><br><br>  When parsing the file <a href="http://www.stroustrup.com/C%2B%2B.html">www.stroustrup.com/C++.html</a> it gives: <br><br>  <a href="http://www-h.eng.cam.ac.uk/help/tpl/languages/C%2B%2B.html">www-h.eng.cam.ac.uk/help/tpl/languages/C++.html</a> <br>  <a href="http://www.accu.org/">www.accu.org</a> <br>  <a href="http://www.artima.co/cppsource">www.artima.co/cppsource</a> <br>  <a href="http://www.boost.org/">www.boost.org</a> <br>  ... <br><br>  I used the set, so the URLs are listed alphabetically. <br>  I hid the connection check in connect_to_file (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect_to_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(iostream&amp; s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; server, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; file)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//         s //   { if (!s) throw runtime_error{" \n"}; //      s &lt;&lt; "GET " &lt;&lt; "http://"+server+"/"+file &lt;&lt; " HTTP/1.0\r\n"; s &lt;&lt; "Host: " &lt;&lt; server &lt;&lt; "\r\n"; s &lt;&lt; "Accept: */*\r\n"; s &lt;&lt; "Connection: close\r\n\r\n"; //  : string http_version; unsigned int status_code; s &gt;&gt; http_version &gt;&gt; status_code; string status_message; getline(s,status_message); if (!s || http_version.substr(0, 5) != "HTTP/") throw runtime_error{ "  \n" }; if (status_code!=200) throw runtime_error{ "    " }; //   ,    : string header; while (getline(s,header) &amp;&amp; header!="\r"); }</span></span></span></span></code> </pre><br><br>  I did not write everything from scratch.  Working with HTTP is copied from the asio documentation. <br><br><h5>  6.2 Hello, World! </h5><br>  C ++ is a compiled language designed to create good, maintainable code for which speed and reliability matter.  It was not intended for competitions with interpreted scripting languages ‚Äã‚Äãthat are suitable for writing small programs.  JavaScript and other similar languages ‚Äã‚Äãare often written in C ++.  However, there are many useful C ++ programs that take up only a few dozen or hundreds of lines. <br><br>  Authors of libraries can help here.  Instead of concentrating on abstruse and advanced things in libraries, provide simple examples of ‚Äúhello, world!‚Äù.  Make a minimal version of the library, which is easy to install, and a one-page example of what it can do.  At one time or another, we all find ourselves in the role of a novice.  By the way, here is my version of ‚Äúhello world‚Äù for C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { std::cout &lt;&lt; "Hello, World\n"; }</span></span></span></span></code> </pre><br><br>  Longer and more complex versions seem less cool to me. <br><br><h4>  7 Applications of myths </h4><br>  Often myths have a basis.  Each of them has moments and situations where they can be believed on a reasonable basis, based on evidence.  To date, I consider them absolutely false, simple misunderstandings, although they were obtained in an honest way.  The problem is that myths always serve a purpose, or they would have already become extinct.  These five myths serve different purposes: <br>  - they give comfort.  No need to change, re-evaluate and rethink.  The familiar seems pleasant.  Changes are alarming, so it's good if the new product is unviable. <br>  - you can save time.  If it seems to you that you know what C ++ is, you don‚Äôt have to spend time learning something new, experimenting with new technologies, measuring code for speed, training beginners. <br>  - you can not learn C ++.  If these myths were true, why would he need to be taught at all? <br>  - they help to promote other languages ‚Äã‚Äãand technologies - in the case of their truthfulness it would be necessary. <br><br>  But they are false, so the arguments for keeping everything as it is, looking for alternatives to C ++ or avoiding the modern style of programming on it should not be based on these myths.  Existing with an outdated concept of C ++ in the head may be comfortable, but when working with software it is necessary to change.  More can be achieved than simply using C, C with classes, C ++ 98, etc. <br><br>  The adherents of the "good old" lose.  Support costs are often more than writing modern code.  Older compilers and tools provide less speed and perform worse analysis than modern ones.  Good programmers often refuse to work with antique code. <br><br>  Modern versions of C ++ and the technology of programming that it supports differ for the better from the idea that ‚Äúgenerally accepted myths‚Äù create.  If you believe in any of them - do not take my word for it.  Try it, check it out.  Measure the "old way" and alternatives for the actual problem.  Try to master new methods, explore new opportunities and technologies.  Do not forget to compare the estimated cost of supporting the new and old ways.  The best way to disprove a myth is to provide evidence.  I presented my examples and arguments to you. <br><br>  And I do not declare that C ++ is perfect.  It is not perfect, it is not the best language for all and for all.  Like any other language.  Think of him as he is now, not as he was 20 years ago, and not as he is exposed by someone who advertises alternatives.  To make a rational choice, look for reliable information, and try to understand for yourself how modern C ++ handles your tasks. <br><br><h4>  8 total </h4><br>  Do not believe the "generally accepted" knowledge of C ++, or its unsubstantiated use.  This article discusses five popular opinions about C ++ and suggests that they are just myths: <br><br>  1. To understand C ++, you first need to learn C <br>  2. C ++ is an object-oriented programming language. <br>  3. Reliable programs require garbage collection. <br>  4. To achieve efficiency, it is necessary to write low-level code. <br>  5. C ++ is only suitable for large and complex programs. <br><br>  These myths are harmful. <br><br><h4>  9 Feedback </h4><br>  Any doubts?  Let me know why.  What other myths have you met?  Why are they myths and not true?  What evidence do you have of exposing them? <br><br><h4>  10 References </h4><br>  1. ISO / IEC 14882: 2011 Programming Language C ++ <br>  2. POCO libraries: <a href="http://pocoproject.org/">pocoproject.org</a> <br>  3. Boost libraries: <a href="http://www.boost.org/">www.boost.org</a> <br>  4. AMP: C ++ Accelerated Massive Parallelism.  <a href="http://msdn.microsoft.com/en-us/library/hh265137.aspx">msdn.microsoft.com/en-us/library/hh265137.aspx</a> <br>  5. TBB: Intel Threading Building Blocks.  <a href="http://www.threadingbuildingblocks.org/">www.threadingbuildingblocks.org</a> <br>  6. Cinder: A library for professional-quality creative coding.  <a href="http://libcinder.org/">libcinder.org</a> <br>  7. vxWidgets: A Cross-Platform GUI Library.  <a href="http://www.wxwidgets.org/">www.wxwidgets.org</a> <br>  8. Cgal - Computational Geometry Algorithms Library.  <a href="http://www.cgal.org/">www.cgal.org</a> <br>  9. Christopher Kohlhoff: Boost.Asio documentation.  <a href="http://www.boost.org/doc/libs/1_55_0/doc/html/boost_asio.html">www.boost.org/doc/libs/1_55_0/doc/html/boost_asio.html</a> <br>  10. B. Stroustrup: Software Development for Infrastructure.  Computer, vol.  45, no.  1, pp.  47-58, Jan.  2012, doi: 10.1109 / MC.2011.353. <br>  11. Bjarne Stroustrup: The C ++ Programming Language (4th Edition).  Addison-Wesley.  ISBN 978-0321563842.  May 2013. <br>  12. Bjarne Stroustrup: A Tour of C ++.  Addison Wesley.  ISBN 978-0321958310.  September 2013. <br>  13. B. Stroustrup: Programming: Principles and Practice using C ++ (2nd edition).  Addison-Wesley.  ISBN 978-0321992789.  May 2014. <br><br><h4>  Afterword </h4><br>  After the publication of the article on isocpp.org received different comments.  Let me comment on some of them. <br><br>  Comments confirmed that this material is necessary.  People repeat the old arguments.  Unfortunately, many programmers do not read long articles, and short ones are discarded for incompleteness.  The reluctance to read long articles prompted me to write this material and break it into three parts during initial publication. <br><br>  This is not a research material that describes in detail every detail.  As I wrote at the beginning: ‚ÄúA book can be dedicated to every myth, but I will confine myself to a simple statement and a brief statement of my arguments against them.‚Äù <br><br>  However, many confuse examples to illustrate the point of view with the point of view itself.   ¬´ ¬ª,  ,   ,    .  , ..      .        ,     ¬´¬ª . <br><br>     ++11/++14,      ,    . ++14 ‚Äì  ++  1980-.     ,    .   ,     .   ,   ,      .     .          -   ++     ‚Äì  ,         (  ).        . <br><br>   ,  ,     .   ++    20-    10- .    ++     ,     .      ,   ++11.        ,      ++11. <br><br>       ¬´        ¬ª  ¬´ Y   X   ¬ª. ,     ,   ,   ++,   ,       ,       ‚Äì  .             . <br><br>         .  -      .       ,   ‚Äì  .           .        ,      .  ,  asio,      6.1 ‚Äì ,     .          (   ),     .       . ,      .6.2 ‚Äì   ++    ,     ,      . ,  99%    sort(v)  sort(v.begin(),v.end()). <br><br><h4>  Speed ‚Äã‚Äãperformance </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My comments caused a small storm. Many tried to refute them by simple objections. I do not accept speed arguments that are not backed up by test data. My comments have been confirmed by real measurements in different situations over several years. Many of them are described in books. They are true for a wide range of similar examples.</font></font><br><br>       ++,  .  ,        ,       ++  ++11.      ,  std::sort()  std::string     .  ‚Äì      .   GCC  Clang  ‚ÄìO2;    Microsoft  release mode. <br><br>        .         ,    ,     : , , ,   for,   ,   .       . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, the C-version of compose () does not check the value returned by malloc (). I asked you if I did everything right. I deliberately did not give you a production code. The lack of verification of the result is one of the main sources of errors, so my ‚Äúmistake‚Äù was specifically made to illustrate this. In this case, exceptions often help. Of course, you could write the C-version of compose () using the less well-known functions of the standard library, and yes, free storage could be avoided by letting the caller pass a buffer allocated on the stack and let the caller deal with the problem of string arguments that would overwhelm . However, these alternatives do not relate to the main issue: such code is more difficult to write than in C ++, and even harder to write it correctly. Newbies from the first time they write a version for C ++,but not for C, especially for those versions that are based on functions from the standard library that are not taught to beginners.</font></font><br><br> ++         ‚Äì      (    ), F-35, F-16 (  ),   : <a href="http://www.stroustrup.com/applications.html">www.stroustrup.com/applications.html</a> .  ,       ++. <br><br><h4>  Libraries </h4><br> ,    ,         .  This is problem.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But these libraries exist, and their research is often more productive than a simple movement forward, resulting in the invention of the next wheel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, C ++ libraries are often not designed to work with others. And there is no one place where you could take all the libraries. For years I have been watching the process of teaching students according to the ‚Äúfirst C‚Äù scheme, and have been reading these programs for decades. To thousands of people I taught C ++ as a first language. My statements about the possibility of learning C ++ are based on a lot of experience. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ is easier to teach than C because of a better type system and syntax. Need to learn fewer tricks and crutches. Imagine how you would learn to teach C programming style by teaching the C ++ language. I would never give beginners a C ++ course that would:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- did not contain a good basis for working with memory, pointers, etc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- did not give students an idea of ‚Äã‚Äã"pure C" and its use </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- did not justify most of the possibilities of the language </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- would try to teach absolutely all the techniques of C ++ </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good teachers who teach C do not try to teach beginners to all the techniques. </font></font><br> <a href="http://www.stroustrup.com/programming.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.stroustrup.com/programming.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - my answer to the question "How would you train new C ++?". This system works. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can read my rather old work on some aspects of teaching C and C ++: Learning Standard C ++ as a New Language. C / C ++ Users Journal. pp 43-54. May 1999 (www.stroustrup.com/papers.html).</font></font><br><br>     -  ,  ++ ‚Äî  .       (         ++). <br><br>  ++ ‚Äî   ISO ++14,   ,    30  ,   ,      20  .  C++11/C++14   ,      ,    .    ,    ++.   ‚Äì   ISO 11,   K&amp;R C (   ,      11   ,   ++  ++14).    ,      ¬´ ++¬ª. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ is not an OOP language. </font><font style="vertical-align: inherit;">This is a language that supports OOP, other programming techniques, and combinations thereof. </font><font style="vertical-align: inherit;">If you are an experienced programmer, I recommend reading A Tour of C ++ as a quick overview of the modern C ++ language.</font></font></div><p>Source: <a href="https://habr.com/ru/post/247551/">https://habr.com/ru/post/247551/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247539/index.html">ROS Speech Recognition with Google Speech API</a></li>
<li><a href="../247541/index.html">Parse security in iOS application</a></li>
<li><a href="../247543/index.html">Impress Application Server in simple terms</a></li>
<li><a href="../247545/index.html">Introduction to the development of web-applications on PSGI / Plack</a></li>
<li><a href="../247547/index.html">Creating an environment for web development based on Docker</a></li>
<li><a href="../247553/index.html">network-enabled single-mode on FreeBSD</a></li>
<li><a href="../247555/index.html">When nobody reads Habr</a></li>
<li><a href="../247557/index.html">About goals</a></li>
<li><a href="../247561/index.html">Fragment transactions and loss of activity</a></li>
<li><a href="../247571/index.html">Starry sky on webGL using three.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>