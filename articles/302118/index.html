<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Immunity in JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is Immunity? 


 Immutable (English immutable) is an object whose state can not be changed after creation. The result of any modification of such...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Immunity in JavaScript</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/023/23c/6b1/02323c6b1acd4548ad4f2d2c968a2cdd.png" alt="habracut"></p><br><h1 id="chto-takoe-immutabelnost">  What is Immunity? </h1><br><p>  Immutable (English immutable) is an object whose state can not be changed after creation.  The result of any modification of such an object will always be a new object, while the old object will not change. <a name="habracut"></a></p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mutableArr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; arr.push(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(mutableArr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5] //Use seamless-immutable.js var immutableArr = Immutable([1, 2, 3, 4]); var newImmutableArr = immutableArr.concat([5]); console.log(immutableArr); //[1, 2, 3, 4]; console.log(newImmutableArr); //[1, 2, 3, 4, 5];</span></span></code> </pre> <br><p>  This is not about deep copying: if an object has a nested structure, then all nested objects that have not been modified will be reused. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//Use seamless-immutable.js var state = Immutable({ style : { color : { r : 128, g : 64, b : 32 }, font : { family : 'sans-serif', size : 14 } }, text : 'Example', bounds : { size : { width : 100, height : 200 }, position : { x : 300, y : 400 } } }); var nextState = state.setIn(['style', 'color', 'r'], 99); state.bounds === nextState.bounds; //true state.text === nextState.text; //true state.style.font === state.style.font; //true</span></span></code> </pre> <br><p>  In memory, objects will be represented as follows: </p><br><p><img src="https://habrastorage.org/files/398/28d/e28/39828de284eb4d2ea17d61755e5493da.png" alt="In memory"></p><br><h2 id="pravda-ili-lozh-immutabelnye-dannye-v-javascript">  Truth or lie?  Immunity Data in JavaScript </h2><br><h3 id="prostoe-i-bystroe-otslezhivanie-izmeneniy">  Easy and quick change tracking </h3><br><p>  This feature is actively used in conjunction with today's popular <a href="http://tonyfreed.com/blog/what_is_virtual_dom">VirtualDOM</a> ( <a href="https://github.com/facebook/react">React</a> , <a href="">Mithril</a> , <a href="https://github.com/riot/riot">Riot</a> ) to speed up the redrawing of web pages. </p><br><p>  Take the example of <code>state</code> , just above.  After modifying the <code>state</code> object, you need to compare it with the <code>nextState</code> object and find out exactly what has changed in it.  Immunity greatly simplifies the task for us: instead of comparing the value of each field of each nested <code>state</code> object with the corresponding value from the <code>nextState</code> , you can simply compare references to the corresponding objects and thus filter out the entire nested branches of comparisons. </p><br><pre> <code class="javascript hljs">state === nextState <span class="hljs-comment"><span class="hljs-comment">//false state.text === nextState.text //true state.style === nextState.style //false state.style.color === nextState.style.color //false state.style.color.r === nextState.style.color.r //false state.style.color.g === nextState.style.color.g //true state.style.color.b === nextState.style.color.b //true state.style.font === nextState.style.font; //true //state.style.font.family === nextState.style.font.family; //true //state.style.font.size === nextState.style.font.size; //true state.bounds === nextState.bounds //true //state.bounds.size === nextState.bounds.size //true //state.bounds.size.width === nextState.bounds.size.width //true //state.bounds.size.height === nextState.bounds.size.height //true //state.bounds.position === nextState.bounds.position //true //state.bounds.position.x === nextState.bounds.position.x //true //state.bounds.position.y === nextState.bounds.position.y //true</span></span></code> </pre> <br><p>  Inside the <code>bounds</code> and <code>style.font</code> objects, <code>style.font</code> comparison operation is necessary, since they are immutable, and the references to them have not changed. </p><br><h2 id="bezopasnee-ispolzovat-i-legche-testirovat">  Safer to use and easier to test. </h2><br><p>  There are often cases when the data passed to the function can be accidentally corrupted, and it is very difficult to track down such situations. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr .sort(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : a &gt; b ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>}) .map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;div&gt;'</span></span> + item + <span class="hljs-string"><span class="hljs-string">'&lt;/div&gt;'</span></span>; }); } render(arr); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [0, 1, 2, 3, 4, 5]</span></span></code> </pre> <br><p>  Here immobile data would save the situation.  The <code>sort</code> function would be disabled. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//Use seamless-immutable.js var arr = [2, 1, 3, 5, 4, 0]; function render(items) { return items .sort(function(a, b) {return a &lt; b ? -1 : a &gt; b ? 1 : 0}) .map(function(item){ return '&lt;div&gt;' + item + '&lt;/div&gt;'; }); } render(arr); //Uncaught Error: The sort method cannot be invoked on an Immutable data structure. console.log(arr);</span></span></code> </pre> <br><p>  Or would return a new sorted array without changing the old one: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//Use immutable.js var arr = Immutable.fromJS([2, 1, 3, 5, 4, 0]); function render(items) { return arr .sort(function(a, b) {return a &lt; b ? -1 : a &gt; b ? 1 : 0}) .map(function(item){ return '&lt;div&gt;' + item + '&lt;/div&gt;'; }); } render(arr); console.log(arr.toJS()); // [2, 1, 3, 5, 4, 0]</span></span></code> </pre> <br><h2 id="bolshiy-rashod-pamyati">  Greater memory consumption </h2><br><p>  Each time an immutable object is modified, a copy of it is created with the necessary changes.  This leads to more memory consumption than when working with a regular object.  But since immutable objects never change, they can be implemented using a strategy called ‚Äústructural sharing‚Äù, which generates a much lower cost of memory costs than one would expect.  Compared to embedded arrays and objects, costs will still exist, but it will have a fixed value and can usually be compensated for by other benefits available due to immutability. </p><br><h2 id="legche-keshirovat-memoizirovat"><del>  Easier to cache (memorize) </del></h2><br><p>  In most cases, it will not be easier to cache.  This example will clarify the situation: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step_1 = Immutable({ <span class="hljs-attr"><span class="hljs-attr">data</span></span> : { <span class="hljs-attr"><span class="hljs-attr">value</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step_2 = step_1.setIn([<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step_3 = step_2.setIn([<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>); step_1.data === step_3.data; <span class="hljs-comment"><span class="hljs-comment">//false</span></span></code> </pre> <br><p>  Despite the fact that <code>data.value</code> from the first step does not differ from <code>data.value</code> from the last step, the <code>data</code> object itself is different, and the link to it also changed. </p><br><h2 id="otsutstvie-pobochnyh-effektov"><del>  No side effects </del></h2><br><p>  This is also not true: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">immutableData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = immutableData.get(<span class="hljs-string"><span class="hljs-string">'value'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.title = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> immutableData.set(<span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); }</code> </pre> <br><p>  There is no guarantee that the function will become <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D1%2582%25D0%25B0_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B8">pure</a> , or that it will have no <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B1%25D0%25BE%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258D%25D1%2584%25D1%2584%25D0%25B5%25D0%25BA%25D1%2582_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">side effects</a> . </p><br><h2 id="uskorenie-koda-bolshe-prostora-dlya-optimizaciy"><del>  Acceleration code.  More room for optimizations </del></h2><br><p>  Not everything is so obvious here, and performance depends on the concrete implementation of the immutable data structures with which you have to work.  But if you take and simply freeze the object using <code>Object.freeze</code> , then access to it and its properties will not become faster, and in some browsers it will become even slower. </p><br><h2 id="thread-safety"><del>  Thread safety </del></h2><br><p>  JavaScript is single-threaded, and there's nothing to talk about here.  Many people confuse asynchrony and multithreading - this is not the same thing. <br>  By default, there is only one thread that asynchronously serves the message queue. <br>  In a browser for multithreading there is WebWorkers, but the only possible communication between threads is through sending strings or serialized JSON;  it is not possible to refer to the same variables from different workers. </p><br><h1 id="vozmozhnosti-yazyka">  Language features </h1><br><h2 id="klyuchevoe-slovo-const">  Keyword const </h2><br><p>  Using <code>const</code> instead of <code>var</code> or <code>let</code> does not mean that the value is constant or that it is immutable (immutable).  The <code>const</code> keyword simply tells the compiler to ensure that no other value is assigned to the variable anymore. </p><br><p>  If <code>const</code> used, modern JavaScript engines can perform a number of additional optimizations. </p><br><p>  Example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">text</span></span> : <span class="hljs-string"><span class="hljs-string">'test'</span></span>}; obj.text = <span class="hljs-string"><span class="hljs-string">'abc'</span></span>; obj.color = <span class="hljs-string"><span class="hljs-string">'red'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">//Object {text: "abc", color: "red"} obj = {}; //Uncaught TypeError: Assignment to constant variable.(‚Ä¶)</span></span></code> </pre> <br><h2 id="objectfreeze">  Object.freeze </h2><br><p>  The <code>Object.freeze</code> method freezes an object.  This means that it prevents the addition of new properties to an object, the removal of old properties from an object, and the modification of existing properties or the values ‚Äã‚Äãof their enumeration, customizability, and recordability attributes.  In essence, the object becomes effectively unchanged.  The method returns a frozen object. </p><br><h1 id="storonnie-biblioteki">  Third Party Libraries </h1><br><h2 id="seamless-immutable">  Seamless-Immutable </h2><br><p>  <a href="https://github.com/rtfeldman/seamless-immutable">The library</a> offers immutable data structures that are backward compatible with regular arrays and objects.  That is, access to values ‚Äã‚Äãby key or index will not differ from the usual, standard cycles will work, and all this can be used in conjunction with specialized high-performance libraries for data manipulation, such as <a href="https://github.com/lodash/lodash">Lodash</a> or <a href="https://github.com/jashkenas/underscore">Underscore</a> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Immutable([<span class="hljs-string"><span class="hljs-string">"totally"</span></span>, <span class="hljs-string"><span class="hljs-string">"immutable"</span></span>, {<span class="hljs-attr"><span class="hljs-attr">hammer</span></span>: <span class="hljs-string"><span class="hljs-string">"Can't Touch This"</span></span>}]); array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"I'm going to mutate you!"</span></span> array[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-comment"><span class="hljs-comment">// "immutable" array[2].hammer = "hm, surely I can mutate this nested object..." array[2].hammer // "Can't Touch This" for (var index in array) { console.log(array[index]); } // "totally" // "immutable" // { hammer: 'Can't Touch This' } JSON.stringify(array) // '["totally","immutable",{"hammer":"Can't Touch This"}]'</span></span></code> </pre> <br><p>  This library uses <code>Object.freeze</code> , and also prohibits the use of methods that can change data. </p><br><pre> <code class="javascript hljs"> Immutable([<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]).sort() <span class="hljs-comment"><span class="hljs-comment">// This will throw an ImmutableError, because sort() is a mutating method.</span></span></code> </pre> <br><p>  Some browsers, such as Safari, <a href="http://jsperf.com/performance-frozen-object/20">have performance problems</a> when working with objects frozen using <code>Object.freeze</code> , so this is disabled in the <code>production</code> assembly for increased performance. </p><br><h2 id="immutablejs">  Immutable.js </h2><br><p>  Thanks to Facebook's promotion, this <a href="https://github.com/facebook/immutable-js">library</a> for working with immunity data has become the most common and popular among web developers.  It provides the following immutable data structures: </p><br><ul><li>  List - the immutable analogue of JavaScript Array <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = Immutable.List([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(list.size); <span class="hljs-comment"><span class="hljs-comment">//5 list = list.pop().pop(); //[1, 3, 2] list = list.push(6); //[1, 3, 2, 6] list = list.shift(); //[3, 2, 6] list = list.concat(9, 0, 1, 4); //[3, 2, 6, 9, 0, 1, 4] list = list.sort(); //[0, 1, 2, 3, 4, 6, 9]</span></span></code> </pre> </li><li>  Stack - an immutable list of elements organized according to the LIFO principle (last in - first out, ‚Äúlast arrived, first out‚Äù) <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Immutable.Stack(); stack = stack.push( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); stack.size; stack.get(); <span class="hljs-comment"><span class="hljs-comment">//2 stack.get(1); //1 stack.get(2); //0 stack = stack.pop(); // [1, 0]</span></span></code> </pre> </li><li>  Map - the immutable analog of JavaScript Object <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Immutable.Map(); map = map.set(<span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//{value : 5} map = map.set('text', 'Test'); //{value : 5, text : "Test"} map = map.delete('text'); // {value : 5}</span></span></code> </pre> </li><li>  OrderedMap is an immutable analogue of JavaScript Object, which guarantees the same order of traversal of elements as it was when writing <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Immutable.OrderedMap(); map = map.set(<span class="hljs-string"><span class="hljs-string">'m'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//{m : 5} map = map.set('a', 1); //{m : 5, a : 1} map = map.set('p', 8); //{m : 5, a : 1, p : 8} for(var elem of map) { console.log(elem); }</span></span></code> </pre> </li><li>  Set - an immutable set for storing unique values. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = Immutable.Set( [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 = Immutable.Set( [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s3 = Immutable.Set( [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( s1.count(), s2.size, s3.count() ); <span class="hljs-comment"><span class="hljs-comment">// 2 2 1 console.log( s1.toJS(), s2.toArray(), s3.toJSON() ); // [2, 1] [2, 3] [1] var s1S2IntersectArray = s1.intersect( s2 ).toJSON(); // [2]</span></span></code> </pre> </li><li>  OrderedSet is an immutable set for storing unique values, guaranteeing the same order of traversal of elements as it was when writing. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = Immutable.OrderedSet( [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 = Immutable.OrderedSet( [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s3 = Immutable.OrderedSet( [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1S2S3UnionArray = s1.union( s2, s3 ).toJSON();<span class="hljs-comment"><span class="hljs-comment">// [2, 1, 3] var s3S2S1UnionArray = s3.union( s2, s1 ).toJSON();// [1, 2, 3]</span></span></code> </pre> </li><li>  Record is an immutable data constructor with default values. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Data = Immutable.Record({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Test = Immutable.Record({ <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Data() }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> test = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( test.get(<span class="hljs-string"><span class="hljs-string">'data'</span></span>).get(<span class="hljs-string"><span class="hljs-string">'value'</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">//5 the default value</span></span></code> </pre> </li></ul><br><h2 id="mori">  Mori </h2><br><p>  <a href="https://github.com/swannodette/mori">A library</a> that adds persistent data structures from <a href="https://github.com/clojure/clojurescript">ClojureScript</a> (Lists, Vectors, Maps, etc.) to JavaScript. </p><br><p>  Differences from Immutable.js: </p><br><ul><li>  Functional API without public methods </li><li>  Faster </li><li>  Larger library size </li></ul><br><p>  Usage example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n+<span class="hljs-number"><span class="hljs-number">1</span></span>; }; mori.intoArray(mori.map(inc, mori.vector(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>))); <span class="hljs-comment"><span class="hljs-comment">// =&gt; [2,3,4,5,6] //Efficient non-destructive updates! var v1 = mori.vector(1,2,3); var v2 = mori.conj(v1, 4); v1.toString(); // =&gt; '[1 2 3]' v2.toString(); // =&gt; '[1 2 3 4]' var sum = function(a, b) { return a + b; }; mori.reduce(sum, mori.vector(1, 2, 3, 4)); // =&gt; 10 //Lazy sequences! var _ = mori; _.intoArray(_.interpose("foo", _.vector(1, 2, 3, 4))); // =&gt; [1, "foo", 2, "foo", 3, "foo", 4]</span></span></code> </pre> <br><h1 id="problemy-pri-razrabotke-s-kotorymi-vy-stolknetes">  Development issues you will encounter </h1><br><p>  It will be about using <a href="https://github.com/facebook/immutable-js">Immutable.js</a> (with <a href="https://github.com/swannodette/mori">Mori</a> everything is also about).  If you work with <a href="https://github.com/rtfeldman/seamless-immutable">Seamless-Immutable</a> , you will not have such problems due to backward compatibility with native JavaScript structures. </p><br><h2 id="rabota-s-servernym-api">  Work with server API </h2><br><p>  The fact is that in most cases the server API accepts and returns data in JSON format, which corresponds to standard objects and arrays from JavaScript.  This means that it will be necessary to somehow convert the Immutable data to normal and vice versa. </p><br><p>  Immutable.js for converting normal data into immutable offers the following function: </p><br><pre> <code class="javascript hljs">Immutable.fromJS(json: any, reviver?: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k: any, v: Iterable&lt;any, any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> any): any</code> </pre> <br><p>  where using the <code>reviver</code> function <code>reviver</code> can add your own conversion rules and manage existing ones. </p><br><p>  Suppose the server API returns the following object to us: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = [ {<span class="hljs-attr"><span class="hljs-attr">_id</span></span> : <span class="hljs-string"><span class="hljs-string">'573b44d91fd2f10100d5f436'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">_id</span></span> : <span class="hljs-string"><span class="hljs-string">'573dd87b212dc501001950f2'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">_id</span></span> : <span class="hljs-string"><span class="hljs-string">'5735f6ae2a380401006af05b'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">_id</span></span> : <span class="hljs-string"><span class="hljs-string">'56bdc2e1cee8b801000ff339'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span> : <span class="hljs-number"><span class="hljs-number">4</span></span>} ]</code> </pre> <br><p>  Most conveniently such an object will be represented as an orderedmap.  <code>reviver</code> appropriate <code>reviver</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = Immutable.fromJS(response, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k, v</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Immutable.Iterable.isIndexed(v)) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elem <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> v) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!elem.get(<span class="hljs-string"><span class="hljs-string">'_id'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elem; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ordered = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elem <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> v) { ordered.push([elem.get(<span class="hljs-string"><span class="hljs-string">'_id'</span></span>), elem.get(<span class="hljs-string"><span class="hljs-string">'value'</span></span>)]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Immutable.OrderedMap(ordered); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(state.toJS()); <span class="hljs-comment"><span class="hljs-comment">//Object {573b44d91fd2f10100d5f436: 1, 573dd87b212dc501001950f2: 2, 5735f6ae2a380401006af05b: 3, 56bdc2e1cee8b801000ff339: 4}</span></span></code> </pre> <br><p>  Suppose we need to change the data and send it back to the server: </p><br><pre> <code class="javascript hljs">state = state.setIn([<span class="hljs-string"><span class="hljs-string">'573dd87b212dc501001950f2'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(state.toJS()); <span class="hljs-comment"><span class="hljs-comment">//Object {573b44d91fd2f10100d5f436: 1, 573dd87b212dc501001950f2: 5, 5735f6ae2a380401006af05b: 3, 56bdc2e1cee8b801000ff339: 4}</span></span></code> </pre> <br><p>  Immutable.js for converting immobile data into regular data offers the following function: </p><br><pre> <code class="javascript hljs">toJS(): any</code> </pre> <br><p>  As you can see, the <code>reviver</code> missing, which means that you have to write your own external <code>immutableHelper</code> .  And he should somehow be able to distinguish the usual OrderMap from the one that matches the structure of your source data.  You cannot inherit from OrderMap either.  In this application, the structures are likely to be nested, which will add to your additional difficulties. </p><br><p>  You can, of course, use only List and Map in development, but then why is everything else?  And what are the advantages of using Immutable.js specifically? </p><br><h2 id="immutabelnost-vezde">  Immunity is everywhere </h2><br><p>  If the project used to work with native data structures, then it is not easy to switch to immutable data.  We'll have to rewrite all the code that somehow interacts with the data. </p><br><h2 id="serializaciyadeserializaciya">  Serialization / Deserialization </h2><br><p>  Immutable.js offers us nothing but functions <code>fromJS</code> , <code>toJS</code> , which work like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> set = Immutable.Set([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]); set = Immutable.fromJS(set.toJS()); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(Immutable.Set.isSet(set)); <span class="hljs-comment"><span class="hljs-comment">//false console.log(Immutable.List.isList(set)); //true</span></span></code> </pre> <br><p>  That is absolutely useless for serialization / deserialization. </p><br><p>  There is a third-party library <a href="https://github.com/glenjamin/transit-immutable-js">transit-immutable-js</a> .  An example of its use: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transit = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'transit-immutable-js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Immutable = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'immutable'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = Immutable.Map({<span class="hljs-attr"><span class="hljs-attr">with</span></span>: <span class="hljs-string"><span class="hljs-string">"Some"</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: <span class="hljs-string"><span class="hljs-string">"In"</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str = transit.toJSON(m); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(str) <span class="hljs-comment"><span class="hljs-comment">// ["~#cmap",["with","Some","data","In"]] var m2 = transit.fromJSON(str); console.log(Immutable.is(m, m2));// true</span></span></code> </pre> <br><h1 id="proizvoditelnost">  Performance </h1><br><p>  Benchmarks were written for performance testing.  To run them at home, run the following commands: </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/MrCheater/immutable-benchmarks.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ./immutable-benchmarks npm install npm start</code> </pre> <br><p>  The results of benchmarks can be seen on the graphs (repeats / ms).  The longer the execution time, the worse the result. </p><br><p>  When reading, native data structures and Seamless-immutable turned out to be the fastest. </p><br><p><img src="https://habrastorage.org/files/9ad/949/82b/9ad94982bd674be9ac2f3b175c5f1a77.png" alt="Read"></p><br><p>  When recording was the fastest Mori.  Seamless-immutable showed the worst result. </p><br><p><img src="https://habrastorage.org/files/3f4/030/dd9/3f4030dd93d348509c41103cf3be377e.png" alt="Write"></p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  This article will be useful to JavaScript developers who are faced with the need to use immune data in their applications to improve performance.  In particular, this applies to frontend developers who work with frameworks using <a href="http://tonyfreed.com/blog/what_is_virtual_dom">VirtualDOM</a> ( <a href="https://github.com/facebook/react">React</a> , <a href="">Mithril</a> , <a href="https://github.com/riot/riot">Riot</a> ), as well as <a href="https://github.com/facebook/flux">Flux</a> / <a href="https://github.com/reactjs/redux">Redux</a> solutions. </p><br><p>  Summing up, it can be said that among the considered libraries for immobility in JavaScript the most fast, convenient and easy to use is <a href="https://github.com/rtfeldman/seamless-immutable">Seamless-immutable</a> .  The most stable and common is <a href="https://github.com/facebook/immutable-js">Immutable.js</a> .  The fastest to write and the most unusual is <a href="https://github.com/swannodette/mori">Mori</a> .  I hope this study will help you choose a solution for your project.  Good luck. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/302118/">https://habr.com/ru/post/302118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302104/index.html">PHP Digest number 86 - interesting news, materials and tools (May 15 - 29, 2016)</a></li>
<li><a href="../302106/index.html">ConstraintLayout 101 and the new layout editor in Android Studio</a></li>
<li><a href="../302110/index.html">The digest of fresh materials from the world of the frontend for the last week No. 213 (May 23 - 29, 2016)</a></li>
<li><a href="../302112/index.html">That kills developer productivity</a></li>
<li><a href="../302116/index.html">Plone Licensing FAQ</a></li>
<li><a href="../302120/index.html">Stock Market Technologies: 10 Misconceptions About Neural Networks</a></li>
<li><a href="../302122/index.html">How companies should send emails: A Developer Look</a></li>
<li><a href="../302124/index.html">Working with data: How do large companies</a></li>
<li><a href="../302126/index.html">Data Plane Development Kit (DPDK): Getting Started</a></li>
<li><a href="../302128/index.html">How to raise CI for iOS developers in a day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>