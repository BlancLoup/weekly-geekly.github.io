<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C # async for iOS and Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Xamarin added support for C # 5 Async / await on iOS and Android. In addition to the base classes of .NET Async, 174 asynchronous methods appeared in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C # async for iOS and Android</h1><div class="post__text post__text-html js-mediator-article">  Xamarin added support for <a href="http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx">C # 5 Async / await</a> on iOS and Android.  In addition to the base classes of .NET Async, 174 asynchronous methods appeared in Xamarin.iOS and 337 in Xamarin.Android.  <a href="http://xamarin.com/mobileapi">Xamarin Mobile</a> , which provides cross-platform access to the address book, camera and geolocation, also became asynchronous.  <a href="http://components.xamarin.com/">Components with</a> might and main add support for async, for example, cloud backend <a href="http://components.xamarin.com/view/parse/">Parse</a> . <br><br>  Under the cut decoding and translation of the <a href="http://blog.xamarin.com/csharp-async-on-ios-and-android/">webinar</a> about this significant event. <br><br><img src="https://habrastorage.org/storage3/dd8/827/942/dd88279421732391b81adff42c27eb77.png"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Programmers want to make responsive applications, so they use asynchronous programming. <br><br>  Responsive interface responds to user actions no longer than 64 milliseconds, this is not so easy to achieve.  Especially if the reaction to user actions requires the execution of long operations.  The easiest option is to run a long operation in another thread.  And if you use threads, you need to invent your system to coordinate their actions.  There are many different approaches and literature on this subject, but each time you need to re-implement it. <br><br>  Almost any operation on a smartphone can be a long one: working with the file system, scaling a picture, querying the database.  And when you download something over the network, you can‚Äôt predict how long it will take.  And in order to respond to the user no later than 64 milliseconds, we came up with callbacks.  They are now very popular with the filing of NodeJS. <br><br>  If you use many callbacks, the code becomes <a href="https://twitter.com/marcoarment/status/365683181069942784">unreadable</a> and difficult to modify, it is called <a href="http://callbackhell.com/">Callback Hell</a> . <br><br><img src="https://habrastorage.org/storage3/7a8/8e2/157/7a88e215788cad04a3709b401c85d1a7.jpg"><br><br>  The problem is that the order of execution of this piece of code is not obvious and difficult to understand.  We cannot think about functions, cycles, function calls, we start thinking about small blocks of code that other small blocks of code call. <br><br>  Adding new functions to such code is a very difficult task, I have a headache when I just think about changing this method.  And the most interesting is that we still do not handle errors.  I don't want to do this, I give up. <br><br><img src="https://habrastorage.org/storage3/34e/4ce/523/34e4ce523d799857f09758c9c917f348.jpg" align="left"><br>  <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D0%25B0,_%25D0%25AD%25D0%25B4%25D1%2581%25D0%25B3%25D0%25B5%25D1%2580_%25D0%2592%25D0%25B8%25D0%25B1%25D0%25B5">Edsger Dijkstra</a> <br><blockquote>  Our brain is sharpened for understanding static structures, our ability to represent processes that develop over time is poorly developed.  Therefore, we must reduce the difference between the program code and the process of its execution in order to understand how the program will be executed by its code as simply as possible. </blockquote>  He meant using GOTO, we encountered the same problem when using callbacks.  But progress does not stand still, we create new idioms, new languages, we teach the compiler to do the work for us.  And async / await in C # is the new idiom that can replace callbacks. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SnapAndPostAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Busy = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; UpdateUIStatus (<span class="hljs-string"><span class="hljs-string">"Taking a picture"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> picker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xamarin.Media.MediaPicker (); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mFile = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> picker.TakePhotoAsync (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xamarin.Media.StoreCameraMediaOptions ()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tagsCtrl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GetTagsUIViewontroller (mFile.GetStream ()); <span class="hljs-comment"><span class="hljs-comment">// Call new iOS await API await PresentViewControllerAsync (tagsCtrl, true); UpdateUIStatus ("Submitting picture to server"); await PostPicToServiceAsync (mFile.GetStream (), tagsCtrl.Tags); UpdateUIStatus ("Success"); } catch (OperationCanceledException) { UpdateUIStatus ("Canceled"); } finally { Busy = false; } }</span></span></code> </pre> <br>  Here is an example of using async / await.  This code looks consistent and understandable; adding new features is easy.  And the difference is that I added the word async to the function header, which marks the method as asynchronous and then uses await.  These keywords say to the compiler: ‚Äúplease do the work for the developer, rewrite this code, divide it into several independent pieces‚Äù.  In fact, the output will be the same callbacks, the same state control, only made automatically.  And you can read the code sequentially, as bequeathed by Dijkstra. <br><br>  In the example, we used <a href="http://msdn.microsoft.com/en-us/library/vstudio/dd321424.aspx">Task &lt;T&gt;</a> .  He helps us manage the operations taking place in the background.  Task encapsulates task status (in progress, completed, canceled), result and exceptions that occurred during execution.  There are two types of Task: not returning a value and returning a value of type T. <br><br><img src="https://habrastorage.org/storage3/b3f/834/075/b3f834075815ddecc658454b8db23a98.jpg"><br><br>  With Task you can do a lot of interesting things.  If you have several tasks, you can wait until all of them or all of them are completed together.  Or chained and executed sequentially. <br><br>  You can create a Task consisting of other Task.  For example, you can run three tasks to retrieve data from different server mirrors and wrap them into one task, which will complete as soon as any of the three completes and returns its result. <br><br>  Let's look at another example.  I really like his sequence.  This method downloads the file, if it is already on the disk, we ask the user to overwrite the file or not, if he says ‚Äúyes‚Äù - we will overwrite the file, otherwise we will stop working. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DownloadFile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Uri uri, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists (target)){ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ShowAlert (<span class="hljs-string"><span class="hljs-string">"File Exists"</span></span>, <span class="hljs-string"><span class="hljs-string">"Do you want to overwrite the file?"</span></span>, <span class="hljs-string"><span class="hljs-string">"yes"</span></span>, <span class="hljs-string"><span class="hljs-string">"no"</span></span>)){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Http.Get (uri); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.SaveTo(target); }</code> </pre><br><br>  As you remember in iOS and Android, the result of the system message comes to us in a callback, that is, without async, we needed to create a message, configure it, assign a callback.  In the case of async, the compiler does all this for us.  And it is beautiful. <br><br>  Let's see how ShowAlert is implemented inside Xamarin. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowAlert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> title, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> [] buttons</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; (); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> alert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UIAlertView { Title = title, Message = message }; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> button <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> buttons) alert.AddButton (button); alert.Clicked += (s, e) =&gt; tcs.TrySetResult (e.ButtonIndex); alert.Show (); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tcs.Task; }</code> </pre> <br>  Pay attention to the third line from the end, this is where the magic happens.  So we return the result in asynchronous methods.  Of course, displaying a system message is a very simple function, but I think it will give you inspiration to write your own. <br><br>  As I already mentioned, Xamarin supports .NET5 Async base classes and specialized methods for mobile platforms.  To be precise, Xamarin.iOS provides 174 asynchronous methods, and Xamarin.Android - 337. In addition, <a href="http://xamarin.com/mobileapi">Xamarin Mobile</a> , which provides cross-platform access to the address book, camera and geolocation, became asynchronous.  Many <a href="http://components.xamarin.com/">components</a> also become asynchronous, for example, cloud backend <a href="http://components.xamarin.com/view/parse/">Parse</a> . <br><br>  If an API method call can take more than 50 milliseconds, we make its asynchronous version.  Depending on the context, you can use either the synchronous or asynchronous version of the method. <br><br>  <b>Async / await support is exactly the situation when Xamarin greatly simplifies working with iOS and Android platforms and stops being just a wrapper.</b> <br><br>  <i>(approx. Trans. begins part of Craig Dunn, it seems, he retells the <a href="http://msdn.microsoft.com/en-us/library/hh873175.aspx">Task-based Asynchronous Pattern</a> )</i> <br><br>  Let's look at larger examples.  All code <a href="https://github.com/xamarin/mobile-samples/blob/master/AsyncAwait">is available on Github</a> . <br><br>  Notice nested callbacks, error handling in several places, switching to the UI thread when we need to update the user interface.  Pff.  The code is difficult to read and, especially, modifications. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DownloadHomepage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient(); webClient.DownloadStringCompleted += (sender, e) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(e.Cancelled || e.Error != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// do something with error } string contents = e.Result; int length = contents.Length; InvokeOnMainThread (() =&gt; { ResultTextView.Text += "Downloaded the html and found out the length.\n\n"; }); webClient.DownloadDataCompleted += (sender1, e1) =&gt; { if(e1.Cancelled || e1.Error != null) { // do something with error } SaveBytesToFile(e1.Result, "team.jpg"); InvokeOnMainThread (() =&gt; { ResultTextView.Text += "Downloaded the image.\n"; DownloadedImageView.Image = UIImage.FromFile (localPath); }); ALAssetsLibrary library = new ALAssetsLibrary(); var dict = new NSDictionary(); library.WriteImageToSavedPhotosAlbum (DownloadedImageView.Image.CGImage, dict, (s2,e2) =&gt; { InvokeOnMainThread (() =&gt; { ResultTextView.Text += "Saved to album assetUrl\n"; }); if (downloaded != null) downloaded(length); }); }; webClient.DownloadDataAsync(new Uri("http://xamarin.com/images/about/team.jpg")); }; webClient.DownloadStringAsync(new Uri("http://xamarin.com/")); }</span></span></code> </pre> <br><br>  The same with async / await: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DownloadHomepageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; contentsTask = httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://xamarin.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> contents = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> contentsTask; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = contents.Length; ResultTextView.Text += <span class="hljs-string"><span class="hljs-string">"Downloaded the html and found out the length.\n\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] imageBytes = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> httpClient.GetByteArrayAsync(<span class="hljs-string"><span class="hljs-string">"http://xamarin.com/images/about/team.jpg"</span></span>); SaveBytesToFile(imageBytes, <span class="hljs-string"><span class="hljs-string">"team.jpg"</span></span>); ResultTextView.Text += <span class="hljs-string"><span class="hljs-string">"Downloaded the image.\n"</span></span>; DownloadedImageView.Image = UIImage.FromFile (localPath); ALAssetsLibrary library = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ALAssetsLibrary(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dict = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NSDictionary(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assetUrl = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> library.WriteImageToSavedPhotosAlbumAsync (DownloadedImageView.Image.CGImage, dict); ResultTextView.Text += <span class="hljs-string"><span class="hljs-string">"Saved to album assetUrl = "</span></span> + assetUrl + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; ResultTextView.Text += <span class="hljs-string"><span class="hljs-string">"\n\n\n"</span></span> + contents; <span class="hljs-comment"><span class="hljs-comment">// just dump the entire HTML return length; } catch { // do something with error return -1; } }</span></span></code> </pre> <br><br>  Compare?  The new code is linear, easy to read, error handling is collected in one place. <br><br>  You may also notice HttpClient, a new API object available in Xamarin.  In the code we are trying to download the html of the xamarin.com main page with its help.  After calling GetStringAsync, a parallel stream is immediately launched, which downloads html from the site.  And returns to us Task, the link to this operation.  When we call await, we say that we cannot continue without the result of this operation, control is transferred to the main process.  When the string is received, control returns to our method on the next line after await, we calculate its length and update the user interface. <br><br>  When we call httpClient.GetByteArrayAsync, we do not create an intermediate Task, but immediately wait for the result of the query.  The image will be downloaded in a different background process, and when it is over the control will return to our method, we will save the image and update the user interface. <br><br>  The code is consistent and understandable. <br><br>  I have not done any error handling, but this is easy.  It doesn't matter if an error occurs in the code of the method or in the background HttpClient stream, we get it in the catch block.  The compiler does this work for us. <br><br>  I marked different operations in the code with colors, let's compare the old and the new versions: <br><img src="https://habrastorage.org/storage3/10d/655/c5a/10d655c5ad6853831d05e3f4700b0077.jpg"><br><br>  Notice how inconsistent the old code is, how error handling and reference to the main thread are spread throughout the code.  The async / await version is much better in terms of readability and code support. <br><br><h4>  Moving to async / await </h4><br>  So, how to switch to asynchronous mobile programming?  Use the async modifier for methods, lambda expressions, and anonymous functions so that the compiler generates asynchronous code for them.  Add the Async suffix to the names of asynchronous methods, this will help other developers to distinguish them from synchronous ones. <br><img src="https://habrastorage.org/storage3/b04/eb9/1f5/b04eb91f56b964b5fc06cfe654752317.jpg"><br><br>  Async methods can return void, Task or Task &lt;T&gt;.  Void is applicable only for event handlers.  If your method returns a value, use Task &lt;T&gt;, otherwise, just Task.  If you use Task &lt;T&gt;, just return the value as from the normal method, the compiler will do the rest. <br><br>  Await can only be used in methods marked as async.  Await cannot be used in Catch and Finally blocks. <br><br><h4>  Error processing </h4><br>  If you call await for a task, any exceptions that occur inside will be thrown into the method of the pending task. <br><br>  <i>Note: asynchronous methods returning void have nowhere to redirect exceptions, they will appear in the current thread and will cause the application to crash.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   t    await t; ResultTextView.Text += "** Downloaded " + t.Result.Length + " bytes\n"; } catch(OperationCancelledException) {// t  } catch(Exception exc) { //      t ResultTextView.Text += "--Download Error: " + exc.Messsage + "\n"; }</span></span></code> </pre> <br><br><h4>  Cancel tasks </h4><br>  The active task can be canceled, this is especially important for long tasks, such as working with the network.  You can decide to cancel the task from the code or to offer the user the possibility of canceling too long operations. <br><br>  Cancellation is implemented by passing the Cancellation token parameter to the asynchronous method.  You can transfer the created token to other tasks, so you can cancel groups of tasks. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> DownloadHomepageAsync(cts.Token); <span class="hljs-comment"><span class="hljs-comment">//        cts.Cancel();</span></span></code> </pre> <br><br><h4>  Progress display </h4><br>  The task can inform the pending method of the progress of the operation, for example, transfer the current number of bytes downloaded. <br>  To do this, you must overload the asynchronous method with the version of the host IProgress. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Progress</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IProgress</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Progress; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action&lt;T&gt; handler</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;T&gt; ProgressChanged; <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre><br><br><h4>  Combinations of tasks </h4><br>  Multiple tasks can be combined into one using the <a href="http://msdn.microsoft.com/en-us/library/system.threading.tasks.task.whenany.aspx">Task.WhenAny</a> and <a href="http://msdn.microsoft.com/en-us/library/system.threading.tasks.task.whenall.aspx">Task.WhenAll methods</a> .  For example, you download several files by combining tasks to download files into one, you can wait until all of them are loaded or continue execution after the first downloaded file. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(tasks.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ,         //t ‚Äî    var t = await Task.WhenAny(tasks); tasks.Remove(t); try { await t; //   t   ResultTextView.Text += "++ Downloaded " + t.Result.length + " bytes\n"; } catch(OperationCancelledException) {} catch(Exception exc) { //     t ResultTextView.text += "-- Download Error: " + exc.Message + "\n"; } }</span></span></code> </pre> <br><br>  In this example, we download three images from the site, a link to one of them will cause a 403 error.  So, we will add all tasks to the tasks list and we will process them in a loop until the list is empty.  Create a composite task via Task.WhenAny and wait for it to complete, it will end when any of the nested tasks are completed and return it to us in t.  Remove the completed task from the list and execute wait t to get the result of the task.  Exceptions that worked during the execution of t will pop up after await is called.  Combinations of tasks are a powerful tool for operations of the same type, take a closer look at it. <br><br>  <b>Read more about C # async in <a href="http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx">Microsoft documentation</a> , support for iOS and Android APIs on <a href="http://docs.xamarin.com/guides/cross-platform/advanced/async_support_overview">the Xamarin website</a> .</b>  <b>Examples of applications in <a href="https://github.com/xamarin/mobile-samples/tree/master/AsyncAwait">the webinar repository</a> .</b> <br><br><hr>  Subscribe to our blog (button on the right above).  Every Thursday, useful articles about mobile development, marketing and business of mobile studio.  The next article (September 12) ‚ÄúHow sales are organized in a mobile studio‚Äù: our sales manager's confession about processes, reports, megaplanes, self-written CRM and ways of its professional growth. </div><p>Source: <a href="https://habr.com/ru/post/191926/">https://habr.com/ru/post/191926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191912/index.html">OpenMP is now available in Clang!</a></li>
<li><a href="../191916/index.html">Rust key features</a></li>
<li><a href="../191918/index.html">The world's smallest autopilot</a></li>
<li><a href="../191920/index.html">The history of personal computers in advertising. Part 1: 1970s</a></li>
<li><a href="../191922/index.html">Experience in building a b2b product: 3 continents in 6 years and half a mile of stuffed cones</a></li>
<li><a href="../191928/index.html">Dog's life in the Jimdo office in Hamburg</a></li>
<li><a href="../191932/index.html">.NET 4.5 - on-site update .NET 4.0</a></li>
<li><a href="../191934/index.html">.NET and design patterns</a></li>
<li><a href="../191936/index.html">Dendy console in amateur constructions</a></li>
<li><a href="../191938/index.html">The prosecutor's office of St. Petersburg has blocked the site for bribing a moderator with virtual currency!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>