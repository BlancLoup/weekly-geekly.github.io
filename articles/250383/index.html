<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free data structures. Concurrent map: warm up</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I was honored - invited to speak at the first C ++ 2015 Russia conference on February 27-28. I was so impudent that I asked for 2 hours to speak inste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free data structures. Concurrent map: warm up</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ba5/c68/1d2/ba5c681d22ee424f86fd4261dfa563bb.png" align="right"><br>  I was honored - invited to speak at the first <a href="http://meetingcpp.ru/">C ++ 2015 Russia</a> conference on February 27-28.  I was so impudent that I asked for 2 hours to speak instead of one, and declared the topic that interests me most - competitive associative containers.  This hash set / map and trees.  The organizer of the <a href="https://habrahabr.ru/users/sermp/" class="user_link">sermp</a> went to meet him, for which he thanks a lot. <br>  How to prepare for such a responsible <s>test</s> statement?  The first is to draw a presentation, that is, a bunch of pictures, preferably close to the subject.  But it is also necessary to voice the pictures for two hours, - how to remember all this?  How to avoid profound "eeemmmmm", "here we see", "this slide shows", incoherent jumping of the narration and other things that characterize the speaker is not very good in terms of fluency in the native language (I‚Äôm talking about Russian, I quickly understood C ++ - no code in the presentation, only pictures)? <br>  Of course, you need to write down your thoughts, looking at the slides.  And if something is written, then it would not be bad to publish.  And if you publish - then on the habr. <br>  So, in the wake of <a href="http://meetingcpp.ru/">C ++ 2015 Russia</a> !  The author's statement, I hope, without the author's inert language, without banknotes and with deviations on the topic, written before the onset of the event, in several parts. <br><a name="habracut"></a><br>  I, as a C ++ programmer, most of the standard container library had to use not queues / stacks / decks / lists, but associative containers - hash set / map, they are std :: unordered_set / map, and trees, that is, std :: set / map.  As we know, the C ++ 11 standard guarantees our thread-safe operation with such containers, but very weak - only read-only, any change - only under external locking!  In practice, such a guarantee is almost nothing, because if I see a read-only map, then most likely I will make a sorted array and look for it with a binary search - experience shows that this is faster, and memory is used carefully, and the processor cache nicely. <br>  Is it possible to implement a concurrent map container without the need for external synchronization?  Let's explore this question. <br>  To warm up, let's look at the internal structure of the hash map. <br><br><h1>  Hash table </h1><br>  Internally, the device of the simplest <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588-%25D1%2582%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0">hash map</a> with a list of collisions is extremely primitive: there is an array <code>T[N]</code> , each element of which is a list.  The entry to the table (index) is the hash value of the key.  All keys with the same hash (modulo <code>N</code> ) fall into the same list, called the collision list. <br><br><img src="https://habrastorage.org/files/cbb/567/957/cbb5679574e440a18b76340be85f92ff.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, the most important thing here is hidden inside the hash function.  A hash map will work well if and only if the correct hash function is selected for a set of keys.  "Correct" - this means, first of all, "well spreading" keys on the table cells.  But from the point of view of increasing the level of competition, it does not matter to us at all how the hash function is arranged inside, so that we will not talk more about it. <br>  Looking at the picture, you can immediately guess how to make the usual hash map competitive: instead of blocking access to the entire hash map, you can block at the level of each cell of the <code>T[N]</code> table.  Thus, work with each specific list of collisions <code>T[i]</code> will be serialized, but you can work with different lists <code>T[i]</code> and <code>T[j]</code> ( <code>i != j</code> ) in parallel.  This technique is described in the work of <a href="http://www.amazon.com/The-Multiprocessor-Programming-Revised-Reprint/dp/0123973376">M. Herlihy and Nir Shavit "The Art of Multiprocessor Programming"</a> and is called striping. <br><div class="spoiler">  <b class="spoiler_title">Claim to publishers</b> <div class="spoiler_text">  Why is this work not yet translated, although the original has already sustained two editions? !!!  This fundamental work from the world's most famous authors is an analogue of Knuth's monumental monograph, but for parallel algorithms, an invaluable guide for students and anyone who wants to figure out "how it works" is a launching pad for growing domestic cadres. <br>  No, we will publish "C ++ waste paper for 35 minutes for dummies"!  Teapots do not need C ++ !!!  And without such books, we will only have teapots.  This disclaimer does not concern readers of a habr. <br></div></div><br><br><h2>  Striped map </h2><br><img src="https://habrastorage.org/files/59e/f3a/403/59ef3a403261414db8d88bc225bd313f.png"><br><br>  So, in the striping technique, we have two arrays - the <code>Lock[N]</code> lock array and the <code>T[N]</code> hash table itself.  Initially, the size of these two arrays is the same (this is an important requirement, then we will see why).  The internal operation algorithm is simple: for any operation (insert / erase / find), we calculate the hash value <code>i</code> key modulo <code>N</code> , block the <code>Lock[i]</code> mutex and go to perform the operation in the <code>T[i]</code> list.  But there is one ‚Äúbut‚Äù: the hash table needs to be expanded from time to time.  The criterion for expansion is the so-called load factor: the ratio of the number of elements in the hash map to the size <code>N</code> hash table.  If we do not expand the table, the collision lists will become very large, and all the advantages of the hash map will turn into a pumpkin: instead of evaluating O (1) for the complexity of the operation, we get O (S / N), where S is the number of elements in the table, that with S &gt;&gt; N and unchanged N is equivalent to O (S), that is, the complexity of a linear search!  This is unacceptable.  To combat this phenomenon, rehashing is required: increase N, if the load factor exceeds a certain threshold value, and rebuild the hash table to the new hash values <code>std::hash(key) % N'</code> . <br>  The rehashing algorithm for the striped map is as follows: <br><br><img src="https://habrastorage.org/files/dec/1f5/e44/dec1f5e44e114f0d9c298d334d446a50.png"><br><br>  First, we block all mutexes from left to right;  then increment N by <i>an integer number</i> (integer is important, see below), rearrange the hash table, and finally unlock all mutexes in the reverse order - from right to left.  Do not forget that the main cause of deadlock is non-observance of the order of locking / unlocking several mutexes. <br><br>  Locking all mutexes here is important so that no one stops us from doing rehashing.  Rehashing is quite a hard operation and redistributes the keys to the cells of the new <code>T[N']</code> table. <br>  Note that above we talked about increasing the size of the hash table, but did not say anything about increasing the size of the <code>Lock[N]</code> lock array - this is no accident: the fact is that the size of the lock array <i>does not change</i> . <br><br><img src="https://habrastorage.org/files/0d4/48d/82b/0d448d82b2ec449db518fe40706a7cce.png"><br><br>  If the sizes of the arrays <code>Lock</code> and <code>T</code> different, then <i>in principle the</i> situation is possible when the same cell <code>T[k]</code> corresponds to different <code>Lock[i]</code> and <code>Lock[j]</code> mutexes, which breaks our entire slender algorithm.  For this to be unacceptable, it is required: <br><ol><li>  Initially, the sizes of arrays <code>Lock</code> and <code>T</code> coincide and are equal to <code>N</code> </li><li>  When rehashing, the new size <code>N'</code> array <code>T</code> calculated as <code>N' = k * N</code> , where <code>k</code> is a positive integer (usually 2). </li></ol><br>  Under these conditions, we always have the size of the array <code>T</code> is a multiple of the size of the array <code>Lock</code> (which does not change);  based on the properties of modular arithmetic, it is easy to prove that in this case the same <code>T[k]</code> cell <i>cannot</i> correspond to different <code>Lock[i]</code> and <code>Lock[j]</code> mutexes. <br><div class="spoiler">  <b class="spoiler_title">Refinable hash map</b> <div class="spoiler_text">  The authors of ‚ÄúThe Art of Multiprocessor Programming‚Äù go further by solving the rehashing problem for the <code>Lock</code> array, that is, by proposing an algorithm that allows you to increase the <code>Lock[]</code> size along with the increase in the hash table.  They call this algorithm a refinable hash map.  Interested refer to the original. <br></div></div><br>  The striping algorithm easily spreads to other data structures, such as trees: <br><br><img src="https://habrastorage.org/files/667/aae/4e4/667aae4e4702472680689e583aa013b7.png"><br><br>  The idea is very simple: each element of the <code>Lock[L]</code> mutex array protects its own tree.  The input to <code>Lock[L]</code> is the hash value of the key (modulo <code>L</code> ).  By locking <code>Lock[i]</code> , we gain access to the corresponding tree, in which we perform the required action. <br><div class="spoiler">  <b class="spoiler_title">libcds</b> <div class="spoiler_text">  The <a href="https://github.com/khizmax/libcds">libcds</a> library has striped and refinable hash set / map implementations, as well as adapters for all associative containers of STL and boost, including intrusive ones. <br></div></div><br>  The striping technique is not bad, but it has a significant flaw in terms of a series of articles on lock-free data structures - it is blocked.  Is there a lock-free algorithm for hash map? .. <br><br><a name="MichaelList"></a><br><h2>  Lock-free ordered list </h2><br>  Take another look at the internal structure of the hash map: <br><br><img src="https://habrastorage.org/files/cbb/567/957/cbb5679574e440a18b76340be85f92ff.png"><br><br>  As long as we leave the questions of rehashing overboard, we will assume that we a priori know the number of elements in the hash table and have a good hash function for our set of keys.  Then, to build a lock-free hash map, we need a bit - the lock-free list of collisions.  And the list of collisions is nothing more than an ordered (by key) single-linked list.  We will try to build it, after <a href="http://research.microsoft.com/pubs/67089/2001-disc.pdf">T.Harris</a> and <a href="http://www.research.ibm.com/people/m/michael/spaa-2002.pdf">M.Michael</a> . <br>  Searching a lock-free list is rather trivial: a linear pass through the list, starting with its head.  Considering that we use atomic operations and one of the <a href="http://habrahabr.ru/company/ifree/blog/202190/">safe deletion schemes</a> (Hazard Pointer, <a href="http://habrahabr.ru/company/ifree/blog/206984/">user-space RCU</a> or similar), the search algorithm is not much different from the usual search in an ordered list (in fact, if you look at the code, it is much this is a fee for lock-free). <br>  Inserting a new item is also not a problem: <br><br><img src="https://habrastorage.org/files/481/863/d3e/481863d3e28248c7a382bb92caa91f47.png"><br><br>  We are looking for the insertion position (remember that our list is ordered), create a new element and insert it with a single <a href="http://habrahabr.ru/company/ifree/blog/195948/">CAS</a> primitive (compare-and-swap, aka <code>std::compare_exchange</code> ). <br>  Removing is also quite trivial: <br><br><img src="https://habrastorage.org/files/d72/eb1/caf/d72eb1caf09a4e8287869459ef32aa7f.png"><br><br>  Linearly we look for a deleted element and atomically, with CAS, we throw the pointer from its predecessor to the next element. <br>  Problems begin when all this is done together and in parallel: flow A removes the element with key 3, flow B inserts key 4: <br><br><img src="https://habrastorage.org/files/1c5/bf3/e7b/1c5bf3e7b0bf4dc0a11b0284cd522571.png"><br><br>  Threads A and B simultaneously search;  at the same time, they store in local variables the position found for deletion (A) and for insertion (B).  Then flow A safely removed 3 from the list; flow B at that time, for example, was <s>drunk</s> expelled.  Further, flow B is planned by the operating system and continues its work on inserting key 4. It already has a local position in the local variables ‚Äî the <code>iprev</code> and <code>inext</code> in the list ‚Äî and it executes the atomic CAS primitive to insert the element ‚Äî where?  After the item with key 3, which is already excluded from the list!  (Hazard Pointer / RCU guarantee that the element 3 is not <i>physically</i> deleted yet, that is, we will not receive ‚Äúaccess to garbage‚Äù, but 3 is already excluded from the list by stream A).  Everything was completed without errors, as a result, the element with key 4 was lost and in addition we got a memory leak. <br><a name="HarrisTwoPhaseDel"></a><br>  T.Harris found an elegant solution to this problem in 2001.  He proposed a <i>two-phase</i> deletion of an element: the first phase - <i>logical deletion</i> - marks the element as deleted, not excluding it from the list, the second phase - <i>physical exclusion</i> - excludes the element from the list (and the third phase - physical <i>deletion</i> - is performed by the secure memory deletion scheme - Hazard Pointer, RCU or similar).  The point of logical deletion is to <i>mark the</i> element to be deleted in such a way that the CAS <i>does not work</i> on it.  For this, Harris suggested using the low bit of the <code>next</code> element's pointer.  Indeed, in modern architectures (both processors and OS), data is aligned on the border of 4 (for 32bit) or 8 (for 64bit) bytes, so the lower 2 or 3 bits of any pointer are always zero and can be used as bit flags.  Such a trick received the proper name of the <i>marked Pointer</i> and is widely used in lock-free programming. <br>  Using marked pointer, parallel insert / delete looks like this: <br><br><img src="https://habrastorage.org/files/bc2/30b/2b3/bc230b2b3ec7428c8deab35c94115c3f.png"><br><br>  Stream A marks element 3 as logically removed ‚Äî sets the low bit of the <code>found-&gt;next</code> pointer to one.  Now stream B, having tried to insert 4 after 3, will fail - CAS will not work, since we believe that the <code>3.next</code> pointer <code>3.next</code> not marked. <br>  The price of the marked pointer method is an additional call to CAS when the item is deleted. <br>  It may seem that all of the above described is unnecessarily and much faster and easier simply to assign the value of <code>nullptr</code> to the <code>next</code> pointer of the element to be <code>nullptr</code> - then the CAS on the insert will not work.  Yes, it is simpler, but these are two <i>independent</i> operations: one is an exception, the other is zeroing <code>next</code> .  And since there are two operations, then someone can interpose between them and insert a new element after the already excluded one.  Thus, we only <i>reduce the probability of</i> error, but do not exclude it.  Lock-free grimaces: everything should be done as atomically as possible, but in any case - without disturbing the internal structure of the container. <br><br><div class="spoiler">  <b class="spoiler_title">Historical excursion</b> <div class="spoiler_text">  The evolution of the Harris algorithm for the lock-free ordered list is interesting.  The original algorithm is distinguished by the fact that in principle the Hazard Pointer scheme is not applicable to it.  The fact is that the Harris algorithm assumes the physical removal of a <i>chain of</i> related list nodes, in principle, an infinite one.  As we know, the Hazard Pointer scheme first requires <i>protecting the</i> deleted elements by declaring them to be hazard, and only then do something with them.  But the number of hazard pointers is <i>limited</i> , we can not protect the entire dimensionless chain of elements! <br>  M. Michael, developing Hazard Pointer, revealed this fundamental inapplicability of his scheme to Harris's elegant algorithm and proposed his own modification, which also uses a two-phase deletion ‚Äî the reception of a marked pointer ‚Äî but removes the elements <i>one by one</i> , thereby making it permissible to use Hazard Pointer. <br>  There is another modification of this algorithm that solves the problem of <i>resuming the search</i> .  As I have repeatedly stressed, all the lock-free algorithms are an infinite loop of ‚Äúswotting until it works out‚Äù.  Describing the interesting situations above, I did not mention what needs to be done when the CAS did not work.  In fact, everything is simple: if the CAS on insertion / deletion did not work, we must again try to perform insertion / deletion from the very beginning - from the search position - until we either perform the operation or realize that it is impossible to perform (for insertion - because the key is already in the list, for deletion - because the key is not in the list).  Resuming the operation from the beginning of the list is an expensive thing if the list is long (and we will see later that, based on the list described here, you can build a rather efficient ordered container algorithm that supports millions of elements), so the thought comes: what if you start the repeated search not from the beginning , and from some previous element?  But the concept of ‚Äúprevious‚Äù in the ever-changing world of lock-free is very fragile.  In <a href="http://www.cse.yorku.ca/~ruppert/Mikhail.pdf">his thesis,</a> Fomichev suggests adding back-reference to some previous element in each element of the lock-free list and describes techniques for working with these pointers and keeping them up-to-date, rather complex. <br><br>  Well, to the heap - there is an original algorithm of an ordered list based on fine-grained locks at the level of each element - <a href="http://people.csail.mit.edu/shanir/publications/Lazy_Concurrent.pdf">lazy list</a> .  It is also implemented in libcds.  Despite its lock-based nature, the hash map, built on it, is not much inferior to the lock-free analogue disassembled in this article.  It uses spin-lockes as mutexes by default. <br></div></div><br><br>  So, we have analyzed the lock-free algorithm of an ordered list, with which you can implement a lock-free hash map.  The disadvantage of this algorithm is that it does not provide for rehashing, that is, we need to know a priori the estimated number of elements S in such a container and the optimal load factor.  Then the size N of the hash table <code>T[N]</code> is equal to <code>S / load factor</code> .  Nevertheless, despite these limitations, more precisely, thanks to them, such an algorithm is one of the fastest and scalable, since there is no overhead for rehashing. <br>  According to the results of my experiments, a good load factor is 2 - 4, that is, each lock-free list of collisions contains on average 2 - 4 items.  When load factor = 1 (the list of collisions consists of one element on average), the results are slightly better, but there is more memory overhead for actually degenerate lists of collisions. <br>  In the next article, we will look at an algorithm that quite originally supports rehashing and is based on the lock-free ordered list described here. <br><div class="spoiler">  <b class="spoiler_title">Lock-free data structures</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/company/ifree/blog/195770/">Start</a> <br>  Basics: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/195948/">Atomicity and atomic primitives</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/196548/">Where did the memory barriers go from</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/197520/">Memory model</a> </li></ul><br>  Inside: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/202190/">Memory management circuits</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/216013/">Stack evolution</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/219201/">Another treatise</a> </li><li>  <a href="http://habrahabr.ru/post/230349/">Queue dissection</a> </li><li>  <a href="http://habrahabr.ru/post/250383/">Concurrent maps: warm up</a> </li><li>  <a href="http://habrahabr.ru/post/250523/">Concurrent maps: rehash, no rebuild</a> </li><li>  <a href="http://habrahabr.ru/post/250815/">Concurrent maps: skip list</a> </li><li>  <a href="https://habrahabr.ru/post/251267/">Concurent maps: trees</a> </li><li>  <a href="https://habrahabr.ru/post/314948/">Iterators: multi-level array</a> </li><li>  <a href="https://habrahabr.ru/post/317882/">Iterable list</a> </li></ul><br>  Outside: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/196834/">Introduction to libcds</a> </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/250383/">https://habr.com/ru/post/250383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250371/index.html">We overload data from XPS to 1C processing without OCR</a></li>
<li><a href="../250373/index.html">As we explained to the children, who is a programmer?</a></li>
<li><a href="../250375/index.html">The book about the design on the FPGA (in Ukrainian)</a></li>
<li><a href="../250379/index.html">VkPlaylistServer - add music from VK to almost any audio player</a></li>
<li><a href="../250381/index.html">Metro.Prosto scheme</a></li>
<li><a href="../250385/index.html">Creating a CNC machine from parts available with minimum plumbing work</a></li>
<li><a href="../250387/index.html">Beeline: people's control (you can mark a technical problem on the map)</a></li>
<li><a href="../250389/index.html">Server insurance company refactoring: when there is less physical space than data</a></li>
<li><a href="../250391/index.html">Toaster. Collective editing of questions</a></li>
<li><a href="../250393/index.html">Vibration API: who needs it and why?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>