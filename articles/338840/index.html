<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How faster DOM build: parsing, async, defer and preload</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To date, a gentleman's set to accelerate the site includes everything from minifying and optimizing files to caching, CDN, code separation, and so-cal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How faster DOM build: parsing, async, defer and preload</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/3e2/8f9/f573e28f9eb94e5030c7e1c31c562b3e.png"></div><br>  To date, a gentleman's set to accelerate the site includes everything from minifying and optimizing files to caching, CDN, code separation, and so-called tree shaking.  But even if you are not familiar with this terminology, significant acceleration can be achieved with a couple of keywords with a well-thought-out code structure. <br><br>  Firefox will soon have a new web standard <code>&lt;link rel="preload"&gt;</code> , which will allow you to load important resources faster.  It can already be tested in the versions of Firefox Nightly and the Developer Edition, but for now this is a great reason to remember the basics of the browser and to understand more about performance when working with the DOM. <br><a name="habracut"></a><br>  The most important thing for a web developer is understanding what is happening under the hood of the browser.  In the article, we will look at how the browser interprets the page code and how it helps to load them faster with the help of speculative parsing, and then we will deal with <code>defer</code> , <code>async</code> and how the new standard <code>preload</code> can be used. <br><br><h1>  Brick by brick </h1><br>  HTML describes the structure of the page.  In order for the browser to be able to extract at least some benefit from HTML, it must be converted into a browser-friendly format - the Document Object Model or simply the DOM.  The browser has a special parser function that allows you to convert from one format to another.  HTML parser converts HTML to DOM. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Links of various elements in HTML are determined by nesting of tags.  In DOM, these same links form a tree data structure.  Each HTML tag in a DOM has its vertex (vertex DOM). <br><br>  Step by step, the browser builds the DOM.  As soon as the first lines of code become available, the browser starts parsing HTML, adding vertices to the tree. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd8/e3b/73e/fd8e3b73e5e591bcd276b84b01d726f9.gif"></div><br>  The DOM has two roles: the object representation of the HTML document and at the same time the DOM serves as an interface, connecting the page with the outside world, such as JavaScript.  If, for example, call <code>document.getElementById()</code> the function will return the vertex of the DOM.  To manipulate the vertex and how the user sees it, the vertex has many functions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/072/0d6/22b/0720d622ba490f23b33105a7349c8505.gif"></div><br>  CSS styles on the page are mapped to the CSSOM - CSS Object Model.  Very similar to DOM, but for CSS, not HTML.  Unlike DOM, CSSOM cannot be built step by step, because  CSS styles can override each other.  The browser has to work hard to apply CSS to the DOM. <br><br><h1>  History of the &lt;script&gt; tag </h1><br>  If, when building a DOM, the browser encounters the <code>&lt;script&gt;...&lt;/script&gt;</code> tag in HTML code, then it should immediately execute it, while downloading if it is from an external source. <br><br>  Previously, to run the script, you had to pause the parsing and continue it only after the script was executed by JavaScript. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/ec2/42c/aa8ec242c40277e41825c85b0972e3ff.png"></div><br>  Why do I need to stop parsing?  Scripts can modify both HTML and DOM.  The DOM structure can be modified using the <code>document.createElement()</code> function.  And the notorious <code>document.write()</code> function can also change HTML.  This function has earned notoriety because it can change HTML, complicating subsequent parsing.  For example, using this function, you can insert a comment opening tag, thereby breaking HTML. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea4/99d/019/ea499d019e1fba14dfed6c7eaa37de11.gif"></div><br>  Scripts can also send requests to the DOM, and if this happens during the construction of the DOM, the result can be unpredictable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1a/402/90e/a1a40290e8786157e281fb45abbc66ec.png"></div><br>  <code>document.write()</code> is a legacy function that can break a page in unexpected ways, so it‚Äôs better not to use it, even if browsers support it.  For these reasons, browsers have developed clever methods of circumventing performance problems caused by blocking scripts, about them a little lower. <br><br><h1>  What about CSS? </h1><br>  JavaScript pauses HTML parsing because  scripts can change the page.  CSS cannot change the page, so there‚Äôs no reason to stop the parsing process, right? <br><br>  But what if the script asks for information about the style of an element that has not yet been parsed?  The browser has no idea what will be executed in the script - it can be a request to the top of the DOM about the <code>background-color</code> property, depending on the style sheet, or it can be a direct appeal to CSSOM <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70a/cc1/c1a/70acc1c1ae113103f33fb6c65ec40d14.png"></div><br>  Because of this, CSS can block parsing, depending on the order of connection of scripts and styles on the page.  If external style sheets are up to scripts, then creating DOM and CSSOM can interfere with each other.  When the parser reaches the script, the DOM build cannot continue until JavaScript executes the script, and JavaScript in turn cannot be run until the CSS is downloaded, parted, and CSSOM becomes available. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/817/f53/dfe/817f53dfeca8877369311481902ee4ac.png"></div><br>  One more thing you should not forget.  Even if the CSS does not block the construction of the DOM, it blocks the rendering process.  The browser will not show anything until it has ready DOM and CSSOM.  This is because pages without CSS are often unsuitable for use.  If the browser shows the curve page without CSS, and then after a moment the full stylized page, then the user will experience cognitive dissonance. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/micikato/embed/preview/JroPNm" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>This phenomenon has a name - Glimpse of Unformed Content, abbreviated as Flash of Unstyled Content or FOUC.</i> <br><br>  To avoid such problems, you need to provide CSS as soon as possible.  Remember the golden rule "styles from above, scripts from below"?  Now you know why this is important! <br><br><h1>  Back to the Future.  Speculative parsing </h1><br>  Suspending the parser at every encounter with the script will mean a delay in processing the rest of the data loaded in HTML. <br><br>  Previously, if you take several scripts and images by loading them, for example, like this: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slider.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"animate.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cookie.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slide1.png"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slide2.png"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  The parsing process would look like the one below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/960/d50/522/960d50522f019abd7973b600c5f95185.png"></div><br>  This behavior changed in 2008 when IE introduced the so-called ‚Äúlookahead downloader‚Äù.  With the help of it, files were uploaded in the background during the execution of scripts.  Soon, this method was adopted by Firefox, Chrome with Safari, using it under various names, as well as most modern browsers.  In Chrome with Safari, this is a ‚Äúpreliminary analysis‚Äù [of the preload scanner], and in Firefox it is a speculative parser.  The idea is this, given the fact that building a DOM while executing scripts is very risky, you can still parse HTML to see what resources should be uploaded.  Then the detected files are added to the download queue and downloaded in parallel in the background.  And by the time the script is completed, the necessary files may be ready to use. <br><br>  Thus, using this method, the parsing process above would look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32b/13b/b75/32b13bb750761105cf99ea389ab37892.png"></div><br>  Such a process is called ‚Äúspeculative‚Äù, sometimes ‚Äúrisky‚Äù, because HTML can still change during the execution of the script (let me remind you of <code>document.write</code> ), which can lead to work done in vain.  But despite the fact that such a scenario is possible, it is extremely rare, which is why speculative parsing gives a huge performance boost. <br><br>  While other browsers load only bound files in this way, the Firefox parser also continues to build the DOM during the execution of the scripts.  The advantage of this is that if the speculation has passed, then some of the work in the construction of the DOM will already be done.  But in the case of unsuccessful speculation work will be spent more. <br><br><h1>  (Prev) Download </h1><br>  When using such a loading technique, you can significantly increase the download speed and no special skills will be required for this.  But if you are a web developer, then knowledge of the mechanism of speculative parsing will help to use it to the maximum. <br><br>  Different browsers preload different types of resources.  All major browsers must preload the following: <br><br><ul><li>  scripts </li><li>  external css </li><li>  and images in the <code>&lt;img&gt;</code> </li></ul><br>  Firefox also loads the <code>poster</code> attribute on video elements, while Chrome and Safari load the <code>@import</code> rules from inlined styles. <br><br>  The number of files that can be downloaded in parallel is limited and varies from browser to browser.  It also depends on many factors, such as whether files are downloaded from a single server or from different ones, the HTTP / 1.1 or HTTP / 2 protocol is used.  To render a page as quickly as possible, browsers use complex algorithms and download resources with different priorities, depending on the type of resource, location on the page and the state of the rendering process itself. <br><br>  When speculative parsing, the browser does not launch inline JavaScript blocks.  This means that if files are loaded in scripts, they will most likely be the last in the download queue. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> script = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>); script.src = <span class="hljs-string"><span class="hljs-string">"//somehost.com/widget.js"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'head'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].appendChild(script);</code> </pre> <br>  Therefore, it is very important to simplify the task of the browser when downloading important resources.  You can, for example, insert them into HTML tags or transfer the download script to inline and as high as possible in the page code.  Although sometimes it is required on the contrary, to upload files as late as possible, since  they are not so important.  In this case, to hide the resource from the speculative parser, it can be connected as late as possible on the page via JavaScript.  To learn more about how to optimize the page for the speculative parser, you can follow the <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Optimizing_Your_Pages_for_Speculative_Parsing">MDN</a> link of the <a href="https://developer.mozilla.org/ru/docs/Web/HTML/Optimizing_Your_Pages_for_Speculative_Parsing">manual</a> [in Russian]. <br><br><h1>  defer and async </h1><br>  But scripts running in sequence remain a problem.  And not all scripts are really important for the user, such as analytics scripts, for example.  Ideas?  You can load them asynchronously. <br><br>  The <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script">defer and async</a> attributes were designed specifically for this, to enable developers to specify which scripts can be loaded asynchronously. <br><br>  Both of these attributes will prompt the browser that it can continue parsing HTML and at the same time load these scripts in the background.  In this scenario, the scripts will not block the construction of the DOM and rendering, as a result, the user will see the page before all the scripts are loaded. <br><br>  The difference between <code>defer</code> and <code>async</code> is that they start executing scripts at different <code>defer</code> in time. <br><br>  <code>defer</code> appeared before <code>async</code> .  Scripts with this attribute are executed after the parsing is complete, but before the <code>DOMContentLoaded</code> event.  They are guaranteed to be launched in the order in which they are on the page and will not block the parser. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a1/a5d/1bb/1a1a5d1bb25369527a9db6da54b9122e.png"></div><br>  Scripts with <code>async</code> will be executed at the first opportunity after they are loaded and before the <a href="https://developer.mozilla.org/ru/docs/Web/Events/load">load</a> event at the <code>window</code> .  This means that it is possible (and most likely certain) scripts with <code>async</code> will be executed not in the order of their appearance in HTML.  It also means that they can block the construction of the DOM. <br><br>  Wherever they are listed, scripts with <code>async</code> are loaded with low priority, often after all other scripts, without blocking the DOM build.  But if the script with <code>async</code> loads faster, then its execution can block the construction of the DOM and all other scripts that just need to be loaded. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1b/e26/ba1/c1be26ba1354f5e3b078c7cd4617f66c.png"></div><br>  <i>Note: the <code>async</code> and <code>defer</code> work only for external scripts.</i>  <i>Without the <code>src</code> parameter, they will be ignored.</i> <br><br><h1>  preload </h1><br>  <code>async</code> and <code>defer</code> great if you don‚Äôt sweat about some scripts, but what about resources on the page that are important to the user?  Speculative parsers are useful, but are only suitable for a handful of resource types and act on their own logic.  In general, you need to load CSS in the first place, because it blocks rendering, sequential scripts should always have higher priority than asynchronous, visible images should be available soon and there are more fonts, videos, SVG ... in short, everything is complicated. <br><br>  As an author, you better know exactly what resources are important for rendering the page.  Some of them are often buried in CSS or scripts and the browser will have to go through the jungle before it even reaches them.  For these important resources, you can now use <code>&lt;link rel="preload"&gt;</code> to tell the browser to load the file as soon as possible. <br>  All you need to write is: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"preload"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"very_important.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">as</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"script"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  The list of what can be downloaded is quite large and the <code>as</code> attribute will tell the browser what kind of content it downloads.  Possible values ‚Äã‚Äãfor this attribute: <br><br><ul><li>  script </li><li>  style </li><li>  image </li><li>  font </li><li>  audio </li><li>  video </li></ul><br>  More details can be found in <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content">MDN</a> [in English]. <br><br>  Fonts are perhaps the most important element to load, which is hidden in CSS.  Fonts are needed to render text on a page, but they will not be loaded until the browser makes sure that they are used.  And this check only happens after parsing and applying CSS and when the styles are already applied to the vertices of the DOM.  This happens rather late in the page loading process and usually results in an unjustified delay in rendering the text.  This can be avoided by using the <code>preload</code> attribute when loading fonts.  One detail to pay attention to when downloading fonts is that you need to set the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">crossorigin</a> attribute, even if the font is on the same domain. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"preload"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"font.woff"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">as</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"font"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">crossorigin</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  At this time, the preloading options are limited and browsers are just starting to use this method, but you can monitor progress <a href="https://caniuse.com/">here</a> . <br><br><h1>  Conclusion </h1><br>  Browsers are complex creatures that have evolved since the 90s.  We have dismantled some quirks from the past as well as the latest standards in web development.  These recommendations will help make sites more pleasant for the user. <br><br>  If you want to learn more about browsers, here are a couple of articles that may be of interest to you: <br><br>  ‚Üí <a href="https://hacks.mozilla.org/2017/05/quantum-up-close-what-is-a-browser-engine/">Quantum Up Close: What is a browser engine?</a> <a href="https://hacks.mozilla.org/2017/05/quantum-up-close-what-is-a-browser-engine/"><br></a> <br>  ‚Üí <a href="https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/">Inside a super fast CSS engine: Quantum CSS (aka Stylo)</a> ( <a href="https://habrahabr.ru/post/336722/">habr</a> ) </div><p>Source: <a href="https://habr.com/ru/post/338840/">https://habr.com/ru/post/338840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338824/index.html">Who needs flakes</a></li>
<li><a href="../338828/index.html">Sending a request to all databases of all specified servers using the example of MS SQL Server and C # .NET</a></li>
<li><a href="../338830/index.html">Data geometry 6. Star graph</a></li>
<li><a href="../338832/index.html">Numbers - Douglas Crockford‚Äôs paper on number systems in life and in programming</a></li>
<li><a href="../338836/index.html">Design patterns in test automation</a></li>
<li><a href="../338844/index.html">Web server - your first Arduino network program</a></li>
<li><a href="../338846/index.html">How to get frustrated and NOT go Linux</a></li>
<li><a href="../338848/index.html">PowerShell for IT security. Part IV: Script Security Platform</a></li>
<li><a href="../338850/index.html">Strange character and hot announcements of the first days of Microsoft Ignite</a></li>
<li><a href="../338852/index.html">Why do business games and what have the ERA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>