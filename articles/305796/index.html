<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learning OpenGL ES2 for Android Lesson ‚Ññ2. Creating triangles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lesson number 2. Creating triangles 

 The basis of the code and ideas I drew from here: 
 1. Satia Komatineni, Dave Macklin, Saeed Hashimi. Android 3...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learning OpenGL ES2 for Android Lesson ‚Ññ2. Creating triangles</h1><div class="post__text post__text-html js-mediator-article">  <b>Lesson number 2.</b>  <b>Creating triangles</b> <br><br>  The basis of the code and ideas I drew from here: <br>  1. Satia Komatineni, Dave Macklin, Saeed Hashimi.  Android 3 for professionals.  Creating applications for tablets and smartphones .: Trans.  from English  - Moscow: I.D. Williams LLC.  2012 - 1024 s. <br>  2. <a href="http://www.learnopengles.com/android-lesson-one-getting-started/">http://www.learnopengles.com/android-lesson-one-getting-started/</a> <br><br>  At the first lesson (you can see here <a href="https://habrahabr.ru/post/278895/">https://habrahabr.ru/post/278895/</a> or here <a href="http://albatrossgames.blogspot.com/2016/03/opengl-es-2-android-1-opengl.html">albatrossgames.blogspot.com/2016/03/opengl-es-2-android-1-opengl.html#more</a> ) we are with you learned how to fill the screen with one color using OpenGL ES.  It is time to draw triangles, or rather, with the help of triangles, we will draw a sailboat that will move cyclically from left to right. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/5a2/ee6/8ee/5a2ee68ee8664c788078f82f593cca71.png" alt="image1"><br><a name="habracut"></a><br>  Why triangles?  The fact is that in OpenGL there are only three graphic primitives: a point, a line and a triangle.  The hull of the yacht (trapezium) and the sea (rectangle) are also drawn using triangles.  As is known, a point in our space is determined by three coordinates (x, y, z).  Since our drawing is flat, then all the points of the drawing have one coordinate along the 0z axis (it is perpendicular to the screen plane and goes towards us) will be equal to zero.  For example, I indicated the coordinates on the 0x axis and 0y of the two extreme points of the large sail (grotto). <br><br><img src="https://habrastorage.org/files/b9a/41b/ac1/b9a41bac1612439ba07cfb881403ba9c.jpg" alt="image2"><br><br>  In the code, the definition of the three points of the grotto is <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// this triangle is white-blue. First sail is mainsail final float[] triangle1VerticesData = { // X, Y, Z, // R, G, B, A -0.5f, -0.25f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f, -0.25f, 0.0f, 0.8f, 0.8f, 1.0f, 1.0f, 0.0f, 0.56f, 0.0f, 0.8f, 0.8f, 1.0f, 1.0f};</span></span></code> </pre> <br><br>  As you can see, a float array is created.  For each point its coordinate and color scale is indicated.  The first point is white, so the weights of red, green and blue are the same and equal to 1, but for the other two peaks I have changed the color for beauty.  Bypassing points is done counterclockwise. <br>  The dimension of the coordinates in OpenGL is conditional and will actually be determined by the number of pixels on the screen of the device in terms of width and height. <br>  Now we need to create a buffer where we will transfer the data on points for OpenGL.  This is due to the fact that OpenGL is written in a C-like language.  Therefore, we translate our data into a different form that is understandable for OpenGL, allocating memory. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** How many bytes per float. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mBytesPerFloat = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Initialize the buffers. mTriangle1Vertices = ByteBuffer.allocateDirect(triangle1VerticesData.length * mBytesPerFloat) .order(ByteOrder.nativeOrder()).asFloatBuffer(); mTriangle1Vertices.put(triangle1VerticesData).position(0);</span></span></code> </pre><br><img src="https://habrastorage.org/files/237/9b6/e9d/2379b6e9d662458f92bef1c732a62f1b.jpg" alt="image"><br><br>  Let's look at each part.  First, we allocated a block of computer memory using ByteBuffer.allocateDirect ();  this memory will not be managed by the Garbage Collector (which is important).  It is necessary to tell the method how large a block of memory should be in bytes.  Since our vertices are stored in the array as float variables and occupy 4 bytes for each float, we pass in triangle1VerticesData.length * mBytesPerFloat.  (Let me remind you that private final int mBytesPerFloat = 4;) <br><br>  The next line tells the byte buffer how it should organize its bytes in machine code.  When it comes to values ‚Äã‚Äãthat span several bytes, such as 32-bit integers, bytes can be written in a different order, for example, from the most significant value to the least significant.  It is like writing a large number either from left to right or from right to left.  We don't care, but what matters is that we use the same order as the system.  We arrange this by calling order (ByteOrder.nativeOrder ()).  Finally, it is better not to deal with individual bytes directly.  We want to work with floats, so we call FloatBuffer () to get a FloatBuffer that contains the main bytes.  Then we copy, starting from the zero position, the data from the Dalvik memory into the machine memory, calling mTriangle1Vertices.put (triangle1VerticesData) .position (0); <br><br>  The memory will be released when the process stops, so we do not need to worry about it. <br><br>  <b>Understanding Matrices</b> <br>  A good lesson to understand matrices <a href="http://www.songho.ca/opengl/gl_transform.html">www.songho.ca/opengl/gl_transform.html</a> <br><br>  To understand the matrix, you first need to figure out how we "see" an object in OpenGL. <br>  Imagine that you are holding a camera in your hands and want to take a picture of our sailboat. <br><br><img src="https://habrastorage.org/files/ac8/745/7fa/ac87457fae8d4e95a0229640b01f6a74.jpg" alt="image"><br><br>  Let our camera is in because it is called a point of view.  If we do not specify a viewpoint in the code, the camera will default to the coordinates with (0,0,0). <br>  Let's see how the camera position is defined in the code: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL10 glUnused, EGLConfig config)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Set the background clear color to gray. GLES20.glClearColor(0.5f, 0.5f, 0.7f, 1.0f); // Position the eye behind the origin. final float eyeX = 0.0f; final float eyeY = 0.0f; final float eyeZ = 1.5f; // We are looking toward the distance final float lookX = 0.0f; final float lookY = 0.0f; final float lookZ = -5.0f; // Set our up vector. This is where our head would be pointing were we holding the camera. final float upX = 0.0f; final float upY = 1.0f; final float upZ = 0.0f; // Set the view matrix. This matrix can be said to represent the camera position. // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> In OpenGL 1, a ModelView matrix is used, which is a combination of a model and // view matrix. In OpenGL 2, we can keep track of these matrices separately if we choose. Matrix.setLookAtM(mViewMatrix, 0, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ);</span></span></code> </pre><br>  In the beginning, we set the background color to blue-gray, similarly, as we did in the first lesson. <br><pre> <code class="java hljs">GLES20.glClearColor(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>);</code> </pre><br>  Then they placed the camera, they actually indicated the coordinates of t.  As you can see, the camera is shifted along the 0z axis by 1.5 units (the distance is OK). <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> eyeX = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> eyeY = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> eyeZ = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre><br>  In the following lines of code, we indicate the coordinate of the point at which the camera is looking. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lookX = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lookY = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lookZ = -<span class="hljs-number"><span class="hljs-number">5.0f</span></span>;</code> </pre><br>  The following lines of code define how the camera is oriented or the up vector position.  Due to unsuccessful translations, in various articles there were inaccuracies in this matter.  In our code now <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upX = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upY = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upZ = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>;</code> </pre><br>  This means that the camera is placed normally, so if you put it on a horizontal table and look at the sailboat in t.0. <br><br><img src="https://habrastorage.org/files/cc8/be0/e15/cc8be0e15a014565ba75c5dc3cdd4406.jpg"><br>  Now imagine that there are three vectors coming out of the camera, as from the so-called.  Putting the final float weighting factor upY = 1.0f, we say to OpenGL that the 0U axis will be pointing upwards and see the picture, as in the beginning of the article. <br>  But once we put these coefficients <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upX = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upY = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upZ = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>;</code> </pre><br>  we will see the following on the emulator.  Our sailboat will climb upwards. <br><img src="https://habrastorage.org/files/366/edc/392/366edc3924084d9794f32174641113b7.png"><br>  The camera turned 45 degrees counterclockwise, if you look at the axis 0z.  It is clear that if you make such a combination <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upX = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upY = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upZ = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>;</code> </pre><br>  the 0x camera axis will look upwards and the boat will sail vertically upwards. <br>  We pass all our data to the setLookAtM method. <br>  Matrix.setLookAtM (mViewMatrix, 0, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ); <br><br>  <b>Visible camera volume</b> <br><br>  Consider the following piece of code. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSurfaceChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL10 glUnused, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Set the OpenGL viewport to the same size as the surface. GLES20.glViewport(0, 0, width, height); // Create a new perspective projection matrix. The height will stay the same // while the width will vary as per aspect ratio. final float ratio = (float) width / height; final float left = -ratio; final float right = ratio; final float bottom = -1.0f; final float top = 1.0f; final float near = 1.0f; final float far = 10.0f; Matrix.frustumM(mProjectionMatrix, 0, left, right, bottom, top, near, far); }</span></span></code> </pre><br>  The onSurfaceChanged method allows you to work out the orientation change of the device itself. <br>  Let's turn our gadget on the emulator and see this picture <br><img src="https://habrastorage.org/files/f52/fe2/f41/f52fe2f41c3c4d4a84560cd4c9194260.png" alt="image"><br>  Not very beautiful, but in principle what we drew. <br>  The next line of code sets the screen size.  First, set the coordinates of the lower point of the left corner of the screen (0,0), and then the width and height of the screen. <br>  GLES20.glViewport (0, 0, width, height); <br>  Let's review our drawing again: <br><br><img src="https://habrastorage.org/files/ac8/745/7fa/ac87457fae8d4e95a0229640b01f6a74.jpg" alt="image"><br><br>  The volume that our camera sees is enclosed in the volume of a truncated pyramid (A <sub>1</sub> , B <sub>1</sub> , C <sub>1</sub> , D <sub>1</sub> , A <sub>2</sub> , B <sub>2</sub> , C <sub>2</sub> , D <sub>2</sub> ). <br>  First we find the ratio of the width to the height of the device (ratio). <br>  final float ratio = (float) width / height; <br>  Then we set the coordinate to 0x of the left and right side of the visible box (A <sub>1</sub> , B <sub>1</sub> , C <sub>1</sub> , D <sub>1</sub> ). <br>  final float left = -ratio; <br>  final float right = ratio; <br>  We specify the 0 coordinate of the lower and upper sides of the parallelepiped (A <sub>1</sub> , B <sub>1</sub> , C <sub>1</sub> , D <sub>1</sub> ). <br>  final float bottom = -1.0f; <br>  final float top = 1.0f; <br>  The distance from the camera to the front side (KO <sub>1</sub> ) <br>  final float near = 1.0f; <br>  The distance from the camera to the back side (KO <sub>2</sub> ) <br>  final float far = 10.0f; <br>  Apply matrix transformation <br>  Matrix.frustumM (mProjectionMatrix, 0, left, right, bottom, top, near, far); <br>  There are several different types of matrices that we use: <br>  1. Matrix model.  This matrix is ‚Äã‚Äãused to place the model somewhere in the "world."  For example, if you have a car model, and you want to position it at a distance of 1000 m to the east, you will use the model matrix. <br>  2. The matrix of the form.  This matrix is ‚Äã‚Äãa camera.  If we want to look at our car, which is 1000 m to the east, we must move ourselves to 1000 m to the east.  Or you can stay still and move the rest of the world 1000 meters to the west.  To do this, we will use a view matrix. <br>  3. Projection matrix.  Since our screens are flat, we need to make a final transformation into the ‚Äúproject‚Äù of our view on the screen and get a 3D perspective.  To do this, use the projection matrix. <br><br>  <b>Definition of vertex and fragment shaders</b> <br>  Even the simplest drawings in OpenGL ES 2.0 require the creation of software segments called shaders.  Shaders form the core of OpenGL ES 2.0.  Vertices are processed by vertex shaders and deal only with vertex points.  The spaces between the vertices are processed using fragment shaders; they deal with each pixel on the screen. <br><br>  For writing shaders use the programming language OpenGL Shading Language (GLSL). <br>  Each shader mainly consists of input, output and program.  First we define the form, which is a combined matrix containing all our transformations.  It is constant for all vertices and is used to project them onto the screen.  Then we define two attributes for the position and color.  These attributes will be read from the buffer that we defined earlier; they set the position and color of each vertex.  Then we define the variation (color change), which interpolates the values ‚Äã‚Äãfor the entire triangle and passes it to the fragment shader.  When it comes to the fragment shader, it will contain an interpolated value for each pixel. <br><br>  Let's say we have defined a triangle whose vertices will be red, green and blue, and its size will occupy 10 pixels on the screen.  When executing a fragment shader, it will contain a different changing color for each pixel.  At some point, that change will be red, but halfway between red and blue, it may be a purple color. <br><br>  Consider our vertex shader <br><pre> <code class="cs hljs">final String vertexShader = <span class="hljs-string"><span class="hljs-string">"uniform mat4 u_MVPMatrix; \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">// A constant representing the combined model/view/projection matrix. + "attribute vec4 a_Position; \n" // Per-vertex position information we will pass in. + "attribute vec4 a_Color; \n" // Per-vertex color information we will pass in. + "varying vec4 v_Color; \n" // This will be passed into the fragment shader. + "void main() \n" // The entry point for our vertex shader. + "{ \n" + " v_Color = a_Color; \n" // Pass the color through to the fragment shader. // It will be interpolated across the triangle. + " gl_Position = u_MVPMatrix \n" // gl_Position is a special variable used to store the final position. + " * a_Position; \n" // Multiply the vertex by the matrix to get the final point in + "} \n"; // normalized screen coordinates.</span></span></code> </pre><br><br>  Through the uniform (uniform) external data are transferred to the shaders, which can be used for calculations.  Uniforms can only be used for reading.  Uniforms can be transferred to both vertex and fragment shaders.  In our case, there is only one uniform - this is the matrix of the projection view-model u_MVPMatrix and it is passed to the vertex shader.  The mat4 keyword means that it is a 4x4 matrix consisting of floating point numbers.  Uniforms have nothing to do with a particular vertex and are global constants.  For the name of the uniform usually use the prefix u_. <br>  Attributes (attribute) is a property of the vertex.  Vertices may have different attributes.  For example, position coordinates in space, coordinates of the normal vector, color.  In addition, you can pass any attributes to the vertex shader.  It is important to understand that an attribute is a property of a vertex and therefore it must be defined for each vertex.  Attributes are transmitted only to the vertex shader.  Attributes are available to the vertex shader only for reading.  Attributes cannot be defined in a fragment shader.  In the future, for convenience, we denote attributes with the prefix a_. <br><br>  Define three attributes in the vertex shader: <br>  attribute vec4 a_Position; <br>  The variable a_Position is a vertex attribute that deals with the position of the vertex (coordinates); it is a four-component vector (vec4). <br>  Vertex color attribute <br>  attribute vec4 a_Color; <br>  Color Interpolation Attribute <br>  varying vec4 v_Color; <br>  Consider the main function code in more detail: <br>  v_Color = a_Color; <br>  We transfer the information about the color of the vertices to the fragment shader. <br>  gl_Position = u_MVPMatrix * a_Position; <br>  Transform the position of the vertices using the matrix and write to the new variable gl_Position. <br>  The system variable gl_Position is a four-component vector defining the vertex coordinates projected onto the screen plane.  The variable gl_Position must be defined in the vertex shader, otherwise we will not see anything on the screen. <br><br>  <b>Let us proceed to the consideration of the fragment shader.</b> <br><pre> <code class="cs hljs">final String fragmentShader = <span class="hljs-string"><span class="hljs-string">"precision mediump float; \n"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Set the default precision to medium. We don't need as high of a // precision in the fragment shader. + "varying vec4 v_Color; \n" // This is the color from the vertex shader interpolated across the // triangle per fragment. + "void main() \n" // The entry point for our fragment shader. + "{ \n" + " gl_FragColor = v_Color; \n" // Pass the color directly through the pipeline. + "} \n";</span></span></code> </pre><br>  The default accuracy is set to medium, since we do not need it high in the case of a fragment shader.  In the vertex shader, the default accuracy is high. <br>  precision mediump float; <br>  The ultimate goal of a fragment shader is to get the color of a pixel.  The calculated color of the pixel must be recorded in the system variable gl_FragColor.  In our simplest example, we do not calculate the color of the pixel in the fragment shader, but simply assign the value of the color v_color, obtained by interpolation from the colors of the vertices: <br>  gl_FragColor = v_color; <br><br>  <b>Loading shaders in OpenGL</b> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Load in the vertex shader. int vertexShaderHandle = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER); if (vertexShaderHandle != 0) { // Pass in the shader source. GLES20.glShaderSource(vertexShaderHandle, vertexShader); // Compile the shader. GLES20.glCompileShader(vertexShaderHandle); // Get the compilation status. final int[] compileStatus = new int[1]; GLES20.glGetShaderiv(vertexShaderHandle, GLES20.GL_COMPILE_STATUS, compileStatus, 0); // If the compilation failed, delete the shader. if (compileStatus[0] == 0) { GLES20.glDeleteShader(vertexShaderHandle); vertexShaderHandle = 0; } } if (vertexShaderHandle == 0) { throw new RuntimeException("Error creating vertex shader."); }</span></span></code> </pre><br>  <b>Linking vertex and fragment shaders together in a program</b> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Create a program object and store the handle to it. int programHandle = GLES20.glCreateProgram(); if (programHandle != 0) { // Bind the vertex shader to the program. GLES20.glAttachShader(programHandle, vertexShaderHandle); // Bind the fragment shader to the program. GLES20.glAttachShader(programHandle, fragmentShaderHandle); // Bind attributes GLES20.glBindAttribLocation(programHandle, 0, "a_Position"); GLES20.glBindAttribLocation(programHandle, 1, "a_Color"); // Link the two shaders together into a program. GLES20.glLinkProgram(programHandle); // Get the link status. final int[] linkStatus = new int[1]; GLES20.glGetProgramiv(programHandle, GLES20.GL_LINK_STATUS, linkStatus, 0); // If the link failed, delete the program. if (linkStatus[0] == 0) { GLES20.glDeleteProgram(programHandle); programHandle = 0; } } if (programHandle == 0) { throw new RuntimeException("Error creating program."); }</span></span></code> </pre><br><br>  Before using our vertex and fragment shaders, we need to link them together in the program.  This is what connects the output of the vertex shader to the input of the fragment shader.  This is also what allows us to transfer input from our program and use shaders to draw our shapes. <br><br>  We create a new software object, and if it succeeds, we then attach our shaders.  We want to pass position and color data as attributes, so we need to link these attributes.  Then we tie the shaders together. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//New class members /** This will be used to pass in the transformation matrix. */ private int mMVPMatrixHandle; /** This will be used to pass in model position information. */ private int mPositionHandle; /** This will be used to pass in model color information. */ private int mColorHandle; @Override public void onSurfaceCreated(GL10 glUnused, EGLConfig config) { ... // Set program handles. These will later be used to pass in values to the program. mMVPMatrixHandle = GLES20.glGetUniformLocation(programHandle, "u_MVPMatrix"); mPositionHandle = GLES20.glGetAttribLocation(programHandle, "a_Position"); mColorHandle = GLES20.glGetAttribLocation(programHandle, "a_Color"); // Tell OpenGL to use this program when rendering. GLES20.glUseProgram(programHandle); }</span></span></code> </pre><br>  After we have successfully linked our program, we will finish with a couple of big tasks, now we can really use it.  The first task is to get links, so we can transfer data to the program.  Then we tell OpenGL to use this program when drawing occurs.  Since we only use one program in this tutorial, we can put this in onSurfaceCreated () instead of onDrawFrame (). <br><br>  <b>Installing a perspective projection</b> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// New class members /** Store the projection matrix. This is used to project the scene onto a 2D viewport. */ private float[] mProjectionMatrix = new float[16]; @Override public void onSurfaceChanged(GL10 glUnused, int width, int height) { // Set the OpenGL viewport to the same size as the surface. GLES20.glViewport(0, 0, width, height); // Create a new perspective projection matrix. The height will stay the same // while the width will vary as per aspect ratio. final float ratio = (float) width / height; final float left = -ratio; final float right = ratio; final float bottom = -1.0f; final float top = 1.0f; final float near = 1.0f; final float far = 10.0f; Matrix.frustumM(mProjectionMatrix, 0, left, right, bottom, top, near, far); }</span></span></code> </pre><br>  Our onSurfaceChanged () method is called at least once, as well as whenever our surface changes.  Since we need to reset our projection matrix whenever the projection on the screen changes, onSurfaceChanged () is the perfect place to do this. <br><br>  <b>Displaying objects on the screen</b> <br>  The output is produced in the onDrawFrame method (GL10 glUnused) <br>  To make the triangles move along the 0x axis, we apply the displacement matrix and set the increase in x offset by 0.001 for each surface update.  As soon as x reaches 1 or the right edge of the screen, reset it. <br><br>  Matrix.translateM (mModelMatrix, 0, x + 0.3f, 0.0f, 0.0f); <br>  drawTriangle (mTriangle2Vertices); <br>  if (x &lt;= 1) {x = (float) (x + 0.001);} <br>  else {x = 0;} <br>  I think for the second lesson is more than enough.  Many questions are missed, and their understanding will come later. <br><br>  <b>Running a lesson on Android Studio.</b> <br><br>  I recommend using the draft of the previous lesson and just copying this code into it. <br>  If you do not have it, then create a project First Open GL Project <br>  <u>AndroidManifest.xml</u> <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.adc2017gmail.firstopenglproject"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:supportsRtl</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">uses-feature</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:glEsVersion</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0x00020000"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:required</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".FirstOpenGLProjectActivity"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.action.MAIN"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.LAUNCHER"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  <u>FirstOpenGLProjectActivity.java</u> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.adc2017gmail.firstopenglproject; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.app.Activity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.app.ActivityManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.Context; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.ConfigurationInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.opengl.GLSurfaceView; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Bundle; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstOpenGLProjectActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** Hold a reference to our GLSurfaceView */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GLSurfaceView mGLSurfaceView; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); mGLSurfaceView = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GLSurfaceView(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Check if the system supports OpenGL ES 2.0. final ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); final ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo(); final boolean supportsEs2 = configurationInfo.reqGlEsVersion &gt;= 0x20000; if (supportsEs2) { // Request an OpenGL ES 2.0 compatible context. mGLSurfaceView.setEGLContextClientVersion(2); // Set the renderer to our demo renderer, defined below. mGLSurfaceView.setRenderer(new LessonOneRenderer()); } else { // This is where you could create an OpenGL ES 1.x compatible // renderer if you wanted to support both ES 1 and ES 2. return; } setContentView(mGLSurfaceView); } @Override protected void onResume() { // The activity must call the GL surface view's onResume() on activity onResume(). super.onResume(); mGLSurfaceView.onResume(); } @Override protected void onPause() { // The activity must call the GL surface view's onPause() on activity onPause(). super.onPause(); mGLSurfaceView.onPause(); } }</span></span></code> </pre><br><br>  <u>LessonOneRenderer.java</u> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.adc2017gmail.firstopenglproject; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.opengl.GLES20; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.opengl.GLSurfaceView; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.opengl.Matrix; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteOrder; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.FloatBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.microedition.khronos.egl.EGLConfig; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.microedition.khronos.opengles.GL10; <span class="hljs-comment"><span class="hljs-comment">/** * This class implements our custom renderer. Note that the GL10 parameter passed in is unused for OpenGL ES 2.0 * renderers -- the static class GLES20 is used instead. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LessonOneRenderer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GLSurfaceView</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Renderer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Store the model matrix. This matrix is used to move models from object space (where each model can be thought * of being located at the center of the universe) to world space. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] mModelMatrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/** * Store the view matrix. This can be thought of as our camera. This matrix transforms world space to eye space; * it positions things relative to our eye. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] mViewMatrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/** Store the projection matrix. This is used to project the scene onto a 2D viewport. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] mProjectionMatrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/** Allocate storage for the final combined matrix. This will be passed into the shader program. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] mMVPMatrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/** Store our model data in a float buffer. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FloatBuffer mTriangle1Vertices; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FloatBuffer mTriangle2Vertices; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FloatBuffer mTriangle3Vertices; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FloatBuffer mTriangle4Vertices; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FloatBuffer mTriangle5Vertices; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FloatBuffer mTriangle6Vertices; <span class="hljs-comment"><span class="hljs-comment">/** This will be used to pass in the transformation matrix. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mMVPMatrixHandle; <span class="hljs-comment"><span class="hljs-comment">/** This will be used to pass in model position information. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mPositionHandle; <span class="hljs-comment"><span class="hljs-comment">/** This will be used to pass in model color information. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mColorHandle; <span class="hljs-comment"><span class="hljs-comment">/** How many bytes per float. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mBytesPerFloat = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** How many elements per vertex. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mStrideBytes = <span class="hljs-number"><span class="hljs-number">7</span></span> * mBytesPerFloat; <span class="hljs-comment"><span class="hljs-comment">/** Offset of the position data. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mPositionOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** Size of the position data in elements. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mPositionDataSize = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** Offset of the color data. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mColorOffset = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** Size of the color data in elements. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mColorDataSize = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-comment"><span class="hljs-comment">/** * Initialize the model data. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LessonOneRenderer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Define points for equilateral triangles. // This triangle is white_blue.First sail is mainsail final float[] triangle1VerticesData = { // X, Y, Z, // R, G, B, A -0.5f, -0.25f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f, -0.25f, 0.0f, 0.8f, 0.8f, 1.0f, 1.0f, 0.0f, 0.56f, 0.0f, 0.8f, 0.8f, 1.0f, 1.0f}; // This triangle is white_blue..The second is called the jib sail final float[] triangle2VerticesData = { // X, Y, Z, // R, G, B, A -0.25f, -0.25f, 0.0f, 0.8f, 0.8f, 1.0f, 1.0f, 0.03f, -0.25f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, -0.25f, 0.4f, 0.0f, 0.8f, 0.8f, 1.0f, 1.0f}; // This triangle3 is blue. final float[] triangle3VerticesData = { // X, Y, Z, // R, G, B, A -1.0f, -1.5f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, -0.35f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, -1.0f, -0.35f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f}; // This triangle4 is blue. final float[] triangle4VerticesData = { // X, Y, Z, // R, G, B, A -1.0f, -1.5f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, -1.5f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, -0.35f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f}; // This triangle5 is brown. final float[] triangle5VerticesData = { // X, Y, Z, // R, G, B, A -0.4f, -0.3f, 0.0f, 0.7f, 0.3f, 0.4f, 1.0f, -0.4f, -0.4f, 0.0f, 0.7f, 0.3f, 0.4f, 1.0f, 0.3f, -0.3f, 0.0f, 0.7f, 0.3f, 0.4f, 1.0f}; // This triangle6 is brown. final float[] triangle6VerticesData = { // X, Y, Z, // R, G, B, A -0.4f, -0.4f, 0.0f, 0.7f, 0.3f, 0.4f, 1.0f, 0.22f, -0.4f, 0.0f, 0.7f, 0.3f, 0.4f, 1.0f, 0.3f, -0.3f, 0.0f, 0.7f, 0.3f, 0.4f, 1.0f}; // Initialize the buffers. mTriangle1Vertices = ByteBuffer.allocateDirect(triangle1VerticesData.length * mBytesPerFloat) .order(ByteOrder.nativeOrder()).asFloatBuffer(); mTriangle2Vertices = ByteBuffer.allocateDirect(triangle2VerticesData.length * mBytesPerFloat) .order(ByteOrder.nativeOrder()).asFloatBuffer(); mTriangle3Vertices = ByteBuffer.allocateDirect(triangle3VerticesData.length * mBytesPerFloat) .order(ByteOrder.nativeOrder()).asFloatBuffer(); mTriangle4Vertices = ByteBuffer.allocateDirect(triangle4VerticesData.length * mBytesPerFloat) .order(ByteOrder.nativeOrder()).asFloatBuffer(); mTriangle5Vertices = ByteBuffer.allocateDirect(triangle5VerticesData.length * mBytesPerFloat) .order(ByteOrder.nativeOrder()).asFloatBuffer(); mTriangle6Vertices = ByteBuffer.allocateDirect(triangle6VerticesData.length * mBytesPerFloat) .order(ByteOrder.nativeOrder()).asFloatBuffer(); mTriangle1Vertices.put(triangle1VerticesData).position(0); mTriangle2Vertices.put(triangle2VerticesData).position(0); mTriangle3Vertices.put(triangle3VerticesData).position(0); mTriangle4Vertices.put(triangle4VerticesData).position(0); mTriangle5Vertices.put(triangle5VerticesData).position(0); mTriangle6Vertices.put(triangle6VerticesData).position(0); } @Override public void onSurfaceCreated(GL10 glUnused, EGLConfig config) { // Set the background clear color to gray. GLES20.glClearColor(0.5f, 0.5f, 0.7f, 1.0f); // Position the eye behind the origin. final float eyeX = 0.0f; final float eyeY = 0.0f; final float eyeZ = 1.5f; // We are looking toward the distance final float lookX = 0.0f; final float lookY = 0.0f; final float lookZ = -5.0f; // Set our up vector. This is where our head would be pointing were we holding the camera. final float upX = 0.0f; final float upY = 1.0f; final float upZ = 0.0f; // Set the view matrix. This matrix can be said to represent the camera position. // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> In OpenGL 1, a ModelView matrix is used, which is a combination of a model and // view matrix. In OpenGL 2, we can keep track of these matrices separately if we choose. Matrix.setLookAtM(mViewMatrix, 0, eyeX, eyeY, eyeZ, lookX, lookY, lookZ, upX, upY, upZ); final String vertexShader = "uniform mat4 u_MVPMatrix; \n" // A constant representing the combined model/view/projection matrix. + "attribute vec4 a_Position; \n" // Per-vertex position information we will pass in. + "attribute vec4 a_Color; \n" // Per-vertex color information we will pass in. + "varying vec4 v_Color; \n" // This will be passed into the fragment shader. + "void main() \n" // The entry point for our vertex shader. + "{ \n" + " v_Color = a_Color; \n" // Pass the color through to the fragment shader. // It will be interpolated across the triangle. + " gl_Position = u_MVPMatrix \n" // gl_Position is a special variable used to store the final position. + " * a_Position; \n" // Multiply the vertex by the matrix to get the final point in + "} \n"; // normalized screen coordinates. final String fragmentShader = "precision mediump float; \n" // Set the default precision to medium. We don't need as high of a // precision in the fragment shader. + "varying vec4 v_Color; \n" // This is the color from the vertex shader interpolated across the // triangle per fragment. + "void main() \n" // The entry point for our fragment shader. + "{ \n" + " gl_FragColor = v_Color; \n" // Pass the color directly through the pipeline. + "} \n"; // Load in the vertex shader. int vertexShaderHandle = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER); if (vertexShaderHandle != 0) { // Pass in the shader source. GLES20.glShaderSource(vertexShaderHandle, vertexShader); // Compile the shader. GLES20.glCompileShader(vertexShaderHandle); // Get the compilation status. final int[] compileStatus = new int[1]; GLES20.glGetShaderiv(vertexShaderHandle, GLES20.GL_COMPILE_STATUS, compileStatus, 0); // If the compilation failed, delete the shader. if (compileStatus[0] == 0) { GLES20.glDeleteShader(vertexShaderHandle); vertexShaderHandle = 0; } } if (vertexShaderHandle == 0) { throw new RuntimeException("Error creating vertex shader."); } // Load in the fragment shader shader. int fragmentShaderHandle = GLES20.glCreateShader(GLES20.GL_FRAGMENT_SHADER); if (fragmentShaderHandle != 0) { // Pass in the shader source. GLES20.glShaderSource(fragmentShaderHandle, fragmentShader); // Compile the shader. GLES20.glCompileShader(fragmentShaderHandle); // Get the compilation status. final int[] compileStatus = new int[1]; GLES20.glGetShaderiv(fragmentShaderHandle, GLES20.GL_COMPILE_STATUS, compileStatus, 0); // If the compilation failed, delete the shader. if (compileStatus[0] == 0) { GLES20.glDeleteShader(fragmentShaderHandle); fragmentShaderHandle = 0; } } if (fragmentShaderHandle == 0) { throw new RuntimeException("Error creating fragment shader."); } // Create a program object and store the handle to it. int programHandle = GLES20.glCreateProgram(); if (programHandle != 0) { // Bind the vertex shader to the program. GLES20.glAttachShader(programHandle, vertexShaderHandle); // Bind the fragment shader to the program. GLES20.glAttachShader(programHandle, fragmentShaderHandle); // Bind attributes GLES20.glBindAttribLocation(programHandle, 0, "a_Position"); GLES20.glBindAttribLocation(programHandle, 1, "a_Color"); // Link the two shaders together into a program. GLES20.glLinkProgram(programHandle); // Get the link status. final int[] linkStatus = new int[1]; GLES20.glGetProgramiv(programHandle, GLES20.GL_LINK_STATUS, linkStatus, 0); // If the link failed, delete the program. if (linkStatus[0] == 0) { GLES20.glDeleteProgram(programHandle); programHandle = 0; } } if (programHandle == 0) { throw new RuntimeException("Error creating program."); } // Set program handles. These will later be used to pass in values to the program. mMVPMatrixHandle = GLES20.glGetUniformLocation(programHandle, "u_MVPMatrix"); mPositionHandle = GLES20.glGetAttribLocation(programHandle, "a_Position"); mColorHandle = GLES20.glGetAttribLocation(programHandle, "a_Color"); // Tell OpenGL to use this program when rendering. GLES20.glUseProgram(programHandle); } @Override public void onSurfaceChanged(GL10 glUnused, int width, int height) { // Set the OpenGL viewport to the same size as the surface. GLES20.glViewport(0, 0, width, height); // Create a new perspective projection matrix. The height will stay the same // while the width will vary as per aspect ratio. final float ratio = (float) width / height; final float left = -ratio; final float right = ratio; final float bottom = -1.0f; final float top = 1.0f; final float near = 1.0f; final float far = 10.0f; Matrix.frustumM(mProjectionMatrix, 0, left, right, bottom, top, near, far); } @Override public void onDrawFrame(GL10 glUnused) { GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT); // Draw the triangle facing straight on. Matrix.setIdentityM(mModelMatrix, 0); Matrix.translateM(mModelMatrix, 0, x, 0.0f, 0.0f); drawTriangle(mTriangle1Vertices); // Draw triangle_2. Matrix.setIdentityM(mModelMatrix, 0); Matrix.translateM(mModelMatrix, 0, x + 0.3f, 0.0f, 0.0f); drawTriangle(mTriangle2Vertices); if(x&lt;=1){x = (float) (x + 0.001);} else {x=0;} // Draw triangle_3. Matrix.setIdentityM(mModelMatrix, 0); drawTriangle(mTriangle3Vertices); // Draw triangle_4. Matrix.setIdentityM(mModelMatrix, 0); drawTriangle(mTriangle4Vertices); // Draw triangle_5. Boat Matrix.setIdentityM(mModelMatrix, 0); Matrix.translateM(mModelMatrix, 0, x, 0.0f, 0.0f); //Matrix.rotateM(mModelMatrix, 0, 0, 0.0f, 0.0f, 1.0f); drawTriangle(mTriangle5Vertices); // Draw triangle_6. Boat Matrix.setIdentityM(mModelMatrix, 0); Matrix.translateM(mModelMatrix, 0, x, 0.0f, 0.0f); //Matrix.rotateM(mModelMatrix, 0, 0, 0.0f, 0.0f, 1.0f); drawTriangle(mTriangle6Vertices); } /** * Draws a triangle from the given vertex data. * * @param aTriangleBuffer The buffer containing the vertex data. */ private void drawTriangle(final FloatBuffer aTriangleBuffer) { // Pass in the position information aTriangleBuffer.position(mPositionOffset); GLES20.glVertexAttribPointer(mPositionHandle, mPositionDataSize, GLES20.GL_FLOAT, false, mStrideBytes, aTriangleBuffer); GLES20.glEnableVertexAttribArray(mPositionHandle); // Pass in the color information aTriangleBuffer.position(mColorOffset); GLES20.glVertexAttribPointer(mColorHandle, mColorDataSize, GLES20.GL_FLOAT, false, mStrideBytes, aTriangleBuffer); GLES20.glEnableVertexAttribArray(mColorHandle); // This multiplies the view matrix by the model matrix, and stores the result in the MVP matrix // (which currently contains model * view). Matrix.multiplyMM(mMVPMatrix, 0, mViewMatrix, 0, mModelMatrix, 0); // This multiplies the modelview matrix by the projection matrix, and stores the result in the MVP matrix // (which now contains model * view * projection). Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mMVPMatrix, 0); GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mMVPMatrix, 0); GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, 3); } }</span></span></code> </pre><br><br><h4>  List of sources </h4><br> 1.  ,  ,  . Android 3  .       .: .  from English ‚Äì .:  ¬´..¬ª. 2012 ‚Äì 1024 . <br> 2. <a href="http://www.learnopengles.com/android-lesson-one-getting-started/">http://www.learnopengles.com/android-lesson-one-getting-started/</a> <br> 3. <a href="http://andmonahov.blogspot.com/2012/10/opengl-es-20-1.html">http://andmonahov.blogspot.com/2012/10/opengl-es-20-1.html</a> <br> 4. <a href="https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/attributes.php">https://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/attributes.php</a> <br> 5. <a href="https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf">https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf</a> </div><p>Source: <a href="https://habr.com/ru/post/305796/">https://habr.com/ru/post/305796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305786/index.html">ORM on php for MySQL, reality (part one)</a></li>
<li><a href="../305788/index.html">The recent past: a study on the problems of test automation</a></li>
<li><a href="../305790/index.html">Google page speed insights 100 out of 100 on the platform for online store</a></li>
<li><a href="../305792/index.html">The digest of interesting materials for the mobile # 162 developer (July 11-17)</a></li>
<li><a href="../305794/index.html">Introduction to the concept of entropy and its many faces</a></li>
<li><a href="../305798/index.html">MVP on steroids: make the robot write the code for you</a></li>
<li><a href="../305800/index.html">STM32F405: flash 400kb in 10 seconds or a fast UART bootloader sharpened for USB-UART, less than 4 kilobytes in size</a></li>
<li><a href="../305802/index.html">Create a multilanguage blog using OctoberCMS</a></li>
<li><a href="../305808/index.html">PHP Digest number 88 - interesting news, materials and tools (June 13 - July 17, 2016)</a></li>
<li><a href="../305812/index.html">Honest MVC at React + Redux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>