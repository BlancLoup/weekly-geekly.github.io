<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automatic text recognition in video</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a translation of the article "Automatic text recognition in digital videos" by Rainer Lienhart and Frank Stuber, University of Mannhei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automatic text recognition in video</h1><div class="post__text post__text-html js-mediator-article">  <i>This article is a translation of the article "Automatic text recognition in digital videos" by Rainer Lienhart and Frank Stuber, University of Mannheim, Germany.</i> <br><br><h2>  Short review </h2><br>  We develop algorithms for the automatic segmentation of characters in films that extract text from the preface, captions and conclusion.  Our algorithms use standard text symbols in video to improve the quality of segmentation and, as a result, recognition efficiency.  As a result, we have separate characters from frames.  They can be analyzed using any OCR software.  The results of recognition of several copies of the same symbol in all subsequent frames are combined to improve the quality of recognition and to calculate the final result.  We tested our algorithms in a series of experiments with video clips recorded from a TV and achieved good segmentation results. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  In the multimedia era, video is becoming an increasingly important and common way of transmitting information.  However, most of the current video data is unstructured, that is, stored and displayed only as pixels.  There is no additional information about the video content: year of release, cast, directors, costumers, filming locations, positions and types of scene breaks, etc., so the ease of use of unprocessed video is limited, which eliminates efficient and productive search.  There are thousands of MPEG videos online.  It is rare to find any information about the content and structure of these films in addition to the title and brief description, therefore searching, for example, specific scenes can be seen and scenes - a serious task.  We would all like to receive more detailed information about video content than we have now. <br><br>  Usually this information needs to be written manually, but manual annotation of a video is very expensive and takes a lot of effort.  Thus, searching and viewing content-based information gives rise to the need for automatic video analysis tools for indexing. [2] [15] [16] [17]  One of the important sources of information about a video is the text contained in it.  We have developed algorithms for automatic segmentation of symbols and their recognition in the video.  These algorithms automatically and reliably extract text from the preface, titles and conclusion.  Algorithms explicitly use typical text characteristics in video created by video header generators or similar devices and / or methods to improve the quality of segmentation and, as a result, recognition efficiency. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The rest of the article is organized as follows.  Section 2 discusses similar work on text segmentation and text recognition in video.  We then describe the features of the characters and text displayed in the films, and present in section 4 our characteristics-based approach to the segmentation of candidate areas, which are based on the characteristics of the characters listed in section 3. Section 5 discusses our recognition algorithms.  This is followed by some information on the implementation of the algorithms in section 6. In section 7, we present empirical results as evidence that our algorithms lead to good segmentation results.  Finally, we complete our work with a summary and prospect of future work. <br><br><h2>  Related work </h2><br>  At the moment, the existing work on the recognition of text is mainly focused on optical character recognition in printed and handwritten documents, since there is a great demand for devices for reading documents for office automation systems and in the market.  These systems have reached a high degree of maturity. [6]  Also, text recognition works can be found in industrial applications.  Most of this work focuses on a very narrow scope.  An example is the automatic recognition of license plates. [13]  The proposed system works only for characters / numbers whose background is mostly monochrome and whose position is limited.  On top of that, a little work was published on character recognition in text appearing in video programs. <br><br>  Michael A. Smith and Takeo Canada briefly describe in [12] a method that concentrates on extracting areas from video frames containing textual information.  However, they do not prepare the detected text for standard optical character recognition software.  In particular, they do not attempt to define the outlines of characters or segment individual characters.  They save bitmap images containing text as is.  People need to disassemble them on their own.  They characterize the text as a ‚Äúhorizontal rectangular structure of grouped sharp edges‚Äù [12] and use this function to identify text segments.  We also use this feature in our approach during the filling phase.  Unlike their approach, this function plays only a small role in the process of segmentation of candidate areas.  We also use several instances in different conditions to increase the efficiency of segmentation and recognition. <br><br>  Another interesting approach to text recognition in scene images is Yun Ohya, Akio Shio and Shigeru Akamatsu.  Characters in scene images may suffer from a variety of noise components.  Text in scene images exists in three-dimensional space, so it can turn, bend, partially hide and / or darken and be under uncontrolled lighting. [7]  In view of the many possible degrees of freedom of text characters, Ohya and others have limited them to almost vertical, monochromatic and unrelated, in order to facilitate detection.  This makes the approach of Ohya et al. Feasible for our purpose, despite the fact that they focus on still images rather than video streams, and therefore do not use the characteristics typical of text appearing in video.  Moreover, we focus on the text generated by the video header generators, and not on the text of the scene. <br><br><h2>  Features of characters in titles and introductory and final text </h2><br>  The text in the videos serves for different purposes: at the beginning and / or end of the broadcast, he informs the audience about its title, director, actors, producers, etc.  The broadcast text also provides important information about the subject that is currently being covered.  For example, text in sports broadcasts often reports results, while news releases and documentaries show the name and place of the speaker and / or important information about the topic.  Text in advertising informs slogan, product or company name.  These textual representations have a common point that they are clearly directed.  They do not appear just like that - they are superimposed on the frame and created to be read. <br><br>  In addition, the text can also be displayed in the scenes as part of them: for example, in the video of the shopping center, many store names can be seen in the video.  Such text in the video is difficult to detect or recognize, it can be under any tilt, have distortion, in any light and on straight or wavy surfaces (for example, text on a T-shirt). <br><br>  We do not work with the text of the scene in this article; rather, we concentrate solely on the text added to the video artificially, especially with the help of the video header generator.  The reason lies in the fact that the text that is superimposed on top of the scene is fundamentally different from the text contained in the scenes, and we did not want to deal with two different problems at the same time.  Thus, in the following, the words ‚Äútext‚Äù and ‚Äúsymbol‚Äù will refer exclusively to those video headers that are made by machines or similar devices / methods. <br><br>  Before it becomes possible to recognize words and text, it is necessary to analyze the features of their appearance. <br><br>  Our list includes: <br><br><ul><li>  Monochrome symbols.  Only a very small percentage have chromaticity, so this parameter is not of great interest; </li><li>  The characters are hard.  They do not change their shape, size or orientation from frame to frame.  Again, the percentage of characters that change size is not so high, so they are not interested in us either; </li><li>  Characters have a size limit.  Letters are not as big as the entire frame, and less than a certain number of pixels, because otherwise they would be unreadable for people; </li><li>  Symbols are fixed or moving linearly.  Stationary symbols do not move, their position remains fixed on several subsequent frames.  Moving characters are constantly moving [3] and have a constant direction of movement: as a rule, they move either horizontally or vertically.  Moreover, most of the moving text moves from right to left or from bottom to top; </li><li>  The characters contrast with the background.  Artificial text is designed to be read and, therefore, must be distinguishable from the background.  But, as we will see later, due to the narrow bandwidth of the television signal, this item is not reserved for all character outlines; </li><li>  The same characters appear in several consecutive frames (temporal relation); </li><li>  Characters often appear in clusters (lines) at a limited distance, aligned horizontally (spatial relation), since this is a natural method of recording words and sentences.  But this is not a prerequisite, just an obvious indicator.  From time to time only one character may appear on a single line; </li><li>  The quality of symbol / border contours is falling due to modern television technologies and digital converter boards.  Characters are often mixed with the background, especially on the left side.  Monochrome symbols no longer look as such.  The color is very turbid and sometimes changes slightly in space and time, for example, by mixing with the color of the surrounding background.  Even still text can move several pixels.  These are typical old analogue television and video recordings. </li></ul><br>  Any (artificial) method of segmentation and text recognition should be based on these observable features.  Next we describe their use. <br><br><h2>  Separation of candidate symbol areas </h2><br>  Theoretically, the segmentation pass extracts all pixels belonging to the text appearing in the video.  However, it is impossible to do without knowing where and what characters.  Thus, the ultimate goal of the segmentation stage is to divide the pixels of each video frame into two classes: <br><br><ul><li>  Areas containing text; </li><li>  Areas that do not contain text. </li></ul><br>  Areas that do not contain text are discarded because they cannot contribute to the recognition process, and areas that may contain text are retained.  We call them candidate areas, because they are (not quite) a superset of character areas.  They will be passed to the recognition stage for evaluation. <br><br>  Here we describe the segmentation process.  It can be divided into three parts, each part increasing the set of symbolic areas of the previous part by other areas that do not contain text, thereby reducing candidate areas, bringing them more and more closer to areas with symbols.  First, we process each frame independently of the others.  Then we try to take advantage of several copies of the same text in successive frames.  Finally, we analyze the contrast of the remaining areas in each frame in order to further reduce the number of candidate areas and construct final candidate areas.  In each part, we use the functions of the symbols, as described in section 3. <br><br><h3>  Character segmentation in candidate regions in single frames </h3><br><h4>  Monochromatic </h4><br>  Let's start with the original frame (Fig. 1).  Due to the supposed monochromatic character of the characters, we divide the frame to homogeneous gray scale segments at the first stage of processing.  We use the ‚ÄúSeparation and Merge‚Äù algorithm proposed by Horowitz and Pavlidis [4] to perform segmentation.  It is based on a hierarchical decomposition of the frame.  According to Horowitz and Pavlidis, the separation process begins with the entire image as an initial segment, which is then divided into quarters.  Each quarter is tested for certain uniformity criteria to determine if a segment is ‚Äúhomogeneous enough‚Äù.  If it is not homogeneous enough, the segment is again divided into quarters.  This process is applied recursively until only homogeneous segments remain.  We use the standard uniformity criterion: the difference between the highest and lowest intensities of a gray tone should be below a certain threshold.  We call the threshold max_split_distance.  A homogeneous segment is assigned its average gray level.  Then, in the merge process, adjacent segments are combined together if their intensity of the average gray tone is less than the max_merge_distance parameter.  As a result, all monochrome characters appearing in the image must be contained in some monochrome segments.  For our example frame, the Split and Merge algorithm displays the image shown in Figure 2. <br><br><h4>  Size restrictions. </h4><br>  Now the segmented image consists of areas of uniform gray tone intensity.  Some areas are too large and others too small to be instantiated characters.  Consequently, the width and height of monochrome segments exceed max_size, since the connected monochrome segments, the aggregate size of which is less than min_size.  An example of the image can be seen in Figure 3 (the deleted segments became black). <br><br><img src="https://pp.userapi.com/c638231/v638231513/6e403/NNwewAJlPyg.jpg" alt="image"><br>  <i>Figure 1. Original frame</i> <br><br><img src="https://pp.userapi.com/c638231/v638231513/6e40a/CN_0Uqd0MZs.jpg" alt="image"><br>  <i>Figure 2. Figure 1 using the Split and Merge method</i> <br><br><h3>  Improved segmentation based on sequential frames </h3><br>  As we analyze text in videos created by video header generators, the same text usually appears in the number of consecutive frames.  Obviously, the result of the segmentation can be improved by using these multiple instances of the same text, because each character of the text often looks slightly changed from frame to frame due to noise, background changes and / or position changes.  Thus, we must detect the corresponding character of the candidate area in successive frames. <br><br><h4>  Motion analysis </h4><br>  As mentioned in section 3, the text considered here is either stationary or linearly moving, and even stationary text can move several pixels around its original position from frame to frame.  Therefore, we must perform a motion analysis to detect the corresponding candidate areas in consecutive frames.  Movement is estimated using block mapping, since block mapping is suitable for hard objects, and characters are considered hard if their shape, orientation and color do not change.  Moreover, block mapping is very popular and is used to compensate for movement in international standards for video compression, such as H.261 and MPEG3.  Our criterion of conformity is the minimum average criterion of absolute difference [14].  Mean absolute difference (MAD) is defined as <br><br><img src="https://pp.userapi.com/c638231/v638231513/6e412/k6Yk-t-j9SQ.jpg" alt="image"><br><br>  R indicates the block for which the translation vector is to be calculated.  Offset estimate <img src="https://pp.userapi.com/c638231/v638231513/6e419/5atYXu4OLys.jpg" alt="image">  for block R, is set as an offset, where the MAD value is minimal.  Search scope is limited <img src="https://pp.userapi.com/c638231/v638231513/6e420/9DrgVbz-Gek.jpg" alt="image">  and follows from the speed of scrollable titles. <br><br>  The upcoming question is how to determine the location and size of the blocks that will be used for motion estimation.  Obviously, the quality of the estimation of the displacement depends on the position and size of the block, which we are trying to compare with its instance in a sequential frame.  For example, if the selected block is too large, it may not be possible for the algorithm to find an equivalent block, since parts of the block may leave the frame (this may happen with scroll lists) or parts of the block in the next frame may be correctly recognized as background, while in the first frame, they were not filtered and remained part of the candidate area. <br><br>  To avoid these problems, we use the fact that characters appear as words and therefore fit into strings.  We select our R block using the following algorithm: the input image is converted to two-color (background = black, the rest = white).  And each white pixel expands around the specified radius.  As can be seen from Figure 4, symbols and words now constitute a compact area.  We structure each connected cluster in a rectangle and define it as a block R. If the fill factor is above a certain threshold, the block is used for motion analysis.  If the fill factor is below a certain threshold, the block is recursively divided into smaller blocks until the fill factor for the resulting block exceeds the threshold value.  For each result block that corresponds to the required fill factor, motion analysis is performed according to block matching. <br><br><img src="https://pp.userapi.com/c638231/v638231513/6e427/YkIckCIp4ag.jpg" alt="image"><br>  <i>Figure 3. Applying size restrictions for Figure 2</i> <br><br><img src="https://pp.userapi.com/c638231/v638231513/6e43b/2ZJAvZqRhnQ.jpg" alt="image"><br>  <i>Figure 4: Figure 3 after turning into a two-color frame and stretching.</i>  <i>Blocks are marked with rectangles.</i> <br><br>  Blocks with no equivalent in the next frame are discarded.  In addition, blocks that have an equivalent in a subsequent frame, but demonstrate a significant difference in their average gray tone intensity, are discarded.  The resulting image is transferred to the next stage of segmentation (Figure 5). <br><br><img src="https://pp.userapi.com/c638231/v638231513/6e451/m1Hr_NKkliU.jpg" alt="image"><br>  <i>Figure 5: Image result after applying motion analysis to two consecutive frames in Figure 3</i> <br><br><h3>  Improved segmentation of candidate areas using contrast analysis </h3><br><h4>  Contrast analysis </h4><br>  Characters created by video header generators are usually contrasted with their background.  Therefore, it is also a prerequisite for candidate areas.  Therefore, each area remaining from the previous segmentation step is checked to see if its contour is partially contrasted strongly with the background and / or other remaining areas.  Especially dark shadows, often lying below symbols, in order to improve readability, should result in very strong contrast between the areas of the characters and parts of their environment.  If no such contrast is found for the region, we conclude that it cannot belong to the symbol and discard the region. <br><br>  Contrast analysis is performed by the following processing queue: we compute a map of Canny's boundaries (1) and apply a significantly high threshold (called canny_threshold) to limit the response to sharp edges.  The resulting edge image is expanded with dilation_radius.  Then the areas from the segmentation stage of the motion analysis are discarded if they do not intersect with any extended edge.  In our example, this leads to the result shown in Figure 6. <br><br><h4>  Fill factor and width to height ratio </h4><br>  The blocks and their corresponding fill factors are calculated again for each remaining candidate area, as described in the motion analysis section above.  If the fill factor is too low, the corresponding areas are discarded.  Then the ratio of the width to the height of the blocks is calculated.  If it exceeds certain limits, i.e.  does not lie between min_ratio and max_ratio, corresponding areas are also discarded.  This process leads to the final image segmentation.  Figure 7 shows this for our exemplary video frame. <br><br><h4>  Segmentation result </h4><br>  So far, the candidate symbol areas for each frame have been extracted.  Regions are saved in new frames, thereby creating a new video.  In these frames, pixels belonging to candidate areas retain their original gray level.  All other pixels are marked as background.  The segmentation is complete, and the new video can be analyzed frame by frame with any standard OCR software. <br><br><img src="https://pp.userapi.com/c638231/v638231513/6e458/TBNBmee_Yho.jpg" alt="image"><br>  <i>Figure 6: Result after contrasting analysis of Figure 5</i> <br><br><img src="https://pp.userapi.com/c638231/v638231513/6e45f/ylECrmpRQjc.jpg" alt="image"><br>  <i>Figure 7: Final Segmentation</i> <br><br><h2>  Character recognition </h2><br>  Segmentation provides a video showing the areas of candidates.  When recognizing characters, each frame must be analyzed by OCR software.  We implemented our own OCR software using the classification of objects with vector characteristics, as described in [11].  However, this software is far from perfect, and the use of a commercial software package should lead to higher recognition rates. <br><br>  As we analyze the video, each character appears in several consecutive frames.  Thus, all instances of recognition of the same character must be combined into one recognition result.  The corresponding symbols and groups of symbols are identified by motion analysis, as described in section 4.2.  Thus, we can associate multiple independent recognition results with the same symbol and word.  The most frequent result is the final result of recognition. <br><br><h2>  Implementation </h2><br>  Segmentation algorithms were implemented on SUN SPARCstation 5 under Solaris 2.4 and on DEC ALPHA 3000 under Digital Unix 3.2 with 2300 lines of code C. They are part of the MoCA Workbench5 and require the Vista 1.3 library as the basis. [9,10] OCR software is implemented on C in 1200 lines of C code and trained in 14 different postscript fonts.  However, the second part of the character recognition process, that is, the combination of all text recognition results in one final text output, is still underway and will soon be completed. <br><br><h2>  Experimental results </h2><br>  We tested our approach to segmentation on 8 samples of digital video.  Video data was digitized from several German and international television broadcasts in the form of 24-bit JPEG images with a figure of merit of 508, 384 by 288 pixels and 14 frames per second.  All JPEG images were decoded as gray scale images only.  We have two samples for each of the following classes: <br><br><ul><li>  Stationary text, fixed scene; </li><li>  Fixed text, moving scene; </li><li>  Moving text, fixed scene; </li><li>  Moving text, moving the scene. </li></ul><br>  Moving text means the text is moving around the scene, for example.  Bottom up or right to left.  Equivalently, moving scenes denote scenes with significantly greater movement or, more generally, dramatically significant changes.  A stationary scene is either a still image or a very static scene, for example, a column scene in a news release.  Stationary text remains in a fixed position.  Moreover, the characters in the video samples vary in size, color and shape. <br><br>  In our experiments, we used the following values ‚Äã‚Äãfor the following parameters <br><br><ul><li>  <i>max_split_distance</i> = 30; </li><li>  <i>max_merge_distance</i> = 30; </li><li>  <i>max_size</i> = 70 pixels; </li><li>  <i>min_size</i> = 5 pixels; </li><li>  <i>search_area</i> = 20 pixels; </li><li>  <i>dilation radius</i> = 3 pixels; </li><li>  <i>fill_faktor_threshold</i> = 0.7 (section 4.2) and 0.3 (section 4.3), respectively; </li><li>  <i>canny_threshold</i> = 80; </li><li>  <i>min_ratio</i> = 0 and <i>max_ratio</i> = 6. </li></ul><br>  Experimental results can be found in Table 1. The first column identifies the type of video, followed by its length, measured in frames.  The third column contains the actual number of characters in the corresponding video sample.  It is measured by recording the entire text of the video header appearing in the video sample and character counting.  Thus, the symbol number refers to the text in the video is not the sum of the number of characters displayed in all frames.  The fourth column gives the number and percentage of characters, segmented as candidate areas, according to our segmentation algorithms.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The effectiveness of segmentation in our experiments is always very high - from 86% to 100% and, thus, gives experimental data on the quality of our algorithms. For video samples with moving text and / or moving scene, the segmentation performance ranges even from 97% to 100%. These performance measurements are consistent with our approach. It cannot benefit from multiple instances in a fixed scene with stationary text, since all instances of the same symbol have the same background. Therefore, the performance of the segmentation is lower. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Readers interested in seeing eight video clips can extract them </font></font><a href="http://www.informatik.uni-mannheim.de/~lienhart/MoCA_TextRecognition/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from here.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The quality of the characters in the candidate areas for the recognition process cannot be evaluated here, since we are only dealing with the segmentation of characters. Such an assessment can only be performed in combination with OCR software and should be investigated in future experiments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another important quality factor in the segmentation process is the average reduction rate of the corresponding pixels. It defines a decrease in the number of relevant pixels in our segmentation process, reducing the workload for the recognition process. Moreover, the higher the reduction rate, the smaller the non-character regions that are still part of the character candidate area, thereby reducing the misrecognition of the OCR software. The average reduction ratio is determined by</font></font><br><br><img src="https://pp.userapi.com/c638231/v638231513/6e46c/RkBUr9afZ14.jpg" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last column of Table 1 shows the number of characters per frame for video samples. </font><font style="vertical-align: inherit;">It correlates with the average reduction factor.</font></font><br><table border="1"><caption><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Table 1. Segmentation results </font></font></caption><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Video type </font></font></th><th>  Frames </th><th>  Characters </th><th colspan="2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Of these, found in the candidate area </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduction </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Characters in the frame </font></font></th></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stationary text, stationary scene</font></font></b> </td><td>  400 </td><td>  137 </td><td>  131 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 96% </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.058 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.34 </font></font></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stationary text, stationary scene</font></font></b> </td><td>  400 </td><td>  92 </td><td>  79 </td><td>  86% </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.028 </font></font></td><td>  0.23 </td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stationary text, moving scene</font></font></b> </td><td>  116 </td><td>  21 </td><td>  21 </td><td>  100% </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.035 </font></font></td><td>  0.18 </td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stationary text, moving scene</font></font></b> </td><td>  400 </td><td>  148 </td><td>  144 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 97% </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.037 </font></font></td><td>  0.36 </td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moving text, stationary scene</font></font></b> </td><td>  139 </td><td>  264 </td><td>  264 </td><td>  100% </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.065 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.90 </font></font></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moving text, stationary scene</font></font></b> </td><td>  190 </td><td>  273 </td><td>  273 </td><td>  100% </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.112 </font></font></td><td>  1.44 </td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moving text, moving scene</font></font></b> </td><td>  202 </td><td>  373 </td><td>  372 </td><td>  99.7% </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.130 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.85 </font></font></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moving text, moving scene</font></font></b> </td><td>  400 </td><td>  512 </td><td>  512 </td><td>  100% </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0.090 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.28 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To give empirical evidence of the stability of our algorithm, we tested it with the ninth video sample without any text. The sample video consisted of 500 frames, and the average reduction factor was 0.038. This value is very low compared to those contained in video samples containing text. Thus, our algorithm is also able to detect scenes that probably do not contain or little text. But the final decision rests with the OCR tool. Some readers may ask, what about the text as part of the scene? Does it distort the results of the experiments of the algorithm? In general, the text of the scene is not extracted. But if it has the same functions as an artificial text, it is extracted. This usually happens for scene text that is used in video for similar tasks,such as artificial text, for example, a snapshot of a city‚Äôs name at close range.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusions and perspectives </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We presented algorithms for automatic segmentation of symbols in moving images, which automatically and reliably extract text in the preface, captions and final words. </font><font style="vertical-align: inherit;">Experimental results of 8 samples of digital video, consisting of a total of 2,247 frames, are very promising. </font><font style="vertical-align: inherit;">Our algorithms extracted from 86% to 100% of all added text images in our digital video samples. </font><font style="vertical-align: inherit;">For video samples with moving text and / or moving scene, the segmentation performance ranges even from 97% to 100%. </font><font style="vertical-align: inherit;">The resulting candidate areas can easily be analyzed with standard OCR software. </font><font style="vertical-align: inherit;">Our recognition algorithms combine all instances of recognition of the same character into a single recognition result.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Currently, our algorithms process the image with a gray scale. This makes it difficult to detect, for example, yellow text on a gray-blue background, since these colors do not contrast with images with a gray scale. Consequently, our approach could not reliably segment such text. Our future plan is to expand the algorithm for working with color images in the corresponding color space and calculate the contrast in these color images.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the future, we also plan to include text segmentation and a text recognition module in our automatic video abstraction system in order to be able to extract movie titles and the most important film actors, since they are an integral part of abstracting. </font><font style="vertical-align: inherit;">Algorithms will also be built into our system of automatic recognition of video genres [2] in view of improved performance, since certain text may be characteristic of certain genres.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Links</b> <div class="spoiler_text"> [1] <a href="https://pdfs.semanticscholar.org/55e6/6333402df1a75664260501522800cf3d26b9.pdf">John Canny, ‚ÄúA Computational Approach to Edge Detection‚Äù, IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol. 8, No. 6, pp. 679-697, Nov. 1986.</a> <br> [2] <a href="https://ub-madoc.bib.uni-mannheim.de/805/1/TR-95-006.pdf">Stefan Fischer, Rainer Lienhart, and Wolfgang Effelsberg, ‚ÄúAutomatic Recognition of Film Genres‚Äù, Proc. ACM Multimedia 95, San Francisco, CA, Nov. 1995, pp. 295-304.</a> <br> [3] <a href="http://www.cs.ucsb.edu/~almeroth/classes/W10.290F/papers/legall-acm-91.pdf">DL Gall, ‚ÄúMPEG: A Video Compression Standard for Multimedia Applications‚Äù, Communications of the ACM, 34, 4, April 1991.</a> <br> [4] SL Horowitz and T. Pavlidis, ‚ÄúPicture Segmentation by a Traversal Algorithm‚Äù, Comput. Graphics Image Process.  1, pp. 360-372, 1972. <br> [5] <a href="http://www.multimedia-computing.de/mediawiki/images/3/39/1995-tr-95-34.pdf">Rainer Lienhart, Silvia Pfeiffer, and Wolfgang Effelsberg, ‚ÄúThe MoCA Workbench‚Äù, University of Mannheim, Computer Science Department, Technical Report TR-34-95, November 1996.</a> <br> [6] Shunji Mori, Ching Y. Suen, Kazuhiko Yamamoto, ‚ÄúHistorical Review of OCR Research and Development‚Äù, Proceedings of the IEEE, Vol. 80, No. 7, pp. 1029-1058, July 1992. <br> [7] Jun Ohya, Akio Shio, and Shigeru Akamatsu, ‚ÄúRecognizing Characters in Scene Images‚Äù, IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol. 16, No. 2, pp. 214-220, 1994. <br> [8] William B. Pennebaker and Joan L. Mitchel, ‚ÄúJPEG Still Image Data Compression Standard‚Äù, Van Nostrand Rheinhold, New York, 1993. <br> [9] Arthur R. Pope, Daniel Ko, David G. Lowe, ‚ÄúIntroduction to Vista Programming Tools‚Äù, Department of Computer Science, University of British Columbia, Vancouver. <br> [10] <a href="https://www.semanticscholar.org/paper/Vista-a-software-environment-for-computer-vision-r-Pope-Lowe/0331a58d34bdc668799229329e4f66a8782eecca">Arthur R. Pope and David G. Lowe, ‚ÄúVista: A Software Environment for Computer Vision Research‚Äù, Department of Computer Science, University of British Columbia, Vancouver.</a> <br> [11] <a href="https://archive.org/stream/automaticcharact112stev/automaticcharact112stev_djvu.txt">Alois Regl, ‚ÄúMethods of Automatic Character Recognition‚Äù, Ph. D. thesis, Johannes Kepler University Linz, Wien 1986 (in German).</a> <br> [12] <a href="http://www.informedia.cs.cmu.edu/documents/cmu-cs-95-186.pdf">Michael A. Smith and Takeo Kanade, ‚ÄúVideo Skimming for Quick Browsing Based on Audio and Image Characterization‚Äù, Carnegie Mellon University, Technical Report CMU-CS-95-186, July 1995.</a> <br> [13] <a href="http%253A%252F%252Fpatentimages.storage.googleapis.com%252Fpdfs%252FUS6101274.pdf%26usg%3DAFQjCNFz1JncMz9K9S3Rxdua5-JJcRMIIw">M. Takatoo et al., ‚ÄúGray Scale Image Processing Technology Applied to Vehicle License Number Recognition System‚Äù, in Proc. Int. Workshop Industrial Applications of Machine Vision and Machine Intelligence, pp. 76-79, 1987.</a> <br> [14] <a href="http://ptgmedia.pearsoncmg.com/images/9780133991000/samplepages/9780133991000.pdf">A. Murat Tekalp, ‚ÄúDigital Video Processing‚Äù, Prentice Hall Signal Processing Series, ISBN 0-13-190075-7, 1995.</a> <br> [15] <a href="http://www.cs.cornell.edu/~rdz/Papers/ZMM-MM95.pdf">Ramin Zabih, Justin Miller, and Kevin Mai, ‚ÄúA Feature-Based Algorithm for Detecting and Classifying Scene Breaks‚Äù, Proc. ACM Multimedia 95, San Francisco, CA, pp. 189-200, Nov. 1995.</a> <br> [16] HJ Zhang, CY Low, SW Smoliar, and JH Wu, ‚ÄúVideo Parsing, Retrieval and Browsing: An Integrated and Content-Based Solution‚Äù, Proc. ACM Multimedia 95, San Francisco, CA, pp. 15-24, Nov. 1995. <br> [17] <a href="http://proceedings.spiedigitallibrary.org/proceeding.aspx%3Farticleid%3D957711">Hong Jiang Zhang and Stephen W. Smoliar, ‚ÄúDeveloping Power Tools for Video Indexing and Retrieval‚Äù, Proc. SPIE Conf. on Storage and Retrieval for Image and Video Databases, San Jose, pp. 140-149, CA, 1994.</a> </div></div></div><p>Source: <a href="https://habr.com/ru/post/332840/">https://habr.com/ru/post/332840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332828/index.html">Record from 1 million neurons: new plans DARPA</a></li>
<li><a href="../332830/index.html">How to increase sales in Moscow by 60% during a crisis? The success story of one company</a></li>
<li><a href="../332832/index.html">Using BSP-trees to create game cards</a></li>
<li><a href="../332834/index.html">Superjob php meetup</a></li>
<li><a href="../332836/index.html">Continuous Integration: CircleCI vs Travis CI vs Jenkins</a></li>
<li><a href="../332842/index.html">GitLab CI for continuous integration and delivery in production. Part 2: Overcoming Difficulties</a></li>
<li><a href="../332844/index.html">Study of the sustainability of national segments of the network</a></li>
<li><a href="../332846/index.html">The problem of continuous protection of web applications. View from the side of researchers and operators. Part 2</a></li>
<li><a href="../332848/index.html">Steam Greenlight and Steam Direct: what indie developers need to know</a></li>
<li><a href="../332850/index.html">GraphQL queries. From simple to more complex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>