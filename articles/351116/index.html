<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Security Basics: Keychain and Hashing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most important aspects of software development, which is also considered one of the most mysterious and scary (therefore avoided like the p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Security Basics: Keychain and Hashing</h1><div class="post__text post__text-html js-mediator-article">  One of the most important aspects of software development, which is also considered one of the most mysterious and scary (therefore avoided like the plague), is application security.  Users expect their applications to work correctly, store their personal information and protect this information from potential threats. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p-/0g/5v/p-0g5vrie9j5ksni4ss05r-lbq0.png"></div><br><br>  In this article, you dive into the basics of security in iOS.  You will work with some basic cryptographic hashing methods for secure storage of received data in Keychain - while maintaining and protecting user data in the application. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Apple has several APIs to help protect your applications, and you will learn about them when working with Keychain.  In addition, you will use CryptoSwift - study and browse through an open source library that implements cryptographic algorithms. <br><a name="habracut"></a><br><h3>  Start </h3><br>  Use this <a href="">link</a> to download the project for work. <br><br>  We will work on an application that allows users to register and see photos of their friends.  Most of the application is already implemented, your task is to protect this application. <br><br>  Once you unzip the archive, be sure to open the Friendvatars.xcworkspace file, and use CocoaPod to add dependencies.  Compile and run the application.  You will see that it starts from the login screen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/2db/84c/6d52db84c853993f38b12b47318c6ba1.png" alt="iOS Security" width="281" height="500"></div><br>  Currently, when you click on the <b>Sign in</b> button, nothing happens.  This is due to the fact that the application does not implement a way to store user credentials.  This is what you will need to add first. <br><br><h3>  Why safety is important </h3><br>  Before you dive into working with the code, you need to understand why security is necessary in your application.  The security of your application is especially important if you store personal user data, such as emails, passwords, or bank account data. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edd/0db/e14/edd0dbe14cde5ca78a0bd2ad6fb67c57.png" alt="iOS Security" width="320" height="320"></div><br>  Why is Apple taking security so seriously?  The photos that you photograph, up to the number of steps that were taken during the day, your iPhone stores a lot of personal data.  The protection of this data is very important. <br><br>  Who are the intruders in the iOS ecosystem and what do they want?  An attacker can be a criminal, a business rival, even a friend or relative.  Not all attackers want the same thing.  Some may want to damage or spoil the information, while others may want to know what gifts they will receive on their birthdays. <br><br>  Your task is to make sure that the data stored in your application is protected from possible threats.  Fortunately, Apple has developed many powerful APIs that simplify this task. <br><br><h3>  Keychain </h3><br>  One of the most important security elements for iOS developers is <b>Keychain</b> , a specialized database for storing metadata and confidential information.  Using Keychain is the best practice for storing small pieces of data that are crucial to your application, such as secrets and passwords. <br><br>  Why use Keychain for simpler solutions?  Is it enough to store the user's password in <b>base-64</b> in <i>UserDefaults</i> ?  Definitely not!  It is quite trivial for an attacker to recover a password saved in this way.  Security is complicated, and trying to create your own solution is not a good idea.  Even if your application is not for a financial institution, storing user personal data should not be taken lightly. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/421/cd2/34b/421cd234bf15e450bf3e6658a29e49e6.png" alt="iOS Security" width="320" height="320"></div><br>  Direct interaction with Keychain is not easy, especially in Swift.  You should use <i>Security frameworks</i> , which are mostly written in C. <br><br>  Fortunately, you can avoid using these low-level APIs by borrowing Apple's wrapper for Swift from the <a href="https://developer.apple.com/library/content/samplecode/GenericKeychain/Introduction/Intro.html">GenericKeychain</a> example.  <b>KeychainPasswordItem</b> provides an easy-to-use interface for working with Keychain and has already been added to the start project. <br><br>  Time to dive into the code! <br><br><h3>  Using Keychain </h3><br>  Open <i>AuthViewController.swift</i> .  This controller is responsible for the authorization form that you saw at the beginning.  If you go to the <b>Actions</b> section, you will notice that the <b>signInButtonPressed</b> method <b>does</b> nothing.  It's time to fix it. <br><br>  Add the following code to the <b>Helpers</b> section at the bottom: <br><br><pre><code class="hljs pgsql">private func signIn() { // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.endEditing(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) // <span class="hljs-number"><span class="hljs-number">2</span></span> guard let email = emailField.text, email.count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } guard let <span class="hljs-keyword"><span class="hljs-keyword">password</span></span> = passwordField.text, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>.count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } // <span class="hljs-number"><span class="hljs-number">3</span></span> let <span class="hljs-type"><span class="hljs-type">name</span></span> = UIDevice.<span class="hljs-keyword"><span class="hljs-keyword">current</span></span>.name let <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, email: email) }</code> </pre> <br>  Here‚Äôs how it happens: <br><br><ol><li>  You remove the keyboard to confirm that a user action has been completed. </li><li>  You accept the email address and password of the user.  If the length of the entered information in the field is zero, then the function will not continue.  In a real application, you must show the user an error. </li><li>  You assign a user name, which for training purposes in this article, you take from the device name. </li></ol><br>  Note: You can change the name of your Mac (which is used by the SIM card) by going to <i>System Preferences -&gt; Sharing</i> .  In addition, you can change the name of your iPhone by going to <i>Settings -&gt; General -&gt; About -&gt; Name</i> . <br><br>  Now add the following to the <b>signInButtonPressed</b> method <b>:</b> <br><br><pre> <code class="hljs lisp">signIn()</code> </pre><br>  This code calls the signIn method when signInButtonPressed is executed. <br><br>  Find <b>textFieldShouldReturn</b> and replace <b>TextFieldTag.password.rawValue</b> in the <b>break</b> under <b>case</b> with the following: <br><br><pre> <code class="hljs lisp">signIn()</code> </pre><br>  Now the <b>signIn ()</b> method will be called when the user presses Return on the keyboard, after he entered the text in the password field, while the password field has focus and already contains text. <br><br>  The <b>signIn ()</b> method is not yet fully implemented.  We still need to save user and password objects.  All this will be implemented in auxiliary class. <br><br>  Open <b>AuthController.swift</b> , which is a static class ‚Äî it will contain the business logic associated with authentication. <br><br>  To begin with, at the very top of the file above <b>isSignedIn</b> , add the following: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceName = <span class="hljs-string"><span class="hljs-string">"FriendvatarsService"</span></span></code> </pre><br>  This code defines the name of the service that will be used to identify application data in Keychain.  To use this constant, create a <b>signIn</b> method at the end of the class: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> func signIn(_ <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: String) throws { try KeychainPasswordItem(service: serviceName, account: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.email).savePassword(<span class="hljs-keyword"><span class="hljs-keyword">password</span></span>) Settings.currentUser = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> }</code> </pre><br>  This method will reliably store information for user authorizations in Keychain.  It creates a <b>KeychainPasswordItem</b> with the name of the service that you identified along with the unique identifier (account). <br><br>  For this application, the user's email is used as an identifier for Keychain, but other data can also serve as an identifier or unique user name.  Finally, in Settings.currentUser is assigned the value of user - all this is stored in <b>UserDefaults</b> . <br><br>  This method should not be considered complete!  Storing a user's password directly is not the best practice.  For example, if an attacker hacked Keychain, he could get each user's passwords in plain text.  The best solution is to store a password hash, built on the basis of user identification. <br><br>  At the top of the <b>AuthController.swift</b> immediately after <i>import Foundation</i> add the following <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CryptoSwift</code> </pre><br>  <a href="http://cryptoswift.io/">CryptoSwift</a> is one of the most popular collections of many standard cryptographic algorithms written in Swift.  Cryptography is complex and needs to be done correctly in order for it to be beneficial.  Using a popular library for security means that you are not responsible for implementing standardized hashing functions.  The best methods of cryptography are open to the public. <br><br>  <b>Note:</b> <i>Apple‚Äôs CommonCrypto framework provides many useful hashing functions, but Swift is not easy to work with.</i>  <i>That is why for this article we chose the CryptoSwift library.</i> <br><br>  Then add the following code above <b>signIn</b> : <br><br><pre> <code class="hljs rust">class func passwordHash(from email: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, password: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> salt = <span class="hljs-string"><span class="hljs-string">"x4vV8bGgqqmQwgCoyXFQj+(o.nUNQhVP7ND"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"\(password).\(email).\(salt)"</span></span>.sha256() }</code> </pre><br>  This method takes an email address and password, and returns a hashed string.  The salt constant is a unique string that makes a rare <b>.sha256 ()</b> from a regular password - this is the <b>CryptoSwift</b> c method, which hashes the entered string using the <b>SHA-2</b> algorithm. <br><br>  In the previous example, the attacker who hacked Keychain will find this hash.  An attacker can create a table of frequently used passwords and their hashes for comparison with this hash.  If you only hashed user input without a salt, and the password existed in the intruder‚Äôs hash table, the password can be cracked. <br><br>  Using <a href="https://en.wikipedia.org/wiki/Salt_(cryptography)">salt</a> increases the difficulty of hacking.  In addition, you combine the user's email and password with a salt to create a hash that cannot be easily cracked. <br><br>  <b>Note:</b> <i>For user authentication, the mobile app and server will use the same <b>salt</b> .</i>  <i>This allows them to build hashes in the same way and compare two hashes to verify identity.</i> <br><br>  Go back to the <b>signIn</b> method <b>(_: password :)</b> , replace the line of code that calls the <b>savePassword</b> method <b>with</b> the following: <br><br><pre> <code class="hljs pgsql">let finalHash = passwordHash(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.email, <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>) try KeychainPasswordItem(service: serviceName, account: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.email).savePassword(finalHash)</code> </pre><br>  <b>signIn</b> now stores a strong hash, not a raw password.  Now it's time to add it to the view controller. <br><br>  Return to <b>AuthViewController.swift</b> and add this code to the end of the <b>signIn ()</b> method: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">AuthController</span></span>.signIn(user, password: password) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Error signing in: \(error.localizedDescription)"</span></span>) }</code> </pre><br>  Although this code saves the user and saves the hashed password, the application will need something else in order to log in.  <b>AppController.swift</b> should be notified when authentication changes. <br><br>  You may have noticed that <b>AuthController.swift</b> has a static variable named <b>isSignedIn</b> .  Currently, it always returns false, even if the user is registered. <br><br>  In <b>AuthController.swift,</b> change <b>isSignedIn</b> : <br><br><pre> <code class="hljs pgsql">static var isSignedIn: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { // <span class="hljs-number"><span class="hljs-number">1</span></span> guard let currentUser = Settings.currentUser <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { // <span class="hljs-number"><span class="hljs-number">2</span></span> let <span class="hljs-keyword"><span class="hljs-keyword">password</span></span> = try KeychainPasswordItem(service: serviceName, account: currentUser.email).readPassword() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>.count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> } catch { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } }</code> </pre><br>  This is what happens here: <br><br><ol><li>  You immediately check the current user stored in <b>UserDefaults</b> .  If the user does not exist, then the identifier for finding the password hash in Keychain will also be absent, so you indicate that he is not registered in the system. </li><li>  You get the hash password from <b>Keychain</b> , and if the password exists and is not empty, the user is considered registered. </li></ol><br>  Now the <b>handleAuthState</b> in <b>AppController.swift</b> will work correctly, but after logging in you will need to restart the application in order to correctly update the <b>UI</b> .  But there is a good way to notify an application about a state change, for example, user authentication, using notification. <br><br>  Add the following to the end of <b>AuthController.swift</b> : <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Notification</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Name</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loginStatusChanged = <span class="hljs-type"><span class="hljs-type">Notification</span></span>.<span class="hljs-type"><span class="hljs-type">Name</span></span>(<span class="hljs-string"><span class="hljs-string">"com.razeware.auth.changed"</span></span>) }</code> </pre><br>  A good practice is to use a domain identifier when composing custom notifications, which is usually taken from the <b>bundle identifier of the</b> application.  Using a unique identifier can help you debug an application, so everything related to your notification is highlighted from other frameworks mentioned in your logs. <br><br>  To use this custom notification name, add the following to the bottom of the <b>signIn</b> method <b>(_: password :)</b> : <br><br><pre> <code class="hljs delphi">NotificationCenter.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.post(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: .loginStatusChanged, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>)</code> </pre><br>  This code will send a notification that may be detected by other parts of the application. <br><br>  Inside the <b>AppController.swift,</b> add the <b>init</b> method above the <b>show (in :)</b> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { <span class="hljs-type"><span class="hljs-type">NotificationCenter</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.addObserver( <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: #selector(handleAuthState), name: .loginStatusChanged, object: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) }</code> </pre><br>  This code will register <b>AppController</b> as an observer of your login name.  When triggered, it calls <b>callAuthState</b> . <br><br>  Compile and run the application.  After logging in to the system using any combination of email and password, you will see a list of friends: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/584/638/bfe/584638bfe3370e7e3be0f773c39c1fcb.png" width="281" height="500"></div><br>  You will notice that there are no avatars, just the names of friends.  This is not very pleasant to look at.  You should probably get out of this unfinished application and forget about it.  Oh yes, even the exit button does not work.  Time to put a 1-star as a rating and really give this app back to its developer! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/334/a81/c39/334a81c392da99cf22d2c68d8ca05799.png" width="320" height="320"></div><br>  Logging works fine, but there is no way to exit the application.  This is actually quite easy to achieve, since there is a notification that will signal a change in the authentication state. <br><br>  Go back to <b>AuthViewController.swift</b> and add the following under <b>signIn (_: password :)</b> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> func signOut() throws { // <span class="hljs-number"><span class="hljs-number">1</span></span> guard let currentUser = Settings.currentUser <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } // <span class="hljs-number"><span class="hljs-number">2</span></span> try KeychainPasswordItem(service: serviceName, account: currentUser.email).deleteItem() // <span class="hljs-number"><span class="hljs-number">3</span></span> Settings.currentUser = nil NotificationCenter.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.post(<span class="hljs-type"><span class="hljs-type">name</span></span>: .loginStatusChanged, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: nil) }</code> </pre><br>  It's pretty simple: <br><br><ol><li>  You check whether you have saved the current user or not, if you have not done so before. </li><li>  You delete the hash password from Keychain. </li><li>  You clear the user object and post a notification. </li></ol><br>  To enable this, go to <b>FriendsViewController.swift</b> and add the following to <b>signOut:</b> <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">AuthController</span></span>.signOut()</code> </pre><br>  Your new method is invoked to clear the logged in user data when the "Logout" button is pressed. <br><br>  Working with errors in your application is a good idea, but in view of this lesson, ignore any errors. <br><br>  Compile and run the application, then click ‚ÄúExit‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/720/f08/191/720f0819133df215842f4f16117b9366.png" width="281" height="500"><br><br>  Now you have a full working example of authentication in the application! <br><br><h3>  Hashing </h3><br>  You have done a great job creating authentication!  However, the fun is not over.  Now you will convert this empty space before the names in the list of friends. <br><br>  <b>FriendsViewController.swift</b> displays a list of objects in the User model.  You also want to display avatar images for each user in the view.  Since there are only two attributes for a User, a name and an email address, how are you going to display the image? <br><br>  It turns out that there is a service that takes an email address and associates it with an avatar image: <a href="https://gravatar.com/">Gravatar</a> !  If you have not heard of Gravatar, it is usually used in blogs and forums to globally associate an email address with an avatar.  It simplifies the work, so users do not need to upload a new avatar to every forum or site they join. <br><br>  Each of these users already have an avatar associated with their email.  So the only thing you need to do is to execute a request to Gravatar and get the images for the requested users.  To do this, you will create an <b>MD5</b> hash of their email to create URL requests. <br><br>  If you look at the documentation on the Gravatar website, you will see that you need a hashed email address to create a request.  This will be a piece of cake, since you can use <b>CryptoSwift</b> .  Add Gravatar comments to the <b>tableView (_: cellForRowAt :) with the</b> following: <br><br><pre> <code class="hljs haskell">// <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> emailHash = user.email.trimmingCharacters(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: .whitespacesAndNewlines) .lowercased() .md5() // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(string: <span class="hljs-string"><span class="hljs-string">"https://www.gravatar.com/avatar/"</span></span> + emailHash) { <span class="hljs-type"><span class="hljs-type">URLSession</span></span>.shared.dataTask(with: url) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">, response, error in guard let </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">, let image = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UIImage</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">) else { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> } // 3 self.imageCache.setObject(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">image</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forKey</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">as</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NSString</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DispatchQueue</span></span></span><span class="hljs-class">.main.async { // 4 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tableView</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reloadRows</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">at</span></span></span><span class="hljs-class">: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">indexPath</span></span></span><span class="hljs-class">], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class">: .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">automatic</span></span></span><span class="hljs-class">) } }.resume() }</span></span></code> </pre><br>  Let's look at: <br><br><ol><li>  First, you format the email address according to the Gravatar documentation, and then create an <b>MD5</b> hash. </li><li>  You create a Gravatar URL and <b>URLSession</b> .  You load a <b>UIImage</b> from the returned data. </li><li>  You cache the image to avoid duplicate selections for the email address. </li><li>  You reload the row in the table view so that the avatar image is displayed. </li></ol><br>  Compile and run the application.  Now you can see the images and names of your friends: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/c14/837/468c14837a55474c57645171eba687a5.png" width="281" height="500"></div><br>  <b>Note:</b> <i>If your email returns a default image (white on blue G), go to the Gravatar website and upload your own avatar and join your friends!</i> <br><br>  If you are interested in other ways to protect your applications, explore the use of biometric sensors in the latest Apple products in this <a href="https://www.raywenderlich.com/179924/secure-ios-user-data-keychain-biometrics-face-id-touch-id">article</a> . <br><br>  You can also learn more about <a href="https://developer.apple.com/documentation/security%3Flanguage%3Dswift">Apple‚Äôs security infrastructure</a> if you really want to look into the framework. <br><br>  Finally, be sure to learn the <a href="http://cryptoswift.io/">additional security algorithms</a> provided by CryptoSwift. <br><br>  <i>Hope you enjoyed this article!</i>  <i>If you have any questions or comments, join the discussion!</i> </div><p>Source: <a href="https://habr.com/ru/post/351116/">https://habr.com/ru/post/351116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351102/index.html">People do not want something really new - they want something they‚Äôve done, but they‚Äôve done differently.</a></li>
<li><a href="../351104/index.html">Test Automation and Agile</a></li>
<li><a href="../351108/index.html">Script for centralized backup of configurations of Mikrotik routers on Powershell</a></li>
<li><a href="../351112/index.html">Efficient use of memory with parallel input-output operations in Python</a></li>
<li><a href="../351114/index.html">How not to get the phone (almost) any beauty in Moscow, or an interesting feature MT_FREE</a></li>
<li><a href="../351118/index.html">As i blakecoin miner did</a></li>
<li><a href="../351122/index.html">Dimnie: from geeks with github to corporate accountants</a></li>
<li><a href="../351126/index.html">FastTrack Training. "Network Basics". "The value of Cisco in data centers." Eddie Martin December 2012</a></li>
<li><a href="../351128/index.html">‚ÄúBlack Holes‚Äù Revealed at macOS High Sierra</a></li>
<li><a href="../351130/index.html">Font (more) Awesome - patterned invention</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>