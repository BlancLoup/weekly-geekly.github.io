<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagger 2. We treat dependencies by the method of Google</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Author: Konstantin Mars 
 Senior Developer @ DataArt, 
 Co-Organizer @ GDG Dnipro 


 Dependency Injection 

 What, why and when it is needed 
 Today ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagger 2. We treat dependencies by the method of Google</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/5fe/412/b9e/5fe412b9ed564616929967bc8411cf30.png"><br>  Author: Konstantin Mars <br>  Senior Developer @ DataArt, <br>  Co-Organizer @ GDG Dnipro <br><br><br><h2>  Dependency Injection </h2><br><br><h3>  What, why and when it is needed </h3><br>  Today we will talk about a tool that helps improve the quality of development for Android.  You can solve this problem with Dependency Injection (DI).  Usually this term is associated with injections, syringes and a little bit with ‚Äúdependencies‚Äù.  In fact, Dependency Injection is a design pattern that provides the implementation of the principle of dependency inversion and implements the rules for creating objects and the independence of implementations. <br>  So, we have a class, the class has a constructor, and there are several class members.  When you create an entity of this class, you need to provide the class with instances of the same types that are declared for its class members.  In this case, this is the name of the car and the engine type Engine.  You will use object references, respectively, the links inside your class will not be empty. <br>  Thus, you implement OOP and can create objects. <br><a name="habracut"></a><br><h3>  Creating classes generates ... </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/839/ec9/31d/839ec931d5524f3cb16562757f2d7ff6.png"><br><br><ul><li>  Composition is not inheritance. </li><li>  Links will not be empty. </li></ul><br><br><h3>  The ability to create objects ... </h3><br>  You can create an object, set the name of the car and create some new engine. <br><br><img src="https://habrastorage.org/files/9da/1e1/519/9da1e1519e41438fb205213d8089a4b7.png"><br><br>  Available to create different objects, for example, the creation of a different type of engine or just another engine. <br><br><img src="https://habrastorage.org/files/c1e/3bd/787/c1e3bd7877e14c869f10cf6d5a46cc28.png"><br><br>  Suppose you can create two different objects that you will use.  In this case, the same engine from the "Patriot".  Accordingly, if you put this engine in the Jeep Grand Cheerokee - it will be a bit strange.  But, nevertheless, you can do it.  This uses the so-called pattern "composition", when the entities that you create will be included in another entity, and this will be, as you see, not inheritance, but composition. <br><br><img src="https://habrastorage.org/files/b6b/374/ee4/b6b374ee43244804b557b230ef1f0c44.png"><br><br>  Everything is very simple here: if you look at SuperTunedEngine, you will understand that in fact it is a certain type of heir that has already been declared in advance, and also perhaps an interface implementation - this is not fundamental for us.  In this case, the Engine can be an interface. <br><br><img src="https://habrastorage.org/files/575/831/195/5758311959594590a82648364353ad8b.png"><br><br>  Looking at the two ads, you see: we can make it so that two objects will depend on some other object.  Actually, this is addiction.  Thus, the ability to create objects creates dependencies is a rather banal thing. <br><br><h3>  And ... dependencies </h3><br>  Car depends on Engine.  Engines may vary.  We'll probably need different engines for testing and production. <br><br><img src="https://habrastorage.org/files/7a1/e18/edd/7a1e18edd2b34f60be0d14e9c4b65046.png"><br><br>  As you can see in the diagram (the image is not from our example), the dependencies are very different.  You will have dependent services, dependent activity, presenters, view, controllers.  All these entities are intertwined with dependencies.  If you try to express it graphically, you get about what you see now in the picture. <br>  In a real working system, dependencies will be much larger.  Tests that are conducted by well-known companies that provide tools for testing Android applications show that there are thousands of dependencies, even in seemingly simple applications.  On average, thousands and tens of thousands of dependencies are found even in the simplest applications.  To implement these dependencies as efficiently as possible, without instantiating any other classes within your class each time and without adding a bunch of code that will be repeated and add extra work to you, there is a Dagger tool. <br><br><h2>  Dagger and JSR-330 Standart </h2><br><br><h3>  Abstract <a href="https://habrahabr.ru/users/inject/" class="user_link">Inject</a> </h3><br>  Dagger is based on the JSR-330 standard.  This standard has been used by Google for a very long time, and this is the standard for Java Injection. <br><br><h3>  A bit more non-history <strong>&nbsp;</strong></h3><br><ul><li>  Dagger 2 - Google, Greg Kick </li><li>  Dagger - Square, Jake Wharthon </li><li>  Guice - Google, Jesse Wilson </li></ul><br>  Let's look a little into history: Google once created such a product as Guice (popularly called ‚ÄúJuice‚Äù, and in our latitudes - ‚ÄúGoose‚Äù).  Guice worked with reflection, he followed the annotations, but subsequently the developers from Square improved the system that was in Guice and created Dagger1. <br>  Dagger1 was a cool tool, but, as practice shows, something can be improved here.  By the way, Dagger1 also used reflection.  And in 2015, developers from Google released Dagger2.  It seems that quite recently Jake Wharton (a well-known developer from the company Square) announced its release with an eye on autumn - the promise is fulfilled, we have a high-quality and ahead of competitors in the test results product. <br><br><h3>  Inversion of Control ( <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D0%25B3%25D0%25BB%25D0%25B8%25D0%25B9%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">English</a> Inversion of Control, IoC) </h3><br><br><img src="https://habrastorage.org/files/243/4df/562/2434df5623464104bf3f5786a3cb2bcf.png"><br><br>  Let's return to standards and terminology.  So, we have a product that appeared in the course of evolution.  It uses JSR-330, which provides a variety of annotations.  In addition, it follows certain principles, a kind of development patterns, one of which is Inversion of control (IoC). <br>  The process of providing external dependency to a software component is a specific form of ‚Äúinversion of control‚Äù (IoC), when it is applied to dependency management.  In accordance with the principle of single responsibility, the object gives care to build the dependencies required by it to an external, specially designed for this general mechanism. <br>  This thing is related to architectural patterns.  We must write the application in such a way that the inner classes associated with the domain logic do not depend on the outer classes, so that the application is written based on the interfaces.  Thus, the division of responsibility is realized.  Turning to some kind of implementation, we turn, first of all, to the interface <em>.</em>  <em>Inversion of Control is implemented through Dependency Injection, the actual tool is called Dependency Injection (DI).</em> <br><br><h3>  Reflection vs Compile time </h3><br><ul><li>  Dagger2 vs Dagger1 </li></ul><br><br>  Dagger2 uses code generation, unlike Dagger1, which used reflection. <br><br><h2>  JSR-330 </h2><br><br><h3>  JSR-330 aka javax.inject </h3><br><ul><li>  <a href="https://habrahabr.ru/users/inject/" class="user_link">Inject</a> , <a href="https://habrahabr.ru/users/qualifier/" class="user_link">Qualifier</a> , <a href="https://habrahabr.ru/users/scope/" class="user_link">Scope</a> .  etc. </li><li>  Standardized Dependency Injection API </li><li>  Reference Implementation: Google Guice 2.0 </li><li>  Also supported by Spring since 3.0 </li><li>  Defines API, not injector implementation or configuration </li></ul><br>  JSR describes not only the <a href="https://habrahabr.ru/users/inject/" class="user_link">Inject</a> annotation, but also provides a whole package of annotations that allow you to declare how entities will interact to provide Dependency Injection. <br>  For example, I‚Äôm talking about a specific family of Dependency Injection products that follow this standard.  There are other products that do not follow this standard, we will not talk about them today, but they exist.  There is <a href="https://habrahabr.ru/users/inject/" class="user_link">Inject</a> , <a href="https://habrahabr.ru/users/qualifier/" class="user_link">Qualifier</a> , <a href="https://habrahabr.ru/users/scope/" class="user_link">Scope</a> - we'll talk about them later.  These annotations were not created only for Dagger2, they exist for other injectors, for example, Guice. <br><br><h3>  So, it's time to add some magic to our code ... </h3><br><br><img src="https://habrastorage.org/files/ebc/ac6/bd4/ebcac6bd468045fbbda5f07f16b43047.png"><br><br>  We begin by annotating class members with an <a href="https://habrahabr.ru/users/inject/" class="user_link">inject</a> annotation.  Everything is quite simple.  In order to further instantiate these dependencies and our toolkit, Dependency Injection could correctly choose exactly where to instantiate and what, we must also annotate the constructor.  Here the situation becomes a bit more interesting. <br><br><h3>  Notice the default constructor. </h3><br><br><img src="https://habrastorage.org/files/496/56a/46d/49656a46d42c43e5a0f0a9095b83d452.png"><br><br>  The easiest way to provide injection is to create a default constructor.  Then inject the default constructor itself and those members that require instantiation of this class to inject.  This is done very simply. <br><br><h3>  Constructor with parameters is a good place for modifications. </h3><br><br><img src="https://habrastorage.org/files/58c/726/4ea/58c7264eaa1e485295cafe5e55861d02.png"><br><br>  In real life, we need constructors with parameters.  The system will be able to pick up some of them automatically if they have default constructors.  And some, for example, the same Engine, you may have to construct manually. <br>  Also you will inject presenters with the help of such constructors, this is very often used in MVP (Model-View-Presenter). <br><br><h3>  And yet - how to make it work? </h3><br><br><img src="https://habrastorage.org/files/e5d/289/1bf/e5d2891bf93443a78d0175519ad4e3f2.png"><br><br><h2>  Dagger2.0 injection structure </h2><br>  Injection structure is the interconnection of Dagger components that allow us to combine <a href="https://habrahabr.ru/users/inject/" class="user_link">inject</a> annotations and combine class declarations. <br><br><h3>  Components and Modules </h3><br><br><img src="https://habrastorage.org/files/bee/d3a/735/beed3a73595e43d4a0fbd6a7f17c634c.png"><br>  <em>Pic.</em>  <em>author - Miroslaw Stanek from Azimo</em> <em><br></em>  <a href="http://frogermcs.github.io/dagger-graph-creation-performance/">http://frogermcs.github.io/dagger-graph-creation-performance/</a> <br>  The Dagger injection structure includes components and modules.  If you look at the picture (from the article by Miroslav Stanek from Azima), you will see that the components are containers for modules, and there may be others inside one component.  Later we will see that the components that are nested are called subcomponents (@ SubComponent).  And we cannot call them simply ‚Äúcomponents‚Äù by the injection rules. <br><br><h3>  Module - a collection of generators </h3><br><br><img src="https://habrastorage.org/files/def/f9b/449/deff9b44984545e7af8aebafb6357620.png"><br><br>  <a href="https://habrahabr.ru/users/module/" class="user_link">Module</a> annotation ‚Äî an annotation that says that this entity ‚Äî this class ‚Äî is a module that will generate instances of objects. <br>  Here, too, everything is quite simple.  Annotations that generate - this abstract provides.  The summary provides simply indicates that this module method will supply you with an entity.  The most interesting thing will happen inside this method. <br>  You will need to follow the rules to instantiate the object in some way.  Some objects will depend on each other.  Some objects will depend on the members of the module class, which you can store in the module.  For example, the same context you can put in a module.  The module remembers it and then, when instantiating the same agents, you will generate new presenter entities based on the context that the module remembers once it was created. <br>  As you can see, the module has a constructor.  In this case, instead of the context, we are passing Application.  When creating something new, we can return what is stored in the module itself. <br><br><h3>  What is a singleton (eng. Singleton)? </h3><br>  When creating some entities, we set certain parameters.  Singleton - a statement that says that where the injector <a href="https://habrahabr.ru/users/inject/" class="user_link">finds the inject</a> annotation, it should not instantiate a new object, but should re-use the already single-time singleton object. <br><br><h3>  @Component </h3><br>  Component - host for modules, class injector, dependency tree root. <br><br><img src="https://habrastorage.org/files/029/038/584/029038584e4d4b94979a2539860299c2.png"><br><br>  With the component, everything is a little more interesting.  The component must take into account the lifetime of the modules that it includes.  If we try to use singleton for the component that uses the instantiation lifetime, conflicts will arise.  Therefore, you need to clearly understand that, for example, the component for Application will be a singleton, because the object of the Application class exists in a single instance, and there is a lifetime of the application.  For activity, for example, this can also be a singleton, and its lifetime will be tied to the lifetime of the activity.  If necessary, it is possible to annotate the component with additional annotation <a href="https://habrahabr.ru/users/singleton/" class="user_link">Singleton</a> .  There is a list of modules that includes this component. <br>  For example, in Activity there will be an inject annotation.  In the component should be specified the modules that make this activity.  You must specify in the component where we inject.  That is, we have to specify a specific class, and note that it is impossible, for example, to write BaseActivity as a base class, because then injection will occur only in Base aActivity, and in MainActivity, where you need, for example, some Presenter, the rules will be slightly different. <br><br><img src="https://habrastorage.org/files/832/6d8/b13/8326d8b1382747e9a257c29149a841c9.png"><br><br>  The inject method is a description of who depends.  Modules - a description of those who provide dependencies. <br>  Let's go back to the module.  The module is declared as a class.  It is important to note that the module is a real class that has real references to real objects.  And you create it manually when you declare a component, with a bundle.  The component, in turn, is the object that Dagger generates.  Just at this moment the magic of code generation occurs.  Therefore, the component is declared as an interface. <br><br><h3>  Component initialization generated code used </h3><br><br><img src="https://habrastorage.org/files/30c/586/fc8/30c586fc88de4a78984d5378a6ea609c.png"><br><br>  For example, DaggerAppComponent is initialized inside our application.  Note that the generated code used (component initialization) means that we use the generated code.  For example, you can detect DaggerAppComponent.  As you saw earlier, there was no Dagger prefix.  Where did he come from?  Yes, Dagger generated the code.  He generates it quickly enough.  If you accidentally break the injection, which we are talking about (its structure), in the end you will not have a DaggerAppComponent.  If you made a small error and incorrectly specified a class, generation will not work - DaggerAppComponent will not appear, and all the magic that provides us to bind our activity and other classes will not work without the generated class.  Because the component is the root of the whole tree - this is the basis.  And without it, everything else does not work.  You should be careful about how we build the injection before, and use the component correctly. <br>  Also note that the component has a builder.  Builder - design pattern.  We understand that the builder has some arguments that determine how our component will be built on, for example, the AppModule method ‚Äî an automatically generated method that takes the instance instance class AppModule as an argument.  We create the module with our hands and set parameters for it.  And call the build method to get the AppComponent.  In this link there is an example from the real code: <a href="">http://github.com/c-mars/Dagger2Scopes.git</a> . <br><br><h3>  Inject This!  :) </h3><br><br><img src="https://habrastorage.org/files/641/0d6/059/6410d60591644e23a3c8e121a77c148a.png"><br><br><h3>  Puttin 'magic will work only after injection ... :) </h3><br>  The Application class has methods that provide access to it.  Moreover, this is not a static method, you can simply get a context from get application.  You can tackle him to your class - the same thing will turn out and there will be no magic here.  But, for what's really important, we will have this getAppComponent. <br>  The idea is that Application stores an AppComponent.  We call some additional methods on this component, and then we use the inject method.  As you noticed, this one is inject with an indication of the specific class that we declared in the component.  In this case, it is the LoginActivity class.  You see in the abstract inject, see how we inject dependencies.  Magic will work only after injection. <br><br><h3>  Custom Scopes and efficient memory management </h3><br>  Custom Scopes, as such, serve to provide your lecturing classes with a specific life time. <br><br><h3>  Object life cycle </h3><br><br><img src="https://habrastorage.org/files/37c/0c0/a7b/37c0c0a7b74d425e9e53b31a9fae34b0.png"><br>  <em>Pic.</em>  <em>author - Miroslaw Stanek from Azimo</em> <em><br></em>  <a href="http://frogermcs.github.io/dagger-graph-creation-performance/">http://frogermcs.github.io/dagger-graph-creation-performance</a> <br>  For example, you have an activity, and they live for quite a short time, go from one screen to another and kill everything.  That is, everything that is injected into the activity can be cleaned up after that, and the application will consume less memory.  Some class of user data, for example, User, will live between logins.  Application Scope - the most important, root scope, living the longest. <br><br><h3>  And once again the same matryoshka <br>  Component has a scope of life </h3><br><br><img src="https://habrastorage.org/files/985/34d/e5c/98534de5c5b04ddeb8a2995eb74fbc14.png"><br>  <em>Pic.</em>  <em>author - Miroslaw Stanek from Azimo</em> <em><br></em>  <a href="http://frogermcs.github.io/dagger-graph-creation-performance/">http://frogermcs.github.io/dagger-graph-creation-performance/</a> <br><br><h3>  This mysterious 'plus' ... </h3><br><br><img src="https://habrastorage.org/files/68f/2e1/457/68f2e1457468463896b0b49276380a60.png"><br><br>  Now pay attention to the plus. <br><br><h3>  Subcomponent declaration </h3><br><br><img src="https://habrastorage.org/files/2aa/18c/af7/2aa18caf73ca48d199ab5d4ab33f2582.png"><br><br>  Abstract <a href="https://habrahabr.ru/users/scope/" class="user_link">Scope</a> allows you to generate scopes of a specific lifetime.  For example, ActivityScope will live as long as the activity lives.  They annotate components as subcomponents. <br><br><h3>  But there was a module there! </h3><br><br><img src="https://habrastorage.org/files/140/3fd/409/1403fd409e554651a1f10ccb1752f5e0.png"><br><br>  The data inside is described as in the root component.  Except for one thing: when you call plus, pass the module there and instantiate it, you get the subcomponent you need. <br><br><h3>  Add subcomponent to dependency tree root </h3><br><br><img src="https://habrastorage.org/files/7c1/994/251/7c19942519cd4a6a8b48839ac7829f30.png"><br><br>  What is it used for?  For scopes, which can be declared as interfaces, limit the lifetime of our objects. <br><br><h3>  Abstract <a href="https://habrahabr.ru/users/scope/" class="user_link">Scope</a> </h3><br><br><img src="https://habrastorage.org/files/d64/d0c/700/d64d0c7002b84385a7c93740d3359561.png"><br><br><img src="https://habrastorage.org/files/f13/12b/44b/f1312b44b31149d98145d7d900a429d0.png"><br><br>  This type of <a href="https://habrahabr.ru/users/scope/" class="user_link">Scope</a> will limit the lifetime statically, depending on where you are going to inject.  And the other will limit dynamically. <br>  Dynamic means that you will manage it manually, and everything will be removed using the garbage <em>collector</em> ("garbage collector"). <br>  We annotate the component needed by the scopam. <br><br><h3>  @ActivityScope </h3><br><br><img src="https://habrastorage.org/files/327/996/4c2/3279964c229a49dd8c2ce454c3726308.png"><br><br><img src="https://habrastorage.org/files/b85/019/044/b8501904461e424182891f526c0c8613.png"><br><br>  @UserScope, for example, how it will work this very scop, which has @Retention (RUNTIME).  It can be controlled manually. <br><br><h3>  @UserScope </h3><br><br><img src="https://habrastorage.org/files/141/874/23f/14187423fcee4a90bd038456c543011d.png"><br><br>  To manage it manually, you save the link to the component inside the application next to the AppComponent. <br><br><img src="https://habrastorage.org/files/c45/5d9/231/c455d9231b2a40dca816c8c2b2f985ea.png"><br><br>  It is created using a special method, an example of code that you can see.  Then the code was cleaned, sent to the release, and the garbage <em>collector removes it.</em>  <em>When does this happen?</em>  <em>When the user logged out</em> ( <em>‚Äúlogged out‚Äù</em> ).  The next time you call another createUserComponent, this component will be created again with other user data. <br><br><h3>  Finally ... What is injected? </h3><br><ul><li>  Modules demo data. </li><li>  Presenters. </li><li>  Singletons </li><li>  Test class implementations. </li><li>  ... Everything else that is instantiated and creates dependencies. </li></ul><br>  In fact, you need to inject something that will help you more effectively inject memory and write code.  Presenters must be uniquely used. <br>  Singleton - it is convenient.  In the example that I will give now, we injected Mock data for the demo version, and they could also be used with variations for testing. <strong>&nbsp;</strong><br><h2>  Home readings </h2><br>  Sample code: <a href="">http://github.com/c-mars/Dagger2Scopes.git</a> <br><ul><li>  Fernando Cejas ‚ÄúTasting Dagger 2 on Android‚Äù: <br>  <a href="http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/">http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/</a> </li></ul><br><ul><li>  Miroslav Stanek ‚ÄúDagger 2 - graf creation performance /: <br>  <a href="http://frogerms.github.io/dagger-creation-performance/">http://frogerms.github.io/dagger-creation-performance/</a> </li></ul><br><ul><li>  Dagger2 official page: <br>  <a href="http://google.github.io/dagger/">http://google.github.io/dagger/</a> </li></ul><br>  I recommend reading Fernando Cejas about design patterns.  Miroslav Stanek very well described scopes.  He has a wonderful article on how to properly manage @Retention (RUNTIME) and clean memory in time.  And, of course, visit the official page Dagger2. <br><h2>  Sense code </h2><br>  How we organized quick agile development using Mock modules and eventually overtook the server side. <br>  The story is.  We used Dagger 2 in the project with unit tests, with the correct MVP separation, but the key point was that the server side was not at that time.  And we wrote an application that should take the data from the server, show it all beautifully processed by analyzing the data.  The main task was to ensure that when REST services appeared, we could quickly switch to them.  Quickly do this, you can only change the code manually.  With the presence of modules and components, after the appearance of the server, we easily replaced the Mock-data (which was delivered via injection) with real data from the REST API, replacing only one module and one line of code in the declaration of the root component. </div><p>Source: <a href="https://habr.com/ru/post/283018/">https://habr.com/ru/post/283018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283002/index.html">Mouse gesture editor and other new items in the assembly Vivaldi 1.2.470.11</a></li>
<li><a href="../283004/index.html">How to build a competent testing system? Insights from QA experts on May 19 in St. Petersburg</a></li>
<li><a href="../283008/index.html">Differences between Azure Resource Manager and Azure Service Manager - a developer‚Äôs perspective, part two, about Networking</a></li>
<li><a href="../283010/index.html">Viber received end-to-end encryption by default</a></li>
<li><a href="../283012/index.html">Experience of using contracts in REST API calls</a></li>
<li><a href="../283020/index.html">The first success of a complex game bot</a></li>
<li><a href="../283022/index.html">Developers lazy to the edge?</a></li>
<li><a href="../283024/index.html">We delegate the right to restore virtual machines, files and application objects using Enterprise Manager</a></li>
<li><a href="../283026/index.html">How to replace ELK for viewing logs?</a></li>
<li><a href="../283028/index.html">Squid's serious proxy vulnerability can ‚Äúpoison cache‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>