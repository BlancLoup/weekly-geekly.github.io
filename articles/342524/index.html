<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Experience developing low power devices on the STM32L</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quite often you can find articles on the use of low power modes. In most cases, they describe the advantages and disadvantages of a particular microco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Experience developing low power devices on the STM32L</h1><div class="post__text post__text-html js-mediator-article"> Quite often you can find articles on the use of low power modes.  In most cases, they describe the advantages and disadvantages of a particular microcontroller, and all the recommendations are reduced to a generalized phrase - use sleep modes. <br><a name="habracut"></a><br>  In this article, I would like to delve a little into these recommendations and tell the reader about the methods of reducing energy consumption that I personally encountered when developing one of the devices. <br><br>  The background is such that it was necessary to develop an analog signal logger.  Circuitry no difficulties: <br><br>  - 11 ADC channels <br>  - Bluetooth <br>  - SD card <br>  - OLED display 128x64 <br>  - powered by one AAA battery 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The idea was as follows: the user turns on the device, using the buttons and the display, adjusts the parameters and starts the measurements.  Next, the channels are digitized and saved to the memory card.  Optionally, you can turn on Bluetooth to view measurements in real time from your smartphone, or unload previously saved data to the card.  In the measurement mode, the device had to live on one AAA battery for 3 days. <br><br>  For the reader not versed in the calculations, an approximate estimate: <br><br>  24 hours a day, on average, an AAA battery with a nominal 1.5V value gives 600‚Äì1000 mAh, so in the worst case the device should consume 600 / (24 * 3) = 8.3 mA, at best 1000 / (24 * 3) = 13 mA.  But there is a very important feature: the consumption of 1.5V.  The memory card and the microcontroller work at 3V, so in terms of 3V roughly this figure should be 2 times less, i.e.  4-6mA.  When you turn on Bluetooth and the display requirements were more "soft", so they are not taken into account. <br><br>  There was no doubt about the choice of platform - STM32, mainly due to the availability and recommendations of other developers, and the platform has long been mastered.  L0 did not fit due to the lack of stones with the necessary amount of minced meat, so the choice was made in favor of STM32L151.  There were thoughts about the STM32L4, but the price at that time was higher, and there were no obvious reasons for choosing it. <br><br>  At that time, I had no experience in developing low power devices, but in general, the requirements and preliminary calculations of power consumption using the + cubemx datasheet showed that everything should converge.  To penetrate a little, turn on a regular microcontroller, for example STM32F103 at the maximum frequency of 72 MHz and you will see consumption of only one processor in tens of mA, without peripherals.  Even the usual red LED consumes 10mA at 1.9V.  Therefore, it was assumed that the device will sleep most of the time. <br><br><img src="https://habrastorage.org/webt/5z/qb/uy/5zqbuydgvvlltvj6t9x5kxjw9lm.png"><br><br>  Circuit features the device does not contain.  Used already proven power scheme.  From 1.5V it was pumped into 3B, the ADC part was powered from 2.5V.  When the power was reduced to 0.95V, the device was turned off. <br><br><img src="https://habrastorage.org/webt/lk/nv/ba/lknvbaupcycmzmd-9jttalyziqm.png"><br><br>  The first problem faced was how to get data from the ADC.  In fact, there were 11 channels, each of which was digitized at its own frequency, in addition, some channels were 12-bit, some 8-bit.  The total data flow is about 6.5kbytes per second.  There were two options: 1. pick up via DMA.  2. to start transformations on the timer and to take away in interruption. <br><br>  An inexperienced reader will say that the DMA + timer is driving, you can start conversions and take the CPU to sleep.  However, there is only one ADC in L151, so it cannot be launched simultaneously at different frequencies.  If one channel is polled at a frequency of 1 Hz, and the second is 2 kHz, then when working through DMA, both will have to be polled at 2 kHz.  The disadvantages are obvious - additional RAM consumption, additional buffer raking involving CPU, additional DMA consumption. <br><br>  Obviously, if the distribution of the survey frequency was different, then everything would be different, but in my particular case, it turned out to be completely unprofitable to use DMA.  Tests have shown that polling on interrupts saves battery consumption much more.  I repeat, it all depends on the specific situation. <br><br>  Another interesting note for using a bunch of ADC + DMA + timer.  Keep in mind that the timers themselves consume very unevenly, so be sure to check out the datasheet before you start a particular timer. <br><br>  Despite the variety of sleep patterns in L1, they are quite limited.  For example, do you want to confuse DMA + ADC and turn off the CPU?  Then the only mode you can do is Sleep, because the ADC is clocked by HSI, and HSI only works in Sleep. <br><br><img src="https://habrastorage.org/webt/_c/xa/_q/_cxa_qoiigm0amqqvyoxichglne.png"><br><br>  The topic of further research was which interface to use for a memory card - SPI or SDIO.  Unfortunately, I don‚Äôt remember the details, but when recording by sector, the consumption was approximately the same, but in the multiblock, due to the write-to-power ratio, the choice was clearly in favor of SDIO. <br><br>  Also, in principle, the multiblock turned out to be more profitable in terms of power consumption, so saving data as much as possible in RAM is the right decision.  There was an option to put an external operative, but many new risks appeared there, so I had to confine myself to internal one. <br><br>  Another piece of work was the FAT file system.  It was required that the memory card when connected to a PC was visible on any computer without additional software.  Taking into account the features required only FAT32.  At the same time, the data are not lost when a sudden power outage. <br><br>  From the point of view of energy consumption, as already mentioned above, it was much more profitable to write with a multiblock and at the same time it was necessary to minimize the number of calls to the card.  The FAT problem is a periodic reference to the FAT table, where cluster chains are updated. <br><br>  The solution turned out to be simple - before the recording began, space was allocated for a large file, and later during the work, the data was written without the FAT library, using the usual low-level functions.  It also avoided the problems associated with a sudden power outage. <br><br>  As for the SD memory cards themselves, this is a separate story.  Despite their prevalence, there is simply no 100% reliable data on how maps work on the Internet.  Information had to be collected bit by bit.  The problems that I had to face two: 1. Consume differently 2. Sector transfer works differently. <br><br>  With problem 1, it is simply impossible to fight.  A simple example.  You take a card - you write down a sector, N mA is spent on it.  If you stop writing, the card continues to consume these N mA, for example, 64 ms, without doing anything.  You take another card; it immediately stops consuming after recording a sector. <br><br>  Problem 2. Maybe someone has heard that there is such a thing as wear leveling, in short, this is a controller inside the memory card, which ensures that the sectors on the card are worn evenly.  Apparently, there is no single standard on this score, and the mean mention of this came across only (if not mistaken) from toshiba.  Therefore, there are reasons to believe that this controller works completely differently in different cards.  And in some maps, there is none at all. <br><br>  It appears so, you write many times in the same sector.  For those cards that apparently do not have a controller, the sector stops reading after N records.  For other cards, at certain intervals, the recording time increases dramatically once.  Moreover, tests have shown that this time can reach up to 1 second.  Yes, yes, there is no error in this figure.  Here is an example of recording 5,000 times in the same sector, we see a periodic increase in recording time. <br><br><img src="https://habrastorage.org/webt/xs/yr/-h/xsyr-hoho6xwqas1ya5vyufm2du.png"><br><br>  In practice, no difference was noted between brand and noname cards.  Checked a bunch of cards from different manufacturers.  It so happened that in tests the card of a certain manufacturer showed excellent results, but the same card, bought in another store or with a different amount of GB, showed absolutely disgusting indicators. <br><br>  The only solution to the problem was to finish the memory card tester in the device, buy a card - insert it into the device, test it, if it passes on power consumption, then you buy a batch.  Within the same batch, consumption of the cards was similar. <br><br>  Total, on STM32L151 it was succeeded to get into 10 mA on 1.5B.  During the development process, many additional requests appeared, so the initial idea that the device would sleep turned out to be fundamentally wrong.  In general, this fit the requirement of 3 days, however, it turned out that they should include 4 mA of the customer's additional fee :).  The only hope was the transfer of the project under STM32L4. <br><br>  The main trump card STM32L4 was 3 ADC, instead of one.  What is good?  You can run each ADC transform independently, i.e.  The ADC + DMA + timer, no longer gave such an overhead as in L1.  Now it was possible to group the channels by the number of samples per second.  This made it possible for the processor to go to sleep more often and spend a minimum of time on raking the buffer. <br><br>  Compare the ADC clocking system for L1 <br><br><img src="https://habrastorage.org/webt/nc/io/9t/ncio9tuzxjrq5bh91wilx3lnh8y.png"><br><br>  And for L4 <br><br><img src="https://habrastorage.org/webt/jy/vt/pj/jyvtpj5mbxkmgg80s5lckk1zpo0.png"><br><br>  As mentioned earlier, the measurements in L1 are quite limited.  For example, the ADC is clocked directly from HSI, if you need to measure something, then HSI should be enabled at 16 MHz and nothing else.  In STM32L4 almost everything is configured independently of each other.  ADC can be clocked from any generator. <br><br>  The most pleasant surprise was the MSI clock generator.  Yes, it is in L1, however, as mentioned above, it is impossible to start an ADC from it.  In my case, the difference in consumption between HSI 16 MHz and MSI 8 MHz was just huge. <br><br>  But studies of the dependence of the clock frequency on power consumption showed that reducing the clock speed to 4 MHz does not give a strong difference in consumption, but the performance drops dramatically. <br><br>  Clock signals for the rest of the periphery, now also become possible to understate.  There were also bonus things for L4, such as low power clocking SDIO and ADC, when clocking is included directly at the moments of transmission.  The use of the CRC hardware module also paid off.  Here, you can enable another feature, you can configure the peripherals so that it is automatically turned off when you enter Sleep. <br><br>  The essential step, which allowed to achieve a result, was the use of compression.  More precisely, in the first version of the device it was also present, the algorithm used was developed by the customer specifically for this device.  However, tests have shown that LZ4 presses much better and spends significantly less CPU.  On average, from 6.5kB turned out 1.5-2kB data. <br><br>  An important factor was the verification of each nominal for suspenders, high-quality washing of printed circuit boards, any drop of poorly washed flux gave additional leaks.  Practice has shown that the boards are best washed only with ordinary alcohol.  The seemingly imperceptible defects of installation are very important, therefore I highly recommend paying great attention to this. <br><br>  In conclusion, I can say that the transition and the price of L4 are absolutely justified for devices that require really low power consumption.  In the end, it was possible to achieve the desired consumption of 4.5-5.5 mA at 1.5V.  On tests, the device successfully lived more than 3 days from one battery. </div><p>Source: <a href="https://habr.com/ru/post/342524/">https://habr.com/ru/post/342524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342510/index.html">3D graphics from scratch. Part 1: ray tracing</a></li>
<li><a href="../342512/index.html">‚ÄúHello, World!‚Äù For novice writers</a></li>
<li><a href="../342514/index.html">How White Label helps in the development of services and products. 5 examples</a></li>
<li><a href="../342516/index.html">Key announcements Connect (); 2017</a></li>
<li><a href="../342518/index.html">Why programmers don't get jobs: four horror stories</a></li>
<li><a href="../342526/index.html">Service Oriented Architecture (SOA)</a></li>
<li><a href="../342528/index.html">Video of reports from the Agile Kitchen conference in M.Video</a></li>
<li><a href="../342530/index.html">It fell by itself, or the consequence are the cones</a></li>
<li><a href="../342532/index.html">51% attack or pocket guide for the Chinese government</a></li>
<li><a href="../342534/index.html">Dive into ICO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>