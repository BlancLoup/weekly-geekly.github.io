<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Table of virtual methods and safety</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As a small warm-up before the article, I would like the reader to ask himself the following question: do the photographer need to know how the camera ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Table of virtual methods and safety</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/335/656/82d/33565682db6c6d0acd263884e9731c97.png" alt="Safety engineering" align="left">  As a small warm-up before the article, I would like the reader to ask himself the following question: do the photographer need to know how the camera works in order to get high-quality pictures?  Well, at least, should he know the concept of "diaphragm"?  "Signal-to-noise ratio"?  "Depth of field"?  Practice suggests that even with the knowledge of such complex words, pictures can be obtained from the most ‚Äúhandy‚Äù ones, which are not particularly better than those taken on a mobile phone through a 0.3-megapixel-hollow.  And on the contrary, really good pictures can be obtained solely due to experience and intuition with complete ignorance of the materiel (although these are rather exceptions to the rules, but still).  However, it is unlikely that someone will argue with me that professionals who want to squeeze everything out of their technology (and not just the number of megapixels per square millimeter of the matrix) need this knowledge without fail, since otherwise they will have to be called a professional. can not.  And this is true not only for the digital photography industry, but for almost any other. <br><br>  This is also true for programming, and doubly for programming in C ++.  This article will describe the important concept of the language, known as the ‚ÄúVirtual Table Index‚Äù, which is present in almost all complex classes, and how it can be accidentally damaged.  This can, in turn, lead to hardly debugging errors.  First, let me remind you what it is all about, and then I will share my thoughts on how and what could break there. <br><a name="habracut"></a><br>  To our great regret, in this article there will be a lot of reasoning related to the low level.  But no problem anymore, alas, not to illustrate.  At the same time, I‚Äôll make a reservation that the article is written mostly for the Visual C ++ Compiler compiler in the build mode of a 64-bit program - the results of the program‚Äôs work in other compilers and for another architecture may differ. <br><br><h2>  Virtual Table Index </h2><br>  The theory says that the vptr pointer ‚Äî a pointer to a virtual method table, or a virtual table pointer ‚Äî is present in every class that has at least one virtual method.  Let us understand in more detail what kind of animal it is.  To do this, we write a simple demo program in C ++. <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; int nop() { static int nop_x; return ++nop_x; //   , ! }; class A { public: unsigned long long content_A; A(void) : content_A(0xAAAAAAAAAAAAAAAAull) { cout &lt;&lt; "++ A has been constructed" &lt;&lt; endl;}; ~A(void) { cout &lt;&lt; "-- A has been destructed" &lt;&lt; endl;}; void function(void) { nop(); }; }; void PrintMemory(const unsigned char memory[], const char label[] = "contents") { cout &lt;&lt; "Memory " &lt;&lt; label &lt;&lt; ": " &lt;&lt; endl; for (size_t i = 0; i &lt; 4; i++) { for (size_t j = 0; j &lt; 8; j++) cout &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; uppercase &lt;&lt; hex &lt;&lt; static_cast&lt;int&gt; (memory[i * 8 + j]) &lt;&lt; " "; cout &lt;&lt; endl; } } int main() { unsigned char memory[32]; memset(memory, 0x11, 32 * sizeof(unsigned char)); PrintMemory(memory, "before placement new"); new (memory) A; PrintMemory(memory, "after placement new"); reinterpret_cast&lt;A *&gt;(memory)-&gt;~A(); system("pause"); return 0; };</span></span></span></span></code> </pre> <br>  Despite the relatively large amount of code, the logic of its work should be fairly obvious: 32 bytes are allocated on the stack, which are filled with the values ‚Äã‚Äã0x11 (we assume that this is sort of garbage in memory).  Then, a rather trivial class A object is created over these 32 bytes using the <a href="http://www.viva64.com/go.php%3Furl%3D1084">placement new</a> operator. Finally, the contents of the memory are printed, after which the program destroys the object and completes its execution.  Below is the output of this program (Microsoft Visual Studio 2012, x64). <br><pre> <code class="cpp hljs">Memory before placement <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> ++ A has been constructed Memory after placement <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: AA AA AA AA AA AA AA AA <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> -- A has been destructed Press any key to <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> . . .</code> </pre> <br>  It is easy to see that the class size in memory is 8 bytes and is equal to the size of its only member unsigned long long content_A. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's make the program a bit more complicated by adding the virtual keyword to the void function (void): <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{nop();};</code> </pre> <br>  The output of the program (hereinafter, only part of the output will be shown with the exception of Memory before placement new and Press any key ...): <br><pre> <code class="cpp hljs">++ A has been constructed Memory after placement <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: F8 D1 C4 <span class="hljs-number"><span class="hljs-number">3F</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> AA AA AA AA AA AA AA AA <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> -- A has been destructed</code> </pre> <br>  Again, it is easy to see that the class size in memory is now 16 bytes.  The first eight bytes now occupy a pointer to a table of virtual methods.  The pointer at the start of the program turned out to be 0x000000013FC4D1F8 (the pointer and content_A are ‚Äúdeployed‚Äù in memory, since Intel64 uses little-endian <a href="http://www.viva64.com/go.php%3Furl%3D1444">byte order</a> ; however, in the case of content_A, you can‚Äôt tell about it right away). <br><br>  The virtual method table is a special in-memory structure generated automatically that lists pointers to virtual methods.  If the function () method is called somewhere in the code with reference to the pointer to class A, instead of calling the function A :: function directly (), the function in the virtual methods table will be called at the desired offset ‚Äî this behavior implements polymorphism.  By itself, the table of virtual functions is presented below (obtained by compiling with the / FAs key; in addition, pay attention to the somewhat strange name of the function in the assembler code - it went through the <a href="http://www.viva64.com/go.php%3Furl%3D1447">name-mangling</a> ): <br><pre> <code class="cpp hljs">CONST SEGMENT ??_7A@@<span class="hljs-number"><span class="hljs-number">6B</span></span>@ DQ FLAT:??_R4A@@<span class="hljs-number"><span class="hljs-number">6B</span></span>@ ; A::<span class="hljs-string"><span class="hljs-string">'vftable'</span></span> DQ FLAT:?function@A@@UEAAXXZ CONST ENDS</code> </pre> <br><br><h2>  __declspec (novtable) </h2><br>  Sometimes there are situations when the table of virtual classes, in principle, is not needed.  Suppose that we will never instantiate class A, and if we do, it is only on weekends and on holidays, but at the same time carefully making sure that no virtual function is called.  This is quite a common situation in cases of abstract classes - it is known that if a class is abstract, then it cannot be instantiated.  Not at all.  Indeed, if function (void) were declared in class A as abstract, then the virtual method table would look like this: <br><pre> <code class="cpp hljs">CONST SEGMENT ??_7A@@<span class="hljs-number"><span class="hljs-number">6B</span></span>@ DQ FLAT:??_R4A@@<span class="hljs-number"><span class="hljs-number">6B</span></span>@ ; A::<span class="hljs-string"><span class="hljs-string">'vftable'</span></span> DQ FLAT:_purecall CONST ENDS</code> </pre> <br>  Obviously, an attempt to call such a function will lead to a backache of his own leg. <br><br>  The question is: if a class is never instantiated, then why install a virtual table pointer?  In order for the compiler to not generate extra code, you can give it instructions in the form of __ declspec (notable) (caution: Microsoft-specific!).  Rewrite our example class with a virtual function using the __declspec (novtable) attribute: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">declspec</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">novtable</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> .... }</code> </pre> <br>  The output of the program will be as follows: <br><pre> <code class="cpp hljs">++ A has been constructed Memory after placement <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> AA AA AA AA AA AA AA AA <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> -- A has been destructed</code> </pre> <br>  First of all, let's pay attention to the fact that the size of the object has not changed: it still takes 16 bytes.  In total, after introducing the __declspec (novtable) attribute, there were only two differences: firstly, now at the place where the address of the virtual method table was located, there is an uninitialized memory area;  secondly, in the assembler code, the virtual methods table of class A is no longer at all.  But the virtual table pointer is still there and still ‚Äúweighs‚Äù eight bytes!  This needs to be remembered because ... <br><br><h2>  Inheritance </h2><br>  Let's rewrite our example in such a way as to implement the simplest inheritance from an abstract class with a virtual table pointer. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">declspec</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">novtable</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> //     {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> content_A; A(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) : content_A(<span class="hljs-number"><span class="hljs-number">0xAAAAAAAAAAAAAAAA</span></span>ull) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"++ A has been constructed"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;}; ~A(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"-- A has been destructed"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> A <span class="hljs-comment"><span class="hljs-comment">//     A { public: unsigned long long content_B; B(void) : content_B(0xBBBBBBBBBBBBBBBBull) { cout &lt;&lt; "++ B has been constructed" &lt;&lt; endl;}; ~B(void) { cout &lt;&lt; "-- B has been destructed" &lt;&lt; endl;}; virtual void function(void) { nop(); }; };</span></span></code> </pre> <br>  Also we will make so that instead of class A in the main program a class B is created (and destroyed): <br><pre> <code class="cpp hljs">.... <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (memory) B; PrintMemory(memory, <span class="hljs-string"><span class="hljs-string">"after placement new"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;B *&gt;(memory)-&gt;~B(); ....</code> </pre> <br>  The output of the program will be as follows: <br><pre> <code class="cpp hljs">++ A has been constructed ++ B has been constructed Memory after placement <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: D8 CA <span class="hljs-number"><span class="hljs-number">2</span></span>C <span class="hljs-number"><span class="hljs-number">3F</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> AA AA AA AA AA AA AA AA BB BB BB BB BB BB BB BB <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> -- B has been destructed -- A has been destructed</code> </pre> <br>  Let's try to figure out what happened.  The constructor B :: B () was called.  This constructor, before being executed, calls the constructor of the base class, the constructor A :: A ().  First of all, it should have initialized the virtual table pointer, however, due to the attribute __ declspec (novtable) it was not initialized.  Then the constructor sets the value of the content_A field to 0xAAAAAAAAAAAAAAAAull (the second field in memory) and returns control to the constructor B :: B (). <br><br>  Since object B does not have the attribute __declspec (novtable), the constructor sets the virtual table pointer (first field in memory) to the class B virtual table, then sets content_B to 0xBBBBBBBBBBBBBBBBull (third field in memory) and returns control to the main program.  From the contents of the memory, it is easy to understand that the object of class B was constructed correctly, and from the logic it is clear that an unnecessary operation in this context was skipped.  If confused: under an unnecessary operation is the initialization of a pointer to a virtual table in the constructor of the base class. <br><br>  It would seem that only one operation was missed - meaning to get rid of it?  But if the program has thousands and thousands of classes inherited from the same abstract class, getting rid of one auto-generated command can seriously affect performance.  And will affect.  Do not believe? <br><br><h2>  Memset function </h2><br>  The main idea of ‚Äã‚Äãthe memset () function is to fill the memory area with a certain constant value (most often zero).  In C, it could be used to quickly initialize all the fields in a structure.  What is the difference between C ++ class and C structure in memory if there is no virtual table pointer in it?  In principle, nothing, data - they are data.  To initialize really simple classes (in C ++ 11 terminology - <a href="http://www.viva64.com/go.php%3Furl%3D1445">types with a standard device</a> ) it is quite possible to use the memset () function.  But, in theory, the memset () function can be used to initialize all classes in general, but what are the consequences?  An incorrect memset () can, in one fell swoop, make a virtual table pointer unusable.  But the question immediately arises: is it possible, all the same, if the class is declared as __ declspec (notable)? <br><br>  Answer: it is possible, but only carefully. <br><br>  Rewrite the classes as follows: add the wipe method, which will set all the contents of class A to 0xAA: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">declspec</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">novtable</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> //     {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> content_A; A(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"++ A has been constructed"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; wipe(); }; <span class="hljs-comment"><span class="hljs-comment">// { cout &lt;&lt; "++ A has been constructed" &lt;&lt; endl; }; ~A(void) { cout &lt;&lt; "-- A has been destructed" &lt;&lt; endl;}; virtual void function(void) = 0; void wipe(void) { memset(this, 0xAA, sizeof(*this)); cout &lt;&lt; "++ A has been wiped" &lt;&lt; endl; }; }; class B : public A //     A { public: unsigned long long content_B; B(void) : content_B(0xBBBBBBBBBBBBBBBBull) { cout &lt;&lt; "++ B has been constructed" &lt;&lt; endl;}; // { // cout &lt;&lt; "++ B has been constructed" &lt;&lt; endl; // A::wipe(); // }; ~B(void) { cout &lt;&lt; "-- B has been destructed" &lt;&lt; endl;}; virtual void function(void) {nop();}; };</span></span></code> </pre> <br>  The output of the program in this case will turn out to be quite expected: <br><pre> <code class="cpp hljs">++ A has been constructed ++ A has been wiped ++ B has been constructed Memory after placement <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: E8 CA E8 <span class="hljs-number"><span class="hljs-number">3F</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> AA AA AA AA AA AA AA AA BB BB BB BB BB BB BB BB <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> -- B has been destructed -- A has been destructed</code> </pre> <br>  So far everything is working well. <br><br>  However, it is worth slightly changing the location of the call to the wipe () function, commenting out the constructor lines and uncommenting the ones following them, and it will immediately become clear that something has gone wrong.  The first call to the virtual function function () will result in a run-time error due to a damaged virtual table pointer: <br><pre> <code class="cpp hljs">++ A has been constructed ++ B has been constructed ++ A has been wiped Memory after placement <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA BB BB BB BB BB BB BB BB <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> -- B has been destructed -- A has been destructed</code> </pre> <br>  Why did it happen?  The wipe () function was called after the class B constructor initialized the pointer to the virtual method table.  As a result, this pointer has gone bad.  In other words, you should not reset a class with a virtual table pointer, even if it is declared with __ declspec (novtable).  Full zeroing will be appropriate only in the constructor of the class that will never be instantiated, and even then this should be done with great care. <br><br><h2>  Memcpy function </h2><br>  With the memcpy () function, the picture is exactly the same.  Again, in theory, it can be used to copy types with a standard device in memory.  However, judging by practice, some programmers like to use it where necessary and where not.  In the case of types that do not have a standard device in memory, using the memcpy () function is like walking a rope over Niagara Falls: one mistake can lead to fatal consequences, and making it ridiculously simple.  As an example: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">declspec</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">novtable</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> .... A(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp;source) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;source, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> A { .... };</code> </pre> <br>  The copy constructor can write whatever his digital heart desires to a pointer to a virtual table of an abstract class: the correct value will be put there anyway in the heir classes.  But in the implementation of the assignment operator, the memcpy () function can no longer be used: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">declspec</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">novtable</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> .... A &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp;source) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;source, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> A { .... };</code> </pre> <br>  Now, remember how much we are used to, that the assignment operator and the copy constructor are in fact the same thing.  No, not everything is so bad: in practice, the assignment operator code can even work properly, but not at all because it is correct, but because the stars are like that.  The code copies the pointer to the table of virtual methods from another object, and it is not known what this will result in. <br><br><h2>  PVS-Studio </h2><br>  This article appeared as a result of detailed research regarding the mysterious __ declspec (novtable), as well as when it is possible, and when it is impossible to use the functions memset () and memcpy () in high-level code.  From time to time, developers write to us that the <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> analyzer too often gives warnings regarding the virtual table pointer.  Programmers believe that if there is __declspec (novtable), then there is neither a virtual method table nor a virtual table pointer.  We began to carefully deal with this issue and realized that not everything is so simple. <br><br>  <b>It must be remembered.</b>  If __declspec (novtable) is used when declaring a class, this does not mean that the class does not contain a pointer to a table of virtual methods!  But this pointer is initialized or not - this is a completely different question. <br><br>  We will make the analyzer not swear at the memset () / memcpy () function, but only if they are used in the constructors of the base class declared with __ declspec (novtable). <br><br><h2>  Conclusion </h2><br>  Unfortunately, the article did not manage to cover a lot of material related to inheritance (for example, the topic of multiple inheritance remained completely uncovered).  However, I hope that this information will make it possible to understand that ‚Äúeverything is not so simple there‚Äù and that it is worth thinking three times before using low-level functions in relation to high-level objects.  And in general, is it worth it? </div><p>Source: <a href="https://habr.com/ru/post/239915/">https://habr.com/ru/post/239915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239897/index.html">"Disney" is working on the natural movements of robots</a></li>
<li><a href="../239903/index.html">Come freebie!</a></li>
<li><a href="../239905/index.html">What's new in CakePHP 3.0.0?</a></li>
<li><a href="../239907/index.html">Tesla D: Two engines, four-wheel drive, acceleration to 100 km / h in 3.2 seconds</a></li>
<li><a href="../239913/index.html">‚ÄúWild‚Äù tourism as the highest gradation of the traveler, or for whom Tourista.me was created</a></li>
<li><a href="../239919/index.html">How we developed our first application on Xamarin.Forms and what came of it</a></li>
<li><a href="../239921/index.html">Trial versions of applications will appear on Google Play Store</a></li>
<li><a href="../239925/index.html">W for Wikipedia</a></li>
<li><a href="../239927/index.html">News from the world of Node: Node 0.11.14, svgexport, node-webkitgtk, Nightmare, Prototypes, node-libpq and node-pg-native</a></li>
<li><a href="../239931/index.html">Amazon opens first physical store in New York</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>