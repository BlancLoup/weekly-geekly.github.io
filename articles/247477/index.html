<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>QQuickRenderControl, or how to make QML friends with someone else's OpenGL context. Part I</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The recent release of Qt 5.4 , among other things, put at the disposal of the developers one, in my opinion, a very interesting tool. Namely, the Qt d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>QQuickRenderControl, or how to make QML friends with someone else's OpenGL context. Part I</h1><div class="post__text post__text-html js-mediator-article">  The recent <a href="http://habrahabr.ru/post/245521/">release of Qt 5.4</a> , among other things, put at the disposal of the developers one, in my opinion, a very interesting tool.  Namely, the Qt developers made <a href="http://doc-snapshot.qt-project.org/qt5-5.4/qquickrendercontrol.html">QQuickRenderControl</a> part of the public API.  The use of this class is that it is now possible to use Qml in conjunction with any other framework, if it provides the ability to get (or set) a pointer to the context used by OpenGL. <br>  On the other hand, in the process of working on one of my projects, I was faced with the need to render the QML scene on <a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CALayer_class/index.html">CALayer (Mac OS X)</a> , without the slightest opportunity to access the parent window.  A weekly search for possible solutions to the problem showed that the most appropriate solution would be to use QQuickRenderControl from Qt 5.4, thanks to a successful coincidence, which received release status at the same time as the aforementioned task had occurred. <br>  Initially, I assumed that the task is not real, and it will be solved in a couple of evenings, but how wrong I was - the task took about half a month for research, and another half a month for implementation (which is still far from ideal). <br><a name="habracut"></a><br><h4>  <b>Several theses</b> </h4><br><ul><li>  QQuickRenderControl is just an additional interface to the implementation of <a href="http://doc.qt.io/qt-5/qquickwindow.html">QQuickWindow</a> for receiving notifications about changing the QML scene, as well as sending commands in the opposite direction (that is, in fact, a ‚Äúcrutch‚Äù); </li><li>  The result of rendering will be obtained as <a href="http://doc.qt.io/qt-5/qopenglframebufferobject.html">QOpenGLFramebufferObject (hereinafter referred to as FBO)</a> , which can later be used as a texture; </li><li>  You will have to work directly with QuickWindow; accordingly, the QML download service provided by QQuickView will not be available, and you will have to implement it yourself; </li><li>  Since no window is actually created, it becomes necessary to artificially pass mouse and keyboard events to QQuickWindow.  It is also necessary to manually control the size of the window; </li><li>  An example of using QQuickRenderControl I managed to find only one, in Qt 5.4 (Examples \ Qt-5.4 \ quick \ rendercontrol) - it was actually on him and went through all the proceedings; </li></ul><br><br><h4>  <b>What should be done to solve the original problem?</b> </h4><br>  1) Implement the QQuickWindow setting for rendering in FBO and controlling this process through QQuickRenderControl; <br>  2) Implement loading Qml and attaching the result to QQuickWindow; <br>  3) Implement the transmission of mouse and keyboard events; <br>  4) Draw FBO (for the sake of which everything was started); <br><br>  In this article I will allow myself to dwell only on point 1), the remaining points in the subsequent parts (if you find it interesting). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <b>Customizing QQuickWindow</b> </h4><br><h5>  <b><i>External QOpenGLContext</i></b> </h5><br>  The starting point is the OpenGL context in which FBO will eventually render.  But since, with a high degree of probability, it is necessary to work with the context initially having no relation to Qt, it is necessary to convert the context from the operating system format to the QOpenGLContext instance.  To do this, use the <a href="http://doc.qt.io/qt-5/qopenglcontext.html">QOpenGLContext :: setNativeHandle method</a> . <br>  NSOpenGLContext based usage example: <br><br><pre><code class="hljs php">NSOpenGLContext* nativeContext = [super openGLContextForPixelFormat: pixelFormat]; QOpenGLContext* extContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QOpenGLContext; extContext-&gt;setNativeHandle( QVariant::fromValue( QCocoaNativeContext( nativeContext ) ) ); extContext-&gt;create();</code> </pre> <br>  <i>It is better to look at the list of available Native Context directly in Qt header files (include \ QtPlatformHeaders), since</i>  <i>the documentation in this part is not very complete.</i> <br><br>  Then you can use this context (but you need to carefully monitor that the state changes of this context do not conflict with the owner's manipulations), but you can make a shared context: <br><br><pre> <code class="hljs pgsql"> QSurfaceFormat <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>.setDepthBufferSize( <span class="hljs-number"><span class="hljs-number">16</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>.setStencilBufferSize( <span class="hljs-number"><span class="hljs-number">8</span></span> ); context = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> QOpenGLContext; context-&gt;setFormat( <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> ); context-&gt;setShareContext( extContext ); context-&gt;<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>();</code> </pre><br><br>  An important nuance to use OpenGL context with QML is the presence of configured Depth Buffer and Stencil Buffer, so if you do not have the ability to influence the parameters of the source context, you need to use a shared context with the installed Depth Buffer Size and Stencil Buffer Size. <br><br><h5>  <b><i>Creating QQuickWindow</i></b> </h5><br>  When creating a QQuickWindow, a QQuickRenderControl is pre-created and passed to the constructor: <br><pre> <code class="hljs php"> QQuickRenderControl* renderControl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QQuickRenderControl(); QQuickWindow* quickWindow = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QQuickWindow( renderControl ); quickWindow-&gt;setGeometry( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">640</span></span>, <span class="hljs-number"><span class="hljs-number">480</span></span> );</code> </pre><br>  In addition, it is important to set the window size for further successful creation of the FBO. <br><br><h5>  <b><i>QQuickRenderControl and QOpenGLFramebufferObject initialization</i></b> </h5><br>  Before calling QQuickRenderControl :: initialize, it is important to make the context current, because  during the call, the sceneGraphInitialized signal will be generated, and this is a good point for creating an FBO (which, in turn, requires an exposed current context). <br><pre> <code class="hljs php"> QOpenGLFramebufferObject* fbo = nullptr; connect( quickWindow, &amp;QQuickWindow::sceneGraphInitialized, [&amp;] () { fbo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QOpenGLFramebufferObject( quickWindow-&gt;size(), QOpenGLFramebufferObject::CombinedDepthStencil ); quickWindow-&gt;setRenderTarget( fbo ); } ); offscreenSurface = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QOffscreenSurface(); offscreenSurface-&gt;setFormat( context-&gt;format() ); offscreenSurface-&gt;create(); context-&gt;makeCurrent( offscreenSurface ); renderControl-&gt;initialize( context ); context-&gt;doneCurrent();</code> </pre><br><br><h5>  <b><i>Rendering</i></b> </h5><br>  Rendering needs to be done as a response to the QQuickRenderControl :: renderRequested and QQuickRenderControl :: sceneChanged signals.  The difference in these two cases is that in the second case it is necessary to additionally call QQuickRenderControl :: polishItems and QQuickRenderControl :: sync.  The second important feature is that it is <a href="http://doc-snapshot.qt-project.org/qt5-5.4/qquickrendercontrol.html">strongly advised not to</a> render directly in the handlers of the above signals.  Therefore, a timer is used with a small interval.  Well, the last subtlety is that, in the case of using the shared OpenGL context, after rendering, glFlush is required to be called - otherwise the primary context does not see changes in FBO. <br><br><pre> <code class="hljs php"> bool* needSyncAndPolish = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bool; *needSyncAndPolish = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; QTimer* renderTimer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QTimer; renderTimer-&gt;setSingleShot( <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ); renderTimer-&gt;setInterval( <span class="hljs-number"><span class="hljs-number">5</span></span> ); connect( renderTimer, &amp;QTimer::timeout, [&amp;] () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( context-&gt;makeCurrent( offscreenSurface ) ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( *needPolishAndSync ) { *needPolishAndSync = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; renderControl-&gt;polishItems(); renderControl-&gt;sync(); } renderControl-&gt;render(); quickWindow-&gt;resetOpenGLState(); context-&gt;functions()-&gt;glFlush(); context-&gt;doneCurrent(); } ); connect( renderControl, &amp;QQuickRenderControl::renderRequested, [&amp;] () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !renderTimer-&gt;isActive() ) renderTimer-&gt;start(); } ); connect( renderControl, &amp;QQuickRenderControl::sceneChanged, [&amp;] () { *needPolishAndSync = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !renderTimer-&gt;isActive() ) renderTimer-&gt;start(); } );</code> </pre><br><br>  Well, in general, that's all, the first part of the task is completed. <br><br>  A class that implements the above concept is available on GitHub: <a href="">FboQuickWindow.h</a> , <a href="">FboQuickWindow.cpp</a> <br>  Comments, questions, healthy criticism in the comments are welcome. <br><br>  Continued: <a href="http://habrahabr.ru/post/248103/">Part II: Loading QML</a> , <a href="http://habrahabr.ru/post/249383/">Part III: Processing User Input</a> </div><p>Source: <a href="https://habr.com/ru/post/247477/">https://habr.com/ru/post/247477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247467/index.html">Open-rynda: crowdsourcing solutions for emergency situations and volunteer network coordination</a></li>
<li><a href="../247469/index.html">Some interesting and useful things for web developer # 36</a></li>
<li><a href="../247471/index.html">Messages in depth: the amazing story of the underwater Internet</a></li>
<li><a href="../247473/index.html">JSON, which you can comment</a></li>
<li><a href="../247475/index.html">Real-Time Interactive Cyber ‚Äã‚ÄãAttack Maps</a></li>
<li><a href="../247481/index.html">Year npm in numbers: 2014</a></li>
<li><a href="../247483/index.html">Dnipropetrovsk Discussion Meetup: CQRS Problem / Solution</a></li>
<li><a href="../247487/index.html">Why vi-ax programmer 21st century</a></li>
<li><a href="../247489/index.html">The first experience of developing iOS applications and thinking about marketing and advertising</a></li>
<li><a href="../247491/index.html">We make shipped assemblies: we interact between domains without marshalling</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>