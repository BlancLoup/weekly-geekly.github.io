<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Chromium: memory leaks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We bring to your attention a series of articles devoted to recommendations for writing high-quality code using the example of errors found in the Chro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Chromium: memory leaks</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f5/e8f/aac/7f5e8faacd9b5dd5f248d1ed618f7682.png" alt="PVS-Studio and CWE-401"></div>  We bring to your attention a series of articles devoted to recommendations for writing high-quality code using the example of errors found in the Chromium project.  This is the third part, which will be devoted to memory leaks. <br><a name="habracut"></a><br>  I believe that the code of the Chromium project and the libraries used in it are of very high quality.  Yes, in the introductory article I wrote about <a href="http://cppfiles.com/chromium.txt">250 errors</a> , but in fact - this is a very small number.  By virtue of the laws of probability, a huge project will surely find a lot of mistakes. <br><br>  Nevertheless, if we talk about memory leaks, they are not so few.  I think the developers of Chromium are failing that they prefer dynamic code analyzers.  Of course, these tools have a number of advantages.  For example, they do not give false positives, because once the dynamic analyzer has detected an error, then it really is. <br><br>  On the other hand, dynamic analysis has weaknesses.  If some code is not executed, then the error will not be detected.  And any programmer understands that it is extremely difficult to cover with tests 100% of the code, or rather, in practice it is simply impossible.  As a result, a number of errors remain in the code and are waiting for a favorable set of circumstances in order to prove themselves. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here a static code analyzer can help.  Yes, this is a hint to Google developers that we will be happy if they become our customers.  Moreover, we are ready for additional work on the adaptation and configuration of PVS-Studio for the features of the Chromium project.  Our team is also ready to take on editing the errors found.  We already had a similar experience ( <a href="https://www.unrealengine.com/en-US/blog/static-analysis-as-part-of-the-process">example</a> ). <br><br>  But back to memory leaks.  As you will see, they are hiding in code that rarely gets control.  Basically, these are different error handlers.  Static analyzers, unlike dynamic ones, are not always able to track the ‚Äúfate of the pointer‚Äù on the allocated memory and will not detect many memory leaks.  On the other hand, static analyzers check the entire code, regardless of the probability of its execution, and notice errors.  Thus, static and dynamic analyzers complement each other. <br><br>  Let's see what memory leaks I noticed during the analysis of the report issued by PVS-Studio.  As I wrote in the <a href="https://habrahabr.ru/company/pvs-studio/blog/347536/">introductory article</a> , I looked at the report rather briefly, so there may be other errors that I did not notice.  I also note that memory leaks are extremely unpleasant for a project like Chromium, so it will be interesting to talk about them.  According to CWE, these errors can be classified as <a href="https://cwe.mitre.org/data/definitions/401.html">CWE-401</a> . <br><br><h2>  Part 1: forgot to free the memory before exiting the function </h2><br>  Consider an error in the Chromium code.  First, I‚Äôll show the auxiliary function <i>BnNew</i> , which allocates and returns a zeroed memory buffer: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  And now let's look at the code that could lead to a memory leak: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; .... }</span></span></code> </pre> <br>  If the condition is satisfied <i>(pkey.n0inv == 0)</i> , then the function is exited without releasing the buffer, the pointer to which is stored in the variable <i>n</i> . <br><br>  The analyzer points to this defect by issuing a warning: <a href="https://www.viva64.com/ru/w/v773/">V773</a> CWE-401.  A memory leak is possible.  android_rsa.cc 248 <br><br>  By the way, this is where memory leaks related to Chromium itself end.  But there are a lot of them in used libraries.  But users do not care, memory will flow in the libraries of Chromium or in the Chromium itself.  Therefore, errors in libraries are no less important. <br><br>  The following errors are related to the WebKit engine.  We will have to start again with an auxiliary function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CSSValueList* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSpaceSeparated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSSValueList(kSpaceSeparator); }</code> </pre> <br>  Now the code containing the error: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSSValue* CSSTransformValue::ToCSSValue(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { CSSValueList* transform_css_value = CSSValueList::CreateSpaceSeparated(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transform_components_.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSSValue* component = transform_components_[i]-&gt;ToCSSValue(secure_context_mode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!component) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= transform_css_value-&gt;Append(*component); } return transform_css_value; }</span></span></code> </pre> <br>  If the <i>component</i> pointer turns out to be zero, the function will terminate, and a memory leak will occur. <br><br>  The PVS-Studio analyzer issues a warning: V773 CWE-401 The transform_css_value pointer.  A memory leak is possible.  csstransformvalue.cpp 73 <br><br>  Let's look at some more error related to WebKit. <br><br><pre> <code class="cpp hljs">Request* Request::CreateRequestWithRequestOrString(....) { .... BodyStreamBuffer* temporary_body = ....; .... temporary_body = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyStreamBuffer(script_state, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(init.GetBody())); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exception_state.HadException()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; .... }</code> </pre> <br>  If the <i>HadException ()</i> function returns true, the function will complete its work ahead of schedule.  In this case, no one will call the operator <i>delete</i> for the pointer stored in the variable <i>temporary_body</i> . <br><br>  PVS-Studio warning: V773 CWE-401 The function was extinguished.  A memory leak is possible.  request.cpp 381 <br><br><div class="spoiler">  <b class="spoiler_title">The remaining errors that I noticed in WebKit are no different from those described, so I see no reason to consider them in the article and will limit myself to just a list of analyzer messages.</b> <div class="spoiler_text"><ul><li>  V773 CWE-401 The function was exited without releasing the 'image_set' pointer.  A memory leak is possible.  csspropertyparserhelpers.cpp 1507 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  csspropertyparserhelpers.cpp 1619 </li><li>  V773 CWE-401 The function was exited without releasing the 'shape' pointer.  A memory leak is possible.  cssparsingutils.cpp 248 </li><li>  V773 CWE-401 The function was exited without releasing the 'shape' pointer.  A memory leak is possible.  cssparsingutils.cpp 272 </li><li>  V773 CWE-401 The function was exited without releasing the 'shape' pointer.  A memory leak is possible.  cssparsingutils.cpp 289 </li><li>  V773 CWE-401 The function was exited without releasing the 'shape' pointer.  A memory leak is possible.  cssparsingutils.cpp 315 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  cssparsingutils.cpp 1359 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  cssparsingutils.cpp 1406 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  cssparsingutils.cpp 1359 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  cssparsingutils.cpp 1406 </li><li>  V773 CWE-401 The 'values' pointer.  A memory leak is possible.  cssparsingutils.cpp 1985 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  cssparsingutils.cpp 2474 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  cssparsingutils.cpp 2494 </li><li>  V773 CWE-401 The 'values' pointer.  A memory leak is possible.  atruledescriptorparser.cpp 30 </li><li>  V773 CWE-401 The 'values' pointer.  A memory leak is possible.  atruledescriptorparser.cpp 57 </li><li>  V773 CWE-401 The 'values' pointer.  A memory leak is possible.  atruledescriptorparser.cpp 128 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  csssyntaxdescriptor.cpp 193 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  computedstylecssvaluemapping.cpp 1232 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  computedstylecssvaluemapping.cpp 1678 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  computedstylecssvaluemapping.cpp 1727 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  computedstylecssvaluemapping.cpp 2036 </li><li>  V773 CWE-401 The size_and_line_height 'pointer.  A memory leak is possible.  computedstylecssvaluemapping.cpp 2070 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  computedstylecssvaluemapping.cpp 2070 </li><li>  V773 CWE-401 The function file ex.  A memory leak is possible.  v8scriptvaluedeserializer.cpp 249 </li><li>  V773 CWE-401 The function file ex.  A memory leak is possible.  v8scriptvaluedeserializer.cpp 264 </li><li>  V773 CWE-401 The computed_style_info 'pointer.  A memory leak is possible.  inspectordomsnapshotagent.cpp 367 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  cursor.cpp 42 </li><li>  V773 CWE-401 The 'values' pointer.  A memory leak is possible.  content.cpp 103 </li><li>  V773 CWE-401 The function was exited without releasing the 'variation_settings' pointer.  A memory leak is possible.  fontvariationsettings.cpp 56 </li><li>  CWE-401 V773 Visibility Scope of the font_variation_value  A memory leak is possible.  fontvariationsettings.cpp 58 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  rotate.cpp 32 </li><li>  V773 CWE-401 The 'values' pointer.  A memory leak is possible.  quotes.cpp 25 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  textindent.cpp 52 </li><li>  V773 CWE-401 The List List Pointer.  A memory leak is possible.  shapeoutside.cpp 35 </li><li>  V773 CWE-401 The 'port_array' pointer.  A memory leak is possible.  v8messageeventcustom.cpp 127 </li></ul></div></div><br>  Lot?  Lot.  In this case, here are written only those messages for which I had the strength.  I quickly got bored and looked through such warnings very superficially.  Most likely, with a more careful analysis of the report, there will be much more errors found in WebKit. <br><br>  What does it mean?  This means that the WebKit project has problems with memory leaks, with which I ‚Äúcongratulate‚Äù this project. <br><br>  We now turn to the ICU project and consider the error found in it. <br><br><pre> <code class="cpp hljs">UVector* RuleBasedTimeZone::copyRules(UVector* source) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } UErrorCode ec = U_ZERO_ERROR; <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> size = source-&gt;size(); UVector *rules = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UVector(size, ec); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (U_FAILURE(ec)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } .... }</code> </pre> <br>  If during the initialization of an object of the <i>UVector</i> type some error occurs, this will affect the status that is placed in the variable <i>ec</i> .  For example, the constructor will return the status of <i>U_MEMORY_ALLOCATION_ERROR</i> if it is not possible to allocate a memory buffer to store the required number of elements.  However, regardless of whether it is possible to allocate memory for storing elements or not, an object of type <i>UVector</i> will be created and a pointer to this object will be placed in the variable <i>rules</i> . <br><br>  If the constructor returns the status <i>U_MEMORY_ALLOCATION_ERROR</i> , then the function will exit.  In this case, an object of type <i>UVector</i> will not be deleted, and a memory leak will occur. <br><br>  PVS-Studio warning: V773 CWE-401 The function was exhibited.  A memory leak is possible.  rbtz.cpp 668 <br><br><div class="spoiler">  <b class="spoiler_title">Other errors in the library ICU also give just a list.</b> <div class="spoiler_text"><ul><li>  V773 CWE-401 The tmpSet 'pointer.  A memory leak is possible.  uspoof_impl.cpp 184 </li><li>  V773 CWE-401 The 'result' pointer.  A memory leak is possible.  stsearch.cpp 301 </li><li>  V773 CWE-401 The 'values' pointer.  A memory leak is possible.  tznames_impl.cpp 154 </li><li>  V773 CWE-401 The function of filtering.  A memory leak is possible.  tridpars.cpp 298 </li><li>  V773 CWE-401  A memory leak is possible.  transreg.cpp 984 </li><li>  V773 CWE-401 The function of the instance.  A memory leak is possible.  tzgnames.cpp 1216 </li><li>  V773 CWE-401 The function was exited without releasing the pointer.  A memory leak is possible.  rbbiscan.cpp 1276 </li></ul></div></div><br>  What else did I notice? <br><br><div class="spoiler">  <b class="spoiler_title">Libwebm library.</b> <div class="spoiler_text"><ul><li>  V773 CWE-401 The function was exited without releasing the 'new_frame' pointer.  A memory leak is possible.  mkvmuxer.cc 3513 </li><li>  V773 CWE-401 The function was exited without releasing the 'new_frame' pointer.  A memory leak is possible.  mkvmuxer.cc 3539 </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">SwiftShader library.</b> <div class="spoiler_text"><ul><li>  V773 CWE-401  A memory leak is possible.  intermediate.cpp 405 </li><li>  V773 CWE-401  A memory leak is possible.  intermediate.cpp 443 </li><li>  V773 CWE-401  A memory leak is possible.  intermediate.cpp 514 </li><li>  V773 CWE-401 The function was exited without releasing the pointer.  A memory leak is possible.  intermediate.cpp 1457 </li><li>  V773 CWE-401 The function was exited without releasing the 'unionArray' pointer.  A memory leak is possible.  intermediate.cpp 1457 </li><li>  V773 CWE-401 The function was exited without the aggregateArguments' pointer.  A memory leak is possible.  parsehelper.cpp 2109 </li></ul></div></div><br>  Probably, these are not all errors, but they are enough for me to demonstrate the capabilities of PVS-Studio and write this article. <br><br><h2>  Part 1: recommendation </h2><br>  What unites all the above cases?  The fact that errors became possible due to manual memory management! <br><br>  Friends, we already use C ++ 17.  Stop calling the <i>new</i> operator, put the result in an ordinary pointer, and then forget to release it.  It's a shame. <br><br>  No more ordinary pointers and subsequent manual control of the selected resource!  Let's always use smart pointers. <br><br>  The modern C ++ standard offers <a href="https://en.wikipedia.org/wiki/Smart_pointer">smart pointers</a> such as <i>unique_ptr</i> , <i>shared_ptr,</i> and <i>weak_ptr</i> .  In most cases, one <i>unique_ptr</i> will suffice. <br><br>  Let us return, for example, to this incorrect code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSSValue* CSSTransformValue::ToCSSValue(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { CSSValueList* transform_css_value = CSSValueList::CreateSpaceSeparated(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transform_components_.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSSValue* component = transform_components_[i]-&gt;ToCSSValue(secure_context_mode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!component) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; transform_css_value-&gt;Append(*component); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transform_css_value; }</code> </pre> <br>  Let's rewrite it using <i>unique_ptr</i> .  To do this, we first need to change the type of the pointer itself.  Secondly, at the very end, you need to call the <i>release</i> function to return a pointer to the managed object and no longer control it. <br><br>  Correct code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSSValue* CSSTransformValue::ToCSSValue(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;CSSValueList&gt; transform_css_value( CSSValueList::CreateSpaceSeparated()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transform_components_.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSSValue* component = transform_components_[i]-&gt;ToCSSValue(secure_context_mode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!component) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; transform_css_value-&gt;Append(*component); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transform_css_value.release(); }</code> </pre> <br>  I do not plan to teach in this article how to use smart pointers.  This topic is devoted many good articles and sections in the books.  I just wanted to show that the code did not become more complicated and cumbersome due to the changes.  But now it will be much more difficult to make a mistake. <br><br>  Do not think that it is you who will cope with <i>new / delete</i> or <i>malloc / free</i> and make no mistakes.  Chromium developers make such mistakes.  Other developers <a href="https://www.viva64.com/ru/examples/v773/">do</a> .  You make and will make such mistakes.  And do not unnecessary dreams that your team is special :).  Taking this opportunity, I ask the managers to read now this <a href="https://www.viva64.com/ru/b/0498/">note here</a> . <br><br>  Use smart pointers. <br><br><h2>  Part 2: realloc </h2><br>  According to my observations, programmers sometimes incorrectly use the <a href="http://en.cppreference.com/w/c/memory/realloc"><i>realloc</i></a> function.  Here is the classic error pattern associated with using this function: <br><br><pre> <code class="cpp hljs">p = <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(p, n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR;</code> </pre> <br>  Let's pay attention to the following property of the function: <br><br>  Since <i>NULL</i> will be written to the variable <i>p</i> , which kept the pointer to the buffer, it is no longer possible to free this buffer.  There is a memory leak. <br><br>  The correct option would be to rewrite the code, for example, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *old_p = p; p = <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(p, n); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(old_p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR; }</code> </pre> <br>  Not without such errors in the libraries used in the project Chromium. <br><br>  For example, consider the code snippet in the FLAC codec. <br><br><pre> <code class="cpp hljs">FLAC__bool FLAC__format_entropy_codi.....ce_contents_ensure_size( FLAC__EntropyCodingMethod_PartitionedRiceContents *object, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> max_partition_order) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(object-&gt;capacity_by_order &lt; max_partition_order) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span> == (object-&gt;parameters = <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(object-&gt;parameters, ....))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span> == (object-&gt;raw_bits = <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(object-&gt;raw_bits, ....))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... }</code> </pre> <br>  The function increases the size of two buffers: <br><br><ul><li>  object-&gt; parameters </li><li>  object-&gt; raw_bits </li></ul><br>  If a memory allocation error occurs, the function terminates early and returns <i>false</i> .  This will lose the previous value of the pointer, and a memory leak will occur. <br><br>  The PVS-Studio analyzer issues two corresponding warnings here: <br><br><ul><li>  <a href="https://www.viva64.com/ru/w/v701/">V701</a> CWE-401 realloc () possible leak: when realloc () fails in allocating memory, original pointer 'object-&gt; parameters' is lost.  Consider assigning realloc () to a temporary pointer.  format.c 576 </li><li>  V701 CWE-401 realloc () possible leak: when realloc () fails in allocating memory, original pointer 'object-&gt; raw_bits' is lost.  Consider assigning realloc () to a temporary pointer.  format.c 578 </li></ul><br><div class="spoiler">  <b class="spoiler_title">Similar flaws in the project WebRTC.</b> <div class="spoiler_text"><ul><li>  V701 CWE-401 realloc () possible leak: when realloc () fails in allocating memory, original pointer 'self-&gt; binary_far_history' is lost.  Consider assigning realloc () to a temporary pointer.  delay_estimator.cc 303 </li><li>  V701 CWE-401 realloc () possible leak: when realloc () fails in allocating memory, original pointer 'self-&gt; far_bit_counts' is lost.  Consider assigning realloc () to a temporary pointer.  delay_estimator.cc 306 </li><li>  V701 CWE-401 realloc () possible leak: when realloc () fails in allocating memory, original pointer 'self-&gt; mean_bit_counts' is lost.  Consider assigning realloc () to a temporary pointer.  delay_estimator.cc 453 </li><li>  V701 CWE-401 realloc () possible leak: when realloc () fails in allocating memory, original pointer 'self-&gt; bit_counts' is lost.  Consider assigning realloc () to a temporary pointer.  delay_estimator.cc 456 </li><li>  V701 CWE-401 realloc () possible leak: when realloc () fails in allocating memory, original pointer 'self-&gt; histogram' is lost.  Consider assigning realloc () to a temporary pointer.  delay_estimator.cc 458 </li></ul></div></div><br>  Errors of this type in Chromium, fortunately, are very few.  At least, much less than I usually meet in other projects. <br><br><h2>  Part 2: recommendation </h2><br>  It is not always possible to abandon the <i>realloc</i> function, since it allows you to write efficient code when you often need to change the buffer size. <br><br>  Therefore, I will not rush to recommend completely abandon it.  Sometimes it will be unjustified.  I ask only to be careful with this function and not to forget the error pattern that I described above. <br><br>  However, very often in C ++ it is quite possible to do without this function and use containers such as <i>std :: vector</i> or <i>std :: string</i> .  The efficiency of containers has increased significantly in recent years.  For example, I was pleasantly surprised when I saw that there is no longer any difference in performance in the PVS-Studio core between the self-made string class and <i>std :: string</i> .  But many years ago, the self-made class of the line gave about 10% increase in performance to the analyzer.  More such effect is not observed and it became possible to remove its own class.  Now the class <i>std :: string</i> is not at all what it was 10 years ago.  Efficiency has significantly increased due to modern compiler optimization capabilities and thanks to such language innovations as, for example, the displacement constructor. <br><br>  In general, do not rush to roll up your sleeves and manually manage memory using functions <i>malloc</i> , <i>realloc</i> , <i>free</i> .  Almost certainly <i>std :: vector</i> will be no less effective for your tasks.  At the same time, using <i>std :: vector is</i> much easier.  Making a mistake will also become more difficult.  It makes sense to return to the low-level functions only when the profiler shows that this is indeed one of the bottlenecks in the program. <br><br>  Thank you all for your attention.  I invite you to download and try the <a href="https://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> analyzer. <br><br><div style="text-align:center;"> <a href="https://www.viva64.com/en/b/0555/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov.  <a href="https://www.viva64.com/en/b/0555/">Chromium: Memory Leaks</a> . </div><p>Source: <a href="https://habr.com/ru/post/347746/">https://habr.com/ru/post/347746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347734/index.html">Automatic monitoring of newly installed software in ZABBIX</a></li>
<li><a href="../347736/index.html">CC1101 running a PIC controller or building a peer-to-peer network for a radio engineer (part 2)</a></li>
<li><a href="../347738/index.html">Mobile devices from the inside. What is GPT?</a></li>
<li><a href="../347740/index.html">Front End Developer Checklist</a></li>
<li><a href="../347744/index.html">How to package a dependent library in obr when developing a plugin for Jira</a></li>
<li><a href="../347748/index.html">Object in a case or Optional in Java 8 and Java 9. Part 3: ‚ÄúWhat's added in Java 9‚Äù</a></li>
<li><a href="../347750/index.html">Learn OpenGL. Lesson 4.6 - Cubic cards</a></li>
<li><a href="../347752/index.html">Spring AOP. Little question from the interview</a></li>
<li><a href="../347754/index.html">JavaScript proxy: beautiful and useful</a></li>
<li><a href="../347756/index.html">SuperJob IT meetup. Work with business requirements at different project scales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>