<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Build projects using Gulp.js. Yandex Workshop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, my name is Boris. I work in Yandex in the testing department and create tools that allow us to make the life of our testers easier and happier. Ou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Build projects using Gulp.js. Yandex Workshop</h1><div class="post__text post__text-html js-mediator-article">  Hi, my name is Boris.  I work in Yandex in the testing department and create tools that allow us to make the life of our testers easier and happier.  Our team is partly research, so we can afford to use rather unusual tools and experiments.  Recently, I told my colleagues about one of these experiments: <a href="http://gulpjs.com/">Gulp.js.</a>  Today I would like to share this experience with you. <br><br><video>  http://video.yandex.ru/users/ya-events/view/3299/ </video><br><br>  First, a little background, about how web technologies developed.  In the beginning there was no frontend as a separate concept, most of the logic was performed on the server.  Therefore, a variety of tasks for the assembly of scripts and styles, as well as the preparation of images, fonts and other resources were performed by the backend, and their collectors, for example, Apache Ant or Maven.  The frontend was at a disadvantage, the tools provided by these collectors were not very suitable for him.  This problem began to be solved only recently, when Grunt appeared.  This is the first collector written in JS.  Every fronder knows JavaScript, so he can easily write tasks under Grunt and understand already written ones.  This led to the success of this collector.  Grunt has a lot of advantages, but there are also disadvantages. <br><a name="habracut"></a><br>  For example, this is what the simplest Grunt file looks like. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Gruntfile.js</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">grunt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Project configuration. grunt.initConfig({ pkg: grunt.file.readJSON('package.json'), jshint: { files: ['&lt;%= pkg.name %&gt;.js'] }, concat: { options: { banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n' }, main: { src: ['&lt;%= pkg.name %&gt;.js'], dest: 'build/&lt;%= pkg.name %&gt;.js' } }, uglify: { main: { src: 'build/&lt;%= pkg.name %&gt;.js', dest: 'build/&lt;%= pkg.name %&gt;.min.js' } } }); grunt.loadTasks('tasks/'); grunt.registerTask('default', ['jshint', 'concat', 'uglify']); return grunt; };</span></span></code> </pre> <br></div></div><br>  We have a task, for its performance plugins are used.  If we need more action, we connect more plugins.  As a result, we get a huge sheet of code in which nothing can be found.  And since the Grunt-file is large, the build becomes prohibitively long.  And how to accelerate it is completely incomprehensible, because in the Grunt architecture there are no ways to do this. <br><br><div class="spoiler">  <b class="spoiler_title">Gruntfile.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">grunt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Project configuration. grunt.initConfig({ pkg: grunt.file.readJSON('package.json'), karma: { options: { configFile: 'karma.conf.js' }, unit: {}, travis: { browsers: ['Firefox'] } }, jshint: { files: ['&lt;%= pkg.name %&gt;.js'] }, concat: { options: { banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n' }, main: { src: ['&lt;%= pkg.name %&gt;.js'], dest: 'build/&lt;%= pkg.name %&gt;.js' } }, uglify: { main: { src: 'build/&lt;%= pkg.name %&gt;.js', dest: 'build/&lt;%= pkg.name %&gt;.min.js' } }, copy: { main: { expand: true, cwd: 'docs/', src: ['**', '!**/*.tpl.html'], dest: 'build/' } }, buildcontrol: { options: { dir: 'build', connectCommits: false, commit: true, push: true, message: 'Built %sourceName% from commit %sourceCommit% on branch %sourceBranch%' }, pages: { options: { remote: 'git@github.com:just-boris/angular-ymaps.git', branch: 'gh-pages' } } } }); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-jshint'); grunt.loadNpmTasks('grunt-karma'); grunt.loadNpmTasks('grunt-contrib-copy'); grunt.loadNpmTasks('grunt-build-control'); grunt.registerTask('test', 'Run tests on singleRun karma server', function() { if (process.env.TRAVIS) { //this task can be executed in Travis-CI grunt.task.run('karma:travis'); } else { grunt.task.run('karma:unit'); } }); grunt.registerTask('build', ['jshint', 'test', 'concat', 'uglify']); grunt.registerTask('default', ['build', 'demo']); grunt.registerTask('build-gh', ['default', 'buildcontrol:pages']); return grunt; };</span></span></code> </pre><br></div></div><br>  Therefore, the only way out is to try to start everything from the beginning and enter from the other side.  Well, for starters, you can see what is already useful in the outside world.  For example, there is a UNIX shell.  It has a useful concept - pipeline - the direction of exhaust of one process to the input of another process, and it can send its next and so on along the chain. <br><br><pre> <code class="javascript hljs">$ cat *.coffee \ | coffee \ | concat \ | uglify \ &gt; build/app.min.js</code> </pre><br>  Thus, we can build a real conveyor that will perform our assembly.  This is pretty damn logical to do assembly on the pipeline.  This also applies to frontend tasks.  However, if you do this on a pure shell, there may be some problems.  Firstly, not every operating system has a shell, and secondly, we have no commands that, for example, make the conversion of coffee to JS. <br><br>  But this can make Gulp.  This utility is written in JavaScript.  It uses the same principle as the Shell script, but the <code>pipe()</code> function is used instead of the vertical bar here. <br><br><pre> <code class="javascript hljs">gulp.src(<span class="hljs-string"><span class="hljs-string">'*.coffee'</span></span>) .pipe(coffee()) .pipe(concat()) .pipe(uglify()) .pipe(gulp.dest(<span class="hljs-string"><span class="hljs-string">'build/'</span></span>))</code> </pre><br>  Those.  we can do exactly the same thing, while it is clear that what we do, if necessary, we can change blocks of places, delete and generally configure our conveyor as you like. <br><br>  Gulp is already quite stable, has developed to the third version and has found its fans.  It is installed in our favorite way: <br><br><pre> <code class="javascript hljs">npm install -g gulp</code> </pre><br>  I decided to test it on one of my projects and was surprised to find that the build with it runs a little faster than with Grunt.  And now I will try to explain why. <br><br><img src="https://habrastorage.org/files/6c5/046/041/6c504604148b448d907ae3979a593905.png" width="640"><br><br>  The thing is that the most expensive operation at the time of assembly is access to the file system: the assembly takes place in the processor, the file system is somewhere far away, you need to go to it, and it takes some time.  The diagram shows the red arrows as these operations.  It can be seen that there are only two of them in Gulp (read at the entrance, recorded at the output), and at Grunt - four: each plugin reads and writes.  Well, since everything works faster, why not switch to Gulp.  But first I decided to check everything carefully.  I prepared a <a href="https://github.com/just-boris/grunt-gulp-compare">test case</a> in which coffee files and styles are assembled and packaged, described this task for Grunt and Gulp, ran them one by one and saw that there was indeed a gain, gulp was about a quarter faster: 640 ms versus 850. I also prepared another test, a little more complicated.  In it, we need to still slightly style the styles.  Most styles, of course, in bootstrap.  Let's try to build it from the original less-files, and then, to reduce its size, walk through CSSO.  In Gulp, this is done quite easily: there is a plugin for both <code>less</code> and <code>csso</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gulp = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gulp'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> csso = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gulp-csso'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> less = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gulp-less'</span></span>); gulp.task(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gulp.src(<span class="hljs-string"><span class="hljs-string">'bower_components/bootstrap/less/bootstrap.less'</span></span>) .pipe(less()) .pipe(csso()) .pipe(gulp.dest(<span class="hljs-string"><span class="hljs-string">'dest/'</span></span>)); });</code> </pre><br>  Grunt-file turns out more. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">grunt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'time-grunt'</span></span>)(grunt); grunt.loadNpmTasks(<span class="hljs-string"><span class="hljs-string">'grunt-contrib-less'</span></span>); grunt.loadNpmTasks(<span class="hljs-string"><span class="hljs-string">'grunt-csso'</span></span>); grunt.initConfig({ <span class="hljs-attr"><span class="hljs-attr">less</span></span>: { <span class="hljs-attr"><span class="hljs-attr">compile</span></span>: { <span class="hljs-attr"><span class="hljs-attr">src</span></span>: <span class="hljs-string"><span class="hljs-string">'bower_components/bootstrap/less/bootstrap.less'</span></span>, <span class="hljs-attr"><span class="hljs-attr">dest</span></span>: <span class="hljs-string"><span class="hljs-string">'dest/bootstrap.css'</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">csso</span></span>: { <span class="hljs-attr"><span class="hljs-attr">compile</span></span>: { <span class="hljs-attr"><span class="hljs-attr">src</span></span>: <span class="hljs-string"><span class="hljs-string">'dest/bootstrap.css'</span></span>, <span class="hljs-attr"><span class="hljs-attr">dest</span></span>: <span class="hljs-string"><span class="hljs-string">'dest/bootstrap.min.css'</span></span> } } }); grunt.registerTask(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, [<span class="hljs-string"><span class="hljs-string">'less'</span></span>, <span class="hljs-string"><span class="hljs-string">'csso'</span></span>]); };</code> </pre><br>  As a result, Gulp won again: 2 seconds against 2.3.  Grunt spent 300 milliseconds reading and writing unnecessary files. <br><br>  There are not as many plugins for Gulp as for Grunt, but the 400 that are are enough for typical tasks.  Well, if you still lack something, you can always write your own.  The main idea of ‚Äã‚ÄãGulp is streams.  They already exist in the core node.js, for this you do not need to connect anything.  Consider a small example: a plugin that will greet everyone.  We give him a word, and he greet us: <br><br><img src="https://habrastorage.org/files/d32/8b1/156/d328b11565a94b51bc64a6292a9a8535.png" width="640"><br><br>  This is how it will look in JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>), greeterStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> stream.Transform({<span class="hljs-attr"><span class="hljs-attr">objectMode</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); greeterStream._transform = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>+str+<span class="hljs-string"><span class="hljs-string">'!'</span></span>); }; greeterStream.pipe(process.stdout) greeterStream.write(<span class="hljs-string"><span class="hljs-string">'world'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Hello, world! greeterStream.write('uncle Ben'); // Hello, uncle Ben!</span></span></code> </pre><br>  We have a ready-made native object in which we need to define the <code>_transform</code> method.  He is given a string at the entrance so that we process it and return it.  We write to him, and he converts.  You do not need to connect anything, this is the node.js native API.  To see how all this is embedded in the Gulp, remove the cover from it and look inside.  There we will see two modules: Orchestrator and Vinyl fs.  Orchestrator conducts streams, builds them in a queue, tries to perform them with maximum parallelism, and generally ensures that everything works like an orchestra.  With Vinyl everything is a little more interesting.  A stream is a data set, and we collect files.  It is more than just data; it is also a name, an extension, and other attributes.  I would like to somehow separate the continuous stream into separate files.  Vinyl does all that.  In essence, this is a wrapper over files: we receive not just data, but objects.  Vinyl puts all the required fields there.  We can modify and manage them. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coffeeFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File({ <span class="hljs-attr"><span class="hljs-attr">cwd</span></span>: <span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">base</span></span>: <span class="hljs-string"><span class="hljs-string">"/test/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">"/test/file.coffee"</span></span> contents: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(<span class="hljs-string"><span class="hljs-string">"test = 123"</span></span>) });</code> </pre><br>  Every plugin does this, for example, <a href="https://github.com/just-boris/gulp-freeze">gulp-freeze</a> , written by me specifically to show how easy it is.  It is designed to freeze static.  In Gulp, this is all done very simply: we have the content, we calculate the md5-hash from it and say that it is the file name.  Then we write the file further to the stream.  Gulp will do the rest of the operations for us: read the files, give them to our plugin, then pass them on to the rest of the plugins and eventually write them to the file system.  And we write only the most interesting, our plugin. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> through = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'through2'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> through.obj(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/**Vinyl*/</span></span></span></span><span class="hljs-function"><span class="hljs-params">file, enc, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = file.contents.toString(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>), checksum = createMD5(content), file.path = checksum; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(file); callback(); }); };</code> </pre><br>  And since we have nothing superfluous, the test is pretty simple.  Let's create a test stream in which we put the fake data, and we can not even use the file system.  If we write a large plugin, and CI will be configured for it, for example, Travis, we will be pleasantly surprised at the speed of the build.  For all test cases, you can generate virtual files, write them to the stream and listen to the output.  If the output is correct, everything is fine, the test is passed, if not - we have a mistake, we go to correct it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> freeze = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./index.js'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testStream = freeze() testStream.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//assert here }); testStream.write(fakeFile);</span></span></code> </pre><br>  Sometimes it is not even necessary to write a plugin.  Some functions can be inserted directly into the stream.  For example, no one has yet written a Gulp plugin for the Yate template engine.  But we can call it directly: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'vinyl-map'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> yate = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'yate'</span></span>); gulp.src(<span class="hljs-string"><span class="hljs-string">'*.yate'</span></span>) .pipe(map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code, filename</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        return yate.compile(code.toString('utf-8')).js; })) .pipe(gulp.dest('dist/'))</span></span></code> </pre><br><br>  There are more exotic applications of such a system.  For example, this picker can be replaced by Jekyll.  Suppose we have articles in markdown, and we collect web pages from them in HTML.  This scheme ideally fits into the ideology of Gulp, with its help you can collect Jekyll-templates.  To do this, you just need to read our posts, process them, you may have to write a couple of small plug-ins, and as a result get a full-fledged Jekyll port on node.js.  Very comfortably.  It seems to me that in Grunt it is impossible to do this in principle. <br><br><pre> <code class="javascript hljs">gulp.task(<span class="hljs-string"><span class="hljs-string">'jekyll'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gulp.src(<span class="hljs-string"><span class="hljs-string">'_posts/**'</span></span>) .pipe(liquid.collectMeta()) <span class="hljs-comment"><span class="hljs-comment">//    .pipe(post()) //    .pipe(gulp.src('!_*/?*')) //   .pipe(markdown()) //  html,   .pipe(liquid.template()) // .pipe(gulp.dest('_site/')); //  });</span></span></code> </pre><br><br>  <em>PS The report was told in the spring of 2014, over the past six months, tools have evolved, something could have changed, but the basic idea remains the same.</em> </div><p>Source: <a href="https://habr.com/ru/post/239993/">https://habr.com/ru/post/239993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239979/index.html">The hacker group Sednit has switched to using its own set of exploits.</a></li>
<li><a href="../239981/index.html">SSP-based 1-Wire interface implementations</a></li>
<li><a href="../239985/index.html">Overview of mobile applications for learning English</a></li>
<li><a href="../239989/index.html">Designing an UWB Hexagonal Fractal Microstrip Non-Antenna, or Be Vigilant</a></li>
<li><a href="../239991/index.html">What to read at your leisure. Gaming Industry News Digest for September</a></li>
<li><a href="../239995/index.html">Behavioral factors and marketing strategy (interview with top manager)</a></li>
<li><a href="../239997/index.html">Smart Ring Ring - environmental management with gestures</a></li>
<li><a href="../240001/index.html">Cash self-service. Full review</a></li>
<li><a href="../240003/index.html">Introducing Laravel 5 simple blog with local development on VirtualBox + Vagrant</a></li>
<li><a href="../240007/index.html">Remote surveillance based on Synology EDS14 NAS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>