<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Memory models underlying programming languages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We offer you a translation of an article devoted to the consideration of memory models used in programming. 

 Today, six main memory models dominate ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Memory models underlying programming languages</h1><div class="post__text post__text-html js-mediator-article">  <i>We offer you a translation of an <a href="http://canonical.org/~kragen/memory-models">article</a> devoted to the consideration of memory models used in programming.</i> <br><br>  Today, six main memory models dominate programming (not to be confused with <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8_Intel_x86">Intel 8086 memory models</a> ).  Three of them stem from the three historically most important programming languages ‚Äã‚Äãof the 1950s ‚Äî COBOL, LISP, and FORTRAN, and the rest are connected with three historically important data storage systems: tape, hierarchical file system in Unix-style, and a relational database. <br><br>  These models, at a much deeper level than syntax or even a type system, define what our programming languages ‚Äã‚Äãcan or cannot do.  Let's take a closer look at these models, and then discuss some possible alternatives and reasons why they might be interesting. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  Each modern programming environment, to one degree or another, uses all six memory models, and this is one of the reasons why our systems are so complex and difficult to understand. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here we will analyze how each of these memory models: <br><br><ol><li>  represents entity attributes, </li><li>  interacts with serialization, </li><li>  implements and maintains the modularity of programs, limiting access to certain aspects, making them local or private. </li></ol><br><h2>  Prolog: programs with atomic variables only </h2><br>  Let's start with a simple programming language that lacks the ability to structure data, since it has no closures and does not contain any other data types except boolean and finite precision numbers.  Here is his <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0_%25D0%2591%25D1%258D%25D0%25BA%25D1%2583%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%259D%25D0%25B0%25D1%2583%25D1%2580%25D0%25B0">BNF</a> description with the usual semantics and the usual priority of operations: <br><br><pre><code class="hljs matlab">program ::= def* def ::= <span class="hljs-string"><span class="hljs-string">"def"</span></span> name <span class="hljs-string"><span class="hljs-string">"("</span></span> args <span class="hljs-string"><span class="hljs-string">")"</span></span> block args ::= <span class="hljs-string"><span class="hljs-string">""</span></span> | name <span class="hljs-string"><span class="hljs-string">","</span></span> args block ::= <span class="hljs-string"><span class="hljs-string">"{"</span></span> statement* <span class="hljs-string"><span class="hljs-string">"}"</span></span> statement ::= <span class="hljs-string"><span class="hljs-string">"return"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> <span class="hljs-string"><span class="hljs-string">";"</span></span> | name <span class="hljs-string"><span class="hljs-string">":="</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> <span class="hljs-string"><span class="hljs-string">";"</span></span> | <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> <span class="hljs-string"><span class="hljs-string">";"</span></span> | nest nest ::= <span class="hljs-string"><span class="hljs-string">"if"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> block | <span class="hljs-string"><span class="hljs-string">"if"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> block <span class="hljs-string"><span class="hljs-string">"else"</span></span> block | <span class="hljs-string"><span class="hljs-string">"while"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> block <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> ::= name | num | <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> op <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> | <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> exps <span class="hljs-string"><span class="hljs-string">")"</span></span> | <span class="hljs-string"><span class="hljs-string">"("</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> <span class="hljs-string"><span class="hljs-string">")"</span></span> | unop <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> exps ::= <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span> <span class="hljs-string"><span class="hljs-string">","</span></span> exps unop ::= <span class="hljs-string"><span class="hljs-string">"!"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span> | <span class="hljs-string"><span class="hljs-string">"~"</span></span> op ::= logical | comparison | <span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"*"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span> | <span class="hljs-string"><span class="hljs-string">"/"</span></span> | <span class="hljs-string"><span class="hljs-string">"%"</span></span> logical ::= <span class="hljs-string"><span class="hljs-string">"||"</span></span> | <span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span> | <span class="hljs-string"><span class="hljs-string">"&amp;"</span></span> | <span class="hljs-string"><span class="hljs-string">"|"</span></span> | <span class="hljs-string"><span class="hljs-string">"^"</span></span> | <span class="hljs-string"><span class="hljs-string">"&lt;&lt;"</span></span> | <span class="hljs-string"><span class="hljs-string">"&gt;&gt;"</span></span> comparison ::= <span class="hljs-string"><span class="hljs-string">"=="</span></span> | <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> | <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span> | <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> | <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> | <span class="hljs-string"><span class="hljs-string">"!="</span></span></code> </pre> <br>  An example of converting Fahrenheit to Celsius in this language: <br><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (f ‚Äî <span class="hljs-number"><span class="hljs-number">32</span></span>) * <span class="hljs-number"><span class="hljs-number">5</span></span> / <span class="hljs-number"><span class="hljs-number">9</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { say(f2c(-<span class="hljs-number"><span class="hljs-number">40</span></span>)); say(f2c(<span class="hljs-number"><span class="hljs-number">32</span></span>)); say(f2c(<span class="hljs-number"><span class="hljs-number">98.6</span></span>)); say(f2c(<span class="hljs-number"><span class="hljs-number">212</span></span>)); }</code> </pre> <br>  Let's agree that in our programming language recursion is prohibited, and the greedy (eager) computation strategy with call-by-value is used.  We also agree that all variables are implicitly local and initialized with zeros when calling subroutines.  Thus, no subroutine can have any side effects.  In this form, our programming language is applicable only to the programming of finite automata.  If you compile such a program under a real processor with registers, then each variable encountered in the program text can be assigned one register.  Each subroutine can also be assigned a register for the return address.  In addition, you will need another register for the team counter.  Running the program in this language on a machine with gigabytes of RAM will not give any benefit.  She can never use more variables than she did at the beginning. <br><br>  It does not make such a language useless.  There are many useful calculations that can be done in tight spaces.  But it really does not allow to fully use its abstract power, even for such calculations. <br><br>  To access additional memory, you can use the peek () and poke () functions to read or write one byte to the specified address.  Thus, one would really use memory effectively: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strcpy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d, s, n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { poke(d + n, peek(s + n)); n := n ‚Äî <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br>  However, many programming languages ‚Äã‚Äãdo not even provide peek () and poke ().  Instead, they provide a certain structure on top of an ascetic uniform byte array. <br><br>  For example, even when programming finite automata, nested records, arrays, and unions already provide tremendous benefits. <br><br><h2>  COBOL Nesting Entries and Memory Model: Memory as Income Declaration </h2><br>  In COBOL, a data object is either something indivisible: <br><br><ul><li>  foundational object of the type of string or number of a certain size, </li><li>  or a collection of objects, such as: <br><br><ul><li>  recording (objects of various types, stored side by side one after another); </li><li>  association (alternative objects that are stored, occupying the same place); </li><li>  or an array (a certain number of objects of the same type, stored side by side one after another). </li></ul></li></ul><br>  (Here we have significantly deviated from the terminology and taxonomy of COBOL, in order to simplify the understanding of what this language offers). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/539/d49/c4a/539d49c4aa87472db2d18e3e1e42c3a3.jpg"></div><br>  In such a memory model, if you have several similar entities, then each of them will have a record of the same type (both in size and in subfields) intended for storing information.  Thus, all information about this entity will be located in memory sequentially.  You can very easily download and store these pieces of related data on a disk, tape, punch cards or any other storage media.  If several of these entries are in memory at the same time, they can be put into an array. <br><br>  Any attribute of an entity is defined by two bytes representing the beginning and end offset of this attribute relative to the base address of the record storing the data of this entity.  For example, the Account object may have the Owner field, which occupies bytes from 10 to 35, within which from 18 to 26 bytes the account holder‚Äôs middle name will be stored. <br><br>  About this approach, you can make some interesting comments. <br><br>  There are no pointers at all.  This means that there is no way to make a dynamic allocation of memory, you can‚Äôt dereference a null pointer, don‚Äôt overwrite a memory area using a dangling pointer (although if two variables are declared as REDEFINES, then of course they can wipe each other and avoid <a href="https://en.wikipedia.org/wiki/Tagged_union">Tagged unions can</a> help with this problem, no memory shortage, no overlap, and no memory consumption on pointers. <br><br>  On the other hand, it also means that every data structure in your program has a strict limit, and the only way to use the same memory for different things at different times is to risk using them at the same time. <br><br>  Nested records are very economical with memory.  You need to keep in memory only the data of those entities with which you are working at the moment.  This means that you can successfully process megabytes of data on a machine with kilobytes of memory, as COBOL programmers did in the 1950s. <br><br>  Each piece of data (fields, subfields, etc.) has one unique parent (with the exception of the highest level), which immediately contains all the child data. <br><br>  In this memory model, if one part of the program has its own memory (for example, a stack frame or a static private variable), it can make some entities private by storing their data in this own memory.  This is useful if you need to create a local temporary variable and be sure that it will not affect the execution of the rest of the program.  However, such a memory model does not allow any part of the program to make the attribute private. <br><br>  ALGOL (and ALGOL-58 and ALGOL-60) borrowed a record from COBOL as the main, in addition to arrays, data structuring mechanism.  And it is from Algol that almost all other programming languages ‚Äã‚Äãinherited it in one form or another. <br><br>  The C language has almost the entire set of tools for structuring data: primitive types (char, int, etc.), structures, unions, and arrays.  However, C also has pointers and subroutines that not only take arguments, but are recursive, requiring something like a stack allocation.  Both of these extensions to the COBOL model come from LISP. <br><br><h2>  Object Graphs and LISP Memory Model: Memory as a Marked Oriented Graph </h2><br>  LISP (it is now Lisp, and in 1959 was LISP) could hardly be even more different from COBOL.  Not only are there pointers in it, so besides them there is almost nothing left in the LISP.  The only mechanism for structuring data in a LISP is something called cons, which consists of two pointers, one of which is called "car" and the other is "cdr".  The value of any variable is a pointer.  It can be a pointer to cons, or a pointer to a character, or a pointer to a number, or sometimes even a pointer to a subroutine, but this is a pointer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c22/2c8/d04/c222c8d046de4e99be198583342b24d5.jpg"></div><br><br>  In addition, there are recursive subroutines with arguments, and because of this, as well as <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B2%25D0%25BE%25D1%2581%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2580%25D0%25B5%25D0%25BA%25D1%2583%25D1%2580%25D1%2581%25D0%25B8%25D1%258F">tail recursion</a> optimization, you can write programs that do something without ever changing the value of a variable. <br><br>  Any object can be referenced by any number of pointers, by means of any of which an object can be modified.  Thus, the object does not have a unique parent. <br><br>  This model is extremely flexible in the sense that it makes it quite easy to write programs for processing natural languages, program interpretation and compilation, <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B1%25D0%25BE%25D1%2580">brute-force</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25B2%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">symbolic computations</a> .  It also makes it easy to create a data structure (for example, a <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D1%2581%25D0%25BD%25D0%25BE-%25D1%2587%25D1%2591%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">red-black tree</a> ) once, and then apply it to many different types of objects.  In contrast, COBOL-derived languages ‚Äã‚Äãsuch as C have considerable difficulty with this kind of generalization, with the result that programmers have to write a huge amount of repetitive code again and again to implement the same well-known data structures and algorithms for new data types. <br><br>  At the same time, however, this model does not cope well with memory limitations, is error prone and requires a lot of ingenuity to effectively implement.  Since each object is identified only by a pointer, each object can have aliases.  Each variable can be a null pointer.  Since a pointer can indicate anything, type errors (when a pointer to an object of one type is stored in a variable that is expected to point to some other type) are ubiquitous, and object-graph languages ‚Äã‚Äãtraditionally use checks to shorten the debugging time. types at runtime. <br><br>  In this object-graph memory model, if you have several objects of the same type, each of them will be identified by a pointer, and finding a specific attribute of an object includes navigating through the object graph, starting with this pointer.  For example, if you have an Account object, then you can present it as an associative list.  Then, to find its owner (an object that can be shared with other objects of accounts), you go through the list until you find a cons, whose car will be ACCOUNT-HOLDER, and take its cdr.  Then, in order to find the middle name of the account holder, you may be looking for the attributes of the account holder in the vector, you get a pointer to the corresponding name, which can be either a string or a character, as in old Lisp, which has no lines.  Updating the second name may include changing this line, updating the vector to point to a new line, or building a new associative list with a new account holder object, depending on whether this owner object is used with other account objects, and whether it is desirable other accounts to update the middle name too. <br><br>  Garbage collection is almost a necessity in these languages.  Beginning in 1959, when McCarthy created Lisp, and until 1980, when Lieberman and Hewitt came up with the use of generations for garbage collection, programs using this memory model spent between a third and a half of their work on garbage collection.  Some computers were even specially created with several processors so that the garbage collector could be run on a separate processor. <br><br>  Object-graph languages ‚Äã‚Äãmade high demands on garbage collectors, not only because they prefer to create new objects rather than modify existing ones, but also because they usually have many pointers.  In COBOL-derived languages, such as C and Golang, it is easier for garbage collectors to work because less large memory operations are performed there;  these languages ‚Äã‚Äãtend to modify objects instead of re-allocating memory for modified versions.  And programmers, as a rule, try to use nested records where possible, rather than linking them with pointers, so pointers are found only where polymorphism is desirable, the validity of null pointers (which can be considered as a special case of polymorphism) or overlay. <br><br>  Serialization of an object graph is a bit more complicated because it may contain circular references, and also because the part you want to serialize may contain links to parts that you do not want to serialize, and you should consider both cases as specific cases.  For example, on some systems, an instance of a class contains a reference to its class, and a class contains references not only to the current versions of all methods, but also to the parent class.  And you may not want to serialize the entire bytecode of the class with each object serialization.  In addition, when you deserialize two objects that previously had common links (two accounts for the same account holder), then you probably want to keep sharing them.  In general, the specific policy on this issue may vary depending on the purpose for which you are serializing data. <br><br>  Like a memory model with nested entries, an object graph model allows you to make all attributes of a particular entity local to a specific part of your program ‚Äî you simply do not give any references to its data structure for the rest of the program ‚Äî but it does not allow you to make a particular attribute private. all entities.  However, unlike the memory model with nested records, the object graph model reduces the dependence on the memory size of any node, which opens the door to object-oriented inheritance and allows you to make attributes private, despite some serious problems. <br><br>  This model is used by the most popular programming languages ‚Äã‚Äãtoday.  Not only the current Lisps, but also Haskell, ML, Python, Ruby, PHP5, Lua, JavaScript, Erlang and Smalltalk.  They all expanded the set of object types that exist in memory outside of a simple pair;  as a rule, they include arrays of pointers and hash tables of strings, or pointers to other pointers.  Some of them also include Tagged unions and unchangeable entries.  Hash tables, in particular, offer a kind of way to add new properties of existing objects, in most cases without affecting other code that uses these objects. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/16d/f81/523/16df8152319240aab5d1519bf55b7b60.jpg"></div><br><br>  In general, in these languages ‚Äã‚Äãyou can only follow the edges of the graph in the direction that they indicate, and the edge labels must be unique within the source node (cons has only one car, not two and not ten), but not node- destination.  Ted Nelson's ZigZag data structure is a study of the situation where you require them to be unique in both source and destination.  UnQL is, in a sense, a study that completely eliminates uniqueness. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/572/511/f48/572511f486424cd8beb08606cb1a63e4.jpg"></div><br>  Java (and C #) use a slightly modified version of this memory model: in Java, for example, there are things like ‚Äúprimitive types‚Äù that are not pointers. <br><br><h2>  FORTRAN parallel arrays and memory model: memory as a group of arrays </h2><br>  Fortran was developed for the numerical simulation of physical phenomena, the so-called ‚Äúscientific calculations‚Äù, which was one of the earliest applications of computers.  At that time, scientific computers differed from "business computers" in COBOL with a number of features: they used binary numbers instead of decimals;  they had no data type byte - just a word;  they supported floating point math operations;  and they had faster computation and slower I / O. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/820/bcd/324/820bcd324137453b88f0592331ef669a.jpg"></div><br>  As a rule, such modeling implied a lot of linear algebra with large arrays of numbers that should be processed as soon as possible.  And FORTRAN was optimized just for this - for the effective use of multidimensional arrays.  In FORTRAN not only there were no recursive subroutines, pointers and records, at first there were no subroutines in it at all! <br><br>  When subroutines appeared in it, they had parameters that could be arrays.  In Algol 60, it was never really implemented.  Since arrays were the only non-primitive types, the only possible element types for arrays were primitive types, such as integers or floating-point numbers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1a7/ab3/187/1a7ab31874d94c9cbc54867988c33022.jpg"></div><br>  In the memory model of parallel arrays that has evolved in the FORTRAN environment, if you have several objects of the same type, then each of them will be identified by a numerical offset, which is valid for several arrays.  And the search for the private attribute of a particular object includes the indexing of the array for this attribute with the index of such an object.  If you move a little bit away from the 1950s and allow yourself a primitive type of symbol from which you can form arrays, sticking to parallel arrays for structuring data, you can determine the second name of the account holder from the previous example as follows: <br><br><ol><li>  IM = IMDNAM (ICCHLD (IACCTN)) <br>  IA = ISTR (IM) <br>  IE = ISTR (IM + 1) <br>  After these four array indexing operations, the account holder‚Äôs second name is in the [IA, IE) characters of the CCHARS array. </li><li>  IM = IMDNAM (IACCTN), then proceed as in the previous version, if you do not have a separate character set for the account holder attributes. </li><li>  Instead of IMDNAM, use CMDNAM, N * 12 character array, with one 12-character column for the second name of each account holder. </li></ol><br>  In this memory model, the subroutine can access any index in the array that was passed as an argument or is available to it in some other way, read or write it any number of times in a random order. <br><br>  This is exactly what the phrase ‚ÄúFORTRAN can write in any language‚Äù means: there are arrays of primitive types in almost any programming language.  Even in assembler or Forth, it is easy to make arrays.  Awk, Perl4, and Tcl also provide dictionaries that are not first-class objects, since these are not object-graph languages, although they work well instead of arrays to store object attributes, allowing you to identify objects by strings instead of integers. <br><br>  Interestingly, at the machine level, in the simple case, parallel arrays generate almost the same code as the structural elements that reference via pointers, as in the nested model.  For example, here <code>b-&gt;foo</code> , where b is a pointer to a struct with a 32-bit member foo: <br><br><pre> <code class="hljs xml">40050c: 8b 47 08 mov 0x8(%rdi),%eax<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">code</span></span></span><span class="hljs-tag">&gt;</span></span>    <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">code</span></span></span><span class="hljs-tag">&gt;</span></span>foos[b]<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">code</span></span></span><span class="hljs-tag">&gt;</span></span>,  b ‚Äî    foos,   32-  : <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">source</span></span></span><span class="hljs-tag">&gt;</span></span>400513: 8b 04 bd e0 d8 60 00 mov 0x60d8e0(,%rdi,4),%eax</code> </pre> <br>  In both cases, we add an immediate constant representing the attribute we need to a variable in the register that indicates which object we are considering.  In the second case, the difference is that we multiply the index by the size of the element, and the immediate constant is slightly larger. <br><br> ( , ,    ,           ,                 ). <br><br> <a href="http://www.the-adam.com/adam/rantrave/st02.pdf"> .  </a>         . ,      ,       ,    . <br><br>  ,     cache-friendly,          ,  ,    ,     (  ‚Äî    ,     ).  ,      ,    ,        :     sum   covariance,       . <br><br>    :            ,     . <br><br>  ,       .    ,      ,   ,        .    ,     (type error) ‚Äî       ,         ‚Äî              . (,        ).  ,        ,   ,         ,       (   ),         ,       (nested-record model). <br><br>        ,    ,          ,           ,     . <br><br> FORTRAN ‚Äî    ,        . Octave, Matlab, APL, J, K, PV-WAVE IDL, Lush, S, S-Plus  R      . Numpy, Pandas  OpenGL ‚Äî ¬´¬ª , Perl4, awk,  Tcl,   ,   -      .        ,       . Pandas, K  -  (parallel-dictionary variant)    ,         . <br><br>            :     CPU   ,  GPU  SIMT-,  CPU  SIMD-    ALU    .          ,   ¬´,    ¬ª (data-oriented design)  (  ) ¬´ ¬ª (entity systems).  ,   ¬´¬ª       . <br><br><h2> :     Lua, Erlang  Forth? </h2><br>           :  (record),    .   ,      ,   : <br><br><ul><li> Lua    (finite maps) (,    ¬´¬ª), </li><li> Erlang      ,        (  ,   (Hewitt)   (Agha)), </li><li> Forth  . </li></ul><br> Lua  Erlang   - .    Forth    . ,    ,     -    -- ,     .       --        Linda,        . <br><br>       . <br><br><h2>        </h2><br>  Unix ‚Äî     (     ).   ,    ‚Äî   (,  ,  ),   , ,  (  ). (      ,     ).  ,                 . <br><br>         ,     . MapReduce    ,       lex, ,         . <br><br>    Python,   (forward iterators) C++ STL,   (forward ranges) D,  Golang ‚Äî      ,       . <br><br>         ,    ?          (,  )   .          .     empty, get,  ``put,     ,      ,        Python  - : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(in1, in2, out)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">have1</span></span></span><span class="hljs-function"> :</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; have2 := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> !empty(in1) || !empty(in2) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> == have1 &amp;&amp; !empty(in1) { val1 := get(in1); have1 := <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> == have2 &amp;&amp; !empty(in2) { val2 := get(in2); have2 := <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> == have1 { put(out, val2); have2 := <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> == have2 || val1 &lt; val2 { put(out, val1); have1 := <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { put(out, val2); have2 := <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } }</code> </pre> <br>  ,         ,     .     ,        .       ,     .  in1, out  ..    -     ,      . (  Unix-   Unix-:    ).         ,       ,     . <br><br>     (multithreaded)     (control flow system),        (threads),   ,        (empty streams block),     .        ; ,         .            , ,        . <br><br> - (œÄ-calculus) ‚Äî ,    .  ,   (concurrent) - (channel-oriented)  Œª-.    : <br><br><blockquote>     Q    .   : <br><br><ul><li> P|Q  ,   P  Q,  ; </li><li> a(x).P  ,        ,  ,  ,    ; </li><li> ƒÅ„Äàx„Äâ.P  ,        ,   ,     -  ,    . </li><li> (ŒΩa)P ,   ‚Äî     ; </li><li>  !      ,   ; </li><li> P + Q  ,     P  Q; </li><li> 0   ,    . </li></ul></blockquote><br>   -: <br><br> <code>!incr(a, x).ƒÅ„Äàx+1„Äâ | (ŒΩa)( iÃÖnÃÖcÃÖrÃÖ„Äàa, 17„Äâ | a(y) )</code> <br> <br>    ¬´¬ª    ,      incr    ,      ,   +1     .         ,       ¬´¬ª.     17   incr,   ,        ,    y. <br><br> -, ,     ,       ,              .   ,             (labeled graphs)!      ,          . <br><br> ¬´ ¬ª,    NSA,   Apache NiFi,        Unix---. <br><br><h2>     Multics:      (string-labeled tree)  blob- </h2><br>    Unix ( Windows,  MacOS,  Multics) ‚Äî     ,     ,         shell-.         - ,      ‚Äî  ,    ¬´¬ª  -     ,  ¬´ ¬ª,   ( ).      , ¬´ ¬ª,                 ‚Äî    . <br><br>         ()       ,     !   ,  , ,       ,            .      ,    () ¬´¬ª   ¬´¬ª.    Unix     , ,     ,    ,     . <br><br>    ‚Äî      .         ,       ,   ,      ,    ,       .             ,     ,      . <br><br>         . <br><br>    ,      .   -  MUMPS,          (  ¬´¬ª  4096 ,      ¬´¬ª,   ¬´ ¬ª).   IBM IMS,       ,    ,    ¬´¬ª.      .      (Mark Lentczner)   , -  ,    Wheat.        -     PHP.  Wheat      ¬´¬ª     ¬´¬ª ( ,    ).   ¬´ ¬ª ,   .       . Wheat      ,  ,   -     . <br><br><h2>     SQL:  ‚Äî       </h2><br> ,       . <br><br> ¬´ ¬ª     ¬´¬ª  ¬´¬ª. cos ‚Äî  :   Œ∏  cos(Œ∏)   . Cos-1 ‚Äî  :  cos‚Åª¬π(0.5)  ,      ,   - .     cos     , : (0, 1), (œÄ/2, 0), (œÄ, -1), (3œÄ/2, 0)   .    ‚Äî       : (1, 0), (0, œÄ/2), (-1, œÄ), (0, 3œÄ/2)   . <br><br> , ,    ,   ,   :        n-    n.          ,    : (0, 1, 0), (œÄ/2, 0, 1), (œÄ, -1, 0)  .. <br><br>              cos,        . <br><br>    ,  , ,    permissions.sqlite   Firefox: <br><br><pre> <code class="sql hljs">sqlite&gt; .mode column sqlite&gt; .width 3 20 10 5 5 15 1 1 sqlite&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> moz_hosts <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; id host type permi expir expireTime ai <span class="hljs-comment"><span class="hljs-comment">--- -------------------- ---------- ----- ----- --------------- ‚Äî - 1 addons.mozilla.org install 1 0 0 2 getpersonas.com install 1 0 0 5 github.com sts/use 1 2 1475110629178 9 news.ycombinator.com sts/use 1 2 1475236009514 10 news.ycombinator.com sts/subd 1 2 1475236009514</span></span></code> </pre> <br>     ,           ,     id ;     host(1)  addons.mozilla.org, host(2)  getpersonas.com, type(5)  sts/use.     -. <br><br>        .    ,     host(9),  host‚Åª¬π('news.ycombinator.com'),   : <br><br><pre> <code class="sql hljs">sqlite&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> moz_hosts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> host = <span class="hljs-string"><span class="hljs-string">'news.ycombinator.com'</span></span>; id <span class="hljs-comment"><span class="hljs-comment">--- 9 10</span></span></code> </pre> <br>  ,       : <br><br><pre> <code class="sql hljs">sqlite&gt; .width 0 sqlite&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(expireTime) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> moz_hosts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> host = <span class="hljs-string"><span class="hljs-string">'news.ycombinator.com'</span></span>; min(expireTime) <span class="hljs-comment"><span class="hljs-comment">--------------- 1475236009514</span></span></code> </pre><br>   ,     SQL,      (¬´¬ª  ¬´¬ª),              ,   ,  id   .       -   .       : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> accountholder.middlename <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> accountholder, <span class="hljs-keyword"><span class="hljs-keyword">account</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> accountholder.id = account.accountholderid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> account.id = <span class="hljs-number"><span class="hljs-number">3201</span></span></code> </pre> <br>     ,     ,      ,   - . <br><br> SQL ‚Äî      ,   . <a href="http://blog.coelho.net/database/2013/08/17/turing-sql-1.html">     </a>     . <br><br>            Lisp, FORTRAN  C,  SQL      ,   .    ,      .     SQL-,         ,    ,       ,     (,   -  PL/SQL). <br><br>           .              ,              ,       . <br><br>  SQL   -  :       ,         (        ,          ,       );            (  ,       ,   COBOL).       . <br><br>     SQL,       ,      : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; moz_hosts_len; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == strcmp(moz_hosts_host[i], <span class="hljs-string"><span class="hljs-string">"news.ycombinator.com"</span></span>)) { results[results_len++] = moz_hosts_id[i]; } }</code> </pre> <br>   ,  SQL    :   /         (unmanageable) .   SQL: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> accountholder.middlename <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> accountholder, <span class="hljs-keyword"><span class="hljs-keyword">account</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> accountholder.id = account.accountholderid</code> </pre> <br>    -       : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *fksort = iota(account_len); sort_by_int_column(account_accountholderid, fksort, account_len); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *pksort = iota(accountholder_len); sort_by_int_column(accountholder_id, pksort, accountholder_len); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>, k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; account_len &amp;&amp; j &lt; accountholder_len) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fk = account_accountholderid[fksort[i]]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pk = accountholder_id[pksort[j]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fk == pk) { result_id[k] = fk; result_middle_name[k] = accountholder_middlename[pksort[j]]; k++; i++; <span class="hljs-comment"><span class="hljs-comment">// Supposing accountholder_id is unique. } else if (fk &lt; pk) { i++; } else { j++; } } free(fksort); free(pksort);</span></span></code> </pre> <br>  iota  : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *iota(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *results = calloc(size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*results)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!results) abort(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) results[i] = i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; }</code> </pre> <br>   sort_by_int_column   : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_by_int_column</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *values, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *indices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indices_len</span></span></span><span class="hljs-function">)</span></span> { qsort_r(indices, indices_len, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*indices), indirect_int_comparator, values); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indirect_int_comparator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *values = arg; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values[*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)a] ‚Äî values[*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)b]; }</code> </pre> <br>  SQL-          ,          ,       ,   . ,   . <br><br>  ,  SQL ‚Äî   ,     ,    ,     . ,    ,   ‚Äî   , , ,    ,    .         ,    ,     . <br><br>      Prolog  miniKANREN,           .    miniKANREN , ,             . <br><br>          (constraint programming),       (¬´¬ª,    ),       .      , ,  ,           SAT  SMT. </div><p>Source: <a href="https://habr.com/ru/post/323624/">https://habr.com/ru/post/323624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323614/index.html">Pygest # 5. Releases, articles, interesting projects from the world of Python [February 28, 2017 - March 13, 2017]</a></li>
<li><a href="../323616/index.html">A preliminary DUMP program is ready. Speakers from Dropbox, JetBrains, Mozilla, Mail.Ru, Yandex, Rambler & Co</a></li>
<li><a href="../323618/index.html">PostgreSQL data change audit</a></li>
<li><a href="../323620/index.html">Where the games go: the problem of preserving old video games. Part 2</a></li>
<li><a href="../323622/index.html">Developing the mechanics of the game Bounce from Nokia JavaScript</a></li>
<li><a href="../323626/index.html">Intel Software Guard Extensions Extensions Tutorial. Part 6, two branches of code</a></li>
<li><a href="../323628/index.html">Testing Conference Heisenbag: Video recordings of reports-2016 and work on the bugs in 2017</a></li>
<li><a href="../323630/index.html">Videos: February TechLeads Mitap at Badoo</a></li>
<li><a href="../323632/index.html">How to optimize a site on Magento</a></li>
<li><a href="../323634/index.html">Stacker: what's new?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>