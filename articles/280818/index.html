<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote the library under IEC 870-5-104 on Arduino using Wireshark</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I would like to talk about my acquaintance with the IEC 870-5-104 data transfer channel from a controlled (slave) device by writing a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote the library under IEC 870-5-104 on Arduino using Wireshark</h1><div class="post__text post__text-html js-mediator-article">  In this article, I would like to talk about my acquaintance with the IEC 870-5-104 data transfer channel from a controlled (slave) device by writing a simple Arduino library. <br><br><h2>  What is IEC 870-5-104 and where does it apply? </h2><br>  IEC 60870-5-104 is a telemechanical protocol designed to transmit TM signals to an automated process management system that regulates the use of network access using the TCP / IP protocol.  It is most often used in power engineering for information exchange between power systems, as well as for receiving data from measuring transducers (voltmeters, electricity meters, etc.). <br><br>  Stack Protocol IEC 670-5-104: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/55d/e9f/d32/55de9fd3250e425eb990bd24f0a95c61.jpg"><br><a name="habracut"></a><br><h2>  Materials used </h2><br><ul><li>  Arduino UNO board; </li><li>  Ethernet shield (HR911105a); </li><li>  ABB MicroScada will play the role of IEC 60870-5-104; </li><li>  Wireshark to analyze traffic. </li></ul><br><br><h2>  Brief description of the stages of work </h2><br><ol><li>  Installing TCP / IP connection on port 2404; </li><li>  Confirmation of the request for data transfer (STARTDT act / con); </li><li>  Request for a general station survey; </li><li>  Preparation and transmission of data to the controlling (master) station; </li><li>  Testing procedures. </li></ol><br><h2>  Training </h2><br><ul><li>  Arduino board connected to PC; </li><li>  Configured as appropriate network interface; </li><li>  A master station was set up (104 lines added and a controlled (slave) device added). </li></ul><br><img src="https://habrastorage.org/files/7c7/57a/7e9/7c757a7e90224906861affb7729a845b.jpg"><br><br><h2>  Terms and abbreviations </h2><br>  <b>APCI</b> - Application Level Control Information can be used as a separate control frame (U frame or S frame). <br>  <b>ASDU</b> - Application-level data blocks, consists of a data block identifier and one or more information objects, each of which includes one or more homogeneous information elements (or combinations of information elements). <br>  <b>APDU</b> - Application layer protocol data unit. <br>  <b>TC</b> - TV alarm. <br>  <b>TI</b> - telemetry. <br>  <b>TU</b> - remote control. <br><br><h2>  1. Install TCP / IP connection port 2404 </h2><br>  The master station initiates the establishment of a TCP connection by sending a TCP packet with a flag (SYS).  A connection is considered established if, during the monitoring time (t0), the monitored station (slave) has issued a ‚Äúactive open‚Äù (SYS ACK) to its TCP / IP level.  The watchdog time t0 is called ‚ÄúConnection setup timeout‚Äù.  The timer t0 determines when the opening is canceled and does not determine the beginning of a new connection attempt. <br><br><img src="https://habrastorage.org/files/eb2/65a/2e6/eb265a2e6766475083cce7e729f8b2e9.jpg"><br><br>  The interaction with the transport layer is performed by the standard library for Arduino Ethernet.h boards.  That is, the first step is to establish a TCP / IP connection between the monitored and the monitoring stations.  To do this, you need to initialize the device in the Arduino sketch and create a server that will wait for incoming connections through the specified port. <br><br><div class="spoiler">  <b class="spoiler_title">Sketch</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Ethernet.h&gt; byte mac[] = {0x90, 0xA2, 0xDA, 0x0E, 0x94, 0xB7 };//  IPAddress ip(172, 16, 7, 1);// ip    IPAddress gateway(172, 16,7, 0);// IPAddress subnet(255, 255, 0, 0);// EthernetClient client; EthernetServer iec104Server(2404);//   670-5-104- - 2404 void setup() { Ethernet.begin(mac, ip, gateway, subnet); //  Ethernet- } void loop() { client = iec104Server.available();//  }</span></span></span></span></code> </pre> <br></div></div><br>  If you download this sketch, the following will happen: <br><br><img src="https://habrastorage.org/files/af2/2bb/562/af22bb562a044e40953690fa05ff1e6c.jpg"><br><br>  Establishing a connection, then comes the STARTDT act package unknown for Arduino and after a certain time the connection is broken.  Next, you need to understand what a STARTDT act. <br><h2>  2. Confirmation of the request for data transfer (STARTDT act / con) </h2><br>  In IEC 670-5-104, there are 3 types of format for transmission: <br><br><ul><li>  I-format for telemetry data transmission; </li><li>  S-format for the transfer of receipts; </li><li>  U-format for the transmission of the messages of communication and testing of the communication channel. </li></ul><br>  After a successful ‚Äútriple handshake‚Äù, the controlling (master) station sends an APDU STARTDT (data transfer start).  STARTDT initiates for the controlled (Slave) station the resolution of the transmission of ASDUs (frames I) in the direction of the controlling (master), to continue the work, you must confirm STARTDT, if the controlled (Slave) station is ready to transmit data blocks.  If the monitored (slave) station does not confirm the execution of STARTDT, then the controlling (master) station causes the mandatory closure of the IP connection. <br><br><div class="spoiler">  <b class="spoiler_title">Picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/bdd/ce9/156/bddce915668f4fa4bc23bfa2ac96da1d.jpg"><br></div></div><br>  Thus, further it is necessary to count the bytes received from the controlling (master) station and disassemble them. <br><br><div class="spoiler">  <b class="spoiler_title">Sketch</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> iec104ReciveArray[<span class="hljs-number"><span class="hljs-number">128</span></span>];<span class="hljs-comment"><span class="hljs-comment">//   EthernetClient client = iec104Server.available(); if(client.available()) { delay(100); int i = 0; while(client.available()) { iec104ReciveArray[i] = client.read();//     i++; }</span></span></code> </pre><br></div></div><br>  After reading the data you need to parse them and form the answer. <br><br><div class="spoiler">  <b class="spoiler_title">Wireshark</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d20/e60/ed1/d20e60ed10884926b65d367d685beab7.jpg"><br></div></div><br>  Here's what the package containing the STARTDT block in the Wireshark program looks like, the APDU is a U-format block that consists only of APCI. <br>  <b>APCI</b> - <i>Application Level Control Information can be used as a separate control frame (U frame or S frame).</i> <br><br><img src="https://habrastorage.org/files/fcd/112/eb4/fcd112eb423040808580405d389c50e8.jpg"><br><br>  In short, we can say that the APCI block determines the type of APDU block and its length.  <b>APCI</b> consists of the following six bytes: <br><br>  <b>1.</b> Sign of initialization of the variable-length APDU block, starting with START2 68h; <br>  <b>2. The</b> length of the APDU, in this example is four bytes; <br>  <b>3.</b> The control byte in which the type of APDU is determined, in this example, a value of seven is written, which means a request for data transfer; <br>  <b>4,5,6</b> Not used. <br><br><img src="https://habrastorage.org/files/e12/122/9e6/e121229e6ab34b06ab52daa36bc64eec.jpg"><br><br>  Based on the above, before answering, it would not hurt to determine what type of APDU the monitoring station sent us.  Knowing that the type of APDU is written in the third order of reading the APCI block byte, I will save it in an integer variable. <br>  <i>Note: If an ‚ÄúI‚Äù format packet is received, then 3 bytes in APCI will also contain the low word value of the received packets counter,</i> <br><img src="https://habrastorage.org/files/7d6/328/0b9/7d63280b9eab47e5b011477dc3f1eaa9.jpg"><br>  <i>therefore, we had to slightly complicate the construction of the definition of the type APDU.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Sketch</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ASDU=iec104ReciveArray[<span class="hljs-number"><span class="hljs-number">6</span></span>];<span class="hljs-comment"><span class="hljs-comment">// ASDU? switch (ASDU) { case 100://  TypeQuerry=iec104ReciveArray[2]-word(iec104ReciveArray[3],iec104ReciveArray[2]);// rxcnt+=2;//    break; case 0: TypeQuerry=iec104ReciveArray[2]; // break; default : TypeQuerry=iec104ReciveArray[2];// break; }</span></span></code> </pre><br></div></div><br><br>  It can be seen from the figure above that the type of APDU corresponding to the value 7 is STARTDT act, respectively, it is necessary to respond with the same package structure, only the type value should have the value 11 (0b), which corresponds to STARTDT con. <br><br><div class="spoiler">  <b class="spoiler_title">Sketch</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Ethernet.h&gt; byte mac[] = {0x90, 0xA2, 0xDA, 0x0E, 0x94, 0xB7 }; IPAddress ip(172, 16, 7, 1); IPAddress gateway(172, 16,7, 0); IPAddress subnet(255, 255, 0, 0); EthernetClient client; EthernetServer iec104Server(2404); int TypeQuerry, MessageLength;//  APDU    uint8_t iec104ReciveArray[128];//  APDU void setup() { Ethernet.begin(mac, ip, gateway, subnet); } void loop() { client = iec104Server.available(); if(client.available())//  { delay(100); int i = 0; while(client.available())//  { iec104ReciveArray[i] = client.read();//     i++; } TypeQuerry= iec104ReciveArray[2];//  APDU switch(TypeQuerry) { case 07://    STARTDT iec104ReciveArray[0]=iec104ReciveArray[0];// START2 = 68h; iec104ReciveArray[1]=iec104ReciveArray[1];// APDU iec104ReciveArray[2] = iec104ReciveArray[2]+4; // APDU iec104ReciveArray[3]=0; iec104ReciveArray[4]=0; iec104ReciveArray[5]=0; MessageLength = iec104ReciveArray[1]+2;//  + 2  Start and Lenght APCI delay(100); client.write(iec104ReciveArray, MessageLength);//  break; } } }</span></span></span></span></code> </pre><br></div></div><br>  After updating the sketch, we observe the following order of exchange: <br><br><img src="https://habrastorage.org/files/66c/6c7/50a/66c6c750ad3e4054a379b78aba695470.jpg"><br><br>  Establishing a connection, a request for data transfer, confirmation of the request and another new yet unknown APDU of format I type 1 C_IC_NA Act. <br><br><h2>  3. Request for a general station survey </h2><br><blockquote>  The C_IC ACT polling command requests a full volume or a specified subset of polled information at a CP.  A subset (group) is selected using the QOI polling descriptor. <br>  The station polling team requires the monitored stations to transmit the current status of their information, usually transmitted sporadically (transmission cause = 3), to the monitoring station with transmission reasons from &lt;20&gt; to &lt;36&gt;.  Station polling is used to synchronize information about the process at a monitoring station and monitored stations.  It is also used to update the information at the monitoring station after the initialization procedure or after the monitoring station detects a loss of the channel (unsuccessful repetition of the data link layer request) and then recovers it.  The response to the station survey should include process information objects that are stored at the monitored station.  In response to polling the station, these information objects are transmitted with type identifiers &lt;1&gt;, &lt;3&gt;, &lt;5&gt;, &lt;7&gt;, &lt;9&gt;, &lt;11&gt;, &lt;13&gt;, &lt;20&gt; or &lt;21&gt; and can also transferred to other ASDUs with type identifiers from &lt;1&gt; to &lt;14&gt;, &lt;20&gt;, &lt;21&gt;, from &lt;30&gt; to &lt;36&gt; and with transmission reasons &lt;1&gt; - periodically / cyclically, &lt;2&gt; - background scanning or &lt;3&gt; - sporadically. </blockquote><br><div class="spoiler">  <b class="spoiler_title">Picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/0b1/e4b/5e6/0b1e4b5e647d473a9e7079bbdfb1fdeb.jpg"><br></div></div><br><br>  The APDU &lt;100&gt; C_IC_NA_1, in addition to the APCI block, also has an ASDU (Application Level Data Block), which together form the APDU Protocol Data Block of the Application Layer. <br><br><img src="https://habrastorage.org/files/13e/bb4/32d/13ebb432d1cc44cc9bdd5eb4b30677c6.jpg"><br><br>  Consider in more detail the received APDU. <br><br>  <b>APCI:</b> <br><br><ul><li>  In the first byte, type 0 indicates that this is a polling command; </li><li>  In the second, the length of the APDU is 14 bytes; </li></ul><br>  <b>ASDU:</b> <br><br><ul><li>  The first byte in the ASDU block determines the type of information object, in this case &lt;100&gt; C_IC_NA_1 (general station polling); </li><li>  The second data block structure; </li><li>  The third reason for the transfer (CauseTx), a value of six means an activation request; </li><li>  The fourth general address of the station; </li><li>  The fifth address of the controlled (slave) station; </li><li>  From the sixth to the eighth address of the information object is zero; </li><li>  The ninth information byte - QOI is a request handle that has the following values: </li></ul><br>  In response to &lt;100&gt; C_IC_NA_1, it is necessary to respond with a confirmation of the request, transfer the process information objects stored at the monitored station and complete the activation. <br>  To send an acknowledgment, it is necessary in ASDU &lt;100&gt; C_IC_NA_1 to write to byte a value indicating the cause of transmission (CauseTX) equal to 7, to send the activation end to send the reason of transmission (CauseTX) equal to 10 to send the activation completion request. <br><br><div class="spoiler">  <b class="spoiler_title">Sketch</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-comment"><span class="hljs-comment">//  txcnt=txcnt+02; //   iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=iec104ReciveArray[1]; iec104ReciveArray[2]=lowByte(txcnt);//TX L iec104ReciveArray[3]=highByte(txcnt);//TX H iec104ReciveArray[4]=lowByte(rxcnt);//RX L iec104ReciveArray[5]=highByte(rxcnt);//RX H iec104ReciveArray[6]=100;//  iec104ReciveArray[7]=01; iec104ReciveArray[8]=7;//cause Actcon iec104ReciveArray[9]=00;//OA iec104ReciveArray[10]=01;//Addr iec104ReciveArray[11]=00;//Addr iec104ReciveArray[12]=00;//IOA iec104ReciveArray[13]=00;//IOA iec104ReciveArray[14]=00;//IOA iec104ReciveArray[15]=20;//IOA, QOI MessageLength = iec104ReciveArray[1]+2; delay(100); client.write(iec104ReciveArray, MessageLength); txcnt=txcnt+2;//    //          iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=14;// APDU=APCI(4)+ ASDU(10) iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=1;//type 1 iec104ReciveArray[7]=01;//sq iec104ReciveArray[8]=20;//Cause Inrogen iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[0];//IOA iec104ReciveArray[13]=iecData[1];//IOA iec104ReciveArray[14]=0;//IOA iec104ReciveArray[15]=iecData[2];//value [DATA 1] MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); txcnt=txcnt+2; iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=14; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=1;//type 1 bool iec104ReciveArray[7]=01; iec104ReciveArray[8]=20;//Cause Inrogen iec104ReciveArray[9]=00; iec104ReciveArray[10]=01; iec104ReciveArray[11]=00; iec104ReciveArray[12]=iecData[3]; iec104ReciveArray[13]=iecData[4]; iec104ReciveArray[14]=0; iec104ReciveArray[15]=iecData[5]; MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); delay(5); txcnt=txcnt+2; iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=22; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=11;//type 11 int iec104ReciveArray[7]=02;//sq iec104ReciveArray[8]=20;//Cause Inrogen iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[6];//IOA iec104ReciveArray[13]=iecData[7];//IOA iec104ReciveArray[14]=0;//IOA iec104ReciveArray[15]=iecData[8];//value [DATA 1] iec104ReciveArray[16]=iecData[9];//value [DATA 1] iec104ReciveArray[17]=iecData[10];//QDS iec104ReciveArray[18]=iecData[11];//IOA iec104ReciveArray[19]=iecData[12];//OA iec104ReciveArray[20]=0;//IOA iec104ReciveArray[21]=iecData[13];//value [DATA 2] iec104ReciveArray[22]=iecData[14];//value [DATA 2] iec104ReciveArray[23]=iecData[15];//IOA QDS MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); delay(5); txcnt=txcnt+2; iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=26; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=13;//type 13 Float iec104ReciveArray[7]=02;//sq iec104ReciveArray[8]=20;//Cause Inrogen iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[16];//IOA iec104ReciveArray[13]=iecData[17];//IOA iec104ReciveArray[14]=0; iec104ReciveArray[15]=iecData[18];//value [DATA 1] iec104ReciveArray[16]=iecData[19];//value [DATA 1] iec104ReciveArray[17]=iecData[20];//value [DATA 1] iec104ReciveArray[18]=iecData[21];//value [DATA 1] iec104ReciveArray[19]=iecData[22];//IOA QDS iec104ReciveArray[20]=iecData[23];//IOA iec104ReciveArray[21]=iecData[24];//IOA iec104ReciveArray[22]=0;//IOA iec104ReciveArray[23]=iecData[25];//value [DATA 2] iec104ReciveArray[24]=iecData[26];//value [DATA 2] iec104ReciveArray[25]=iecData[27];//value [DATA 2] iec104ReciveArray[26]=iecData[28];//value [DATA 2] iec104ReciveArray[27]=iecData[29];//IOA QDS MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); txcnt=txcnt+2; //   iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=iec104ReciveArray[1]; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=100;//type iec104ReciveArray[7]=01;//sq iec104ReciveArray[8]=10;//cause AckTerm iec104ReciveArray[9]=00; iec104ReciveArray[10]=01; iec104ReciveArray[11]=00; iec104ReciveArray[12]=00; iec104ReciveArray[13]=00; iec104ReciveArray[14]=00; iec104ReciveArray[15]=20; MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); iec104ReciveArray[6]=00;//       break;</span></span></code> </pre><br></div></div><br>  After updating the sketch, we observe the following order of exchange: <br><img src="https://habrastorage.org/files/559/b87/741/559b877419ac43d8b5e87f58cfd8c2ec.jpg"><br><br>  Establish a connection, request for data transmission, confirmation, request for a general interrogation of a station from a monitoring station, completion of initialization, request for a general interrogation of a station to the direction of a controlled station, confirmation of a general interrogation, forwarding the values ‚Äã‚Äãof all available signals at the monitoring station, completion of a general interrogation and unknown APCI format S. <br>  The station inquiry request is issued in the direction of the monitored station: <br>  - if ‚ÄúEND OF INITIALIZATION‚Äù is received from the controlled station or <br>  - if the central station detects a loss of the channel (unsuccessful repeated request of the data link layer) and its subsequent recovery. <br><br><h2>  4. Preparation and transmission of data </h2><br>  An APDU S format block consisting only of APCI is intended to confirm the received APDU I format.  For S-format 7, the upper bits of the service field of byte 1 and byte 2 are not involved, and byte 3 (7 high bits) and byte 4 determine the current number of the received parcel. <br><br><img src="https://habrastorage.org/files/1df/c5e/662/1dfc5e66294742cbbaa8017bb456c3d5.jpg"><br><br>  In this case, the S block indicates that the controlling (master) station is ready to receive data within a certain time, not exceeding, the timeout t3 determined on the side of the controlling (master) station.  That is, the master station tells us "I am ready to receive data!".  Next, you need to take care of what data to transfer and where to get it. <br><br>  What can be transmitted?  There are several types of information defined in IEC 870-5- 104: <br><br><ul><li>  Control; </li><li>  The manager; </li><li>  Options; </li><li>  File transfer </li></ul><br><div class="spoiler">  <b class="spoiler_title">Picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f1b/afa/aae/f1bafaaaee9946c2b65bad349c1e02b5.jpg"><br></div></div><br>  In this example, the transfer of control information is considered using examples 1, 11 and 13 of functions (single-element, measurement scalable, measurement short format with a floating point).  Data is generated randomly.  It is also necessary to take into account that each transmitted signal has a quality byte. <br><br><img src="https://habrastorage.org/files/283/22d/bcb/28322dbcbf5e4355a963284e40132559.jpg"><br><br>  A simple algorithm for determining the quality of the signal: <br><br><ul><li>  If a substitution of an active signal is used, then the BL (blocking) and SB (substitution) flags are set; </li><li>  If the signal value did not change during the control period of time, then the NT flag is set (not relevant); </li><li>  If there is a sign of inoperability of a node or device of a lower level (sensor or other), then flag IV is set (not a valid value). </li></ul><br><div class="spoiler">  <b class="spoiler_title">Sketch</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetQDS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currvalue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zam)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   { if (zam==0)//? { if (currvalue==previusValue[i])//  ? { previusValue[i]=currvalue; counter[i]+=1; if (counter[i]&gt;=1000) { qds[i]=64;// NT counter[i]=0; } } else { qds[i]=0; counter[i]=0; previusValue[i]=currvalue; } } else { qds[i]=48;// SB, BL } }</span></span></span></span></code> </pre><br></div></div><br>  It is also necessary to take into account that for each signal there is a unique identifier IOA, in the power industry it is customary to allocate these addresses as follows: <br><br><ul><li>  TC-starting from 4096; </li><li>  TI-starting from 8192; </li><li>  TU-starting from 20480. </li></ul><br>  To transfer the values ‚Äã‚Äãof signals to an array for sending, use the EEPROM library: <br><br><div class="spoiler">  <b class="spoiler_title">Sketch</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EEPROM_float_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IOA,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subs)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    EEPROM,  ,  ,    ,  { SetQDS(val,number, subs);//   byte *x = (byte *)&amp;val;//float --&gt;byte byte *xxx = (byte *)&amp;IOA;//  IOA for(int jj = 0; jj &lt;2; jj++) { EEPROM.write(addr,xxx[jj]);//  EEPROM     2  addr+=1; } for(byte i = 0; i &lt; 4; i++) //  float  4  { EEPROM.write(addr, x[i]); //  float  4  addr+=1; } EEPROM.write(addr, qds[number]);//     if (addr == EEPROM.length()) { addr = 0; } }</span></span></span></span></code> </pre><br></div></div><br>  And so having received the APDU confirmation S or I format from the monitoring station, you can begin to transmit the available data, not forgetting to increase the number of the transmitted frame. <br><img src="https://habrastorage.org/files/245/ac2/26a/245ac226a2be4241a6ebe70aed7645ae.jpg"><br><br><div class="spoiler">  <b class="spoiler_title">Sketch</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;eeprom.h&gt; #include &lt;Ethernet.h&gt; #include &lt;eeprom.h&gt; byte mac[] = {0x90, 0xA2, 0xDA, 0x0E, 0x94, 0xB7 }; IPAddress ip(172, 16, 7, 1); IPAddress gateway(172, 16,7, 0); IPAddress subnet(255, 255, 0, 0); EthernetClient client; EthernetServer iec104Server(2404); int TypeQuerry, MessageLength; uint8_t iec104ReciveArray[128]; int counter[6];//   int qds[6];//      int previusValue[6];//     NT word iecData[256];//     int ASDU;//     int txcnt, rxcnt;//     void setup() { //  2404  Ethernet.begin(mac, ip, gateway, subnet); Serial.begin(9600); } void EEPROM_float_write(int addr, float val,int IOA,int number,bool zam) //      Float  13 { SetQDS(val,number,zam);//  byte *x = (byte *)&amp;val; byte *xxx = (byte *)&amp;IOA; for(int jj = 0; jj &lt;2; jj++)//  IOA  2  { EEPROM.write(addr,xxx[jj]); addr+=1; } for(byte i = 0; i &lt; 4; i++)//  float  4  { EEPROM.write(addr, x[i]); addr+=1; } EEPROM.write(addr, qds[number]); if (addr == EEPROM.length()) { addr = 0; } } void EEPROM_byte_write(int addr, bool val,int IOA,int number,bool zam) //      Bool  1 { SetQDS(val,number,zam);//  byte c=val+qds[number]; byte *x = (byte *)&amp;c; byte *xxxx = (byte *)&amp;IOA; for(int jj = 0; jj &lt;2; jj++) //  IOA  2  { EEPROM.write(addr,xxxx[jj]); addr+=1; } for(byte i = 0; i &lt; 1; i++) //  bool +    1  { EEPROM.write(addr, x[i]); } if (addr == EEPROM.length()) { addr = 0; } } void EEPROM_int_write(int addr, int val, int IOA,int number,bool zam) //      Int  11 { SetQDS(val,number,zam); //  byte *x = (byte *)&amp;val; byte *xx = (byte *)&amp;IOA; for(int jj = 0; jj &lt;2; jj++)//  IOA  2  { EEPROM.write(addr,xx[jj]); addr+=1; } for(byte i = 0; i &lt; 2; i++)//  int  2 a { EEPROM.write(addr, x[i]); addr+=1; } EEPROM.write(addr, qds[number]); if (addr == EEPROM.length()) { addr = 0; } } //   void SetQDS(int currvalue, int i,bool zam)// ,    ,  { if (zam==0)//? { if (currvalue==previusValue[i])//  ? { previusValue[i]=currvalue; counter[i]+=1; if (counter[i]&gt;=1000) { qds[i]=64;//  NT counter[i]=0; } } else { qds[i]=0; counter[i]=0; previusValue[i]=currvalue; } } else { qds[i]=48;//     } } void loop() { //   1,11,13  // : (  EEPROM,  , IOA ,  ) EEPROM_byte_write(0,0,4096,0,0); EEPROM_byte_write(3,random(0, 2),4097,1,1); EEPROM_int_write(6, 67,8192,2,1); EEPROM_int_write(11, random(10, 20),8193,3,0); EEPROM_float_write(16, random(-1000, 2000),8194,4,1); EEPROM_float_write(23, 78.66f,8195,5,1); client = iec104Server.available(); if(client.available()) { delay(100); int i = 0; while(client.available()) { iec104ReciveArray[i] = client.read();//     i++; } ASDU=iec104ReciveArray[6];// ASDU? switch (ASDU) { case 100://  TypeQuerry=iec104ReciveArray[2]-word(iec104ReciveArray[3],iec104ReciveArray[2]); rxcnt+=2;//    break; case 0: TypeQuerry=iec104ReciveArray[2];//   break; default : TypeQuerry=iec104ReciveArray[2]; break; } for(byte z = 0; z &lt;64; z++) //   { iecData[z]= EEPROM.read(z); } //  APDU switch(TypeQuerry) { case 07://APDU STARTDT rxcnt=0; txcnt=0; iec104ReciveArray[0]=iec104ReciveArray[0];//  ,   START2 = 68h; iec104ReciveArray[1]=iec104ReciveArray[1];// APDU iec104ReciveArray[2]=11;//STARTDT con iec104ReciveArray[3]=0; iec104ReciveArray[4]=0; iec104ReciveArray[5]=0; MessageLength = iec104ReciveArray[1]+2;//  client.write(iec104ReciveArray, MessageLength);//  // iec104ReciveArray[0]=iec104ReciveArray[0];//  ,   START2 = 68h; iec104ReciveArray[1]=14;// APDU iec104ReciveArray[2]=0;//, TX L iec104ReciveArray[3]=0;//TX H iec104ReciveArray[4]=0;//RX L iec104ReciveArray[5]=0;//RX H iec104ReciveArray[6]=70;//type End of Init iec104ReciveArray[7]=01;//sq iec104ReciveArray[8]=04;//cause Init iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=00;//IOA iec104ReciveArray[13]=00;//IOA iec104ReciveArray[14]=00;//IOA iec104ReciveArray[15]=129;//IOA, COI MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); //      iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=14;// APDU iec104ReciveArray[2]=2;//TX L iec104ReciveArray[3]=0;//TX H iec104ReciveArray[4]=0;//RX L iec104ReciveArray[5]=0;//RX H iec104ReciveArray[6]=100;//   iec104ReciveArray[7]=01; iec104ReciveArray[8]=6;//cause Act iec104ReciveArray[9]=00; iec104ReciveArray[10]=01; iec104ReciveArray[11]=00; iec104ReciveArray[12]=00; iec104ReciveArray[13]=00; iec104ReciveArray[14]=00; iec104ReciveArray[15]=20;//IOA, QOI  MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); txcnt=txcnt+02; break; case 00://  txcnt=txcnt+02; //   iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=iec104ReciveArray[1]; iec104ReciveArray[2]=lowByte(txcnt);//TX L iec104ReciveArray[3]=highByte(txcnt);//TX H iec104ReciveArray[4]=lowByte(rxcnt);//RX L iec104ReciveArray[5]=highByte(rxcnt);//RX H iec104ReciveArray[6]=100;//  iec104ReciveArray[7]=01; iec104ReciveArray[8]=7;//cause Actcon iec104ReciveArray[9]=00;//OA iec104ReciveArray[10]=01;//Addr iec104ReciveArray[11]=00;//Addr iec104ReciveArray[12]=00;//IOA iec104ReciveArray[13]=00;//IOA iec104ReciveArray[14]=00;//IOA iec104ReciveArray[15]=20;//IOA, QOI MessageLength = iec104ReciveArray[1]+2; delay(100); client.write(iec104ReciveArray, MessageLength); txcnt=txcnt+2;//    //          iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=14;// APDU=APCI(4)+ ASDU(10) iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=1;//type 1 iec104ReciveArray[7]=01;//sq iec104ReciveArray[8]=20;//Inrogen iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[0];//IOA iec104ReciveArray[13]=iecData[1];//IOA iec104ReciveArray[14]=0;//IOA iec104ReciveArray[15]=iecData[2];//value [DATA 1] MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); txcnt=txcnt+2; iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=14; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=1; iec104ReciveArray[7]=01; iec104ReciveArray[8]=20; iec104ReciveArray[9]=00; iec104ReciveArray[10]=01; iec104ReciveArray[11]=00; iec104ReciveArray[12]=iecData[3]; iec104ReciveArray[13]=iecData[4]; iec104ReciveArray[14]=0; iec104ReciveArray[15]=iecData[5]; MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); delay(5); txcnt=txcnt+2; iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=22; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=11;//type 11 iec104ReciveArray[7]=02;//sq iec104ReciveArray[8]=20;//cause iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[6];//IOA iec104ReciveArray[13]=iecData[7];//IOA iec104ReciveArray[14]=0;//IOA iec104ReciveArray[15]=iecData[8];//value [DATA 1] iec104ReciveArray[16]=iecData[9];//value [DATA 1] iec104ReciveArray[17]=iecData[10];//QDS iec104ReciveArray[18]=iecData[11];//IOA iec104ReciveArray[19]=iecData[12];//OA iec104ReciveArray[20]=0;//IOA iec104ReciveArray[21]=iecData[13];//value [DATA 2] iec104ReciveArray[22]=iecData[14];//value [DATA 2] iec104ReciveArray[23]=iecData[15];//IOA QDS MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); delay(5); txcnt=txcnt+2; iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=26; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=13;//type 13 iec104ReciveArray[7]=02;//sq iec104ReciveArray[8]=20;//cause iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[16];//IOA iec104ReciveArray[13]=iecData[17];//IOA iec104ReciveArray[14]=0; iec104ReciveArray[15]=iecData[18];//value [DATA 1] iec104ReciveArray[16]=iecData[19];//value [DATA 1] iec104ReciveArray[17]=iecData[20];//value [DATA 1] iec104ReciveArray[18]=iecData[21];//value [DATA 1] iec104ReciveArray[19]=iecData[22];//IOA QDS iec104ReciveArray[20]=iecData[23];//IOA iec104ReciveArray[21]=iecData[24];//IOA iec104ReciveArray[22]=0;//IOA iec104ReciveArray[23]=iecData[25];//value [DATA 2] iec104ReciveArray[24]=iecData[26];//value [DATA 2] iec104ReciveArray[25]=iecData[27];//value [DATA 2] iec104ReciveArray[26]=iecData[28];//value [DATA 2] iec104ReciveArray[27]=iecData[29];//IOA QDS MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); txcnt=txcnt+2; //   iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=iec104ReciveArray[1]; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=100;//type iec104ReciveArray[7]=01;//sq iec104ReciveArray[8]=10;//cause AckTerm iec104ReciveArray[9]=00; iec104ReciveArray[10]=01; iec104ReciveArray[11]=00; iec104ReciveArray[12]=00; iec104ReciveArray[13]=00; iec104ReciveArray[14]=00; iec104ReciveArray[15]=20; MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); iec104ReciveArray[6]=00;//       break; //APDU S case 01: txcnt=word(iec104ReciveArray[5],iec104ReciveArray[4]); iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=14; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=1;//type 1 iec104ReciveArray[7]=01;//sq iec104ReciveArray[8]=01;//cause Cycl iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[0];//IOA iec104ReciveArray[13]=iecData[1];//IOA iec104ReciveArray[14]=0;//IOA iec104ReciveArray[15]=iecData[2];//value [DATA 1] MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); delay(5); txcnt=txcnt+2; iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=14; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=1;//type 1 Bool iec104ReciveArray[7]=01;//sq iec104ReciveArray[8]=01;//cause Cycl iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[3];//IOA iec104ReciveArray[13]=iecData[4];//IOA iec104ReciveArray[14]=0;//IOA iec104ReciveArray[15]=iecData[5];//value [DATA 1] MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); delay(5); txcnt=txcnt+2; iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=22; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=11;//type 11 Int iec104ReciveArray[7]=02;//sq iec104ReciveArray[8]=01;//cause Cycl iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[6];//IOA iec104ReciveArray[13]=iecData[7];//IOA iec104ReciveArray[14]=0;//IOA iec104ReciveArray[15]=iecData[8];//value [DATA 1] iec104ReciveArray[16]=iecData[9];//value [DATA 1] iec104ReciveArray[17]=iecData[10];//QDS iec104ReciveArray[18]=iecData[11];//IOA iec104ReciveArray[19]=iecData[12];//OA iec104ReciveArray[20]=0;//IOA iec104ReciveArray[21]=iecData[13];//value [DATA 2] iec104ReciveArray[22]=iecData[14];//value [DATA 2] iec104ReciveArray[23]=iecData[15];//IOA QDS MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); delay(5); txcnt=txcnt+2; iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=26; iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=13;//type 13 Float iec104ReciveArray[7]=02;//sq iec104ReciveArray[8]=01;//cause Cycl iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[16];//IOA iec104ReciveArray[13]=iecData[17];//IOA iec104ReciveArray[14]=0; iec104ReciveArray[15]=iecData[18];//value [DATA 1] iec104ReciveArray[16]=iecData[19];//value [DATA 1] iec104ReciveArray[17]=iecData[20];//value [DATA 1] iec104ReciveArray[18]=iecData[21];//value [DATA 1] iec104ReciveArray[19]=iecData[22];//IOA QDS iec104ReciveArray[20]=iecData[23];//IOA iec104ReciveArray[21]=iecData[24];//IOA iec104ReciveArray[22]=0;//IOA iec104ReciveArray[23]=iecData[25];//value [DATA 2] iec104ReciveArray[24]=iecData[26];//value [DATA 2] iec104ReciveArray[25]=iecData[27];//value [DATA 2] iec104ReciveArray[26]=iecData[28];//value [DATA 2] iec104ReciveArray[27]=iecData[29];//IOA QDS MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); txcnt=txcnt; break; case 67: //TESTFR iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=iec104ReciveArray[1]; iec104ReciveArray[2] =131; //TESTFR con iec104ReciveArray[3] =0; iec104ReciveArray[4] =0; iec104ReciveArray[5] =0; MessageLength = iec104ReciveArray[1]+2; delay(10); client.write(iec104ReciveArray, MessageLength); iec104ReciveArray[0]=iec104ReciveArray[0]; iec104ReciveArray[1]=26;// APDU iec104ReciveArray[2]=lowByte(txcnt); iec104ReciveArray[3]=highByte(txcnt); iec104ReciveArray[4]=lowByte(rxcnt); iec104ReciveArray[5]=highByte(rxcnt); iec104ReciveArray[6]=13;//type 13 iec104ReciveArray[7]=02;//sq iec104ReciveArray[8]=03;//spont iec104ReciveArray[9]=00;//AO iec104ReciveArray[10]=01;//Adress iec104ReciveArray[11]=00;//Adress iec104ReciveArray[12]=iecData[16];//IOA iec104ReciveArray[13]=iecData[17];//IOA iec104ReciveArray[14]=0; iec104ReciveArray[15]=iecData[18];//value [DATA 1] iec104ReciveArray[16]=iecData[19];//value [DATA 1] iec104ReciveArray[17]=iecData[20];//value [DATA 1] iec104ReciveArray[18]=iecData[21];//value [DATA 1] iec104ReciveArray[19]=iecData[22];//IOA QDS iec104ReciveArray[20]=iecData[23];//IOA iec104ReciveArray[21]=iecData[24];//IOA iec104ReciveArray[22]=0;//IOA iec104ReciveArray[23]=iecData[25]; iec104ReciveArray[24]=iecData[26]; iec104ReciveArray[25]=iecData[27]; iec104ReciveArray[26]=iecData[28]; iec104ReciveArray[27]=iecData[29];//IOA QDS MessageLength = iec104ReciveArray[1]+2; client.write(iec104ReciveArray, MessageLength); break; } } }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After uploading the sketch to Wireshark, we observe that data transfer has finally begun. </font></font><br><img src="https://habrastorage.org/files/a61/b08/555/a61b085554d7466dbece57d3d2a4a4f9.JPG"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, I provide a description of the structure of the ASDU &lt;100&gt; M_SP_NA_1 single-element indication. </font></font><br><br><img src="https://habrastorage.org/files/8ac/a08/fc1/8aca08fc17484208ad5f9d2929c5f692.jpg"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TypeId</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a type of information. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - variable structure classifier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two structures of data blocks are provided for: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. A block containing i information objects, each of which contains one information item (or one combination of elements); the high-order bit of the classifier for the variable structure SQ (single / sequence) is 0, the remaining 7 bits specify the number i. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. A block containing a single information object that contains j elements or the same combinations of information elements; the most significant bit (27 = 80h) of the SQ classifier is 1, the remaining 7 bits specify the number j.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b07/7b0/fe0/b077b0fe004548d09207436d5288b2a8.jpg"><br></div></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CauseTx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the reason for the transfer.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a05/d3f/7ad/a05d3f7ad3854e69b093e53629fb7efb.jpg"><br></div></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - slave address (specified when configuring the wizard). </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the address of the information object; at this address, the monitoring station will link its </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tag </font><font style="vertical-align: inherit;">‚Äî the quality indicator of the transmitted signal. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ASDU structure of the function block &lt;11&gt; M_ME_NB_1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wireshark</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/614/0af/f41/6140aff415ee45d0a3536f78168f9ee5.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In response to the received data, the master will send blocks of format S and the process will loop until the monitored (slave) device stops transmitting frames. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Testing procedures </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing procedures are used to monitor the performance of transport connections. </font><font style="vertical-align: inherit;">The procedure is performed independently of the ‚Äúactivity‚Äù of the IP connection, if during the control time t3 no frames were received (I, U, S). </font><font style="vertical-align: inherit;">Time t3 is subject to negotiation and is called ‚ÄúTime out for sending test blocks in case of long idle time‚Äù. </font><font style="vertical-align: inherit;">The test procedure is implemented by sending a test APDU (TESTFR = act), which is confirmed by the received station using the APDU (TESTFR = con).</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/bfb/e47/0ef/bfbe470ef86348da84fc482a7addd379.jpg"><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wireshark</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b3e/c68/d9e/b3ec68d9e96f41ae9967bf244318b290.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the control station (master) receives an APDU whose value in the byte responsible for the type of APDU is sixty network (TESTFR), it means that during the time t3, no frame was received from the monitored station (I, U, S) , and if during the time t1 does not respond with a confirmation, the connection will be terminated. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sketch</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">67</span></span>: iec104ReciveArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]=iec104ReciveArray[<span class="hljs-number"><span class="hljs-number">0</span></span>];<span class="hljs-comment"><span class="hljs-comment">//  ,   START2 = 68h; iec104ReciveArray[1]=iec104ReciveArray[1];// APDU LENGHT iec104ReciveArray[2] = 131; //TESTDT con iec104ReciveArray[3] =0; iec104ReciveArray[4] =0; iec104ReciveArray[5] =0; MessageLength = iec104ReciveArray[1]+2;//   + 2  Start68H and Lenght delay(10); client.write(iec104ReciveArray, MessageLength);</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wireshark</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a9f/c4c/604/a9fc4c60423d4867945468f5636ea5ec.jpg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> That's all, if anyone is interested, then in the next article I will look at the IEC 670-5-104 protocol from the controlling (master) station using the example of Arduino. </font></font></div><p>Source: <a href="https://habr.com/ru/post/280818/">https://habr.com/ru/post/280818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280806/index.html">SSO for beauty and monster</a></li>
<li><a href="../280810/index.html">Use an Intel RealSense camera with TouchDesigner. Part 1</a></li>
<li><a href="../280812/index.html">Mythbusters: Automatic Google Recaptcha Solution</a></li>
<li><a href="../280814/index.html">Framework fastcgi container</a></li>
<li><a href="../280816/index.html">About the UHD-resolution restaurant table and other interactive technologies from Kodisoft</a></li>
<li><a href="../280820/index.html">The digest of interesting materials from the world of MODX # 1</a></li>
<li><a href="../280822/index.html">Reading large amounts of data in Python / Postgresql</a></li>
<li><a href="../280824/index.html">IL2CPP: generated code tour</a></li>
<li><a href="../280826/index.html">Announcement of the Russian-language catalog of solutions of independent developers certified for Microsoft Azure</a></li>
<li><a href="../280828/index.html">New big css book</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>