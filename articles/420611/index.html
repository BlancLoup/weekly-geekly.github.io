<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modeling Quantum Entanglement on C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As the topic of quantum entanglement pops up more and more, I wanted to delve a little. Judging by the comments on the articles on quantum entanglemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modeling Quantum Entanglement on C #</h1><div class="post__text post__text-html js-mediator-article">  As the topic of quantum entanglement pops up more and more, I wanted to delve a little.  Judging by the comments on the articles on quantum entanglement, this information will not be useful to me alone.  Well, taking into account the fact that for most of us, the program code is much more convenient than any allegories - it was decided to present my understanding in the form of code. <br><a name="habracut"></a><br>  This article expands another author <a href="https://habr.com/post/181692/">'s</a> article <a href="https://habr.com/post/181692/">‚ÄúQuantum entanglement for dummies‚Äù</a> (I recommend reading, it helped me a lot).  In his article, <a href="https://habr.com/users/indomit/" class="user_link">indomit</a> gave an example of a program that clearly demonstrates the problem of the theory of hidden parameters, but could not give an example of code for particles in a superposition.  In this article, we will try to simulate 2 cases: <br><br><ol><li>  As if entangled particles behaved under determinism, when the state of particles is established before measurement, we simply cannot measure it without introducing distortions (that is the theory of hidden parameters).  We get the numbers and see the discrepancy with the practice. </li><li>  We write a model of entangled particles in superposition (the state of the particles is not determined before the measurement).  Let's try to assume how the particle is programmed inside, that is, we fit its code to the data that were obtained experimentally. </li></ol><br>  The article is based on a popular explanation of the quantum entanglement phenomenon from Mermin: <br><br><div class="spoiler">  <b class="spoiler_title">Mermin Paradox Explained</b> <div class="spoiler_text">  For the popular paradox report, D. Mermin proposes to construct a simple device [23].  The device should consist of a particle emitter and two detectors.  Two identical particles are emitted to each of them.  Catching a particle, the detector gives a binary response (0 or 1), depending on the particle and its three-position setting switch.  Detection of a pair of particles should give the same answers: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Whenever the detectors are configured equally. </li><li>  According to statistics in half the cases when they are configured randomly. </li></ol><br>  The first property requires that all detectors use the same coding switch position ‚àà {1,2,3} ‚Ü¶ response ‚àà {0,1}, without any element of randomness.  That is, they should agree in advance which of the responses, 0 or 1, should be given to the switch position, choosing one of eight possible functions for each particle, 000, 001, 010, 011, 100, 101, 110 and 111. Choosing 000 or 111 will result to 100% coincidence of the detectors, regardless of the position of the knob.  If the detectors implement one of the six remaining functions, one of the numbers is pulled out by a randomly configured switch in 2/3 cases, the other with a probability of 1/3.  The probability of coincidence of two answers at the same time will be (‚Öî) ¬≤ + (‚Öì) ¬≤ = 5/9.  So whatever the algorithm of the automaton, the correlation inevitably exceeds 50%, breaking the second requirement. <br><br>  <i>But since such a machine can still be built (for example, with the position of polarizers at 120 ¬∞, as in Bohm‚Äôs experience), there can be no determinism (parameters) even in latent form.</i>  <i>Instead, correlation responses are maintained by transferring information from one ‚Äúmeasured‚Äù particle to another faster than the second measurement occurs.</i> <br><br>  Taken <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D0%25B0%25D0%25B4%25D0%25BE%25D0%25BA%25D1%2581_%25D0%25AD%25D0%25B9%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0_%25E2%2580%2594_%25D0%259F%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25BB%25D1%258C%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE_%25E2%2580%2594_%25D0%25A0%25D0%25BE%25D0%25B7%25D0%25B5%25D0%25BD%25D0%25B0">from here</a> . <br></div></div><br>  Unfortunately, I do not do physics either professionally or even at the level of an amateur; I do not pretend to infallibility.  The main goal of the article is to demonstrate how to make a model that is understandable to those familiar with programming.  If someone works professionally in this field, then instead of reproaching - try to write more accurate interaction models based on my article. <br><br><h2>  [Update] Explanation of the description of Mermin </h2><br>  Although several months have passed since the article was written and no one will return to it, I decided to clarify to calm my conscience. <br><br>  He went a little deeper and came to the conclusion that the description according to Mermin was greatly simplified and attempts to bind him to real physical experiments are <i>meaningless</i> . <br><br>  Initially, I tried to link the article to a real experiment with circular polarization and I was mistaken about that.  <a href="https://habr.com/users/arad/" class="user_link">ARad</a> tried to develop a binding to real physical experiments, wrote about the mistakes made, and even offered <a href="https://dotnetfiddle.net/iYElNq">its own version of the code</a> (which also does not correspond to any physical experiment). <br><br>  In order for the article to have at least some sense, it was decided to remove all imaginary bindings to real physical experiments and simply <i>clarify Mermin‚Äôs description in the code</i> and make it more visual.  Real experiments are more difficult and for their modeling it is necessary to spend much more time. <br><br>  In the first version of the article, we assumed that in the first experiment (the position of the sensors coincides) the particles give a mirror result, but in the original description by Mermin the measurement result with the same position of the sensors always coincides.  This is <i>fixed</i> . <br><br>  Additionally, I will add the ‚Äúexplanation to the explanation‚Äù of this Mermin himself, since it is not unequivocally written: <br><br><blockquote>  That is, they must agree in advance on which of the responses, 0 or 1, to give to the switch position, choosing for each particle one of the eight possible functions, 000, 001, 010, 011, 100, 101, 110 and 111. <br></blockquote><br>  The phrase ‚Äúeight possible functions‚Äù is not straightforward.  It is a question of eight possible variants of <i>potential</i> impact of particles on the sensor.  There are three sensor positions (see full description above).  If we consider that the state of two particles coincides and is set in advance, then we can determine in advance which response (0 or 1) we will potentially receive for each of the three switch positions (although we can measure only one of the three options). <br><br><blockquote>  Selecting 000 or 111 will result in a 100% coincidence of the readings of the detectors, regardless of the position of the adjustment knob. </blockquote><br>  If the particles can take the value at which potentially get the response "1" at any position of the switch (as well as 0, at any position of the switch) - then the second experiment in these cases will give 100% matches.  To approach 50% these options can be excluded. <br><br><blockquote>  If the detectors implement one of the six remaining functions, one of the numbers is pulled out by a randomly configured switch in 2/3 cases, the other with a probability of 1/3. </blockquote><br>  It means that in each of 6 triples (001, 010, 011, 100, 101, 110) - only two of the three digits match (in the first version, two of the three are ‚Äú0‚Äù, and one of the three is ‚Äú1‚Äù ). <br><br>  To estimate the probability we will create a table for the first case <b>001</b> : <br><br><table><tbody><tr><th>  Sensor position 1 </th><th>  Sensor position 2 </th><th>  Will the measurements match </th></tr><tr><td>  one </td><td>  one </td><td>  + </td></tr><tr><td>  one </td><td>  2 </td><td>  + </td></tr><tr><td>  one </td><td>  3 </td><td>  - </td></tr><tr><td>  2 </td><td>  one </td><td>  + </td></tr><tr><td>  2 </td><td>  2 </td><td>  + </td></tr><tr><td>  2 </td><td>  3 </td><td>  - </td></tr><tr><td>  3 </td><td>  one </td><td>  - </td></tr><tr><td>  3 </td><td>  2 </td><td>  - </td></tr><tr><td>  3 </td><td>  3 </td><td>  + </td></tr></tbody></table><br>  It is seen that in five cases out of nine measurements will coincide.  The same probability will be for each of these six options (after all, in each of them two numbers are the same). <br><br><h2>  Measurements </h2><br>  In each of the models (both in deterministic and superpositional), we will carry out two experiments with entangled particles, corresponding to the first and second conditions according to Mermin: <br><br><ol><li>  First set both sensors to the same position.  In this case, we will get 100% identical results (if the first photon passes through the polarizer, then the associated one also passes through the polarizer at the same angle). </li><li>  Then we will set the position of the sensors randomly. </li></ol><br>  Here is the code for the first experiment: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //  </span></span></code> </pre> <br>  Here is the code for the second experiment: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100);</span></span></code> </pre><br>  For all models of particles there will be the same tests, only the code of particles will differ for the deterministic and superposition models (more on this below). <br><br><h2>  Deterministic model </h2><br>  Attention!  See UPDATE at the end of the article! <br><br>  For those who want to immediately run the code, this can be done from the browser: <a href="https://dotnetfiddle.net/N5Xg18">dotnetfiddle.net/N5Xg18</a> <br><br>  So, according to Mermin's explanation, we have a quantum particle with 3 parameters: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ( , ) public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Since the model is deterministic, all the parameters of the particle are initialized at the moment of its creation, that is, directly in the constructor.  The only condition is that measurement is allowed only once! <br><br>  Further.  A pair of entangled particles: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean(); ; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (    ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } }</span></span></code> </pre><br><br>  It can be seen that the values ‚Äã‚Äãof each of the particles are set at the time of creating a pair of entangled particles, and the parameters of the second particle correspond to the parameters of the first (without this we can not pass the first test).  We use random numbers, but according to the model, the parameters depend on factors at the time of entanglement (as a result, roulette depends on a number of factors at the time of unwinding). <br><br>  Full sample code: <br><br><div class="spoiler">  <b class="spoiler_title">C # code of deterministic model (fixed)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean();; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (   ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  You can run from the browser (again link: <a href="https://dotnetfiddle.net/N5Xg18">dotnetfiddle.net/N5Xg18</a> ). <br><br>  After launch, these are the results: <br><br><blockquote>  Experiment No. 1: 100% of the values ‚Äã‚Äãcoincided <br>  Experiment number 2: 55.6700% of the values ‚Äã‚Äãcoincided <br></blockquote><br>  The first test passed, corresponds to what is happening in reality.  But the second - does not match, because they should get 50%! <br><br>  As a result, physicists were forced to come to the conclusion that the theory of hidden parameters is erroneous.  And along with it, the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">principle of locality</a> was refuted and even the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BF%25D1%2580%25D0%25B8%25D1%2587%25D0%25B8%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">principle of causality was</a> shaken. <br><br><h2>  Superposition model </h2><br>  Immediately link to the code of the example, for those who like specifics (can be run in the browser): <a href="https://dotnetfiddle.net/Mb7JqU">dotnetfiddle.net/Mb7JqU</a> <br><br>  In order to explain the results obtained during the experiments, it was necessary to use more complex models.  In modern models, the state of the particle parameters before the measurement is not defined, and the entangled particles themselves have the ability to instantly (above the speed of light) influence the state of each other.  This is how our model of an elementary particle now looks like: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  First, the parameters of the steel are Nullable (they may not matter) and we do not set them in the constructor.  Secondly, the CreateSuperluminalChannelWith method appeared to set up a superluminal channel between particles, i.e.  now one particle can receive a state of another instantaneously, regardless of the distance.  Well and, most importantly, now the state of the particle is <i>established only at the moment of measurement</i> (call the GetValue method) and depends on whether another particle associated with it was measured. <br><br>  The interior of the GetValue method is pure assumption.  How a particle is arranged inside - nobody knows, but we know that it works exactly like this: 100% mismatch when measuring the same parameter and 50% mismatch when measuring parameters in a random order. <br><br>  In my version of the code, the particle over the superluminal channel checks whether the measurement is made entangled with it and acts as follows: <br><br><ol><li>  If the measured parameter of another particle is the same as what we are trying to measure, it gives the same value. </li><li>  If the parameter is different, then in 1/4 cases it gives the same value, and in 3/4 cases it gives the opposite value (since we get 50/50). </li></ol><br>  If the measurement was not made - the particle uses the true random to set its value, that is, there is a violation of the causal relationship (the value did not exist before the measurement and the measurement itself did not determine its value). <br><br>  <i>By the way!</i>  <i>You can rewrite this function in a different way, but make the test results the same.</i>  <i>Still, no one knows how the elementary particle is arranged and how it is achieved 50% for the second test.</i> <i><br></i> <br>  A pair of entangled particles has become simpler, since at the moment of entanglement no values ‚Äã‚Äãare set (values ‚Äã‚Äãare not yet defined): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } }</span></span></code> </pre><br>  Full sample code: <br><br><div class="spoiler">  <b class="spoiler_title">Superposition Model on C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Results: <br><br><blockquote>  Experiment No. 1: 100% of the values ‚Äã‚Äãcoincided <br>  Experiment number 2: 49.7700% of the values ‚Äã‚Äãcoincided <br></blockquote><br>  Run in browser: <a href="https://dotnetfiddle.net/Mb7JqU">dotnetfiddle.net/Mb7JqU</a> <br><br><h2>  findings </h2><br>  I would like more accessible interpretations, like those expressed by Mermin.  Based on this interpretation, I managed to create visual models of existing theories and even put forward an alternative model and these models are not allegorical - you can run them and see how they work. <br><br>  Unfortunately, I do not have temporary resources for a deeper knowledge of quantum physics and I hope that those in the know will be able to follow my example and lead more accurate working models. <br><br>  <b>UPDATE</b> <br>  In the explanation of Mermin nothing about the device detectors.  I, on my own initiative, added an explanation to A, B and C as a projection of the spin on the X, Y and Z axes, respectively.  That is, I wanted to add a link to physical phenomena in the comments to the code so that it would not be so dry.  And in this I was mistaken ... <br><br>  The article has been corrected and all vain attempts to link Mermin‚Äôs explanation to real physical experiments have been removed. </div><p>Source: <a href="https://habr.com/ru/post/420611/">https://habr.com/ru/post/420611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420599/index.html">Thirteen Things Lemme foreseen</a></li>
<li><a href="../420603/index.html">Statistics from the owner of Tesla Model S</a></li>
<li><a href="../420605/index.html">Overview of tasks for interviewing algorithms - generating sets</a></li>
<li><a href="../420607/index.html">Digital events in Moscow from August 20 to 26</a></li>
<li><a href="../420609/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ327 (August 13 - 19, 2018)</a></li>
<li><a href="../420613/index.html">11 libraries (sets of components) for React Native, which you should know about in 2018</a></li>
<li><a href="../420615/index.html">Javascript: object exploration</a></li>
<li><a href="../420617/index.html">Developer Web Design Guide</a></li>
<li><a href="../420619/index.html">Responsive images: CSS techniques that help save time</a></li>
<li><a href="../420623/index.html">Distributed C ++ applications with minimal effort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>