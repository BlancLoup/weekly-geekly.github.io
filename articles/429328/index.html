<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Software module for digitizing damaged documents</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Optical Character Recognition (OCR) is the process of obtaining printed texts in a digitized format. If you read a classic novel on a digital device o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Software module for digitizing damaged documents</h1><div class="post__text post__text-html js-mediator-article"><p>  Optical Character Recognition (OCR) is the process of obtaining printed texts in a digitized format.  If you read a classic novel on a digital device or asked a doctor to pick up old medical records through the hospital's computer system, you probably took advantage of OCR. </p><br><p>  OCR makes previously static content editable, searchable and exchangeable.  But many documents that need digitization contain coffee stains, pages with curved corners and many wrinkles retain some printed documents in a non-digitized form. </p><br><p>  Everyone has long known that there are millions of old books that are stored in the vaults.  The use of these books is prohibited because of their dilapidation and decrepitude, and therefore the digitization of these books is so important. </p><br><p>  The paper deals with the task of clearing text from noise, recognizing text in an image and converting it into text format. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3b0/14c/324/3b014c324c6ac91f8d8a761ca4e0bbc1.jpg" alt="image"></p><br><p>  For training used 144 pictures.  The size may be different, but preferably should be within reason.  Pictures must be in PNG format.  After reading the image, binarization is used - the process of converting a color image to black and white, that is, each pixel is normalized to the range from 0 to 255, where 0 is black, 255 is white. </p><br><p>  To train a convolutional network, you need more images than there are.  It was decided to divide the images into parts.  Since the training sample consists of images of different sizes, each image was compressed to 448x448 pixels.  The result was 144 images at a resolution of 448x448 pixels.  After that, they were all cut into non-overlapping windows measuring 112x112 pixels. </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/getpro/habr/post_images/07a/c1d/271/07ac1d2716da451215a597dbb8241a9d.jpg" alt="image"></p><br><p>  Thus, out of the 144 original images, about 2,304 images were obtained in the training set.  But this was not enough.  For good learning of the convolution network, more examples are needed.  In consequence of this, the best option was to rotate the pictures by 90 degrees, then by 180 and 270 degrees.  As a result, an array with the size [16,112,112,1] is fed to the input of the network.  Where 16 is the number of images, 112 is the width and height of each image, 1 is the color channels.  It turned out 9216 examples for learning.  This is enough to train a convolutional network. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7d/320/415/f7d320415a5cba904cf715646dddbe2a.png" alt="image"></p><br><p>  Each image has a size of 112x112 pixels.  If the size is too large, the computational complexity will increase, respectively, the limitations on the speed of response will be violated, the determination of the size in this problem is solved by the selection method.  If you select a size that is too small, the network will not be able to identify key features.  Each image has a black and white format, so it is divided into 1 channel.  Color images are divided into 3 channels: red, blue, green.  Since we have black and white images, the size of each image is 112x122x1 pixels. </p><br><p>  First of all, it is necessary to train a convolutional neural network on the harvested, processed images.  For this task, the U-Net architecture was chosen. </p><br><p>  A reduced version of the architecture was selected, consisting of only two blocks (the original version of four).  An important consideration was the fact that a large class of well-known binarization algorithms is explicitly expressed in such an architecture or a similar architecture (as an example, we can take a modification of the Niblack algorithm with the replacement of the standard deviation by the mean deviation modulus, in this case the network is especially simple). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/43a/928/f6d/43a928f6d29028779c1fa25df30f794c.jpg" alt="image"></p><br><p>  The advantage of this architecture is that you can create a sufficient amount of training data from a small number of source images for network training.  At the same time, the network has a relatively small number of weights due to its convolutional architecture.  But there are some nuances.  In particular, the artificial neural network used, strictly speaking, does not solve the problem of binarization: it assigns to each pixel of the original image a certain number from 0 to 1, which characterizes the degree of belonging of this pixel to one of the classes (meaningful filling or background) and still convert to final binary answer.  [one] </p><br><p>  U-Net consists of a compressing and unclamping path and ‚Äúforwarding‚Äù between them.  The compression path, in this architecture, consists of two blocks (in the original version of four).  In each block, there are two bundles with a 3x3 filter (using the Tanh activation function after folding) and a pooling with a 2x2 filter size in increments of 2. The number of channels at each step down is doubled. </p><br><p>  Splitting path also consists of two blocks.  Each of them consists of a ‚Äúsweep‚Äù with a 2x2 filter size, halving the number of channels, concatenation with a corresponding truncated feature map from a compression path (‚Äúforwarding‚Äù), and two bundles with a 3x3 filter (using the Tanh activation function after folding).  Next, on the last layer, the 1x1 convolution (using the Sigmoid activation function) to produce an output, flat image.  Note that clipping the feature map during concatenation is significant due to the loss of boundary pixels at each convolution.  Adam was chosen as the method of stochastic optimization. </p><br><p>  In general, the architecture is a sequence of layers of convolution + pooling, which reduce the spatial resolution of the image, then increase it by combining with the image data in advance and passing it through other layers of the convolution.  Thus, the network serves as a kind of filter.  [2] </p><br><p>  The test sample consisted of similar images, the differences were only in the texture of noise and in the text.  Network testing took place on this image. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/595/79b/89b/59579b89b072f197c925623e11e712c5.jpg" alt="image"></p><br><p>  The output of the convolutional neural network is an array of numbers with a size [16,112,112,1].  Each number is a separate pixel processed by the network.  The images have a format of 112x112 pixels, as before, it was cut into pieces.  She needs to betray the original look.  We merge the obtained images into one part, as a result, the picture has the format of 448x448.  Then we multiply each number in the array by 255 to get the range from 0 to 255, where 0 is black, 255 is white.  We return the image to its original size, as before, it was compressed.  The result is a picture below in the picture. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a05/a85/636/a05a856361fdc5cefe5c84e81df33992.jpg" alt="image"></p><br><p>  In this example, it is clear that the convolutional network has coped with the majority of noisiness and has shown itself to work.  But it is clearly noticeable that the picture has become duller and the missed noises are visible.  In the future, this may affect the accuracy of text recognition. </p><br><p>  Based on this fact, it was decided to use another neural network - a multilayer perceptron.  In the expected result, the network should make the text in the image clearer and remove the noisiness missed by the convolutional neural network. </p><br><p>  An image that has already been processed by a convolutional network is sent to the input of the multilayer perceptron.  In this case, the training sample for this network will differ from the sample for the convolutional network, since the networks process the image differently.  A convolutional network is considered to be the main network and removes most of the noise in the image, while the multi-layer perceptron processes what the convolutional failed. <br>  Here are some examples from a training sample for a multilayer perceptron. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/505/62f/877/50562f87767ceb31fae90cb98f86dacf.jpg" alt="image"></p><br><p>  The image data was obtained by processing the training sample for the convolutional network with a multilayer perceptron.  At the same time, the perceptron was trained on the same sample, but on a small number of examples and a small number of epochs. </p><br><p>  For perceptron training, 36 images were processed.  The network is trained pixel-by-pixel, that is, one pixel from the image is sent to the input of the network.  At the output of the network we also get one output neuron - one pixel, that is, the response of the network.  To increase the processing accuracy, 29 input neurons were made.  And on the image obtained after processing by the convolutional network, 28 filters are superimposed.  The result is 29 images with different filters.  We send one pixel from each 29 images to the network input and only one pixel is received at the network output, that is, the network response. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d00/628/790/d00628790fa450774472e3293bba3965.jpg" alt="image"></p><br><p>  This was done for better learning and networking.  After that, the network began to increase the accuracy and contrast of the image.  It also clears minor errors that could not clear the convolutional network. </p><br><p>  As a result, the neural network has 29 input neurons, one pixel from each image.  After the experiments, it was found that only one hidden layer is needed, in which there are 500 neurons.  Outlet at the network one.  Since the learning took place pixel by pixel, the network was accessed n * m times, where n is the width of the image, and m is the height, respectively. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a1a/1b4/2d9/a1a1b42d91fd9ec4ea767e9a72850f11.jpg" alt="image"></p><br><p> After image processing by successively two neural networks, the main thing that remains is to recognize the text.  For this, a ready-made solution was taken, namely the Pytesseract Python library.  Pytesseract does not provide true Python bindings.  Rather, it is a simple wrapper for the tesseract binary file.  At the same time tesseract is installed separately on the computer.  Pytesseract saves the image to a temporary file on disk, then calls the tesseract binary file and writes the result to a file. </p><br><p>  This wrapper is developed by Google and is free and free to use.  It can be used both in their own and for commercial purposes.  The library works without an internet connection, supports many languages ‚Äã‚Äãfor recognition and impresses with its speed.  Its application can be found in various popular applications. </p><br><p>  The last item left is to write the recognized text to a file in a format suitable for its processing.  We use for this the usual notebook, which opens, after the completion of the program.  Also, the text is displayed on the test interface.  An illustrative example of the interface. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3b7/bb0/a49/3b7bb0a49f54d81ecd638b0e074ab24e.jpg" alt="image"></p><br><p>  <strong>Bibliography:</strong> </p><br><ol><li>  The history of victory in the international competition for the recognition of documents of the SmartEngines company team [Electronic resource].  Access mode: <a href="https://habr.com/company/smartengines/blog/344550/">https://habr.com/company/smartengines/blog/344550/</a> </li><li>  Image segmentation using neural network: U-Net [Electronic resource].  Access mode: <a href="http://robocraft.ru/blog/machinelearning/3671.html">http://robocraft.ru/blog/machinelearning/3671.html</a> </li></ol><br><p>  <a href="https://github.com/SergeyChernenko/segmentation-of-damaged-documents">&gt; <strong>Repository on github</strong></a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/429328/">https://habr.com/ru/post/429328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429318/index.html">SMT Solver on iPhone</a></li>
<li><a href="../429320/index.html">Sberbank Data Science Day live stream November 10</a></li>
<li><a href="../429322/index.html">nanoCAD Mechanics 9.0: The Basics of Modern Design</a></li>
<li><a href="../429324/index.html">Unreal Engine 4.21 release</a></li>
<li><a href="../429326/index.html">App Store will not call. Or how I made my application, but it will not get to users</a></li>
<li><a href="../429330/index.html">Myths and legends of Agile - from the Pharaohs to the present day</a></li>
<li><a href="../429332/index.html">Self-made laser installation "Lightsaber" - as it were, part 1</a></li>
<li><a href="../429336/index.html">Driver and device communication using the _HID method of ACPI using the example of a GPIO Lynxpoint controller</a></li>
<li><a href="../429338/index.html">Android Storage: Internal, External, Removable. Part 1/3</a></li>
<li><a href="../429340/index.html">Think twice before using Helm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>