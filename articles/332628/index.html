<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>5 tricks to help develop on vue.js + vuex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently decided to deal with vue.js. The best way to learn technology is to write something on it. To this end, my old route planner was rewritten, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>5 tricks to help develop on vue.js + vuex</h1><div class="post__text post__text-html js-mediator-article">  Recently decided to deal with <a href="https://vuejs.org/">vue.js.</a>  The best way to learn technology is to write something on it.  To this end, my <a href="https://github.com/Kasheftin/RoutePlanner">old route planner</a> was rewritten, and <a href="https://github.com/Kasheftin/route-planner-vue"><b>this was the project</b></a> .  The code is large enough to face the scaling task. <br><br>  In this article I will give a number of techniques that, in my opinion, will help in the development of any large project.  This material is for you if you have already written your todo list on vue.js + vuex, but have not yet dug into large-scale cycling. <br><br><img src="https://habrastorage.org/web/314/6e7/c9a/3146e7c9a4dc4c9b9236952ae5f4d45a.png"><br><a name="habracut"></a><br><h3>  1. Centralized Event Bus </h3><br>  Any project on vue.js consists of nested components.  The basic principle is props down, events up.  The subcomponent receives data from the parent that it cannot change, and a list of parent events that it can run. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The principle is valid, but it creates a strong connection.  If the target component is deeply nested, you have to drag data and events through all the wrappers. <br><br>  We will deal with the events.  It is often useful to have a global event emitter with which any component can communicate, regardless of the hierarchy.  It is very easy to make; no additional libraries are needed: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(Vue.prototype,<span class="hljs-string"><span class="hljs-string">"$bus"</span></span>,{ <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$root.bus; } }); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue({ <span class="hljs-attr"><span class="hljs-attr">el</span></span>: <span class="hljs-string"><span class="hljs-string">'#app'</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">bus</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue({}) <span class="hljs-comment"><span class="hljs-comment">// Here we bind our event bus to our $root Vue model. } });</span></span></code> </pre> <br>  After that, in any component there is access to this. $ Bus, you can subscribe to events through this. $ Bus. $ On () and call them through this. $ Bus. $ Emit ().  Here is <a href="https://jsfiddle.net/g8Lqv0rx/10/">an example</a> . <br><br>  It is very important to understand that this. $ Bus is a global object for the entire application.  If you forget to unsubscribe, the components remain in the memory of this object.  Therefore, for each this. $ Bus. $ On in mounted there must be a corresponding this. $ Bus. $ Off in beforeDestroy.  For example: <br><br><pre> <code class="javascript hljs">mounted: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._someEvent = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">..</span></span></span><span class="hljs-function">) =&gt;</span></span> { .. } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._otherEvent = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">..</span></span></span><span class="hljs-function">) =&gt;</span></span> { .. } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$bus.$on(<span class="hljs-string"><span class="hljs-string">"someEvent"</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._someEvent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$bus.$on(<span class="hljs-string"><span class="hljs-string">"otherEvent"</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._otherEvent); }, <span class="hljs-attr"><span class="hljs-attr">beforeDestroy</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._someEvent &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$bus.$off(<span class="hljs-string"><span class="hljs-string">"someEvent"</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._someEvent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._otherEvent &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$bus.$off(<span class="hljs-string"><span class="hljs-string">"otherEvent"</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._otherEvent); }</code> </pre><br><h3>  2. Centralized Promises Bus </h3><br>  Sometimes in a component you need to initialize some asynchronous piece (for example, an instance of google maps) that you want to access from other components.  To do this, you can organize an object that will store promises.  For example, <a href="">such</a> .  As in the case of the event bus, do not forget to be deleted when the component is deinitialized.  And in general, the above method can attach any external object with any logic to vue. <br><br><h3>  3. Flat structures (flatten store) </h3><br>  In a complex project, data is often heavily embedded.  Working with such data is inconvenient in both vuex and redux.  It is recommended to reduce nesting, for example, using the utility <a href="https://github.com/paularmstrong/normalizr">normalizr</a> .  The utility is good, but it is even better to understand what it does.  I did not immediately come to understand the flat structure, for the same type of myself I will consider a detailed example. <br><br>  We have projects, in each - an array of layers, in each layer - an array of pages: projects&gt; layers&gt; pages.  How to organize storage? <br><br>  The first thing that comes to mind is the usual nested structure: <br><br><pre> <code class="javascript hljs">projects: [{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">layers</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">pages</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"page1"</span></span> },{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"page2"</span></span> }] }] }];</code> </pre><br>  This structure is easy to read, it is easy to run foreach on projects, render subcomponents with lists of layers, and so on.  But suppose you need to change the name of the page with id: 1.  Inside some small component that renders the page, call $ store.dispatch (‚ÄúchangePageName‚Äù, {id: 1, name: ‚Äúnew name‚Äù}).  How to find a place where in this deeply nested structure lies the desired page with id: 1?  Run across the repository?  Not the best solution. <br><br>  You can specify the full path, such as <br><br><pre> <code class="javascript hljs">$store.dispatch(<span class="hljs-string"><span class="hljs-string">"changePageName"</span></span>,{<span class="hljs-attr"><span class="hljs-attr">projectId</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-attr"><span class="hljs-attr">layerId</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-attr"><span class="hljs-attr">id</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-attr"><span class="hljs-attr">name</span></span>:<span class="hljs-string"><span class="hljs-string">"new name"</span></span>})</code> </pre> <br>  But this means that in every small component of the page rendering, you need to drag the entire hierarchy, and the projectId, and layerId.  Inconvenient. <br><br>  Second attempt, from sql: <br><br><pre> <code class="javascript hljs">projects: [{<span class="hljs-attr"><span class="hljs-attr">id</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}], <span class="hljs-attr"><span class="hljs-attr">layers</span></span>: [{<span class="hljs-attr"><span class="hljs-attr">id</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-attr"><span class="hljs-attr">projectId</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}], <span class="hljs-attr"><span class="hljs-attr">pages</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"page1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">layerId</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">projectId</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> },{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"page2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">layerId</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">projectId</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }]</code> </pre><br>  Now the data is easy to change.  But hard to run.  To display all the pages in one layer, you need to run through all the pages in general.  This can be hidden in getter, or in template rendering, but there will still be a run. <br><br>  Third attempt, normalizr approach: <br><br><pre> <code class="javascript hljs">projects: [{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">layersIds</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>] }], <span class="hljs-attr"><span class="hljs-attr">layers</span></span>: { <span class="hljs-number"><span class="hljs-number">1</span></span>: { <span class="hljs-attr"><span class="hljs-attr">pagesIds</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>] } }, <span class="hljs-attr"><span class="hljs-attr">pages</span></span>: { <span class="hljs-number"><span class="hljs-number">1</span></span>: {<span class="hljs-attr"><span class="hljs-attr">name</span></span>:<span class="hljs-string"><span class="hljs-string">"page1"</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>: {<span class="hljs-attr"><span class="hljs-attr">name</span></span>:<span class="hljs-string"><span class="hljs-string">"page2"</span></span>} }</code> </pre><br>  Now all the pages of the layer can be obtained through the trivial getter <br><br><pre> <code class="javascript hljs">layerPages: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state,getters</span></span></span><span class="hljs-function">) =&gt;</span></span> (layerId) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> layer = state.layers[layerId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!layer || !layer.pagesIds || layer.pagesIds.length==<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.pagesIds.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pageId</span></span></span><span class="hljs-function"> =&gt;</span></span> state.pages[pageId]); }</code> </pre><br>  Note that the getter does not run through the list of all pages.  Data is easy to change.  The order of the pages in the layer is specified in the layer object, and this is also correct, since the re-sorting procedure is usually located in the component that lists the objects, in our case it is the component that renders the layer. <br><br><h3>  4. Mutations are not needed. </h3><br>  According to the rules of vuex, changes to the repository data should occur only in functions-mutations, mutations should be synchronous.  In vuex is the main logic of the application.  Therefore, the data validation unit will also be logical to include in the repository. <br><br>  But validation is not always synchronous.  Therefore, at least part of the validation logic will not be in mutations, but in actions. <br><br>  I suggest not to break the logic, and to store in actions in general the whole validation.  Mutations become primitive, consist of elementary assignments.  But then they can not be accessed directly from the application.  Those.  mutations are a kind of utilitarian thing inside the repository, which is useful except for the vuex debugger.  The application communicates with the repository only through actions.  In my application, any action, even synchronous, always returns a promise.  It seems to me that knowing that all actions are asynchronous (and working with them as with promises) is easier than remembering what is which. <br><br><h3>  5. Restriction of reactivity </h3><br>  Sometimes it happens that the data in the repository does not change.  For example, it may be the search results of objects on the map, requested from the external api.  Each result is a complex object with many fields and methods.  It is necessary to display a list of results.  Need reactivity list.  But the data inside the objects themselves are constant, and there is no need to track the change of each property.  To limit reactivity, you can use Object.freeze. <br><br>  But I prefer a more stupid method: let state store only a list of id-snik, and the results themselves are next to each other in the array.  Type: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> results = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = {<span class="hljs-attr"><span class="hljs-attr">resultIds</span></span>:[]}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getters = { <span class="hljs-attr"><span class="hljs-attr">results</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.map(state.resultsIds,id =&gt; results[id]); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mutations = { <span class="hljs-attr"><span class="hljs-attr">updateResults</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state,data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newIds = []; data.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[r.id] = r; newIds.push(r.id); }); results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>; state.resultsIds = newIds; } }</code> </pre><br><h3>  Questions </h3><br>  Something I did not get as beautiful as I wanted.  Here are my questions to the community: <br><br>  - How to beat css animation harder to change the opacity?  Often you want to animate the appearance of a block of unknown size, i.e.  change its height from height: 0 to height: auto. <br>  This is easily solved with javascript - just wrapped in a container with overflow: hidden, we look at the height of the wrapped element and animate the height of the container.  Can this be solved via css? <br><br>  - I am looking for a normal way of working with icons in a webpack, so far without success (therefore, I continue to use fontello).  Like <a href="http://www.webhostinghub.com/glyphs/">whhg</a> icons.  Pulled svg, split into files.  I want to select multiple files and automatically collect inline font + classes based on file names.  What can you do? </div><p>Source: <a href="https://habr.com/ru/post/332628/">https://habr.com/ru/post/332628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332618/index.html">The method of recovering data from a disk encrypted with NotPetya using the Salsa20 algorithm</a></li>
<li><a href="../332620/index.html">Will Python save from execution?</a></li>
<li><a href="../332622/index.html">DPM: Why is he like that?</a></li>
<li><a href="../332624/index.html">How to win in Vkontakte contests? Another approach</a></li>
<li><a href="../332626/index.html">Handling recurring SIGSEGV-like errors</a></li>
<li><a href="../332630/index.html">Extending, modifying, and creating controls on the UWP platform. Part 2</a></li>
<li><a href="../332632/index.html">Rewarded Video: the best show scripts or how to make your ad look</a></li>
<li><a href="../332634/index.html">Things I needed to know before creating a queue system</a></li>
<li><a href="../332636/index.html">Go Developer Tools: Meet Profiler Labels</a></li>
<li><a href="../332638/index.html">RAML routing in the Play Framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>