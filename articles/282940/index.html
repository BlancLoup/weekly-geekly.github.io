<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write an IO monad in C # (not) without the help of a parallel universe and time machine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In life, there are often situations when you just need to sit down and do some business, not bothering with questions like ‚Äúwhat will it give?‚Äù, ‚ÄúAnd ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write an IO monad in C # (not) without the help of a parallel universe and time machine</h1><div class="post__text post__text-html js-mediator-article"> In life, there are often situations when you just need to sit down and do some business, not bothering with questions like ‚Äúwhat will it give?‚Äù, ‚ÄúAnd who needs it?‚Äù  and so on. Writing a monad of <code>IO ‚Äî</code> definitely the case.  Therefore, under the cut there is a story about how <em>to</em> write an <code>IO</code> monad in <em>C #,</em> without the slightest attempt to explain <em>why</em> . <br><br><div class="spoiler">  <b class="spoiler_title">Bayan picture reflecting the essence of the article</b> <div class="spoiler_text"><img src="http://cs.pikabu.ru/images/big_size_comm/2013-09_5/13798569678719.gif"><br></div></div><a name="habracut"></a><br><h2>  Interpretations of the monad <code>IO</code> </h2><br>  There are two ways of understanding (interpreting) the monad of <code>IO.</code> <br><br>  The first interpretation can be found, for example, in the remarkable <a href="https://wiki.haskell.org/IO_inside">IO inside</a> article.  Although it is not explicitly declared, in this article <code>IO</code> considered as a way to deceive the <em>Haskell</em> compiler <em>, to</em> shove the calls of ‚Äúdirty‚Äù native functions into clean code due to the ability to treat them formally as clean because of the addition of fictitious elements to the signature. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second interpretation can be understood by noting that for other monads (for example, <code>Get</code> from the <code>Data.Binary</code> module) there are functions of type <code>ma -&gt; a</code> (for <code>Get</code> this is the <code>runGet</code> function), that is, it is possible <em>to pull the</em> value out of the monad.  For <code>IO</code> , there is no such function, and the only way to do it is to return the native runtime from the <code>main</code> function.  That is, <code>IO</code> is a list of actions (script), and the task of clean code is to create this list of actions, but not to perform them. <br><br>  None of these interpretations helps translate the notion of <code>IO</code> to <em>C #</em> : in the first case we notice that in C # there is no difficulty in calling the ‚Äúdirty‚Äù code from any place, and in the second that in <em>C #</em> all functions and the whole program are there is a list of actions, and the semicolon is nothing more than the monadic operator <code>&gt;&gt;=</code> . <br><br>  Obviously, the problem is in the uniqueness of <code>IO</code> : while the other monads are syntactic sugar, input-output is an operation that is difficult to accomplish while staying within the framework of a clean code.  And if you find a way to write a really clean (without monads, without directly or indirectly calling native functions) I / O code, <code>IO</code> will simply appear as syntactic sugar for these pure functions, an object of the same kind as the <code>Maybe</code> monad.  Well, <code>Maybe</code> in <em>C #</em> did not write just lazy. <br><br><h2>  Pure <em>Haskell</em> I / O functions.  Operating principle </h2><br>  Suppose we (within some programming language) have a <code>beep,</code> function that returns the number 7 and displays the message ‚ÄúBeep!‚Äù And another function <code>returnBeep</code> , which simply returns the number 7. What can be said about the purity of these functions? <br><br>  At first glance, it seems that <code>returnBeep</code> clean, but <code>beep</code> is not: a pure function is a function that does not produce side effects, and in the latter case there is clearly a side effect. <br><br>  However, when using the pure <code>returnBeep</code> function in the program, it must be calculated, and side effects will also be present during the calculation, at least in the form of heat dissipated by computer.  But does this mean that the <code>returnBeep</code> function <code>returnBeep</code> ceased to be clean because of this?  This question can be answered in different ways and - just as in the case of the question "Do parallel lines intersect?" - any of the answers can be taken as an axiom and build on this consistent theory to create a model for some part of the surrounding world.  So we will accept as an axiom that the <em>features of the implementation of the calculator and, in particular, the side effects created by it when calculating the function do not affect the purity of the calculated function</em> . <br><br>  But from this it immediately follows that not only <code>returnBeep,</code> but also <code>beep,</code> is clean <code>beep,</code> since issuing a message does not affect the course of the program execution and therefore it is the same implementation feature of the calculator. <br><br>  In accordance with the foregoing, it is not impossible that, when executing a program consisting only of pure functions, what was to be deduced and what was to be read out ‚Äî that is, the computer behaved as if our computer programs have a side effect, although there is none.  Moreover, the provision of such activity is shifted from our shoulders - the shoulders of the application programmer - onto the shoulders of the developers of the artist;  that is, on the cumulative virtual shoulders of microprocessor developers, compilers, <em>Haskell</em> runtime, and so on. <br><br>  What remains to be done in the program code is to make sure that the necessary letters are displayed on the screen and find out which ones were entered.  And for this we will need a time machine and a parallel universe. <br><br>  The idea is to serialize the Universe (everything that was, is and will be), then encode (for convenience) on base64 and include in our program as a hard-coded string constant.  In fact, I‚Äôm not sure of the need for this set (time machine + parallel universe) or of its sufficiency.  However, in my opinion, it will not be possible to do without a parallel universe, since it will probably be more difficult than to write quin on the POSIX shell while it is in the universe itself. <br><br>  Of course, in order for a <em>Haskell</em> program (being a pure function) to pull information from a Universe constant related to a particular launch (instanta) of this program, it must take some kind of identifier for this instance as input.  And it really takes it - in the form of a value like <code>RealWorld</code> (see the already mentioned article <a href="https://wiki.haskell.org/IO_inside">IO inside</a> ).  Direct work with values ‚Äã‚Äãof this type in <em>Haskell is</em> impossible, but it is easy to turn a value of type <code>RealWorld</code> into a value of type <code>Integer,</code> <code>String</code> or any other, using the available standard functions.  The specific type and method of conversion depends on the encoding of the constant of the Universe and the implementation of I / O functions. <br><br>  Acting in this way, it will not be difficult to create a library of pure I / O functions.  Function signatures can be, for example, such (for simplicity, we restrict ourselves to the simplest console I / O lines): <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">getOutText</span></span> :: <span class="hljs-type"><span class="hljs-type">AppInstance</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IOIndex</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> getInText :: <span class="hljs-type"><span class="hljs-type">AppInstance</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IOIndex</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre><br>  The <code>getOutText</code> function accepts the application instance and the text number in the user and program dialog and returns the corresponding text output by the computer or <code>Nothing</code> if the input parameters are incorrect.  The result <code>Nothing</code> returned, for example, if the transferred number corresponds to the text entered by the user, and not to the text displayed by the computer.  So, if the specified instance of the program did not display anything, then for any value of the number <code>Nothing.</code> should be returned <code>Nothing.</code>  The <code>getInText</code> function takes the same arguments and returns the corresponding text entered by the user or <code>Nothing</code> . <br><br>  In fact, it turns out that instead of the <code>getOutText</code> function, <code>getOutText</code> more convenient to use the <code>getOutText</code> function, which is more limited but practical <code>isOutTextEquals</code> with the following signature and semantics: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">isOutTextEquals</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AppInstance</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IOIndex</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> isOutTextEquals text inst index = getOutText inst index == <span class="hljs-type"><span class="hljs-type">Just</span></span> text</code> </pre><br><h2>  Pure <em>Haskell</em> I / O functions <em>.</em>  Model implementation </h2><br>  Despite the fact that it is difficult to bring the ideas described above to the working code for our Universe, we can do this for a simple model universe. <br><br>  So, let there be some universe in which a certain creature named noname lives.  Noname is studying computer science at a university, and in order to pass the state programming exam, he needs to write a project ‚Äî a console program that asks the user for a name, reads the answer, and displays a greeting: <br><blockquote> <code>What is your name?</code> <br> <em><code></code></em> <br> <code>Hi, !</code> <br> </blockquote><br>  The only programming language in this universe is <em>Haskell</em> , and without the built-in support of the <code>IO</code> monad.  The program blank, created by noname, looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Main_ <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Vector (<span class="hljs-type"><span class="hljs-type">Vector</span></span>, (!?)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.ByteString.Lazy.UTF8 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> U <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.ByteString.Base64.Lazy worldBase64 :: String worldBase64 = "V29ybGQge2FwcEluc3RhbmNlcyA9IFtbSU9PcGVyYXRpb24gSU9Xcml0ZSAiV2hhdCBpcyB5b3Vy" ++ "IG5hbWU/CiIsSU9PcGVyYXRpb24gSU9SZWFkICJub25hbWUiLElPT3BlcmF0aW9uIElPV3JpdGUg" ++ "IkhpLCBub25hbWUhCiJdLFtJT09wZXJhdGlvbiBJT1dyaXRlICJXaGF0IGlzIHlvdXIgbmFtZT8K" ++ "IixJT09wZXJhdGlvbiBJT1JlYWQgIlwxMDQyXDEwNzJcMTA4OVwxMTAzIixJT09wZXJhdGlvbiBJ" ++ "T1dyaXRlICJIaSwgXDEwNDJcMTA3MlwxMDg5XDExMDMhCiJdLFtJT09wZXJhdGlvbiBJT1dyaXRl" ++ "ICJXaGF0IGlzIHlvdXIgbmFtZT8KIixJT09wZXJhdGlvbiBJT1JlYWQgIlwxMDU0XDEwODNcMTEw" ++ "MyIsSU9PcGVyYXRpb24gSU9Xcml0ZSAiSGksIFwxMDU0XDEwODNcMTEwMyEKIl1dfQo=" type AppInstance = Int type IOIndex = Int data IOAction = IORead | IOWrite deriving (<span class="hljs-type"><span class="hljs-type">Eq</span></span>, <span class="hljs-type"><span class="hljs-type">Show</span></span>, <span class="hljs-type"><span class="hljs-type">Read</span></span>) data IOOperation = IOOperation IOAction String deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>, <span class="hljs-type"><span class="hljs-type">Read</span></span>) data World = World { appInstances :: Vector (<span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">IOOperation</span></span>) } deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>, <span class="hljs-type"><span class="hljs-type">Read</span></span>) world :: World world = read $ U.toString $ decodeLenient $ U.fromString worldBase64 getInOutText :: IOAction -&gt; AppInstance -&gt; IOIndex -&gt; Maybe String getInOutText action app i = do IOOperation actual_action result &lt;- (!? <span class="hljs-title"><span class="hljs-title">i</span></span>) &lt;=&lt; (!? <span class="hljs-title"><span class="hljs-title">app</span></span>) $ appInstances world if actual_action == action then return result else Nothing getInText :: AppInstance -&gt; IOIndex -&gt; Maybe String getInText = getInOutText IORead getOutText :: AppInstance -&gt; IOIndex -&gt; Maybe String getOutText = getInOutText IOWrite isOutTextEquals :: String -&gt; AppInstance -&gt; IOIndex -&gt; Bool isOutTextEquals text inst index = getOutText inst index == Just text _main :: AppInstance -&gt; Maybe String _main app = do let question = "What is your name?\n" _ &lt;- if isOutTextEquals question app 0 then return () else Nothing name &lt;- getInText app 1 let greeting = "Hi, " ++ name ++ "!\n" _ &lt;- if isOutTextEquals greeting app 2 then return () else Nothing return $ question ++ name ++ "\n" ++ greeting</code> </pre><br></div></div><br>  For historical reasons, the main function and module in this universe are called, respectively, <code>Main_</code> and <code>_main</code> , and, as you can see, the <code>_main</code> function has the type <code>AppInstance -&gt; Maybe String</code> .  In the noname implementation, <code>_main</code> returns the dialog protocol ‚Äî this is not required by the conditions of the problem, but may be useful for debugging purposes. <br><br>  Noname checked the working capacity of the program, running it and entering its name - and the program seemed to work as it should - requested a name and in response to ‚Äúnoname‚Äù issued ‚ÄúHi, noname!‚Äù <br><br>  (As you can see in the program, there are no explicit indications of what exactly should be displayed on the screen and at what points to wait for user input, so the fact that this program is working is very indicative of the demonstration of the power of the heuristics inherent in <em>Haskell‚Äôs</em> standard noname universe). <br><br>  However, despite the fact that the program worked correctly during the first test run, noname is not sure that the program will continue to work: after all, he entered the test ‚Äúuniverse constant‚Äù ( <code>worldBase64</code> ) because it doesn‚Äôt know the real one.  Therefore, noname developed a time machine (of the original design, with a rather powerful paradoxes built-in) and contacted our Universe by transmitting the program listing and time machine drawings in exchange for the promise to provide it with the exact constant of its universe (more precisely, its parts). supposedly from here it is more visible, than to it from within. <br><br>  Run this Inovselenskaya program as it is, of course, will not work.  But if you equip it with the following starting module, then somehow it will work: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Environment <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Vector ((!?)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> V <span class="hljs-keyword"><span class="hljs-keyword">hiding</span></span> ((!?)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Main_ main :: IO () main = do args &lt;- V.fromList &lt;$&gt; getArgs case _main =&lt;&lt; read &lt;$&gt; (<span class="hljs-title"><span class="hljs-title">args</span></span> !? 0) of Just text -&gt; putStr text Nothing -&gt; putStrLn "Error!"</code> </pre><br></div></div><br>  (The complete project is on the githaba: <a href="https://github.com/A1-Triard/pure-io">pure-io</a> . By the way, if you still don‚Äôt know how to manage the <em>stack</em> build and dependency management tool that replaced <em>cabal</em> , here‚Äôs a good article: <a href="http://ruhaskell.org/posts/utils/2015/07/13/from-cabal-to-stack.html">Goodbye, cabal. Hello, stack!.</a> ) <br><br>  Of course, we will not see the ‚Äúdisplayed‚Äù messages, nor will we be able to enter a name, because we do not have a clever Inovselensky district time ‚Äî only the record of the corresponding dialog returned by the <code>_main</code> function will be available to us.  You will also have to manually transmit the launch number ( <code>AppInstance</code> ) as a command line argument, but this is enough to understand and model the functioning of this program in its real environment. <br><br>  Understanding the principle of the program and building a time machine according to the provided drawings, it is easy to make sure that <code>wordBase64</code> do not need to correct the <code>wordBase64</code> constant: the program will be run only three times (assuming the first test run), and the author will run it all three times, introducing the very names from the very beginning encoded in the text of the program! <br><br>  Having dealt with the principle of pure non-monadic I / O in this way and providing fraternal help to the noname alien, we move from the model universe to the real one and from <em>Haskell</em> to <em>C #</em> . <br><br><h2>  Pure I / O functions in <em>C #.</em>  Interface </h2><br>  Due to the presence of an executing mechanism, <em>C # is a</em> function that returns <code>X,</code> in fact, returns <code>Either Exception X</code> ;  in particular, the <code>void</code> functions "return" <code>Either Exception ().</code>  (By the way, in <em>Haskell the</em> situation is similar, and the conditional definition of the standard <code>IO</code> , taking into account the presence of exceptions, does not look like <code>type IO a = RealWorld -&gt; (RealWorld, a),</code> but rather like <code>type IO a = RealWorld -&gt; (RealWorld, Either SomeException a).</code> ). <br><br>  Considering the above situation with exceptions, we‚Äôll select these signature templates for our pure I / O functions: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertOutTextEquals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, AppInstance inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AppInstance inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  The <code>AssertOutTextEquals</code> function is the same <code>isOutTextEquals,</code> only instead of <code>True</code> it returns <code>void</code> without an expression, and instead of <code>False</code> throws an exception.  Similarly, the <code>GetInText</code> function either returns a non-zero string or throws an exception. <br><br>  These functions are pure, so we could express them through other pure functions (as was shown in the previous section), but instead we will go the other way.  Namely, we will create an equivalent native implementation - thanks to this, we will not need parallel universes and time machines. <br><br>  Let's see if it is possible to somehow refactor and improve the external syntax of these functions without violating the ideology.  You can make them non-static members of <code>AppInstance</code> , and also use something more idiomatic instead of <code>void</code> (for functional code): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">None</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> None _ { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } None() { } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppInstance</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> None </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertOutTextEquals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">publi </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  Using <code>None</code> instead of <code>void</code> will avoid unnecessary code duplication and make it easier to write the monad itself. <br><br>  Further, you will notice that the first function is the functional equivalent of <code>Console.Write(string),</code> and the second is <code>Console.ReadLine().</code>  In addition to these, there are many more useful input and output functions in the <code>Console</code> class and, using linq expressions, we can summarize our pure functions so as to support them all at once: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> None </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertOutTextEquals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression&lt;Action&gt; ioExpression, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression&lt;Func&lt;TResult&gt;&gt; ioExpression, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Finally, let's rearrange the parameters for convenience and give the methods the same short name to emphasize symmetry: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> None </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertIO</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, Expression&lt;Action&gt; ioExpression</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertIO</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, Expression&lt;Func&lt;TResult&gt;&gt; ioExpression</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  This unification is justified by the fact that if <code>None</code> were part of a standard ecosystem, instead of <code>Action</code> we would have <code>Func&lt;None&gt;</code> and the first function would disappear as a special case of the second. <br><br>  In order for us to write unit tests, it is necessary to provide for the possibility of working not only with a real console, but also with a test replacement: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppInstance</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Lazy&lt;AppInstance&gt; inst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lazy&lt;AppInstance&gt;(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppInstance((method, argTypes, args) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Console).GetMethod(method, BindingFlags.Static | BindingFlags.Public, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, argTypes, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).Invoke(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args))); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AppInstance </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inst.Value; } <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, Type[], <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[], <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; consoleDescriptor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Type[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; consoleDescriptor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.consoleDescriptor = consoleDescriptor; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppInstanceTestExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AppInstance </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForTests</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AppInstance inst, Func&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Type[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; consoleDescriptor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppInstance(consoleDescriptor); } }</code> </pre><br></div></div><br>  Prepare the test environment: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestFixture</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tests</span></span> { TestConsole console; AppInstance testInst; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span> { console = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestConsole(input); testInst = AppInstance.Get().ForTests((method, argTypes, args) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> call = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] { console, console.In, console.Out }.Select(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { t = x, m = x.GetType().GetMethod(method, argTypes) }).Where(x =&gt; xm != <span class="hljs-literal"><span class="hljs-literal">null</span></span>).First(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> call.m.Invoke(call.t, args); }); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestConsole</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> MemoryStream output; StreamWriter writer; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> MemoryStream input; StreamReader reader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestConsole</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.input = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream(Encoding.UTF8.GetBytes(input)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.input); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamWriter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.output); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TextWriter Out { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> writer; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TextReader In { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reader; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Output { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(writer != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { writer.Close(); writer = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Encoding.UTF8.GetString(output.ToArray()); } } }</code> </pre><br></div></div><br><h2>  Pure I / O functions in <em>C #.</em>  Tests </h2><br>  Let's start with the simple: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteChars</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Setup(<span class="hljs-string"><span class="hljs-string">""</span></span>); testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">0</span></span>, () =&gt; Console.Write(<span class="hljs-string"><span class="hljs-string">'A'</span></span>)); testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">1</span></span>, () =&gt; Console.Write(<span class="hljs-string"><span class="hljs-string">'B'</span></span>)); Assert.AreEqual(<span class="hljs-string"><span class="hljs-string">"AB"</span></span>, console.Output); }</code> </pre><br>  Note that not only the performance of the pure <code>AssertIO,</code> function is <code>AssertIO,</code> but also the side effects: the code says <code>... Write('A') ... Write('B') ...,</code> and it is expected that the screen will be displayed "AB". <br><br>  Let's try something more interesting.  For example, swap <code>AssertIO.</code> calls <code>AssertIO.</code>  Since <code>AssertIO</code> is a pure function, it would seem that the result (the absence of exceptions) should not change.  But this is not the case: this is a different test, there is another AppInstance in it, and therefore the result <em>may</em> change (although it may not change).  In practice, it turns out that in this case nothing is output: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteCharsInBackOrder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Setup(<span class="hljs-string"><span class="hljs-string">""</span></span>); Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">1</span></span>, () =&gt; Console.Write(<span class="hljs-string"><span class="hljs-string">'B'</span></span>))); Assert.Throws&lt;ArgumentOutOfRangeException&gt;(() =&gt; testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">0</span></span>, () =&gt; Console.Write(<span class="hljs-string"><span class="hljs-string">'A'</span></span>))); Assert.AreEqual(<span class="hljs-string"><span class="hljs-string">""</span></span>, console.Output); }</code> </pre><br>  A pure function must return the same result on the same set of arguments: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteCharTwice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Setup(<span class="hljs-string"><span class="hljs-string">""</span></span>); testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">0</span></span>, () =&gt; Console.Write(<span class="hljs-string"><span class="hljs-string">'A'</span></span>)); testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">0</span></span>, () =&gt; Console.Write(<span class="hljs-string"><span class="hljs-string">'A'</span></span>)); Assert.Throws&lt;ArgumentException&gt;(() =&gt; testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">0</span></span>, () =&gt; Console.Write(<span class="hljs-string"><span class="hljs-string">'B'</span></span>))); Assert.AreEqual(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, console.Output); }</code> </pre><br>  If the output failed for some reason, we should get an error in the form of an exception: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWriteError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Setup(<span class="hljs-string"><span class="hljs-string">""</span></span>); console.Out.Close(); Assert.Throws&lt;AggregateException&gt;(() =&gt; testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">0</span></span>, () =&gt; Console.Write(<span class="hljs-string"><span class="hljs-string">'A'</span></span>))); Assert.Throws&lt;ArgumentException&gt;(() =&gt; testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">0</span></span>, () =&gt; Console.Write(<span class="hljs-string"><span class="hljs-string">'B'</span></span>))); }</code> </pre><br>  We also need at least one reading test: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadChar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Setup(<span class="hljs-string"><span class="hljs-string">"123"</span></span>); Assert.AreEqual((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)<span class="hljs-string"><span class="hljs-string">'1'</span></span>, testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">0</span></span>, () =&gt; Console.Read())); Assert.AreEqual((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)<span class="hljs-string"><span class="hljs-string">'2'</span></span>, testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">1</span></span>, () =&gt; Console.Read())); Assert.AreEqual((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)<span class="hljs-string"><span class="hljs-string">'3'</span></span>, testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">2</span></span>, () =&gt; Console.Read())); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">-1</span></span>, testInst.AssertIO(<span class="hljs-number"><span class="hljs-number">3</span></span>, () =&gt; Console.Read())); }</code> </pre><br><h2>  Pure I / O functions in <em>C #.</em>  Implementation </h2><br>  Let's write an auxiliary class that will parse the passed linq expression and make a real call to the specified method with the specified parameters, using the passed <code>consoleDescriptor</code> : <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IOOperation</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TResult</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> method; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Type[] argTypes; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] args; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IOOperation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LambdaExpression callExpression</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodExpr = (MethodCallExpression)callExpression.Body; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.args = methodExpr.Arguments.Select(x =&gt; Expression.Lambda&lt;Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;(Expression.Convert(x, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>))).Compile()()).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method = methodExpr.Method.Name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.argTypes = methodExpr.Method.GetParameters().Select(x =&gt; x.ParameterType).ToArray(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Type[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; consoleDescriptor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TResult)consoleDescriptor(method, argTypes, args); } }</code> </pre><br></div></div><br>  To track identical calls (as in the <code>WriteCharTwice</code> test), it is convenient to block Equals: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(IOOperation&lt;TResult&gt; a, IOOperation&lt;TResult&gt; b) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> aIsNull = ReferenceEquals(a, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bIsNull = ReferenceEquals(b, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aIsNull &amp;&amp; bIsNull || !aIsNull &amp;&amp; !bIsNull &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Equals(a.method, b.method, StringComparison.Ordinal) &amp;&amp; a.args.Length == b.args.Length &amp;&amp; !a.args.Zip(b.args, Equals).Where(x =&gt; !x).Any(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> method.GetHashCode() ^ args.Length; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> !=(IOOperation&lt;TResult&gt; a, IOOperation&lt;TResult&gt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(a == b); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == obj <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IOOperation&lt;TResult&gt;; }</code> </pre><br></div></div><br>  Now we can reduce two <code>AssertIO</code> methods to one: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> None </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertIO</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, Expression&lt;Action&gt; ioExpression</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssertIO(index, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOOperation&lt;None&gt;(ioExpression)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TResult AssertIO&lt;TResult&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index, Expression&lt;Func&lt;TResult&gt;&gt; ioExpression) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssertIO(index, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOOperation&lt;TResult&gt;(ioExpression)); } TResult AssertIO&lt;TResult&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index, IOOperation&lt;TResult&gt; operation);</code> </pre> <br>  It remains to implement the last method - and it's done. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is clear that we need to somehow cache the results of our calls to the native console. </font><font style="vertical-align: inherit;">Add the necessary classes and fields:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;IOOperationWithResult&gt; completedOperations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;IOOperationWithResult&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IOOperationResult</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IOOperationResult</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TResult</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IOOperationResult</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TResult returnValue; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Exception exception; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IOOperationResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;TResult&gt; getResult</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { returnValue = getResult(); exception = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception e) { returnValue = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(TResult); exception = e; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TResult Result { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(exception != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AggregateException(exception); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnValue; } } } <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IOOperationWithResult</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IOOperationWithResult</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TResult</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IOOperationWithResult</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IOOperationWithResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOOperation&lt;TResult&gt; operation, IOOperationResult&lt;TResult&gt; result</span></span></span><span class="hljs-function">)</span></span> { Operation = operation; Result = result; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IOOperation&lt;TResult&gt; Operation; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IOOperationResult&lt;TResult&gt; Result; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having done the preliminary work, you can finally write the actual </font></font><code>AssertIO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> rejectOperations = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TResult AssertIO&lt;TResult&gt;(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index, IOOperation&lt;TResult&gt; operation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(index &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentOutOfRangeException(<span class="hljs-string"><span class="hljs-string">"index"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(index &lt; completedOperations.Count) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completedOperation = completedOperations[index] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IOOperationWithResult&lt;TResult&gt;; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(completedOperation == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || completedOperation.Operation != operation) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"operation"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> completedOperation.Result.Result; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rejectOperations) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentOutOfRangeException(<span class="hljs-string"><span class="hljs-string">"index"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(index == completedOperations.Count) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completedOperation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOOperationWithResult&lt;TResult&gt;(operation, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOOperationResult&lt;TResult&gt;(() =&gt; operation.Do(consoleDescriptor))); completedOperations.Add(completedOperation); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> completedOperation.Result.Result; } rejectOperations = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentOutOfRangeException(<span class="hljs-string"><span class="hljs-string">"index"</span></span>); }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algorithm is simple. If a request comes in on the result of an operation that has already been performed, then we crawl and check IOOperation. If we have a complete match, it means that the specified method was actually called with the specified parameters, and we return the result; and if there is a difference - raising is quick. Further, if there is no operation in the cache and now is just the right time to execute it, we perform the operation, add the result to the cache along with the result, and return the result. If there is no operation in the cache and a time machine is required for its execution, nothing good will come out, so it remains to fall, having previously raised a special flag </font></font><code>rejectOperations,</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will ensure the consistency of the method's behavior during further calls.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Such a simple implementation behaves in the same way as a possible implementation on pure functions, and ensures that written (and unwritten) tests pass. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Monad </font></font><code>IO</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have pure non-monadic I / O functions, writing a monad </font></font><code>IO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is easy:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IO</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Func&lt;RealWorld, Tuple&lt;RealWorld, T&gt;&gt; func; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IO</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;RealWorld, Tuple&lt;RealWorld, T&gt;&gt; func</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.func = func; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> RealWorld </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RealWorld index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultTuple = func(index); result = resultTuple.Item2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resultTuple.Item1; } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RealWorld</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> AppInstance inst; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RealWorld</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AppInstance inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inst = inst; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.index = index; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Tuple&lt;RealWorld, None&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression&lt;Action&gt; callExpression</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tuple.Create(Yield(), inst.AssertIO(index, callExpression)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Tuple&lt;RealWorld, TResult&gt; Do&lt;TResult&gt;(Expression&lt;Func&lt;TResult&gt;&gt; callExpression) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tuple.Create(Yield(), inst.AssertIO(index, callExpression)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RealWorld </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Yield</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RealWorld(inst, index + <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can even support the </font><font style="vertical-align: inherit;">special monadic syntax </font><font style="vertical-align: inherit;">available in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C #</font></font></em><font style="vertical-align: inherit;"></font><code>(from ... in ... select ...).</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To do this, besides our custom methods </font></font><code>Return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you </font></font><code>Do</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will need to implement the methods </font></font><code>Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>SelectMany</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(they should be called that way and have a certain signature - duck typing works):</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IO</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IO&lt;T&gt; Return&lt;T&gt;(T <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IO&lt;T&gt;(x =&gt; Tuple.Create(x, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IO&lt;R&gt; Select&lt;T, R&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IO&lt;T&gt; io, Func&lt;T, R&gt; selector) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IO&lt;R&gt;(x =&gt; { T t; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = io.Execute(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tuple.Create(index, selector(t)); }); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IO&lt;R&gt; SelectMany&lt;T, C, R&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IO&lt;T&gt; io, Func&lt;T, IO&lt;C&gt;&gt; selector, Func&lt;T, C, R&gt; projector) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IO&lt;R&gt;(x =&gt; { T t; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = io.Execute(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> t); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ioc = selector(t); C c; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultIndex = ioc.Execute(index, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> c); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tuple.Create(resultIndex, projector(t, c)); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IO&lt;None&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Do</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression&lt;Action&gt; callExpression</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IO&lt;None&gt;(x =&gt; x.Do(callExpression)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IO&lt;TResult&gt; Do&lt;TResult&gt;(Expression&lt;Func&lt;TResult&gt;&gt; callExpression) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IO&lt;TResult&gt;(x =&gt; x.Do(callExpression)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IO&lt;T&gt; Handle&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IO&lt;T&gt; io, Func&lt;Exception, IO&lt;T&gt;&gt; handler) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IO&lt;T&gt;(x =&gt; { RealWorld rw; T t; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { rw = io.Execute(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> t); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception e) { rw = handler(e).Execute(x.Yield(), <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> t); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tuple.Create(rw, t); }); } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the above, we have added a very useful method </font></font><code>Handle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that allows you to continue working when an event occurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You will also need a ‚Äúmonadic‚Äù entry point to the application:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppInstanceIOExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AppInstance inst, Func&lt;IO&lt;None&gt;&gt; body</span></span></span><span class="hljs-function">)</span></span> { None result; body().Execute(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RealWorld(inst, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> result); } }</code> </pre><br><h2>  Demonstration of the result </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's write the simplest console application using the monad </font></font><code>IO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { AppInstance.Get().DoMain(IOMain); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IO&lt;None&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IOMain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> IO.Do(() =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"What is your name?"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> IO.Do(() =&gt; Console.ReadLine()) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">"Hi, "</span></span> + name + <span class="hljs-string"><span class="hljs-string">"!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> IO.Do(() =&gt; Console.WriteLine(message)) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> r; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of the work: The </font></font><br><br><img src="https://habrastorage.org/files/448/1c2/155/4481c2155c4448c58e9d3f4a1e56250e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">full code on the githaba: </font></font><a href="https://github.com/A1-Triard/IOMonad"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOMonad</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/282940/">https://habr.com/ru/post/282940/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282930/index.html">Smart or virtual hardware drivers</a></li>
<li><a href="../282932/index.html">About the usefulness of indexes by expressions</a></li>
<li><a href="../282934/index.html">Easy Hack: Java application</a></li>
<li><a href="../282936/index.html">Efficient Rails - a new book on optimizing the development of Rails applications</a></li>
<li><a href="../282938/index.html">Redmine: Migration from MySQL to PostgreSQL 9.5</a></li>
<li><a href="../282944/index.html">About order management on the new 1C-Bitrix platform</a></li>
<li><a href="../282946/index.html">Quick transition to a new platform</a></li>
<li><a href="../282948/index.html">Component "Ordering" in the new version of the platform "1C-Bitrix" (part 1)</a></li>
<li><a href="../282950/index.html">5 worthy exploring open source projects at React Native</a></li>
<li><a href="../282954/index.html">Component "Ordering" in the new version of the platform "1C-Bitrix" (part 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>