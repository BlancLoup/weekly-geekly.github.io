<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Threads, locks, and condition variables in C ++ 11 [Part 1]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first part of this article will focus on threads and locks in C ++ 11, conditional variables in all their glory will be discussed in detail in the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Threads, locks, and condition variables in C ++ 11 [Part 1]</h1><div class="post__text post__text-html js-mediator-article">  The first part of this article will focus on threads and locks in C ++ 11, conditional variables in all their glory will be discussed in detail in the <a href="http://habrahabr.ru/post/182626/">second part</a> ... <a name="habracut"></a><br><br><h4>  Streams </h4><br>  In C ++ 11, work with threads is done using the methods of the <code>std::thread</code> class (available from the <code>&lt;thread&gt;</code> header file), which can work with regular functions, lambdas and functors.  In addition, it allows you to pass any number of parameters to a stream function. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;thread&gt; void threadFunction() { // do smth } int main() { std::thread thr(threadFunction); thr.join(); return 0; }</span></span></span></span></code> </pre><br>  In this example, <code>thr</code> is an object representing the thread in which the <code>threadFunction()</code> function will be executed.  A call to <code>join</code> blocks the calling thread (in our case, the main thread) until <code>thr</code> (or rather <code>threadFunction()</code> ) does its work.  If the stream function returns a value, it will be ignored.  However, the function can accept any number of parameters. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">threadFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span> &lt;&lt; d &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(threadFunction, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2.34</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"example"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; thr.join(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Although you can pass any number of parameters, they were all passed by value. If you need to pass parameters to a function by reference, they must be wrapped in <code>std::ref</code> or <code>std::cref</code> , as in the example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">threadFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;a)</span></span></span><span class="hljs-function"> </span></span>{ a++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(threadFunction, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ref(a))</span></span></span></span>; thr.join(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The program prints to console 2. If you do not use <code>std::ref</code> , the result of the program will be 1. <br><br>  In addition to the <code>join</code> method, you should consider another, a similar method - <code>detach</code> . <br>  <code>detach</code> allows you to disconnect the stream from the object, in other words, to make it background.  <code>join</code> can no longer be applied to detached threads. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(threadFunction)</span></span></span></span>; thr.detach(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  It should also be noted that if the stream function throws an exception, it will not be caught by the try-catch block.  Those.  The following code will not work (it will work more precisely, but not as it was intended: without intercepting exceptions): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thr1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(threadFunction)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thr2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(threadFunction)</span></span></span></span>; thr1.join(); thr2.join(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;ex) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ex.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  To pass exceptions between threads, you need to catch them as a stream function and store them somewhere in order to access them later. <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex g_mutex; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception_ptr&gt; g_exceptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throw_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(<span class="hljs-string"><span class="hljs-string">"something wrong happened"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">threadFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { throw_function(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(g_mutex); g_exceptions.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::current_exception()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ g_exceptions.clear(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(threadFunction)</span></span></span></span>; thr.join(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;e: g_exceptions) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(e != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::rethrow_exception(e); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Before moving on, I want to point out some useful functions provided by <code>&lt;thread&gt;</code> in the <code>std::this_thread</code> : <br><ul><li>  <a href="http://en.cppreference.com/w/cpp/thread/get_id">get_id</a> : returns the id of the current thread </li><li>  <a href="http://en.cppreference.com/w/cpp/thread/yield">yield</a> : tells the scheduler to execute other threads, can be used while actively waiting </li><li>  <a href="http://en.cppreference.com/w/cpp/thread/sleep_for">sleep_for</a> : blocks the execution of the current thread for a set period </li><li>  <a href="http://en.cppreference.com/w/cpp/thread/sleep_until">sleep_until</a> : blocks the execution of the current thread until the specified point in time is reached </li></ul><br><h4>  Locks </h4><br>  In the last example, I had to synchronize access to the <code>g_exceptions</code> vector to make sure that only one thread could insert a new item at a time.  For this, I used a mutex and a lock on the mutex.  The mutex is a basic synchronization element and in C ++ 11 is presented in 4 forms in the <code>&lt;mutex&gt;</code> header file: <br><ul><li>  <a href="http://en.cppreference.com/w/cpp/thread/mutex">mutex</a> : provides the basic functions <a href="http://en.cppreference.com/w/cpp/thread/mutex/lock">lock ()</a> and <a href="http://en.cppreference.com/w/cpp/thread/mutex/unlock">unlock ()</a> and a non-blocking method <a href="http://en.cppreference.com/w/cpp/thread/mutex/try_lock">try_lock ()</a> </li><li>  <a href="http://en.cppreference.com/w/cpp/thread/recursive_mutex">recursive_mutex</a> : can enter "in itself" </li><li>  <a href="http://en.cppreference.com/w/cpp/thread/timed_mutex">timed_mutex</a> : unlike the usual mutex, it has two more methods: <a href="http://en.cppreference.com/w/cpp/thread/timed_mutex/try_lock_for">try_lock_for ()</a> and <a href="http://en.cppreference.com/w/cpp/thread/timed_mutex/try_lock_until">try_lock_until ()</a> </li><li>  <a href="http://en.cppreference.com/w/cpp/thread/recursive_timed_mutex">recursive_timed_mutex</a> : this is a combination of timed_mutex and recursive_mutex </li></ul><br>  I will give an example of using <code>std::mutex</code> with the help functions <code>get_id()</code> and <code>sleep_for()</code> mentioned earlier: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;chrono&gt; #include &lt;thread&gt; #include &lt;mutex&gt; std::mutex g_lock; void threadFunction() { g_lock.lock(); std::cout &lt;&lt; "entered thread " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(rand()%10)); std::cout &lt;&lt; "leaving thread " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; g_lock.unlock(); } int main() { srand((unsigned int)time(0)); std::thread t1(threadFunction); std::thread t2(threadFunction); std::thread t3(threadFunction); t1.join(); t2.join(); t3.join(); return 0; }</span></span></span></span></code> </pre><br>  The program should produce something like the following: <br><pre> <code class="bash hljs">entered thread 10144 leaving thread 10144 entered thread 4188 leaving thread 4188 entered thread 3424 leaving thread 3424</code> </pre><br>  Before accessing shared data, the mutex must be locked by the <code>lock</code> method, and after finishing working with shared data it must be unlocked. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The following example shows a simple thread-safe container (implemented on the basis of <code>std::vector</code> ), having <code>add()</code> methods for adding one element and <code>addrange()</code> for adding several elements. <br>  <i>Note</i> : yet this container is not completely thread-safe for several reasons, including the use of <code>va_args</code> .  Also, the <code>dump()</code> method should not belong to the container, but should be an autonomous function.  The purpose of this example is to show the basic concepts of using mutexes, and not to make a full-fledged, error-free, thread-safe container. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex _lock; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; _elements; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T element)</span></span></span><span class="hljs-function"> </span></span>{ _lock.lock(); _elements.push_back(element); _lock.unlock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addrange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, ...)</span></span></span><span class="hljs-function"> </span></span>{ va_list arguments; va_start(arguments, num); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num; i++) { _lock.lock(); add(va_arg(arguments, T)); _lock.unlock(); } va_end(arguments); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _lock.lock(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> e: _elements) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _lock.unlock(); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">threadFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(container&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;c)</span></span></span><span class="hljs-function"> </span></span>{ c.addrange(<span class="hljs-number"><span class="hljs-number">3</span></span>, rand(), rand(), rand()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)time(<span class="hljs-number"><span class="hljs-number">0</span></span>)); container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; cntr; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(threadFunction, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ref(cntr))</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(threadFunction, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ref(cntr))</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(threadFunction, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ref(cntr))</span></span></span></span>; t1.join(); t2.join(); t3.join(); cntr.dump(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  When executing this program, <b>deadlock</b> will occur (deadlock, i.e., the blocked thread will remain to wait).  The reason is that the container tries to get the mutex several times before it is released (calling <code>unlock</code> ), which is impossible.  This is where <code>std::recursive_mutex</code> comes on stage, which allows you to get the same mutex several times.  The maximum number of receiving mutexes is not defined, but if this number is reached, <code>lock</code> will throw an exception <a href="http://en.cppreference.com/w/cpp/error/system_error">std :: system_error</a> .  Therefore, the solution to the problem in the code above (except for changing the implementation of <code>addrange()</code> so that <code>lock</code> and <code>unlock</code> not called) is to replace the mutex with <code>std::recursive_mutex</code> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex _lock; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre><br>  Now, the result of the program will be as follows: <br><pre> <code class="bash hljs">6334 18467 41 6334 18467 41 6334 18467 41</code> </pre><br>  You probably noticed that when you call <code>threadFunction()</code> , the same numbers are generated.  This is because the <code>void srand (unsigned int seed);</code> function <code>void srand (unsigned int seed);</code>  initializes the <code>seed</code> only for the main thread.  In other threads, the pseudo-random number generator is not initialized and the same numbers are obtained each time. <br>  Explicit locking and unlocking can lead to errors, for example, if you forget to unblock the stream or, conversely, there will be an incorrect order of locks - all this will cause deadlock.  Std provides several classes and functions to solve this problem. <br>  The wrapper classes allow you to consistently use a mutex in the <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> style with automatic locking and unlocking within a single block.  These classes are: <br><ul><li>  <a href="http://en.cppreference.com/w/cpp/thread/lock_guard">lock_guard</a> : when an object is created, it tries to get a mutex (by calling <code>lock()</code> ), and when an object is destroyed, it automatically releases the mutex (by calling <code>unlock()</code> ) </li><li>  <a href="http://en.cppreference.com/w/cpp/thread/unique_lock">unique_lock</a> : unlike <code>lock_guard</code> , also supports pending locking, temporary locking, recursive locking, and using conditional variables </li></ul><br>  With this in mind, we can rewrite the container class as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex _lock; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; _elements; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex&gt; locker(_lock); _elements.push_back(element); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addrange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num, ...)</span></span></span><span class="hljs-function"> </span></span>{ va_list arguments; va_start(arguments, num); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num; i++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex&gt; locker(_lock); add(va_arg(arguments, T)); } va_end(arguments); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex&gt; locker(_lock); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> e: _elements) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br>  One can argue that the <code>dump()</code> method must be constant, because it does not change the state of the container.  Try to make it so and get an error when compiling: <br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'std::lock_guard&lt;_Mutex&gt;::lock_guard(_Mutex &amp;)'</span></span> : cannot convert parameter <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-string"><span class="hljs-string">'const std::recursive_mutex'</span></span> to <span class="hljs-string"><span class="hljs-string">'std::recursive_mutex &amp;'</span></span></code> </pre><br>  A mutex (regardless of the implementation form) must be retrieved and released, which implies the use of non-constant <code>lock()</code> and <code>unlock()</code> methods.  Thus, the <code>lock_guard</code> argument cannot be a constant.  The solution to this problem is to make the <code>mutable</code> , then the const specifier will be ignored and this will allow changing the state from constant functions. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex _lock; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; _elements; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::recursive_mutex&gt; locker(_lock); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> e: _elements) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br>  Wrap class constructors can take a parameter that defines a blocking policy: <br><ul><li>  <code>defer_lock</code> type <code>defer_lock_t</code> : do not receive mutex </li><li>  <code>try_to_lock</code> type <code>try_to_lock_t</code> : try to get a mutex without blocking </li><li>  <code>adopt_lock</code> type <code>adopt_lock_t</code> : it is assumed that the calling thread already has a mutex </li></ul><br>  They are announced as follows: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">defer_lock_t</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">try_to_lock_t</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">adopt_lock_t</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">defer_lock_t</span></span> defer_lock = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">defer_lock_t</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">try_to_lock_t</span></span> try_to_lock = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">try_to_lock_t</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">adopt_lock_t</span></span> adopt_lock = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">adopt_lock_t</span></span>();</code> </pre><br>  In addition to ‚Äúwrappers‚Äù for mutexes, <code>std</code> also provides several methods for locking one or more mutexes: <br><ul><li>  <a href="http://en.cppreference.com/w/cpp/thread/lock">lock</a> : locks the mutex using the deadlock avoidance algorithm (using <code>lock()</code> , <code>try_lock()</code> and <code>unlock()</code> ) </li><li>  <a href="http://en.cppreference.com/w/cpp/thread/try_lock">try_lock</a> : tries to block mutexes in the order in which they were specified </li></ul><br>  Here is a typical example of a deadlock: we have a container with elements and the <code>exchange()</code> function that swaps two elements of different containers.  For thread safety, the function synchronizes access to these containers, getting the mutex associated with each container. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex _lock; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;T&gt; _elements; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T element)</span></span></span><span class="hljs-function"> </span></span>{ _elements.insert(element); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T element)</span></span></span><span class="hljs-function"> </span></span>{ _elements.erase(element); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(container&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;c1, container&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ c1._lock.lock(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::sleep_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  deadlock c2._lock.lock(); c1.remove(value); c2.add(value); c1._lock.unlock(); c2._lock.unlock(); }</span></span></code> </pre><br>  Suppose that this function is called from two different threads, from the first thread: the element is removed from 1 container and added to 2, from the second stream, on the contrary, the element is removed from 2 container and added to 1. This may cause a deadlock (if the context of the thread switches from one thread to another, immediately after the first lock). <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)); container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; cntr1; cntr1.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); cntr1.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); cntr1.add(<span class="hljs-number"><span class="hljs-number">3</span></span>); container&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; cntr2; cntr2.add(<span class="hljs-number"><span class="hljs-number">4</span></span>); cntr2.add(<span class="hljs-number"><span class="hljs-number">5</span></span>); cntr2.add(<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exchange, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ref(cntr1), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ref(cntr2), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exchange, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ref(cntr2), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ref(cntr1), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; t1.join(); t2.join(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  To solve this problem, you can use <code>std::lock</code> , which guarantees locking in a safe (in terms of deadlock) way: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(container&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;c1, container&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock(c1._lock, c2._lock); c1.remove(value); c2.add(value); c1._lock.unlock(); c2._lock.unlock(); }</code> </pre><br>  <i>Continued</i> : <a href="http://habrahabr.ru/post/182626/">conditional variables</a> </div><p>Source: <a href="https://habr.com/ru/post/182610/">https://habr.com/ru/post/182610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182598/index.html">Assembler for brainfuck</a></li>
<li><a href="../182600/index.html">Development of a content application for iOS, attack Russian App Store</a></li>
<li><a href="../182604/index.html">PocketBook Touch 2 - reader with E-Ink Pearl and sensor</a></li>
<li><a href="../182606/index.html">Photos of workplaces habrazhiteli</a></li>
<li><a href="../182608/index.html">Real-Time UIKit Inspector (Reveal App)</a></li>
<li><a href="../182612/index.html">Silicone Skeleton - Silex tuned</a></li>
<li><a href="../182614/index.html">Qt Graphics Framework - the dark side. Part 1</a></li>
<li><a href="../182620/index.html">Exploring JavaScript Generators</a></li>
<li><a href="../182622/index.html">Video: New software development and testing offers for MSDN subscribers and other Windows Azure news</a></li>
<li><a href="../182626/index.html">Threads, locks, and condition variables in C ++ 11 [Part 2]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>