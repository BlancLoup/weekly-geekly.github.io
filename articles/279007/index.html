<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Crutch for the signal-slot system in Qt</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all. I want to tell you about this ... About two weeks ago, for the first time, I had to work with GUI using C ++ and, after a little googlin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Crutch for the signal-slot system in Qt</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a35/754/d5c/a35754d5cac944259cacbc0b050eedd2.png"><br><br>  Hello to all.  I want to tell you about this ... About two weeks ago, for the first time, I had to work with GUI using C ++ and, after a little googling, I decided to use Qt.  He was all terribly praised, and indeed at first glance he looked very dignified. <br><br>  At a second glance, Qt turned out to be a good fit too, but due to some limitations in the implementation of its method-object compiler, I had to construct small crutches.  In this essay (I think the word ‚Äúessay‚Äù will fit better, because it doesn‚Äôt draw on the article in terms of volume) I want to talk about how I solved the problems that arise. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Added:</b> Based on the comments of good people, an edit was made that tells how you can do without MOC and without crutches at all. <br><br><a name="habracut"></a><br><br><h3>  How it all began </h3><br><br>  It all started with the fact that I needed to make a template controller class as part of the implementation of the MVC architecture in my library.  The controller had to interact with heterogeneous integer data, associating <a href="http://doc.qt.io/qt-4.8/qspinbox.html">QSpinBox</a> with them as a GUI.  If we discard any husk, something like this happened: <br><br><div class="spoiler">  <b class="spoiler_title">Sample controller</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_IntegralType &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegralController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: T_IntegralType *_modelField; QSpinBox *_view; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">QSpinBox *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_view) { _view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QSpinBox(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _view; } . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ,        void setValue(T_IntegralType inValue) { * modelField = inValue; } };</span></span></code> </pre> <br></div></div><br><br>  Having scribbled the code, I read about event handling in Qt, and realized that to work with events in general and with events from GUI elements in particular, I need to use a system of <a href="http://doc.qt.io/qt-4.8/signalsandslots.html">signals and slots</a> (this system is well analyzed in <a href="https://habrahabr.ru/post/214379/">this article</a> - it seems this is a translation of the official docks) . <br><br><div class="spoiler">  <b class="spoiler_title">A note about the model-view approach</b> <div class="spoiler_text">  There is still such a thing as a delegate system within the <a href="http://doc.qt.io/qt-4.8/model-view-programming.html">model-view approach</a> in Qt, which allows you to handle the transfer of data between the view and model through the implementation of interfaces, without a signal-slot system.  For some reason, I was not able to properly use model-view Qt in my library. <br></div></div><br><br>  In order for a class to provide slots for a signal-slot system, it was necessary that this class inherit from the <i>QObject</i> class and include the <i>Q_OBJECT</i> macro.  What for?  Then I did not steamed in order to understand.  It is necessary - it means it is necessary.  Without further ado, I added the required things to my template class and described the implementation of GUI event handling: <br><br><div class="spoiler">  <b class="spoiler_title">Template controller with event handling</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_IntegralType &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegralController</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: T_IntegralType *_modelField; QSpinBox *_view; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">QSpinBox *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_view) { _view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QSpinBox(); QObject::connect(_view, SIGNAL(valueChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(valueChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); } } . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> slots: <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> valueChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inValue) { *_modelField = inValue; } };</code> </pre><br></div></div><br><br>  All gathered.  Great, I thought, what a fine fellow I am!  - and continued to saw the library, for a time having forgotten about this template controller.  Of course, in vain I hurried and generally rejoiced early, for he was not a good fellow.  As soon as I tried to collect the code that uses the specialization of the template controller, the linker‚Äôs error messages fell down like this: <br><br><div class="spoiler">  <b class="spoiler_title">Link errors</b> <div class="spoiler_text"><pre> unresolved external symbol "public: virtual struct QMetaObject const * __cdecl TClass &lt;int&gt; :: metaObject (void) const" (? metaObject @? $ TClass @ H @@ UEBAPEBUQMetaObject @@ XZ)<font></font>
<font></font>
 unresolved external symbol "public: virtual void * __cdecl TClass &lt;int&gt; :: qt_metacast (char const *)" (? qt_metacast @? $ TClass @ H @@ UEAAPEAXPEBD @ Z)<font></font>
<font></font>
 unresolved external symbol "public: virtual int __cdecl TClass &lt;int&gt; :: qt_metacall (enum QMetaObject :: Call, int, void * *)" (? qt_metacall @? $ TClass @ H @@ UEAAHW4Call @ QMetaObject @@ HPEAPEAX @ Z)
</pre><br></div></div><br><br>  It was obvious that I was doing something wrong with the meta-object system.  I had to reread about <a href="http://doc.qt.io/qt-4.8/moc.html">MOC</a> .  The point was that MOC, when traversed by source, generates additional cpp-files in which the implementation of the methods necessary for the meta-object of the system is created.  With templates, this system can work very crookedly, poorly generating this very meta-object code ‚Äî the MOC either simply ignores the template classes when generating code, or treats them as normal classes, discarding template arguments, which for obvious reasons caused the above problems. <br><br><div class="spoiler">  <b class="spoiler_title">More about templates and Qt</b> <div class="spoiler_text">  There is even a <a href="http://doc.qt.io/qt-4.8/templates.html">separate article</a> in the dock about why you should not use templates with the signal-slot system.  Unfortunately, in my case it was not about optimality, but about a decent reduction in the amount of code and avoiding a large amount of save-paste - so the points from this article were not suitable for me. <br></div></div><br><br>  Upon further acquaintance with MOC, it was discovered that there are still several restrictions on the use of classes under the control of MOC.  The most unpleasant of them is the impossibility of describing fully-qualified MOC QObject heirs in nested classes.  And I love to do nested classes, breaking the areas of responsibility of a large class between the smaller classics living inside it.  Yes, I know, labor programmers use namespaces, but at the same time, in my opinion, the program context is cluttered up, and the semantics of nested classes differ from the semantics of namespaces (in the first case we build a hierarchy of relations between classes, in the second we simply group them by what - feature). <br><br>  In general, given that I only needed the ability to subscribe to events through the static <i>QObject :: connect (...)</i> method, I decided to write a small crutch ... Just a small, small crutch. <br><br>  <u><b>Note:</b></u> Kostylyk, as it turned out, turned out for the Qt version below the fifth, where the crooked MOC ruled.  Qt 5 has a cool API that allows signal slots without this very MOC.  <a href="https://habr.com/ru/post/279007/">Added</a> this information at the end of the article.  Again, the moral for me, a lazy author of articles, who is not at all well done: <i>google seven times, write an article once</i> . <br><br><h3>  About crutch </h3><br><br>  The idea was simple - to make a mini-class that would inherit a <i>QObject</i> and would be fully suitable for the MOC in the sense of registering a class for correct operation within the signal-slot system.  This mini-class would also provide a method for associating a Qt-independent callback with a slot call in this auxiliary class. <br><br>  Sounds complicated, the example will be clearer, I hope.  In the event handling code from <i>QSpinBox,</i> it looked like this: <br><br><div class="spoiler">  <b class="spoiler_title">Crutchik for events from QSpinBox</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueChangedWorkaround</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// -,  .     //  FastDelegate (     , ) typedef fastdelegate::FastDelegate1 &lt; int &gt; Callback; private: Callback _callback; public: ValueChangedWorkaround() : _callback() { } void bind(QSpinBox *inSpinBox, const Callback &amp;inCallback) { _callback = inCallback; QObject::connect(inSpinBox, SIGNAL(valueChanged(int)), this, SLOT(valueChanged(int)); } private slots: void valueChanged(int inValue) { _callback(inValue); } };</span></span></code> </pre><br><br>  <a href="http://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible">About FastDelegate in general</a> <br>  <a href="https://github.com/dreamcat4/FastDelegate">FastDelegate on github</a> <br></div></div><br><br>  I used this code in the controller - and it all worked: <br><br><div class="spoiler">  <b class="spoiler_title">Crutch Controller</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_IntegralType &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegralController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> IntegralController&lt; IntegralType &gt; OwnType; T_IntegralType *_modelField; QSpinBox *_view; ValueChangedWorkaround _valueChangedWorkaround; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">QSpinBox *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_view) { _view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QSpinBox(); _valueChangedWorkaround.bind(_view, ValueChangedWorkaround::Callback( &amp;OwnType::valueChanged)); } } . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valueChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inValue)</span></span></span><span class="hljs-function"> </span></span>{ *_modelField = inValue; } };</code> </pre><br></div></div><br><br>  It would seem that one could calm down on this ... But I am a pathological fan of universal solutions, so I decided to make a macro that allows you to create crutches for processing various events from Qt objects on an industrial scale. <br><br><img src="https://habrastorage.org/getpro/habr/comment_images/1b8/2bd/b3d/1b82bdb3d3ce3c63374d3d42452b12ab.gif" alt="Crutches lord"><br><br><h3>  Crutches generator </h3><br><br>  It would seem that a new macro can be made on the basis of the old one by simply replacing some identifiers with macro arguments and slightly generalizing the macro itself. <br><br><div class="spoiler">  <b class="spoiler_title">Macro for generating crutches.</b>  <b class="spoiler_title">Version 1.0</b> <div class="spoiler_text">  <i>I omit here the slashes (here: "\") - terribly enraged!</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">define </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QT_EVENT_WORKAROUND_1_ARG</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(M_WorkaroundName, M_EventName, M_Arg0Type)</span></span></span><span class="hljs-function"> class M_WorkaroundName : </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> QObject </span></span>{ Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> fastdelegate::FastDelegate1 &lt; M_Arg0Type &gt; Callback; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Callback _callback; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: M_WorkaroundName() : _callback() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QObject *inQSignalSource, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Callback &amp;inCallback)</span></span></span><span class="hljs-function"> </span></span>{ _callback = inCallback; QObject::connect(inQSignalSource, SIGNAL(M_EventName(M_Arg0Type)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(M_EventName(M_Arg0Type)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> slots: <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> M_EventName(M_Arg0Type inValue) { _callback(inValue); } };</code> </pre><br></div></div><br><br>  Having written this macro, I thought with confidence that now I‚Äôm surely well done and generally a master of crutches (like the other man above).  Very pleased, I ran the code and ... Yes, of course, nothing worked.  There were no compilation errors, everything was going to happen, but the callback was not invoked, and there were messages in the log stating that, say, my <i>TestWorkaround</i> class <i>does</i> not have the correct slot. <br><br>  I had to dig further.  It turned out that MOC in Qt does not know how to deploy macros.  It passes through the code before the preprocessor is executed (that is, not by the code that, for example, can be seen if you build with the <a href="https://gcc.gnu.org/onlinedocs/gcc-4.4.1/gcc/Preprocessor-Options.html">-E</a> flag in MinGW, but by no means processed code). <br>  On the other hand, MOC should know the method signatures located in the blocks of the class declaration after the word ‚Äúslots‚Äù - it reads them as strings and then uses these string names when calling <i>QObject :: connect</i> (SLOT and SIGNAL macros extract these names + some metadata about place of use).  Thus, it became clear that in order to generate crutches, the user of the macro must be required to write his own implementation of the slot. <br><br>  I tried to minimize the volume and complexity of this code and the final solution looks like this (already the final code, with godless slashes, aha): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIGNAL_WORKAROUND_1_ARG(M_WorkaroundName, M_CallName, M_Arg0Type)\ class M_WorkaroundName : public QObject {\ public:\ typedef fastdelegate::FastDelegate1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; M_Arg0Type &gt; Delegate;\ \ private:\ Delegate _delegate;\ \ public:\ void bind(QObject *inQSignalSource, const Delegate &amp;inDelegate) {\ _delegate = inDelegate;\ QObject::connect(inQSignalSource, SIGNAL(M_CallName(M_Arg0Type)),\ this, SLOT(M_CallName(M_Arg0Type)));\ }\ \ void CALL(M_Arg0Type inArgument) { _delegate(inArgument); }\</span></span></span></span></code> </pre>  - As you can see, the macro describes an incomplete class, which the user needs to end with a slot description for calling the CALL (...) method.  Complete instructions for using the generator of crutches below ... <br><br>  Full instructions: <br>  1. Generate a crutch class somewhere using a macro.  In the example, we will generate a crutch called <i>YourWorkaroundName</i> , which wraps the <i>qtEventName</i> event, which takes one argument of the type <i>EventArg1Type</i> ).  Code for class generation: <br><br><pre> <code class="cpp hljs">SIGNAL_WORKAROUND_1_ARG(YourWorkaroundName, qtEventName, EventArg1Type) Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qtEventName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventArg1Type a0)</span></span></span><span class="hljs-function"> </span></span>{ CALL(a0); } };</code> </pre><br><br>  2. Use a new type anywhere in the code where you need to handle events from any Qt objects that can send an event of a wrapped type (in the example, the <i>qtEventName</i> event, which sends a single argument of type <i>EventArg1Type</i> ).  An example of code using a crutch: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: QSomeObject *_qTestObject; YourWorkaroundName _workaround; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UsingClass() : _qTestObject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QSomeObject()) { _workaround.bind(_qTestObject, YourWorkaroundName::Callback(&amp;UsingClass:: onEvent)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventArg1Type inArg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Some actions on callback */</span></span> } }</code> </pre><br><br>  All is ready.  Now you can process messages from Qt objects in any classes, without restrictions imposed by Qt MOC. <br><br>  In conclusion, a few comments: <br>  1. The proposed macro is suitable for events that take one argument per input.  To process a different number of arguments, you can either make a copy-paste of this macro (oldfag-style), or use the <a href="https://en.wikipedia.org/wiki/Variadic_macro">variadic macro</a> from C ++ 11. <br>  2. The proposed solution uses the <a href="https://github.com/dreamcat4/FastDelegate">FastDelegate</a> library for working with callbacks.  You can easily replace FastDelefate in a macro with your own type if you want to use your functors. <br>  3. In this solution, there is no error handling, assertion, etc. - in my case, such processing is not required.  You can add to taste. <br>  4. I am ready to agree that the proposed solution is a hell of a disaster and I will be happy to hear suggestions how else you could cope with the limitations of Qt MOC.  I will add your suggestions to the article indicating the authorship of the decision and with gratitude from myself personally.  Thank you in advance! <br><br><h4>  Conclusion </h4><br><br>  I hope the proposed generator of crutches will help save someone the time to write a similar tin.  Finally, I note that the generator of crutches contains a small amount of code, so, as for me, it makes no sense to post it on GitHub. <br>  However, at the request of a respectable public, I can make a small turnip with a test drive.  Express in the comments about, if there are more than five people willing, I‚Äôll post. <br><br>  Thank you for your attention and for reading! <br><br>  PS: If you find any errors in the article - write, I will rule. <br><br><a name="Qt5API"></a><br>  <b>(Added 03/11/2016)</b> <br><br>  Thanks to <a href="https://habrahabr.ru/users/alexpublic/" class="user_link">AlexPublic</a> and <a href="https://habrahabr.ru/users/violetgiraffe/" class="user_link">VioletGiraffe</a> , they <a href="https://habrahabr.ru/users/violetgiraffe/" class="user_link">stuck their</a> nose into the new <a href="https://wiki.qt.io/New_Signal_Slot_Syntax">signal-slot API</a> . <br><br>  If we talk about the generator of crutches, it will look like this: <br><br><div class="spoiler">  <b class="spoiler_title">Crutches generator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIGNAL_WORKAROUND_1ARG(M_WorkaroundName, M_CallName, M_Arg0Type)\ class M_WorkaroundName : public QObject {\ public:\ typedef fastdelegate::FastDelegate1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; M_Arg0Type &gt; Delegate;\ \ private:\ Delegate _delegate;\ \ public:\ template&lt; typename T_ListenerType &gt;\ void bind(T_ListenerType *inQSignalSource, const Delegate &amp;inDelegate) {\ _delegate = inDelegate;\ connect(inQSignalSource,\ static_cast&lt; void (T_ListenerType::*)(M_Arg0Type) &gt; &amp;T_ListenerType::M_CallName),\ this, &amp;M_WorkaroundName::M_CallName);\ }\ \ void M_CallName(M_Arg0Type a0) { _delegate(a0); }\ };</span></span></span></span></code> </pre><br><br>  Use made easier.  Now you can create a wrapper type anywhere, including a template context.  Something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_SomeQObject&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: SIGNAL_WORKAROUND_1ARG(YourWorkaroundName, qtEventName, EventArg1Type); T_SomeQObject *_qTestObject; YourWorkaroundName _workaround; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UsingClass() : _qTestObject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T_SomeQObject()) { _workaround.bind(_qTestObject, YourWorkaroundName::Callback(&amp;UsingClass::onEvent)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EventArg1Type inArg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Some actions on callback */</span></span> } }</code> </pre><br></div></div><br><br>  Although, it should be noted, this new signal-slot Qt5 API allows you to completely get rid of the MOC and its limitations.  Therefore, instead of using a crutch, it is easier to inherit a class listener from a QObject (since there is no longer a binding to the MOC, the heir to the listener can be patterned and generally whatever), overlaying the QObject ifdef if you want to create a library with support for different GUI frameworks, or if you use C ++ 11 and older, and <a href="https://habrahabr.ru/post/279007/">use lambda</a> , as suggested by <a href="https://habrahabr.ru/users/alexpublic/" class="user_link">AlexPublic</a> . </div><p>Source: <a href="https://habr.com/ru/post/279007/">https://habr.com/ru/post/279007/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278991/index.html">Report with MoscowJS February 25</a></li>
<li><a href="../278995/index.html">Calltracking in Minecraft or how to quickly make a three-dimensional UI</a></li>
<li><a href="../278997/index.html">Release Webix 3.2. New widgets for working with data and other features</a></li>
<li><a href="../278999/index.html">Thorny road to sales on Themeforest.net - Part 1</a></li>
<li><a href="../279005/index.html">Creating reports in PowerShell</a></li>
<li><a href="../279011/index.html">Update DataGrid after DELETE (WPF)</a></li>
<li><a href="../279017/index.html">Bitrix, HMVC and a bit of nonsense ...</a></li>
<li><a href="../279019/index.html">Emoji appeared on Github: reactions to pull requests, bugs and comments</a></li>
<li><a href="../279021/index.html">Experiment: Using Google Trends to predict stock market crashes</a></li>
<li><a href="../279023/index.html">CI DIY for Unity3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>