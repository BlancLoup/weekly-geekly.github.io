<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>When MVC is not enough</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the main advantages of frameworks is their predefined architecture. You open an unfamiliar project and immediately know where and how to search...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>When MVC is not enough</h1><div class="post__text post__text-html js-mediator-article">  One of the main advantages of frameworks is their predefined architecture.  You open an unfamiliar project and immediately know where and how to search for a connection code with a database, or HTML, or a url scheme.  In addition, it allows the developer not to think about the storage structure of the code and at the same time be sure that the project will look more or less adequate.  But I want to talk about the case when the implementation of MVC in Django, namely, the distribution of logic in the files models, forms, views, templates was inconvenient and what alternative was built based on it. <br><br>  Our task was to make an engine for statistical reporting on Django.  We created selectors for getting data from Oracle and widgets for displaying this data in the form of tables or graphs (using HighChart).  But these are all purely technological solutions, without much magic.  If you are interested, I will tell in a separate post.  And now I would like to draw attention to a more unusual part of the project.  To provide report compilers with a convenient way to compile these reports. <br><a name="habracut"></a><br>  Here are a few points: <br><ol><li>  On the one hand, the compilers of the reports are with us in the same department, that is, in principle they can be shown the insides of the project.  On the other hand, they are fluent in SQL, a little bit of HTML and not at all Python, and certainly not Django. <br>  So, it is necessary, if possible, to relieve them of the load on the brain in the form of mastering the architecture of the framework.  In addition, you need to put their work in the sandbox, so that no errors would affect the performance of the system as a whole. </li><li>  Each page should contain several reports in a rather arbitrary form.  There are a lot of pages and they are usually not related to each other (well, except that the sources in the database) <br>  If you stuff the logic of a single report across different files, you will get huge files by which you need to search for a report in pieces. <br><img src="https://habrastorage.org/storage2/443/a25/063/443a250632d8bcd0fffdc82fe6822b97.png"><br><br>  But one ought to have the opportunity to open "something" and see in front of you the whole logic of building a report in and out. <br><img src="https://habrastorage.org/storage2/58b/98c/a8c/58b98ca8cf71c815a491dca56208fdb4.png"><br></li><li>  You need the ability to quickly edit the report without restarting Django. </li><li>  It is desirable to provide the ability to collaborate and track changes in reports. </li></ol><br>  There was an option to store the report settings in the database.  But tracking changes is much easier in a version control system than in a database.  In addition, it was clear in advance that the engine will develop, and changing the data scheme is perhaps the most painful for any system. <br>  Means files.  Which engine will read and do something based on them.  The format was assumed to be different.  And JSON, and ini, and invent some kind of your own.  XML was flagged immediately as hard to read.  But one evening it dawned on me - and how is Python bad?  Setting looks nothing more complicated, even for someone unfamiliar with the language at all (except that the first two lines will seem magical to him): <br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- from statistics import OracleSelect, Chart, Table select_traf = OracleSelect('user/password@DB', """select DAY, NSS_TRAF, BSS_TRAF from DAY_TRAFFIC where DAY &gt;= trunc(sysdate,'dd')-32""") chart_traf = Chart(selector=select_traf, x_column='DAY', y_columns=[('NSS_TRAF', u'NSS '), ('BSS_TRAF', u'BSS ')]) table_traf = Table(selector=select_traf, columns=['DAY', 'NSS_TRAF', 'BSS_TRAF']) template = """ {{ chart_traf }} {{ table_traf }} """</span></span></code> </pre>  <i>In fact, there are much more options for the Chart and Table widgets, but I don‚Äôt see any sense in the demo code to list them all.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Simply put, the configuration file can be a script that runs every time a page is accessed.  For Django, this behavior is not typical, but we will make her do it. <br>  I must say that I later thanked myself many times for this decision.  Not only because it was easier to add new features, but also because in special cases it became possible to solve the problem with a simple Python hack right in the configuration file.  For example, to perform different requests, depending on the conditions, or to generate several graphs of the same type.  If the config were standardized as a static file, it is not known how such issues would be solved.  But I suspect that it is very difficult.  For each such case, I would have to finish the engine. <br><br><h5>  Reading (execution) of the setup file </h5><br>  This is how the ‚Äúinterpreter‚Äù of the configuration files looks in the simplest form. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.template <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RequestContext, Template <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HttpResponse, Http404 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> settings <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PROJECT_ROOT <span class="hljs-comment"><span class="hljs-comment">#   ,    __file__   settings.py def dynamic_page(request, report_path): ctx_dict = {} execfile(os.path.join(PROJECT_ROOT, 'reports', report_path + '.py'), ctx_dict) templ_header = '{% extends "base.html" %}{% block content %}' templ_footer = '{% endblock %}' template = Template(templ_header + ctx_dict['template'] + templ_footer) context = RequestContext(request) context.autoescape = False context.update(ctx_dict) return HttpResponse(template.render(context))</span></span></code> </pre><br>  We execute with the help execfile setup file.  All variables created in the script will be in the ctx_dict dictionary.  We take the contents of the template variable and create a full-fledged template, into which we pass the standard RequestContext and the newly created context from the same script. <br>  In urls.py add <br><pre> <code class="python hljs">(<span class="hljs-string"><span class="hljs-string">r'^reports/(?P&lt;report_path&gt;.+)$'</span></span>, <span class="hljs-string"><span class="hljs-string">'statistics.views.dynamic_page'</span></span>),</code> </pre><br><h5>  Passing context to and from report </h5><br>  Passing an arbitrary dictionary as a namespace for an executable script opens up interesting possibilities. <br>  For example, we needed to access request get parameters in the configuration file.  To do this, simply change ctx_dict before passing it to execfile <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamic_page</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, report_path)</span></span></span><span class="hljs-function">:</span></span> ctx_dict = {<span class="hljs-string"><span class="hljs-string">'get'</span></span>: request.GET.get} ...</code> </pre><br>  Now, in the configuration file, without any imports, the function get will be available, which gets the value of the desired parameter from the current request.  Actually, imports would not help here, since request is new each time. <br>  At the same time, it was necessary to post-process the data obtained from the configuration file.  For example, it became necessary to assign each html-id to each graphic in accordance with its name.  This is necessary in order for javascript to print the same name as in python (for interaction of graphs with each other).  Of course, you can solve this with another parameter in Chart, but it's not very kosher to constantly write something in the style <br><pre> <code class="python hljs">chart_name = Chart(select, x_col, config, ..., html_id=<span class="hljs-string"><span class="hljs-string">'chart_name'</span></span>)</code> </pre><br>  It is better not to strain the users of the engine with its entrails, and assign the necessary id automatically, after the formation of ctx_dict in the execfile. <br><pre> <code class="python hljs"> ... execfile(os.path.join(PROJECT_ROOT, <span class="hljs-string"><span class="hljs-string">'reports'</span></span>, report_path + <span class="hljs-string"><span class="hljs-string">'.py'</span></span>), ctx_dict) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (name, obj) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ctx_dict.items(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(obj, (Chart, Table)): obj.html_id = name ...</code> </pre><br>  There is another interesting point with ctx_dict.  Since all its values ‚Äã‚Äãfall into the context of the template, they rewrite those of the same name transmitted from RequestContext.  For example, if some context processor calculates the value 'TITLE' to put it in the page header, then you can calculate your own in your configuration file and it will be displayed instead of the existing <br><pre> <code class="python hljs">bs = get(<span class="hljs-string"><span class="hljs-string">'bs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bs <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: TITLE = <span class="hljs-string"><span class="hljs-string">u'   %s'</span></span> % bs</code> </pre><br>  It is clear that there is a danger of inadvertent rewriting.  But this is decided by a naming convention (for example, in context processors only the upper case is used, and in the configuration files only the lower case). <br><br><h5>  Scaling to other url and base patterns </h5><br>  In the end, it got to the point that it was necessary to post several sections with statistics on the Portal.  Of course, they were slightly differently designed and required a little different logic, well, we ourselves were convenient to store the report groups separately. <br>  So dynamic_page should be from a simple viewview generator.  What was done. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.template <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RequestContext, Template <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HttpResponse, Http404 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> settings <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PROJECT_ROOT <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> partial <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_param</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, key=None, default=None, as_list=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> as_list: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.GET.getlist(key) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.GET.get(key, default) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.GET.lists() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicPage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"       "</span></span> <span class="hljs-comment"><span class="hljs-comment">#  view def __init__(self, subpath, # ,   ,       parent_template = "base.html", load_tags = (), #     block_name = 'content', pre_calc = lambda request, context: None, #     execfile post_calc = lambda request, context: None): #     execfile self.templ_header = ('{% extends "' + parent_template + '" %}' + DynamicPage.loading_tags(load_tags) + DynamicPage.block_top(block_name)) self.templ_footer = DynamicPage.block_foot(block_name) self.subpath = subpath self.pre_calc = pre_calc self.post_calc = post_calc @staticmethod def block_top(block_name): if block_name: return "{% block " + block_name + " %}" else: return '' @staticmethod def block_foot(block_name): if block_name: return "{% endblock %}" else: return '' @staticmethod def loading_tags(tags): return ''.join(['{% load ' + tag + ' %}' for tag in tags]) @property def __name__(self): return self.__class__.__name__ #  view def __call__(self, request, pagepath): ctx_dict = self.get_context(request, pagepath) if 'response' in ctx_dict and isinstance(ctx_dict['response'], HttpResponse): return ctx_dict['response'] #    response    #     ,     ,   html- else: template = Template(self.templ_header + ctx_dict['template'] + self.templ_footer) context = RequestContext(request) context.autoescape = False context.update(ctx_dict) return HttpResponse(template.render(context)) def get_context(self, request, pagepath): fullpath = os.path.join(PROJECT_ROOT, self.subpath, pagepath + '.py') if not os.path.exists(fullpath): raise Http404 ctx_dict = {'get': partial(get_param, request), 'request': request} self.pre_calc(request, ctx_dict) execfile(fullpath, ctx_dict) self.post_calc(request, ctx_dict) return ctx_dict</span></span></code> </pre><br>  This allowed us to create wrappers for different reporting sections.  They were engaged in programmers.  The principles of making reports did not change. <br><br>  For example, in one case, the games mentioned above with html_id were needed. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_html_id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, context)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (name, obj) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> context.items(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(obj, (Chart, Table)): obj.html_id = name show_report = DynamicPage(<span class="hljs-string"><span class="hljs-string">'stat_tech/pages'</span></span>, parent_template=<span class="hljs-string"><span class="hljs-string">'stat_tech/base.html'</span></span>, load_tags=[<span class="hljs-string"><span class="hljs-string">'adminmedia'</span></span>, <span class="hljs-string"><span class="hljs-string">'jquery'</span></span>, <span class="hljs-string"><span class="hljs-string">'chapters'</span></span>], post_calc=add_html_id)</code> </pre><br>  In the other, fill out from the setup file not one block of the template, but two. <br><pre> <code class="python hljs">show_weekly = DynamicPage(<span class="hljs-string"><span class="hljs-string">'stat_weekly/pages'</span></span>, parent_template = <span class="hljs-string"><span class="hljs-string">'stat_weekly/base.html'</span></span>, load_tags = [<span class="hljs-string"><span class="hljs-string">'chapters'</span></span>, <span class="hljs-string"><span class="hljs-string">' employees'</span></span>], block_name=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre><br>  In this case, the blocks are specified in the file with the report. <br><pre> <code class="python hljs">template = <span class="hljs-string"><span class="hljs-string">""" {% block chart %} {{ costs_monthly }} {{ costs_weekly }} {% endblock %} {% block responsible %} {% employee vasily_pupkin %}, {% employee ivan_ivanov %} {% endblock %} """</span></span></code> </pre><br>  In the third, to recognize the division in which the current user works, on its basis to determine how and what requests to perform, as well as in what form to show the submenu. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_division</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, context)</span></span></span><span class="hljs-function">:</span></span> div = Division.get_by_user(request.user) context[<span class="hljs-string"><span class="hljs-string">'DIVISION'</span></span>] = div context[<span class="hljs-string"><span class="hljs-string">'SUBMENU'</span></span>] = calc_goal_submenu(request.path, div) show_goal = DynamicPage(<span class="hljs-string"><span class="hljs-string">'stat_goals/pages'</span></span>, load_tags = [<span class="hljs-string"><span class="hljs-string">'chapters'</span></span>], block_name=<span class="hljs-string"><span class="hljs-string">'report'</span></span>, parent_template = <span class="hljs-string"><span class="hljs-string">'stat_goals/base.html'</span></span>, pre_calc = add_division)</code> </pre><br>  All these wrappers are added to the urls as regular views. <br><pre> <code class="python hljs"> (<span class="hljs-string"><span class="hljs-string">r'^stat/(?P&lt;pagepath&gt;.+)$'</span></span>, <span class="hljs-string"><span class="hljs-string">'stat_tech.views.show_report'</span></span>), (<span class="hljs-string"><span class="hljs-string">r'^weeklyreport/(?P&lt;pagepath&gt;.+)$'</span></span>, <span class="hljs-string"><span class="hljs-string">'stat_weekly.views.show_weekly'</span></span>), (<span class="hljs-string"><span class="hljs-string">r'^goals/(?P&lt;pagepath&gt;.+)$'</span></span>, <span class="hljs-string"><span class="hljs-string">'stat_goals.views.show_goal'</span></span>),</code> </pre><br><br>  Here is such a mini framework over a large one.  I hope he successfully demonstrates that if the framework of the system makes it difficult to solve the problem in a simple way, you can always slightly push them apart using the more powerful features of the language. <br><br>  <b>UPD:</b> As suggested by <a href="http://habrahabr.ru/users/magic4x/" class="user_link">magic4x</a> , the __name__ property has been added to DynamicPage, which enhances the mimicry for the function. </div><p>Source: <a href="https://habr.com/ru/post/185180/">https://habr.com/ru/post/185180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../185162/index.html">Try Windows Server 2012 R2, SQL Server 2014 and Visual Studio 2013 without installation!</a></li>
<li><a href="../185164/index.html">Backward compatibility for losers</a></li>
<li><a href="../185172/index.html">Windows on RAM disk</a></li>
<li><a href="../185176/index.html">The life of a homemade arcade machine</a></li>
<li><a href="../185178/index.html">Linux 3.10 kernel out</a></li>
<li><a href="../185182/index.html">Interface Digest, June 2013</a></li>
<li><a href="../185184/index.html">The main errors of the applicant at the interview</a></li>
<li><a href="../185186/index.html">Comparative test-review of the flagships of 2013: Sony Xperia Z, OPPO Find 5, Samsung Galaxy S IV and HTC One</a></li>
<li><a href="../185194/index.html">Two hundred Nokia video wall</a></li>
<li><a href="../185196/index.html">Analyzing the new orders of the FSTEC of Russia No. 17 and No. 21</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>