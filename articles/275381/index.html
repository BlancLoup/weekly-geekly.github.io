<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Remote firmware update microcontroller</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In one of the previous articles, we wrote about a USB bootloader on a SAM D21 microcontroller with a Cortex M0 + core. Using a flash drive to update t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Remote firmware update microcontroller</h1><div class="post__text post__text-html js-mediator-article">  In one of the previous articles, we wrote about a <a href="http://geektimes.ru/company/rainbow/blog/261006/">USB bootloader</a> on a SAM D21 microcontroller with a Cortex M0 + core.  Using a flash drive to update the firmware is very convenient, but not suitable for all cases.  For example, if access to a device is limited or problematic, and communication with it is established remotely.  In such cases, the development of a bootloader should be treated with the utmost care.  Otherwise, in case of an error, the probability of getting a ‚Äúbrick‚Äù and a huge number of problems is high.  An example of such a hard-to-reach device is the control board of a ‚Äúsmart‚Äù architectural lamp hanging on the facade of a building on the 7th floor. <br><img src="https://habrastorage.org/files/33a/4c8/38b/33a4c838bd2345c1b230fd99b62cc868.jpg"><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  In the project, which formed the basis of this article, the connection with the remote device is carried out by power wires in accordance with the standard <a href="http://www.g3-plc.com/content/g3-plc-overview">G3 PLC</a> (Power Line Communication).  At first glance, the method of communication should not matter, because  for a microcontroller, it still comes down to an exchange over UART / I2C / SPI.  However, for example, in our case this imposes a limitation in the form of the impossibility of an online firmware update (when the bootloader establishes connection with the server to receive a new firmware), since  Work with a PLC-modem resource-intensive task and the size of the bootloader section is not enough. <br>  <b>Thus, the following requirements were formed:</b> <br><ul><li>  The update process takes place offline.  Those.  The firmware file is transferred in parts to the target device and saved to external flash memory.  Starting the update process is a separate command. </li><li>  The head unit (gateway) is managing the remote device and transferring the file with the new firmware.  The description of these processes in this article is not considered. </li><li>  An external EEPROM is used to exchange information between the application and the bootloader sections.  For example, to start the update process, the application writes a corresponding flag to the EEPROM and transfers control to the bootloader section. </li><li>  Before updating, it is obligatory to check the checksum of the firmware located in the external flash.  Otherwise, the update does not start, and control is returned to the application section. </li><li>  The first always starts bootloader.  In addition to checking commands in the EEPROM, the bootloader checks the correctness of the current firmware in the controller's flash memory each time before transferring control to the application section using the CRC.  CRC - stored as the last two bytes of the flash. </li></ul><br><img src="https://habrastorage.org/files/8f5/591/76a/8f559176af4d4b408ba97e355136eaf6.png"><br><br>  In the article on the <a href="http://geektimes.ru/company/rainbow/blog/261006/">USB bootloader,</a> a brief theory is given on the organization of the memory of the SAM D20 / D21 families, and we will not duplicate it here.  <a href="http://light.rtcs.ru/eshop/catalog/detail.php%3FID%3D433645">ATSAMD20G16 is</a> used as the target microcontroller.  We will build the project in IAR using the <a href="http://geektimes.ru/company/rainbow/blog/260938/">ASF</a> (Atmel Software Framework). <br><br><h4>  Algorithms of work </h4><br>  The operation of the device always starts from the bootloader, then, depending on the command in the EEPROM, either the firmware is updated or the correctness of the current firmware crc is simply checked.  Upon completion of the bootloader, if there are no errors, a transition is made to the application: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APP_START_ADDRESS 0x00004000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// brief Function for starting application // This function will configure the WDT module and enable it. The LED is // kept toggling till WDT reset occurs. static void start_application(void) { // Pointer to the Application Section void (*application_code_entry)(void); // Rebase the Stack Pointer __set_MSP(*(uint32_t *) APP_START_ADDRESS); // Rebase the vector table base address SCB-&gt;VTOR = ((uint32_t) APP_START_ADDRESS &amp; SCB_VTOR_TBLOFF_Msk); // Load the Reset Handler address of the application application_code_entry = (void (*)(void))(unsigned *)(*(unsigned *)(APP_START_ADDRESS + 4)); // Jump to user Reset Handler in the application application_code_entry(); }</span></span></span></span></code> </pre> <br>  The general algorithm of the bootloader is shown in the figure below: <br><img src="https://habrastorage.org/files/ee1/77f/faa/ee177ffaa2744f14b3b94862e7b979a2.png"><br>  The CRC check of its firmware is performed every time the microcontroller starts, in order to avoid incorrect operation in case of damage to the main code.  What to do if the calculated CRC does not coincide with what is read, is solved in each specific application individually.  You can blink infinitely red LED, you can fill in the backup firmware (then you need to provide a place where to store it). <br>  The general algorithm of the application is shown in the figure below.  Here is only what is directly related to the firmware update. <br><img src="https://habrastorage.org/files/f63/5b7/5f2/f635b75f27d54d2d9eb8cba29cb43fcb.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Project settings for application </h4><br>  To implement what was planned in the project with the application, you must do the following: <br><ul><li>  use IAR as a checksum of firmware (CRC) and substitute the result in the form of the last two bytes of the received binary </li><li>  place the application not from the zero memory address of the microcontroller, in order to leave "space" for the bootloader. </li></ul><br>  This is done in the project settings. <br><br><h5>  CRC count </h5><br><img src="https://habrastorage.org/files/dcd/9e8/93b/dcd9e893b2514181812f4c5f6260b0a7.png"><br>  Such settings correspond to the polynomial 0x1021, while we should not forget to change the bytes in places when counting with the help of the code, and also that the CRC means IAR is considered throughout the memory, and not only for the filled code.  After counting the CRC from the contents of the entire application memory, at the end you must flip the result by ‚Äúadding‚Äù 2 more bytes to the checksum (see <a href="http://ftp.iar.se/WWWfiles/arm/webic/doc/EWARM_DevelopmentGuide.ENU.pdf">EWARM_DevelopmentGuide.ENU</a> ). <br><br>  CRC verification code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestChecksum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> calc = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> zeros[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">/* Run the checksum algorithm */</span></span> calc = slow_crc16(<span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) ChecksumStart,(ChecksumEnd - ChecksumStart+<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* Rotate out the answer */</span></span> calc = slow_crc16(calc, zeros, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Test the checksum */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (calc != checksum) { <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/* Failure */</span></span> } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">short</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow_crc16</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (len--) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> byte = *(p++); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> oSum = sum; sum &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byte &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span>) sum |= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oSum &amp; <span class="hljs-number"><span class="hljs-number">0x8000</span></span>) sum ^= <span class="hljs-number"><span class="hljs-number">0x1021</span></span>; byte &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre><br><br><h5>  Code location settings for application </h5><br>  Specify the beginning of the memory and the address of the interrupt vector table: <br><img src="https://habrastorage.org/files/41f/055/579/41f055579d0b424f8169ea005bc54f64.png"><br><img src="https://habrastorage.org/files/bf3/4c1/b2e/bf34c1b2e238488d8c9a93bf7b5b60c3.png"><br><br><h4>  Code </h4><br>  To work we need the following modules ASF / MK: <br><ul><li>  NVM (non-volatile memory controller), </li><li>  SERCOM SPI (for communication with external flash memory), </li><li>  SERCOM I2C (for communication with external EEPROM memory), </li></ul><br>  In addition to initialization and configuration of all modules, it is necessary to ensure the logic of operation. <br><div class="spoiler">  <b class="spoiler_title">Full code main.c</b> <div class="spoiler_text">  #include &lt;asf.h&gt; <br>  #include "twi_driver.h" <br>  #include "MCP7941x.h" <br>  #include "at45db041d.h" <br>  #include "init.h" <br>  #include "utils.h" <br>  // ------------------------------------------------ ----------------------------- <br>  // --------------- global variables ------------------------------- ---------- <br>  // --------- structures of peripheral instances ------------------------------------ - <br>  extern struct spi_module spi_master_instance; <br>  extern struct spi_slave_inst slave; <br>  extern struct tc_module tc_instance_tc2; <br>  extern struct i2c_master_module i2c_master_instance; <br><br>  //------------------------periphery----------------------- --------------------- <br>  // ------------------------------ i2c ----------------- --------------------------- <br>  unsigned char twi_out_data [9]; <br>  unsigned char twi_in_data [8]; <br>  // ---------------------------- SPI ------------------- --------------------------- <br>  extern unsigned char spi_in_data [ext_flash_page_size]; <br>  extern unsigned char spi_out_data [ext_flash_page_size]; <br>  unsigned char temp_buffer_write [ext_flash_page_size]; <br>  unsigned long rtc_cnt; <br>  // ------------------- counters for cycles -------------------------- ------------- <br>  unsigned int i, m; <br>  unsigned char led_cnt; <br>  // ------------------------ working with the firmware --------------------- ------------- <br>  unsigned int page_addr; <br>  unsigned int CRC; <br>  unsigned int CRC_read; <br>  unsigned char zero [2] = {0,0}; <br>  unsigned int last_page_length; <br>  unsigned int page_num; <br>  unsigned int byte_amount; <br>  unsigned int last_page_number; <br>  const uint8_t flash_data [256]; <br>  // ------------------------------------------------ ----------------------------- <br>  // ------------------- init ---------------------------- ------------------------ <br><br>  void MC_init (void) <br>  { <br>  struct nvm_config config; <br><br>  system_init (); <br>  SystemClock_Init (); <br>  configure_tc2 (); <br>  configure_pins (); <br>  configure_spi_master (); <br>  configure_i2c_master (); <br>  nvm_get_config_defaults (&amp; config); <br>  nvm_set_config (&amp; config); <br>  } <br><br>  void init_variables (void) <br>  { <br>  // ------------------------------ i2c ----------------- --------------------------- <br>  clear_twi_in_buffer (); <br>  clear_twi_out_buffer (); <br>  // ---------------------------- SPI ------------------- --------------------------- <br>  for (i = 0; i &lt;ext_flash_page_size; i ++) temp_buffer_write [i] = 0; <br>  rtc_cnt = 0; <br>  // ------------------- counters for cycles -------------------------- ------------- <br>  led_cnt = 0; <br>  // ------------------------ other ----------------------- ------------------------ <br>  last_page_number = 0; <br>  } <br><br>  void external_init (void) <br>  { <br>  unsigned char temp; <br>  // ---------------- external eeprom --------------------- <br>  // check that the memory is not write protected <br>  clear_twi_in_buffer (); <br>  twi_read_bytes (twi_in_data, 1, EEPROM_ADR, 0xff); <br>  if (twi_in_data [0]! = 0) <br>  { <br>  clear_twi_out_buffer (); <br>  twi_out_data [0] = 0xff; <br>  twi_out_data [1] = 0; <br>  twi_write_bytes (twi_out_data, 2, EEPROM_ADR, EEPROM_OWN_METERS_1_STATUS); <br>  } <br>  // ---------------- FLASH ------------------------------- <br>  // check the page size of the external flash <br>  temp = flash_wait (spi_delay); <br>  // if 264, then install 256 <br>  if ((temp &amp; 0x01)! = 0x01) set_page_size_256 (); <br>  temp = 0; <br>  } <br><br>  // brief Function for programming data to Flash <br>  // This is the function that will check whether the data is greater than the Flash page size. <br>  // If it is greater, it splits and writeswise. <br>  // param address of the flashmed page to be programmed <br>  // param buffer pointer <br>  // param len length <br><br>  static void program_memory (uint32_t address, uint8_t * buffer, uint16_t len) <br>  { <br>  // Check if length is greater than Flash page size <br>  if (len&gt; NVMCTRL_PAGE_SIZE) <br>  { <br>  uint32_t offset = 0; <br>  while (len&gt; NVMCTRL_PAGE_SIZE) <br>  { <br>  // Check if it is the first page of a row <br>  if ((address &amp; 0xFF) == 0) <br>  { <br>  // Erase row <br>  nvm_erase_row (address); <br>  } <br>  // Write one page data to flash <br>  nvm_write_buffer (address, buffer + offset, NVMCTRL_PAGE_SIZE); <br>  // Increment the address to be programmed <br>  address + = NVMCTRL_PAGE_SIZE; <br>  // Increment the offset of the buffer containing data <br>  offset + = NVMCTRL_PAGE_SIZE; <br>  // Decrement the length <br>  len - = NVMCTRL_PAGE_SIZE; <br>  } <br>  // Check if there is data <br>  if (len&gt; 0) <br>  { <br>  // Write the data to flash <br>  nvm_write_buffer (address, buffer + offset, len); <br>  } <br>  } <br>  else <br>  { <br>  // Check if it is the first page of a row) <br>  if ((address &amp; 0xFF) == 0) <br>  { <br>  // Erase row <br>  nvm_erase_row (address); <br>  } <br>  // Write the data to flash <br>  nvm_write_buffer (address, buffer, len); <br>  } <br>  } <br><br>  // brief Function for starting application <br>  // This function will configure the WDT module and enable it.  The LED is <br>  // kept toggling till wdt reset occurs. <br>  static void start_application (void) <br>  { <br>  // Pointer to the Application Section <br>  void (* application_code_entry) (void); <br>  // Rebase the Stack Pointer <br>  __set_MSP (* (uint32_t *) APP_START_ADDRESS); <br>  // Rebase the vector table base address <br>  SCB-&gt; VTOR = ((uint32_t) APP_START_ADDRESS &amp; SCB_VTOR_TBLOFF_Msk); <br>  // Load the Reset Handler address of the application <br>  application_code_entry = (void (*) (void)) (unsigned *) (* (unsigned *) (APP_START_ADDRESS + 4)); <br>  // Jump to user Reset Handler in the application <br>  application_code_entry (); <br>  } <br><br>  unsigned int slow_crc16 (unsigned short sum, unsigned char * p, unsigned int len) <br>  { <br>  while (len--) <br>  { <br>  int i; <br>  unsigned char byte = * (p ++); <br><br>  for (i = 0; i &lt;8; ++ i) <br>  { <br>  unsigned long osum = sum; <br>  sum &lt;&lt; = 1; <br>  if (byte &amp; 0x80) <br>  sum | = 1; <br>  if (osum &amp; 0x8000) <br>  sum ^ = 0x1021; <br>  byte &lt;&lt; = 1; <br>  } <br>  } <br>  return sum; <br>  } <br><br>  void MC_reset (void) <br>  { <br>  tc_reset (&amp; tc_instance_tc2); <br>  i2c_master_reset (&amp; i2c_master_instance); <br>  spi_reset (&amp; spi_master_instance); <br><br>  } <br>  // ------------------------ !!!!!! MAIN !!!!!! ----------- -------------------------- <br>  int main (void) <br>  { <br>  unsigned int temp; <br>  unsigned int j; <br>  unsigned char k; <br><br>  init_variables (); <br>  MC_init (); <br><br>  for (i = 0; i &lt;20; i ++) <br>  { <br>  LED_2_TOGGLE (); <br>  delay_ms (100); <br>  } <br><br>  system_interrupt_enable_global (); <br>  external_init (); <br>  // ------------ check if there is a command to upgrade ------------------------- <br>  for (i = 0; i &lt;8; i ++) twi_in_data [i] = 0; <br>  // read the upgrade from the external EEPROM <br>  twi_read_bytes (twi_in_data, 4, EEPROM_ADR, EEPROM_UPGRADE); <br>  // team to upgrade <br>  if (twi_in_data [0] == 0x55) <br>  { <br>  for (i = 0; i &lt;20; i ++) <br>  { <br>  LED_1_TOGGLE (); <br>  delay_ms (100); <br>  } <br>  // determine the length of the firmware and the position of crc in it <br>  // since we are transmitting all the memory via the PLC, not just the code <br>  // has not yet figured out how to transmit only the code <br>  for (page_addr = 2; page_addr &lt;194; page_addr ++) <br>  { <br>  // read the page <br>  continuous_low_freq_read (spi_in_data, page_addr, 0, ext_flash_page_size); <br>  temp = 0; <br>  for (j = 0; j &lt;ext_flash_page_size; j ++) <br>  { <br>  if (spi_in_data [j] == 0xff) <br>  { <br>  temp ++; <br>  } <br>  else temp = 0; <br>  } <br>  // first blank page <br>  if (temp == ext_flash_page_size) <br>  { <br>  // read the previous page <br>  page_addr--; <br>  continuous_low_freq_read (spi_in_data, page_addr, 0, ext_flash_page_size); <br>  last_page_number = page_addr; <br>  // analyze the last page with the code from the end <br>  // if the last byte is not ff, then this is a CRC <br>  if (spi_in_data [ext_flash_page_size-1]! = 0xff) <br>  { <br>  CRC_read = spi_in_data [ext_flash_page_size-2]; <br>  CRC_read &lt;&lt; = 8; <br>  CRC_read | = spi_in_data [ext_flash_page_size-1]; <br>  } <br>  // if the last bay ff, then look for a place crc <br>  else <br>  { <br>  i = ext_flash_page_size-1; <br>  while ((spi_in_data [i] == 0xff) &amp;&amp; (i&gt; 0)) <br>  { <br>  i--; <br>  } <br>  CRC_read = spi_in_data [i]; <br>  CRC_read &lt;&lt; = 8; <br>  CRC_read | = spi_in_data [i-1]; <br>  // this is the last byte position of crc <br>  last_page_length = i + 1; <br>  break; <br>  } <br>  } <br>  } <br>  } <br>  // -------------- check the current firmware CRC ----------------------------- <br>  else <br>  { <br>  k = 0; <br>  CRC = 0; <br>  CRC_read = 0xffff; <br>  // if it doesn't fit, we will try 5 times <br>  // if it doesn‚Äôt converge, then we blink red LED until blue) <br>  while ((CRC! = CRC_read) &amp;&amp; (k &lt;5)) <br>  { <br>  k ++; <br>  CRC = 0; <br>  CRC_read = 0; <br>  // determine the length of the firmware and the position of crc in it <br>  for (page_addr = 0x4000; page_addr &lt;0x10000; page_addr + = NVMCTRL_PAGE_SIZE) <br>  { <br>  // read the page <br>  nvm_read_buffer (page_addr, spi_in_data, NVMCTRL_PAGE_SIZE); <br>  temp = 0; <br>  for (j = 0; j &lt;64; j ++) <br>  { <br>  if (spi_in_data [j] == 0xff) <br>  { <br>  temp ++; <br>  } <br>  else temp = 0; <br>  } <br>  // first blank page <br>  if (temp == NVMCTRL_PAGE_SIZE) <br>  { <br>  // read the previous page <br>  page_addr- = NVMCTRL_PAGE_SIZE; <br>  nvm_read_buffer (page_addr, spi_in_data, NVMCTRL_PAGE_SIZE); <br>  last_page_number = page_addr; <br>  // analyze the last page with the code from the end <br>  // if the last byte is not ff, then this is a CRC <br>  if (spi_in_data [NVMCTRL_PAGE_SIZE-1]! = 0xff) <br>  { <br>  CRC_read = spi_in_data [NVMCTRL_PAGE_SIZE-2]; <br>  CRC_read &lt;&lt; = 8; <br>  CRC_read | = spi_in_data [NVMCTRL_PAGE_SIZE-1]; <br>  } <br>  // if the last bay ff, then look for a place crc <br>  else <br>  { <br>  i = NVMCTRL_PAGE_SIZE-1; <br>  while ((spi_in_data [i] == 0xff) &amp;&amp; (i&gt; 0)) <br>  { <br>  i--; <br>  } <br>  CRC_read = spi_in_data [i]; <br>  CRC_read &lt;&lt; = 8; <br>  CRC_read | = spi_in_data [i-1]; <br>  // this is the last byte position of crc <br>  last_page_length = i + 1; <br>  break; <br>  } <br>  } <br>  } <br>  // directly consider crc <br>  for (page_addr = 0x4000; page_addr &lt;last_page_number + 1; page_addr + = NVMCTRL_PAGE_SIZE) <br>  { <br>  // read the page <br>  nvm_read_buffer (page_addr, spi_in_data, NVMCTRL_PAGE_SIZE); <br>  temp = 0; <br>  // swap adjacent bytes in the read <br>  for (j = 0; j &lt;NVMCTRL_PAGE_SIZE; j + = 2) <br>  { <br>  temp = spi_in_data [j]; <br>  spi_in_data [j] = spi_in_data [j + 1]; <br>  spi_in_data [j + 1] = temp; <br>  } <br>  if (page_addr == last_page_number) <br>  { <br>  // read separately crc parts of the page before the CRC linker <br>  CRC = slow_crc16 (CRC, spi_in_data, last_page_length-2); <br>  // after CRC linker <br>  temp = NVMCTRL_PAGE_SIZE-last_page_length; <br>  CRC = slow_crc16 (CRC, &amp; (spi_in_data [last_page_length]), temp); <br>  } <br>  // if the entire page code <br>  else <br>  { <br>  CRC = slow_crc16 (CRC, spi_in_data, NVMCTRL_PAGE_SIZE); <br>  } <br>  } <br>  for (i = 0; i &lt;NVMCTRL_PAGE_SIZE; i ++) spi_in_data [i] = 0xff; <br>  while (page_addr &lt;0x10000) <br>  { <br>  CRC = slow_crc16 (CRC, spi_in_data, NVMCTRL_PAGE_SIZE); <br>  page_addr + = NVMCTRL_PAGE_SIZE; <br>  } <br>  CRC = slow_crc16 (CRC, zero, 2); <br>  } // end o fwhile ((CRC! = CRC_read) &amp;&amp; (k &lt;5)) <br>  // if crc does not match <br>  if (CRC! = CRC_read) <br>  { <br>  while (1) <br>  { <br>  LED_1_TOGGLE (); <br>  delay_ms (500); <br>  } <br>  } <br>  // if CRC converged <br>  else <br>  { <br>  MC_reset (); <br>  start_application (); <br>  } <br>  } <br>  CRC = 0; <br>  ////////////////////////////////////////////////// ////////////////////////////// <br>  // ------------------------------ MAIN PROGRAM ---------------- ------------------- <br>  ////////////////////////////////////////////////// ////////////////////////////// <br>  while (1) <br>  { <br>  // read the page to check the CRC <br>  for (page_addr = 2; page_addr &lt;last_page_number + 1; page_addr ++) <br>  { <br>  // read the page <br>  continuous_low_freq_read (spi_in_data, page_addr, 0, ext_flash_page_size); <br>  temp = 0; <br>  // swap adjacent bytes in the read <br>  for (j = 0; j &lt;ext_flash_page_size; j + = 2) <br>  { <br>  temp = spi_in_data [j]; <br>  spi_in_data [j] = spi_in_data [j + 1]; <br>  spi_in_data [j + 1] = temp; <br>  } <br>  if (page_addr == last_page_number) <br>  { <br>  // read separately crc parts of the page before the CRC linker <br>  CRC = slow_crc16 (CRC, spi_in_data, last_page_length-2); <br>  // after CRC linker <br>  temp = ext_flash_page_size-last_page_length; <br>  CRC = slow_crc16 (CRC, &amp; (spi_in_data [last_page_length]), temp); <br>  } <br>  // if the entire page code <br>  else <br>  { <br>  CRC = slow_crc16 (CRC, spi_in_data, ext_flash_page_size); <br>  } <br>  } <br>  // translate the address into bytes from the page numbers of the external flash <br>  page_addr &lt;&lt; = 8; <br>  for (i = 0; i &lt;NVMCTRL_PAGE_SIZE; i ++) spi_in_data [i] = 0xff; <br>  while (page_addr &lt;0xc200) <br>  { <br>  CRC = slow_crc16 (CRC, spi_in_data, NVMCTRL_PAGE_SIZE); <br>  page_addr + = NVMCTRL_PAGE_SIZE; <br>  } <br>  CRC = slow_crc16 (CRC, zero, 2); <br><br>  // if CRC matched <br>  // read again and write to our flash <br>  // otherwise go to application with some flag <br>  // for rolling back the CRC firmware, we don‚Äôt count: we don‚Äôt know its size and CRC location <br>  // but by default they are both 0 <br>  if (CRC == CRC_read) <br>  { <br>  page_addr = 0x4000; <br>  for (i = 0; i &lt;15; i ++) <br>  { <br>  // erase and write new firmware <br>  continuous_low_freq_read (spi_in_data, i, 0, NVMCTRL_PAGE_SIZE); <br>  program_memory (page_addr, spi_in_data, 256); <br>  page_addr + = 256; <br>  delay_ms (10); <br>  } <br>  twi_out_data [0] = EEPROM_FW_RESULT; <br>  twi_out_data [1] = 0xda; <br>  twi_write_bytes (twi_out_data, 2, EEPROM_ADR, EEPROM_FW_RESULT); <br>  } <br>  else <br>  { <br>  twi_out_data [0] = EEPROM_FW_RESULT; <br>  twi_out_data [1] = 0xad; <br>  twi_write_bytes (twi_out_data, 2, EEPROM_ADR, EEPROM_FW_RESULT); <br>  } <br>  // erase only the command for flashing <br>  // parameters of the firmware do not erase <br>  delay_ms (100); <br>  twi_out_data [0] = EEPROM_UPGRADE; <br>  twi_out_data [1] = 0xff; <br>  twi_write_bytes (twi_out_data, 2, EEPROM_ADR, EEPROM_UPGRADE); <br>  delay_ms (100); <br>  for (j = 2; j &lt;2048; j ++) <br>  { <br>  // erase the entire flash, except for the first two pages, in which the addresses of the bindings <br>  erase_page (j); <br>  temp = flash_wait (spi_delay); <br>  temp = 0; <br>  } <br>  for (i = 0; i &lt;20; i ++) <br>  { <br>  LED_1_TOGGLE (); <br>  delay_ms (300); <br>  } <br>  MC_reset (); <br>  start_application (); <br><br>  } // end of while (1) <br>  } // end of main <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/275381/">https://habr.com/ru/post/275381/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275371/index.html">Atmel Software Framework (ASF): how does it work?</a></li>
<li><a href="../275373/index.html">1-Wire slave on MK. Part 1: Iron</a></li>
<li><a href="../275375/index.html">Clocking Atmel microcontrollers SAMD20 / 21</a></li>
<li><a href="../275377/index.html">1-Wire slave on MK. Part 2: Implementing in code</a></li>
<li><a href="../275379/index.html">Dialog and Atmel have announced a merger. Comments of the official distributor in Russia</a></li>
<li><a href="../275383/index.html">Connecting the temperature sensor and iButton key reader to Queclink GV300 / GV320 trackers</a></li>
<li><a href="../275385/index.html">Atmel Launches Studio 7 Development Environment and Atmel START Web Platform - Software Configuration and Software Generation Tool</a></li>
<li><a href="../275387/index.html">Diagnostic connector OBDII: whether it is possible to ‚Äútame‚Äù</a></li>
<li><a href="../275389/index.html">Using ASF and Atmel Start in IAR</a></li>
<li><a href="../275391/index.html">We give debugging SAM4S-EK + Atmel SAM-ICE programmer for publishing on the Internet (the action is completed)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>