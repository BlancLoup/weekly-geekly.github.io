<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a component approach on the web: an overview of web components</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Four of the five most requested Edge user-defined platform features on User Voice (Shadow DOM, Template, Custom Elements, HTML Imports) belong to a fa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a component approach on the web: an overview of web components</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ca7/260/02a/ca726002acc4455bb0afa6b3c1e27705.PNG"><br><br>  Four of the five most requested Edge user-defined platform features on User Voice (Shadow DOM, Template, Custom Elements, HTML Imports) belong to a family of APIs called Web Components.  In this article, we want to talk about web components and our view of them, some in-house kitchen, for those who are not familiar with them, as well as speculate on where all this may evolve in the future.  This is a rather long story, so sit back, take a coffee (or not a caffeine drink) and start reading. <br><br>  Content: <br><ul><li>  Component implementation: old design practice that has become new to the web </li><li>  How to break into components </li><li>  This is not the first time: previous approaches to the implementation of components </li><li>  Modern web components </li><li>  Web components: the next generation </li></ul><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Component implementation: old design practice that has become new to the web </h2><br>  Modern web applications are as complex as any other software applications, and are often created by several people joining forces to create the final product.  In such conditions, in order to increase efficiency, it is natural to look for the right ways to divide work into areas with minimal intersections between people and subsystems.  The implementation of the component approach (as a whole) is how this problem is usually solved.  Any component system must <i>reduce the</i> overall complexity through the provision of <b>isolation</b> , or natural barriers that hide the complexity of some systems from others.  Good insulation also facilitates reuse and implementation of service paradigms. <br><br>  Initially, the complexity of web applications was mainly regulated by the server by dividing the application into separate pages, which required the user to switch from one page to another in the browser accordingly.  With the introduction of AJAX and related technologies, developers were able to abandon the need to make "transitions" between different pages of a web application.  For typical scenarios such as reading mail or news, user expectations have changed.  For example, after login to the mail, you can ‚Äúuse the mail application‚Äù from the same address (URL) and stay on this page for a whole day (the so-called <a href="https://en.wikipedia.org/wiki/Single-page_application">Single-Page Applications</a> , SPA).  The logic of client-side web applications in such situations becomes much more complicated, sometimes it even becomes more complicated than on the server side.  A possible resolution of this complexity may be a further division into components and isolation of logic within a single page or document. <br><br>  <b>The goal of web components is to reduce complexity by isolating related groups of HTML, CSS, and JavaScript code to perform common functionality <i>within the</i> context of a single page.</b> <br><br><h2>  How to break into components? </h2><br>  Since web components must tie together HTML, CSS, and JavaScript, it is necessary to take into account the existing isolation models inherent in each of the technologies, as they affect the scripts and integrity of the web components.  These independent insulation models include: <br><br><ul><li>  CSS Isolation </li><li>  Javascript and scope (closures) </li><li>  Isolation of a global object </li><li>  Element encapsulation (iframe) </li></ul><br><br><h3>  CSS Isolation </h3><br>  In today's platform, there is no perfect and natural way to split CSS into components (although tools like <a href="http://sass-lang.com/">Sass</a> can help a lot).  The component model should offer a mechanism to isolate one CSS subset from another, so that the rules will not affect each other.  In addition, component styles should apply only to the direct parts of the component and nothing else.  Easier said than done! <br><br>  Inside the style sheets, CSS rules are applied to the document using selectors.  Selectors are always considered as potentially applicable to the whole document, therefore their scope is, in essence, global.  Global application leads to real conflicts when several people working on a project mix their CSS files together.  C intersections and repetitions of selectors can be dealt with in a precise order (for example, cascades, specificity, order of source) for resolving conflicts, however, such actions are quite likely - not at all what the developers wanted.  There are many potential ways to solve this problem.  A simple solution is to transfer elements and related styles that participate in the formation of a component from the main document to another document (shadow document) so that they will no longer ‚Äúreact‚Äù to other people's selectors.  This leads to the second problem: now that we have separated them, how can a certain style cross the border (to control the outside of the component)?  The obvious possible solution is to use JavaScript explicitly, but it looks like something awful: relying on JavaScript to transfer styles across the border, which seems more like a space in CSS. <br><br>  To transfer styles across a component border in an efficient manner and at the same time protect the structure of a component (for example, to allow the freedom to change the structure without affecting styles), there are two general approaches that many prefer: ‚Äúpartial‚Äù styling using pseudo-elements and <a href="http://www.w3.org/TR/css-variables/">custom properties</a> (previously known as ‚Äúvariable‚Äù CSS).  For a while, the super-powerful cross-border selector '&gt;&gt;&gt;' (defined in <a href="https://drafts.csswg.org/css-scoping/">CSS Scoping</a> ) was also considered, but today it is not universally accepted as a very good idea, as it easily breaks the isolation of components. <br><br>  Partial stylization will allow the authors of the component to create their own pseudo-elements for stylization, thus exposing the outside world only a part of its internal structure.  This is similar to the model that browsers use to place <a href="https://msdn.microsoft.com/en-us/library/windows/apps/hh767361.aspx">"parts" of native controls</a> .  For the integrity of this scenario, authors will also need some way to limit the set of styles that can apply to a pseudo-element.  Additional research of this ‚Äúpartial model‚Äù based on pseudo-elements may lead to the appearance of convenient stylistic primitives, although the elaboration of details will still require effort.  Further work on the partial model should also rationalize the <a href="http://dev.w3.org/csswg/css-forms/">styling of native controls in browsers</a> (an area that clearly needs attention). <br><br>  <a href="http://www.w3.org/TR/css-variables/">Custom properties</a> will allow authors to describe the values ‚Äã‚Äãof the styles that they want to reuse in style sheets (defined as their own double-dash property names as a prefix).  Custom properties are inherited through the document sub-tree, allowing selectors to redefine the value of the custom property for a particular sub-tree without affecting other sub-trees.  Custom properties can also be inherited across component boundaries, providing an elegant component styling mechanism that avoids the disclosure of the internal structural nature of the component.  Custom properties were evaluated when developing various component frameworks in Google and, according to reports, allow to cover most of the stylization needs. <br><br>  Of all the approaches currently being considered for styling, the future ‚Äúpartial‚Äù model and the current specification of custom properties seem to have the greatest chance of implementation.  We consider custom properties as a new key member of the web component specification. <br><br><h4>  Other approaches to isolating CSS styles </h4><br>  To complete the picture, the scope and isolation of CSS is not such a black and white area as it might seem above.  In fact, several past and current approaches offer options for limiting the scope and isolation with varying applicability to web components. <br><br>  CSS offers some limited forms of isolation of selectors in specific scenarios.  For example, the @ ‚Äçmedia rule groups a set of selectors together and applies them when conditions match the media context (for example, the size or resolution of the viewport, or the media type ‚Äî print, etc.);  The @ ‚Äçpage rule defines some styles that are applicable only in the context of printing;  <a href="http://dev.w3.org/csswg/css-conditional/">The @ ‚Äçsupports rule</a> brings together selectors for use only when support for specific CSS functionality is implemented (a new form of determining the presence of functionality in CSS);  the proposed <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/%40document">@ ‚Äçdocument</a> rule groups selectors for use only when the document in which the styles are loaded meets the conditions. <br><br>  <a href="http://dev.w3.org/csswg/css-scoping/">CSS scopes</a> (originally written as part of working on web components) offer a way to limit the applicability of CSS selectors within a single HTML document.  The specification introduces the new @ ‚Äçscope rule, which allows the selector to determine the root (s) of the application and further leads to the fact that applying all selectors within the @ ‚Äçscope rule will work only in the subtree of this root (and not on the entire document).  The specification allows you to specify the root of the domain declaratively in HTML (for example, the &lt;style scoped&gt; attribute is suggested, as long as it is implemented only in Firefox; this functionality was previously available as an experimental feature in Chrome, but was completely removed later).  Some aspects of this functionality (for example,: scope, defined in <a href="http://dev.w3.org/csswg/selectors/">Selectors L4</a> ) can also be applied to the relative evaluation of selectors in the <a href="https://dom.spec.whatwg.org/">new query API in the DOM specification</a> . <br><br>  It is important to note here that @ ‚Äçscope establishes only <i>one-directional</i> isolation of boundaries: selectors contained within @ ‚Äçscope are limited to this area, while any other selectors (outside @ scope) can quietly penetrate inside @ ‚Äçscope (although they can be - in various ordered cascade styles).  This is a somewhat unfortunate design, as it does not provide for limiting the scope and isolation from any styles that are not in the @ ‚Äçscope subset - all CSS should still ‚Äúfit well‚Äù to avoid styling inside another @ ‚Äçscope rule.  See also the <a href="http://lists.w3.org/Archives/Public/public-webapps/2015JanMar/0127.html">@ ‚Äçin-shafow-of draft from Taba</a> , which is better aligned with the component insulation protection model. <br><br>  Another suggestion of visibility limitations is <a href="http://dev.w3.org/csswg/css-containment/">containment in CSS</a> .  Holding the field of view is less about isolating styles and selectors and more about isolating ‚Äúcomposition‚Äù.  Inside the ‚Äúcontain‚Äù property, the behavior of some CSS features that have natural inheritance (in the sense of applicability from the parent to the child in the document, for example, counters) will be blocked.  The main use of this for developers is to indicate that some elements imply strict ‚Äúcontainment‚Äù, so a composition applicable to this element and its subtree will never affect the composition of other elements of the document.  These promises of containment (indicated by the use of the "contain" property) allow browsers to optimize the composition and rendering so that the "new" composition of the held subtree will only require updating this subtree, and not the entire document. <br><br>  As technology implementations for web components mature among browsers and find more and more public applications, additional styling patterns and problems may appear;  we look forward to further investment and subsequent progress in the various proposals in CSS to improve the styling of web components. <br><br><h3>  Javascript and scopes </h3><br>  All JavaScript code that is included on the page has access to the same global object.  Like other programming languages, JavaScript has scopes that provide some level of ‚Äúprivacy‚Äù for function code.  These lexical scopes are used to isolate variables and functions from the rest of the global environment.  The ‚Äúmodular template‚Äù in JavaScript, which is popular today (using lexical scopes), evolved from the need of many JavaScript frameworks to ‚Äúcoexist‚Äù in a single global environment without ‚Äústepping on the heels‚Äù of each other (depending on the order of loading). <br><br>  JavaScript lexical visibility areas are a unidirectional isolation of borders: the code inside the region can have access to both the internal content and the content of any parent area up to the global one, while the code outside the area does not have access to its content.  <i>An important principle</i> is that the unidirectional method of isolation gives preference to the code inside the region, that is, protects it.  The code inside the lexical area has the ability to protect / hide itself from the rest of the environment (or not). <br><br>  The contribution that the lexical scopes of JavaScript make to the implementation of a web component meets the requirement to have a way to ‚Äúclose‚Äù a component so that its contents can be reasonably private. <br><br><h3>  Isolation of a global object </h3><br>  For some code, it may not be desirable for it to have global access to the global environment, as described above.  For example, an application developer may not trust some JavaScript code, although it provides significant value.  A typical case is advertising and advertising frameworks.  For security reasons, it is necessary that the untrusted code be executed in a separate clean script environment (with its own global object).  To achieve this behavior today (without the inclusion of iframe elements in the game), developers can use <a href="http://www.w3.org/TR/workers/">workers</a> .  However, the disadvantage of this solution is that the workers do not have access to the elements, that is, the UI. <br><br>  There are a number of considerations that need to be taken into account when designing components that support the isolation of a global object ‚Äî especially if the isolation implies protected boundaries (more details below).  Today, we expect that the isolated components will not be fully accessible until the basic set of web component specifications is fixed (that is, it is ‚Äúpostponed until the next version‚Äù).  However, if we spend some time exploring how the isolated components may look, it can put the current work in the right direction.  <a href="">Some offers</a> really worth paying attention to. <br><br>  Isolating a global object is an important unimplemented script for web components.  In the meantime, we are working on implementation, for example, we can rely on the most successful and widely used way of introducing componentuality to the web: the iframe element. <br><br><h3>  Element encapsulation (iframe) </h3><br>  Iframe elements and their close relatives: the object, frameset and imperative API windows.open () elements already provide the ability to work in an isolated subtree of elements.  However, if components imply work within a single document, the iframe includes an entire HTML document within it;  as if two separate web applications were co-located, just one inside the other.  Each has a unique document address, global environment for scripts and CSS scope;  each document is completely separate from the other. <br><br>  Iframe is currently the most successful (and the only widely implemented) form of Web component authorization.  Iframe allows you to interact with various web applications.  For example, many sites use iframe precisely as a form of a component for all sorts of scenarios from advertising to user login.  However, the iframe ran into a number of challenges and some ways to deal with these challenges appeared: <br><ul><li>  JavaScript code inside one HTML document can potentially invade the isolation boundaries of other documents (for example, through the contentWindows property of the iframe element).  This possibility of trespassing may be a necessary need, but it also represents a security risk when the contents of the iframe contain sensitive information that you would not want to share.  Today, unwanted violations can be regulated <a href="http://en.wikipedia.org/wiki/Same-origin_policy">by common source policies</a> : documents with URLs from one source can violate default boundaries, while documents from different sources have limited ability to interact with each other. </li><li>  Border violation is not the only security risk.  Using <a href="http://www.w3.org/TR/html5/embedded-content-0.html">the &lt;iframe sandbox&gt; attribute</a> imposes further restrictions on iframes from other sources in order to protect the host environment from unwanted scripts, pop-ups, navigation changes and other features available in the iframe. </li><li>  External document CSS styles cannot be applied to an internal document.  This architectural solution follows the principle of isolation.  However, the isolation of styles creates a significant gap in the integration of the iframe as a component (within the common source of origin).  HTML addresses this problem with the proposed <a href="http://www.w3.org/html/wg/drafts/html/master/single-page.html">&lt;iframe seamless&gt; attribute</a> for a common source iframe.  This ‚Äúseamlessness‚Äù attribute removes the isolation of the frame's content styles;  seamlessly included documents take a copy of the stylesheets of the host document and are displayed as if their restrictions to the iframe element in which they were included were not. </li></ul><br><br>  With good security policies and the ability to insert a frame seamlessly, using an iframe as a model for components seems like a very attractive solution.  However, several properties that are desirable in the web components model are still missing: <br><ul><li>  Deep integration.  Iframe limits (and basically disables) the integration and interaction of models between the host and the frame document.  For example, with respect to the host: the focus and allocation model is independent, and the transmission of events is isolated by one or another document.  For components that suggest closer integration, support for this behavior is not possible without the introduction of some ‚Äúagent‚Äù in the host document that would forward information across the border. </li><li>  The multiplication of global objects.  For each iframe entity created on the page, there will be a unique global object.  A global object and its associated complete type system is not cheap to create and can lead to a large amount of memory consumption and an excessive browser load.  Multiple copies of the same component used on the same page do not need to be isolated from each other; in practice, having a common global object may be desirable, especially if they need to maintain a certain general condition. </li><li>  Host Content Usage Model.  Iframe does not allow the reuse of the content model of the host element within the frame document.  (For simplicity: the <i>content model of an</i> element is its supported subtree of elements and text.) For example, select-elements have a content model that includes option-elements.  A select element implemented as a component will want to interact in some way with its child elements. </li><li>  Selective styling.  Seamless iframe does not work with documents from different sources.  There are clear security risks if this were allowed.  The main problem is that the ‚Äúseamlessness‚Äù is controlled by the host, and not by the frame document (the frame document is often the victim of attacks).  For a component, the two-digit possibility of including "seamless" (whether or not) may be too expensive;  components would rather choose to decide which styles from the host are applicable to their content (instead of automatically inheriting all styles, that is, how seamlessness works).  <b>In general, the question of what should be styled should be resolved by the component itself</b> . </li><li>  Expose API.  Many scripts for web components involve the creation of full-fledged custom elements with their own exposed API set, display semantics and lifecycle management.  Using an iframe restricts the developer to work within the iframe API, with all its features.  For example, you cannot influence the parameters of the iframe itself and its life cycle. </li></ul><br><br><h2>  This is not the first time. </h2><br>  We can not fail to note that in the past several technologies have already been proposed and even implemented in an attempt to improve the work of the iframe in HTML and the associated encapsulation capabilities.  However, none of them got accustomed to a large extent in the modern web: <br><ul><li>  <a href="http://www.w3.org/TR/NOTE-HTMLComponents">HTML Components</a> (1998) have been proposed and implemented by Microsoft since IE5.5 (out of date in IE10).  The intention was to use a declarative model to add events and APIs to the host element (including isolation) and parse the components into some ‚Äúviewlink‚Äù (like the ‚Äúshadow DOM‚Äù).  Two types of behavior of components were available: they were simultaneously attached to an element, the other was dynamically linked through the CSS property ‚Äúbehavior‚Äù. </li><li>  <a href="http://www.w3.org/TR/2001/NOTE-xbl-20010223/">XBL</a> (2001) and its successor <a href="http://www.w3.org/TR/xbl/">XBL2</a> (2007) were proposed by Mozilla as an addition to XUL to describe interfaces.  It is a declarative language with two linking capabilities (similar to Microsoft‚Äôs HTML components), XBL also supported additional access to the host content model and content generation. </li></ul><br><br><h2>  Modern web components </h2><br>  After the failure of the first two attempts, it was time to try to launch the game into components again, this time Google took up the business.  Using the concepts described in XBL as a starting point, the monolithic component system was broken down into a collection of <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">building blocks for components</a> .  These building blocks allowed web developers to experiment with individual useful features before the overall vision for the web components is fully defined.  The component of the approach itself and the development of individual useful features allowed us to move closer to success.  Almost everyone can find something useful in their web components for their application! <br><br>  This new wave of web components has led to a set of <a href="http://www.w3.org/2008/webapps/wiki/Component_Model_Use_Cases">concrete use cases</a> explaining how existing embedded elements work within today's web platform.  In theory, web components will allow developers to prototype new types of HTML elements with the same accuracy and characteristics as native elements (in practice, ensuring accessibility in HTML is especially difficult to achieve today). <br><br>  It is clear that the full set of all technologies necessary to cover all scenarios for the use of web components will not be implemented immediately in browsers.  Browser developers work together to align a basic set of technologies that can be consistently implemented before moving on to additional scenarios. <br><br>  The first generation of web components includes: <br><ul><li>  <a href="http://w3c.github.io/webcomponents/spec/custom/">Custom elements</a> .  Custom elements define the extension point of the HTML parser so that it can recognize the names of the new ‚Äúcustom elements‚Äù and automatically provide them with the necessary JavaScript object model.  Custom elements do not create component boundaries, but they do provide the browser with a way to attach APIs and behaviors to original elements.  Browsers that do not support custom elements can simulate them (through polyfiles) with some accuracy, using events and change monitors and adjusting the prototype.  Proper planning and understanding of the implications is a key element of our upcoming meetings. </li><li><ul><li>  <b>The ‚Äúis‚Äù attribute</b> .  It is hidden inside the specification of custom elements, but provides critical functionality ‚Äî the ability to specify that the embedded element should receive the name of custom elements and new APIs.  In the usual case, a custom element is based on some common element;  using ‚Äúis‚Äù, the native element can be used as a basis (for example, &lt;input is = ‚Äùcustom-input‚Äù&gt;).  Although this functionality is a great way to inherit the benefits of embedded rendering, accessibility, parsing, etc., the syntax of this functionality is perceived rather as a hack, and it is believed that perhaps the primitives for accessibility and the stylization of native elements is more appropriate in the long run. plan for standardization. </li></ul></li><li>  <a href="http://w3c.github.io/webcomponents/spec/shadow/">Shadow DOM</a> (Shadow DOM).  Provides an imperative API for creating a separate element tree that can be connected (one-time) to the host element.  Such "shadow" descendants replace the "real" descendants when displaying a document.  The shadow DOM also provides a mechanism for using the content model of host elements using new slot elements (recently proposed), solves the problem with the target element of events and adds open / closed modes of operations (also recently added).  This relatively trivial idea has a surprisingly large number of third-party effects in everything, starting with the focus model and selection and ending with composition and propagation (for a shadow DOM inside a shadow DOM). </li><li><ul><li>  CSS <a href="http://dev.w3.org/csswg/css-scoping/">scopes</a> define various pseudo-elements relevant to the styling of a shadow DOM, including: host, :: content (it may soon become :: slot), and the former ‚Äú&gt;&gt;&gt;‚Äù (permeating the shadow DOM combinator), which is now officially disavowed . </li></ul></li><li>  <a href="http://www.w3.org/TR/html5/scripting-1.html">Template element</a> .  It is included for completeness, this functionality was previously part of the web components, and is now part of the <a href="http://www.w3.org/TR/html5/">HTML5 recommendation</a> .  The template element introduces the concept of inertia (the child elements of the template do not lead to the loading of resources, do not respond to user input, etc.).  This is a way to declaratively create an unlinked subtree of an element in HTML.  A template can be used for different tasks: from the actual template samples and data binding to the provision of content for the shadow DOM. </li><li>  <a href="http://w3c.github.io/webcomponents/spec/imports/">HTML Imports</a> .  Specifies the declarative syntax for ‚Äúimport‚Äù (request, load, or parse) HTML into a document.  Import requests (using a link element with rel = "import") execute the scripts of the document being imported in the context of the host page (thus having access to the same global object and state).  HTML, JavaScript, and CSS parts of a web component can, respectively, be loaded using a single import. </li><li>  <a href="http://www.w3.org/TR/css-variables/">Custom properties</a> .  As described in more detail above, custom properties described outside the component and available for use inside the component are a simple and convenient model for styling components today.  Considering this, we have included custom properties in the first generation of technologies for web components. </li></ul><br><br><h2>  Web components: the next generation </h2><br>  As we noted at the beginning of this article, building full-featured web components is a great adventure.  Several ideas for developing and filling gaps in the current generation of opportunities have already begun to circulate among developers (this is not a complete list!): <br><br><ul><li>  <b>Declarative Shadow DOM</b> .  It becomes important when you are thinking about how to transfer components in a serialized manner.  Without a declarative form, techniques like innerHTML or XMLSerializer will not be able to build a string representation of the DOM that includes any shadow content.  In other words, the shadow DOM today cannot be converted to and from a string without the help of a script.  <a href="http://lists.w3.org/Archives/Public/public-webapps/2015AprJun/0052.html">Mozilla's Anne suggested the &lt;shadowdom&gt;</a> element as a topic for discussion.  Similarly, a template element is already a declarative way to build "shadow" markup and the serialization methods in the browser have already adjusted to this feature and, accordingly, serialize the "shadow" content of the template in the correct way. </li><li>  <b>Fully insulated components</b> .  <a href="http://lists.w3.org/Archives/Public/public-webapps/2015AprJun/0052.html">Three browser makers</a> made three different offers in this area.  These proposals are already quite well coordinated, which is good news in terms of reaching a consensus.  As mentioned earlier, isolated components will use new global objects and can be imported from other sources.  They will also have a reasonable model for exposing APIs and related behaviors across their isolation boundary. </li><li>  <b>Primitives accessibility</b> .  Many accessibility communities sympathize with the ‚Äúis‚Äù idea (from custom elements) as a way of extending existing native elements, as they already contain accessibility mechanisms that are not always available to JavaScript developers.  Ideally, regular web components (without using ‚Äúis‚Äù) could include aspects of accessibility in much the same way as native elements, among other things, including sending forms and the ability to focus.  Such expansion points are not possible today, but must be worked out and defined. </li><li>  <b>Single stylization of native controls</b> .  The gap in the presence of a stylized control model between browsers is an interoperability problem that interferes, for example, with the proliferation of simple ‚Äútheme change‚Äù extensions.  This leads to the fact that developers often consider a shadow DOM as an alternative solution (although creating markup in a shadow DOM with behavior similar to that of native elements may be nontrivial).  <a href="http://dev.w3.org/csswg/css-forms/">   </a>   CSS-,           . </li><li> <b>  CSS</b> .    CSS        -,   ,       ,   ,         .    ,    ,  <a href="http://tjvantoll.com/2013/04/15/list-of-pseudo-elements-to-style-form-controls/">  </a>       . </li><li> <b> </b> .    ,            .       <a href="https://github.com/w3c/webcomponents/issues/113">  </a>   -. </li></ul><br><br> ,        -,   iframe     .  , iframe ‚Äì        -,    ,   .        ¬´¬ª  iframe.  ,       &lt;iframe seamless&gt;      . <br><br> - ‚Äì     .           .        <a href="https://twitter.com/msedgedev">@msedgedev</a> . </div><p>Source: <a href="https://habr.com/ru/post/264791/">https://habr.com/ru/post/264791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264775/index.html">Comparison of Drupal code execution speed for PHP 5.3-5.6 and 7.0. "Battle of code optimizers" apc vs xcache vs opcache</a></li>
<li><a href="../264777/index.html">A set of the second offline school of Android development has opened</a></li>
<li><a href="../264781/index.html">The world's first MMO strategy for programmers launched</a></li>
<li><a href="../264785/index.html">VNXe Storage Family - Small Business Solution at Reasonable Prices</a></li>
<li><a href="../264789/index.html">Release Cordova 5.2.0</a></li>
<li><a href="../264793/index.html">Brief history of the emergence of Mathematica</a></li>
<li><a href="../264795/index.html">When size matters</a></li>
<li><a href="../264797/index.html">I can do without Git, yeah</a></li>
<li><a href="../264799/index.html">Introduction to High Frequency Trading (HFT)</a></li>
<li><a href="../264801/index.html">Contingency Tables: Log Linear Models and Markov Networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>