<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Immersion in Android services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article "Deep Dive into Android Services" by Nazmul Idris. I left the original name of the author, although it is rather not "immer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Immersion in Android services</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/v3/fq/wt/v3fqwt2sf3uczb97gm-c4uckvbg.png" alt="image"></p><br><p>  Translation of the article <a href="https://proandroiddev.com/deep-dive-into-android-services-4830b8c9a09">"Deep Dive into Android Services"</a> by Nazmul Idris.  I left the original name of the author, although it is rather not "immersion", but "acquaintance".  I think the text will be useful for novice developers.  The article perfectly complements the <a href="https://developer.android.com/guide/components/services.html">off.</a>  <a href="https://developer.android.com/guide/components/services.html">service documentation on Android</a> .  The article deals with the features of interaction with running and associated services.  Plus, the articles are that changes in the work with services in Android O are taken into account. There are minor changes in comparison with the original, added for greater clarity. </p><a name="habracut"></a><br><h3 id="vvedenie">  Introduction </h3><br><p>  Most modern android applications perform part of the tasks in the background.  This means that tasks are performed in the background thread, and not in the user interface thread (UI thread). </p><br><p> If you create <code>Thread</code> (thread) or <code>Executor</code> (thread control wrapper) in a specific <code>Activity</code> your application, this can lead to unpredictable results.  For example, during a simple reorientation of the screen, your <code>Activity</code> is recreated, and for threads attached to the old <code>Activity</code> , there is no place to return the result. </p><br><p>  To deal with this you could use <code>AsyncTask</code> .  But what if your application needs to run this background thread not only from the <code>Activity</code> , but also from notification (or notification) or from another component? </p><br><p>  In this case, the service is a suitable component of Android, which will link the life cycle of the thread with its life cycle, and thus will not lose it. </p><br><p>  The service is a component of an android application without a visible interface that runs in the main application thread.  The service must be declared in the manifest.  If you need the service to work in a background thread, you must implement it yourself. </p><br><p>  The terms <em>background</em> and <em>foreground are</em> overloaded, and can be applied to: </p><br><ol><li>  the life cycle of Android components </li><li>  streams </li></ol><br><p>  In this article, by default we will assume that the terms <em>background</em> and <em>foreground</em> refer to the life cycle.  But when it comes to streams, we will clearly speak of a <em>background stream</em> or a <em>foreground stream</em> . </p><br><p>  There is a subclass of android services called <a href="https://developer.android.com/training/run-background-service/create-service.html"><code>IntentService</code></a> , which runs tasks in the background stream out of the box.  But we will not talk about such services in this article. </p><br><br><h3 id="potoki-sluzhby-i-zhiznennyy-cikl-komponentov-android">  Android threads, services, and life cycle </h3><br><p>  Let's take a step back and look at a more general picture of what services should do.  Your code that runs in a background thread, such as <code>Thread</code> or <code>Executor</code> , is not actually related to the life cycle of any Android component.  If we are talking about an <code>Activity</code> , then it has a specific point of starting and stopping work, based on user interaction.  However, these start and end points of an <code>Activity</code> not necessarily related to the life cycle of a <code>Thread</code> or an <code>Executor</code> . </p><br><p><img src="https://habrastorage.org/webt/pr/jx/db/prjxdbpwzjrzluprd_5vl9ko4hq.png" alt="image"></p><br><p>  Below are explanations of the main time points of this Gantt chart.  Details of these points (and explanations of them) are given in the rest of the article. </p><br><p>  The <code>onCreate()</code> service method is called at the time of its creation (by launching or linking to it). </p><br><p>  Then, after a while, the service starts <code>Thread</code> or <code>Executor</code> .  When <code>Thread</code> finishes, it lets the service know so that it can call the <code>stopSelf()</code> method.  This is a fairly common service implementation pattern. </p><br><p>  The code that you write in your <code>Thread</code> or <code>Executor</code> should inform the service about starting or stopping the background thread. </p><br><ul><li>  When a thread starts, it should set the initial state of the service by calling <code>startService()</code> </li><li>  When a thread exits, it should call <code>stopSelf()</code> on the service. </li></ul><br><p>  The <code>onDestroy()</code> service method is called by the system only when you inform the service that it is time to shut down.  The service does not know what will happen in the code of your <code>Thread</code> or <code>Executor</code> - this is your area of ‚Äã‚Äãresponsibility.  Thus, the task of the programmer is to inform the service about the beginning and completion of work. </p><br><p>  Services are divided into two types: <em>running</em> and <em>associated</em> .  In addition, the service may be running and allow binding.  We will consider each of the cases: </p><br><ol><li>  Running service </li><li>  Tied service </li><li>  Linked and running service at the same time </li></ol><br><br><h3 id="izmeneniya-v-android-o">  Android O changes </h3><br><p>  In Android O (API 26), there have been significant changes in the regulation of background services by the system.  One of the main changes is that a running service that is not in the white list (services that are visible to the user are placed on the white list; see the <a href="https://developer.android.com/about/versions/oreo/background.html">off-line documentation</a> for details) or that does not explicitly inform the user about its work will not run in the background flow after closing <code>Activity</code> .  In other words, you must create a notification (notification) to which you attach the running service.  And you must start the service with the new <a href="https://developer.android.com/reference/android/content/Context.html"><code>startForegroundService()</code></a> method (and not with <code>startService()</code> ).  And, after creating the service, you have five seconds to call the <a href="https://goo.gl/T5R8hv"><code>startForeground()</code></a> method of the running service and show the notice visible to the user.  Otherwise, the system stops the service and shows <a href="https://developer.android.com/training/articles/perf-anr.html">ANR</a> ("application does not respond").  Below we explain these provisions using code examples. </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3 id="zapuschennye-sluzhby">  Running services </h3><br><p>  Started services begin their work after calling the <code>startService(Intent)</code> method in your <code>Activity</code> or service.  In this case, the <code>Intent</code> should be explicit.  This means that you must explicitly indicate in <code>Intent</code> the class name of the service you are running.  Or, if it is important for you to allow some ambiguity about which service is running, you can provide intent filters for your services and eliminate the component name from the Intent, but then you must install the intent package with <code>setPackage()</code> , which provides sufficient ambiguity resolution for the target service.  Below we give an example of creating an explicit <code>Intent</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyIntentBuilder</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> MyIntentBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyIntentBuilder(context); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyIntentBuilder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mContext = context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MyIntentBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mMessage = message; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MyIntentBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Command </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> command)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mCommandId = command; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Intent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Assert.assertNotNull(<span class="hljs-string"><span class="hljs-string">"Context can not be null!"</span></span>, mContext); Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(mContext, MyTileService.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mCommandId != Command.INVALID) { intent.putExtra(KEY_COMMAND, mCommandId); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mMessage != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { intent.putExtra(KEY_MESSAGE, mMessage); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intent; } }</code> </pre> <br><p>  For the service to start, you must call <code>startService()</code> with explicit intent.  If you do not do this, then the service will not go into a running state.  And thus, it will not be able to go to the fore, and <code>stopSelf()</code> not actually do anything. </p><br><p>  So, if you did not put the service into a running state, you will not be able to attach it to the notification.  These are quite important things that you need to remember when you need to put a service into a running state. </p><br><p>  The service can be started several times.  Every time it is launched, <code>onStartCommand()</code> called.  Several parameters are passed to this method along with explicit <code>Intent</code> .  Even if you start a service several times, it calls <code>onCreate()</code> only once (of course, if the service was not already attached before).  To shut down, the service must call <code>stopSelf()</code> .  After the service is stopped (when you stop it), and if nothing else is associated with it, <code>onDestroy()</code> called.  Keep this in mind when allocating resources for your running service. </p><br><br><h3 id="intent">  Intent </h3><br><p>  In order to start a running service, an <code>Intent</code> required.  The Android component in which the service starts does not actually store the connection with it, and if it needs to inform something about the running service, it can start it again using another <code>Intent</code> .  This is the main difference between a running and anchored service.  Bound services for their part implement the <em>client-server</em> pattern.  Where the client (component of the Android UI or another service) stores the connection and can call methods directly at the service through it. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@TargetApi</span></span>(Build.VERSION_CODES.O) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveToStartedState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyIntentBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setCommand(Command.START).build(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPreAndroidO()) { Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"Running on Android N or lower"</span></span>); startService(intent); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"Running on Android O"</span></span>); startForegroundService(intent); } } }</code> </pre> <br><p>  Remember that in Android O, much has changed in terms of running services.  They can no longer work long enough in the background without a mechanism for constant notification.  And the start method of the running service in the background in Android O is <code>startForegroundService(Intent)</code> . </p><br><br><h3 id="peredniy-plan-i-mehanizm-postoyannogo-uvedomleniya">  Foreground and mechanism for continuous notification </h3><br><p>  The running service can run in the foreground.  Again, the term <em>foreground</em> does not refer to whether the service is running in the background thread or in the main thread.  But this means that the system will give the service the highest priority, and therefore the service is not a candidate for the system to delete in case of insufficient memory.  Putting service to the forefront is only when it is really necessary to create a modern and responsive application. </p><br><p>  Examples of using front-end services: </p><br><ol><li>  Applications that play media files in the background. </li><li>  Applications that update location data in the background. </li></ol><br><p>  When a running service is placed in the foreground, it should display a notification, explicitly telling the user that the service is running.  This is important because the running service in the foreground is separated from the life cycle of the UI components (with the exception, of course, of the constant notification itself).  And there is no other way to tell the user that something is working on his phone (and potentially consuming a lot of resources) other than to send a permanent notification to the UI. </p><br><p>  Below is an example of starting a running service in the foreground: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commandStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mServiceIsStarted) { moveToStartedState(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mExecutor == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Start Executor task in Background Thread. } } }</span></span></code> </pre> <br><p>  Here is the code to create a permanent notice in versions </p><br><div class="spoiler">  <b class="spoiler_title">before Android O</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TargetApi</span></span>(<span class="hljs-number"><span class="hljs-number">25</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreO</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Service context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Create Pending Intents. PendingIntent piLaunchMainActivity = getLaunchActivityPI(context); PendingIntent piStopService = getStopServicePI(context); // Action to stop the service. NotificationCompat.Action stopAction = new NotificationCompat.Action.Builder( STOP_ACTION_ICON, getNotificationStopActionText(context), piStopService) .build(); // Create a notification. Notification mNotification = new NotificationCompat.Builder(context) .setContentTitle(getNotificationTitle(context)) .setContentText(getNotificationContent(context)) .setSmallIcon(SMALL_ICON) .setContentIntent(piLaunchMainActivity) .addAction(stopAction) .setStyle(new NotificationCompat.BigTextStyle()) .build(); context.startForeground( ONGOING_NOTIFICATION_ID, mNotification); } }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">in Android O, through NotificationChannel</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@TargetApi</span></span>(<span class="hljs-number"><span class="hljs-number">26</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">O</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CHANNEL_ID = String.valueOf(getRandomNumber()); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Service context)</span></span></span><span class="hljs-function"> </span></span>{ String channelId = createChannel(context); Notification notification = buildNotification(context, channelId); context.startForeground( ONGOING_NOTIFICATION_ID, notification); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Notification </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Service context, String channelId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Create Pending Intents. PendingIntent piLaunchMainActivity = getLaunchActivityPI(context); PendingIntent piStopService = getStopServicePI(context); // Action to stop the service. Notification.Action stopAction = new Notification.Action.Builder( STOP_ACTION_ICON, getNotificationStopActionText(context), piStopService) .build(); // Create a notification. return new Notification.Builder(context, channelId) .setContentTitle(getNotificationTitle(context)) .setContentText(getNotificationContent(context)) .setSmallIcon(SMALL_ICON) .setContentIntent(piLaunchMainActivity) .setActions(stopAction) .setStyle(new Notification.BigTextStyle()) .build(); } @NonNull private static String createChannel(Service ctx) { // Create a channel. NotificationManager notificationManager = (NotificationManager) ctx.getSystemService(Context.NOTIFICATION_SERVICE); CharSequence channelName = "Playback channel"; int importance = NotificationManager.IMPORTANCE_DEFAULT; NotificationChannel notificationChannel = new NotificationChannel( CHANNEL_ID, channelName, importance); notificationManager.createNotificationChannel( notificationChannel); return CHANNEL_ID; } }</span></span></code> </pre> </div></div><br><p>  In addition, here <a href="https://medium.com/google-developers/migrating-mediastyle-notifications-to-support-android-o-29c7edeca9b7">is another article</a> that contains more details about creating notifications in MediaStyle (since for background playback of audio files, both notifications, associated and running services are needed) </p><br><br><h3 id="ostanovka--zapuschennyh-sluzhb">  Stop running services </h3><br><p>  Note that the <code>piStopService</code> parameter of type <code>PendingIntent</code> (which is passed to the notification constructor) actually transmits <code>Intent</code> with a <code>Command.STOP</code> constant of type <code>Integer</code> .  Remember that <code>startService(Intent)</code> can be called several times?  This is an example of this behavior.  To stop the service, we start the <code>Intent</code> via <code>startService(Intent)</code> and then process this <code>Intent</code> in the <code>onStartCommand()</code> method of the running service. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandleNotifications</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> PendingIntent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStopServicePI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Service context)</span></span></span><span class="hljs-function"> </span></span>{ PendingIntent piStopService; { Intent iStopService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyIntentBuilder(context) .setCommand(Command.STOP).build(); piStopService = PendingIntent.getService( context, getRandomNumber(), iStopService, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> piStopService; } }</code> </pre> <br><p>  This explains why the <code>onStartCommand()</code> method should be able to handle <code>Intent</code> s.  Using this mechanism, we can "tell" the service to stop work.  Below is the code that illustrates these features: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containsCommand = MyIntentBuilder .containsCommand(intent); d(TAG, String.format( <span class="hljs-string"><span class="hljs-string">"Service in [%s] state. cmdId: [%d]. startId: [%d]"</span></span>, mServiceIsStarted ? <span class="hljs-string"><span class="hljs-string">"STARTED"</span></span> : <span class="hljs-string"><span class="hljs-string">"NOT STARTED"</span></span>, containsCommand ? MyIntentBuilder.getCommand(intent) : <span class="hljs-string"><span class="hljs-string">"N/A"</span></span>, startId)); mServiceIsStarted = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; routeIntentToCommand(intent); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> START_NOT_STICKY; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routeIntentToCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// process command if (containsCommand(intent)) { processCommand(MyIntentBuilder.getCommand(intent)); } // process message if (MyIntentBuilder.containsMessage(intent)) { processMessage(MyIntentBuilder.getMessage(intent)); } } } }</span></span></code> </pre> <br><p>  If you want to complete the execution of a running service in the foreground, you must call <code>stopForeground(true)</code> .  This method will also terminate the ongoing notification.  However, the service itself will not stop it.  To do this, call <code>stopSelf()</code> . </p><br><p>  To stop the service, you can do one of the following: </p><br><ol><li>  As shown above, pass an <code>Intent</code> with an additional parameter to <code>startService()</code> , which will then be processed in <code>onStartCommand()</code> and the service will actually call <code>stopSelf()</code> .  And, if no other components are attached to the service, it will call <code>onDestroy()</code> and the service will complete its work. </li><li>  You can also create an explicit <code>Intent</code> (pointing to the service class) and pass it to the <code>stopService()</code> method, which will call <code>stopSelf()</code> and, then, <code>onDestroy()</code> similar to claim 1. </li></ol><br><p>  Here are some examples of stopping a service from an <code>Activity</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopService1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ stopService(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyIntentBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).build()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopService2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startService(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyIntentBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setCommand(Command.STOP).build()); } }</code> </pre> <br><p>  And here is the code in your service that will handle these requests (assuming that your running service is in the foreground): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ stopForeground(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); stopSelf(); } }</code> </pre> <br><br><h3 id="privyazannye-sluzhby">  Linked Services </h3><br><p>  Unlike running services, linked services allow you to establish a connection between the Android component associated with the service and the service.  This connection is provided by the implementation of the <code>IBinder</code> interface, which defines methods for interacting with the service.  A simple example of this would be implementing an associated service in the same process as the client (that is, as part of your own application).  In this case, the Java object, a <code>Binder</code> subclass, is passed to the client, which can use it to invoke service methods. </p><br><p>  In more complex scenarios, when it is necessary for the service interface to be available for different processes, the <code>Messenger</code> object should be used to provide the client with the service interface (this is a reference to the <code>Handler</code> object that receives a callback for each call from the client), so that you can interact with the service using <code>Message</code> objects.  The <code>Messenger</code> object is actually based on <a href="https://developer.android.com/guide/components/aidl.html">AIDL</a> (Android Interface Definition Language).  <code>Messenger</code> creates a queue from all client requests within one thread, so the service simultaneously receives only one request.  If you want the service to handle several requests at once, you can use AIDL directly. </p><br><p>  Differences between linked and running services: </p><br><ol><li>  The client component does not have a connection to the running service.  It simply uses the <code>Intent</code> objects via <code>startService()</code> or <code>stopService()</code> , which are processed by the service in the <code>onStartCommand()</code> method. </li><li>  When a client component ( <code>Activity</code> , <code>Fragment</code> or other service) is connected to an <code>IBinder</code> service, they get an <code>IBinder</code> implementation, through which they can call methods on the associated service. </li></ol><br><p>  In any case, when a service (linked or running) needs to send messages to a linked client, it should use something like <a href="https://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html"><code>LocalBroadcastManager</code></a> (if the client and the service are running in the same process).  Linked services usually do not connect directly to the bound client component. </p><br><br><h3 id="bindservice-i-oncreate">  bindService () and onCreate () </h3><br><p>  In order for the client component to become tied to the service, it is necessary to call <code>bindService()</code> with an explicit <code>Intent</code> , as is the case with the running service. </p><br><p>  Example: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ bindService( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyIntentBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).build(), mServiceConnection, BIND_AUTO_CREATE); } }</code> </pre> <br><p>  <code>BIND_AUTO_CREATE</code> is the most frequently encountered flag when <code>bindService()</code> called.  There are other flags (for example, <code>BIND_DEBUG_UNBIND</code> or <code>BIND_NOT_FOREGROUND</code> ).  In the case of <code>BIND_AUTO_CREATE</code> , the <code>BIND_AUTO_CREATE</code> service is called <code>onCreate()</code> , if the service has not yet been created.  In fact, this means that the service is created at the time of first binding to it. </p><br><p>  As soon as <code>bindService()</code> is called, the service needs to respond to the client's request and provide it with an instance of <code>IBinder</code> , through which the client can call the methods of the bound service.  In the example above, this is implemented using the <code>mServiceConnection</code> reference.  This is the <code>ServiceConnection</code> callback that the associated service will use to notify the client that the binding has completed.  It will also allow the client to know about the disconnection from the service. </p><br><p>  In other words, the binding is asynchronous.  <code>bindService()</code> returned immediately and <em>does not</em> return an <code>IBinder</code> object to the <code>IBinder</code> .  To obtain an <code>IBinder</code> object <code>IBinder</code> client must create an instance of the <code>ServiceConnection</code> and pass it to the <code>bindService()</code> method.  The <code>ServiceConnection</code> interface includes a callback method that the system uses to <code>IBinder</code> an <code>IBinder</code> object. </p><br><p>  The following is an example of the <code>ServiceConnection</code> implementation: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceConnection mServiceConnection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServiceConnection(){ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onServiceConnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ComponentName cName, IBinder service)</span></span></span></span>{ MyBinder binder = (MyService.MyBinder) service; mService = binder.getService(); <span class="hljs-comment"><span class="hljs-comment">// Get a reference to the Bound Service object. mServiceBound = true; } public void onServiceDisconnected(ComponentName cName){ mServiceBound= false; } }; }</span></span></code> </pre> <br><br><h3 id="privyazka-sluzhby">  Service binding </h3><br><p>  Let's see what happens on the side of the <code>bindService(Intent)</code> service when a client calls <code>bindService(Intent)</code> . </p><br><p>  In an <code>onBind()</code> service, you must implement the <code>onBind()</code> method in <code>onBind()</code> for the client to get an <code>IBinder</code> instance.  The 'onBind ()' method will be called only once, at the first binding of the client.  For subsequent customers, the system will issue the same copy of <code>IBinder</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IBinder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mBinder == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ mBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyBinder(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mBinder; } }</code> </pre> <br><p>  The <code>IBinder</code> object provides a programming interface through which clients can interact with the service.  As mentioned above, the easiest way to implement <code>IBinder</code> is an extension of the <code>Binder</code> class, an instance of which is returned from the <code>onBind()</code> method: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyBinder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">android</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">os</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Binder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">MyService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Simply return a reference to this instance //of the Service. return MyService.this; } } }</span></span></code> </pre> <br><p>  In the example above, we simply use the <code>getService()</code> method, which simply returns the Java object of the associated service to the client component.  Referring to this <code>IBinder</code> instance, the client can call public methods on the <code>IBinder</code> service directly.  Note that these methods are executed in the client thread.  And in the case of <code>Activity</code> or <code>Fragment</code> these methods will be executed in the main thread.  Therefore, it is worthwhile to be careful with methods in an anchored service that can block the stream or can cause ANR. </p><br><br><h3 id="otvyazka-ot-sluzhby-i-vyzov-ondestroy">  Unbinding from the service and calling onDestroy () </h3><br><p>     ,    <code>unbindService(mServiceConnection)</code> .    <code>onUnbind()</code>   . ,       ,  , ,     ,    <code>onDestroy</code> . </p><br><p>     <code>unbindService()</code>   : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mServiceBound){ unbindService(mServiceConnection); mServiceBound = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } }</code> </pre> <br><p>   ,  <code>onStop()</code>  <code>Activity</code>    <code>unbindService()</code> .     UX                <code>onStart()</code>  <code>onStop()</code> ,            . </p><br><p>      <code>onUnbind()</code>    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onUnbind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent i)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br><p>    <code>false</code> . ,   <code>true</code> ,         <code>onBind()</code>    <code>onRebind()</code> . </p><br><br><h3 id="privyazannye-i-zapuschennye-sluzhby-odnovremenno">      </h3><br><p>  ,     ,          .   ,        .       ,                        . </p><br><p>    ,  ,     ,  <code>onCreate()</code>  .    ,    .   ,           ,   <code>onDestroy()</code>   . </p><br><p>        startService(),         .  ,   ,       .   ,    ,      ,     <code>bindService()</code> .   ''"   ,      ,         ,         <code>stopSelf()</code> ,    ,       <code>stopService()</code> . </p><br><br><h3 id="perehod-v-zapuschennoe-sostoyanie">     </h3><br><p>  ,   ,      ,       ,        . ,       Android O: </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commandStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mServiceIsStarted) { moveToStartedState(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mExecutor == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { mTimeRunning_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPreAndroidO()) { HandleNotifications.PreO.createNotification(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HandleNotifications.O.createNotification(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } mExecutor = Executors .newSingleThreadScheduledExecutor(); Runnable runnable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ recurringTask(); } }; mExecutor.scheduleWithFixedDelay( runnable, DELAY_INITIAL, DELAY_RECURRING, DELAY_UNIT); d(TAG, <span class="hljs-string"><span class="hljs-string">"commandStart: starting executor"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { d(TAG, <span class="hljs-string"><span class="hljs-string">"commandStart: do nothing"</span></span>); } } <span class="hljs-meta"><span class="hljs-meta">@TargetApi</span></span>(Build.VERSION_CODES.O) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveToStartedState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyIntentBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setCommand(Command.START).build(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPreAndroidO()) { Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"moveToStartedState: on N/lower"</span></span>); startService(intent); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"moveToStartedState: on O"</span></span>); startForegroundService(intent); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStartCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Intent intent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containsCommand = MyIntentBuilder .containsCommand(intent); d(TAG, String.format( <span class="hljs-string"><span class="hljs-string">"Service in [%s] state. id: [%d]. startId: [%d]"</span></span>, mServiceIsStarted ? <span class="hljs-string"><span class="hljs-string">"STARTED"</span></span> : <span class="hljs-string"><span class="hljs-string">"NOT STARTED"</span></span>, containsCommand ? MyIntentBuilder.getCommand(intent) : <span class="hljs-string"><span class="hljs-string">"N/A"</span></span>, startId)); mServiceIsStarted = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; routeIntentToCommand(intent); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> START_NOT_STICKY; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routeIntentToCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// process command if (containsCommand(intent)) { processCommand(MyIntentBuilder.getCommand(intent)); } // process message if (MyIntentBuilder.containsMessage(intent)) { processMessage(MyIntentBuilder.getMessage(intent)); } } } private void processMessage(String message) { try { d(TAG, String.format("doMessage: message from client: '%s'", message)); } catch (Exception e) { e(TAG, "processMessage: exception", e); } } private void processCommand(int command) { try { switch (command) { case Command.START: commandStart(); break; case Command.STOP: commandStop(); break; } } catch (Exception e) { e(TAG, "processCommand: exception", e); } } /*...*/ }</span></span></code> </pre> </div></div><br><p>    : </p><br><ol><li>  <code>commandStart()</code>    ,    . </li><li>  <code>commandStart()</code>    <code>startService()</code>  <code>startForegroundService()</code> ( Android O). </li></ol><br><p> ,    ,       . </p><br><p> ,     ,  <code>commandStart()</code> .    .    ,  ,  : </p><br><ol><li>     ,     (  <code>mServiceStarted</code>  <code>false</code> ) </li><li>     <code>moveToStarted()</code>     <code>Intent</code>  Extras <code>Command.START</code> ,    <code>startService()</code>  <code>startForegroundService()</code> . </li><li>     <code>onStartCommand()</code> ,    <code>commandStart()</code> . </li><li>    <code>commandStart()</code>   <code>mServiceIsStarted</code>  <code>true</code> ,    <code>commandStart()</code>    , ..    . </li></ol><br><br><h3 id="zavershenie-raboty-sluzhby-i-otvyazyvanie">      </h3><br><p>            ,      <code>onDestroy()</code> </p><br><p>         .    "",       (  <code>stopService(Intent)</code>   <code>startService(Intent)</code> c Extras  <code>Intent</code> ,      ,  <code>Command.STOP</code> ). </p><br><p>  ,               : </p><br><p><img src="https://habrastorage.org/webt/gv/_j/f1/gv_jf1oaexg68ztiqx9lsl5sklq.png" alt="image"></p><br><br><h3 id="primery">  Examples </h3><br><p>    ,     ,    <a href="https://github.com/r3bl-alliance/stay-awake-app">GitHub</a> . </p><br><p>     Android O  N,      ,    . </p></div><p>Source: <a href="https://habr.com/ru/post/349102/">https://habr.com/ru/post/349102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349092/index.html">WIP: Product Design</a></li>
<li><a href="../349094/index.html">Multitasking or marijuana?</a></li>
<li><a href="../349096/index.html">SignalR Core. "Hello Habr!"</a></li>
<li><a href="../349098/index.html">We expand automation in a couple of hours: PHPUnit, Selenium, Composer</a></li>
<li><a href="../349100/index.html">Digest news from the world of PostgreSQL. Issue number 3</a></li>
<li><a href="../349104/index.html">Who killed the junior?</a></li>
<li><a href="../349106/index.html">What is a programmer?</a></li>
<li><a href="../349110/index.html">From MS SharePoint to Bitrix24: One Way Ticket</a></li>
<li><a href="../349112/index.html">Why IT wages will start falling soon?</a></li>
<li><a href="../349114/index.html">Avito Data Science Meetup: Personalization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>