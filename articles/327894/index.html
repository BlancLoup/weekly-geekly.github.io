<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a NetFlow sensor on an FPGA + CPU - flexibly and quickly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 


 As you understood from the title, another article about NetFlow awaits you, but this time from an unusual side - from the implementation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a NetFlow sensor on an FPGA + CPU - flexibly and quickly</h1><div class="post__text post__text-html js-mediator-article"><p>  Good day! </p><br><p>  As you understood from the title, another article about NetFlow awaits you, but this time from an unusual side - from the implementation of the NetFlow sensor on the FPGA. </p><br><img src="https://habrastorage.org/files/eb7/9bb/7e1/eb79bb7e1dab4dc9b08d761837ce7153.png"><br><a name="habracut"></a><br><h2>  Introduction </h2><br><p>  Yes, there are many articles on the topic of NetFlow on Habr√©: starting with a <a href="https://habrahabr.ru/post/175359/">detailed analysis and a HOWTO on tuning</a> , to an applied application in <a href="https://habrahabr.ru/post/90489/">catching a virus attack</a> and <a href="https://habrahabr.ru/post/127613/">traffic metering</a> . </p><br><p>  But this article is not about how to use NetFlow, it is about how to implement it. </p><br><p>  The task of creating a NetFlow sensor is interesting in that you need flexibility at the same time to support NetFlow templates that can be changed in real time and at the same time very high performance in order to efficiently handle traffic and work with memory. </p><br><p>  Where I work (I am an FPGA programmer at the STC Metrotek), we use platforms that allow us to choose between software and hardware implementations. </p><br><p>  But for the most part of our tasks, the software part deals mainly with management, and the FPGA assumes the main work.  That is why the creation of NetFlow sensor, as something more interesting in terms of Software Hardware Co-design, seemed to us a good reason to share our work with you by writing this article. </p><br><h2>  About NetFlow </h2><br><p>  In order not to lose the thread of the story and decide on the terms, I‚Äôll tell you about NetFlow, albeit very briefly, because this information is everywhere. </p><br><p>  NetFlow is a protocol that Cisco Systems has come up with. </p><br><img src="https://habrastorage.org/files/81c/888/6c5/81c8886c5e3843cf9847426c2ba276dc.png" alt="image"><br><br><p>  What for?  To be able to remotely monitor the traffic on the network. </p><br><p>  That is, in the local network there is some L3-switch with the function of the NetFlow sensor and somewhere else a collector who knows everything about what is happening in the network. </p><br><p>  In this case, there should not be an extra load on the network with data that we send to the collector, that is, simple traffic mirroring to the analyzer is not suitable. </p><br><p>  Items in NetFlow: </p><br><ul><li><p>  Sensor (aka Exporter) - a device that collects information about streams in the network. <br>  This is usually an L3 switch or router that rarely (usually once per second) sends stream information to the collector. </p><br></li><li>  The collector is (usually) a remote server that collects the information sent by the sensor and stores it. </li></ul><br><p>  What else you need to know about NetFlow: </p><br><ul><li><p>  Export packages are those packages that the sensor sends to the collector. <br>  They have the whole essence of NetFlow.  You have probably heard about the fact that NetFlow comes in different versions - and so, the format of these export packages is the main difference between the versions. </p><br></li><li><p>  NetFlow versions: <em>v1</em> , <em>v5</em> , <em>v8</em> , <em>v9</em> .  <em>v9</em> - the most common, the rest either provide limited functionality ( <em>v1</em> , <em>v5</em> ), or unnecessarily complex ( <em>v8</em> ). <br>  In the <em>v9</em> version, the sensor determines what information it can give, and the collector adjusts for it.  The sensor, along with the data, sends a template by which it is clear how to work with this data.  Templates are very flexible.  Read more about the NetFlow v9 recommendation in <a href="https://www.ietf.org/rfc/rfc3954.txt">RFC 3954</a> . <br>  There are <a href="https://tools.ietf.org/html/rfc3917">IPFIX</a> - at the moment, the same NetFlow v9 is functionally available. <br>  Only NetFlow is managed by Cisco, and IPFIX is standardized by RFC. </p><br></li><li>  Flow - as they say in <a href="https://tools.ietf.org/html/rfc3917">RFC 3917 p.2.1</a> , this is when packets have something in common. <br>  For NetFlow v9, it is customary to use a stricter definition: <br>  Packets are assigned to the same stream, with the following characteristics: <br><ul><li>  Source IP address; </li><li>  Recipient's IP address; </li><li>  TCP / UDP source port; </li><li>  TCP / UDP receiver port; </li><li>  ICMP code; </li><li>  ICMP type; </li><li>  L4 protocol (IP Protocol Number field); </li><li>  IP ToS; </li><li>  Input interface </li></ul></li></ul><br><p>  From these fields we conclude: </p><br><ul><li>  NetFlow considers only IP packets (in IPFIX, this is even in the name rendered); </li><li>  ICMP packets are also considered (in the case of ICMP, the port fields of L4 are assumed to be 0); </li><li>  A stream is only in one direction (that is, if there is a client and a server, then it is one stream from client to server, back to the other); </li></ul><br><p>  And do not forget - this flow definition is not strictly defined by the standard.  As far as our needs are concerned, we can change the concept of flow, for example, by aggregating flows by directions. </p><br><h2>  Design and survey work </h2><br><p>  Now that everything is known about NetFlow, we formulate the statement of work: </p><br><p>  You need a NetFlow sensor, such that: </p><br><ul><li>  He was ready for a large number of streams (tens, hundreds of thousands); </li><li>  I was ready for a heavy load, ideally the line rate on my platform (2G / 100G); </li><li>  Worked without sampling (when some traffic is not included in the statistics). </li><li>  The main development platform is smart probes, for example, the <a href="http://metrotek.spb.ru/M716.html">M716</a> , which can be put into a network break and collect statistics in this way.  But in the design process, it is worth considering the possibility of using <a href="http://metrotek.spb.ru/b100.html">B100</a> in our 100G switch; </li></ul><br><p>  Target platforms are both heterogeneous: CPU + FPGA. </p><br><p>  Probes are based on the Altera SoC (Cyclone V) ARM processor + small FPGA.  All this on one crystal. </p><br><p>  The B100 is a powerful processor (Intel Core I7) + a large FPGA (Stratix V).  Between them, PCIe. </p><br><p>  Therefore, we have a lot of freedom in terms of Hardware / Software Co-design. </p><br><p>  But let's start by explaining why obvious implementation options are not appropriate. </p><br><h3 id="sw-only">  SW Only </h3><br><p>  We do not use FPGA at all.  We use software solution for NetFlow. </p><br><p>  We get a lot of flexibility, but what about performance? </p><br><ol><li>  Reception and processing of the input packet.  It will be very difficult to achieve the processing of userspace traffic line rate by the utility.  Even if we had achieved the FPGA functionality corresponding to the cards from Intel and used the <a href="http://dpdk.org/">DPDK</a> libraries, it would be almost impossible to achieve the speed of the network stack, which would receive lossless packets at a line rate of 100G of 64 bytes, at least in real time.  Even on the 1G link on ARM, there are very serious questions about how long it will take to optimize the stack. </li><li> CPU load.  With the B100 platform, we can assume that having solved the problem of the network stack, we will have enough CPU time to do something other than receiving packets, but on a small ARM there are concerns about whether the system will pull out a constant check of flows in memory, even without receiving packets. </li></ol><br><p>  Thus, we can conclude - yes, such an implementation is possible, but: </p><br><ol><li>  If we are talking about real terms of development - sampling of input packets is inevitable. </li><li>  On the SoC platform, there is a very serious question about the maximum number of threads that we can store in memory, because all these threads will need to be constantly checked. </li><li>  We can in FPGA.  Even if we consider that software implementation is possible, it is quite obvious that many things on the FPGA will be implemented many times more efficiently. </li></ol><br><p>  But we nevertheless learned something useful from consideration of the software implementation - projects in which you can peep at the nuances of the implementation of the NetFlow sensor: </p><br><ul><li>  <a href="https://github.com/aabc/ipt-netflow">ipt-netflow</a> </li><li>  <a href="https://github.com/analytaps/netflow-dpdk">netflow-dpdk</a> </li></ul><br><h3 id="fpga-only">  FPGA only </h3><br><p>  Now let's go to the other extreme - all on FPGA: </p><br><ol><li>  Reception and processing of the input packet.  Maximum speed, line rate on B100 and on SoCs.  Price is development time, but we will not write this from scratch - we already have a lot of groundwork in this area. </li><li>  CPU usage is not relevant, and the number of threads is limited only by memory size.  With adequate numbers (1-2 million threads), we do not rest on the number of readings that will occur when checking threads.  The interface problem remains - the bandwidth that we will divide between adding threads and checking them, but we can always say that checking is a less priority task and do it only when we don‚Äôt add a new packet. </li></ol><br><p>  But there is a very important question about the flexibility of creating NetFlow packages. </p><br><p>  <strong>Option 1</strong> - we refuse to modify the templates NetFlow v9.  We are writing a generator to an FPGA that can only send data using one template. <br>  If we want to change the template, we will have to rewrite this FPGA module.  This approach does not suit us, because different collectors may work differently with NetFlow and sometimes do not quite understand different fields: for example, some NetFlow v9 package fields have a size that can be redefined by the template, but not all collectors are ready for this, they waiting for this field to be a constant size. </p><br><p>  <strong>Option 2</strong> - we implement dynamic template changes in FPGA.  This is possible, but such a module will take up a lot of resources.  In addition, its development will take a very long time both on the module itself and on its debugging. </p><br><p>  And one more minus of such an implementation: the standard says that not only UDP can be used for transport of NetFlow export packets, but SCTP.  This means that if we want to support such functionality, we will have to implement half the network stack on the FPGA. </p><br><h3 id="sw--hw">  SW + HW </h3><br><p>  Now, when we are convinced that only FPGA or only software implementations for this task are not suitable, we will move on to a joint solution. </p><br><h4 id="funkcionalnye-bloki">  Functional blocks </h4><br><p>  To make it easier to find a solution, we will do the following: </p><br><ul><li>  We break prospective functionality into functional blocks; </li><li>  We form requirements for these blocks; </li><li>  We distribute, depending on requirements, these blocks on hardware and software implementations. </li></ul><br><img src="https://habrastorage.org/files/cd1/0ab/7ff/cd10ab7ff263492bb83a8c2b2f027e7f.png" alt="image"><br><br><p>  This diagram shows the main functional blocks of the NetFlow sensor: </p><br><ul><li>  First you need to accept the package and parse (pull out the necessary header fields) ( <em>Parser</em> ); </li><li>  Then you need to understand to which flow the packet belonged ( <em>Flow Detector</em> ); </li><li>  Next you need to get from the memory information on this flow, update it and write back ( <em>Flow Accumulator</em> ); </li><li>  The memory stores the packet header fields + additional information (byte counters and stream packets, start and end timers); </li><li>  At the same time, the second part of NetFlow works - the one that checks that the flow in memory is long enough and it is time to read it.  That is, flows from memory are regularly read and checked ( <em>Flow Checker</em> ); </li><li>  If it is time to export the flow, it must be deleted from memory and prepared for sending ( <em>Flow Reader</em> ); </li><li>  Finally, you need to create a NetFlow Export package for the collector; </li></ul><br><p>  What gave us such a partition: </p><br><ul><li>  In the entire scheme of the NetFlow sensor, one block is responsible for the ‚ÄúNetFlow‚Äù itself - the formation of the package. <br>  That is, if this block is flexible, we can use any version of NetFlow or even IPFIX; </li><li>  The color on the diagram indicates the approximate load on the interfaces - our main selection criterion SW vs HW; </li></ul><br><p>  Now, keeping in mind this schema, let's move on to the options: </p><br><h4 id="variant-1">  Option 1 </h4><br><p>  For now we know the following exactly: </p><br><ul><li>  We want to accept packets, parse them and add them to memory on FPGA; </li><li>  We want to create export packages programmatically. </li></ul><br><p>  All part of the accumulation from receiving a packet to writing to memory should occur on the FPGA. </p><br><p>  Suppose this is where all the work of the FPGA ends: the memory where the streams are stored is shared.  It has access to soft and he himself checks the threads in the memory and their subtraction. </p><br><p>  In this case, we still have a problem of a large load on the CPU with a large number of threads, but in addition to this, a new problem appears - memory access collisions: FPGAs may want to update information about the stream that soft was about to read, in this case it will be very simple lose some flow information. </p><br><p>  This problem has solutions, but they will require additional complexity of the architecture. </p><br><h4 id="variant-2">  Option 2 </h4><br><p>  Then we go a little further - the memory remains common, but the FPGA (regularly reads and checks the timers of the threads) checks the threads.  As soon as the stream needs to be exported, the FPGA reports a soft pointer to this stream.  We removed the load from the CPU, but the collision problem did not dare. </p><br><h4 id="variant-3">  Option 3 </h4><br><p>  We go even further - when the FPGA read the stream from the memory and realized that it was the stream for export - it itself removes the stream from the memory and sends it to soft (using any available interface). <br>  In this case, the memory should no longer be shared, we can solve conflicts inside the FPGA at the stage of memory access resolution. </p><br><p>  And the software part, which can be changed to work with any protocol, is engaged in the formation of export NetFlow packages. </p><br><p>  The latest version of us gave us.  You can proceed to creating a proof of concept based on the SoC platform. </p><br><h3 id="realizaciya">  Implementation </h3><br><p>  Before implementation, we will present some requirements to it: </p><br><ul><li>  It should be IP-core (standard interfaces, reusability through parameters, etc.); </li><li>  The functionality should be expandable - now it is PoC, but you don‚Äôt want to spend a lot of time on something that will not be used later. </li></ul><br><p>  All this led us to the following implementation: </p><br><img src="https://habrastorage.org/files/ca2/9ec/9c0/ca29ec9c01ef44c9ace4702c47aac43d.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <em>Parser</em> is our IP-core taken from another project.  It accepts the Avalon-ST packet interface and takes the necessary header fields from the packet. </li></ul><br><div class="spoiler">  <b class="spoiler_title">What is Avalon-ST?</b> <div class="spoiler_text"><p>  Avalon Streaming Interface - an interface for transferring data streams inside an FPGA.  Used in Altera's IP-core.  It can be used in the continuous data stream or packet data transfer (the beginning / end of the packet signals are used).  You can read more here: <a href="https://www.altera.com/content/dam/altera-www/global/en_US/pdfs/literature/manual/mnl_avalon_spec.pdf">Avalon Interface Specifications.pdf</a> </p></div></div><br><ul><li><p>  <em>NetDMA</em> is also our IP-core DMA controller, which receives Avalon-ST packets and writes them to memory using handles.  In order to supply this DMA with handles, we already have a driver.  Now this DMA and driver are used in our network stack. </p><br></li><li><p>  <em>Simple NetFlow Accumulator</em> is the same IP-core NetFlow sensor.  She is engaged in flow detection.  Reading and updating information in memory for each received packet, constant memory checking for the presence of streams for export and arbitration of requests to the memory when adding and checking. </p><br></li><li>  <em>Stream SDRAM Ctrl</em> is a small IP-core that serves for easier access to memory.  She can read and write to memory on an arbitrary shift.  For reading, it takes a shift and the number of bytes and after some time Avalon-ST sends a stream with data.  For the record, we specify the shift and the number of bytes, and by Avalon-ST we send the data to be recorded. </li></ul><br><h4 id="struktura-hraneniya-dannyh-potokov">  Stream data storage structure </h4><br><p>  The simplest structure for data storage is the hash table without a collision resolution mechanism. </p><br><img src="https://habrastorage.org/files/3be/a62/c36/3bea62c366504b12a1935784e6f882be.png" alt="image" height="246" width="341"><br><br><p>  The result of the calculation of the hash function of the stream, we consider as a shift in memory, on which it is necessary to arrange the relevant information. </p><br><p>  When adding a new stream, we consider a hash from it, read from the memory by the required index and check that it is really it.  If we make a mistake (a hash collision has occurred), then we force the NetFlow scan engine to subtract this stream from memory.  Yes, his timers have not expired yet and he should still be stored in memory, but this is our easiest method of dealing with collisions.  Cons of this approach: </p><br><ul><li>  We generate a greater load on the interface between NetFlow and the CPU; </li><li>  We are a little dishonest about what the collector expects of us. </li></ul><br><p>  The first problem is solved: the lower the probability of collisions, the smaller the possible surge in load. </p><br><p>  The second problem can be solved in the program part, if there is implemented its own small buffer for storing such premature shipments. </p><br><h4 id="vybiraem-hesh">  We select a hash </h4><br><p>  As a hash function is currently used CRC32 from the polynomial 0x04C11DB7 (this is the one used in Ethernet).  Of course, we had an idea to choose a more interesting hash function that would give less collisions.  But the simulations showed that CRC32 was fine. </p><br><p>  For modeling, we made a simple python hash table that contains <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>20</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/metrotek/blog/327894/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhR4_oaXeOjsEPoPSzVefTH0QBDNQ#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/metrotek/blog/327894/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhR4_oaXeOjsEPoPSzVefTH0QBDNQ#MJMAIN-32"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/metrotek/blog/327894/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhR4_oaXeOjsEPoPSzVefTH0QBDNQ#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>20</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {20} </script>  positions (this size seemed to be the most suitable for the first implementation, therefore we test hash functions on it).  That is, from the resulting hash value, only 20 bits are used to determine the position in the table. </p><br><p>  We also wrote a script generator that creates <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>20</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/metrotek/blog/327894/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhR4_oaXeOjsEPoPSzVefTH0QBDNQ#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/metrotek/blog/327894/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhR4_oaXeOjsEPoPSzVefTH0QBDNQ#MJMAIN-32"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/metrotek/blog/327894/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhR4_oaXeOjsEPoPSzVefTH0QBDNQ#MJMAIN-30" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>20</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-2"> 2 ^ {20} </script>  unique words of 17 bytes each (this is how much data is obtained from fields unique to the stream). </p><br><p>  We add this data to our table, with different hash functions: </p><br><ul><li>  CRC32 with polynomial 0x04C11DB7 </li><li>  CRC32 with polynomial 0xEDB88321 </li><li>  CRC32 with polynomial 0x82608EDB </li><li>  <a href="">LookUp3</a> </li><li>  <a href="">MurMurHash3</a> </li></ul><br><p>  The CRC32 polynomials 0xEDB88321 and 0x82608EDB are transformations of the polynomial 0x04C11DB7.  In one of the past projects, we used such CRC functions to quickly generate a large number of different hashes.  We decided to check them at the same time here. </p><br><p>  <em>LookUp3</em> was chosen because this function was specially created for hash tables and contains in itself quite tolerable for FPGA operations - addition and shift. </p><br><p>  <em>MurMurHash3</em> was chosen not only because of its cool name, but also as an example of a multiplicative function, which would be quite expensive to implement in FPGA, but which should, in theory, give a better filling of the table. </p><br><p>  After adding each new word to each of the tables, we kept the table full in order to build such a graph: </p><br><img src="https://habrastorage.org/files/996/4b0/c31/9964b0c3149f4a2e98a2cf6e9f2d968f.png" alt="image"><br><br><p>  As you can see from the graph, there are no significant differences on our data. </p><br><p>  So CRC32 is quite suitable for us until we decide to change the size of the data from which we consider the hash, or until we want to protect ourselves from an intentional attack on filling our table. </p><br><p>  For the test platform was chosen one of the platforms with SoC'om on board and two network interfaces, looking in FPGA. </p><br><img src="https://habrastorage.org/files/a2e/d4f/b54/a2ed4fb54b794770958fc4b681a4946d.png" alt="image"><br><br><p>  Packets that fall into NetFlow are taken from transit ‚Äî when a packet is sent from one port to another via FPGA.  Turning on and off the transfer has already been implemented on this platform. </p><br><p>  Thus, you can create a load of up to 2 Gb / s and at the same time control the number of packets sent to NetFlow. </p><br><p>  On the selected platform, the FPGA and CPU share memory.  To separate the memory with which only FPGA will work (for storing packets), the Linux kernel is limited to the visible memory when loading, so that we have enough ~ 150 MB of storage remaining for 1 million threads. </p><br><p>  To create the export packages themselves, they wrote their simple python utility, which with the help of the scapy library listens to the network interface on which the stream data comes.  Using the same library, it forms NetFlow Export packages and sends them. </p><br><h2>  Conclusion </h2><br><h3 id="proizvoditelnost">  Performance </h3><br><p>  This NetFlow implementation, in theory, "rests" only on the memory bandwidth (in one of the articles, my colleague <a href="https://habrahabr.ru/users/des333/" class="user_link">Des333</a> made a practical calculation of this bandwidth on the SoC platform and got the figures at 20 Gb / s, you can read more in his article <a href="https://habrahabr.ru/company/metrotek/blog/248145/">here</a> ) </p><br><p>  Do we have enough 20 GB / s? </p><br><p>  Adding each packet to us is reading 45 bytes from memory and writing 76. </p><br><p>  In the worst case, Ethernet traffic on the 1G interface can create a load of 1488095 packets per second (packets of 64 bytes per line rate). </p><br><p>  Thus, we will create a load on the memory of 1.44 Gb / s.  The rest of the bandwidth can be given to check the flow. </p><br><p>  But in the current implementation, the performance is much lower: in practice, we are not coping with the worst case line rate (packets of 64 bytes) and some of the packets are not included in the statistics.  You can estimate the problem in numbers in a simulation, where the target, with the current memory settings, is a lossless load of ~ 1420000 packets per second.  This corresponds to the line rate in the case of 69-byte packets. </p><br><p>  This is due to the fact that the battery works consistently - it first processes each packet completely, and only then takes on the next one. </p><br><p>  In addition, the DDR3 memory delay was quite large (interconnect automatically generated by the development environment + using IP-core <em>Stream SDRAM Ctrl</em> gave ~ 15 latencies <br>  between the request to read and receive data at a frequency of 62.5 MHz). </p><br><p>  The solution to this problem is to use a pipeline when adding data to the memory.  That is, we request data for reading, and while waiting for a response, we request a read for the next stream (and so up to 15 times). </p><br><p>  You can also increase the frequency at which Simple NetFlow IP-core works and all memory access. </p><br><h3 id="known-issues">  Known issues </h3><br><p>  This is only PoC and therefore there are a number of limitations, such as: </p><br><ul><li><p>  We do not follow the end of the stream by IP flags (only by timers), although NetFlow implies that this is our task; </p><br></li><li>  Performance sags very much with a large number of hash table collisions: we run into the performance of the network stack between the FPGA and the CPU, because processing the new packet is blocked if we don‚Äôt have enough space to subtract the packet from the memory and send it to the CPU.  A possible solution is to implement baskets for storing streams in memory (one index will contain several threads); </li></ul><br><ul><li>  The previously mentioned performance problem that requires the implementation of a pipeline when adding new data to memory; </li></ul><br><p>  On this, in general, that's all.  Thank you for reading to the end. </p><br><p>  I will be glad to answer your questions in the comments. </p><br><p>  <strong>PS</strong> </p><br><p>  By the way, my colleagues from the system group managed to convert those sketches from python utilities for testing into a decent driver for Linux and a daemon on Rust, which builds packages for NetFlow. </p><br><p>  Maybe sometime they will write something about it.  But while they are resting after the article about our other collaboration, acceleration of AES encryption.  If interested, you can <a href="https://habrahabr.ru/company/metrotek/blog/324042/">read here</a> . </p></div><p>Source: <a href="https://habr.com/ru/post/327894/">https://habr.com/ru/post/327894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327882/index.html">Pitfalls during project team meetings</a></li>
<li><a href="../327886/index.html">SeaMonkey Project officially requests support</a></li>
<li><a href="../327888/index.html">Ros. Navigation stack</a></li>
<li><a href="../327890/index.html">Ruby on Rails agreement. Part 1</a></li>
<li><a href="../327892/index.html">Email is personal data?</a></li>
<li><a href="../327896/index.html">Bash scripts, part 9: regular expressions</a></li>
<li><a href="../327898/index.html">Six programming paradigms that change your view of code</a></li>
<li><a href="../327900/index.html">Automate non-automated, or about Xamarin in real projects</a></li>
<li><a href="../327904/index.html">Twitter: intercepting the management of views and thoughts</a></li>
<li><a href="../327908/index.html">Acronis Backup 12.5 (now and) Advanced: long-awaited release</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>