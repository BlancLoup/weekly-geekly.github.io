<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pyramid of tests in practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About the author: Ham Focke is a developer and consultant for ThoughtWorks in Germany. Tired of deploying at three nights, he added means of continuou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pyramid of tests in practice</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/753/224/111/753224111d9c766c7e6040411e6a5cf9.jpg" align="left">  <font color="gray">About the author: <b><a href="http://www.hamvocke.com/">Ham Focke</a></b> is a developer and consultant for ThoughtWorks in Germany.</font>  <font color="gray">Tired of deploying at three nights, he added means of continuous delivery and careful automation to his toolbox.</font>  <font color="gray">Now he is building such systems to other teams to ensure reliable and efficient software delivery.</font>  <font color="gray">So it saves companies the time that these annoying little people spent on their antics.</font> <br><br>  The ‚Äútest pyramid‚Äù is a metaphor that means the grouping of software tests at different levels of detail.  She also gives an idea of ‚Äã‚Äãhow many tests should be in each of these groups.  Despite the fact that the concept of a test pyramid has been around for a long time, many development teams are still trying to incorrectly implement it in practice properly.  This article discusses the initial concept of the test pyramid and shows how to implement it.  It shows what types of tests to look for at different levels of the pyramid, and gives practical examples of how to implement them. <br><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text"><ul><li>  <a href="https://habr.com/ru/post/358950/">The importance of automation (tests)</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Pyramid of tests</a> </li><li>  <a href="https://habr.com/ru/post/358950/">What tools and libraries will we look at?</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Sample application</a> <br><ul><li>  <a href="https://habr.com/ru/post/358950/">Functionality</a> </li><li>  <a href="https://habr.com/ru/post/358950/">High level structures</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Internal architecture</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/358950/">Unit tests</a> <br><ul><li>  <a href="https://habr.com/ru/post/358950/">What is a unit?</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Sociable and lonely tests</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Imitations and stubs</a> </li><li>  <a href="https://habr.com/ru/post/358950/">What to test?</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Test structure</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Unit test implementation</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/358950/">Integration tests</a> <br><ul><li>  <a href="https://habr.com/ru/post/358950/">Database Integration</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Integration with individual services</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/358950/">Contract Tests</a> <br><ul><li>  <a href="https://habr.com/ru/post/358950/">Customer test (our team)</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Supplier test (other team)</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Supplier test (our team)</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/358950/">UI tests</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Through tests</a> <br><ul><li>  <a href="https://habr.com/ru/post/358950/">UI end-to-end tests</a> </li><li>  <a href="https://habr.com/ru/post/358950/">REST API end-to-end test</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/358950/">Acceptance tests - do your features work correctly?</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Research testing</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Confusion with terminology in testing</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Deploying tests into the deployment pipeline</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Avoid duplicate tests</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Write clean code for tests</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Conclusion</a> </li></ul><br>  <b>Notes</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habr.com/ru/post/358950/">But I really need to test this private method.</a> </li><li>  <a href="https://habr.com/ru/post/358950/">Specialized Test Helpers</a> </li></ul></div></div><a name="habracut"></a><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/308/1dd/ea33081ddc613a817b10881041035a29.png"></div>  Before release the software needs to be tested.  As the software industry has matured, testing approaches have matured.  Instead of a myriad of live testers, developers have moved to automating most of the tests.  Test automation allows you to learn about a bug in seconds and minutes after it is entered into the code, and not in a few days or weeks. <br><br>  The dramatically reduced feedback loop, fed by automated tests, goes hand in hand with flexible development practices, continuous delivery and the DevOps culture.  An effective testing approach ensures fast and confident development. <br><br>  This article looks at how a well-formed test suite should look to be flexible, reliable, and supported ‚Äî regardless of whether you are building microservice architecture, mobile applications, or IoT ecosystems.  We will also take a closer look at creating effective and readable automated tests. <br><br><a name="TheImportanceOftestAutomation"></a><h1>  The importance of automation (tests) </h1><br>  Software has become an integral part of the world in which we live.  It outgrew the original sole goal of increasing business efficiency.  Today, each company seeks to become a first-class digital company.  All of us every day we are users of more and more software.  The speed of innovation is increasing. <br><br>  If you want to keep up with the times, you need to look for faster ways to deliver software without sacrificing its quality.  Continuous delivery can help in this ‚Äî a practice that automatically ensures that software can be released into production at any time.  With continuous delivery, an assembly pipeline is used to automatically test software and deploy it to test and production environments. <br><br>  Soon, assembling, testing, and deploying an ever-growing amount of software manually becomes impossible - unless you want to spend all your time doing manual tasks instead of delivering working software.  The only way is to automate everything, from assembly to testing, deployment and infrastructure. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3a/60c/b8b/a3a60cb8b4d4f10699cc6862d5bcf8fc.png"><br><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">1. Using assembly conveyors for automatic and reliable software commissioning</font></i> <br><br>  Traditionally, testing required excessive manual work through deployment in a test environment, and then tests in the black box style, for example, by clicking everywhere in the user interface with the observation that bugs appear.  Often these tests are set by test scripts to ensure that testers check everything consistently. <br><br>  It is obvious that testing all changes manually takes a lot of time, it is monotonous and tedious.  Monotony is boring, and boredom leads to mistakes. <br><br>  Fortunately, there is a great tool for monotonous tasks: <i>automation</i> . <br><br>  Automating monotonous tests will change your life as a developer.  Automate the tests, and you no longer have to thoughtlessly follow click protocols, checking the correctness of the program.  Automate the tests, and without batting an eye, change the code base.  If you have ever tried large-scale refactoring without a proper set of tests, I‚Äôm sure you know what horror it can turn into.  How do you know if you accidentally make a mistake in the process?  Well, you have to click manually on all test cases, how else.  But let's be honest: do you really like it?  How about even after large-scale changes any bugs reveal themselves in a few seconds while you are drinking coffee?  In my opinion, it is much nicer. <br><br><a name="TheTestPyramid"></a><h1>  Pyramid of tests </h1><br>  If you take the automatic tests seriously, then there is one key concept: <b>the test pyramid</b> .  She was introduced by Mike Cohn in his book <i>Scrum: Flexible</i> Software Development (Succeeding With Agile. Software Development Using Scrum).  This is an excellent visual metaphor, suggestive of different levels of tests.  It also shows the amount of tests at each level. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6c/930/f2d/f6c930f2d4ae8a6068696ace34e9566e.png"></div><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">2. Pyramid of tests</font></i> <br><br>  Mike Cohn's original test pyramid consists of three levels (bottom to top): <br><br><ol><li>  Unit tests. </li><li>  Service tests. </li><li>  UI tests. </li></ol><br>  Unfortunately, with a more thorough concept seems insufficient.  Some argue that either the naming or some conceptual aspects of the Mike Cohn test pyramid are not perfect, and I have to agree.  From the modern point of view, the pyramid of tests seems overly simplistic and therefore may be misleading. <br><br>  However, because of its simplicity, the essence of the test pyramid represents a good rule of thumb when it comes to creating your own set of tests.  From this pyramid the main thing to remember are two principles: <br><br><ol><li>  Write tests of different details. </li><li>  The higher the level, the fewer the tests. </li></ol><br>  Stick to the shape of a pyramid to come up with a healthy, fast and supported set of tests.  Write a <i>lot of</i> small and fast <i>unit tests</i> .  Write a <i>few</i> more general tests and <i>very few</i> high-level end-to-end tests that test the application from start to finish.  Keep in mind that you have failed in the end the <a href="https://watirmelon.blog/testing-pyramids/">ice cream test cake</a> , which will become a nightmare in support and will run for too long. <br><br>  Do not get too attached to the names of the individual levels of the pyramid of tests.  In fact, they can be misleading: the term ‚Äúservice test‚Äù is difficult to understand (Cohn himself noted that <a href="https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid">many developers completely ignore this level</a> ).  Nowadays, frameworks for single-page applications like React, Angular, Ember.js and others are becoming obvious that the UI tests do not belong at the top of the pyramid - you can perfectly test the UI in all of these frameworks. <br><br>  Given the shortcomings of the original names in the pyramid, it is quite normal to come up with other names for their levels of tests.  The main thing is that they correspond to your code and terminology adopted in your team. <br><br><a name="ToolsAndLibrariesWellLookAt"></a><h1>  What tools and libraries will we look at? </h1><br><ul><li>  <a href="http://junit.org/">JUnit</a> : to run tests </li><li>  <a href="http://site.mockito.org/">Mockito</a> : for imitation dependencies </li><li>  <a href="http://wiremock.org/">Wiremock</a> : for external service stubs </li><li>  <a href="https://docs.pact.io/">Pact</a> : for writing CDC tests </li><li>  <a href="http://docs.seleniumhq.org/">Selenium</a> : for writing end-to-end UI tests </li><li>  <a href="https://github.com/rest-assured/rest-assured">REST-assured</a> : for writing end-to-end REST API tests </li></ul><br><a name="TheSampleApplication"></a><h1>  Sample application </h1><br>  I wrote a <a href="https://github.com/hamvocke/spring-testing">simple microservice</a> with tests from different levels of the pyramid. <br><br>  This is an example of a typical microservice.  It provides a REST interface, communicates with the database and extracts information from a third-party REST service.  It is implemented on <a href="https://projects.spring.io/spring-boot/">Spring Boot</a> and should be understandable even if you have never worked with Spring Boot. <br><br>  Be sure to check the <a href="https://github.com/hamvocke/spring-testing">code on Github</a> .  The readme file contains instructions for running applications and automated tests on your computer. <br><br><a name="Functionality"></a><h3>  Functionality </h3><br>  The application has simple functionality.  It provides a REST interface with three endpoints: <br><br> <code>GET /hello <br>  <i>"Hello World"</i> . . <br> <br> GET /hello /{lastname} <br>     .   ,  <i>"Hello {Firstname} {Lastname}"</i> . <br> <br> GET /weather <br>      <i>, </i> .</code> <br> <br><a name="High-levelStructure"></a><h3>  High level structures </h3><br>  At a high level, the system has the following structure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/813/284/1c5/8132841c5c334aad6d292c69c1807de3.png"></div><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">3. High-level microservice structure</font></i> <br><br>  Our microservice provides a REST interface over HTTP.  For some endpoints, the service receives information from the database.  In other cases, it accesses the external <a href="https://darksky.net/">API</a> via HTTP to get and display the current weather. <br><br><a name="InternalArchitecture"></a><h3>  Internal architecture </h3><br>  Inside the Spring Service, the typical architecture for Spring is: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae4/727/6e6/ae47276e66f80ee73f38ea2a995b8c13.png"></div><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">4. The internal structure of microservice</font></i> <br><br><ul><li>  <code>Controller</code> classes provide <i>REST endpoints</i> that handle <i>HTTP</i> requests and responses. </li><li>  <code>Repository</code> classes interact with <i>the database</i> and are responsible for writing and reading data to / from the persistent storage. </li><li>  <code>Client</code> classes interact with other APIs; in our case, they take <i>JSON</i> data over <i>HTTPS</i> from the weather API on darksky.net. </li><li>  <code>Domain</code> classes capture <a href="https://en.wikipedia.org/wiki/Domain_model">the domain model</a> , including the domain logic (which, frankly, is rather trivial in our case). </li></ul><br>  Experienced Spring developers may notice that a frequently used layer is missing here: many developers inspired by <a href="https://en.wikipedia.org/wiki/Domain-driven_design">problem-oriented design</a> create <i>a service layer</i> consisting of classes of <i>services</i> .  I decided not to include it in the app.  One of the reasons is that our application is quite simple, and the layer of services will become an unnecessary level of indirection.  Another reason is that in my opinion people often overdo it with these layers.  Often you have to see code bases where classes of services cover all business logic.  The domain model becomes just a layer for the data, not for the behavior (an <a href="https://en.wikipedia.org/wiki/Anemic_domain_model">anemic domain model</a> ).  For each non-trivial application, great opportunities for good code structuring and testability are lost, and the power of object orientation is not fully utilized. <br><br>  Our repositories are simple and provide simple <abbr title="create, read, update, delete">CRUD</abbr> functionality.  For simplicity, I used <a href="http://projects.spring.io/spring-data/">Spring Data</a> .  It provides a simple and universal implementation of the CRUD repository, and also takes care of deploying the in-memory database for our tests, rather than using real PostgreSQL, as it would be in production. <br><br>  Take a look at the code base and get acquainted with the internal structure.  This is useful for the next step: test the application! <br><br><a name="UnitTests"></a><h1>  Unit tests </h1><br>  The core of your test suite consists of unit tests (unit tests).  They verify that the individual unit ( <i>test subject</i> ) of the code base is working properly.  Unit tests have the narrowest area among all the tests in the test suite.  The number of unit tests in the kit significantly exceeds the number of any other tests. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9be/489/778/9be48977803c4fd5bd9882450db5b4ff.png"></div><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">5. Usually a unit test replaces external users with test duplicates.</font></i> <br><br><a name="WhatsAUnit"></a><h3>  What is a unit? </h3><br>  If you ask three different people what <i>‚Äúunit‚Äù</i> means in the context of unit tests, you will probably get four different, slightly different answers.  To a certain extent, this is a question of your own definition - and it is normal that there is no generally accepted canonical answer. <br><br>  If you are writing in a functional language, then the unit is likely to be a separate function.  Your unit tests will invoke a function with various parameters and return the expected values.  In an object-oriented language, a unit can vary from a single method to a whole class. <br><br><a name="SociableAndSolitary"></a><h3>  Sociable and lonely tests </h3><br>  Some argue that all participants (for example, called classes) of the test subject should be replaced with <i>imitations</i> (mocks) or <i>stubs</i> (stubs) in order to create perfect isolation, avoid side effects and difficult test setup.  Others argue that imitations and stubs should be replaced only by participants who slow down the test or have strong side effects (for example, classes with database access or network calls). <br><br>  <a href="https://martinfowler.com/bliki/UnitTest.html">Sometimes</a> these two types of unit tests are called solitary in the case of the total use of imitations and stubs or <b>sociable</b> in the case of real communication with other participants (these terms were invented by Jay Fields for the book <a href="https://leanpub.com/wewut">"Effective work with unit tests"</a> ).  If you have some free time, you can go down the rabbit hole and <a href="https://martinfowler.com/articles/mocksArentStubs.html">understand the advantages and disadvantages of</a> different points of view. <br><br>  But in the end it doesn't matter what type of tests you choose.  What really matters is their automation.  Personally, I constantly use both approaches.  If it is inconvenient to work with real participants, I will abundantly use imitations and stubs.  If I feel that attracting a real participant gives more confidence in the test, I will drown out only the most distant parts of the service. <br><br><a name="MockingAndStubbing"></a><h3>  Imitations and stubs </h3><br>  Imitations (mocks) and stubs (stubs) are two different types of <a href="https://martinfowler.com/bliki/TestDouble.html">test substitutions</a> (there are generally more of them).  Many use the terms interchangeably.  I think that it is better to observe accuracy and keep in mind the specific properties of each of them.  For production objects, test substitute is created for test implementation. <br><br>  Simply put, you replace a real thing (for example, a class, module or function) with a fake copy.  Counterfeit looks and acts like the original (gives the same answers to the same method calls), but these are predefined answers that you define for the unit test. <br><br>  Test doublers are used not only in unit tests.  More complex backups are used to control the imitation of entire parts of your system.  However, unit tests use especially many imitations and stubs (depending on whether you prefer sociable or single tests) simply because many modern languages ‚Äã‚Äãand libraries make it easy and convenient to create them. <br><br>  Regardless of the technology chosen, the standard library of your language or some popular third-party library already has an elegant way of setting up simulations.  And even for writing your own simulations from scratch, you just need to write a fake class / module / function with the same signature as the real one, and the simulation settings for the test. <br><br>  Your unit tests will work very quickly.  On a decent car, you can run thousands of unit tests in a few minutes.  Test small code base fragments in isolation and avoid contacts with the database, file system and HTTP requests (putting simulations and stubs here) to maintain high speed. <br><br>  Having understood the basics, over time you will begin to write unit tests more freely and easily.  Stub of external participants, setting the input data, calling the test subject - and checking that the return value is as expected.  Look at <a href="https://en.wikipedia.org/wiki/Test-driven_development">test</a> -driven development (TDD), and let unit tests guide your development;  if they are applied correctly, it will help get into a powerful stream and create a good supported architecture, automatically generating a comprehensive and fully automated test suite.  But this is not a universal solution.  Try and see for yourself whether TDD is appropriate for your particular case. <br><br><a name="WhatToTest"></a><h3>  What to test? </h3><br>  It‚Äôs good that unit tests can be written for all classes of production code, regardless of their functionality or what level of internal structure they belong to.  Unit tests are suitable for controllers, repositories, domain classes or file reading programs.  Just stick to the rule of thumb for <b>one test class per one production class</b> . <br><br>  A unit test should at least <b>test the <i>open</i> interface of a class</b> .  Private methods cannot be tested anyway, because they cannot be called from another test class.  <i>Protected</i> or <i>available</i> only within the package (package-private) methods are available from the test class (considering that the package structure of the test class is the same as in production), but testing these methods may already go too far. <br><br>  When it comes to writing unit tests, there is a delicate feature: they must ensure that all non-trivial code paths are checked, including the default scenario and borderline situations.  At the same time, they should not be too closely tied to the implementation. <br><br>  Why is that? <br><br>  Tests that are too attached to the production code quickly become annoying.  As soon as you refactor the code (that is, change the internal structure of the code without changing the external behavior), the unit tests immediately break. <br><br>  Thus, you lose the important advantage of unit tests: act as a security system for code changes.  You‚Äôll rather get tired of these stupid tests that fall every time after refactoring, bringing more problems than good;  Whose foolish idea was it to introduce tests? <br><br>  What to do?  Do not reflect in the unit tests the internal structure of the code.  Test the observed behavior.  For example: <br><br>  <i>If I enter x and y values, will the result be z?</i> <br><br>  instead of this: <br><br>  <i>If I enter x and y, will the method first go to class A, then to class B, and then add the results from class A and class B?</i> <br><br>  As a rule, the closed methods should be considered as an implementation detail.  That is why there should not even be a desire to check them. <br><br>  Often I hear from opponents of unit testing (or TDD) that writing unit tests becomes meaningless if you need to test all the methods for a large test coverage.  They often refer to scenarios where an overly eager tmlid made writing unit tests for getters and setters and other trivial code in order to reach 100% of the test coverage. <br><br>  This is completely wrong. <br><br>  Yes, you should <i>test the public interface</i> .  But even more important is <i>not to test the trivial code</i> .  Don't worry, <a href="https://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests/">Kent Beck approves</a> .  You will get nothing from testing simple getters or setters or other trivial implementations (for example, without any conditional logic).  And you will save time, so you can sit at one more meeting, hooray! <br><br><a name="private-methods-sidebar"></a><blockquote>  <b>But I <i>really</i> need to check out this private method.</b> <br>  If you ever find yourself in a situation where you <i>really</i> need to check the closed method, you need to take a step back and ask yourself: why? <br><br>  I am sure that there is more of a design problem.  Most likely, you feel the need to test a closed method, because it is complicated, and testing a method through an open class interface requires too inconvenient configuration. <br><br>  Whenever I find myself in such a situation, I usually come to the conclusion that the class being tested is overcomplicated.  He does too much and violates the principle of shared responsibility - one of the five principles of <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a> . <br><br>  For me, the solution to splitting the source class into two classes often works.  Often, after a minute or two of reflection, there is a good way to break a large class into two smaller ones with individual responsibility.  I move the private method (which I urgently need to test) to the new class and let the old class call the new method.  Voila, the closed method, inconvenient for testing, is now public and easily tested.  In addition, I improved the structure of the code by introducing the principle of common responsibility. </blockquote><br><a name="TestStructure"></a><h3>  Dough structure </h3><br>  The good structure of all your tests (not only modular) is: <br><br><ol><li>  Setup test data. </li><li>  Call a test method. </li><li>  Check that the expected results are returned. </li></ol><br>  There is a good mnemonic for memorizing this structure: three A ( <a href="https://xp123.com/articles/3a-arrange-act-assert/">Arrange, Act, Assert</a> ).  You can use another mnemonic with roots in BDD (a development based on a behavior description).  This triad is <a href="https://martinfowler.com/bliki/GivenWhenThen.html">given when, then</a> , where "given" reflects the setting, "when" is the method call, and "then" is the statement. <br><br>  This pattern can also be applied to other higher level tests.  In each case, they ensure that the tests remain easy and readable.  In addition, tests written for this structure are usually shorter and more expressive. <br><br><a name="ImplementingAUnitTest"></a><h3>  Unit test implementation </h3><br>  Now we know what to test and how to structure unit tests.  It's time to look at a real example. <br><br>  Take the simplified version of the class <code>ExampleController</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PersonRepository personRepo; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PersonRepository personRepo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.personRepo = personRepo; } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/hello/{lastName}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String lastName)</span></span></span><span class="hljs-function"> </span></span>{ Optional&lt;Person&gt; foundPerson = personRepo.findByLastName(lastName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foundPerson .map(person -&gt; String.format(<span class="hljs-string"><span class="hljs-string">"Hello %s %s!"</span></span>, person.getFirstName(), person.getLastName())) .orElse(String.format(<span class="hljs-string"><span class="hljs-string">"Who is this '%s' you're talking about?"</span></span>, lastName)); } }</code> </pre> <br>  The unit test for the <code>hello(lastname)</code> method might look like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ExampleController subject; <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PersonRepository personRepo; <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ initMocks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExampleController(personRepo); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnFullNameOfAPerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Person peter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-string"><span class="hljs-string">"Pan"</span></span>); given(personRepo.findByLastName(<span class="hljs-string"><span class="hljs-string">"Pan"</span></span>)) .willReturn(Optional.of(peter)); String greeting = subject.hello(<span class="hljs-string"><span class="hljs-string">"Pan"</span></span>); assertThat(greeting, is(<span class="hljs-string"><span class="hljs-string">"Hello Peter Pan!"</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldTellIfPersonIsUnknown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ given(personRepo.findByLastName(anyString())) .willReturn(Optional.empty()); String greeting = subject.hello(<span class="hljs-string"><span class="hljs-string">"Pan"</span></span>); assertThat(greeting, is(<span class="hljs-string"><span class="hljs-string">"Who is this 'Pan' you're talking about?"</span></span>)); } }</code> </pre> <br>  We write unit tests in <a href="http://junit.org/">JUnit</a> , a standard Java testing framework.  We use <a href="http://site.mockito.org/">Mockito</a> to replace the real <code>PersonRepository</code> class with a class with a stub for the test.  This stub allows you to specify preset answers that the stub method returns.  This approach makes the test easier and more predictable, making it easy to set up data validation. <br><br>  Following the structure of ‚Äúthree A‚Äù, we write two unit tests for positive and negative cases when the desired person cannot be found.  A positive test case creates a new person object and tells the repository simulation to return this object when the <code>lastName</code> parameter is called with a <i>Pan</i> value.  The test then calls the test method.  Finally, he compares the answer with the expected one. <br><br>  The second test works in the same way, but it tests a script in which the test method does not find the person object for this parameter. <br><br><a name="SpecialisedTestHelpers"></a><blockquote>  <b>Specialized Test Helpers</b> <br>  It's great that you can write unit tests for the entire code base, regardless of the level of architecture of your application.  The example below shows a simple unit test for the controller.  Unfortunately, when it comes to Spring controllers, this approach has a drawback: the Spring MVC controller makes extensive use of annotations with declarations of the paths being listened to, the HTTP commands used, the URL parsing parameters, the request parameters, and so on.  A simple call to the controller method in a unit test will not check all these important things.  Fortunately, the Spring community has come up with a good test helper, which you can use to improve controller testing.  Be sure to check out the <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html">MockMVC</a> .  This will give a great DSL to generate fake requests to the controller and verify that everything works fine.  I included <a href="">an example</a> in the code.  Many frameworks have test helpers to simplify tests of specific parts of the code.  Familiarize yourself with the documentation on your framework and see if any useful helpers are there for your automated tests. </blockquote><br><a name="IntegrationTests"></a><h1>  Integration tests </h1><br>  All non-trivial applications are integrated with some other parts (databases, file systems, network calls to other applications).  In unit tests, you usually mimic them for better isolation and increased speed.  However, your application will actually interact with other parts - and this should be tested.  For this are intended <a href="https://martinfowler.com/bliki/IntegrationTest.html">integration tests</a> .  They check the integration of the application with all components outside the application. <br><br>  For automated tests, this means that you need to run not only your own application, but also an integrated component.  If you are testing integration with a database, then when performing tests you need to run the database.  To check the reading of files from disk, you need to save the file to disk and load it into the integration test. <br><br>  I previously mentioned that unit tests are an indefinite term.  To a greater extent, this applies to integration tests.  For someone, ‚Äúintegration‚Äù means testing the entire stack of your application in combination with others.  I like the narrower definition and testing of each integration point separately, replacing the rest of the services and databases with test doublers.  Together with contract testing and performing contract tests on doublers and real implementations, you can come up with integration tests that are faster, more independent and usually easier to understand. <br><br>  Narrow integration tests live on the edge of your service.  Conceptually, they always launch an action that leads to integration with the external part (file system, database, separate service).  The database integration test is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/089/6ef/aaf/0896efaaf776a8d308a008d0d2ef625e.png"></div><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">6. Database Integration Test integrates your code with a real database.</font></i> <br><br><ol><li>  Running the database. </li><li>  Connecting the application to the database. </li><li>  Run the function in code that writes data to the database. </li><li>  Check that the expected data is written to the database by reading them from the database. </li></ol><br>  Another example.  The test of integrating your service with a separate service through the REST API may look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/98f/5bd/15b98f5bd52634719eff1280a4117f3b.png"></div><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">7. This kind of integration test verifies that the application is able to properly interact with individual services.</font></i> <br><br><ol><li>  Application launch. </li><li>  Starting an instance of a separate service (or a test substitute with the same interface). </li><li>  Run the function in code that reads data from the external service API. </li><li>  Check that the application correctly parses the answer. </li></ol><br>  Like unit tests, your integration tests can be done quite transparently (whitebox).  Some frameworks allow you to simultaneously run your application and simulate its individual parts to check the correct interaction. <br><br>  Write integration tests for all code fragments where data is <i>serialized</i> or <i>deserialized</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This happens more often than you think. </font><font style="vertical-align: inherit;">Think about the following:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calls REST API of their services. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reading and writing to the database. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API calls from other applications. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reading from the queue and writing there. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Write to the file system. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Writing integration tests around these boundaries ensures that writing data and reading data from these external participants works fine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When writing </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">narrow integration tests,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> try to locally run external dependencies: a local MySQL database, a test on the local ext4 file system. </font><font style="vertical-align: inherit;">If you integrate with a separate service, either launch an instance of this service locally, or create and run a fake version that simulates the behavior of a real service.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it is not possible to start a third-party service locally, then it is better to start the selected test instance and point to it in the integration test. In automated tests, avoid integration with a real production system. Running thousands of test requests to the production system is a sure way to piss people off because you clog their logs (at best) or just do their service (at worst). Integration with the service over the network is a typical feature of a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">broad integration test</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Usually, because of it, tests are harder to write and they work slower.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As for the test pyramid, the integration tests are at a higher level than the modular ones. </font><font style="vertical-align: inherit;">The integration of file systems and databases is usually much slower than the execution of unit tests with their imitations. </font><font style="vertical-align: inherit;">They are also harder to write than small isolated unit tests. </font><font style="vertical-align: inherit;">In the end, you need to think about the work of the outer part of the test. </font><font style="vertical-align: inherit;">Nevertheless, they have an advantage, because they give confidence in the correct operation of the application with all external parts with which it is necessary. </font><font style="vertical-align: inherit;">Unit tests are useless here.</font></font><br><br><a name="DatabaseIntegration"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Database Integration </font></font></h3><br> <code>PersonRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the only class of repository in the entire code base. </font><font style="vertical-align: inherit;">It relies on </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and has no actual implementation. </font><font style="vertical-align: inherit;">It simply extends the interface </font></font><code>CrudRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and provides a single method header. </font><font style="vertical-align: inherit;">The rest is Spring magic.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Optional&lt;Person&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByLastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastName)</span></span></span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Through the interface </font></font><code>CrudRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Boot provides a fully functional repository CRUD with the methods </font></font><code>findOne</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>findAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Our own definition of a method </font></font><code>findByLastName ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extends this basic functionality and makes it possible to get people, that is, objects </font></font><code>Person</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, by their last names. Spring Data analyzes the return type of the method, the name of the method, and checks it for compliance with the naming conventions to find out what it should do. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although Spring Data does a great job of implementing database repositories, I still wrote a database integration test. You can say this is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a framework test.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which should be avoided, because we are testing someone else's code. Nevertheless, I believe that it is very important to have at least one integration test. First, it checks the normal operation of our method </font></font><code>findByLastName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Secondly, it proves that our repository correctly uses Spring and is able to connect to the database. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To facilitate the execution of tests on your computer (without installing the PostgreSQL database), our test connects to the database in memory </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I defined H2 as a test dependency in a file </font></font><code>build.gradle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The file </font></font><code>application.properties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the test directory does not define any properties </font></font><code>spring.datasource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This tells Spring Data to use the in-memory database. Since he finds H2 on the way to the class, he simply uses H2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Real profile application</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(for example, after installation as an environment variable </font></font><code>SPRING_PROFILES_ACTIVE=int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) will connect to the PostgreSQL database, as defined in </font></font><code>application-int.properties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I understand that here you need to know and understand a bunch of Spring features. We'll have to shovel a </font></font><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bunch of documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The final code is simple in appearance, but difficult to understand, unless you know the specific features of Spring. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, working with a database in memory is a risky business. In the end, our integration tests work with a database of a different type than in production. Try and decide for yourself whether to prefer Spring magic and simple code ‚Äî or an explicit, but more detailed implementation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, enough explanations. Here is a simple integration test that saves a Person object to a database and finds it by last name.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonRepositoryIntegrationTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PersonRepository subject; <span class="hljs-meta"><span class="hljs-meta">@After</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tearDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ subject.deleteAll(); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldSaveAndFetchPerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Person peter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-string"><span class="hljs-string">"Pan"</span></span>); subject.save(peter); Optional&lt;Person&gt; maybePeter = subject.findByLastName(<span class="hljs-string"><span class="hljs-string">"Pan"</span></span>); assertThat(maybePeter, is(Optional.of(peter))); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, our integration test follows the same ‚Äúthree A‚Äù structure as unit tests. </font><font style="vertical-align: inherit;">He said that this is a universal concept!</font></font><br><br><a name="IntegrationWithSeparateServices"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integration with individual services </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our microservice receives weather data from darksky.net through the REST API. Of course, we want to make sure that the service sends requests and parses the answers correctly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When performing automated tests, it is advisable to avoid interaction with real </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">darksky</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> servers </font><font style="vertical-align: inherit;">. Limits on our free fare are just one of the reasons. The main thing is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decoupling</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Our tests should be run no matter how lovely people do their job at darksky.net. Even if our machine cannot reach the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">darksky</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> servers </font><font style="vertical-align: inherit;">or they are closed for maintenance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To avoid interacting with real </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">darksky</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> servers </font><font style="vertical-align: inherit;">, we run our own fake </font><i><font style="vertical-align: inherit;">darksky</font></i><font style="vertical-align: inherit;"> server for integration tests </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This may seem like a very difficult task. But it is simplified thanks to tools like </font></font><a href="http://wiremock.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiremock</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . See for yourself:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherClientIntegrationTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WeatherClient subject; <span class="hljs-meta"><span class="hljs-meta">@Rule</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WireMockRule wireMockRule = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WireMockRule(<span class="hljs-number"><span class="hljs-number">8089</span></span>); <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldCallWeatherService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ wireMockRule.stubFor(get(urlPathEqualTo(<span class="hljs-string"><span class="hljs-string">"/some-test-api-key/53.5511,9.9937"</span></span>)) .willReturn(aResponse() .withBody(FileLoader.read(<span class="hljs-string"><span class="hljs-string">"classpath:weatherApiResponse.json"</span></span>)) .withHeader(CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .withStatus(<span class="hljs-number"><span class="hljs-number">200</span></span>))); Optional&lt;WeatherResponse&gt; weatherResponse = subject.fetchWeather(); Optional&lt;WeatherResponse&gt; expectedResponse = Optional.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeatherResponse(<span class="hljs-string"><span class="hljs-string">"Rain"</span></span>)); assertThat(weatherResponse, is(expectedResponse)); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For Wiremock, create an instance </font></font><code>WireMockRule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on a fixed port ( </font></font><code>8089</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). With DSL, you can set up a Wiremock server, define endpoints for listening, and predefined answers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we call the test method ‚Äî the one that calls on the third-party service ‚Äî and check that the result is parsed correctly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to understand how the test determines that it should access the fake Wiremock server instead of the real </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">darksky</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font><font style="vertical-align: inherit;">. The secret is in the file </font></font><code>application.properties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is located in </font></font><code>src/test/resources</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Spring loads it when executing tests. In this file, we override the configuration like API keys and URLs with values ‚Äã‚Äãsuitable for tests. Including assigning a call to a fake Wiremock server instead of the real one:</font></font><br><br><pre> <code class="hljs objectivec">weather.url = http:<span class="hljs-comment"><span class="hljs-comment">//localhost:8089</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that the port defined here must be the same as we specified when creating the WireMockRule instance for the test. Replacing the URL of the real API with a fake one was made possible by introducing the URL into the class constructor </font></font><code>WeatherClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeatherClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RestTemplate restTemplate, @Value(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"${weather.url}"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String weatherServiceUrl, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"${weather.api_key}"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String weatherServiceApiKey) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.restTemplate = restTemplate; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.weatherServiceUrl = weatherServiceUrl; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.weatherServiceApiKey = weatherServiceApiKey; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we tell our </font></font><code>WeatherClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to read the value of the </font></font><code>weatherUrl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property </font><font style="vertical-align: inherit;">parameter </font></font><code>weather.url</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which we defined in the properties of our application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With tools like Wiremock, writing </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">narrow integration tests</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for a separate service becomes quite a simple task. Unfortunately, this approach has a flaw: how to ensure that the fake server we created behaves like a real one? With the current implementation, a separate service can change its API, and our tests will still pass, as if nothing had happened. Now we are just testing that we are </font></font><code>WeatherClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">able to perceive responses from a fake server. It is a beginning, but it is very fragile. The problem is solved </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">through tests</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and testing on a real service, but so we become dependent on its availability. </font><font style="vertical-align: inherit;">Fortunately, there is a better solution to this dilemma ‚Äî contract tests with participation and simulation, and a real server ensure that the imitation in our integration tests exactly matches the original.</font></font> Let's see how it works. <br><br><a name="ContractTests"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contract Tests </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More modern companies have found a way to scale development by distributing work among different teams. </font><font style="vertical-align: inherit;">They create separate, loosely coupled services without interfering with each other, and integrate them into a large, seamless system. </font><font style="vertical-align: inherit;">The recent hype around microservices is connected with this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dividing the system into many small services often means that these services must interact with each other through certain (preferably well defined, but sometimes randomly created) interfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interfaces between different applications can be implemented in different formats and technologies. </font><font style="vertical-align: inherit;">The most common:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> REST and JSON over HTTPS; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RPC using something like </font></font><a href="https://grpc.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gRPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> building event-oriented architecture using queues. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each interface involves two sides: the supplier and the consumer. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The supplier</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> provides data to consumers. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The consumer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> processes the data received from the supplier. In the REST world, the provider creates a REST API with all the necessary endpoints, and the consumer accesses this REST API to get data or initiate changes to another service. In the asynchronous world of an event-oriented architecture, a provider (often referred to as a publisher) publishes data into a queue; and the consumer (often called the subscriber) subscribes to these queues, reads and processes the data.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/a0f/17c/420a0f17c800a1ac4a65a883813da8ae.png"></div><br>  <i><font color="gray">Fig.</font></i> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8. Each interface involves a provider (or publisher) and a consumer (or subscriber). </font><font style="vertical-align: inherit;">Interface specification can be considered a contract. </font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the services of the supplier and the consumer are distributed to different teams, you find yourself in a situation where you need to clearly specify the interface between them (the so-called contract). </font><font style="vertical-align: inherit;">Traditionally, companies approach this problem as follows:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write a long and detailed interface specification ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contract</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the service provider according to a specific contract. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pass the interface specifications to the consumer side. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wait until they implement their part of the interface. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run a large-scale manual system test to check everything. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is hoped that both teams will always comply with the interface definitions and are not screwed up. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More modern companies have replaced steps 5 and 6 with automated </font></font><a href="https://martinfowler.com/bliki/ContractTest.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contract tests</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which verify that implementations on the consumer and supplier side still adhere to a specific contract. They perform a good set of regression tests and guarantee early detection of deviations from the contract. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a more flexible organization, you should choose a more efficient and less wasteful route. The application is created within the same organization. It should not be a problem to talk with the developers of other services instead of throwing overly detailed off-the-shelf documentation with them. In the end, these are your employees, not a third-party vendor, with whom you can communicate only through customer support or bulletproof legal contracts.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">User-focused contract tests</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (CDC tests) allow </font></font><a href="https://martinfowler.com/articles/consumerDrivenContracts.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consumers to manage contract implementation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . With CDC, consumers write tests that check the interface for all the data they need. The team then publishes these tests so that vendor service developers can easily get and run these tests. Now they can develop their API by running CDC tests. After running all the tests, they know that they have satisfied all the needs of the team on the consumer side.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25e/dba/1c2/25edba1c2090bc04cf76e018a53ee451.png"></div><br>  <i><font color="gray">Fig.</font></i> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9. Contract tests ensure that the supplier and all users of the interface adhere to a specific interface contract. Using CDC tests, interface users publish their requirements in the form of automated tests; Suppliers continuously receive and perform these tests.</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This approach allows the interface provider team to implement only what is really needed (while maintaining simplicity,</font></font><abbr title="You aren't gonna need it"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> YAGNI</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc). </font><font style="vertical-align: inherit;">The supplier team should continuously receive and perform these CDC tests (in their assembly line) to immediately notice any critical changes. </font><font style="vertical-align: inherit;">If they break the interface, their CDC tests will not pass, preventing critical changes. </font><font style="vertical-align: inherit;">While the tests pass, the team can make any changes that it wants without worrying about other teams. </font><font style="vertical-align: inherit;">A consumer-oriented contractual approach shortens the development process to the following:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The consumer team writes automated tests with all the expectations from consumers. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> They publish tests for the supplier team. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The vendor team continuously runs CDC tests and monitors them. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teams immediately enter into negotiations when CDC tests break down. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If your organization implements the microservices approach, then CDC tests are an important step towards creating autonomous groups. CDC tests are an automated way to encourage team communication. They ensure that the interfaces between the teams work at any time. A failed CDC test is a good excuse to go to the affected team, talk about upcoming API changes and find out where to go next. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A naive implementation of CDC tests is as simple as requesting an API and evaluating responses for the availability of all the necessary. These tests are then packaged into an executable file (.gem, .jar, .sh) and loaded somewhere for another command (for example, a repository like </font></font><a href="https://www.jfrog.com/artifactory/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artifactory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In recent years, the CDC approach has become more popular and several tools have been created to simplify the writing and exchange of tests. </font></font><br><br> <a href="https://github.com/realestate-com-au/pact"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pact</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is probably the most famous among them. It offers a sophisticated approach to writing tests for consumers and suppliers, provides plugs for individual services, and allows you to exchange CDC tests with other teams. Pact is ported to many platforms and can be used with JVM, Ruby, .NET, JavaScript, and many others. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pact is a smart choice to get started with the CDC. </font></font><a href="https://docs.pact.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stunning at first, but if you have patience, you can overcome it. It helps to gain a solid understanding of the CDC, which in turn makes it easier for you to promote the CDC to work with other teams.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">User-focused contractual tests can dramatically simplify the work of autonomous teams that will begin to act quickly and confidently. </font><font style="vertical-align: inherit;">Do me a favor, read and try this concept. </font><font style="vertical-align: inherit;">A qualitative set of CDC tests is invaluable in order to quickly continue development without breaking other services or upsetting other teams.</font></font><br><br><a name="ConsumerTestourTeam"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Customer test (our team) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our microservice uses weather API. </font><font style="vertical-align: inherit;">So our duty is to write </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a consumer test</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that defines our expectations under the contract (API) between our microservice and the weather service. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we include the library for writing consumer tests in ours </font></font><code>build.gradle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs lisp">testCompile('au.com.dius<span class="hljs-symbol"><span class="hljs-symbol">:pact-jvm-consumer-junit_2</span></span>.<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">3.5</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>')</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thanks to this library, we can implement a consumer test and use Pact simulation services: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherClientConsumerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WeatherClient weatherClient; <span class="hljs-meta"><span class="hljs-meta">@Rule</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PactProviderRuleMk2 weatherProvider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PactProviderRuleMk2(<span class="hljs-string"><span class="hljs-string">"weather_provider"</span></span>, <span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-number"><span class="hljs-number">8089</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-meta"><span class="hljs-meta">@Pact</span></span>(consumer=<span class="hljs-string"><span class="hljs-string">"test_consumer"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RequestResponsePact </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PactDslWithProvider builder)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builder .given(<span class="hljs-string"><span class="hljs-string">"weather forecast data"</span></span>) .uponReceiving(<span class="hljs-string"><span class="hljs-string">"a request for a weather request for Hamburg"</span></span>) .path(<span class="hljs-string"><span class="hljs-string">"/some-test-api-key/53.5511,9.9937"</span></span>) .method(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>) .willRespondWith() .status(<span class="hljs-number"><span class="hljs-number">200</span></span>) .body(FileLoader.read(<span class="hljs-string"><span class="hljs-string">"classpath:weatherApiResponse.json"</span></span>), ContentType.APPLICATION_JSON) .toPact(); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-meta"><span class="hljs-meta">@PactVerification</span></span>(<span class="hljs-string"><span class="hljs-string">"weather_provider"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldFetchWeatherInformation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Optional&lt;WeatherResponse&gt; weatherResponse = weatherClient.fetchWeather(); assertThat(weatherResponse.isPresent(), is(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)); assertThat(weatherResponse.get().getSummary(), is(<span class="hljs-string"><span class="hljs-string">"Rain"</span></span>)); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you look closely, it is </font></font><code>WeatherClientConsumerTest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very similar to </font></font><code>WeatherClientIntegrationTest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Only for the server stub instead of the Wiremock this time we use Pact. On the test itself, the consumer works in the same way as the integration one: we replace the real third-party server with a stub, determine the expected response, and verify that the client can properly parse it. In this sense, </font></font><code>WeatherClientConsumerTest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a narrow integration test. The advantage over Wiremock-based dough is that it generates </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a Pact file</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (located in</font></font><code>target/pacts/&amp;pact-name&gt;.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). It describes our contract expectations in a special JSON format. You can then use this file to verify that the stub server behaves like a real one. We can take a pact file and pass it to the command that provides the interface. They take the pact file and write the test provider, using the expectations specified there. So they check if their API meets all our expectations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, it was from here that the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúcustomer focus‚Äù</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> part of the CDC definition </font><font style="vertical-align: inherit;">came from </font><font style="vertical-align: inherit;">. The consumer controls the implementation of the interface, describing their expectations. The supplier must ensure that it meets all expectations. No extra specs, YAGNI and everything.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transferring a pact file to a vendor team can follow several paths. Simple - register it in the version control system and tell the vendor team to always take the latest version of the file. A more advanced way is to use an artifact repository like Amazon S3 or Pact Broker. Start simple and grow as needed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a real application, you do not need both an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integration test</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font><i><font style="vertical-align: inherit;">a consumer test</font></i><font style="vertical-align: inherit;"> at the same time </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for client class. </font><font style="vertical-align: inherit;">Our sample code contains both for demonstration how to use each one. </font><font style="vertical-align: inherit;">If you want to write CDC tests on Pact, I recommend staying with it. </font><font style="vertical-align: inherit;">In this case, the advantage is that you automatically get a pact file with contract expectations that other teams can use to easily make their supplier tests. </font><font style="vertical-align: inherit;">Of course, it only makes sense if you can convince the other team to use Pact. </font><font style="vertical-align: inherit;">If not, use the integration test integration in conjunction with Wiremock as a worthy alternative.</font></font><br><br><a name="ProviderTesttheOtherTeam"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Supplier test (other team) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vendor tests must be implemented by those who provide a weather API. We use the public API from darksky.net. Theoretically, the darksky team, for its part, should perform a vendor test and make sure that it does not violate the contract between its application and our service. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, they are not worried about our modest test application - and they will not do the CDC test for us. There is a big difference between a public API and an organization that uses microservices. The public API cannot take into account the needs of each individual consumer, otherwise it will not be able to work normally. Inside your organization, you can and should take them into account. Most likely, your application will serve several, well, maybe a couple of dozen consumers. Nothing prevents you from writing vendor tests for these interfaces in order to maintain a stable system.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The vendor team receives the pact file and runs it on its service. To do this, it implements a test that reads the pact-file, puts several stubs and checks on its waiting service defined in the pact-file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Pact project community has written several libraries for implementing vendor tests. Their </font></font><a href="https://github.com/DiUS/pact-jvm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main GitHub repositories have a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> good selection of libraries for consumers and providers. Choose the one that best suits your technology stack. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For simplicity, suppose the darksky API is also implemented in Spring Boot. In this case, they can use </font></font><a href="https://github.com/DiUS/pact-jvm/tree/master/pact-jvm-provider-spring"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Pact Spring library</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which connects well to the MockMVC Spring mechanisms. The hypothetical test of the supplier that the darksky.net team could implement looks like this:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(RestPactRunner.class) <span class="hljs-meta"><span class="hljs-meta">@Provider</span></span>(<span class="hljs-string"><span class="hljs-string">"weather_provider"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// same as the "provider_name" in our clientConsumerTest @PactFolder("target/pacts") // tells pact where to load the pact files from public class WeatherProviderTest { @InjectMocks private ForecastController forecastController = new ForecastController(); @Mock private ForecastService forecastService; @TestTarget public final MockMvcTarget target = new MockMvcTarget(); @Before public void before() { initMocks(this); target.setControllers(forecastController); } @State("weather forecast data") // same as the "given()" in our clientConsumerTest public void weatherForecastData() { when(forecastService.fetchForecastFor(any(String.class), any(String.class))) .thenReturn(weatherForecast("Rain")); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, the supplier only needs to load the pact file (for example, </font></font><code>@PactFolder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determines where to download the resulting pact files), and then determine how to provide test data for predefined states (for example, using Mockito simulations). </font><font style="vertical-align: inherit;">No need to write any special test. </font><font style="vertical-align: inherit;">Everything is taken from a pact file. </font><font style="vertical-align: inherit;">It is important that the supplier‚Äôs test matches </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the supplier‚Äôs name</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">status</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as stated in the customer‚Äôs test.</font></font><br><br><a name="ProviderTestourTeam"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Supplier test (our team) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We looked at how to test a contract between our service and weather information provider. In this interface, our service acts as a consumer, and the meteorological service acts as a supplier. Thinking again, we will see that our service also acts as a supplier for others: we provide a REST API with several endpoints for other consumers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we know the importance of contractual tests, of course we will write a test for this contract. Fortunately, our contracts are customer oriented, so all the consumer teams send us their pact files, which we can use to implement the vendor tests for our REST API. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, add the Pact supplier for Spring to our project:</font></font><br><br> <code>testCompile('au.com.dius:pact-jvm-provider-spring_2.12:3.5.5')</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation of the vendor test follows the same scheme described. </font><font style="vertical-align: inherit;">For simplicity, I will register a pact file from our </font></font><a href="https://github.com/hamvocke/spring-testing-consumer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple consumer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the repository of our service. </font><font style="vertical-align: inherit;">For our case, this is easier, but in real life, you may have to use a more complex mechanism for distributing pact files.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(RestPactRunner.class) <span class="hljs-meta"><span class="hljs-meta">@Provider</span></span>(<span class="hljs-string"><span class="hljs-string">"person_provider"</span></span>)<span class="hljs-comment"><span class="hljs-comment">// same as in the "provider_name" part in our pact file @PactFolder("target/pacts") // tells pact where to load the pact files from public class ExampleProviderTest { @Mock private PersonRepository personRepository; @Mock private WeatherClient weatherClient; private ExampleController exampleController; @TestTarget public final MockMvcTarget target = new MockMvcTarget(); @Before public void before() { initMocks(this); exampleController = new ExampleController(personRepository, weatherClient); target.setControllers(exampleController); } @State("person data") // same as the "given()" part in our consumer test public void personData() { Person peterPan = new Person("Peter", "Pan"); when(personRepository.findByLastName("Pan")).thenReturn(Optional.of (peterPan)); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shown </font></font><code>ExampleProviderTest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should provide status according to the pact file received, that's all. </font><font style="vertical-align: inherit;">When we run the test, Pact will pick up the pact file and send an HTTP request to our service, which will respond according to the specified state.</font></font><br><br><a name="UiTests"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI tests </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most applications have some kind of user interface. We usually talk about the web interface in the context of web applications. People often forget that the REST API or the command line interface is the same UI as the fancy web interface. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI tests</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verify the correctness of the user interface of the application. User actions should trigger the right events, data should be presented to the user, the state of the UI should change as expected.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e1/d34/9b2/1e1d349b260edb4f442fac4bcbabb8b1.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is sometimes said that UI tests and end-to-end tests are one and the same (as Mike Cohn says). For me, this is the identification of two things with highly orthogonal concepts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, testing the application from start to finish often means passing through the user interface. But the opposite is not true. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">User interface testing need not be end-to-end. Depending on the technology used, testing the UI may be as simple as writing some unit tests for a JavaScript frontend with a drowned backend. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To test the UI of traditional web applications are designed special tools like </font></font><a href="http://docs.seleniumhq.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selenium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If you consider the user interface of the REST API, then the correct integration tests around the API are sufficient. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In web interfaces, it is advisable to check several aspects of the UI, including behavior, layout, usability, adherence to corporate identity, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortunately, testing the behavior of the UI is quite simple. Click here, enter the data there - and check that the state of the UI changes accordingly. Modern frameworks for one-page applications ( </font></font><a href="https://facebook.github.io/react/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">react</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://vuejs.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vue.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://angular.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angular</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and others) are often supplied with tools and helpers for thorough testing of these interactions at a rather low level (in unit test). Even if you roll out your own frontend implementation on vanilla JavaScript, you can still use conventional testing tools such as </font></font><a href="https://jasmine.github.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jasmine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://mochajs.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mocha</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . For a more traditional server-side rendering application, Selenium-based tests will be the best choice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The integrity of the </font><font style="vertical-align: inherit;">web application </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">layout is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a little more difficult to verify. Depending on the application and user needs, it may be necessary to make sure that code changes do not accidentally violate the layout of the site.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But computers do not do well with checking that everything ‚Äúlooks fine‚Äù (perhaps in the future some kind of clever machine learning algorithm will change this). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are some tools to try automatically checking the design of a web application in an assembly pipeline. Most of them use Selenium to open a web application in different browsers and formats, screenshots and comparisons with previously taken screenshots. If the old and new screenshots differ in an unexpected way, the tool will give a signal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One such tool is </font></font><a href="http://galenframework.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Galen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Some teams use </font></font><a href="https://github.com/otto-de/lineup"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lineup</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and his brother Java-based jlineup to achieve a similar result. Both tools use the same approach based on Selenium.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as you want to test </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usability</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nice design</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you leave the automated testing space. </font><font style="vertical-align: inherit;">Here we will have to rely on </font></font><a href="https://en.wikipedia.org/wiki/Exploratory_testing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">research tests</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , usability tests (up to the simplest </font></font><a href="https://en.wikipedia.org/wiki/Usability_testing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hall tests</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on random people). </font><font style="vertical-align: inherit;">We'll have to hold demonstrations for users and check whether they like the product and if they can use all the features without frustration or irritation.</font></font><br><br><a name="End-to-endTests"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Through tests </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing a deployed application through the UI is the most complete test that can be done. </font><font style="vertical-align: inherit;">The UI tests described above through WebDriver are good examples of pass-through tests.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91a/118/3e7/91a1183e77f1850a1df00b819503b109.png"></div><br>  <i><font color="gray">Fig.</font></i> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11. End-to-end tests verify a fully integrated system as a whole.</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> End-to-end tests (also called</font></font><a href="https://martinfowler.com/bliki/BroadStackTest.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wide-stack tests</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) provide maximum certainty whether the software is running or not.</font></font><a href="http://docs.seleniumhq.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selenium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and</font></font><a href="https://www.w3.org/TR/webdriver/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the WebDriver protocol</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allow you to automate tests by automatically sending headless browsers to deployed services to perform clicks, enter data, and check the status of the UI. You can use Selenium directly or use tools based on it, such as</font></font><a href="http://nightwatchjs.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nightwatch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pass-through tests have other problems. They are known for their unreliability, failures for unexpected and unforeseen reasons. Quite often these are false positive failures. The more complex the UI, the more fragile the tests become. Browser freaks, timing issues, animations, and unexpected pop-up dialogs are just some of the reasons why I spent more time debugging than I would like. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the world of microservices it is also unclear who is responsible for writing these tests. Since they cover several services (the entire system), there is no one specific team responsible for writing end-to-end tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there is a centralized </font><i><font style="vertical-align: inherit;">quality assurance</font></i><font style="vertical-align: inherit;"> team</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they look like a good candidate. Again, it is strictly not recommended to start a centralized QA team, this should not be in the world of DevOps, where all teams are truly universal. There is no simple answer, who should own end-to-end tests. Maybe your organization has some kind of initiative group or </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quality guild</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to take care of them. Here a lot depends on the specific organization. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, end-to-end tests require serious support and are rather slow. If you have a lot of microservices, then you can not even run pass-through tests locally, because then you will need to run all microservices locally. Try running hundreds of applications on your computer, there‚Äôs not enough RAM.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to high maintenance costs, the number of end-to-end tests should be kept to an absolute minimum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Think of the most important user interactions with the application. Think up the main ‚Äúroutes‚Äù of users from screen to screen to automate the most important of these steps in end-to-end tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are doing an online store, then the most valuable "route" will be a product search - placing it in the basket - placing an order.</font></font> That's all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While this route works, there are no special problems. </font><font style="vertical-align: inherit;">Perhaps you will find a couple of important routes for end-to-end tests. </font><font style="vertical-align: inherit;">Everything else is likely to bring more problems than good. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember: in your test pyramid there are a lot of low-level tests, where we have already tested all variants of border situations and integration with other parts of the system. </font><font style="vertical-align: inherit;">There is no need to repeat these tests at a higher level. </font><font style="vertical-align: inherit;">Great maintenance efforts and a lot of false positives will slow down your work too much, and sooner or later you will lose confidence in the tests at all.</font></font><br><br><a name="UserInterfaceEnd-to-endTest"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI end-to-end tests </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For end-to-end tests, many developers choose </font></font><a href="http://docs.seleniumhq.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selenium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the </font></font><a href="https://www.w3.org/TR/webdriver/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebDriver</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> protocol </font><font style="vertical-align: inherit;">. With Selenium, you can choose any browser and set it on the site. Let him push buttons and links everywhere, enter data and check for changes in the UI. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selenium needs a browser that can be launched and used for tests. There are several so-called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"drivers"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for different browsers. Select one (or several) and add it to your </font></font><code>build.gradle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Whatever browser you choose, you should make sure that all developers and CI server have the correct browser version installed. It may be difficult to ensure such synchronization. For Java there is a small </font><a href="https://github.com/bonigarcia/webdrivermanager"><font style="vertical-align: inherit;">webdrivermanager</font></a><font style="vertical-align: inherit;"> library </font></font><a href="https://github.com/bonigarcia/webdrivermanager"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that automates the loading and configuration of the correct browser version. </font><font style="vertical-align: inherit;">Add two such dependencies to </font></font><code>build.gradle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">testCompile(<span class="hljs-string"><span class="hljs-string">'org.seleniumhq.selenium:selenium-chrome-driver:2.53.1'</span></span>) testCompile(<span class="hljs-string"><span class="hljs-string">'io.github.bonigarcia:webdrivermanager:1.7.2'</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Running a full browser in a test suite can be a problem. </font><font style="vertical-align: inherit;">Especially if the continuous delivery server where our pipeline is running is not able to deploy a browser with a UI (for example, because the X-Server is not available). </font><font style="vertical-align: inherit;">In this case, you can run a virtual X-Server like </font></font><a href="https://en.wikipedia.org/wiki/Xvfb"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xvfb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A newer approach is to use a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">headless</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> browser (i.e., a browser without a user interface) for WebDriver tests. </font><font style="vertical-align: inherit;">Until recently, PhantomJS was used most often to automate browser tasks. </font><font style="vertical-align: inherit;">But when </font></font><a href="https://developers.google.com/web/updates/2017/04/headless-chrome"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chromium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://developer.mozilla.org/en-US/Firefox/Headless_mode"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firefox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have introduced a headless mode out of the box, the PhantomJS is suddenly out of date. In the end, it is better to test the site using a real browser that users actually have (for example, Firefox and Chrome), rather than using an artificial browser just because it is convenient for you as a developer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both the Firefox and Chrome headless browsers are completely new and have not yet become widely used for WebDriver tests. We do not want to complicate anything. Instead of messing around with fresh headless modes, let's stick to the classic way, that is, Selenium in conjunction with a regular browser. Here‚Äôs what a simple pass-through test that runs Chrome, goes to our service and checks the contents of the site:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span>(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloE2ESeleniumTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WebDriver driver; <span class="hljs-meta"><span class="hljs-meta">@LocalServerPort</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port; <span class="hljs-meta"><span class="hljs-meta">@BeforeClass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ChromeDriverManager.getInstance().setup(); } <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ driver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ChromeDriver(); } <span class="hljs-meta"><span class="hljs-meta">@After</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tearDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ driver.close(); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helloPageHasTextHelloWorld</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ driver.get(String.format(<span class="hljs-string"><span class="hljs-string">"http://127.0.0.1:%s/hello"</span></span>, port)); assertThat(driver.findElement(By.tagName(<span class="hljs-string"><span class="hljs-string">"body"</span></span>)).getText(), containsString(<span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>)); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that this test will work only if Chrome is installed on the machine where the test is running (your local computer, CI server). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The test is simple. </font><font style="vertical-align: inherit;">It runs the Spring application on a random port with </font></font><code>@SpringBootTest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Then a new Chrome ‚Äúweb driver‚Äù is created, he is instructed to go to the end point of </font></font><code>/hello</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">our microservice and check that ‚ÄúHello World!‚Äù Is printed in the browser window.</font></font> Cool! <br><br><a name="RestApiEnd-to-endTest"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> REST API end-to-end test </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To increase the reliability of tests, a good idea is to avoid GUI. Such tests are more stable than full-fledged end-to-end tests, and at the same time cover a significant portion of the application stack. This can be useful if testing an application through a web interface is especially difficult. Maybe you don‚Äôt even have a web interface, but only a REST API (because a one-page application communicates with this API somewhere or simply because you despise everything beautiful and brilliant). In any case, the situation is suitable for the </font></font><a href="https://martinfowler.com/bliki/SubcutaneousTest.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subcutaneous test</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (subcutaneous test), which tests everything that is under the GUI. If you are servicing the REST API, then such a test will be correct, as in our example:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PersonRepository personRepository; <span class="hljs-comment"><span class="hljs-comment">// shortened for clarity @GetMapping("/hello/{lastName}") public String hello(@PathVariable final String lastName) { Optional&lt;Person&gt; foundPerson = personRepository.findByLastName(lastName); return foundPerson .map(person -&gt; String.format("Hello %s %s!", person.getFirstName(), person.getLastName())) .orElse(String.format("Who is this '%s' you're talking about?", lastName)); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me show you another library that will come in handy when testing a service that provides the REST API. </font><font style="vertical-align: inherit;">The </font></font><a href="https://github.com/rest-assured/rest-assured"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">REST-assured</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">provides a good DSL for running real HTTP requests to the API and evaluating the responses received. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, add a dependency to yours </font></font><code>build.gradle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs">testCompile(<span class="hljs-string"><span class="hljs-string">'io.rest-assured:rest-assured:3.0.3'</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using this library, you can implement a pass-through test for our REST API: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span>(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloE2ERestTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PersonRepository personRepository; <span class="hljs-meta"><span class="hljs-meta">@LocalServerPort</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port; <span class="hljs-meta"><span class="hljs-meta">@After</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tearDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ personRepository.deleteAll(); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnGreeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Person peter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-string"><span class="hljs-string">"Pan"</span></span>); personRepository.save(peter); when() .get(String.format(<span class="hljs-string"><span class="hljs-string">"http://localhost:%s/hello/Pan"</span></span>, port)) .then() .statusCode(is(<span class="hljs-number"><span class="hljs-number">200</span></span>)) .body(containsString(<span class="hljs-string"><span class="hljs-string">"Hello Peter Pan!"</span></span>)); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We again run the entire Spring application with </font></font><code>@SpringBootTest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In this case, we make </font></font><code>@Autowire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for </font></font><code>PersonRepository</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to easily write test data to the database. </font><font style="vertical-align: inherit;">Now when we ask the REST API to say ‚Äúhello‚Äù to our friend ‚ÄúMr Pan‚Äù, we see a pleasant greeting.</font></font> Awesome!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And more than enough for an end-to-end test, if there is no web interface at all. </font></font><br><br><a name="acceptance"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acceptance tests - do your features work correctly? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The higher you rise in the pyramid of tests, the more likely you are to ask questions: do the features work correctly from the user's point of view? </font><font style="vertical-align: inherit;">You can view the application as a black box and change the direction of the tests from the past:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when I enter x and y, the return value should be z </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the next: </font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considering</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that there is an authorized user </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> there is a ‚Äúbicycle‚Äù product </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> user goes to the ‚Äúbicycle‚Äù product description page </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> presses the ‚ÄúAdd to basket‚Äù button, </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äúbicycle‚Äù product should be in his basket</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It happens that such tests are called </font></font><a href="https://en.wikipedia.org/wiki/Functional_testing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">functional</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><a href="https://en.wikipedia.org/wiki/Acceptance_testing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acceptance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tests </font><font style="vertical-align: inherit;">. Some say that functional and acceptance tests are two different things. Sometimes terms combine. Sometimes people endlessly argue about formulations and definitions. Often such discussions introduce even more confusion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here's what: at some point you should make sure that your program works correctly from the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">user's</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> point of view </font><font style="vertical-align: inherit;">, and not just from a technical point of view. What you call these tests is not really that important. But the presence of these tests is important. Choose any term, stick to it and write these tests.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also mention the BDD (development, based on the description of the behavior) and tools for it. BDD and the corresponding test-writing style is a good trick to change your thinking from implementation details to user needs. Do not be afraid and try. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You don't even have to implement full-scale BDD tools, such as </font></font><a href="https://cucumber.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cucumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (although you can also implement). Some assertion libraries like </font></font><a href="http://chaijs.com/guide/styles/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chai.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allow you to write assertions with keywords in a style </font></font><code>should</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that bring tests to BDD. And even if you don‚Äôt use a library that provides this notation, smart and well thought out code will allow you to write tests that focus on user behavior. Some helper methods / functions can be very successful:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># a sample acceptance test in Python def test_add_to_basket(): # given user = a_user_with_empty_basket() user.login() bicycle = article(name="bicycle", price=100) # when article_page.add_to_.basket(bicycle) # then assert user.basket.contains(bicycle)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acceptance tests can be conducted at different levels of detail. </font><font style="vertical-align: inherit;">Basically, they will be quite high level and test the service through the UI. </font><font style="vertical-align: inherit;">But it is important to understand that technically there is no mandatory requirement to write acceptance tests at the highest level of the test pyramid. </font><font style="vertical-align: inherit;">If the structure of the application and the existing script allow you to write an acceptance test at a lower level, do it. </font><font style="vertical-align: inherit;">A low test is better than a high test. </font><font style="vertical-align: inherit;">The concept of acceptance tests - to prove that the application features work correctly for the user - is completely orthogonal to your test pyramid.</font></font><br><br><a name="ExploratoryTesting"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Research testing </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even the most diligent efforts to automate tests are not perfect. Sometimes in automatic tests you miss certain borderline cases. Sometimes it is simply impossible to detect a specific error by writing a unit test. Some quality problems will not appear at all in automated tests (think about design or usability). Despite the best intentions regarding test automation, manual tests are still irreplaceable in some respects.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65d/c55/38f/65dc5538f1f4ff98c973d5cc43f6a152.png"></div><br>  <i><font color="gray">Fig.</font></i> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12. Research testing will identify quality issues that are not noticed during the build process.</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Include</font></font><a href="https://en.wikipedia.org/wiki/Exploratory_testing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> research tests</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in your test suite. This manual testing procedure emphasizes the freedom and creativity of the tester, who is able to find quality problems in a running system. Just set aside some time in the schedule, roll up your sleeves and try to cause the application to fail in some way. Turn on destructive thinking and think of ways to provoke problems and bugs in the program. Document everything you find. Look for bugs, design issues, slow response times, missing or misleading error messages, and anything else that annoys you as a user.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The good news is that you can easily automate tests for most of the errors found. Writing automated tests for errors found ensures that there will be no regressions of this error in the future. In addition, it helps to find out the root cause of the problem when fixing a bug.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">During exploratory testing, you will find problems that have slipped imperceptibly through the assembly line. Dont be upset. This is a good feedback to improve the assembly line. As with any feedback, be sure to respond on your part: think about what action to take to avoid this kind of problem in the future. Maybe you missed a certain set of automatic tests. It may have been careless with automated tests at this stage and should be more thoroughly carried out in the future. Perhaps there is some brilliant new tool or approach that you can use in your pipeline to avoid such problems. Be sure to respond so that your pipeline and the entire software delivery system become better and improved with each step.</font></font><br><br><a name="TheConfusionAboutTestingTerminology"></a><h1>      </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is always difficult to talk about different classifications of tests. My understanding of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unit tests</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (unit tests) may be slightly different from yours. With integration tests even worse. For some people, integration testing is a very broad activity that tests many different parts of the entire system. For me, this is a rather narrow thing: testing only integration with one external part at a time. Some people call it </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tests, some - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">component</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tests </font><font style="vertical-align: inherit;">, others prefer the term </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">service test</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Someone will say that these are generally three completely different things. There is no right or wrong definition. The software community simply did not establish well-defined terms in testing.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not focus on ambiguous terms. It does not matter if you call this the end-to-end test, the wide stack test, or the functional test. It doesn‚Äôt matter if your integration tests mean to you that‚Äôs not for people in another company. Yes, it would be very good if our industry could clearly define the terms and all would adhere to them. Unfortunately, this has not happened yet. And since there are many nuances in testing, we still deal with a wide range of tests rather than with a bunch of discrete sets, which further complicates clear terminology.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to take it this way: you simply find terms that work for you and your team. </font><font style="vertical-align: inherit;">Clearly identify for yourself the various types of tests you want to write. </font><font style="vertical-align: inherit;">Agree on terms in your team and find a consensus on the coverage of each type of test. </font><font style="vertical-align: inherit;">If in your team (or even throughout the organization) you are consistent with these terms, then this is all that needs to be taken care of. </font></font><a href="https://testing.googleblog.com/2010/12/test-sizes.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simon Stewart</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> summed it up well in the approach that is used in Google. </font><font style="vertical-align: inherit;">I think this is a wonderful demonstration that you should not get too hung up on the names and conventions of the terms.</font></font><br><br><a name="PuttingTestsIntoYourDeploymentPipeline"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deploying tests into the deployment pipeline </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you use continuous integration or continuous delivery, then your </font></font><a href="https://martinfowler.com/bliki/DeploymentPipeline.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deployment pipeline</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> runs automated tests every time you make changes to the software. Usually the pipeline is divided into several stages, which gradually give more and more confidence that your program is ready for deployment in a working environment. When you hear about all the varieties of tests, you may be wondering how to put them in the deployment pipeline. To answer this, you just need to think about one of the most fundamental values ‚Äã‚Äãof continuous delivery (this is one of the key values ‚Äã‚Äãof </font></font><a href="http://www.extremeprogramming.org/values.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extreme programming</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and agile development): </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast feedback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A good assembly line quickly reports errors. You do not want to wait a whole hour to find out that the latest change broke some simple unit tests. If the conveyor is so slow, then you could have gone home when feedback arrived. Information should arrive in a few seconds or a few minutes from quick tests in the early stages of the pipeline. Conversely, longer tests ‚Äî usually with a wider area ‚Äî are placed at later stages so as not to inhibit feedback from fast tests. As you can see, the stages of the deployment pipeline are not determined by the types of tests, but by their speed and scope. Therefore, it may be very reasonable to place some of the narrowest and fastest integration tests at the same stage as unit tests - simply because they provide faster feedback.And it is not necessary to conduct a strict line on the formal type of tests.</font></font><br><br><a name="AvoidTestDuplication"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avoid duplicate tests </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is another trap that should be avoided: duplication of tests at different levels of the pyramid. </font><font style="vertical-align: inherit;">The smell says there aren't many tests, but let me assure you: it happens. </font><font style="vertical-align: inherit;">Each test in the test set - extra baggage, which does not cost for free. </font><font style="vertical-align: inherit;">Writing and running tests takes time. </font><font style="vertical-align: inherit;">Reading and understanding someone else's test takes time. </font><font style="vertical-align: inherit;">And of course, the execution of tests also takes time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As with the production code, you should strive for simplicity and avoid duplication. </font><font style="vertical-align: inherit;">In the context of the implementation of the pyramid of tests, there are two rules of thumb:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If an error is found in the test of a higher level, and there is no error in the tests of a lower level, then it is necessary to write a test of a lower level. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Move the tests as low as possible along the levels of the pyramid. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first rule is important because lower level tests better allow you to narrow the area and reproduce the error in isolation. They are faster and less bloated, which helps with manual debugging. And in the future will serve as a good regression test. The second rule is important for quick test suite execution. If you have confidently tested all the conditions on tests of a lower level, then there is no need to test a higher level. It simply does not add confidence that everything works. Excess tests will become a burden and begin to annoy in everyday work. The test suite will run slower, and as the code changes, more tests will need to be changed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We formulate differently: if a test of a higher level gives more confidence that the application works correctly, then you need to have such a test. Writing a unit test for the controller class helps to verify the logic inside the controller itself. However, it does not tell you whether the REST endpoint that this controller provides really responds to HTTP requests. Thus, you move up the pyramid of tests and add a test that verifies that, but no more. In a higher level test, you do not test all conditional logic and borderline cases that are already covered by lower level unit tests. Make sure that a high level test focuses only on what is not covered by lower level tests.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I strictly refer to the exclusion of tests that have no value. </font><font style="vertical-align: inherit;">I delete high-level tests that are already covered at a lower level (given that they do not provide additional value). </font><font style="vertical-align: inherit;">Replace higher level tests with lower level tests, if possible. </font><font style="vertical-align: inherit;">It is sometimes difficult to remove an extra test, especially if it was not easy to invent. </font><font style="vertical-align: inherit;">But you risk creating </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25B2%25D0%25BE%25D0%25B7%25D0%25B2%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B7%25D0%25B0%25D1%2582%25D1%2580%25D0%25B0%25D1%2582%25D1%258B"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irrecoverable costs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so feel free to click Delete. </font><font style="vertical-align: inherit;">There is no reason to spend precious time on the test, which has ceased to be useful.</font></font><br><br><a name="WritingCleanTestCode"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Write clean code for tests </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As with the usual code, you should take care of the good and clean code of the tests. </font><font style="vertical-align: inherit;">Here are some more tips for creating supported test code before you start and create an automated test suite:</font></font><br><br><ol><li>     ,     .       . ¬´   ¬ª ‚Äî     . </li><li>       .      . </li><li>    (arrange, act, assert)   ¬´, , ¬ª ‚Äî  ,     . </li><li>   .   DRY ( ¬´ ¬ª).  ,   .      <a href="https://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests">DRY  DAMP</a> (DAMP ‚Äî Descriptive And Meaningful Phrases,    ). </li><li>        ,  <a href="https://blog.codinghorror.com/rule-of-three/"> </a> . <i>Use before reuse</i> . </li></ol><br><a name="Conclusion"></a><h1>  Conclusion </h1><br>  That's all!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I know it was a long and difficult explanation of why and how to conduct testing. </font><font style="vertical-align: inherit;">The great news is that this information has almost no statute of limitations and does not depend on which program you are creating. </font><font style="vertical-align: inherit;">You work on microservices, IoT devices, mobile applications or web applications, the lessons from this article apply to everything. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope that the article has something useful. </font><font style="vertical-align: inherit;">Now go ahead, study the </font></font><a href="https://github.com/hamvocke/spring-testing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and apply the learned concepts in your test suite. </font><font style="vertical-align: inherit;">Creating a strong test suite requires some effort. </font><font style="vertical-align: inherit;">It will pay off in the long run and make your developer life more relaxed, trust me.</font></font><br><br>  <b>See also:</b> <br> <a href="https://habr.com/post/358178/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Antipattern testing software"</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/358950/">https://habr.com/ru/post/358950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358940/index.html">Switzerland Travel Guide</a></li>
<li><a href="../358942/index.html">Apollo graphql client - development of isomorphic (universal) applications on react.js</a></li>
<li><a href="../358944/index.html">How to speed up mobile search in half. Yandex lecture</a></li>
<li><a href="../358946/index.html">Introduction to competitive networks</a></li>
<li><a href="../358948/index.html">Data centers, similar to chicken coops, and work in Antarctica: a selection of unusual data centers</a></li>
<li><a href="../358954/index.html">Multi-output in machine learning</a></li>
<li><a href="../358960/index.html">The digest of interesting materials for the mobile developer # 253 (May 14 - May 20)</a></li>
<li><a href="../358964/index.html">How I migrated the project from Angular 1 to React</a></li>
<li><a href="../358966/index.html">Universal API for Check Information</a></li>
<li><a href="../358968/index.html">What are smart contracts: a brief guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>