<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating real-time applications using Server-Sent Events</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Just recently, it became known that Firefox 6 will receive SSE ( already in Opera 10.6+, Chrome, WebKit 5+, iOS Safari 4+, Opera Mobile 10+) so that m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating real-time applications using Server-Sent Events</h1><div class="post__text post__text-html js-mediator-article">  Just recently, it became known that <a href="https://hacks.mozilla.org/2011/05/aurora-6-is-here/">Firefox 6 will receive SSE</a> ( <a href="http://caniuse.com/">already</a> in Opera 10.6+, Chrome, WebKit 5+, iOS Safari 4+, Opera Mobile 10+) so that more than half of all browsers (user reach) are no longer supported. by the mountains.  It is time to look at this technology.  SSE <a href="http://ln.hixie.ch/%3Fcount%3D1%26start%3D1083167110">proposed</a> Ian Hickson more than 7 years ago, but only a year ago it began to appear in browsers.  We have WebSockets, why do we need another protocol?  But everything has its pros and cons, let's see what SSE can be useful for. <br><br>  The idea of ‚Äã‚ÄãSSE is simple - the client subscribes to server events and as soon as an event occurs - the client immediately receives a notification and some data associated with this event.  To understand the usefulness of the SSE protocol, it is necessary to compare it with the usual methods of receiving events, briefly explain their essence: <br><a name="habracut"></a><br><h4>  Polling </h4><br>  The simplest, but the most inefficient, method: the client polls the server once every few seconds for events.  Even if there is nothing, then the client makes a request vseravno - and you never know what will come. <br>  <b>Pros:</b> <br>  - Simply <br>  - Data can be shipped <br>  <b>Minuses:</b> <br>  - A lot of extra requests <br>  - Events always come late <br>  - The server has to store events until the client picks them up or until they become obsolete <br><br><h4>  Long polling </h4><br>  An improved version of the previous method.  The client sends a request to the server, the server keeps the connection open until some data arrives or the client disconnects on its own.  As soon as the data has arrived, the response is sent and the connection is closed and the next is opened and so on. <br>  <b>Pluses in comparison with Polling:</b> <br>  - Minimum number of requests <br>  - High temporal accuracy of events <br>  - The server stores events only for the time of reconnect <br>  <b>Cons compared to Polling:</b> <br>  - More complicated circuit 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  WebSockets </h4><br>  This is a binary duplex protocol that allows the client and server to communicate on an equal footing.  This protocol can be used for games, chats and all those applications where you need extremely accurate events close to real time. <br>  <b>Pluses in comparison with Long Polling:</b> <br>  - One connection rises <br>  - Extremely high temporal accuracy of events <br>  - Manage network failures controlled by browser <br>  <b>Cons compared to Long Polling:</b> <br>  - HTTP is not a compatible protocol, you need your server, debugging is complicated <br><br>  So why is it worth using SSE, since we have such a great protocol WebSockets ?!  First, not every web application needs two-way communication ‚Äî SSE will do.  Secondly, SSE is an HTTP compliant protocol and you can implement event broadcasting on any web server. <br><br><h4>  Server-Sent Events Protocol </h4><br>  The client sends a request to the server, the server sends the following header in response: <br><pre><code class="hljs pgsql">Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: <span class="hljs-type"><span class="hljs-type">text</span></span>/event-stream</code> </pre> <br>  And it does not close the connection (on php you can create an infinite loop, how to do it on node.js will be explained in the sample article).  That's it - SSE works!  To send some data to the client, the server simply writes a string of the following format to the socket: <br><pre> <code class="javascript hljs">data: My message\n\n</code> </pre><br>  If you need to send several lines of data, the format will be as follows: <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: {\n <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: <span class="hljs-string"><span class="hljs-string">"msg"</span></span>: <span class="hljs-string"><span class="hljs-string">"hello world"</span></span>,\n <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">12345</span></span>\n <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: }\n\n</code> </pre><br>  Here, in principle, and the entire base of the protocol.  In addition, the server can send an id message, it is necessary in case the connection was terminated.  If the connection was dropped, the client will send a special header (Last-Event-ID) when trying to connect to recover lost events: <br><pre> <code class="hljs tex">id: 12345<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span> data: GOOG<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span> data: 556<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span></code> </pre><br>  Retry time in case of errors: <br><pre> <code class="hljs tex">retry: 10000<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span> data: hello world<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span></code> </pre><br>  The id and retry fields are optional. <br><br>  On the client, everything will look like this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventSource(<span class="hljs-string"><span class="hljs-string">'http://localhost/stream.php'</span></span>); source.addEventListener(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  console.log(e.data); }, false); source.addEventListener('open', function(e) { //    }, false); source.addEventListener('error', function(e) { if (e.eventPhase == EventSource.CLOSED) { //   } }, false);</span></span></code> </pre><br>  Everything is very simple.  Let's build an application based on the SSE protocol.  As usual, it will be a chat. <br><br><h4>  Multipart XMLHTTPRequest </h4><br>  Also called multipart streaming (Supports only Firefox).  Very similar to SSE protocol. <br>  Its title has a format: <br><pre> <code class="javascript hljs">Content-type: multipart/x-mixed-replace;boundary=smthing</code> </pre><br>  And the parts are sent in this format: <br><pre> <code class="javascript hljs">Content-type: text/html\r\n\r\n --smthing\n Message\n --smthing\n</code> </pre><br><br>  The client creates a regular XHR, but before sending the request, you must set the flag <code>req.multipart = true;</code> <br>  Does it look like SSE?  <a href="httprequest">Read more</a> <br><br>  There is another protocol that can lead to SSE: <br><br><h4>  XMLHTTPRequest: Interactive </h4><br>  To use it, browser support for the special readyState with code 3 (interactive) is necessary - this status indicates that part of the data has arrived, but the connection has not yet been closed.  For jQuery, there is a <a href="http://code.google.com/p/jquery-readystate3/">plugin of the</a> same name that uses readyState with code 3. And as always, not all browsers support readyState with code 3. <br><br><h4>  Example: Chat on Server-Sent Events </h4><br>  We will receive a stream of events on SSE: going offline, coming online, posting.  Because  SSE can not send a message, then we will send them via HTTP. <br><br>  The scheme of work is as follows: <br>  - At the entrance to the chat name is requested <br>  - The client connects to the chat server.  It creates a stream of events. <br>  - When a client connects, the chat sends to all the event:% username% online <br>  - When a client disconnects, the chat sends to all the event:% username% offline <br>  - The client can send a message via HTTP "POST / message" The server accepts this message and sends the received message to all clients via SSE <br><br>  Let's sort the client code.  In order for some browsers not to have an infinite download, instead of $ .ready, we execute setTimeout: <br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,   $.ready       }, 50);</span></span></code> </pre><br>  Requesting username: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    localStorage    var name = (prompt('Name:', window.localStorage ? window.localStorage['name'] || '' : '') || 'anonymous').substr(0, 20); //    if (window.localStorage) { window.localStorage['name'] = name; }</span></span></code> </pre><br>  Create an EventSource and pass it the user name (now the user is online) and listen to the necessary events: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventSrc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventSource(<span class="hljs-string"><span class="hljs-string">"/event?name="</span></span> + name); <span class="hljs-comment"><span class="hljs-comment">//   EventSource - "message" eventSrc.addEventListener("message", function(event) { var data = JSON.parse(event.data); //      renderMessage(data); }, false); //   EventSource - "error" eventSrc.addEventListener("error", function(event) { //      renderMessage({ isbot: true, message: 'connection error', name: '@Chat' }); }, false);</span></span></code> </pre><br>  I will not consider the renderMessage method and page layout.  All client code can be viewed here: <a href="https://github.com/azproduction/event-source-chat/blob/master/index.html">index.html</a> <br><br>  On the server side we will have Node.js.  Everything is more complicated here, but the main difficulty in multicast messages from one user to all, and not in building communication via SSE. <br><br><h5>  We connect the necessary modules </h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>), fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>), qs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'querystring'</span></span>), parse = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>).parse; <span class="hljs-comment"><span class="hljs-comment">//   (index.html      Node.js) var indexFile = fs.readFileSync('index.html'); // Buffer</span></span></code> </pre><br><h5>  Routs </h5><br>  Create a list of routes Routes, which includes the following objects: <br>  <b>1. Static.</b>  <b>Index page, we just helmet statics:</b> <br><pre> <code class="javascript hljs"> <span class="hljs-string"><span class="hljs-string">'GET /'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    response.writeHead(200, {'Content-Type': 'text/html; charset=UTF-8'}); response.write(indexFile); response.end(); }</span></span></code> </pre><br>  <b>2. Raising the SSE connection:</b> <br><pre> <code class="javascript hljs"> <span class="hljs-string"><span class="hljs-string">'GET /event'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = parse(request.url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = (url.query.name || <span class="hljs-string"><span class="hljs-string">'anonymous'</span></span>).substr(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clientId = Clients.generateClientId(); <span class="hljs-comment"><span class="hljs-comment">//     EventSource response.writeHead(200, {'Content-Type': 'text/event-stream'}); //     ,     2  request.socket.setTimeout(1000 * 60 * 60); // 1  //    -    request.on('close', function () { Clients.remove(clientId); }); //     Clients.add(clientId, response, name); }</span></span></code> </pre><br>  <b>3. Message from customer:</b> <br><pre> <code class="javascript hljs"> <span class="hljs-string"><span class="hljs-string">'POST /message'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    POST request.on('data', function (chunk) { data += chunk; }); //   POST   request.on('end', function () { //   data = qs.parse(data); //    Clients.broadcast(data.message, data.name, false); response.writeHead(200); response.end(); }); }</span></span></code> </pre><br>  <b>4. Route by default - Page 404:</b> <br><pre> <code class="javascript hljs"> $: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request, response</span></span></span><span class="hljs-function">) </span></span>{ response.writeHead(<span class="hljs-number"><span class="hljs-number">404</span></span>); response.end(); }</code> </pre><br><h5>  Client Manager - Clients </h5><br>  When adding a new client (add), the manager sends the entire message that the client has arrived: <br><pre> <code class="javascript hljs"> add: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">clientId, response, name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._clients[clientId] = {<span class="hljs-attr"><span class="hljs-attr">response</span></span>: response, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name || <span class="hljs-string"><span class="hljs-string">'anonymous'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count++; <span class="hljs-comment"><span class="hljs-comment">//      this.unicast(clientId, 'Hello, ' + name + '! Online ' + this.count, '@ChatBot', true); this.broadcast(name + ' online', '@ChatBot', true); }</span></span></code> </pre><br>  When deleting closes the connection and sends to all that the client is offline: <br><pre> <code class="javascript hljs"> remove: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">clientId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,     var client = this._clients[clientId]; if (!client) { return; } //   client.response.end(); //   delete this._clients[clientId]; this.count--; //   ,    //      this.broadcast(client.name + ' offline', '@ChatBot', true); }</span></span></code> </pre><br>  To send messages to clients, use the private _send method: <br><pre> <code class="javascript hljs"> _send: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">clients, message, name, isbot</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!message || !name) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//   var data = JSON.stringify({ message: message.substr(0, 1000), name: (name || 'anonymous').substr(0, 20), isbot: isbot || false }); //   ,      //     -   Node.js data = new Buffer("data: " + data + "\n\n", 'utf8'); //   SSE //   clients.forEach(function (client) { client.response.write(data); //   }); }</span></span></code> </pre><br>  The _send method uses public broadcast and unicast methods to send messages to all and one client, respectively. <br><br><h5>  Create and enable the server </h5><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var httpServer = http.createServer(function (request, response) { var key = request.method + ' ' + parse(request.url).pathname; //   ,     Routes.$ - 404 (Routes[key] || Routes.$)(request, response); }); //   httpServer.listen(80); console.log('Online');</span></span></code> </pre><br>  <a href="">Source server.js</a> <br><br>  Our SSE chat is ready.  We start the server: <br><pre> <code class="hljs pgsql">$ node <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.js</code> </pre><br>  Open one of the browsers: Firefox 6, Opera 10.6+, Chrome, WebKit 5+, iOS Safari 4+, Opera Mobile 10+.  Go to <code>http://</code> <code>localhost/</code> and chat! <br><br><h4>  Conclusion </h4><br>  SSE is a good technology that should replace Long Poling; it is simple and no less effective than WebSockets.  Now SSE supports Opera 10.6+ (Opera 9 supports the old SSE standard), Chrome, Safari 5+.  Firefox supports Multipart XMLHTTPRequest, for which you can write a wrapper and use it as an SSE interface. <br><br><h4>  Links </h4><br>  1. An online example of SSE chat can be viewed here: <a href="http://sse-chat.nodester.com/">sse-chat.nodester.com</a> <br>  <i>This is a somewhat stripped-down version of the chat due to the peculiarities of Nodester proxying (there is no message about the number of users online and no messages about quitting the chat, there may be frequent reconnect)</i> <br>  2. Sample <a href="https://github.com/azproduction/event-source-chat">source</a> : <a href="https://github.com/azproduction/event-source-chat">github.com/azproduction/event-source-chat</a> <br>  3. <a href="http://www.html5rocks.com/tutorials/eventsource/basics/">Another SSE Tutorial</a> <br>  4. <a href="http://dev.w3.org/html5/eventsource/">Specification</a> <br><br>  <b>PS</b> It seems that the chat has covered habraeffekt, but something is possible with nodester (it often happens at it).  If you are interested in the result, then download the <a href="https://github.com/azproduction/event-source-chat">source</a> from GitHub. <br><br>  <b>UPD</b> Added Multipart XMLHTTPRequest, XMLHTTPRequest: Interactive thanks for the addition <a href="https://habrahabr.ru/users/yui_room9/" class="user_link">yui_room9</a> </div><p>Source: <a href="https://habr.com/ru/post/120429/">https://habr.com/ru/post/120429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120424/index.html">Creating a programming language using LLVM. Part 3: LLVM IR Code Generation</a></li>
<li><a href="../120425/index.html">Sberbank ATM interface 4 months later</a></li>
<li><a href="../120426/index.html">From the USA to Russia in a week ... Russian Post can!</a></li>
<li><a href="../120427/index.html">Will they play social games outside of social networks?</a></li>
<li><a href="../120428/index.html">Browser Strategy "Paths of History." Architecture and project evolution</a></li>
<li><a href="../120430/index.html">Kango - framework for creating cross-browser extensions</a></li>
<li><a href="../120432/index.html">Work with KVM virtual machines. Introduction</a></li>
<li><a href="../120433/index.html">New service from PRUFFI: ‚Äúwe sell‚Äù ready start-up teams</a></li>
<li><a href="../120434/index.html">PowerShell: machine vs man</a></li>
<li><a href="../120437/index.html">Himself a PR man. Writers and Speakers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>