<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with Perl encodings</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√© there is already a good article about using UTF-8 in Perl - habrahabr.ru/post/53578 . I'm still a little different 
 I would like to talk abo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with Perl encodings</h1><div class="post__text post__text-html js-mediator-article"> On Habr√© there is already a good article about using UTF-8 in Perl - <a href="http://habrahabr.ru/post/53578/">habrahabr.ru/post/53578</a> .  I'm still a little different <br>  I would like to talk about encodings. <br><br>  A lot of questions related to the variety of encodings, as well as the terminology used.  In addition, many of us have encountered problems with encodings.  I will try in this article to write in an understandable form information on this issue.  I'll start with the question of automatic detection of text encoding. <a name="habracut"></a><br><br>  <b>Determining the encoding of the source file.</b>  The definition of the encoding of the original document, a task that is quite common in practice.  Take as an example the browser.  In addition to the html file, it may also receive a header in the HTTP response, which specifies the encoding of the document and this header may not be correct, so you cannot rely only on it, as a result, browsers support the ability to automatically determine the encoding. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In Perl, you can use Encode :: Guess for this, but the more ‚Äúadvanced‚Äù industrial version is Encode :: Detect :: Detector.  As it is written in its documentation, it provides an interface to the Mozilovsky universal coding identifier. <br><br>  If you study the source code, pay attention to the vnsUniversalDetector.cpp file and method <br><br> <code>nsresult nsUniversalDetector::HandleData(const char* aBuf, PRUint32 aLen)</code> <br> <br>  From this method begins all the work on the definition of encoding.  First, it is determined whether there is a BOM header, and if so, the further definition of the encoding is performed by simply comparing the initial data bytes: <br><ul><li>  EF BB BF UTF-8 encoded BOM </li><li>  FE FF 00 00 UCS-4, occount order BOM (3412) </li><li>  FE FF UTF-16, big endian BOM </li><li>  00 00 FE FF UTF-32, big-endian BOM </li><li>  00 00 FF FE UCS-4, unusual octet order BOM (2143) </li><li>  FF FE 00 00 UTF-32, little-endian BOM </li><li>  FF FE UTF-16, little endian BOM </li></ul><br><br>  Then each data byte is analyzed and whether the character is related to non-US-ASCII (codes from 128 to 255). If so, then class objects are created: <br><ul><li>  nsMBCSGroupProber; </li><li>  nsSBCSGroupProber; </li><li>  nsLatin1Prober; </li></ul><br><br>  each of which is responsible for the analysis of encoding groups (MB - multibyte, SB - single-byte). <br><br>  If it is US-ASCII, then there are 2 options here, either it is ordinary ASCII (pure ascii) or a file containing escape sequences and refers to such encodings as ISO-2022-KR, etc.  (for more details <a href="http://en.wikipedia.org/wiki/ISO/IEC_2022">see en.wikipedia.org/wiki/ISO/IEC_2022</a> ).  In this case, the detector is used implemented by the class nsEscCharSetProber. <br><br>  nsMBCSGroupProber supports such encodings as: ‚ÄúUTF8‚Äù, ‚ÄúSJIS‚Äù, ‚ÄúEUCJP‚Äù, ‚ÄúGB18030‚Äù, ‚ÄúEUCKR‚Äù, ‚ÄúBig5‚Äù, ‚ÄúEUCTW‚Äù. <br><br>  nsSBCSGroupProber - such as Win1251, koi8r, ibm866 and others. <br><br>  The definition of single-byte encoding is based on the analysis of the frequency of occurrence of 2-character sequences in the text. <br><br>  It should be said that all these methods are probabilistic in nature.  For example, if there are not enough words to define, no algorithm can automatically determine the encoding.  Therefore, in various programming environments, the issue with encodings is solved in its own way, but there is no such that everything is determined by itself. <br><br>  <b>Unicode and Perl.</b>  <b>Historical perspective.</b>  According to Unicode <a href="http://www.unicode.org/glossary/">www.unicode.org/glossary</a> there are 7 possible coding schemes: UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32, UTF-32BE, UTF-32LE.  For the term Unicode itself, the following definition is given: "... a standard for the digital representation of characters that are used in a letter by all languages ‚Äã‚Äãof the world ...".  In addition, there is also UTF-7, which is not part of the standard, but is supported by Perl - Encode :: Unicode :: UTF7 (see also RFC 2152). <br><br>  UTF-7 is almost never used.  Here is what is written in Encode :: Unicode :: UTF7 - ‚Äú... However, if you want to use UTF-7 for documents in mail and web pages, do not use it unless you make sure that recipients and readers (in the sense of these documents) can process this encoding ... ". <br><br>  Perl developers, following the progress on the universal implementation of Unicode encodings in applications, have also implemented Unicode support in Perl.  In addition, the Encode module also supports other encodings, both single-byte and multibyte, the list of which can be viewed in the package Encode :: Config.  For working with letters, the following MIME encodings are supported: MIME-Header, MIME-B, MIME-Q, MIME-Header-ISO_2022_JP. <br><br>  It should be said that UTF-8 is very widely used as a coding for web documents.  UTF-16 is used in Java and Windows, UTF-8 and UTF-32 are used by Linux and other Unix-like systems. <br><br>  Starting with Perl version 5.6.0, the ability to work with Unicode was originally implemented.  However, Perl 5.8.0 was recommended for more serious work with Unicode.  Perl 5.14.0 is the first version in which Unicode support is easily (almost) integrated without several pitfalls (exceptions are some of the differences in quotemeta).  Version 5.14 also fixes several bugs and deviations from the Unicode standard. <br><br>  <b>Visual Studio 2012 and encoding (for comparison with Perl).</b>  When we write some C # application in Visual Studio, we do not think about the coding in which all this is stored and processed.  When you create a document in Vistual Studio, it will create it in UTF8 and also add a UTF8 BOM to the header ‚Äî a sequence of bytes 0xEF, 0xBB, 0xBF.  When we convert the source file (already open in Visual Studio), for example, from UTF8 to CP1251, we get an error message <br>  Unicode substitution character while loading ... with Unicode (UTF-8) encoding.  Preserve the original file contents. <br><br>  If you open an existing file in cp1251 - ToUpper (), for example, it will work correctly, and if you convert the file to KOI8-R and then open it in Visual Studio and run, there is no question of any correct work, the environment does not know what is it KOI8-R, and how can she find out? <br><br>  <b>‚ÄúUnicode Bug in Perl‚Äù.</b>  Just like in Visual Studio, something similar happens with a Perl program, but Perl developers can explicitly specify the encoding of the source code of an application.  That is why when beginners begin to program in perl they open their favorite editor on Russian-language Windows XP and write something in the spirit of ANSI (ie cp1251) <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $a = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $b = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $c = ‚Äúword‚Äù; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Words are equal"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uc</span></span>($a) eq <span class="hljs-keyword"><span class="hljs-keyword">uc</span></span>($b);</code> </pre><br>  and the output is that the lines in the variables are not equal, they are at first difficult to understand what is happening.  Similar things happen with regular expressions, string functions (but uc ($ c) will work correctly). <br><br>  This is the so-called ‚ÄúUnicode Bug‚Äù in Perl (see the documentation for details), due to the fact that for different single-byte encodings, characters with codes from 128 to 255 will have different meanings.  For example, the letter P in cp1251 - has the code 0xCF, whereas in CP866 - 0x8F, and in KOI8-R - 0xF0.  How, then, is it possible to work out such string functions as uc (), ucfirst (), lc (), lcfirst () or \ L, \ U in regular expressions? <br><br>  It is enough to ‚Äúprompt‚Äù the interpreter that the encoding of the source file is cp1251 and everything will work correctly.  More precisely, in the code below, the variables $ a and $ b will store strings in the internal Perl format. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> encoding <span class="hljs-string"><span class="hljs-string">'cp1251'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $a = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $b = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"equal"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uc</span></span>($a) eq <span class="hljs-keyword"><span class="hljs-keyword">uc</span></span>($b);</code> </pre><br><br>  <b>Perl's internal string format.</b>  In not very old versions of Perl, strings can be stored in a so-called internal format (Perl's internal form).  Note that they can also be stored as a simple set of bytes.  In the example above, where the source file encoding was not explicitly specified (using use encoding 'cp1251';), the $ a, $ b, $ c variables store just a set of bytes (in the Perl documentation the term octet sequence is used - a sequence of octets). <br><br>  The internal format differs from the set of bytes by using the UTF-8 encoding and the UTF8 flag is enabled for the variable.  I will give an example.  Change the source code of the program to the next <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> encoding <span class="hljs-string"><span class="hljs-string">'cp1251'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Devel::Peek; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $a = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $b = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> Dump ($a);</code> </pre><br><br>  This is what we get as a result. <br><br>  SV = PV (0x199ee4) at 0x19bfb4 <br>  REFCNT = 1 <br>  FLAGS = (PADMY, POK, pPOK, UTF8) <br>  PV = 0x19316c "\ 321 \ 201 \ 320 \ 273 \ 320 \ 276 \ 320 \ 262 \ 320 \ 276" \ 0 [UTF8 "\ x {441} \ x {43b} \ x {43e} \ x {432} \ x {43e} "] <br>  CUR = 10 <br>  LEN = 12 <br><br>  Please note that FLAGS = (PADMY, POK, pPOK, UTF8).  If we remove use encoding 'cp1251'; <br>  then we get <br><br>  SV = PV (0x2d9ee4) at 0x2dbfc4 <br>  REFCNT = 1 <br>  FLAGS = (PADMY, POK, pPOK) <br>  PV = 0x2d316c "\ 321 \ 201 \ 320 \ 273 \ 320 \ 276 \ 320 \ 262 \ 320 \ 276" \ 0 <br>  CUR = 10 <br>  LEN = 12 <br><br>  When we specify that the source code of a file encoded in cp1251 or any other, then Perl knows that it is necessary to convert string literals in the source code from the specified encoding to an internal format (in this case from cp1251 to an internal UTF-8 format) and does . <br><br>  A similar problem of encoding determination arises when working with data received ‚Äúfrom the outside‚Äù, for example, files or the web.  Consider each of the cases. <br><br>  Suppose we have a file in the cp866 encoding, which contains the word "When" (in the text file, the word When with a capital letter).  We need to open it and analyze all the lines to find the word "when."  Here's how to do it right (with the source code itself must be in utf8). <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> encoding <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $tmp, <span class="hljs-string"><span class="hljs-string">"&lt;:encoding(cp866)"</span></span>, $ARGV[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"Error open file - $!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (&lt;$tmp&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">//i</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"OK\n"</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">close</span></span> ($tmp);</code> </pre><br><br>  Please note that if we do not use "&lt;: encoding (cp866)", and specify use encoding 'cp866' then regular expressions will work, but only with a set of bytes and / i will not work.  The ‚Äú&lt;: encoding (cp866)‚Äù construct tells Perl that the data is in a text file in the CP866 encoding, so it correctly performs the transcoding from CP866 to the internal format (CP866 -&gt; UTF8 + turns on the UTF8 flag). <br><br>  The following example, we get a page using LWP :: UserAgent.  Here is the correct example of how to do this. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> LWP::UserAgent; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> HTML::Entities; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Data::Dumper; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Encode; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Devel::Peek; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $ua = LWP::UserAgent-&gt;new(); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $res = $ua-&gt;get(<span class="hljs-string"><span class="hljs-string">"http://wp.local"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $content; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$res-&gt;is_error) { $content = $res-&gt;content; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">#     UTF8,   cp1251 - $content = decode('cp1251',$content); # decode   utf8  ( )    Perl $content = decode('utf8',$content); #   $content     ,      ,  , , HTML::Entities,    ,    .. decode_entities($content);</span></span></code> </pre><br><br>  Notice the call to $ content = decode ('utf8', $ content). <br><br>  LWP :: UserAgent works with bytes, it does not know, and it is not his concern, in what encoding the page is in single-byte cp1251 or in UTF8, we must explicitly indicate this.  Unfortunately, a lot of literature contains examples in English and for older versions of Perl, as a result, in these examples there is nothing about transcoding. <br><br>  For example, search engine robots (or other code) should not only correctly determine the encoding of pages, not using server response headers or the contents of the HTML meta tag, which can be erroneous, but also determine the page language.  So do not think that all of the above should be done only by Perl programmers. <br><br>  Using the example of obtaining external data from a web site, we have come to consider using the Encode module.  Here is its main API, which is very important in the work of any Perl programmer: <br><br><pre> <code class="perl hljs">$string = decode(ENCODING, OCTETS[, CHECK]).     ()   ENCODING    Perl; $octets = encode(ENCODING, STRING[, CHECK]).      Perl      ENCODING. [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK]).        .</code> </pre><br><br>  In the example in which we opened a text file in CP866, we can omit &lt;: encoding (cp866).  Then, at each read operation, we will receive a set of bytes in CP866.  We can convert them to internal format using <br><br><pre> <code class="perl hljs">$str = decode(<span class="hljs-string"><span class="hljs-string">'cp866'</span></span>,$str)</code> </pre><br><br>  continue to work with the $ str variable. <br><br>  Some may assume that it is possible to use utf8 as the source code of the program, and in addition, recode from cp866 to utf8 and everything will work as it should.  This is not so, consider an example (in the text file the word When with a capital letter). <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> encoding <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Encode; <span class="hljs-comment"><span class="hljs-comment">#open (my $tmp, "&lt;:encoding(cp866)", $ARGV[0]) or die "Error open file - $!"; open (my $tmp, "&lt;", $ARGV[0]) or die "Error open file - $!"; while (&lt;$tmp&gt;) { my $str = $_; Encode::from_to($str,'cp866','utf8'); if ($str=~//i) { print "OK\n"; } } close ($tmp);</span></span></code> </pre><br><br>  $ str after executing Encode :: from_to ($ str, 'cp866', 'utf8') contains data in utf8 but as a sequence of bytes (octets) therefore / i does not work.  For everything to work as you need to add a call <br><br><pre> <code class="perl hljs">$str = decode(<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>,$str)</code> </pre><br><br>  Of course the simpler option is one line instead of two <br><br><pre> <code class="perl hljs">$str = decode(<span class="hljs-string"><span class="hljs-string">'cp866'</span></span>,$str)</code> </pre><br><br>  <b>The internal format of perl strings in more detail.</b>  We have already said that regular expressions, some modules and string functions work correctly with strings that are stored not as a set of bytes, but in the internal representation of Perl.  It was also said that UTF-8 is used as an internal format for storing strings in Perl.  This encoding is chosen for a reason.  Part of the character codes in this encoding from 0-127 coincides with ASCII (US-ASCII), which are exactly responsible for the English alphabet, which is why calling uc for a string with codes from 0 to 127 works correctly and it will work regardless of single-byte encoding in which the source code is stored.  For UTF8, it still works correctly. <br><br>  However, this is not all you need to know. <br><br>  <b>UTF-8 vs utf8 vs UTF8.</b>  The UTF-8 encoding has become more ‚Äústrict‚Äù over time (for example, the presence of certain characters was prohibited).  Therefore, the implementation of UTF-8 in Perl is outdated.  As of Perl 5.8.7, ‚ÄúUTF-8‚Äù means modern ‚Äúdialent‚Äù is more ‚Äústrict‚Äù, whereas ‚Äúutf8‚Äù means more ‚Äúliberal old dialect‚Äù.  Here is a small example. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Encode; <span class="hljs-comment"><span class="hljs-comment">#      UTF-8 my $str = "\x{FDD0}"; $str = encode("UTF-8",$str,1); #  $str = encode("utf8",$str,1); # OK</span></span></code> </pre><br><br>  Thus, the hyphen between ‚ÄúUTF‚Äù and ‚Äú8‚Äù is important; without it, Encode becomes more liberal and possibly overly permissive.  If you run <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Encode; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $str = <span class="hljs-keyword"><span class="hljs-keyword">sprintf</span></span> (<span class="hljs-string"><span class="hljs-string">"%s | %s | %s | %s | %s\n"</span></span>, find_encoding(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>)-&gt;name , find_encoding(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>)-&gt;name , find_encoding(<span class="hljs-string"><span class="hljs-string">"utf_8"</span></span>)-&gt;name , find_encoding(<span class="hljs-string"><span class="hljs-string">"UTF8"</span></span>)-&gt;name , find_encoding(<span class="hljs-string"><span class="hljs-string">"utf8"</span></span>)-&gt;name ); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $str;</code> </pre><br>  We get the following result - utf-8-strict |  utf-8-strict |  utf-8-strict |  utf8 |  utf8. <br><br>  <b>Work with the console.</b>  Consider the Windows OS OS console.  As everyone knows, Windows has the notion of Unicode, ANSI, OEM encoding.  The OS API itself supports 2 types of functions that work with ANSI and Unicode (UTF-16).  ANSI depends on the localization of the OS, for the Russian version the encoding CP1251 is used.  OEM is the encoding used for console I / O, for Russian-language Windows it is CP866.  This is the encoding that was proposed in the Russian-language MS-DOS, and later migrated to Windows for backward compatibility with old software.  That's why, the next program in utf-8 <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Encode; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> encoding <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $str = <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $str;</code> </pre><br><br>  will not print the coveted line, we also output UTF8, when you need CP866.  Here you need to use the Encode :: Locale module.  If you look at its source code, you can see that for Windows it defines the ANSI encoding and the console and creates aliases console_in, console_out, locale, locale_fs.  All that remains to do is to change our program a little. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> warnings; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Encode::Locale; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Encode; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> encoding <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $str = <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-t) { <span class="hljs-keyword"><span class="hljs-keyword">binmode</span></span>(STDIN, <span class="hljs-string"><span class="hljs-string">":encoding(console_in)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">binmode</span></span>(STDOUT, <span class="hljs-string"><span class="hljs-string">":encoding(console_out)"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">binmode</span></span>(STDERR, <span class="hljs-string"><span class="hljs-string">":encoding(console_out)"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $str;</code> </pre><br><br>  PS This article is for those who start working with Perl and maybe it‚Äôs a bit sherehovata.  Ready to listen and realize the wishes regarding the expansion of the article. </div><p>Source: <a href="https://habr.com/ru/post/163439/">https://habr.com/ru/post/163439/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../163429/index.html">All, all, all: time to update your CSS3</a></li>
<li><a href="../163431/index.html">Printer Wars: Epson vs. Epson, or the difference of mentalities</a></li>
<li><a href="../163433/index.html">Earth through the eyes of an asteroid</a></li>
<li><a href="../163435/index.html">Writing a clone game Super Mario Brothers (part 2)</a></li>
<li><a href="../163437/index.html">Unity Web API, or how to integrate your site in Ubuntu</a></li>
<li><a href="../163443/index.html">Introduction to the development of WinRT applications in HTML / JavaScript. From template to data application</a></li>
<li><a href="../163445/index.html">Jetbrains gives 75% discount on all products. 4 more hours!</a></li>
<li><a href="../163451/index.html">What to do if a RAID controller fails?</a></li>
<li><a href="../163465/index.html">Mobile application rewards users for not using the phone while watching a film</a></li>
<li><a href="../163467/index.html">How prone are you to stupid, and a bit holywar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>