<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The internal structure and optimization of the webpack bundle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Webpack has actually become the standard for building large JS applications. Almost everyone uses it. For the developer, the webpack looks like a magi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The internal structure and optimization of the webpack bundle</h1><div class="post__text post__text-html js-mediator-article">  Webpack has actually become the standard for building large JS applications.  Almost everyone uses it.  For the developer, the webpack looks like a magic black box: if you throw files and a small config into it, a bundle will automatically appear at the output. <br><br>  To understand the secrets of this magic, we turned to an expert, a man who repeatedly climbed inside the webpack, Alexey Ivanov.  He is ready to explain what the bundle looks like from the inside, how different settings affect it, what and why some of them can lead to, and also tell how to debug and optimize all this. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jE1ibm037Fo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The material is based on the report by Aleksey Ivanov at the HolyJS 2017 conference, held in St. Petersburg on June 2-3. <br><a name="habracut"></a><br>  In the company of Evil Martians, I am engaged in the service "eBay for business".  eBay puts forward fairly stringent requirements, for example, on how much a site should weigh, the first page, how much it should load.  In order not to go beyond the limits, we regularly look at the contents of our bundles: what goes there and what to do so that no strange person gets there. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To do this, we use various tools: webpack bundle analyzer, webpack runtime analyzer and others.  It looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/658/85b/b7965885bec4f95f6ccc486304d6eb6c.jpg"><br><br>  He is looking for your build.  When you have finished collecting the bundle, it takes the result of the assembly, parses it and shows three beautiful mapy.  And when you do it all the time, you start to notice oddities. <br><br><ul><li>  React in a bundle weighs more than lib / react.js <br></li><li>  Multiple versions of lodash or underscore <br></li><li>  Moment.js loads 100+ locales <br></li><li>  Incomprehensible polyphiles <br></li><li>  Tree shaking does not work <br></li><li>  Changing cache for unchanged chunks <br></li><li>  And so on <br></li></ul><br>  And here it goes like this: it seems you did everything according to the instructions, but something does not work.  And the inspector says that some kind of garbage happened.  What to do in such a situation is actually not very clear. <br><br>  My first idea was to go on the Internet and look for new manuals, new instructions that would tell what is going wrong.  But it turned out that there were thousands of reports about which webpack is good, and there was no information about what a webpack does with your code, how everything is arranged inside it and why it does so and not otherwise. <br><br>  After that I had to conduct a series of experiments: run a webpack with an empty bundle, with one file and empty js, with one import, etc.  And it helped me, I fixed all the problems.  And then I thought that I, probably, was not the only one, and many faced such problems.  And so I decided to share my experience. <br><br><h2>  Content </h2><br><ul><li>  Commonjs <br></li><li>  Resolv file paths <br></li><li>  Bundle device from the inside <br></li><li>  Global constants and DefinePlugin <br></li><li>  UglifyJS dead code elimination <br></li><li>  ES6 modules and tree shaking <br></li><li>  Isolation of chunks and asynchronous loading <br></li><li>  Build Analysis <br></li></ul><br>  Let's start with the CommonJS modules.  CommonJS modules are such a thing when you write require in some files and require or export or module.exports in others. <br><img src="https://habrastorage.org/getpro/habr/post_images/f68/776/8f6/f687768f61f545ddc9fb51593baa8b2f.jpg"><br>  About CommonJS modules, you need to remember the following: they appeared in the node, and when you use a webpack, you actually use not just CommonJS modules, but a piece that allows for compatibility with the node.  In general, CommonJS is required: <br><br><ul><li>  JS-file with variables require, exports, module <br></li><li>  this equals exports <br></li><li>  exports defaults to {} <br></li><li>  In order to use npm-modules in the browser, we need to emulate this behavior in the browser. <br></li></ul><br>  The second obvious thing is that everyone probably knows it, but I‚Äôll still tell you.  What is rezolv ways?  Here we have require (), inside it we write the way we say that we need to re-register.  There are simple options when we write a dash or dash with dots.  And it goes either to the current folder or to the root system, etc.  There are no nuances, everything is simple. <br><br>  Further, if you have not written the extension, it will first try to add the extension js.  If not, it will try to find the folder where index.js is.  If we are talking about node, then it looks for by default not only js, but also JSON, files with the node extension, and more.  In the webpack, all this is not used, so you can forget about it for now.  But this is what everyone knows. <br><br>  The most interesting thing is what happens when we try to import the module.  If we wrote a module, what does node and, accordingly, webpack do?  It goes to the current node folder, searches for the node_modules folder, goes into it and searches for the folder with the name of the module.  If she found her, then she takes her, and then everything is fine. <br><br>  If she did not find her, she goes to the folder one level higher, after that - another level higher, and so on until it reaches the root of the file system.  And here we have the first nuance, which can be well caught.  It looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/bea/9db/e20/bea9dbe20d9795f677eadc27aa366149.jpg"><br>  You put some kind of library from npm, and it says that it needs the lodash 1.0.0 dependency, and you use lodash 5.0.0 in your project.  And so, if this happened, npm will create its node_modules folder and install its own version of lodash.  If there are several such libraries, then each may contain a version of lodash that is not related to everyone else.  If you use node, no problem, but if webpack, then all versions of lodash are loaded into the browser.  These are the basic things that a webpack needs to do to work well. <br><br><h2>  Basic bundle device </h2><br>  The basic bundle device looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/16e/91e/bcd/16e91ebcdfd5031dd793af6c445418b1.jpg"><br>  Here we have a file, and everything seems to be fine there, but there are nuances.  The browser doesn‚Äôt know about require, neither about exports, nor about the module.  He needs to talk about it somehow.  The easiest way is to take the contents of the file, wrap it in a function in which all these things are passed in the parameters, and then at some point execute it.  In fact, the webpack does something like this, but with a slight change. <br><img src="https://habrastorage.org/getpro/habr/post_images/9d8/bc2/8b9/9d8bc28b968c0fa48d1ef2b03297cbb0.jpg"><br>  First change: we change require to __webpack_require__.  Why do you need it? <br><br>  In fact, for two things.  First, so that when you unload yourself with js in an unnatural way, bypassing the webpack, for example, via JSONP or something else, it does not break the build.  Because if a function is created with the name require, then there may be all sorts of bad things, and so there is some protection against this. <br><br>  Secondly, because of the way in the webpack to tag the functions that it is porting inside the bundle.  Accordingly, we can do all sorts of optimizations. <br><br>  I will show it again.  Here we have written path: <br><img src="https://habrastorage.org/getpro/habr/post_images/16e/91e/bcd/16e91ebcdfd5031dd793af6c445418b1.jpg"><br>  Here we have in brackets 0: <br><img src="https://habrastorage.org/getpro/habr/post_images/9d8/bc2/8b9/9d8bc28b968c0fa48d1ef2b03297cbb0.jpg"><br>  Why is that?  Browsers have no file system.  Therefore, when webpack collects modules into one file, it actually puts them into an array.  The number in parentheses is the default index in this array.  This will affect us in the future.  Why an array?  Because in comparison with any objects with keys it is the most compact option and it will weigh the least. <br><br>  That is, came webpack, wrapped all the modules in a function, put all the functions in an array of modules and added an anonymous function to the beginning that loads it all. <br><img src="https://habrastorage.org/getpro/habr/post_images/b5e/c21/7d4/b5ec217d4dd8c7941db19e348b1c6526.jpg"><br>  The first line that is important to us is installedModules.  That is, when the webpack loads an array, it does not initialize what is in it, automatically - it continues to lie in the array with dead code. <br><br>  At the moment when you recover the first file, the webpack creates an instance of this file, which somehow can continue to live, and everything is further stored in it and is more or less supported. <br><br>  Next we have a function __ webpack_require __, which we will pass inside.  And there is such a root place that calls your file, and you start building your root bandl.  That is, we loaded everything into an array, called the function, declared the function __webpack_require__, and called the root file. <br><br><h2>  What makes __webpack_require__ </h2><br><ol><li>  Searches for the initiated module in the cache. <br></li><li>  Creates a stub and adds it to the array. <br></li><li>  Executes module code with this equal to module.exports <br></li><li>  Returns module.exports <br></li></ol><br>  How exactly does __webpack_require__ work, what does it even do?  Again, as I have already said, we are looking to see if we have a cache in the module.  If not, go ahead, and if there is, return from it.  Further, if not, we create a stub and add it to the array.  The stub looks like this: <br><img src="https://habrastorage.org/webt/oj/dg/cj/ojdgcj1-voosc1qz8jmd1qc2nle.png"><br>  We have IDs (mostly numbers, but sometimes not) and the exports function.  By default, it puts an empty object, so when we call this thing inside the webpack module, by default it will be an empty object there. <br><br>  Next comes the following.  We take our code and call what we had in the array, like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/dec/aba/909/decaba90902e0f9c1d953a6580a37d69.jpg"><br>  That is, we call not just a function, namely via call, so that exports also get into the first object.  This is for backward compatibility with the node.  The result is approximately the following: <br><img src="https://habrastorage.org/webt/dj/2v/af/dj2vafb4vnrfhl-ztkqgxgfel6q.png"><br>  From this point on, our module, which lives in installedModules, has no longer an exports object, but what we assigned and returned to it.  Why is this interesting and important?  Because, since we are doing everything in this way, we have one working instance of our module in the bundle, and we can use it as a closure. <br><br>  That is, if we declare a variable in the module, it will be common to all instances.  If we export to exports some method that allows, for example, to increment this variable inside the closure, then this variable will also be available inside.  If you declare a library here and assign some plugins to it, the instance libraries with all the plugins will also be shared.  Accordingly, with this piece you can share information with all modules and do other interesting things. <br><br>  After we have all initialized, created an instance of the module, we return what is inside the exports, and calm down on this. <br><br>  In fact, if we were talking about CommonJS and the simplest bundle, then we could end it, because in the simplest version of the webpack, it does nothing more.  In practice, the webpack has become popular not because of the fact that he knows how to do it this way, but because of the fact that he knows how to do more complex things.  For example, he can do this: <br><img src="https://habrastorage.org/getpro/habr/post_images/5b5/188/622/5b51886227c092b5eabb246133f5b930.jpg"><br>  That is, when you specify in require not the full path of the file, but some regular one, the webpack will be able to collect it.  At the same time, since he is not engaged in analyzing the code live, he cannot know what is actually being used, and just in case drags everything that can be there.  So how does it all work?  Webpack in this case will create a new module in the array, in which it will write the logic about the resolve paths. <br><img src="https://habrastorage.org/webt/xa/2d/6s/xa2d6swbxjuoiv0w2fbce-dj4jc.png"><br>  Inside the module itself lives a map that describes all possible paths.  That is, if you have 20 files, then he will put everything here and make 40 name choices, if you specify, for example, with js or without js.  Next, it will make a function that will carry out the evolution of the expression passed into the function, and compare what is in the array.  If she finds a match, she will return the body, if not, throw an error.  In this place, too, there may be a problem.  I think many have come across it. <br><img src="https://habrastorage.org/getpro/habr/post_images/851/cd8/3c4/851cd83c40375aeb1a7da27cb6b2083a.jpg"><br>  The problem is as follows.  We have a library of moment.js, which allows you to perform various operations with dates.  When you use it through node, there is a small nuance.  Inside the root file of moment.js there is a line of require ('./ locale /' + name).  Accordingly, the webpack goes inside the locale folder, finds 118 locales there, loads them all into a bundle and creates a map of about 250 keys.  Probably, this is not exactly what I would like to see. <br><br>  For webpack, there is a ContextReplacementPlugin.  He checks the first part of the mask.  If the mask matches what is written in the first argument, instead of returning what it found in the file system, it returns what you passed to it with the second parameter. <br><br><h2>  Global constants and DefinePlugin </h2><br><img src="https://habrastorage.org/webt/3j/vm/u2/3jvmu2yknv2s48lz5lgpm2wp_c0.png"><br>  We have a bundle, it's all good.  It connects files, resolves paths, and so on.  Sometimes we need to make sure that he does not live on the basis of the data that we have, but receive some information outside. <br><br>  Suppose you have dev and production versions that have a different path, and you want the webpack to work with dev to work with one path and during production with another.  Or there are different version numbers.  Another use case that is used in many libraries is the task process.env.NODE_ENV.  This variable is a kind of common template that says that these functions should not be used in development mode, and, for example, functions for debugging - in production mode. <br><br>  The question arises, how do we transfer these variables?  There is a DefinePlugin where you can declare these variables and, therefore, they will fall inside the bundle. <br><img src="https://habrastorage.org/getpro/habr/post_images/322/c37/64f/322c3764f8eeed73ac54c7f1e125143b.jpg"><br>  DefinePlugin takes the line to the left, in our case it is VERSION, then takes the line to the right, goes to the file, and the regular replaces the old line with the new one.  As a result, the result looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/fba/389/4fe/fba3894fea465582aad3306b57759f07.jpg"><br>  JSON.stringify adds quotes.  If there were no quotes, we would have just the number 1.0.1 and everything would be broken.  What happened here?  If, after replacing any string or number, the webpack can understand that this is an if condition, and it understands that the left side is compared with the right side and both are constants, then it replaces them with true or false.  This happens so that UglifyPlugin can come in and tidy up. <br><br>  The second interesting thing: as you can see, require has remained require.  It has not been replaced by __webpack_require__.  Accordingly, require does not hit the bundle and will not be in the build.  If you want to disable some of the functionality, here is one way to do it.  But, as elsewhere, there are nuances.  The problem looks like this: <br><img src="https://habrastorage.org/webt/u0/w0/hb/u0w0hbxbwn6k1btkpu1sy9csmna.png"><br>  If you want to be fashionable and use, for example, babel, and it has destructuring, then you can write NODE_ENV.  Unfortunately, it all breaks down.  But why?  This is how the code looks after the conversion: <br><img src="https://habrastorage.org/getpro/habr/post_images/dbd/255/326/dbd255326127b051b854abf9c5e5991f.jpg"><br>  That is, one variable refers to the second, which also something comes.  And inside your condition will look like this: NODE_ENV! == "production". <br><br>  In fact, if you roll out this code in production, everything will work as you would like.  Because the variable comes false, and what is inside the if will not be executed.  But since the webpack does not know what variables are and it does not do a complete analysis of the code and does not find out what it will be in this variable, it cannot understand that what is inside does not need to be loaded.  In this situation, the module, which is inside and should not be loaded, will actually load. <br><br>  Therefore, once again, if you use DefinePlugin, be sure to use string replacement, i.e.  full line is replaced with the full line, no abbreviations. <br><br><h2>  What happens if process.env is replaced? </h2><br>  Webpack tries to emulate a node, because most of the modules that are in the node_modules folder can be purely node.  The standard variable in node is process.  Therefore, when you do not specify process.env, and some of the libraries, which in the import, use process.env or simply process, the webpack thinks that this is a node module and adds a polyfil.  As a result, not only did the code not decrease, so the polyfil was also added.  That is, any variable that is by default inside node, if it is used in your file and is not replaced or declared, will be replaced with a polyfile when building a webpack. <br><br>  <b>Debugging Functions in Libraries</b> <b><br><br></b>  <b>Redux</b> <b><br><br></b>  <b>...</b> <b><br><br></b> <br>  If you do not add a process for React, Redux, etc., there will be many polifilov. <br><br><h2>  Code compression </h2><br>  What does Uglify do with all of our code? <br><br>  <b>UglifyPlugin</b> <br><br><ul><li>  Removes spaces <br></li><li>  Renames variables with short names <br></li><li>  Does dead code elimination <br></li></ul><br>  First, UglifyPlugin comes in and removes unnecessary spaces, hyphens, replaces long variable names with short ones, but does so within the function. <br><img src="https://habrastorage.org/webt/uu/ta/0h/uuta0hicoqedi6ynsznq88yjeoi.png"><br><img src="https://habrastorage.org/webt/ub/fh/bb/ubfhbb4ezid0ck-l_zmuqlr2xtw.png"><br>  But if variables are declared outside the function, globally, other functions have access to them.  So when we give up such a code as Uglify, <br><img src="https://habrastorage.org/webt/wg/q3/vs/wgq3vsfjv6ug-f0iqodrnncx700.png"><br><img src="https://habrastorage.org/webt/sb/rl/qx/sbrlqxl48rz4rldjwxwjuck4mla.png"><br>  then all variables will remain.  Now we come to the most interesting, to our true and false. <br><img src="https://habrastorage.org/getpro/habr/post_images/7e8/263/2b4/7e82632b4977da2f70fbfdb1a617406e.jpg"><br>  What's going on here?  In some way, we have made a value inside the condition that has become a constant and is guaranteed not to change.  When Uglify comes here and sees this, it will leave like this: <br><img src="https://habrastorage.org/webt/ze/5r/18/ze5r18u7hvzewfmdzfghdohjbxw.png"><br>  If a variable lives in a condition that is not static, Uglify will not be able to understand what is happening and will not delete anything. <br><img src="https://habrastorage.org/webt/bm/kl/g1/bmklg1ag-1exxigoe_vvex-at20.png"><br>  Therefore, even if you declared a variable before a condition and indicated that it is false, and immediately after it comes an if, then Uglify will still not parse the code.  All this code will eventually remain. <br><img src="https://habrastorage.org/webt/lm/ad/0e/lmad0edmxg4kaqv9qiulvu9-usi.png"><br><h2>  ES6 modules </h2><br><img src="https://habrastorage.org/webt/ck/zb/oh/ckzboh9vtemy9k_x86mtvy6zenm.png"><br>  Nothing more global happens.  The difference between import and export is about the following.  First, the keys in import and export are necessarily immutable, i.e.  we cannot assemble them from parts, they must always be constant.  Secondly, import and export should live in the upper scope. <br><br>  What is the joy of using import and export?  It looks like this: <br><br><h2>  Tree shaking </h2><br>  In theory, a webpack can determine exactly what is used in our application, and tag them accordingly.  In practice, everything is somewhat more complicated. <br><br>  One of the main features that is in the webpack 2 is an understanding of import and the ability to do Tree shaking.  It would be great if everything worked, but there is a problem. <br><img src="https://habrastorage.org/webt/bz/gl/mr/bzglmr6qkjtj42fb4ys-y4rd4sq.png"><br>  In fact, the fact that export is not used does not mean that the code will not be executed and it will not have side effects.  If the code has side effects, there is a chance of breaking something. <br><br>  Webpack is very concerned about backward compatibility.  Therefore, he tries to make sure that no deletion breaks the builds.  Therefore, he does the following: <br><img src="https://habrastorage.org/getpro/habr/post_images/a2f/fa8/efe/a2ffa8efea99a62cafa34e233e5f04f1.jpg"><br>  What happens after the webpack reads this?  First, the place it imports transforms into a CommonJS module. <br><img src="https://habrastorage.org/webt/ez/cx/oq/ezcxoqo13nfcwl01dvityfvur0w.png"><br>  It's more interesting here.  What happens in the file from which export left?  First, the export was removed before the word const.  Secondly, for the constant that is exported, we manually wrote __webpack_exports__ with some kind of key.  And everything seems to be good.  When Uglify comes here and sees an unused constant 2, it deletes it. <br><img src="https://habrastorage.org/getpro/habr/post_images/f52/493/1cc/f524931cc251b6252729a677a3fe3ce4.jpg"><br>  But there are nuances. <br><img src="https://habrastorage.org/getpro/habr/post_images/083/254/d51/083254d5162cfe2c97fa8ae3dc286042.jpg"><br>  If one of the exports used a variable that was previously imported from some import, then in this place the webpack and Uglify will not delete anything.  More precisely, the const method will be deleted, and the import will remain and its contents will also be added to the bundle.  Why?  Firstly, because the webpack does not know whether it will be used or not, whether there are side effects or not, so he left it.  Secondly, the module is used, so he left it too.  After that Uglify came to us, saw the method and deleted it, and left the import, because it is actually a call from the array, there may be side effects and in fact Uglify does not know anything about it.  Therefore, it will leave this variable, and it will live inside the array. <br><br>  For example, we decided to use lodash-es, which is written with import and export.  We import a method from it and hope that everything else will not fall, but in fact it will not work. <br><img src="https://habrastorage.org/getpro/habr/post_images/a53/4ee/adb/a534eeadb77e234a68f9921b6e1063c1.jpg"><br>  In the line where from, we have imported all the modules that are in lodash, and now they will all get into your bundle.  Here from this problem not to leave.  You need to use some kind of babel plugin that will replace lodash with specific methods, or manually write down everything you need up to the method. <br><br>  And another very important thing: by default, if you use babel with default settings, then it actually transports all your beautiful imports and exports to the usual require.  Therefore, if you have a babel with default settings, then you will not get any imports inside the webpack, but only the old require will be.  Accordingly, if you want them to work, you need to replace transpiling in import and export in babel. <br><br><h2>  Chunky </h2><br>  A chunk is a piece of code that can be loaded synchronously or asynchronously.  In order to load a chunk, it is necessary to slightly correct the code that is engaged in initialization.  It is edited something like this - the window [‚ÄúwebpackJsonp‚Äù] function is added. <br><br>  <b>Chunky</b> <br><ul><li>  Synchronous and asynchronous <br></li><li>  The function window [‚ÄúwebpackJsonp‚Äù] is added to the first file <br></li><li>  In the following files, the webpackJsonp function is called with a list of modules and id modules to run <br></li><li>  All modules fall into a common array and are used from there. <br></li></ul><br>  We have some file that is first loaded synchronously, you add it to the header.  A function has been added to this file.  All other files consist of a call to this function, to the input of which comes an object in which there is, for example, an id of a chunk, a list of modules, etc. <br><img src="https://habrastorage.org/webt/ve/ju/sv/vejusv-rocfh5uis_iakbdmevyu.png"><br>  Further, after we have loaded all this, the webpack takes the loaded modules and simply adds the necessary indexes to the initial array.  Nothing else happens, we continue to use the first array. <br><br>  With synchronous chunks, everything is simple.  We have two files: first we uploaded a file in which there is a load code, then after it we added another file in which we load the next piece of modules.  Here it is necessary to understand: if we load it like this, then the order is important for us and, accordingly, we cannot add asynchronous loadings or carry out parallel loading, because the second function will be executed, will not find anything and will break everything. <br><br>  Asynchronous chunks work the same way.  There is only one nuance.  We need to load them not at the time of loading the page, but as a separate request by adding a script tag to the header on the fly.  In code, it looks like this: <br><img src="https://habrastorage.org/webt/md/tg/nw/mdtgnwhfewjmfzowo3hhoaycyxu.png"><br>  We have an import function in which we prescribe what we want to import, and then it returns us promises.  And when it is ready, it returns us an error or sends what we downloaded.  In transpiled form, it looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/603/9f0/274/6039f027491bbe08b3e91fa12a097e1e.jpg"><br>  We add a function __webpack_require __. E, which asynchronously loads other files.  In it, one moment is important to us, which looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/49c/359/9e8/49c3599e82e4d43152fc0be146b89325.jpg"><br>  If we had chunks called numbers, then nothing terrible would have happened.  We would give the numbers there, and everything would be fine.  But in order to use the cache or it is more convenient to deal with it, we usually name them or add some tricky line to the url so that this url is unique.  When the webpack needs to load this file, it needs to know the name. <br><br>  Accordingly, all the names of all the chunks as objects are always stored inside the first file.  And every time we change a chunk, its hash and name change - and this part of the code is also generated. <br><br><h2>  CoomonsChunkPlugin </h2><br>  Actually, how are chunks created?  The easiest way is using CommonChunkPlugin. <br><img src="https://habrastorage.org/webt/cv/rt/ye/cvrtye8209kpicu1r4zvhfuxmdm.png"><br>  It works very simple.  We add a plugin, telling him that ‚ÄúminChunks: 2‚Äù means that if a common plugin is used in two chunks, then let's create a separate chunk that will load synchronously, and the common part will be in it.  But at the same time there are a couple of nuances. <br><br>  The first caveat is when we wrote like this, and we have chunks that are created through import, it will not work with them, since these chunks are considered children, and they have a separate logic. <br><img src="https://habrastorage.org/getpro/habr/post_images/158/6d5/363/1586d53639f4bbd8c2450be9ebb55236.jpg"><br>  For example, you work with React and, so that you have not five copies, but one, you need to add children: true, then it will take out a common module from children. <br><br>  The second caveat: when we have a code that takes everything in the node_modules folder and puts it in a separate chunk.  What is the logic here?  We rarely update modules, we have them in a separate file, and we want to cache them.  We change our code often, we want to cache it separately, and it is necessary that only it is updated, and not all anew.  So the most part will become like a constant and will not be loaded every time, and a smaller part will be updated. <br><img src="https://habrastorage.org/getpro/habr/post_images/51f/481/e5b/51f481e5b28d318a29ac18ce7e527bfc.jpg"><br>  This code allows us to do this.  But with him there is one nuance.  He does not work. <br><br><h2>  Variable indices </h2><br>  The example with node_modules does not work for the cache: <br><br><ol><li>  When adding files, indexes change <br></li><li>  The boot and initialization code lives in the first file: <br></li></ol><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> starting index changes </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> links to chunks are changing </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It does not work for two reasons. </font><font style="vertical-align: inherit;">The first looks like this: </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/90e/a42/a21/90ea42a2105ab7160db0d856bb571ac7.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the __webpack_require__ index is not always the first. </font><font style="vertical-align: inherit;">There may be another, random index from the array. </font><font style="vertical-align: inherit;">Accordingly, if you delete or add a file, the index of the first object may change. </font><font style="vertical-align: inherit;">The code of the first chunk changes always and, accordingly, its hash changes, the sum and everything else. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second problem: in order to load chunks asynchronously, a map of their names is necessary. </font><font style="vertical-align: inherit;">Accordingly, if the contents of any chunk changes, then the map that is needed to load them also changes. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/1d6/b72/ed7/1d6b72ed7170710c4f03cf98a9523949.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first file where the webpack function lives, which loads all of this, is guaranteed to change always with every change of any file. </font><font style="vertical-align: inherit;">What to do with it?</font></font><br><img src="https://habrastorage.org/webt/ol/mn/e9/olmne9ttsv5tcrwqc0d4ud_n2mu.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two things need to be done. First, fix the file names. For this webpack has two built-in plugins. The first allows you to keep the names that you used earlier inside the webpack, but this is not very convenient for production, as the names become very long. The second allows you to change names to four-letter hashes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, it is necessary that the part of the code that is responsible for loading new modules and chunks be taken out in a separate chunk. Accordingly, it can be done something like this: </font></font><br><img src="https://habrastorage.org/webt/gp/to/mr/gptomrsyoflrhhzste6i7olzqoe.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here ‚ÄúminChunks: Infinity‚Äù means that there will be only a download code and 0 of its chunks. Accordingly, you will get not two files, but three: the first with the download code, the second with node_modules, the third with your code. Of course, the code will be more, but caching will work.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is how you can connect two plugins in a row: </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/3db/232/71e/3db23271e5a7f8376d2a571ab14fc246.jpg"><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bundle analysis </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two useful plugins for analyzing the bundle: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">webpack-bundle-analyzer</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Build a treemap bundle. </font><font style="vertical-align: inherit;">It is convenient to check if you got into the bundle:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Two versions of the same library </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Copies of the library in different chunks </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Libraries that were supposed to be cut by condition </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unexpected dependencies on libraries </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Just big files </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the second, more convenient plugin: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">webpack-runtime-analyzer</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shows the relationship between the files in the graph - who is referenced by whom, who is added to the assembly. </font><font style="vertical-align: inherit;">Convenient to use to understand:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Who exactly is using the file </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Who exactly connected the library </font></font><br></li></ul><br><h2>  Total </h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Make an empty bundle and look at the contents, there are 40 lines </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Do not be afraid to go to the source and watch what happened in the code </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After adding libraries, always launch a gang analyzer and see what it brought with it </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After adding chunks, check their contents. </font></font><br></li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you like JS just as we do, and with pleasure delve into all its interior, you may be interested in these reports at our December conference </font></font><a href="https://holyjs-moscow.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HolyJS 2017 Moscow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li> <a href="https://holyjs-moscow.ru/talks/6f57ymvefsmu0cweciwc4a/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Better, faster, stronger - getting more from the web platform</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Martin Splitt, Archilogic)</font></font><br></li><li> <a href="https://holyjs-moscow.ru/talks/gq7yrvvfgocsckyq68kok/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Post JavaScript Apocalypse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Douglas Crockford)</font></font><br></li><li> <a href="https://holyjs-moscow.ru/talks/5hfhepewii0iesi46gmgou/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing serverless applications</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Slobodan Stojanovic, Cloud Horizon)</font></font><br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/342842/">https://habr.com/ru/post/342842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342830/index.html">How the leaders of the storage industry gathered at Prostor in Skolkovo (photo report)</a></li>
<li><a href="../342832/index.html">Avito iOS Meetup: Winter Edition</a></li>
<li><a href="../342834/index.html">PKCS # 11 Cryptographic Tokens: Managing and Accessing Token Objects (Continued)</a></li>
<li><a href="../342838/index.html">Sparse columns or sparse columns in MS SQL Server. Real experience</a></li>
<li><a href="../342840/index.html">Performance in all senses: how did DotNext 2017 Moscow go</a></li>
<li><a href="../342846/index.html">ENOG'14 - the impact of content locks on the Internet infrastructure</a></li>
<li><a href="../342848/index.html">Using SVG as a Placeholder</a></li>
<li><a href="../342850/index.html">RxPM - reactive implementation of the Presentation Model pattern</a></li>
<li><a href="../342852/index.html">LiveXAML is a useful tool for Xamarin developer</a></li>
<li><a href="../342860/index.html">Startup history ROI4CIO: Is it possible to automate the sale of IT solutions in the B2B sector and not only?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>