<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What does unsafe mean in Rust?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to you the translation of the article "What Is Rust's unsafe?" by Nora Codes. 


 I have seen many misunderstandings about what th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What does unsafe mean in Rust?</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, Habr!  I present to you the translation of the article "What Is Rust's unsafe?"  by Nora Codes. </p><br><p>  I have seen many misunderstandings about what the unsafe keyword means for the usefulness and correctness of the Rust language and its promotion as a "safe system programming language."  The truth is much more complicated than can be described in a short tweet, unfortunately.  Here is how I see her. </p><br><p>  In general, the <strong>unsafe keyword does not turn off the type system that supports the Rust code is correct</strong> .  It only allows you to use some "superpowers", such as pointer dereferencing.  unsafe is used to implement secure abstractions based on the fundamentally unsafe world so that most of the code on Rust can use these abstractions and avoid unsafe memory access. <a name="habracut"></a></p><br><h1 id="garantiya-bezopasnosti">  Safety guarantee </h1><br><p>  Rust guarantees safety as one of its main principles.  We can say that this is the <em>meaning of the existence of</em> language.  It does not, however, provide security in the traditional sense, during program execution and using the garbage collector.  Instead, Rust uses a very advanced type system to keep track of when and to what values ‚Äã‚Äãyou can access.  Then the compiler statically analyzes each program on Rust to make sure that it is always in the correct state. </p><br><h2 id="bezopasnost-v-python">  Python Security </h2><br><p>  Let's take for example Python.  Clean Python code cannot corrupt memory.  Access to list items has checks to go beyond the boundaries;  links returned by functions are counted to avoid hanging links;  There is no way to perform arbitrary pointer arithmetic. </p><br><p>  This has two implications.  First, many types must be "special."  For example, it is not possible to implement an efficient list or dictionary in pure Python.  Instead, the CPython interpreter has an internal implementation.  Secondly, access to external functions (functions implemented not in Python), called the interface of an external function, requires the use of a special ctypes module and violates the security guarantees of the language. </p><br><p>  In a sense, this means that everything written in Python does not guarantee secure memory access. </p><br><h2 id="bezopasnost-v-rust">  Rust Security </h2><br><p>  Rust also provides security, but instead of implementing unsafe C structures, it provides a trick: the unsafe keyword.  This means that the fundamental data structures in Rust, such as Vec, VecDeque, BTreeMap and String, are implemented in Rust. </p><br><p>  You will ask: "But, if Rust provides a trick against its security guarantees of the code, and the standard library is implemented using this trick, wouldn't everything be considered unsafe in Rust?" </p><br><p>  In a word, dear reader, - <strong>yes</strong> , exactly as it was in Python.  Let's break it down. </p><br><h1 id="chto-zaprescheno-v-bezopasnom-rust">  What is prohibited in safe Rust? </h1><br><p>  Rust security is well defined: we think a lot about it.  In short, safe programs on Rust cannot: </p><br><ul><li>  <strong>To dereference a pointer pointing to a type other than the one the compiler knows about</strong> .  This means that there are no null pointers (because they don‚Äôt point to anywhere), no overrun errors and / or segmentation faults, no buffer overflows.  But it also means that there is no use after freeing memory or re-freeing memory (because freeing memory is considered a pointer dereference) and no <a href="https://en.wikipedia.org/wiki/Type_punning">pun-typing</a> . </li><li>  <strong>Have multiple mutable references to an object or simultaneously mutable and immutable references to an object</strong> .  That is, if you have a changeable link to an object, you can only have it, and if you have an immutable link to an object, it will not change as long as you keep it.  This means that it is impossible to cause a data race in a safe Rust, which is a guarantee that most other safe languages ‚Äã‚Äãcannot provide. </li></ul><br><p>  Rust encodes this information in a type system or using <strong>algebraic data types</strong> , such as Option to indicate the existence / absence of a value and Result &lt;T, E&gt; to indicate an error / success, or <strong>reference and their lifetime</strong> , for example, &amp; T vs &amp; mut T to denote common (immutable) link and exclusive (mutable) link and &amp; 'a T vs &amp;' b T to distinguish between links that are valid in different contexts (this is usually omitted because the compiler is smart enough to understand it) . <br></p><br><h2 id="primery">  Examples </h2><br><p>  For example, the following code will not compile because it contains a hanging link.  More specifically, <em>my_struct does not live enough</em> .  In other words, the function will return a reference to something that no longer exists, and therefore the compiler cannot (and, in fact, does not even know how) compile it. </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;MyStruct { <span class="hljs-comment"><span class="hljs-comment">//     MyStruct   ,  v,   . let my_struct = MyStruct { value: v }; //      my_struct. return &amp;my_struct; //  - my_struct  (  ). }</span></span></code> </pre> <br><p>  This code does the same thing, but it tries to get around this problem by placing the value on the heap (Box is the name of the basic smart pointer in Rust). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_heap_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-comment"><span class="hljs-comment">//    Box         . let my_box = Box::new(my_struct); //      my_box. return &amp;my_box; // my_box   .   "" my_struct       - , //    - MyStruct  . }</span></span></code> </pre> <br><p>  The correct code returns Box itself instead of a link to it.  This encodes a movement of ownership ‚Äî responsibility for freeing memory ‚Äî in the function signature.  When looking at the signature it becomes clear that the calling code is responsible for what happens to Box, and, indeed, the compiler handles this automatically. <br></p><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//    my_box  . return my_box; //    .         , //    ;       //  Box&lt;MyStruct&gt;       ,      . }</span></span></code> </pre> <br><blockquote>  Some bad things are not forbidden in a safe Rust.  For example, allowed from the point of view of the compiler: <br><ul><li>  call deadlock in the program </li><li>  leak arbitrarily large memory </li><li>  failing to close file handles, database connections or rocket covers </li></ul><br><br>  The strength of the Rust ecosystem lies in the fact that many projects choose to use the type system to ensure the correctness of the code to the maximum, but the compiler does not require such coercion, except in cases of ensuring secure memory access. </blockquote><br><h1 id="chto-razresheno-v-nebezopasnom-rust">  What is allowed in an insecure Rust? </h1><br><p>  Insecure Rust code is Rust code with the unsafe keyword.  unsafe can be applied to a function or code block.  When it is applied to a function, it means "this function requires that the called code manually provide an invariant, which is usually provided by the compiler."  When applied to a block of code, it means "this block of code manually provides the invariant necessary to prevent unsafe memory access, and therefore it is allowed to do unsafe things." </p><br><p>  <strong>In other words, the function unsafe means "you have to check everything", and on the code block - "I have already checked everything."</strong> </p><br><p>  As noted in <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">The Rust Programming Language</a> , the code in the block marked with the unsafe keyword can: </p><br><ul><li>  <strong>Dereference pointer.</strong>  This is a key "superpower" that allows you to implement doubly linked lists, hashmap, and other fundamental data structures. </li><li>  <strong>Call an unsafe function or method.</strong>  More about this below. </li><li>  <strong>Access or modify a static variable to be modified.</strong>  Static variables whose scope is not controlled cannot be statically checked, so their use is unsafe. </li><li>  <strong>Implement unsafe type (trait).</strong>  Unsafe types are used to mark whether particular types guarantee certain invariants.  For example, Send and Sync determine whether a type can be sent between stream boundaries or be used by several threads simultaneously. </li></ul><br><p>  Remember those examples with trailing pointers above?  Add the word unsafe, and the compiler will swear twice as much, because it doesn‚Äôt like to use unsafe where it‚Äôs not needed. </p><br><p>  Instead, the unsafe keyword is used to implement safe abstractions based on arbitrary pointer operations.  For example, the Vec type is implemented using unsafe, but it is safe to use, since it checks for attempts to gain access to the elements and does not allow overflow.  Although it provides operations like set_len, which <em>can</em> cause memory access insecurity, they are marked as unsafe. </p><br><p>  For example, we could do the same thing as in the no_dangling_reference example, but with unreasonable use of unsafe: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manual_heap_reference</span></span></span></span>(v: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> MyStruct { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//  Box    . let struct_pointer = Box::into_raw(my_box); return struct_pointer; //   ;     . // MyStruct     . }</span></span></code> </pre> <br><p>  Notice the absence of the word unsafe.  Creating pointers is absolutely safe.  As it was written, this is a risk of memory leaks, but nothing more, and memory leaks are safe.  Calling this function is also safe.  unsafe is required only when something tries to <strong>dereference a</strong> pointer.  As an added bonus dereference will automatically release the allocated memory. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">//  "Value: 1337" println!("Value: {}", my_boxed_struct.value); // my_boxed_struct    .       ,  //    - MyStruct }</span></span></code> </pre> <br><p>  After optimization, this code is equivalent to simply returning the Box.  Box is a safe pointer-based abstraction because it prevents the distribution of pointers everywhere.  For example, the next version of main <strong>will lead</strong> to double freeing of memory (double-free). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct_1 = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">// DOUBLE FREE BUG! let my_boxed_struct_2 = unsafe { Box::from_raw(my_pointer) }; //  "Value: 1337" . println!("Value: {}", my_boxed_struct_1.value); println!("Value: {}", my_boxed_struct_2.value); // my_boxed_struct_2    .     ,  //    - MyStruct. //  my_boxed_struct_1    .      , //      - MyStruct.  double-free bug. }</span></span></code> </pre> <br><h2 id="tak-chto-takoe-bezopasnaya-abstrakciya">  So what is a safe abstraction? </h2><br><p>  Secure abstraction is an abstraction that uses a type system to provide an API that cannot be used to violate the security assurances mentioned above.  Box is safer than * mut T, since it cannot lead to the double freeing of memory, illustrated above. </p><br><p>  Another example is the Rc type in Rust.  This is a reference counting pointer ‚Äî a non-editable link to data located on the heap.  Since it allows multiple simultaneous access to a single memory area, it <em>must</em> prevent change in order to be considered safe. </p><br><p>  In addition to this, it is not thread safe.  If you need thread safety, you have to use the Arc type (Atomic Reference Counting), which has a performance penalty due to the use of atomic values ‚Äã‚Äãto count the references and prevent possible data races in multi-threaded environments. </p><br><p>  The compiler will not allow you to use Rc where you need to use Arc, because the creators of the type Rc did not mark it as thread-safe.  If they did, it would be unfounded: a false promise of security. </p><br><h2 id="kogda-neobhodim-nebezopasnyy-rust">  When is an insecure Rust needed? </h2><br><p>  Unsafe Rust is always needed when you need to perform an operation that violates one of those two rules described above.  For example, in a doubly linked list, the absence of changeable references to the same data (for the next element and the previous element) completely deprives it of its usefulness.  With unsafe, a doubly linked list implementer can write code using * mut Node pointers and then encapsulate it into a safe abstraction. <br></p><p>  Another example is working with embedded systems.  Often, microcontrollers use a set of registers whose values ‚Äã‚Äãare determined by the physical state of the device.  The world cannot stop until you take &amp; mut u8 from such a register, so you need unsafe to work with device support kraits.  As a rule, such cracks encapsulate the state in transparent secure wrappers that copy data as much as possible, or use other techniques that provide guarantees to the compiler. </p><br><p>  Sometimes it is necessary to conduct an operation that can lead to simultaneous reading and writing, or unsafe memory access, and this is where unsafe is needed.  But as long as it is possible to make sure that the safe invariants are maintained before the user of the safe (that is, unsafe marked code) touches something, everything is fine. </p><br><h1 id="na-chih-plechah-lezhit-eta-otvetstvennost">  On whose shoulders does this responsibility lie? </h1><br><p>  We arrive at the statement made earlier - <strong>yes</strong> , the usefulness of the code on Rust is based on unsafe code.  Although this is done somewhat differently than the unsafe implementation of the underlying data structures in Python, the implementation of Vec, Hashmap, etc., <strong>should</strong> use pointer manipulations to any degree. </p><br><p>  We say that Rust is safe, with the fundamental assumption that the unsafe code that we use through our dependencies either on the standard library or on the code of other libraries is correctly written and encapsulated.  The fundamental advantage of Rust is that unsafe code is driven into unsafe blocks, which must be carefully checked by their authors. </p><br><p>  In Python, the burden of checking the security of memory manipulation rests solely with the developers of interpreters and users of external function interfaces.  In C, this burden is on every programmer. </p><br><p>  In Rust, it lies with the users of the unsafe keyword.  This is obvious, since within such a code, invariants must be maintained manually, and therefore it is necessary to strive for the smallest amount of such code in a library or application code.  Insecurity is detected, highlighted and indicated.  Therefore, if segfaults occur in your Rust code, then you have found either an error in the compiler, or an error in several lines of your unsafe code. </p><br><p>  This is not a perfect system, but if you need speed, security and multithreading at the same time, then this is the only option. </p><p></p><p></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/460295/">https://habr.com/ru/post/460295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../46028/index.html">How not to make a login form in the Internet bank</a></li>
<li><a href="../460281/index.html">How a UX writer helps improve a product</a></li>
<li><a href="../460283/index.html">A new programming language with your own hands and head</a></li>
<li><a href="../46029/index.html">A small feature of window.open in Internet Explorer</a></li>
<li><a href="../460291/index.html">Problems of batch request processing and their solution (part 1)</a></li>
<li><a href="../460297/index.html">WeakRef - proposal for adding to ECMAScript standard</a></li>
<li><a href="../4603/index.html">For the virtual "Sotovik" the real battle began</a></li>
<li><a href="../460301/index.html">Powerful new generation LED lamps</a></li>
<li><a href="../460305/index.html">AERODISK Engine: Disaster. Part 2. Metroklaster</a></li>
<li><a href="../460307/index.html">Experience modeling from the team Computer Vision Mail.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>