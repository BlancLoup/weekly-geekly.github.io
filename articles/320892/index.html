<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing untestable JS with Babel and snarejs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of developing modern JS applications, a special place is given to testing. Test Coverage today is almost the main quality metric of JS ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing untestable JS with Babel and snarejs</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88f/284/6c9/88f2846c9d2a673f30855570aec43b68.jpg" alt="image"></div><br>  In the process of developing modern JS applications, a special place is given to testing.  Test Coverage today is almost the main quality metric of JS code. <br><br>  Recently, a huge number of frameworks that solve testing problems have appeared: jest, mocha, sinon, chai, jasmine, the list can be continued for a long time, but even with such freedom to choose tools for writing tests, there are cases that are difficult to test. <br><br>  How to test what may be untestable in general will be discussed further. <br><a name="habracut"></a><br><h3>  Problem </h3><br>  Take a look at a simple module for working with blog posts that makes XHR requests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api(<span class="hljs-string"><span class="hljs-string">'/rest/blog/'</span></span>).post(text); } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTagToPost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">postId, tag</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> api(<span class="hljs-string"><span class="hljs-string">`/rest/blog/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${postId}</span></span></span><span class="hljs-string">/`</span></span>).post(tag); } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPostWithTags</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text, tags = []</span></span></span><span class="hljs-function">) </span></span>{ createPost(text).then( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ postId }</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(tags.map( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tag</span></span></span><span class="hljs-function"> =&gt;</span></span> addTagToPost(postId, tag) )) }) }</code> </pre> <br>  The <b>api</b> function spawns the xhr query. <br>  <b>createPost</b> - creates a blog post. <br>  <b>addTagToPost</b> - tags an existing blogpost. <br>  <b>createPostWithTags</b> - creates a blog post and tags it immediately. <br><br>  Tests for the createPost and addTagToPost functions are reduced to intercepting an XHR request, checking the transmitted URI and payload (which can be done using, for example, useFakeXMLHttpRequest () from the <a href="http://sinonjs.org/">sinon</a> package) and checking that the function returns a promise with the value we returned from the xhr stub . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fakeXHR = sinon.useFakeXMLHttpRequest(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reqs = []; fakeXHR.onCreate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function">) </span></span>{ reqs.push(req); }; describe(<span class="hljs-string"><span class="hljs-string">'createPost()'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'URI'</span></span>, () =&gt; { createPost(<span class="hljs-string"><span class="hljs-string">'TEST TEXT'</span></span>) assert(reqs[<span class="hljs-number"><span class="hljs-number">0</span></span>].url === <span class="hljs-string"><span class="hljs-string">'/rest/blog/'</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'blogpost text'</span></span>, () =&gt; { createPost(<span class="hljs-string"><span class="hljs-string">'TEST TEXT'</span></span>) assert(reqs[<span class="hljs-number"><span class="hljs-number">1</span></span>].data === <span class="hljs-string"><span class="hljs-string">'TEST TEXT'</span></span>); }); it(<span class="hljs-string"><span class="hljs-string">'should return promise with postId'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = createPost(<span class="hljs-string"><span class="hljs-string">'TEST TEXT'</span></span>); assert(p <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>); reqs[<span class="hljs-number"><span class="hljs-number">3</span></span>].respond(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> }, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify({ <span class="hljs-attr"><span class="hljs-attr">postId</span></span>: <span class="hljs-number"><span class="hljs-number">333</span></span> }) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.then( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ postId }</span></span></span><span class="hljs-function">) =&gt;</span></span> { assert(postId === <span class="hljs-number"><span class="hljs-number">333</span></span>); }) }); })</code> </pre><br>  The test code for addTagToPost is similar, so I don‚Äôt give it here.  But what should a test for createPostWithTags look like? <br><br>  Because createPostWithTags () uses createPost () and addTagToPost () and depends on the result of executing these functions, we need to duplicate the code for createPost () and addTagToPost () in the test for createPostWithTags () to ensure that the createPostWithTags function works () <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should create post'</span></span>, () =&gt; { createPostWithTags(<span class="hljs-string"><span class="hljs-string">'TEXT'</span></span>, [<span class="hljs-string"><span class="hljs-string">'tag1'</span></span>, <span class="hljs-string"><span class="hljs-string">'tag2'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">//   createPost(text) assert(reqs[0].requestBody === 'TEXT'); reqs[0].respond(200, { 'Content-Type': 'application/json' }, JSON.stringify({ postId: 333 }) ); });</span></span></code> </pre><br>  Do you feel that something is wrong? <br><br>  To test the createPostWithTags function, we need to check that it called the createPost () function with the argument 'TEXT'.  To do this, we have to duplicate the test from createPost () itself: <br><br><pre> <code class="javascript hljs">assert(reqs[<span class="hljs-number"><span class="hljs-number">0</span></span>].requestBody === <span class="hljs-string"><span class="hljs-string">'TEXT'</span></span>);</code> </pre> <br>  In order for our function to continue execution, we also need to respond to the request sent by createPost, which is also copy paste from the test code. <br><br><pre> <code class="javascript hljs">reqs[<span class="hljs-number"><span class="hljs-number">0</span></span>].respond(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> }, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify({ <span class="hljs-attr"><span class="hljs-attr">postId</span></span>: <span class="hljs-number"><span class="hljs-number">333</span></span> }) );</code> </pre> <br>  We had to copy the code from the tests that check the performance of the createPost function while we need to focus on checking the logic of createPostWithTags itself.  Also, if someone breaks the createPost () function, all other functions that use it will also break down and this may take more time to debug. <br><br>  I remind you that in addition to ensuring the work of the createPost () function, we will have to catch XHR requests from addTagToPost which is called in a loop and make sure that addTagToPost returns the promise with exactly the tagId that we passed using reqs [i] .respond (): <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should create post'</span></span>, () =&gt; { createPostWithTags(<span class="hljs-string"><span class="hljs-string">'TEXT'</span></span>, [<span class="hljs-string"><span class="hljs-string">'tag1'</span></span>, <span class="hljs-string"><span class="hljs-string">'tag2'</span></span>]) assert(reqs[<span class="hljs-number"><span class="hljs-number">0</span></span>].requestBody === <span class="hljs-string"><span class="hljs-string">'TEXT'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Response for createPost() reqs[0].respond(200, { 'Content-Type': 'application/json' }, JSON.stringify({ postId: 333 }) ); // Response for first call of addTagToPost() reqs[1].respond(200, { 'Content-Type': 'application/json' }, JSON.stringify({ tagId: 1 }) ); // Response for second call of addTagToPost() reqs[2].respond(200, { 'Content-Type': 'application/json' }, JSON.stringify({ tagId: 2 }) ); });</span></span></code> </pre><br>  inb4: You can lock the api module.  The example is specially simplified to understand the problem and my code is very confusing.  But even if you lock the api module - this does not save us from checking the arguments passed inside. <br><br>  In my code there are a lot of asynchronous requests to the API, individually they are all covered by tests, but there are functions with complex logic that call these requests - and tests for them turn into something between a spaghetti code and a callback hell. <br><br>  If the functions are more complicated, or corny are in one file (as is customary to do in flux / redux architectures), your tests will swell so much that the complexity of their work will be much higher than the complexity of your code, which is what happened to me. <br><br><h3>  Task statement </h3><br>  We should not check the work of createPost and addTagToPost inside the createPostWithTags test. <br><br>  The task of testing functions like createPostWithTags () is to substitute the function calls inside, check the arguments and call the stub instead of the original functions that will return the desired value in a particular test.  This is called monkey patching. <br><br>  The problem is that JS does not allow us to look inside the scope of the module / function and redefine the calls to addTagToPost and createPost inside createPostWithTags. <br><br>  If createPost and addTagToPost were in a third-party module, we could use something like <a href="https://facebook.github.io/jest/">jest</a> to intercept calls to them, but in our case this is not a solution to the problem, since functions whose calls we would like to intercept can be hidden deep inside the scope tested function and not exported outside. <br><br><h3>  Decision </h3><br>  Like many of you, we are also actively using Babel on our project. <br><br>  Since Babel knows how to parse any JS and gives an API with which you can transform JS into anything, I had an idea to write a plugin that would facilitate the process of writing such tests and give the opportunity to do simple monkey patching despite the isolation of functions that we would like to substitute. <br><br>  The work of such a plugin is simple and can be decomposed into three steps: <br><br><ol><li>  Find a call to our little framework in the test code. </li><li>  Find the module and function in which we want to intercept something. </li><li>  Change the code of the tests and the module under test by substituting stubs for the corresponding calls. </li></ol><br>  The result is a plug-in for Babel called <a href="https://github.com/nginxinc/snarejs">snare (trap) js</a> which can be connected to the project and it will do these three points for you. <br><br><h3>  <a href="https://github.com/nginxinc/snarejs">Snare.js</a> </h3><br>  First you need to install and connect snare to your project. <br><br><pre> <code class="javascript hljs">npm install snarejs</code> </pre> <br>  And add it to your .babelrc <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"presets"</span></span>: [<span class="hljs-string"><span class="hljs-string">"es2015"</span></span>, <span class="hljs-string"><span class="hljs-string">"react"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"snarejs/lib/plugin"</span></span> ] }</code> </pre><br>  To explain how snarejs works, let's write a test for our createPostWithTags () right away: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> snarejs <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'snarejs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {spy} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sinon'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> createPostWithTags <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../actions'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'createPostWithTags()'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TXT = <span class="hljs-string"><span class="hljs-string">'TXT'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> POST_ID = <span class="hljs-number"><span class="hljs-number">346</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TAGS = [<span class="hljs-string"><span class="hljs-string">'tag1'</span></span>, <span class="hljs-string"><span class="hljs-string">'tag2'</span></span>, <span class="hljs-string"><span class="hljs-string">'tag3'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> snare = snarejs(createPostWithTags); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createPost = spy(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">postId</span></span>: POST_ID })); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addTagToPost = spy(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">addTagToPost, postId, tag</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ tag, <span class="hljs-attr"><span class="hljs-attr">id</span></span>: TAGS.indexOf(tag) }) ); snare.catchOnce(<span class="hljs-string"><span class="hljs-string">'createPost()'</span></span>, createPost); snare.catchAll(<span class="hljs-string"><span class="hljs-string">'addTagToPost()'</span></span>, addTagToPost); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = snare(TXT); it(<span class="hljs-string"><span class="hljs-string">'should call createPost with text'</span></span>, () =&gt; { assert(createPost.calledWith(TXT)); }); it(<span class="hljs-string"><span class="hljs-string">'should call addTagToPost with postId and tag name'</span></span>, () =&gt; { TAGS.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tagName, i</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// First argument is post id assert(addTagToPost.args[i][1] == POST_ID); // Second argument assert(addTagToPost.args[i][2] == tagName); }); }); it('result should be promise with tags', () =&gt; { TAGS.forEach( (tagName, i) =&gt; { assert(result[i].tag == tagName); assert(result[i].id == TAGS.indexOf(tagName)); }); }) })</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> snare = snarejs(createPostWithTags);</code> </pre> <br>  Here is the initialization, stumbling on it Babel plugin finds out where the createPostWithTags method (in our example, the module "../actions") is located, and in it it will intercept the corresponding calls. <br><br>  The variable snare is an object of the function createPostWithTags with a prototype containing methods snarejs. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createPost = spy(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">postId</span></span>: POST_ID }));</code> </pre><br>  sinon stub for createPost returning promise.  Instead of sinon, you can use the usual functions if you do not need anything from what sinon gives. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addTagToPost = spy(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">addTagToPost, postId, tag</span></span></span><span class="hljs-function">) =&gt;</span></span></code> </pre><br>  Pay attention to the first argument of the stub, in it snarejs passes the original function in case it is suddenly needed.  Next are the postId and tag arguments ‚Äî these are the original arguments to the function we are hooking. <br><br><pre> <code class="javascript hljs">snare.catchOnce(<span class="hljs-string"><span class="hljs-string">'createPost()'</span></span>, createPost);</code> </pre> <br>  Here we indicate that we need to intercept the createPost () call once and call our stub. <br><br><pre> <code class="javascript hljs">snare.catchAll(<span class="hljs-string"><span class="hljs-string">'addTagToPost()'</span></span>, addTagToPost);</code> </pre> <br>  Here we indicate that we need to intercept all calls to addTagToPost <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = snare(TXT, TAGS);</code> </pre> <br>  We call our createPostWithTags function and write the result to result for verification. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should call createPost with text'</span></span>, () =&gt; { assert(createPost.args[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] == TXT); });</code> </pre> <br>  Here we check that the second argument of the call to our stub is ‚ÄúTXT‚Äù.  The first argument is the original function, didn't you forget?  :) <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should call addTagToPost with postId and tag name'</span></span>, () =&gt; { TAGS.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tagName, i</span></span></span><span class="hljs-function">) =&gt;</span></span> { assert(addTagToPost.args[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] == POST_ID); assert(addTagToPost.args[i][<span class="hljs-number"><span class="hljs-number">2</span></span>] == tagName); }); });</code> </pre> <br>  With tags, too, everything is simple: since we know the set of passed tags, we need to check that each tag has been passed to the addTagToPost () call along with the POST_ID. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'result should be promise with tags'</span></span>, () =&gt; { assert(result <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>); });</code> </pre> <br>  Last check on the type of result. <br><br>  As I said above, snare just finds the calls you need when building your tests and replaces it with your own. <br><br>  For example, the addTagToPost (postId, tags) call will turn into something like: <br><br><pre> <code class="javascript hljs">__g__.__SNARE__.handleCall({ <span class="hljs-attr"><span class="hljs-attr">fn</span></span>: createPost, <span class="hljs-attr"><span class="hljs-attr">context</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/path/to/module/module.js/addTagToPost()'</span></span> }, postId, tags)</code> </pre> <br>  As you can see - no magic. <br><br><h3>  API </h3><br>  The API is very simple and consists of 4 methods. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snareFn = snare(fn);</code> </pre> <br>  As an argument, a link to the function is passed inside which the plugin will look for other calls. <br><br>  Babel plugin, meeting snarejs initialization, resolves the argument passed.  A link can be any identifier obtained from either ES6 import or commonJS require: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fn = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./module'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {fn} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./module'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-attr"><span class="hljs-attr">anotherName</span></span>: fn} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./module'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fn = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./module'</span></span>).anotherName; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fn <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./module'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {fn} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./module'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {anotherName <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fn} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./module'</span></span>;</code> </pre><br>  In all cases, the plugin will find the necessary export in a specific module and replace the necessary calls in it.  The export itself can also be either in the common.js or ES6 style. <br><br><pre> <code class="javascript hljs">snareFn.catchOnce(<span class="hljs-string"><span class="hljs-string">'fnName()'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnName, ‚Ä¶args</span></span></span><span class="hljs-function">)</span></span>{}); snareFn.catchAll(<span class="hljs-string"><span class="hljs-string">'fnName()'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnName, ‚Ä¶args</span></span></span><span class="hljs-function">)</span></span>{});</code> </pre> <br>  The first argument is the string with CallExpression, the second is the intercept function.  catchOnce intercepts the corresponding call once, catchAll appropriately intercepts all calls. <br><br><pre> <code class="javascript hljs">snareFn.reset(<span class="hljs-string"><span class="hljs-string">'fnName()'</span></span>);</code> </pre> <br>  Cancels interception of a call to the corresponding function. <br><br>  A couple of subtleties: <br><br>  In the event you used .catchOnce () and the call in the code was intercepted, subsequent calls will work with the original function until you call catchOnce () / catchAll () again. <br><br>  If you need to intercept the object's method call, then in this function of the interceptor will be the object itself: <br><br><pre> <code class="javascript hljs">snare.catchOnce(<span class="hljs-string"><span class="hljs-string">'obj.api.helpers.myLazyMethod()'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">myLazyMethod, ‚Ä¶args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// this === obj.api.helpers // myLazyMethod -   // args -    })</span></span></code> </pre><br>  .catchOnce () may be several: <br><br><pre> <code class="javascript hljs">snare.catchOnce(<span class="hljs-string"><span class="hljs-string">'fnName()'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnName, ‚Ä¶args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'first call of fnName()'</span></span>); }); snare.catchOnce(<span class="hljs-string"><span class="hljs-string">'fnName()'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnName, ‚Ä¶args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'second call of fnName()'</span></span>); }); snare.catchOnce(<span class="hljs-string"><span class="hljs-string">'fnName()'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnName, ‚Ä¶args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'third call of fnName()'</span></span>); });</code> </pre> <br><h3>  Instead of conclusion </h3><br>  So far, snare can only work with functions, but plans to make support for classes. <br>  Modern JS is very diverse and the plug-in works inside the ast tree - hence there may be bugs in cases that I did not take into account (they all write differently :), so if you step on something, do not be lazy to create an issue in <a href="https://github.com/nginxinc/snarejs">github</a> or email me (ip AT nginx. com). <br><br>  I hope this tool will be useful to you as well as me and your tests will make soft ^ W easier. </div><p>Source: <a href="https://habr.com/ru/post/320892/">https://habr.com/ru/post/320892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320882/index.html">Off splinters from the brain. 15 stereotypes about CRM-systems</a></li>
<li><a href="../320884/index.html">We set up a private Docker repository</a></li>
<li><a href="../320886/index.html">FlexPod - from theory to practice: the word to engineers (webinar)</a></li>
<li><a href="../320888/index.html">Cloudless mobile app - life without Google Play</a></li>
<li><a href="../320890/index.html">NooLite: kill two birds of ergonomics at the same time (installation, opinion, development)</a></li>
<li><a href="../320894/index.html">Experience using Samsung Pay</a></li>
<li><a href="../320898/index.html">Immersion in Robolectric</a></li>
<li><a href="../320900/index.html">Configuring the DNS server for North Korean security standards</a></li>
<li><a href="../320902/index.html">How we prepared the redis cluster</a></li>
<li><a href="../320904/index.html">Petersburg IT exports underestimated by a large amount</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>