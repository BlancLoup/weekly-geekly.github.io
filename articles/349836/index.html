<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding Dependencies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From translator 
 We are implementers. We have to introduce, not fantasize! 
 (Rina Green, film "Girl without an address") 
 
 Two reasons prompted me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding Dependencies</h1><div class="post__text post__text-html js-mediator-article"><h3>  From translator </h3><br><blockquote>  <i>We are implementers.</i>  <i>We have to introduce, not fantasize!</i> <i><br></i>  <i>(Rina Green, film "Girl without an address")</i> <i><br></i> </blockquote><br>  Two reasons prompted me to translate this article: 1) the desire to better understand the Spring framework, 2) a small number of sources on the topic in Russian. <br><br>  The cornerstone of OOP is ‚Äúdependency injection.‚Äù  If the description of the process of ‚Äúintroduction‚Äù as a whole is satisfactory, then the explanation of the concept ‚Äúdependence‚Äù is usually left out of the brackets.  In my opinion, this is a significant omission. <br><br><img src="https://habrastorage.org/webt/sm/u3/p1/smu3p1e-wtarte9ibpgrbf-ye7e.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order not to fantasize, but to introduce, you must first understand what we are introducing.  And the concise article by Jakob Jenkov "Understanding Dependencies" can help us in this.  It will be useful not only to those who write in Java, but also to those who write in other languages ‚Äã‚Äãand monitor the quality of application design. <br><br>  <b>UPD: I translated another Jakob Jenkov article on dependencies.</b>  <b>Read on Habr√© a translation of the article <a href="https://habrahabr.ru/post/350068/">Dependency Injection</a> , which opens a series of articles of the same name and continues this article.</b>  <b>The articles of the series deal with such concepts as Dependency, Dependency Injection (DI), DI-containers.</b> <br><br><a name="habracut"></a><br><a name="start"></a><h2>  Understanding the dependencies </h2><br><ul><li>  <a href="https://habr.com/ru/post/349836/">What is addiction</a> </li><li>  <a href="https://habr.com/ru/post/349836/">Why addiction is bad</a> </li><li>  <a href="https://habr.com/ru/post/349836/">Types of dependencies</a> </li><li>  <a href="https://habr.com/ru/post/349836/">Additional dependency characteristics:</a> <ul><li>  <a href="https://habr.com/ru/post/349836/">interface implementation dependencies</a> </li><li>  <a href="https://habr.com/ru/post/349836/">compile time and runtime dependencies</a> </li><li>  <a href="https://habr.com/ru/post/349836/">visible and hidden dependencies</a> </li><li>  <a href="https://habr.com/ru/post/349836/">direct and indirect dependencies</a> </li><li>  <a href="https://habr.com/ru/post/349836/">unreasonably broad dependencies</a> </li><li>  <a href="https://habr.com/ru/post/349836/">local and contextual dependencies</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/349836/">Standard vs custom class / interface dependencies</a> </li><li>  <a href="https://habr.com/ru/post/349836/">Summary</a> </li></ul><br>  You cannot read a good OOP book that does not mention dependencies, weak connectivity, etc., and there is a good reason for this.  Understanding dependencies is important in object-oriented API and application design.  However, in my opinion, the subject can be explored much deeper than many books do.  This is the purpose of the text.  If you are an experienced OO developer, you can already know a lot of things written here.  I also believe that many developers will still be able to learn something from the text. <br><br><a name="Example1"></a><h3>  What is addiction? </h3><br>  When class A uses a class or interface B, then A depends on B. A cannot do its work without B, and A cannot be reused without reuse B. In this case, class A is called ‚Äúdependent‚Äù, and class or interface B is called ‚ÄúAddiction‚Äù. <br><br>  Two classes that use each other are called related.  Connectivity between classes can be either weak, or strong, or something in between.  The degree of connectivity is not binary and not discrete, it is in the continuum.  Strong connectivity leads to strong dependencies, and weak connectivity leads to weak dependencies or even the absence of dependencies in some situations. <br><br>  Dependencies, or connections, are directional.  The fact that A depends on B does not mean that B depends on A. <br><br><a name="Example2"></a><h3>  Why is addiction bad? </h3><br>  Dependencies are bad because they reduce reuse.  Reducing reuse is bad for many reasons.  Usually, reuse has a positive effect on development speed, code quality, code readability, etc. <br><br>  How dependencies can do harm is best illustrated by an example: Imagine that you have a CalendarReader class that can read calendar events from an XML file.  The implementation of CalendarReader is shown below: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CalendarReader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readCalendarEvents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File calendarEventFile)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//open InputStream from File and read calendar events. } }</span></span></code> </pre> <br>  The readCalendarEvents method gets a File object as a parameter.  Therefore, this method depends on the class File.  The dependency on the File class means that CalendarReader is capable of reading calendar events only from local files in the file system.  It cannot read calendar events from a network connection, database, or from classpath resources.  We can say that CalendarReader is closely related to the File class and the local file system. <br><br>  A less related implementation would be to replace a File parameter with an InputStream parameter, as in the code below: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CalendarReader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readCalendarEvents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream calendarEventFile)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//read calendar events from InputStream } }</span></span></code> </pre> <br>  As you may know, an InputStream can be obtained from an object of type File, from a network socket, a URLConnection class, a Class object (Class.getResourceAsStream (String name)), columns from a database via JDBC, etc.  Now CalendarReader is no longer tied to the local file system.  It can read calendar event files from many sources. <br><br>  With the version of the readCalendarEvents () method using the InputStream, the CalendarReader class has increased reusability.  Close local file system binding has been removed.  Instead, it was replaced by a dependency on the class InputStream.  Dependency on InputStream is more flexible than dependency on File class, but does not mean that CalendarReader can be 100% reusable.  He still cannot read data from the NIO channel, for example. <br><br><a name="Example3"></a><h3>  Types of dependencies </h3><br>  Dependencies are not just ‚Äúdependencies.‚Äù  There are several types of dependencies.  Each of them leads to more or less flexibility in the code.  Types of dependencies: <br><br><ul><li>  class dependencies </li><li>  interface dependencies </li><li>  dependency method / field </li></ul><br>  Class dependencies are class dependencies.  For example, the method in the code box below receives a String as a parameter.  Thus, the method depends on the class String. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] readFileContents(String fileName){ <span class="hljs-comment"><span class="hljs-comment">//open the file and return the contents as a byte array. }</span></span></code> </pre> <br>  Interface dependencies are dependencies on interfaces.  For example, the method in the code insert below gets the CharSequence as a parameter.  CharSequence is a standard Java interface (in the java.lang package).  The CharBuffer, String, StringBuffer, and StringBuilder classes implement the CharSequence interface, so only instances of these classes can be used as parameters of this method. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] readFileContents(CharSequence fileName){ <span class="hljs-comment"><span class="hljs-comment">//open the file and return the contents as a byte array. }</span></span></code> </pre> <br>  Dependencies of methods or fields are dependencies on specific methods or fields of an object.  It does not matter what the class of the object is or what interface it implements, as long as it has a method or field of the required type.  The following example illustrates method dependencies.  The readFileContents method depends on the method named ‚ÄúgetFileName‚Äù in the class of the object passed as a parameter (fileNameContainer).  Please note that the dependency is not visible from the method declaration! <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] readFileContents(Object fileNameContainer){ Method method = fileNameContainer .getClass() .getMethod(<span class="hljs-string"><span class="hljs-string">"getFileName"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); String fileName = method.invoke(fileNameContainer, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//open the file and return the contents as a byte array. }</span></span></code> </pre> <br>  Dependencies of methods or variables are characteristic of APIs that use reflection.  For example, Butterfly Persistence uses reflection to detect class getters and setters.  Without getters and setters, Butterfly Persistence cannot read and write class objects from / to the database.  Thus, Butterfly Persistence depends on getters and setters.  Hibernate (similar ORM API) can use both getters and setters, and fields directly, as well as through reflection.  Thus, Hibernate also has a dependency either on methods or on fields. <br><br>  Dependencies of methods or (‚Äúfunctions‚Äù) can also be seen in languages ‚Äã‚Äãthat support pointers to functions or pointers to methods that must be passed as arguments.  For example, delegates in C #. <br><br><a name="Example4"></a><h3>  Additional dependency characteristics </h3><br>  Dependencies have other important characteristics besides the type.  Dependencies can be dependencies of compile time, runtime, visible, hidden, direct, indirect, contextual, etc.  These additional features will be covered in the following sections. <br><br><a name="Example5"></a><h4>  Interface implementation dependencies </h4><br>  If class A depends on interface I, then A does not depend on the concrete implementation of I. But A depends on some implementation of I. A cannot perform its work without some implementation of I. Thus, when the class depends on the interface, this class also depends on the implementation of the interface. <br><br>  The more methods the interface has, the less likely it is that developers will provide their own implementations if they are not asked to.  Consequently, the more methods there are in the interface, the greater the possibility that developers will be ‚Äústuck‚Äù on the standard implementation of this interface.  In other words, the more complex and cumbersome the interface becomes, the more closely it is associated with its default implementation. <br><br>  Due to the dependencies of the interface implementation, you do not have to add functionality to the interface blindly.  If the functionality can be encapsulated in its component, in its own separate interface, you need to do so. <br><br>  Below is an example of what this means.  The example code shows a tree node for a hierarchical tree structure. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ITreeNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ITreeNode node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;ITreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChildren</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ITreeNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Imagine that you want to be able to count the number of descendants of a particular node.  First you may be tempted to add the countDescendents () method to the ITreeNode interface.  However, if you do this, everyone who wants to implement the ITreeNode interface will also have to implement the countDescendents () method. <br><br>  Instead, you can implement the DescendentCounter class, which can view an ITreeNode instance and count all the descendants of this instance.  DescendentCounter can be reused with other implementations of the ITreeNode interface.  You have just saved your users from the problem of implementing the countDescendents () method, even if they need to implement the ITreeNode interface! <br><br><a name="Example6"></a><h4>  Dependencies of compile time and runtime </h4><br>  A dependency that can be resolved at compile time is called a compile time dependency.  Dependency, which can not be resolved before the start of execution - the dependence of the execution time  Compile-time dependencies can be seen more easily than run-time dependencies, however, run-time dependencies can be more flexible.  For example, Butterfly Persistence, finds class getters and setters at runtime and automatically maps them to the database tables.  This is a very easy way to compare classes with database tables.  However, to do this, Butterfly Persistence depends on correctly named getters and setters. <br><br><a name="Example7"></a><h4>  Visible and hidden dependencies </h4><br>  Visible dependencies are dependencies that developers can see from the class interface.  If dependencies cannot be detected in the class interface, these are hidden dependencies. <br><br>  In the example above, the String and CharSequence dependencies of the readFileContents () method are visible dependencies.  They are visible in the method declaration, which is part of the class interface.  The dependencies of the readFileContents () method, which takes an Object as a parameter, are invisible.  You cannot see from the interface that the readFileContents () method calls fileNameContainer.toString () to get the name of the file, or as it actually happens, calls the getFileName () method. <br><br>  Another example of hidden dependency is dependence on static singleton or static methods inside a method.  You cannot see from the interface that the class depends on a static method or a static singleton. <br><br>  As you can imagine, hidden dependencies can be evil.  They are difficult to detect by the developer.  They can be identified only by studying the code. <br><br>  This is not the same as saying that you should never use hidden dependencies.  Hidden dependencies are often the result of providing reasonable defaults (providing sensible defaults).  In this example, this may not be a problem. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> MyDependency dependency = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependency = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyDefaultImpl(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyDependency dependency)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependency = dependency; } }</code> </pre> <br>  MyComponent has a hidden dependency on MyDefaultImpl as can be seen in the constructor.  But MyDefaultImpl has no dangerous side effects, so in this case the hidden dependency is not dangerous. <br><br><a name="Example8"></a><h4>  Direct and indirect dependencies </h4><br>  Dependence can be either direct or indirect.  If class A uses class B, then class A is directly dependent on class B. If A depends on B, B depends on C, then A has an indirect dependence on C. If you cannot use A without B, and you cannot use B without C, then you can not also use A without C. <br><br>  Indirect dependencies are also called concatenated (chain), or transitive (in "Better, Faster, Lighter Java" by Bruce A. Tate and Justin Gehtland). <br><br><a name="Example9"></a><h4>  Unreasonably extensive dependencies </h4><br>  Sometimes components depend on more information than they need to work.  For example, submit a login component in a web application.  This component needs only a login and password, and it will return the user object if it finds one.  The interface might look like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginManager</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request)</span></span></span></span>{ String user = request.getParameter(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); String password = request.getParameter(<span class="hljs-string"><span class="hljs-string">"password"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//read user and return it. } }</span></span></code> </pre> <br>  A component call might look like this: <br><br><pre> <code class="java hljs">LoginManager loginManager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoginManager(); User user = loginManager.login(request);</code> </pre> <br>  Looks easy, right?  And even if the login method needs more parameters, you will not need to change the calling code. <br><br>  But now the login method has what I call ‚Äúunnecessarily extensive dependencies‚Äù on the HttpServletRequest interface.  The method depends on more than he needs to work.  LoginManager only requires a username and password to find the user, but receives the HttpServletRequest as a parameter in the login method.  HttpServletRequest contains much more information than the LoginManager needs. <br><br>  The dependency on the HttpServletRequest interface causes two problems: <br><br><ol><li>  LoginManager cannot be reused without an HttpServletRequest object.  This can make LoginManager unit testing more difficult.  You will need to lock the HttpServletRequest object, which requires a lot of work. </li><li>  LoginManager requires that the username and password parameter names be ‚Äúlogin‚Äù and ‚Äúpassword‚Äù.  This is also an optional dependency. </li></ol><br>  A much better interface for the LoginManager login method would be: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String user, String password)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//read user and return it. }</span></span></code> </pre> <br>  But look what happens with the calling code now: <br><br><pre> <code class="java hljs">LoginManager loginManager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoginManager(); User user = loginManager.login( request.getParameter(<span class="hljs-string"><span class="hljs-string">"user"</span></span>), request.getParameter(<span class="hljs-string"><span class="hljs-string">"password"</span></span>));</code> </pre> <br>  He became more difficult.  This is the reason why developers create unnecessarily wide dependencies.  To simplify the calling code. <br><br><a name="Example10"></a><h4>  Local and contextual dependencies </h4><br>  When developing applications, it is normal to split applications into components.  Some of these components are general-purpose components that can also be used in other applications.  Other components are application specific and will not be used outside the application. <br><br>  For general purpose components, any classes belonging to a component (or API) are ‚Äúlocal.‚Äù  The rest of the application is ‚Äúcontext.‚Äù  If the general purpose component depends on application-specific classes, this is called context dependency.  Contextual dependencies are bad because they make it impossible to use a general-purpose component outside the application.  It is tempting to think that only a bad OO developer will create contextual dependencies, but this is not the case.  Contextual dependencies usually occur when developers try to simplify the creation of their application.  A good example here is applications that handle requests, such as applications connected to message queues or web applications. <br><br>  Imagine that an application that receives a request in the form of XML, processes requests and receives XML in response.  Several separate components are involved in processing an XML request.  Each of these components needs different information, some information has already been processed by previous components.  It is very tempting to assemble the XML file and all associated processing inside a request object of some kind, which is sent to all components, in a processing sequence.  The processing component can read information from this request object and add information from itself for components that are further in the processing sequence.  Taking this request object as a parameter, each of the components processing the request depends on this request.  The request object is specific to the application, it causes dependence on the context of each request processing component. <br><br><a name="Example11"></a><h3>  Standard vs custom class / interface dependencies </h3><br>  In many situations, it is better for a component to depend on a class or interface from standard Java (or C #) packages.  These classes or interfaces are always available to everyone, which simplifies satisfying these dependencies.  Also, these classes are less likely to change and cause a drop in the compilation of your application. <br><br>  However, in some situations, depending on standard libraries is not the best thing.  For example, the method needs 4 lines to configure it.  Therefore, your method takes 4 lines as parameters.  For example, this is the driver name, database url, username and password to connect to the database.  If all these strings are always used together, it may be clearer for the user of this method if you group these 4 strings into a class and pass an instance of it, instead of 4 strings. <br><br><a name="Example12"></a><h3>  Summary </h3><br>  We looked at several different types and characteristics of dependencies.  In general, interface dependencies are preferable to class dependencies.  In some situations, you may find that class dependencies are preferable to interface dependencies.  Dependencies of methods and fields can be very useful, but remember that they are usually hidden dependencies, and hidden dependencies make it difficult for the users of your components to find them and satisfy their requirements. <br><br>  Interface implementation dependencies are more common than you might think.  I have seen them in many applications and APIs.  Try to limit them as much as possible, keeping the interfaces small.  At least those interfaces that the component user implements.  Move additional functions (for example, counting, etc.) to external components that accept an instance of the interface in question as a parameter. <br><br>  Personally, I prefer the dependencies of the compile time to the dependencies of the execution time, but in some cases the dependencies of the execution time are more elegant.  For example, Mr.  Persister uses runtime dependencies on getters and setters, which frees your pojo from implementing a persistent interface.  Dependencies of execution time in this way may be less invasive than <br>  compile-time dependencies. <br><br>  Hidden dependencies can be dangerous, but since runtime dependencies are sometimes also hidden dependencies, you may not always have a choice. <br><br>  Remember that even if a component does not have direct dependencies on another component, it may still have an indirect relationship to it.  Less restrictive, but nonetheless, mediated dependencies are also dependencies. <br><br>  Try to avoid unnecessarily broad dependencies.  Keep in mind that unnecessarily broad dependencies arise when you group multiple parameters into a class.  This is a general refactoring, which is done to make the code simpler, but as you can see, it can lead to unnecessarily broad dependencies. <br><br>  The component to be used in different contexts should not have any contextual dependencies.  That is, a component should not depend on other components in the context in which it was originally developed and in the one in which it is integrated. <br><br>  This text only described dependencies.  He does not tell you what to do with them.  Other texts on this training site will immerse you in this topic ( <i>approx. Transl</i> .: I mean the <a href="http://tutorials.jenkov.com/">personal site of the author</a> ). <br><br>  <a href="https://habr.com/ru/post/349836/">To top</a> <br>  <a href="https://habrahabr.ru/post/350068/">To a series of articles Dependency Injection</a> </div><p>Source: <a href="https://habr.com/ru/post/349836/">https://habr.com/ru/post/349836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349822/index.html">Qt: Writing a generic model for QML ListView</a></li>
<li><a href="../349824/index.html">Drop Stack Overflow: What Happened</a></li>
<li><a href="../349826/index.html">Sleight of hand and no fraud: practical tips on accelerated design training for developers</a></li>
<li><a href="../349830/index.html">Personal experience: a selection of materials about the virtual infrastructure, information security and trends in the IaaS market</a></li>
<li><a href="../349832/index.html">Alternative to paid off ads in the free Android application</a></li>
<li><a href="../349838/index.html">The story of the internet in Germany and the undocumented features of Juniper SRX</a></li>
<li><a href="../349840/index.html">iPaaS - cloud ESB ... or not?</a></li>
<li><a href="../349842/index.html">Check Point Technical Support (TAC). Quick Start Guide</a></li>
<li><a href="../349844/index.html">Microsatellites for Earth Remote Sensing</a></li>
<li><a href="../349852/index.html">Extension methods for .NET standard library types</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>