<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Work with images in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The topic of today's conversation is what Python has learned over the years of its existence in working with images. And indeed, besides the oldies, o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Work with images in Python</h1><div class="post__text post__text-html js-mediator-article">  The topic of today's conversation is what Python has learned over the years of its existence in working with images.  And indeed, besides the oldies, originally from 1990, ImageMagick and GraphicsMagick, there are modern efficient libraries.  For example, Pillow and more productive Pillow-SIMD.  Their active developer Alexander Karpinsky ( <a href="https://habr.com/users/homm/" class="user_link">homm</a> ) at MoscowPython compared various libraries for working with images in Python, introduced benchmarks and spoke about unobvious features that are always enough.  In this article, deciphering a report that will help you choose a library for your application, and make it work as efficiently as possible. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CZ99Q0DQq3Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>About the speaker:</strong> Alexander Karpinsky works in the company <a href="https://uploadcare.com/">Uploadcare</a> and is engaged in the service of quick image modification on the fly.  Participates in the development of <a href="https://python-pillow.org/">Pillow</a> - a popular library for working with images in Python, develops its own fork of this library - <a href="https://github.com/uploadcare/pillow-simd">Pillow-SIMD</a> , which uses modern instructions of processors for the highest performance. <br><a name="habracut"></a><br><h2>  Background <br></h2><br>  The service to modify images in Uploadcare is a server that receives an HTTP request with an image identifier and some operations that need to be performed by the client.  The server must perform the operation and respond as quickly as possible.  The client most often is the browser. <br><br>  The entire service can be described as a wrapper around a graphic library.  The quality of the entire project depends on the quality, performance and usability of the graphics library.  It is easy to guess that Pillow is used as a graphic library in Uploadcare. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Libraries <br></h2><br>  Briefly consider what kind of graphics libraries exist in Python in order to better understand what will be discussed further. <br><br><h3>  Pillow <br></h3><br>  <a href="https://python-pillow.org/">Pillow</a> - fork PIL (Python Imaging Library).  This is a very old project, released in 1995 for Python 1.2.  You can imagine how old he is!  At some point, the Python Imaging Library was abandoned, its development stopped.  Fork Pillow was made to install and build the Python Imaging Library on modern systems.  Gradually, the number of changes that people needed in the Python Imaging Library grew, and Pillow 2.0 was released, which added support for Python 3. This can be considered the beginning of a separate Pillow project life. <br><br>  Pillow is a native module for Python, half of the code is written in C, half in Python.  Python versions are supported by the most diverse: 2.7, 3.3+, PpP, PpP3. <br><br><h3>  Pillow-SIMD <br></h3><br>  This is my fork Pillow, which comes out from May 2016.  SIMD means Single Instruction, Multiple Data <strong>&nbsp;</strong>  - an approach in which the processor can perform a larger number of actions per clock using modern instructions. <br><br>  <a href="https://github.com/uploadcare/pillow-simd">Pillow-SIMD</a> is not a fork in the classic sense when a project begins to live its own life.  This is a replacement for Pillow, that is, you install one library instead of another, you do not change a line in your source code, and you get great performance. <br><br>  Pillow-SIMD can be built with SSE4 instructions (default).  This is a set of instructions that exists in almost all modern x86 processors.  Also Pillow-SIMD can be assembled with the AVX2 instruction set.  This set of instructions is, starting with the architecture Haswell, that is, from about 2013. <br><br><h3>  Opencv <br></h3><br>  Another library for working with images in Python, which you probably heard about, is <a href="https://opencv.org/">OpenCV</a> (Open Computer Vision).  Works since 2000.  Binding in Python included.  This means that the binding is always up to date, there is no dissynchrony between the library itself and the binding. <br><br>  Unfortunately, this library is not yet supported in PyPy, because OpenCV is based on numpy, and numpy only recently started working under PyPy, and PyPy still does not support OpenCV. <br><br><h3>  VIPS <br></h3><br>  Another library worth paying attention to is VIPS.  The main idea of <a href="https://d.docs.live.net/5f198da7c280adbc/%25D0%2594%25D0%25BE%25D0%25BA%25D1%2583%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582%25D1%258B/HighLoad/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8/icupitt.qithub.io/Libvips/">VIPS</a> is that in order to work with an image, you do not need to load the entire image into memory.  The library can load some small pieces, process them and save.  Thus, to process gigapixel images you do not need to waste gigabytes of memory. <br><br>  This is a rather old library from 1993, but it is ahead of its time.  For a long time, there was little to hear about it, but lately, for VIPS, there were bindings for different languages, including Go, Node.js, Ruby. <br><br>  I wanted to try this library for a long time, to feel it, but I could not do it for a very stupid reason.  I could not figure out how to install VIPS, because binding was going very hard.  But now (in 2017) there is a pyvips binding from the author of the VIPS himself, with whom there are no problems anymore.  Now installing and using VIPS is very simple.  Supported: Python 2.7, 3.3+, PpPu, PpPZ. <br><br><h3>  ImageMagick &amp; GraphicsMagick <br></h3><br>  If we talk about working with graphics, it is impossible not to mention the old people - <a href="http://imagemagick.org/script/index.php">ImageMagick</a> and <a href="http://www.graphicsmagick.org/">GraphicsMagick</a> libraries.  The latter was originally a fork of ImageMagick with greater performance, but now their performance seems to be equal.  There are no other fundamental differences, as far as I know, between them.  Therefore, you can use any, more precisely, the one that you prefer to use. <br><br>  These are the oldest libraries of those that I mentioned today (1990).  In all this time, there have been a few bindings for Python, and almost all of them have safely died by now.  Of those that can be used, left: <br><br><ul><li>  Binding Wand, which is built on ctypes, but is also not updated. </li><li>  Binding pgmagick uses Boost.Python, so it compiles for a very long time and does not work in PyPy.  But, nevertheless, you can use it, I would say that it is preferable to the Wand. </li></ul><br><h2>  Performance <br></h2><br>  When we talk about working with images, the first thing that interests us (at least to me) is productivity, because otherwise we could write something in Python with our hands. <br><br>  Performance is not such a simple thing.  You can't just say that one library is faster than another.  Each library has a set of functions, and each function operates at a different speed. <br><br>  Accordingly, it is correct to say only that the performance of one function is higher or lower in a particular library.  Either you have an application that needs a certain set of functionality, and you make a benchmark for this functionality, and say that for your application such a library runs faster (slower). <br><br><h3>  It is important to check the result. <br></h3><br>  When you make benchmarks, it is very important to look at the result that is obtained.  Even if at first glance you wrote the same code, it does not mean that it is the same. <br><br>  Recently, in an article comparing the performance of Pillow and OpenCV, I came across this code: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFilter.BoxBlur im.filter(ImageFilter.BoxBlur(<span class="hljs-number"><span class="hljs-number">3</span></span>)) ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 cv2.blur(im, ksize=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) ...</code> </pre> <br>  It seems to be both there and there, BoxBlur, and there, and there argument 3, but in fact the result is different.  Because in Pillow (3) this is the blur radius, and in OpenCV, ksize = (3, 3) is the size of the core, that is, roughly speaking, the diameter.  In this case, the correct value for OpenCV would be 3 * 2 + 1, that is (7, 7). <br><br><h3>  What is the problem? <br></h3><br>  Why is performance at all a problem when working with graphics?  Because the complexity of any operations depends on several parameters, and most often the complexity grows linearly with each of them.  And if there are three of these factors, for example, and the complexity is linearly dependent on each, then the complexity is in a cube. <br><br>  <strong>Example:</strong> Gaussian Blur in OpenCV. <br><br><img src="https://habrastorage.org/webt/q5/ea/ut/q5eaut_epivf3abcoh34rdmjsgg.jpeg"><br><br>  On the left - radius 3, on the right - 30. As you can see, the difference in speed is more than 10 times. <br><br>  When I faced the task of adding a Gaussian blur to my application, I was not satisfied that 900 ms could be hypothetically spent on performing a single operation.  Such operations in the application of thousands per minute, and spend so much time on one is impractical.  Therefore, I studied the question and implemented a Pilot blur according to Gauss, which works in a constant time relative to the radius.  That is, only the size of the image affects the performance of Gaussian blur. <br><br>  But the main thing here is not that something works faster or slower. <br><br><blockquote>  I want to convey that when you build a system, it is important to understand the parameters on which the output complexity depends.  Then you can limit these parameters or in other ways deal with this complexity. <br></blockquote><br>  Probably the most frequent operation we do with images after they are opened is resize. <br><br><img src="https://habrastorage.org/webt/ij/-6/xi/ij-6xiharsev-2a89wlcnvun6b0.jpeg"><br><br>  The graph shows the performance (more - better) of different libraries for the operation of reducing the image in 8 and 1.25 times. <br><br>  For a PIL, a result of 17 Mpx / s means that a photo from an iPhone (12 Mpx) can be reduced 1.25 times in a little less than a second.  Such performance is not enough for a serious application that performs a lot of these operations. <br><br>  I began to optimize the performance of the resize, and in Pillow 2.7 I managed to achieve a two-fold increase in productivity, and in Pillow 4.3, a three-fold increase (Pillow 5.3 is currently relevant, but the resize performance in it is the same). <br><br>  But the resize operation is such a thing that fits very well on SIMD.  It fits to single instruction, multiple data, and therefore in the current version of Pillow-SIMD I was able <strong>to increase the resize speed by 19 times</strong> compared to the original Python Imaging Library using the same resources. <br><br>  This is significantly higher resize performance in OpenCV.  But the comparison is not entirely correct, because OpenCV uses a slightly lower quality method for resizing the box filter, and in Pillow-SIMD, resizing is implemented using convolutions. <br><br>  This is an incomplete list of those operations that are accelerated in Pillow-SIMD compared to conventional Pillow. <br><br><ul><li>  Resize: 4 to 7 times. </li><li>  Blur: 2.8 times. </li><li>  Use of a 3 √ó 3 or 5 √ó 5 core: 11 times. </li><li>  Multiplication and division by alpha channel: 4 and 10 times. </li><li>  Alpha composition: 5 times. </li></ul><br>  I have already said that it is impossible to say that some kind of library is faster than another, but you can make up some sort of set of operations that is interesting for you.  I chose a set of operations that are interesting in my application, made a benchmark and got such results. <br><br><img src="https://habrastorage.org/webt/it/_h/hq/it_hhqosz-vm69bg_o8tt8ajddm.jpeg"><br><br>  It turned out that Pillow-SIMD on this set works 2 times faster than Pillow.  At the very end is Wand (remember, this is ImageMagick). <br><br>  But I was interested in something else - why are such low results with OpenCV and VIPS, because these are libraries that are also designed with a view to performance?  It turned out that in the case of OpenCV, that binary assembly of OpenCV, which is installed using pip, is compiled with a slow JPEG codec (the author of the assembly was notified, for 2018 this problem has already been solved).  It is compiled with libjpeg, while on most systems, at least debian-based, libjpeg-turbo is used, which works several times faster.  If you compile OpenCV from source itself, then the performance will be more. <br><br>  In the case of VIPS, the situation is different.  I contacted the author of the VIPS, showed him this benchmark, we had a long and fruitful correspondence with him.  After that, the author of VIPS found several places in the VIPS itself, where the performance was not on the optimal route, and corrected them. <br><br>  That's what will happen with performance if you compile OpenCV from the sources of the current version, and VIPS comes from the master, which is already there. <br><br><img src="https://habrastorage.org/webt/m2/kg/o8/m2kgo8agnblbu9tsc5nw5fonyfk.jpeg"><br><blockquote>  Even if you have found some kind of benchmark, it‚Äôs not a fact that everything will work with such speed on your machine. <br></blockquote><br><h3>  Set of benchmarks <br></h3><br>  All the benchmarks that I talked about can be found on <a href="http://python-pillow.org/pillow-perf/">the results page</a> .  This is a separate mini-project, where I write benchmarks that I myself need to develop Pillow-SIMD, launch them and post the results. <br><br>  On GitHub there is a <a href="https://github.com/python-pillow/pillow-perf">project</a> with frameworks for testing, where everyone can offer their own benchmarks or correct existing ones. <br><br><h2>  Parallel work <br></h2><br>  So far I have been talking about performance in its pure form, that is, on one core of the processor.  But we all have long been available systems with a large number of cores, and I would like to dispose of them.  Here I must say that in fact Pillow is the only library in question that does not use parallelization of tasks.  I will now try to explain why this is happening.  All other libraries in one form or another use it. <br><br><h3>  Performance metrics <br></h3><br>  In terms of performance, we are interested in 2 parameters: <br><br><ol><li>  <strong>Real time to complete a single operation.</strong>  There is an operation (or a sequence of operations), and you wonder what the actual time (wall clock) this sequence will perform.  This parameter is important on the desktop, where there is a user who gave the command and is waiting for the result. <br></li><li>  <strong>Bandwidth of the entire system</strong> (workflow).  When you have a set of operations that goes on constantly, or many independent operations, and the speed of processing these operations on your hardware is important to you.  This metric is more important on the server, where there are many customers, and you need to serve them all.  The service time of a single client, of course, is important, but slightly less than the total throughput. <br></li></ol><br>  Based on these two metrics we consider different ways of parallel work. <br><br><h3>  Ways of parallel work <br></h3><br>  1. <strong>At the application level</strong> , when you at the application level decide that operations are processed in different threads.  At the same time, the actual execution time of one operation does not change, because, as before, one core deals with one sequence of operations.  The capacity of the system grows in proportion to the number of cores, that is very well. <br><br>  2. <strong>At the level of graphic operations</strong> - that is what is in most graphic libraries.  When a graphics library receives an operation, it internally creates the required number of threads, breaks one operation into several smaller ones, and performs them.  At the same time, the actual execution time is reduced - one operation is performed faster.  But <strong>throughput grows far from linearly</strong> with the number of cores.  There are operations that do not parallel, and a vivid example is the decoding of PNG files ‚Äî it can not be parallelized.  In addition, there are overhead costs for creating threads, splitting tasks that also do not allow throughput to grow linearly. <br><br>  3. <strong>At the level of processor commands and data</strong> .  We prepare data in a special way and use special commands in order for the processor to work with them faster.  This is the SIMD approach, which, in fact, is used in Pillow-SIMD.  Real runtime decreases, throughput grows - <strong>this</strong> is <strong>a win-win option</strong> . <br><br><h3>  How to combine parallel work <br></h3><br>  If we want to combine somehow parallel work, then SIMD is well combined with parallelization inside the operation, and SIMD is well combined with parallelization inside the application. <br><img src="https://habrastorage.org/webt/3z/pa/lo/3zpaloqfeh6cczwlz8zlk5s33lc.jpeg"><br>  But parallelization within the application and within the operation with each other are not combined.  If you try to do this, you will get disadvantages from both approaches.  The actual operation time will be the same as it was on one core, and the system capacity will grow, but not linearly relative to the number of cores. <br><br><h3>  Multithreading <br></h3><br>  If we are already talking about threads, we all write in Python and we know that there is a GIL in it, which does not allow two threads to run at the same time.  Python is strictly a single-threaded language. <br><br>  Of course, this is not true, because GIL actually does not allow two threads to run in Python, and if the code is written in another language and does not use internal Python structures during its work, then this code can release GIL and thus release the interpreter for other tasks. <br><br>  Many libraries for working with graphics release GIL during their work, including Pillow, OpenCV, pyvips, Wand.  Only one does not release - pgmagick.  That is, you can safely create threads for performing some operations, and this will work in parallel with the rest of the code. <br><br>  But the question arises: <strong>how many streams to create?</strong> <br><br>  If we create an infinite number of threads for each task that we have, they will simply take up all the memory and the entire processor - we will not get any effective work.  I formulated a special rule. <br><br><blockquote>  <strong>Rule N + 1</strong> <br><br>  For productive work, you need to create no more than N + 1 workers, where N is the number of cores or processor threads on the machine, and the worker is the process or thread that is being processed. <br></blockquote><br>  It is best to use processes, because even within a single interpreter there are bottlenecks and overheads. <br><br>  For example, in our application, N + 1 Instance Tornado is used, balancing between them by ngnix.  If Tornado is mentioned, then let's talk about asynchronous operation. <br><br><h2>  Asynchronous operation <br></h2><br>  The time that the graphics library actually does is useful work ‚Äî image processing ‚Äî can and should be used for I / O, if you have them in the application.  Asynchronous frameworks are very much in topic here. <br><br>  But there is a problem - when we call some kind of processing, it is called synchronously.  Even if the library releases GIL at this point, the Event Loop is still blocked. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@gen.coroutine def get(self, *args, **kwargs): im = process_image(...) ...</span></span></code> </pre><br>  Fortunately, this problem is very easy to solve by creating a ThreadPoolExecutor with one thread, which starts image processing.  This call is already happening asynchronously. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@run_on_executor(executor=ThreadPoolExecutor(1)) def process_image(self, ... @gen.coroutine def get(self, *args, **kwargs): im = yield process_image(...) ...</span></span></code> </pre><br>  In fact, a queue with one worker is created here that performs exactly graphic operations, and the Event Loop is not blocked and quietly runs in parallel in another thread. <br><br><h2>  Input Output <br></h2><br>  Another topic that I would like to touch upon in the context of talking about graphic operations is input / output.  The fact is that we rarely create some images using a graphic library.  Most often, we open images that came to us from users as encoded files (JPEG, PNG, BMP, TIFF, etc.). <br><br>  Accordingly, the graphic library for building a good application should have some I / O buns from the files. <br><br><h3>  Lazy loading <br></h3><br>  The first such bun is a lazy download.  If, for example, in Pillow you open an image, then at this moment there is no decoding of the picture.  You are returned an object that looks as if the image has already been loaded and is working.  You can see its properties and decide, based on the properties of this image, whether you are ready to work with it further, whether the user has downloaded you, for example, a gigapixel image in order to break your service. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>))</code> </pre><br>  If you decide that you are working further, then using the explicit or implicit load call, the image is decoded.  Already at this moment the necessary amount of memory is allocated. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>)) &gt;&gt;&gt; %time im.load() Wall time: <span class="hljs-number"><span class="hljs-number">73.6</span></span> ms</code> </pre><br><h3>  Broken picture mode <br></h3><br>  The second bun that is needed when working with user-generated content is a mode of broken pictures.  The files that we receive from users very often contain some inconsistencies with the format in which they are encoded. <br><br>  These inconsistencies are for various reasons.  Sometimes these are network transmission errors, sometimes they are just some kind of curved codecs that encoded an image.  By default, Pillow, when it sees images that do not correspond to the format to the end, simply throws an exception. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>) IOError: image file <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> truncated (<span class="hljs-number"><span class="hljs-number">143</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> processed)</code> </pre><br>  But the user is not to blame for the fact that his picture is broken, he still wants to get the result.  Fortunately, Pillow has a mode of broken pictures.  We change one setting, and Pillow tries to ignore to the maximum all the decoding errors that are in the image.  Accordingly, the user sees at least something. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFile ImageFile.LOAD_TRUNCATED_IMAGES = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/cm/jq/ju/cmjqjuopb_ct8wqinkaaeaw0bbc.jpeg"><br><br>  Even a cropped picture is still better than nothing - just a page with an error. <br><br><h3>  Summary table <br></h3><br><img src="https://habrastorage.org/webt/zn/p3/yp/znp3ypfris3rbtkmok83gcyvup8.jpeg"><br><br>  In the table above, I collected everything related to input / output in the libraries that I am talking about.  In particular, I counted the number of codecs of various formats that are in libraries.  It turned out that in OpenCV they are the least of all, in ImageMagick - the most.  It seems that in ImageMagick, you can open any image at all that you meet.  VIPS has 12 native codecs, but VIPS can use ImageMagick as an intermediate.  I did not check how it works, I hope that seamlessly. <br><br>  In Pillow 17 codecs.  It is now the only library in which there is no EXIF ‚Äã‚Äãauto rotate.  But now it is a small problem, because you can read the EXIF ‚Äã‚Äãyourself and rotate the image in accordance with it.  This is a question of a small snippet, which is easily googled and takes up a maximum of 20 lines. <br><br><h3>  OpenCV Features <br></h3><br>  If you look at this table closely, you can see that in OpenCV, in fact, not everything is so good with input / output.  It has the least amount of codecs, there is no lazy loading and you cannot read EXIF ‚Äã‚Äãand color profile. <br><br>  But that's not all.  In fact, OpenCV has more features.  When we simply open some image, the <code>cv2.imread(filename)</code> call rotates JPEG files in accordance with EXIF ‚Äã‚Äã(see table), but at the same time ignores the alpha channel of PNG files ‚Äî rather strange behavior! <br><br>  Fortunately, OpenCV has a flag: <code>cv2.imread(filename, flags=cv2.IMREAD_UNCHANGED)</code> . <br><br>  If you specify the IMREAD_UNCHANGED flag, OpenCV leaves the alpha channel of PNG files, but stops rotating JPEG files in accordance with EXIF.  That is, the same flag affects two completely different properties.  As can be seen from the table, OpenCV does not have the ability to read EXIF, and it turns out that in the case of this flag it is impossible to rotate JPEG at all. <br><br>  What to do if you do not know in advance what format you have the image, and you need both the PNG alpha channel and the JPEG auto-rotation?  Do nothing - OpenCV doesn't work that way. <br><br>  The reason why OpenCV has such problems lies in the name of this library.  It has a lot of functionality for computer vision and image analysis.  In fact, OpenCV is designed to work with verified sources.  This is, for example, an outdoor surveillance camera, which once every second throws off images, and does this for 5 years in the same format and the same resolution.  There is no need for variability in the I / O issue. <br><br>  People who need OpenCV functionality do not really need the functionality of working with user content. <br><br>  But what to do if in your application you still need the functionality of working with user content, and at the same time, you need all the power of OpenCV for processing and statistics? <br><br><img src="https://habrastorage.org/webt/2g/2o/mu/2g2omu98a18hv0gzr4387egsj6s.jpeg"><br><br>  The solution is to combine libraries.  The fact is that OpenCV is built on the basis of numpy, and Pillow has all the means to export images from Pillow to a numpy array.  That is, we export the numpy array, and OpenCV can continue to work with this image as with its own.  This is done very easily: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.open(filename) cv_image = numpy.array(pillow_image)</code> </pre><br>  Further, when we do magic using OpenCV (processing), we call another Pillow method and back import the image into the Pillow format from OpenCV.  Accordingly, you can use I / O again. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.fromarray(cv_image, <span class="hljs-string"><span class="hljs-string">"RGB"</span></span>) pillow_image.save(filename)</code> </pre><br>  Thus, it turns out that we use input / output from Pillow, and processing from OpenCV, that is, we take the best of two worlds. <br><br>  I hope this helps you to build a loaded application for working with graphics. <br><br><blockquote>  Learn some other secrets of development in Python, learn from the invaluable and sometimes unexpected experience, and most importantly, you can discuss your tasks very soon in <a href="https://conf.python.ru/2018/">Moscow Python Conf ++</a> .  For example, pay attention to such names and topics in the schedule. <br><br><ul><li>  Donald Whyte with a story about how using popular libraries, tricks and cunning to do mathematics 10 times faster, and the code - clear and supported. </li><li>  Andrei Popov about the collection of a huge amount of data and their analysis for the presence of threats. </li><li>  Efrem Matosyan in his report ‚ÄúMake Python fast again‚Äù will tell how to increase the performance of the daemon that processes messages from the bus. </li></ul><br>  A complete list of what is to be discussed for October 22 and 23 <a href="https://conf.python.ru/2018/abstracts/">here</a> , have time to join. <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/425471/">https://habr.com/ru/post/425471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425461/index.html">Devops and Security: An Interview with Seth Vargo and Liz Rice</a></li>
<li><a href="../425463/index.html">Cards from hexagons in Unity: water, objects of a relief and fortress walls</a></li>
<li><a href="../425465/index.html">As a designer to earn more, the perfect work tool and search for ideas</a></li>
<li><a href="../425467/index.html">Engines Renault D4F> B4D (aka SCe). Generation change. Glance motorist</a></li>
<li><a href="../425469/index.html">The author of Python no longer leads the development. Will this language make it better or worse?</a></li>
<li><a href="../425473/index.html">Conference about Python and about communication</a></li>
<li><a href="../425475/index.html">Universal Robots collaborative robots at the IMTS 2018 exhibition in Chicago</a></li>
<li><a href="../425477/index.html">Friday webinars from Skillbox: from choosing a programming language to finding your company</a></li>
<li><a href="../425479/index.html">Soon half of the calls will be from robots. Tip: do not answer (?)</a></li>
<li><a href="../425483/index.html">Reading for the weekend: 22 articles about the history of legendary audio companies and how they ‚Äúmake sound‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>