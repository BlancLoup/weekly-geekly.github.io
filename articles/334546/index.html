<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About Reflect API available language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Recently I heard some young front-tenders trying to explain to other young front-tenders what Reflect is in JavaScript. In the end, someone sai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About Reflect API available language</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/076/423/2f2/0764232f2001455d83c3ac48a68525e8.jpg"><br><br>  Hello!  Recently I heard some young front-tenders trying to explain to other young front-tenders what Reflect is in JavaScript.  In the end, someone said that this is the same thing as a proxy.  The situation reminded me of a joke: <br><br>  There are two miners: <br>  - Do you understand anything about this? <br>  - Well, I can explain. <br>  - This is understandable, but do you understand anything about this? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here and with Reflect in JS for someone the same situation turned out.  It seems to be saying something, but for what it is not clear.  In the end, I thought that it was worth telling it again in simple language with examples. <br><a name="habracut"></a><br>  First, let's define what reflection is in programming: <br>  Reflection / Reflect API is an API that provides the ability to conduct reverse engineering of classes, interfaces, functions, methods and modules. <br><br>  From here it becomes a little clearer what this API should be used for.  Reflection API exists in different programming languages ‚Äã‚Äãand, at times, is used to circumvent the limitations imposed by PL.  It is also used to develop various auxiliary utilities and to implement various patterns (such as Injection) and much more. <br><br>  For example, the Reflection API is in Java.  It is used to view information about classes, interfaces, methods, fields, constructors, and annotations during the execution of java programs.  For example, using Reflection in Java, you can use the OOP pattern - <a href="https://habrahabr.ru/post/75661/">Public Morozov</a> . <br><br>  In PHP, there is also the Reflection API, which allows you not only to do reverse engineering, but even allows you to receive doc-blocks of comments, which is used in various systems of auto-documentation. <br><br>  In JavaScript, Reflect is a built-in object that provides methods for intercepting JavaScript operations.  In essence, this is neymspace (like Math).  Reflect contains a set of functions that are called exactly the same as methods for Proxy. <br><br>  Some of these methods are the same as the corresponding methods of the Object or Function class.  JavaScript grows and turns into a large and complex PL.  Different things come to the language from other languages.  At present, Reflect API is not able to as much as in other PL.  Nevertheless, there are proposals for expansion, which are not yet included in the standard, but are already in use.  For example, Reflection Metadata. <br><br>  We can say that the Reflect namespace in JS is the result of code refactoring.  We have already used the capabilities of the Reflect API, just all of these features were embedded in the base Object class. <br><br><h2>  Reflect Metadata / Metadata Reflection </h2><br>  This API is designed to get information about objects in runtime.  This is a proposal that is not yet a standard.  Now actively used polyfil.  Today it is actively used in Angular.  Injects and decorators (anotator) are implemented using this API. <br><br>  Actually for the sake of Angular, extended decorators syntax was added to TypeScript.  One of the interesting features of decorators is the ability to obtain information about the type of the property or parameter being decorated.  For this to work, you need to connect the reflect-metadata library, which extends the standard Reflect object and enable the emitDecoratorMetadata option to the TS config.  After that, for properties that have at least one decorator, you can call Reflect.getMetadata with the key "design: type". <br><br><h2>  What is the difference between Reflect and Proxy? </h2><br>  <b>Reflect</b> is a set of useful methods for working with objects, half of which are rewritten ones that already exist from Object.  This was done in order to improve semantics and restore order, since Object is the base class, but it also contains a lot of methods that should not be in it.  Also, if you create an object with an empty prototype, then reflection methods disappear from you (I will show by example what this means). <br><br>  <b>Proxy</b> is a class that always creates a new object with installed handlers to intercept access.  It allows you to catch any actions with the object and modify them.  Reflect is often used to implement various logic.  Below on examples it will be clearly visible. <br><br><h2>  Use Cases </h2><br>  Well, consider how to use Reflect API.  Some examples have long been known, just for this purpose we are used to using methods from the Object class.  But, logically, it would be more correct to use them from the Reflect package (packages are terminology from Java). <br><br><h3>  Autogenerated object fields </h3><br>  We can create an object in which object fields will be created automatically during access to them. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> emptyObj = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>({}, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, key, receiver</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.has(target, key) || <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.set(target, key, emptyObj()), <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, key, receiver) ) } ) ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = emptyObj(); path.to.virtual.node.in.empty.object = <span class="hljs-number"><span class="hljs-number">123</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(path.to.virtual.node.in.empty.object); <span class="hljs-comment"><span class="hljs-comment">// 123</span></span></code> </pre> <br>  Everything is cool, but such an object cannot be serialized into JSON, we get an error.  Add a magic serialization method - toJSON <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.clear(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> emptyObj = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>({}, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, key, receiver</span></span></span><span class="hljs-function">) =&gt;</span></span> ( key == <span class="hljs-string"><span class="hljs-string">'toJSON'</span></span> ? <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> target : ( <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.has(target, key) || <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.set(target, key, emptyObj()), <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, key, receiver) ) ) } ) ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = emptyObj(); path.to.virtual.node.in.empty.object = <span class="hljs-number"><span class="hljs-number">123</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(path)); <span class="hljs-comment"><span class="hljs-comment">// {"to":{"virtual":{"node":{"in":{"empty":{"object":123}}}}}}</span></span></code> </pre><br><h3>  Dynamic constructor call </h3><br>  We have: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> F(...args)</code> </pre><br>  But we want to be able to dynamically call a constructor and create an object.  For this there is Reflect.construct: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.construct(F, args)</code> </pre><br>  It may be necessary for use in factories (OOP gays will understand).  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Old method function Greeting(name) { this.name = name } Greeting.prototype.greet = function() { return `Hello ${this.name}` } function greetingFactory(name) { var instance = Object.create(Greeting.prototype); Greeting.call(instance, name); return instance; } var obj = greetingFactory('Tuturu'); obj.greet();</span></span></code> </pre><br>  How do you spell it in 2017: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greeting</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name } greet() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string">`</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greetingFactory = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.construct(Greeting, [name]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = greetingFactory(<span class="hljs-string"><span class="hljs-string">'Tuturu'</span></span>); obj.greet();</code> </pre><br><h3>  Repeat jQuery behavior </h3><br>  The following line shows how jQuery can be done in 2 lines: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $ = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector.bind(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>); Element.prototype.on = Element.prototype.addEventListener;</code> </pre><br>  It is convenient if you need to quickly build something without dependencies, and writing long native constructs is lazy.  But in this implementation there is a minus - throws an exception when working with null: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( $(<span class="hljs-string"><span class="hljs-string">'some'</span></span>).innerHTML ); error <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>: Cannot read property <span class="hljs-string"><span class="hljs-string">'innerHTML'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Using Proxy and Reflect we can rewrite this example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $ = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">selector</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(selector)||Element, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, key</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, key) } ) ;</code> </pre><br>  Now, when we try to access the null properties, we simply get undefined: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( $(<span class="hljs-string"><span class="hljs-string">'some'</span></span>).innerHTML ); <span class="hljs-comment"><span class="hljs-comment">// undefined</span></span></code> </pre><br><h2>  So why use Reflect? </h2><br>  Reflect API is more convenient when handling errors.  For example, everyone knows the instruction: <br>  Object.defineProperty (obj, name, desc) <br><br>  In case of failure, an exception will be thrown.  But Reflect does not generate exceptions for anything and can return a boolean result: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, name, desc); <span class="hljs-comment"><span class="hljs-comment">// property defined successfully } catch (e) { // possible failure (and might accidentally catch the wrong exception) } /* --- OR --- */ if (Reflect.defineProperty(obj, name, desc)) { // success } else { // failure }</span></span></code> </pre><br>  This allows you to handle errors through conditions, rather than try-catch.  An example of using the Reflect API with error handling: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze({<span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> foo.bar; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) {}</code> </pre><br>  And now you can write like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze({<span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.deleteProperty(foo, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'ok'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'error'</span></span>); }</code> </pre><br>  But I must say that there are cases when Reflect also throws exceptions. <br><br><h2>  Some entries are shorter. </h2><br>  Without many words: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>.prototype.apply.call(func, obj, args) <span class="hljs-comment"><span class="hljs-comment">/* --- OR --- */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.apply.call(func, obj, args)</code> </pre><br><h2>  Behavior difference </h2><br>  Example without words: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// undefined Reflect.getPrototypeOf(1); // TypeError</span></span></code> </pre><br>  It seems to be all clear.  We conclude that it is better.  Reflect API is more logical. <br><br><h2>  Work with objects with an empty prototype </h2><br>  Given: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myObject = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); myObject.foo = <span class="hljs-number"><span class="hljs-number">123</span></span>; myObject.hasOwnProperty === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-comment"><span class="hljs-comment">// true //    : Object.prototype.hasOwnProperty.call( myObject, 'foo' ); // true</span></span></code> </pre><br>  As you can see, we no longer have reflection methods, for example, hasOwnProperty.  Therefore, we either use the old way, referring to the prototype of the base class, or refer to the Reflect API: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(myObject).includes(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br><h2>  findings </h2><br>  Reflect API is the result of refactoring.  This namespace contains reflection functions that were previously embedded in the base classes Object, Function ... The behavior and error handling has been changed.  In the future, this namespace will be expanded with other reflective tools.  Also Reflect API can be considered an integral part when working with Proxy (as can be seen from the examples above). </div><p>Source: <a href="https://habr.com/ru/post/334546/">https://habr.com/ru/post/334546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334534/index.html">Gigabit GOST VPN. Tss diamond</a></li>
<li><a href="../334536/index.html">Beginner's Guide to Progressive Web Applications and the Frontend</a></li>
<li><a href="../334538/index.html">Interview for a front-end JavaScript developer: best questions</a></li>
<li><a href="../334542/index.html">How to cross a hedgehog with a snake. We use GridView from Yii 2 in the project on Laravel</a></li>
<li><a href="../334544/index.html">Smok testing on a small project: how it started and what the results</a></li>
<li><a href="../334548/index.html">The unrealized potential of the Internet of Things</a></li>
<li><a href="../334550/index.html">Company Development with Open Source</a></li>
<li><a href="../334552/index.html">A quarter of a million for the "beetle": Microsoft is beginning an active struggle with bugs</a></li>
<li><a href="../334554/index.html">Characteristics of the PVS-Studio analyzer on the example of EFL Core Libraries, 10-15% of false positives</a></li>
<li><a href="../334556/index.html">Machine Learning for an Insurance Company: Improving the Model through Algorithm Optimization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>