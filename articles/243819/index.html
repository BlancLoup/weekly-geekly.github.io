<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In one run</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Among programming tasks, one often encounters the following: a sequence of elements of the same type is given (usually numbers), it is required to fin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In one run</h1><div class="post__text post__text-html js-mediator-article">  Among programming tasks, one often encounters the following: a sequence of elements of the same type is given (usually numbers), it is required to find some characteristic in one pass (standard deviation, number of minimum elements, continuous section with the largest amount ...) Additional restriction - the sequence can be very long and will not fit in the memory.  Other restrictions on the elements of the sequence, usually not imposed. <br>  With these tasks, everything is more or less clear: you need to find what is called the ‚Äúinductive extension‚Äù of the desired function at the Moscow State University and implement its calculation.  If it could not be found (the required amount of memory is too large), then the problem is not solved. <br>  But there are also other tasks.  They have additional restrictions on the elements of the sequence in the aggregate, and these restrictions have to be significantly used to solve (and they should not be checked).  The simplest such task looks like this: <br><br>  <i><b>Task 1. The sequence contains integers from 1 to N in an arbitrary order, but one of the numbers is omitted (the others are encountered exactly once).</b></i>  <i><b>N is unknown in advance.</b></i>  <i><b>Determine Missing Number</b></i> <br><br>  The solution is obvious: we look through the numbers, we find their number K and the sum S. According to the condition, N = K + 1, then the sum of the numbers from 1 to N will be equal to (K + 1) * (K + 2) / 2, and the missing number equals (K + 1) * (K + 2) / 2-S.  If for some reason you are afraid of overflows, then work with unsigned numbers (overflows are not terrible there - but be careful when calculating (K + 1) * (K + 2) / 2 :)), or instead of the amount, look for the XOR of all numbers. <br><a name="habracut"></a><br>  <i><b>Task 2. The sequence contains integers.</b></i>  <i><b>One of the numbers occurs exactly once, the rest - twice.</b></i>  <i><b>Find the number that occurs once.</b></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here, too, everything is simple: find the XOR of all numbers - it will be the answer.  In fact, if a bit in the desired number is zero, then in the whole sequence it will be equal to 1 in an even number of elements, and its value in XOR is zero.  Otherwise, similarly, its value in XOR is 1. Or, to put it simply, identical elements when summing up mutually destroy. <br><br>  Slightly complicate the task: <br>  <i><b>Task 3. The sequence contains integers.</b></i>  <i><b>The number X occurs once or twice, the other numbers three times.</b></i>  <i><b>Find the number X. For simplicity, we assume that the numbers are non-negative.</b></i> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  We proceed in the same way as the previous problem: translate each of the numbers into a ternary system: b = b [0] + 3 * b [1] +3 <sup>2</sup> * b [2] + ... For each digit, we find the sum of its values ‚Äã‚Äãmodulo 3 (we denote the sum s [0], s [1], s [2], ...).  In addition, count the numbers themselves. <br>  If the numbers in the sequence were 3 * k + 1, then X met once, and its value is s [0] + 3 * s [1] +3 <sup>2</sup> * s [2] + ... If the numbers were 3 * k + 2, in the set s [i], the units will have to be replaced by twos and vice versa: x [i] = (3-s [i])% 3, and X = x [0] + 3 * x [1] +3 <sup>2</sup> * x [2] + ... <br></div></div><br><br>  And if you take one more step? <br>  <i><b>Task 4. The sequence contains integers.</b></i>  <i><b>The number X occurs 1.2 or 3 times, the remaining numbers - 4 times.</b></i>  <i><b>Find the number X.</b></i> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  The previous approach will not work here: if we take the number system with base 4, and we find the sum of digits, then for the cases when X was met once or three times, everything will be fine.  But if X met twice, we will not be able to find out if the next digit was equal to 0 or 2 - the value of the sum si for this discharge will be zero in both cases.  What to do? <br>  In fact, the last time I lied to you.  There is absolutely no need to mess around with the ternary system - it was enough to count the sum of bits in each binary digit, and if it was divided by 3, then in X the corresponding bit was zero.  If not, then one. <br>  In this problem we do the same, but we check the divisibility by 4. For example, these problems can be solved like this: <br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindNotThree</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; seq</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>,b=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seq) { a^=~b&amp;c; b^=~a&amp;c; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a|b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindNotFour</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; seq</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">0</span></span>,b=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seq) { a^=b&amp;c; b^=c; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a|b; }</code> </pre> <br></div></div><br><br>  <i><b>Task 5. People are in a long line.</b></i>  <i><b>For each of them, except the last one, we recorded his name and the name of the one behind him.</b></i>  <i><b>The resulting records are mixed and recorded in the file.</b></i>  <i><b>Required for a single file view to determine the names of the first and last person.</b></i>  <i><b>It is known that these names are different (otherwise the task is unsolvable), but, in general, the names can be repeated.</b></i>  <i><b>Each person‚Äôs name consists of sixteen 8-bit characters.</b></i> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  We will treat each name as a bit line of 128 elements.  In each record we have two such lines - b [i] and c [i]. <br>  First, let's see what happens if for each i we find the sum s [i] of the differences b [i] -c [i] for all the records. <br>  Since all names except the first and last occur in the lines b and c, the same number of times, when summed, they mutually destroy each other, and the sum of the first and last names will remain in the sum.  The value of s [i], therefore, can be -1, 0, or 1. <br>  If s [i] = - 1, then the value of b [i] for the first name is 0, and for the second one, if s [i] = 1, then the values ‚Äã‚Äãwill be 1 and 0, respectively.  But if s [i] = 0, then we can only say that the values ‚Äã‚Äãof this bit in the first and last name are the same.  How would we find them? <br>  Suppose we know that for some k, our s [k] is nonzero.  What happens if we find the XOR values ‚Äã‚Äã(b [i] &amp; b [k]) ^ (c [i] &amp; c [k])? <br>  For all n names except the first and last, the expression n [i] &amp; n [k] will enter the sum twice (once as b, second time as c) and will give zero contribution.  If f is the first name and p is the last, then the sum will remain (f [i] &amp; f [k]) ^ (p [i] &amp; p [k]).  We are interested only in those bits for which f [i] = p [i] (we have already found the values ‚Äã‚Äãof the others).  Therefore, (f [i] &amp; f [k]) ^ (p [i] &amp; p [k]) = f [i] &amp; (f [k] ^ p [k]), and since s [k]! = 0 , then f [k] ^ p [k] = 1, and the total sum is equal to f [i]. <br>  Unfortunately, we cannot say in advance in which bit the names will differ.  Therefore, just in case, we will consider the sums <br>  (b [i] &amp; b [k]) ^ (c [i] &amp; c [k]) for all pairs i, k.  In total, we need 128 * 127/2 = 8128 one-bit counters and 128 two-bit counters (to calculate s [i]). <br>  For example, you can write processing as follows (we assume that both names in the record are transmitted in one byte array, written in a row): <br><pre> <code class="hljs matlab"> static byte[] FindDiffNames(IEnumerable&lt;byte[]&gt; seq) { const int LName=<span class="hljs-number"><span class="hljs-number">16</span></span>; byte[,] pairs=new byte[LName*<span class="hljs-number"><span class="hljs-number">8</span></span>,LName]; byte[] res=new byte[<span class="hljs-number"><span class="hljs-number">2</span></span>*LName]; foreach(byte[] name in seq) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;LName;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { res[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+LName]^=(byte)(name[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]&amp;res[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); res[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]^=(byte)(name[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]^name[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+LName]); res[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+LName]^=(byte)(name[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+LName]&amp;res[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int k=<span class="hljs-number"><span class="hljs-number">0</span></span>;k&lt;LName*<span class="hljs-number"><span class="hljs-number">8</span></span>;k++) { byte mask=(byte)(<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;(k&amp;<span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((name[k&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>]&amp;mask)!=<span class="hljs-number"><span class="hljs-number">0</span></span>) pairs[k,<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]^=name[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((name[LName+(k&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)]&amp;mask)!=<span class="hljs-number"><span class="hljs-number">0</span></span>) pairs[k,<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]^=name[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+LName]; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;LName;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { int b0=res[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>],b1=res[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+LName],s=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>&lt;LName*<span class="hljs-number"><span class="hljs-number">8</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) s|=pairs[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]; s&amp;=~b0; res[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]=(byte)((b0&amp;~b1)|s); res[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+LName]=(byte)((b0&amp;b1)|s); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br><br>  With this technique, you can also find the difference of sets, one of which is obtained from the other by adding two or even three elements (or adding two and removing one).  If the differences are stronger, you have to store the sum of conjunctions not only pairs, but also triples of bits.  And the XOR is not enough there - you have to count at least three-bit alternating sums. <br><br>  UPD: In the discussion of this problem in the comments <a href="http://habrahabr.ru/users/septim/" class="user_link">SeptiM</a> proposed a simpler solution.  We consider names as 128-bit integers (xi, yi), and count the sums S1 = sum (xi-yi), S2 = sum (xi ^ 2-yi ^ 2) (the first sum should be signed 129-bit, the second - sign 257-bit. Overflow is ignored, we work modulo 2 ^ 129 and 2 ^ 257, respectively).  It is clear that their values ‚Äã‚Äãare S1 = x1-xn, S2 = x1 ^ 2-xn ^ 2, where x1 is the first name, xn is the last.  From here we easily find x1 = (S1 + S2 / S1) / 2, xn = x1-S1. <br></div></div><br><br>  <b><i>Task 6. The sequence contains integers, more than half of which are equal to the same number X. In one view of the sequence, find this number.</i></b> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  Note that if we delete two different numbers from the sequence, the condition of the problem will remain true.  Therefore, we can cross out pairs of different numbers until all elements are equal to the same number.  This number will be X. <br>  To implement this method, we will get a cell in which some element of the sequence will be stored, and a counter ‚Äî how many copies of this element we have viewed and have not yet crossed out. <br>  When we read the next item, we have three options: <br>  - The counter is zero.  Put the read item in the cell, increase the counter by 1. <br>  - The element is equal to the cell value.  Increase the counter by 1. <br>  - Element is not equal to the cell value.  Decrease the counter by 1. <br>  After we look through the entire sequence, the desired number will appear in the cell. <br><br>  Unfortunately, it is not possible to generalize this solution to the case when the number X occurs more than in 1 / k cases (k is known).  We can also start a k-1 cell with a counter, delete k different elements at a time, we‚Äôll get a candidate for role X at the end of k-1, but we won‚Äôt be able to identify it - even the counter will not have the largest value.  But if we are allowed to make the second pass, we can count how many times each of the candidates met in a sequence, and issue the most frequent guaranteed. <br><br>  The original problem has another solution.  For each bit, we count how many times it equals 0, and how many - 1, and give a more frequent value.  Perhaps it will be possible to generalize it to the case when X occurs more than in 1/3 cases - let's count the statistics for each pair of bits ... what if it helps? <br></div></div><br><br>  The following two very similar tasks in one pass can hardly be solved.  But for them there is an interesting solution for the log (M) passes. <br>  <b><i>Task 7. In the sequence are written non-negative integers less than M, and it is known that each number occurs no more than once.</i></b>  <b><i>Find the smallest number that does not occur in this sequence.</i></b> <br>  <b><i>Problem 8. The sequence contains M + 1 integer non-negative number, all numbers are less than M. Find some number that occurs at least twice.</i></b> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  The solutions are almost the same.  We divide the range 0..M-1 into two or more parts.  For each part, we calculate how many numbers it has.  In the first task, we leave the earliest subrange, which has fewer numbers than its length, the second, any of the subranges, which has more numbers than its length.  The process is repeated until there is a range of one number.  It will be the answer. <br></div></div><br><br>  There is also a task that interests me for a long time, but whose solutions I do not know. <br>  <b><i>Problem 9. The sequence contains numbers from 1 to N in some order.</i></b>  <b><i>Each number occurs once.</i></b>  <b><i>N is known in advance.</i></b>  <b><i>It is required for one viewing of the sequence to determine the parity of the permutation written in it.</i></b>  <b><i>What is the minimum amount of memory required for this?</i></b> <br>  The paradox is that at any pre-selected moment we just have to remember 1 bit of information.  But after that it will be necessary to have N + 1 bits - in order to remember which elements go in the sequence after this moment. </div><p>Source: <a href="https://habr.com/ru/post/243819/">https://habr.com/ru/post/243819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243809/index.html">We make automated calls for notifications or polls.</a></li>
<li><a href="../243811/index.html">Preparatory work to help you conquer Kickstar [a few forgotten common truths]</a></li>
<li><a href="../243813/index.html">Interactive voice editing of text with the help of new speech technologies from Yandex</a></li>
<li><a href="../243815/index.html">Expressive JavaScript: Document Object Model (Document Object Model)</a></li>
<li><a href="../243817/index.html">Restoring order: how to organize work during the creation of the site. (Part 2)</a></li>
<li><a href="../243821/index.html">Markup math with CSS: Understand with calc</a></li>
<li><a href="../243829/index.html">Innovation or death: Why company executives need to be evangelists of new digital change</a></li>
<li><a href="../243831/index.html">New PyCharm 4 released: more yes better!</a></li>
<li><a href="../243833/index.html">Constructor Multiplo - create your robot</a></li>
<li><a href="../243837/index.html">Google distributes $ 300 per account to GAE for free</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>