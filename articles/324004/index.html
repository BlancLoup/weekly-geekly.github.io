<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New JavaScript: Asynchronous Iterators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this small post I want to talk about one interesting proposal (English proposal) in the standard EcmaScript. It will be about asynchronous iterator...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search"></a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings"></a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">猬锔</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">猬锔</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New JavaScript: Asynchronous Iterators</h1><div class="post__text post__text-html js-mediator-article"><p>  In this small post I want to talk about one interesting proposal (English proposal) in the standard EcmaScript.  It will be about asynchronous iterators, about what it is, how to use them, and why they are needed by a simple developer. </p><br><p> Asynchronous iterators are an extension of the capabilities of ordinary iterators, which, using a <code>for-of</code> / <code>for-await-of</code> loop, allow you to run through all elements of a collection. </p><a name="habracut"></a><br><p>  For a start, its worth explaining what I mean by generators, and what by iterators, since  I will often use these terms.  A generator is a function that returns an iterator, and an iterator is an object containing the <code>next()</code> method, which in turn returns the next value. </p><br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   yield 1 } const iterator = generator() //     console.log(iterator.next()) ///  { value: 1, done: false }</span></span></code> </pre> </div></div><br><p>  I would like to dwell on iterators in some detail and explain their meaning at present.  Modern JavaScript (standard ES6 / ES7) allows you to iterate over the values of a collection (for example, <code>Array</code> , <code>Set</code> , <code>Map</code> , etc.) alternately, without unnecessary fuss with indexes.  For this, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">an iterator protocol</a> was adopted, which is defined in the prototype of the collection using the <code>Symbol.iterator</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    //   Range function Range (start, stop) { this.start = start this.stop = stop } //  ,     //      ,       for-of Range.prototype[Symbol.iterator] = function *values () { for (let i = this.start; i &lt; this.stop; i++) { yield i } } //    const range = new Range(1, 5) //        [Symbol.iterator]() //      for (let number of range) { console.log(number) // 1, 2, 3, 4 }</span></span></code> </pre> <br><p>  Each iterator (in our case, this <code>range[Symbol.iterator]()</code> ) has a <code>next()</code> method that returns an object containing 2 fields: <code>value</code> and <code>done</code> , containing the current value and a flag indicating the end of the generator, respectively.  This object can be described with the following interface: </p><br><pre> <code class="javascript hljs">interface IteratorResult&lt;T&gt; { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: T; done: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>; }</code> </pre> <br><p>  More details about the generators can be read <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">on MDN</a> . </p><br><div class="spoiler">  <b class="spoiler_title">A little explanation</b> <div class="spoiler_text"><p>  By the way, if we already have an iterator and we want to walk through it using <code>for-of</code> , then we do not need to bring it back to our (or any other iterated) type, since  each iterator has the same <code>[Symbol.iterator]</code> method that returns <code>this</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iter = range[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]() assert.strictEqual(iter, iter[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]())</code> </pre> </div></div><br><p>  I hope everything is clear here.  Now a little more to say about asynchronous functions. </p><br><p>  In ES7, the <code>async</code> / <code>await</code> syntax was proposed.  In fact, it is sugar that allows you to work with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> in a pseudo-sync style: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(url) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json() } <span class="hljs-comment"><span class="hljs-comment">//  function request (url) { return fetch(url) .then(response =&gt; response.json()) }</span></span></code> </pre> <br><p>  The difference from the usual function is that the <code>async</code> function always returns a Promise, even if we do the usual <code>return 1</code> , we get a <code>Promise</code> , which when resolved returns <code>1</code> . </p><br><p>  Great, now finally go to asynchronous iterators. </p><br><p>  Following the asynchronous functions ( <code>async function () { ... }</code> ), <a href="https://github.com/tc39/proposal-async-iteration">asynchronous iterators</a> were <a href="https://github.com/tc39/proposal-async-iteration">proposed</a> that can be used inside these same functions: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createQueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... } async function handle (queue) { for await (let value of queue) { console.log(value) // 1, 2, ... } }</span></span></code> </pre> <br><p>  At the moment, asynchronous iterators are in <a href="https://github.com/tc39/proposals">sentences</a> , in the 3rd stage (candidate), which means that the syntax is stabilized and is waiting to be included in the standard.  This proposal has not yet been implemented in any JavaScript engine, but you can still try and play with it using the <a href="https://www.npmjs.com/package/babel-plugin-transform-async-generator-functions">babel-plugin-transform-async-generator-functions</a> <a href="http://babeljs.io/">Babel</a> plugin: </p><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"babel-preset-es2015-node"</span></span>: <span class="hljs-string"><span class="hljs-string">"路路路"</span></span>, <span class="hljs-string"><span class="hljs-string">"babel-preset-es2016"</span></span>: <span class="hljs-string"><span class="hljs-string">"路路路"</span></span>, <span class="hljs-string"><span class="hljs-string">"babel-preset-es2017"</span></span>: <span class="hljs-string"><span class="hljs-string">"路路路"</span></span>, <span class="hljs-string"><span class="hljs-string">"babel-plugin-transform-async-generator-functions"</span></span>: <span class="hljs-string"><span class="hljs-string">"路路路"</span></span> <span class="hljs-comment"><span class="hljs-comment">// 路路路 }, "babel": { "presets": [ "es2015-node", "es2016", "es2017" ], "plugins": [ "transform-async-generator-functions" ] }, // 路路路 }</span></span></code> </pre> <br><p>  <em>taken from the blog <a href="http://www.2ality.com/2016/10/asynchronous-iteration.html">2ality</a> , the full code with examples of use can be viewed in <a href="https://github.com/rauschma/async-iter-demo">rauschma / async-iter-demo</a></em> </p></div></div><br><p>  So, how do asynchronous iterators differ from ordinary ones?  As mentioned above, the iterator returns an <code>IteratorResult</code> value.  The asynchronous iterator always returns a <code>Promise&lt;IteratorResult&gt;</code> .  This means that in order to get the value and understand, you need to continue executing the cycle or not, you need to wait for the permission (resolve) of the promise, which will return the <code>IteratorResult</code> .  That is why a new <code>for-await-of</code> syntax was introduced, which does all this work. </p><br><p>  A legitimate question arises: why introduce a new syntax, why not return <code>IteratorResult&lt;Promise&gt;</code> , not <code>Promise&lt;IteratorResult&gt;</code> and wait ( <code>await ...</code> ) with his hands (I apologize for this strange expression)?  This is done for those cases where we cannot determine from the inside of a synchronous generator whether there is a next value or not.  For example, you need to go to a certain remote queue on the network and pick up the next value, if the queue is empty, then exit the cycle. </p><br><p>  Well, we figured it out, the last question remains - the use of asynchronous generators and iterators.  Everything is quite simple here: add the <code>async</code> keyword to the generator and we get an asynchronous generator: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    async function* queue () { //       while (true) { //   const task = await redis.lpop('tasks-queue') if (task === null) { //   ,      //    ,    Promise&lt;IteratorResult&gt; return } else { //   yield task } } } //     async function handle () { //     const tasks = queue() //      for await (const task of tasks) { //   console.log(task) } }</span></span></code> </pre> <br><p>  If we want our own structure to be asynchronously iterated using <code>for-await-of</code> , then we need to implement the <code>[Symbol.asyncIterator]</code> method: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyQueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name } MyQueue.prototype[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.asyncIterator] = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">values</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,      while (true) { const task = await redis.lpop(this.name) if (task === null) { return } else { yield task } } } async function handle () { const tasks = new MyQueue('tasks-queue') for await (const task of tasks) { console.log(task) } }</span></span></code> </pre> <br><p>  That's all.  I hope this article was interesting and at least to some extent useful.  Thanks for attention. </p><br><h2 id="ssylki">  Links </h2><br><ul><li>  <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Iteration_protocols">The Iterator protocol</a> ; </li><li>  <a href="https://github.com/tc39/proposal-async-iteration">Asynchronous Iterators for JavaScript</a> ; </li><li>  <a href="http://www.2ality.com/2016/10/asynchronous-iteration.html">ES proposal: asynchronous iteration</a> ; </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/324004/">https://habr.com/ru/post/324004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323992/index.html">Frequently used passwords: how not to get caught yourself and protect users</a></li>
<li><a href="../323994/index.html">How much does a cloud office cost</a></li>
<li><a href="../323996/index.html">On the trail of Cobalt: tactics of logical attack on ATMs in the investigation of Group-IB</a></li>
<li><a href="../324000/index.html">From engineer to iOS programmers</a></li>
<li><a href="../324002/index.html">VR-Design: User Interface</a></li>
<li><a href="../324006/index.html">Russian Code Cup challenges programmers again</a></li>
<li><a href="../324008/index.html">Citrix and Microsoft have integrated NetScaler Unified Gateway with Microsoft EMS</a></li>
<li><a href="../324010/index.html">File storage in the social network and other projects of the students of Innopolis University</a></li>
<li><a href="../324012/index.html">We saw the catalog of goods without touching relational algebra</a></li>
<li><a href="../324016/index.html">Network configuration in guest Ubuntu 16.04 Server on VirtualBox + Windows 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>