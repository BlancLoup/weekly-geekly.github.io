<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Position-independent code (PIC) in shared libraries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. My name is Marco, and I'm a system programmer at Badoo. I really like to thoroughly understand how things work, and the subtleties of the work of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Position-independent code (PIC) in shared libraries</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/d01/cce/d5e/d01cced5eb4848358e016d0e7adac959.png" alt="enter image description here"></p><br><p>  <em>Hey.</em>  <em>My name is Marco, and I'm a system programmer at Badoo.</em>  <em>I really like to thoroughly understand how things work, and the subtleties of the work of shared libraries in Linux is no exception.</em>  <em>I present to you the translation of just such an analysis.</em>  <em>Enjoy reading.</em> </p><a name="habracut"></a><br><p>  I <a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/">have already described the need for</a> special handling of shared libraries while loading them into the process address space.  In short, when the linker creates a shared library, it does not know in advance where it will be loaded in memory.  Because of this, to make links to data and code inside the library is problematic: it is not clear how to create a link so that it points to the right place after the library has been loaded. </p><br><p>  In Linux and ELF, there are two main ways to solve this problem: </p><br><ol><li>  Relocation at load time (load-time relocation). </li><li>  Address independent code (position-independent code (PIC)). </li></ol><br><p>  We <a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/">have already considered</a> relocation during loading.  And now consider the second approach - PIC. </p><br><p>  Initially, I planned to talk about x86 and x64 (also known as x86-64), but the article kept growing and grew, and I decided that I needed to be more practical.  So in this article I‚Äôll only talk about x86, and x64 will be discussed in another (I hope, much shorter).  I took the older x86 architecture, since, unlike x64, it was developed without PIC, and the PIC implementation is a bit more complicated. </p><br><h3 id="problemy-relokacii-vo-vremya-zagruzki">  Relocation problems at boot time </h3><br><p>  As we saw in the previous article, relocation during boot is a very simple and straightforward method.  And it works.  But PIC is much more popular at the moment and is the recommended way to create shared libraries.  Why, you ask? </p><br><p>  There are several problems with relocation: it takes time and the text section (containing machine code) is no longer suitable for separation between processes. </p><br><p>  Let's talk first about the performance problem.  If the library was linked with information about symbols that require relocation, then relocation itself when loading will take some time.  You might think that this time should not be long, because the loader does not need to run through all the source code - just walk through these same symbols.  But if some complicated program loads several large libraries, the overhead head accumulates very quickly - and as a result we get quite noticeable delay at the start of the program. </p><br><p>  Well, and a few words about the problem of impossibility to share a text-section.  She is somewhat more serious.  One of the main tasks of the existence of shared libraries is to save on memory.  Some libraries are used by several applications at the same time.  If the text section (where the machine code is located) can be loaded into memory only once (and then added to other processes using mmap), then a fairly large amount of RAM can be saved.  But this is not possible when using relocation, since the text section must be changed at boot time to substitute the correct pointers for a particular process.  It turns out that for each process using the library, you have to keep a full copy of this library in memory <a href="https://habr.com/ru/company/badoo/blog/323904/">[1]</a> .  No separation occurs. </p><br><p>  Moreover, keeping the text section with write permissions (and it must be with write permissions so that the downloader can correct the links) is bad from a security point of view.  Making an exploit in this case is much easier. </p><br><p>  As we will see, the PIC almost completely solves these problems. </p><br><h3 id="vvedenie">  Introduction </h3><br><p>  The idea behind the PIC is very simple - adding an intermediate layer to the code for all references to global objects and functions.  If you intelligently use some artifacts of linking and loading processes, you can make the text section really independent of the address where it will be put;  we will be able to map the segment using mmap to various addresses in the process address space, and we will not need to change any bits in it.  In the next few sections I will show how this can be achieved. </p><br><h3 id="klyuchevaya-ideya-1-smeschenie-mezhdu-sekciyami-text-i-data">  Key idea number 1.  Offset between text and data sections </h3><br><p>  One of the key ideas on which the PIC is based is the offset between the text and data sections, the size of which is known to the linker during linking.  When the linker combines several object files, it assembles their sections together (for example, all text sections are combined into one large text section).  Thus, linker sizes and sections are known to the linker. </p><br><p>  For example, right after the text section, the data section may follow, and in this case the offset from any instruction from the text section to the beginning of the data section will be equal to the size of the text section minus the offset to this instruction from the beginning of the text section.  And all these dimensions and offsets are known to the linker. </p><br><p><img src="https://habrastorage.org/files/151/bc1/202/151bc12028b54d9c846a3e9120541b89.png" alt="enter image description here"></p><br><p>  In the diagram above, the code section was uploaded to some address (unknown to us at the time of linking) 0xXXXX0000 (X literally means "no matter what is there"), and the data section immediately after it at 0xXXXXF000.  In this case, if some instruction on offset 0x80 in the code section wants to indicate something in the data section, the linker knows the relative offset (0xEF80 in this case) and can add it to the instruction. </p><br><p>  Note that nothing will change if another section is jammed between the code and data sections, or if the data section is located before the code section.  Since the linker knows the sizes of all sections and decides where to put them, the idea remains the same. </p><br><h3 id="klyuchevaya-ideya-2-delaem-tak-chtoby-smeschenie-otnositelno-ip-rabotalo-na-x86">  Key idea number 2.  Making the offset relative to IP work on x86 </h3><br><p>  Everything described above works, if we can use relative displacements at all.  After all, references to data (for example, as in the MOV instructions) on x86 require absolute addresses.  So what do we do? </p><br><p>  If we have a relative address, and we need an absolute address, we lack the value of the instruction pointer, or the instruction counter (IP).  Indeed, by definition, a relative address is relative to IP.  On x86, there are no instructions for getting an IP, but we can use a simple trick.  Here is a small assembly pseudocode that demonstrates it: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">call</span></span> TMPLABEL TMPLABEL: pop ebx</code> </pre> <br><p>  What's going on here: </p><br><ol><li>  The processor executes the instruction call TMPLABEL, which stores the address of the next instruction on the stack (pop ebx), and then jumps to the label. </li><li>  Since the label instruction is pop ebx, it is executed next.  This instruction pulls a value from the stack to ebx.  But this is the address of the instruction itself.  So ebx, in fact, now contains an IP value. </li></ol><br><h3 id="globalnaya-tablica-smescheniy-got">  Global Offset Table (GOT) </h3><br><p>  Now we have everything to finally talk about how x86 address independent addressing is implemented.  And it is implemented using a global offset table (global offset table or GOT). </p><br><p>  GOT is just a table with addresses, which is located in the data section.  Suppose that some instruction in the code section wants to refer to a variable.  Instead of accessing it via an absolute address (which will require relocation), it accesses the entry in the GOT.  Since GOT has a strictly defined place in the data section, and the linker knows about it, this appeal is also relative.  And the GOT entry already contains the absolute address of the variable: </p><br><p><img src="https://habrastorage.org/files/3d3/5ed/510/3d35ed51073a4d989de849a4291f93f2.png" alt="enter image description here"></p><br><p>  In a pseudo-assembler, this will look like a substitute for absolute addressing. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//     edx mov edx, [ADDR_OF_VAR]</span></span></code> </pre> <br><p>  for addressing through the register and a small pad: </p><br><ol><li><p>  Somehow find the GOT address and put it in ebx: </p><br><p>  lea ebx, ADDR_OF_GOT </p><br></li><li><p>  Suppose the variable address (ADDR_OF_VAR) is located at offset 0x10 in the GOT.  In this case, the following instruction will put ADDR_OF_VAR in edx: </p><br><p>  mov edx, DWORD PTR [ebx + 0x10] </p><br></li><li><p>  Finally, let's turn to the variable and put its value in edx: </p><br><p>  mov edx, DWORD PTR [edx] </p><br></li></ol><br><p>  Thus, we got rid of relocation in the code section by redirecting calls through the GOT.  But we also created a relocation in the data section.  Why?  Because the GOT must in any case contain the absolute address of the variable for the above scheme to work.  So where is the profit? </p><br><p>  A profit, it turns out, a lot.  Relocation in the data-section is associated with a much smaller number of problems than relocation in the code section.  There are two reasons for this, corresponding to two problems arising during relocation during loading. </p><br><ol><li>  Relocations in the code section are required for each variable call, whereas relocations in the GOT are just for each variable.  Variable accesses are usually noticeably larger than variables, so this is more efficient. </li><li>  The data section is already available for recording and is not shared between processes, so that relocations in it do not harm anything.  But the fact that there will no longer be relocations in the code section allows you to make this section read-only and share it between processes. </li></ol><br><h3 id="pic-s-obrascheniyami-cherez-got-primer">  PIC with hits via GOT (example) </h3><br><p>  Now I will show a full-fledged example that demonstrates the PIC mechanics: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> myglob = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ml_func</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> myglob + a + b; }</code> </pre> <br><p>  This code block will be compiled into a shared library (using the -fpic and -shared flags) libmlpic_dataonly.so. </p><br><p>  Let's see what the compiler generated, focusing on the ml_func function: </p><br><pre> <code class="hljs css">0000043<span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">ml_func</span></span>&gt;: 43<span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span>: 55 <span class="hljs-selector-tag"><span class="hljs-selector-tag">push</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ebp</span></span> 43<span class="hljs-selector-tag"><span class="hljs-selector-tag">d</span></span>: 89 <span class="hljs-selector-tag"><span class="hljs-selector-tag">e5</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ebp</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">esp</span></span> 43<span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">e8</span></span> 16 00 00 00 <span class="hljs-selector-tag"><span class="hljs-selector-tag">call</span></span> 45<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> &lt;__<span class="hljs-selector-tag"><span class="hljs-selector-tag">i686</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.get_pc_thunk</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cx</span></span>&gt; 444: 81 <span class="hljs-selector-tag"><span class="hljs-selector-tag">c1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">b0</span></span> 1<span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> 00 00 <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ecx</span></span>,0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1bb0</span></span> 44<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>: 8<span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> 81 <span class="hljs-selector-tag"><span class="hljs-selector-tag">f0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ff</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ff</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ff</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ecx-0x10]</span></span> 450: 8<span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> 00 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[eax]</span></span> 452: 03 45 08 <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp+0x8]</span></span> 455: 03 45 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp+0xc]</span></span> 458: 5<span class="hljs-selector-tag"><span class="hljs-selector-tag">d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">pop</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ebp</span></span> 459: <span class="hljs-selector-tag"><span class="hljs-selector-tag">c3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span> 0000045<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> &lt;__<span class="hljs-selector-tag"><span class="hljs-selector-tag">i686</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.get_pc_thunk</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cx</span></span>&gt;: 45<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>: 8<span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> 24 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ecx</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[esp]</span></span> 45<span class="hljs-selector-tag"><span class="hljs-selector-tag">d</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">c3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre> <br><p>  I will point to the address of the instructions (the leftmost number in the output).  This address is the offset from the address to which the library was mapped. </p><br><ul><li>  At 43f, the address of the next instruction is placed in ecx in the same way that was described above in the section ‚ÄúKey idea number 2‚Äù. </li><li>  At 444, the known offset from instruction to GOT is put in ecx.  Thus, ecx now serves as a pointer to GOT. </li><li>  At 44a, the value from [ecx - 0x10], which is the entry from GOT, is taken and put in eax.  This is the address of the myglob variable. </li><li>  At 450, we already take the value of myglob and put it in eax. </li><li>  Next, the parameters a and b are added to myglob, and the value is returned (so that we leave it in eax). </li></ul><br><p>  Also with the help of readelf -S you can find out where the linker put the GOT: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Section</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Headers</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[Nr]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Name</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Type</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Addr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Off</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Size</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ES</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Flg</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Lk</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Inf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Al</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">snip</span></span>&gt; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[19]</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.got</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PROGBITS</span></span> 00001<span class="hljs-selector-tag"><span class="hljs-selector-tag">fe4</span></span> 000<span class="hljs-selector-tag"><span class="hljs-selector-tag">fe4</span></span> 000010 04 <span class="hljs-selector-tag"><span class="hljs-selector-tag">WA</span></span> 0 0 4 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[20]</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.got</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.plt</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PROGBITS</span></span> 00001<span class="hljs-selector-tag"><span class="hljs-selector-tag">ff4</span></span> 000<span class="hljs-selector-tag"><span class="hljs-selector-tag">ff4</span></span> 000014 04 <span class="hljs-selector-tag"><span class="hljs-selector-tag">WA</span></span> 0 0 4 &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">snip</span></span>&gt;</code> </pre> <br><p>  Let's get a calculator and check the compiler.  We are looking for myglob.  As I mentioned above, calling __i686.get_pc_thunk.cx puts the address of the next instruction in ecx.  This is 0x444 <a href="https://habr.com/ru/company/badoo/blog/323904/">[2]</a> .  The following instruction adds 0x1bb0 to it - and as a result in ecx we get 0x1ff4.  Finally, to get the GOT element that contains the address myglob, do [ecx - 0x10].  The element thus has an address of 0x1fe4, and this is the first element in the GOT, according to the section header. </p><br><p>  Why is there another section, the name of which begins with .got, I will tell later <a href="https://habr.com/ru/company/badoo/blog/323904/">[3]</a> .  Note that the compiler decided to put the ecx address after the GOT, and then use a negative offset.  It‚Äôs okay if everything fits together.  And so far everything is converging. </p><br><p>  But there is one thing that we still lack.  How exactly does the address of myglob appear in the GOT element at 0x1fe4?  Recall that I mentioned relocation, so let's find it: </p><br><pre> <code class="hljs pgsql">&gt; readelf -r libmlpic_dataonly.so Relocation section <span class="hljs-string"><span class="hljs-string">'.rel.dyn'</span></span> at <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-number"><span class="hljs-number">0x2dc</span></span> contains <span class="hljs-number"><span class="hljs-number">5</span></span> entries: <span class="hljs-keyword"><span class="hljs-keyword">Offset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Info</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Sym.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> Sym. <span class="hljs-type"><span class="hljs-type">Name</span></span> <span class="hljs-number"><span class="hljs-number">00002008</span></span> <span class="hljs-number"><span class="hljs-number">00000008</span></span> R_386_RELATIVE <span class="hljs-number"><span class="hljs-number">00001</span></span>fe4 <span class="hljs-number"><span class="hljs-number">00000406</span></span> R_386_GLOB_DAT <span class="hljs-number"><span class="hljs-number">0000200</span></span>c myglob &lt;snip&gt;</code> </pre> <br><p>  Here it is, the relocation for myglob, pointing to the address 0x1fe4, as we expected.  The relocation is of the type R_386_GLOB_DAT, which simply says to the loader: ‚ÄúPut the real value of the simpol (that is, its address) at the given offset‚Äù.  Now everything is clear.  It remains only to see how it all looks when you load the library.  We can do this by creating a simple binary (driver) that links to libmlpic_dataonly.so and calls ml_func, and running it through gdb. </p><br><pre> <code class="hljs delphi">&gt; gdb driver [...] skipping output (gdb) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> environment LD_LIBRARY_PATH=. (gdb) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> ml_func [...] (gdb) run Starting <span class="hljs-keyword"><span class="hljs-keyword">program</span></span>: [...]pic_tests/driver Breakpoint <span class="hljs-number"><span class="hljs-number">1</span></span>, ml_func (a=<span class="hljs-number"><span class="hljs-number">1</span></span>, b=<span class="hljs-number"><span class="hljs-number">1</span></span>) at ml_reloc_dataonly.c:<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> return myglob + a + b; (gdb) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> disassembly-flavor intel (gdb) disas ml_func Dump <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assembler</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ml_func</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>x0013143c &lt;+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: push ebp <span class="hljs-number"><span class="hljs-number">0</span></span>x0013143d &lt;+<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;: mov ebp,esp <span class="hljs-number"><span class="hljs-number">0</span></span>x0013143f &lt;+<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;: call <span class="hljs-number"><span class="hljs-number">0</span></span>x13145a &lt;__i686.get_pc_thunk.cx&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x00131444 &lt;+<span class="hljs-number"><span class="hljs-number">8</span></span>&gt;: add ecx,<span class="hljs-number"><span class="hljs-number">0</span></span>x1bb0 =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x0013144a &lt;+<span class="hljs-number"><span class="hljs-number">14</span></span>&gt;: mov eax,DWORD PTR [ecx-<span class="hljs-number"><span class="hljs-number">0</span></span>x10] <span class="hljs-number"><span class="hljs-number">0</span></span>x00131450 &lt;+<span class="hljs-number"><span class="hljs-number">20</span></span>&gt;: mov eax,DWORD PTR [eax] <span class="hljs-number"><span class="hljs-number">0</span></span>x00131452 &lt;+<span class="hljs-number"><span class="hljs-number">22</span></span>&gt;: add eax,DWORD PTR [ebp+<span class="hljs-number"><span class="hljs-number">0</span></span>x8] <span class="hljs-number"><span class="hljs-number">0</span></span>x00131455 &lt;+<span class="hljs-number"><span class="hljs-number">25</span></span>&gt;: add eax,DWORD PTR [ebp+<span class="hljs-number"><span class="hljs-number">0</span></span>xc] <span class="hljs-number"><span class="hljs-number">0</span></span>x00131458 &lt;+<span class="hljs-number"><span class="hljs-number">28</span></span>&gt;: pop ebp <span class="hljs-number"><span class="hljs-number">0</span></span>x00131459 &lt;+<span class="hljs-number"><span class="hljs-number">29</span></span>&gt;: ret <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assembler</span></span> dump. (gdb) i registers eax <span class="hljs-number"><span class="hljs-number">0</span></span>x1 <span class="hljs-number"><span class="hljs-number">1</span></span> ecx <span class="hljs-number"><span class="hljs-number">0</span></span>x132ff4 <span class="hljs-number"><span class="hljs-number">1257460</span></span> [...] skipping output</code> </pre> <br><p>  Debagger logged into ml_func and settled on IP 0x0013144a <a href="https://habr.com/ru/company/badoo/blog/323904/">[4]</a> .  We see that ecx is 0x132ff4 (instruction address plus 0x1bb0).  Note that at the moment, during operation, these are all absolute addresses - the library is already loaded into the process address space. </p><br><p>  So, the GOT element with myglob should be on [ecx - 0x10].  Let's check: </p><br><pre> <code class="hljs go">(gdb) x <span class="hljs-number"><span class="hljs-number">0x132f</span></span>e4 <span class="hljs-number"><span class="hljs-number">0x132f</span></span>e4: <span class="hljs-number"><span class="hljs-number">0x0013300c</span></span></code> </pre> <br><p>  That is, we expect that 0x0013300c is the address of myglob.  Checking: </p><br><pre> <code class="hljs pgsql">(gdb) p &amp;myglob <span class="hljs-meta"><span class="hljs-meta">$1</span></span> = (<span class="hljs-type"><span class="hljs-type">int</span></span> *) <span class="hljs-number"><span class="hljs-number">0x13300c</span></span></code> </pre> <br><p>  And there is! </p><br><h3 id="vyzov-funkciy-v-pic">  Calling functions in the PIC </h3><br><p>  So, we saw how the PIC works for data addresses.  But what about the features?  Theoretically, the same way will work for functions.  Instead of the call containing the address of the function, let it contain the address of the element from the GOT, and the element will already be filled at boot time. </p><br><p>  But the function call in the PIC does not work that way, in reality everything is somewhat more complicated.  Before I explain exactly how, in a nutshell I will talk about the motivation for choosing such a mechanism. </p><br><h3 id="optimizaciya-lenivyy-baynding">  Optimization: Lazy Buying </h3><br><p>  When the shared library uses a function, the real address of this function is not yet known.  The definition of the real address is called binding (binding), and this is what the loader does when it loads the shared library into the process address space.  Binding is not trivial, since the loader needs to look for function symbols in special tables <a href="https://habr.com/ru/company/badoo/blog/323904/">[5]</a> . </p><br><p>  Thus, the determination of the real address of each function takes some time (not so much time, but since the function calls can be much larger than the data, the duration of this process increases).  Moreover, in most cases this is done in vain, since with a normal program launch only a small part of the functions will be called (think how many calls are required only when errors or some special conditions occur). </p><br><p>  To speed up this process, a clever ‚Äúlazy‚Äù buyding scheme was invented.  ‚ÄúLazy‚Äù is a generic term for IT optimization, whereby any work is postponed until the very last moment.  The point of this optimization is not to do extra work, which may not be necessary.  Examples of such "lazy" optimization are the copy-on-write mechanism and <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">"lazy" calculations</a> . </p><br><p>  The ‚Äúlazy‚Äù scheme is implemented by adding another level of addressing - PLT. </p><br><h3 id="procedure-linkage-table-plt">  Procedure Linkage Table (PLT) </h3><br><p>  PLT is a part of the text section in a binary consisting of a set of elements (one element per external function that the library calls).  Each element in PLT is a small piece of executable machine code.  Instead of calling the function, a piece of PLT code is called directly, which already calls the function itself.  This approach is often called the <a href="http://en.wikipedia.org/wiki/Trampoline_%2528computing%2529">"springboard</a> . <a href="http://en.wikipedia.org/wiki/Trampoline_%2528computing%2529">"</a>  Each element from the PLT has its own element in the GOT, which contains the actual offset for the function.  After the bootloader detects it, of course. </p><br><p>  At first glance, everything is rather confusing, but I hope that soon everything will become clearer - in the following sections I will discuss the details with diagrams. </p><br><p>  As I already mentioned, PLT allows you to do a "lazy" definition of addresses of functions.  At the moment when the shared library is loaded for the first time, the real addresses of the functions have not yet been determined: </p><br><p><img src="https://habrastorage.org/files/51f/0ca/39e/51f0ca39ecf744cf93b3f66b9c824e66.png" alt="enter image description here"></p><br><p>  Explanation: </p><br><ul><li>  The code calls the func function.  The compiler translates this call into a call to func @ plt, which is one of the PLT elements. </li><li>  The PLT consists of a special first element followed by several identically structured elements, one for each function. </li><li>  All elements of PLT, except the first, contain the following parts: <br>  ‚Ä¢ jump to the address specified in the corresponding element from the GOT; <br>  ‚Ä¢ preparation of arguments for the "definition" method; <br>  ‚Ä¢ calling the ‚Äúdefinition‚Äù method, which is in the first PLT element. </li><li>  The first element of PLT is a call to the ‚Äúdefinition‚Äù method, which is located in the code of the loader itself <a href="https://habr.com/ru/company/badoo/blog/323904/">[6]</a> .  This method determines the real address of the function (more on this - below). </li><li>  Before the real address of the function is determined, the Nth element of the GOT simply points to the address after the jump.  That is why the arrow on the diagram is highlighted in a different color - this is not a real jump, but simply a pointer. </li></ul><br><p>  What happens after func is called the first time: </p><br><ul><li>  PLT [n] is called - and the jump to the address from GOT [n] occurs. </li><li>  This address points back to PLT [n], to the place where the arguments are prepared for the ‚Äúdefinition‚Äù method. </li><li>  The method is being invoked. </li><li>  The method determines the real address of the function func, puts it in GOT [n] and calls func. </li></ul><br><p>  After the first time, the diagram looks a bit different: </p><br><p><img src="https://habrastorage.org/files/7b4/005/b63/7b4005b6396442e794ebf58b23d85002.png" alt="enter image description here"></p><br><p>  Note that GOT [n] now points to real func <a href="&amp;xid=17259,15700022,15700186,15700190,15700248,15700253&amp;usg=ALkJrhg7jDmEqQDAFc-CpZKJIeaLn8XVKA#7-ya-polozhil-func-v-otdelnuyu-sekciyu-hotya-v-teorii-eto-mozhet-byt-ta-sekciya-gde-proishodit-vyzov-func-to-est-v-toy-zhe-samoy-razdelyaemoy-biblioteke-razdel-dopolnitelno-v-etoy-state">[7]</a> instead of pointing back to PLT.  So when the function is called again, the following happens: </p><br><ul><li>  It calls PLT [n] and jumps to the address from GOT [n]. </li><li>  GOT [n] points to func, so func is simply called. </li></ul><br><p>  In other words, func is now simply called without using the "definition" method and without an extra jump.  This mechanism allows you to make a "lazy" definition of the addresses of functions and not to make any definition for those functions that are not called. </p><br><p>  Please note that the library is completely independent of the address where it will be loaded, because the only place where the absolute address is used is GOT, and it is located in the data section and will be relocated during boot by the loader.  Even PLT does not depend on the download address, so that it can be in the read-only text section. </p><br><p>  I do not go into the details of the ‚Äúdefinition‚Äù method, but this is not so important.  The method is just a piece of low-level code in the loader that does its job.  Arguments that are prepared before calling the method, let him know what address of the function to determine and where to place the result. </p><br><h3 id="pic-s-vyzovom-funkcii-cherez-plt-i-got-primer">  PIC with function call via PLT and GOT (example) </h3><br><p>  Well, in order to back up the theory with practice, consider an example that demonstrates a function call using the method described above. </p><br><p>  Here is the shared library code: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> myglob = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ml_util_func</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ml_func</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = b + ml_util_func(a); myglob += c; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b + myglob; }</code> </pre> <br><p>  This code will be compiled in libmlpic.so, and we will focus on calling ml_util_func from ml_func.  Disassemble ml_func: </p><br><pre> <code class="hljs css">00000477 &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">ml_func</span></span>&gt;: 477: 55 <span class="hljs-selector-tag"><span class="hljs-selector-tag">push</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ebp</span></span> 478: 89 <span class="hljs-selector-tag"><span class="hljs-selector-tag">e5</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ebp</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">esp</span></span> 47<span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>: 53 <span class="hljs-selector-tag"><span class="hljs-selector-tag">push</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ebx</span></span> 47<span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span>: 83 <span class="hljs-selector-tag"><span class="hljs-selector-tag">ec</span></span> 24 <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">esp</span></span>,0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x24</span></span> 47<span class="hljs-selector-tag"><span class="hljs-selector-tag">e</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">e8</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">e4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ff</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ff</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ff</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">call</span></span> 467 &lt;__<span class="hljs-selector-tag"><span class="hljs-selector-tag">i686</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.get_pc_thunk</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bx</span></span>&gt; 483: 81 <span class="hljs-selector-tag"><span class="hljs-selector-tag">c3</span></span> 71 1<span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> 00 00 <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ebx</span></span>,0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1b71</span></span> 489: 8<span class="hljs-selector-tag"><span class="hljs-selector-tag">b</span></span> 45 08 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp+0x8]</span></span> 48<span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span>: 89 04 24 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[esp]</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> 48<span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">e8</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ff</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ff</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ff</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">call</span></span> 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">ml_util_func</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">plt</span></span>&gt; &lt;... snip more code&gt;</code> </pre> <br><p>  The interesting part is the call to ml_util_func @ plt.  Notice also that the GOT address is in ebx.  This is what ml_util_func @ plt looks like (located in the .plt section with permissions to execute): </p><br><pre> <code class="hljs xml">000003a0 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ml_util_func@plt</span></span></span><span class="hljs-tag">&gt;</span></span>: 3a0: ff a3 14 00 00 00 jmp DWORD PTR [ebx+0x14] 3a6: 68 10 00 00 00 push 0x10 3ab: e9 c0 ff ff ff jmp 370 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">_init+0x30</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Recall that each PLT element consists of three parts: </p><br><ul><li>  Jump to the address from GOT (this is a jump to [ebx + 0x14]). </li><li>  Preparing arguments for the "definition" method. </li><li>  Calling the method of "determination". </li></ul><br><p>  The method of "determination" (element 0 in PLT) is located at 0x370, but it does not interest us now.  It is much more interesting to see what GOT contains.  To do this, we again need a calculator. </p><br><p>  The trick for getting the current IP in ml_func was done at 0x483, and we added 0x1b71 to it.  So GOT is located at 0x1ff4.  We can see what is there using readelf <a href="https://habr.com/ru/company/badoo/blog/323904/">[8]</a> : </p><br><pre> <code class="hljs javascript">&gt; readelf -x .got.plt libmlpic.so Hex dump <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> section <span class="hljs-string"><span class="hljs-string">'.got.plt'</span></span>: <span class="hljs-number"><span class="hljs-number">0x00001ff4</span></span> <span class="hljs-number"><span class="hljs-number">241</span></span>f0000 <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">86030000</span></span> $............... <span class="hljs-number"><span class="hljs-number">0x00002004</span></span> <span class="hljs-number"><span class="hljs-number">96030000</span></span> a6030000 ........</code> </pre> <br><p>  The entry in the GOT for ml_util_func @ plt seems to be at the offset + 0x14, or 0x2008.  Judging by the conclusion above, the word at this address has the value 0x3a6, and this is the address of the push-instruction in ml_util_func @ plt. </p><br><p>  To help the bootloader do its job, an entry has been added to the GOT with the address of the place in the GOT where the ml_util_func address should be written: </p><br><pre> <code class="hljs delphi">&gt; readelf -r libmlpic.so [...] snip output Relocation section <span class="hljs-string"><span class="hljs-string">'.rel.plt'</span></span> at offset <span class="hljs-number"><span class="hljs-number">0</span></span>x328 contains <span class="hljs-number"><span class="hljs-number">3</span></span> entries: Offset Info <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Sym.Value Sym. <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> <span class="hljs-number"><span class="hljs-number">00002000</span></span> <span class="hljs-number"><span class="hljs-number">00000107</span></span> R_386_JUMP_SLOT <span class="hljs-number"><span class="hljs-number">00000000</span></span> __cxa_finalize <span class="hljs-number"><span class="hljs-number">00002004</span></span> <span class="hljs-number"><span class="hljs-number">00000207</span></span> R_386_JUMP_SLOT <span class="hljs-number"><span class="hljs-number">00000000</span></span> __gmon_start__ <span class="hljs-number"><span class="hljs-number">00002008</span></span> <span class="hljs-number"><span class="hljs-number">00000707</span></span> R_386_JUMP_SLOT <span class="hljs-number"><span class="hljs-number">0000046</span></span>c ml_util_func</code> </pre> <br><p>  The last line means that the loader needs to put the address of the ml_util_func character in 0x2008 (and this, in turn, is the GOT element for this function). </p><br><p>  It would be cool to see how this modification happens in the GOT.  To do this, use GDB again. </p><br><pre> <code class="hljs swift">&gt; gdb driver [...] skipping output (gdb) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> environment <span class="hljs-type"><span class="hljs-type">LD_LIBRARY_PATH</span></span>=. (gdb) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> ml_func <span class="hljs-type"><span class="hljs-type">Breakpoint</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> at <span class="hljs-number"><span class="hljs-number">0x80483c0</span></span> (gdb) run <span class="hljs-type"><span class="hljs-type">Starting</span></span> program: /pic_tests/driver <span class="hljs-type"><span class="hljs-type">Breakpoint</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, ml_func (a=<span class="hljs-number"><span class="hljs-number">1</span></span>, b=<span class="hljs-number"><span class="hljs-number">1</span></span>) at ml_main.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> int <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = b + ml_util_func(a); (gdb)</code> </pre> <br><p>  We are now in front of the first call to ml_util_func.  Recall that the GOT address is in ebx.  Let's see what is there: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">gdb</span></span>) i registers ebx ebx <span class="hljs-number"><span class="hljs-number">0</span></span>x132ff4</code> </pre> <br><p>  The offset for the item we need is at [ebx + 0x14]: </p><br><pre> <code class="hljs">(gdb) x/w 0x133008 0x133008: 0x001313a6</code> </pre> <br><p>  Yes, ends at 0x3a6.  It looks right.  Now let's take a step to call ml_util_func and see again: </p><br><pre> <code class="hljs swift">(gdb) step ml_util_func (a=<span class="hljs-number"><span class="hljs-number">1</span></span>) at ml_main.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>; (gdb) x/w <span class="hljs-number"><span class="hljs-number">0x133008</span></span> <span class="hljs-number"><span class="hljs-number">0x133008</span></span>: <span class="hljs-number"><span class="hljs-number">0x0013146c</span></span></code> </pre> <br><p>  The value at 0x133008 has changed.  It turns out that 0x0013146c is the real address ml_util_func, which was put there by the loader: </p><br><pre> <code class="hljs perl">(gdb) p &amp;ml_util_func $1 = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)) <span class="hljs-number"><span class="hljs-number">0x13146c</span></span> &lt;ml_util_func&gt;</code> </pre> <br><p>  As we expected. </p><br><h3 id="upravlyaem-opredeleniem-adresa-zagruzchikom">  We manage the definition of the address loader </h3><br><p>  Now is the time to mention that the process of ‚Äúlazy‚Äù address determination, which is carried out by the loader, can be configured by several environment variables (as well as the corresponding arguments for linker ld).  Sometimes these settings can be useful for debugging or some special performance requirements. </p><br><p>  The variable LD_BIND_NOW, when defined, tells the loader to determine all addresses at startup, rather than "lazily."  Her work can be checked by looking at the gdb output for the example above when it is set.  We will see that the element from GOT for ml_util_func contains the real address of the function before the first function call. </p><br><p>  In contrast, LD_BIND_NOT tells the boot loader to never update the GOT.  That is, each function call in this case will go through the "definition" method. </p><br><p>  The loader is configured and some other flags.  I recommend learning man ld.so.  There is a lot of interesting information. </p><br><h3 id="stoimost-pic">  PIC cost </h3><br><p>  We started the conversation with a relocation problem while working and solving this PIC problem.  But the PIC itself, alas, is also not without problems.  One of them is the cost of unnecessary indirect addressing.  This is an extra memory access every time a global variable or function is accessed.  The ‚Äúscale of the disaster‚Äù depends on the compiler, processor architecture and the application itself. </p><br><p>  Another, less obvious, problem is the use of additional registers to implement the PIC.  In order not to determine the GOT address too often, it makes sense for the compiler to generate code that will store the address in a register (for example, ebx).  But this means that the whole register goes only on the GOT.  For RISC architectures, which usually have a lot of public registers, this is not such a big problem, which cannot be said about x86-type architectures, which have fewer available registers.  Using PIC means one register less, which means you will need to make more memory access. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Now you know what code is not dependent on the address, and how it helps to create shared libraries with a shared, read-only text section. </p><br><p>  PIC has pros and cons compared to relocation during operation, and the result will depend on many factors (in particular, on the architecture of the processor on which the program will run). </p><br><p>  However, despite the shortcomings, PIC is becoming an increasingly popular approach.  Some non-Intel architectures, such as SPARC64, require the use of PIC for shared libraries, and many others (for example, ARM) have IP-dependent addressing in order to make the PIC more efficient.  Both that, and another is true for the successor of x86 - x64. </p><br><p>  We did not focus on performance issues or processor architectures.  My task was to tell how the PIC works.  If the explanation was not ‚Äútransparent‚Äù enough, let me know in the comments - and I will try to give more information. </p><br><h6 id="1-esli-konechno-vse-do-odnogo-prilozheniya-ne-zagruzyat-etu-biblioteku-po-odnomu-i-tomu-zhe-virtualnomu-adresu-no-tak-v-linux-obychno-ne-delaetsya">  [1] Unless, of course, one and all applications download this library to the same virtual address.  But this is not usually done in Linux. </h6><br><h6 id="2-0x444-i-vse-drugie-adresa-kotorye-my-upominaem-zdes-yavlyayutsya-otnositelnymi-adresam-po-otnosheniyu-k-adresu-kuda-byla-zagruzhena-biblioteka-etot-adres-neizvesten-do-teh-por-poka-biblioteka-ne-budet-zagruzhena-zamette-chto-eto-normalno-tak-kak-kod-rabotaet-tolko-s-otnositelnymi-adresami">  [2] 0x444 (and all other addresses we mention here) are relative addresses relative to the address where the library was loaded.  This address is unknown until the library is loaded.  Note that this is normal, as the code only works with relative addresses. </h6><br><h6 id="3-vnimatelnyy-chitatel-mozhet-zadumatsya-pochemu-got--eto-otdelnaya-sekciya-razve-ya-tolko-chto-ne-pokazal-chto-on-nahoditsya-v-data-na-praktike-eto-tak-ya-ne-hochu-vdavatsya-v-razlichiya-mezhdu-sekciyami-elf-i-segmentami-tak-kak-eto-tema-dlya-otdelnoy-besedy-no-esli-kratko-lyuboe-kolichestvo-sekciy-data-mozhet-byt-opredeleno-v-biblioteke-i-zamapleno-v-kusok-pamyati-dostupnyy-tolko-dlya-chteniya-eto-ne-imeet-znacheniya-esli-elf-fayl-korrekten-razdelenie-data-sekcii-logicheskimi-kuskami-dobavlyaet-modulnosti-i-oblegchaet-rabotu-linkera">  [3] The attentive reader may wonder why .got is a separate section: didn‚Äôt I just show that it is in data?  In practice, it is.         ELF  ,       . ,  ,    data          ,    .    ,  ELF- .  data-        . </h6><br><h6 id="4-zamette-chto-gdb-propustil-kusok-gde-ecx-poluchaet-svoyo-znachenie-eto-proizoshlo-potomu-chto-predpolagaetsya-chto-eto-prolog-k-lyuboy-funkcii-no-nastoyaschaya-prichina-svyazana-s-tem-kak-gcc-strukturiruet-svoyu-debug-informaciyu-konechno-v-funkcii-mozhet-byt-neskolko-ssylok-na-globalnye-dannye-i-funkcii-i-dlya-nih-vseh-mozhet-ispolzovatsya-odin-i-tot-zhe-registr-s-adresom-got"> [4] ,  gdb  ,  ecx   .   ,  ,       (     ,  gcc   debug-, ).           ,              GOT. </h6><br><h6 id="5-obekty-razdelyaemyh-bibliotek-elf-na-samom-dele-idut-so-specialnoy-sekciey-hesh-tablicey-dlya-etogo"> [5]    ELF       / -  . </h6><br><h6 id="6-dinamicheskiy-zagruzchik-v-linux--eto-prosto-eschyo-odna-razdelyaemaya-biblioteka-kotoraya-zagruzhaetsya-v-adresnoe-prostranstvo-vseh-rabotayuschih-processov"> [6]    Linux ‚Äì      ,        . </h6><br><h6 id="7-ya-polozhil-func-v-otdelnuyu-sekciyu-hotya-v-teorii-eto-mozhet-byt-ta-sekciya-gde-proishodit-vyzov-func-to-est-v-toy-zhe-samoy-razdelyaemoy-biblioteke-razdel-dopolnitelno-v-etoy-statehttpelithegreenplacenet20110825load-time-relocation-of-shared-libraries-soderzhit-informaciyu-o-tom-pochemu-vyzov-vneshney-funkcii-iz-toy-zhe-samoy-razdelyaemoy-biblioteki-trebuet-pic-ili-relokacii"> [7]   func   ,        ,    func (       ).  ¬´¬ª <a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/">  </a>    ,            PIC ( ). </h6><br><h6 id="8-vspomnite-chto-v-pervom-primere-s-dostupom-k-dannym-ya-obeschal-obyasnit-pochemu-u-nas-dve-sekcii-got-v-obektnom-fayle-got-i-gotplt-seychas-uzhe-dolzhno-byt-yasno-chto-eto-sdelano-dlya-udobstva-razdeleniya-kuskov-trebuyuschih-tolko-got-i-kuskov-trebuyuschih-eschyo-i-plt-eto-yavlyaetsya-prichinoy-togo-pochemu-smeschenie-k-got-vychislyaetsya-na-konec-got-takim-obrazom-otricatelnoe-smeschenie-ot-etogo-adresa-vedyot-nas-v-got-a-polozhitelnoe--v-gotplt-eto-udobno-no-sovershenno-ne-obyazatelno--my-mogli-by-polozhit-vsyo-v-odnu-got-sekciyu"> [8] ,           ,      GOT   : .got  .got.plt.     ,       ,   GOT,  ,    PLT.    ,    GOT    GOT.  ,         .got,   ‚Äì  .got.plt.  ,     ‚Äì        .got-. </h6></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323904/">https://habr.com/ru/post/323904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323892/index.html">Screening on the WebRTC website from Mozilla Firefox browser</a></li>
<li><a href="../323896/index.html">Online tools for the simplest Pentest</a></li>
<li><a href="../323898/index.html">Blast-off. From idea to release</a></li>
<li><a href="../323900/index.html">PG Metricus - collecting metrics from plpgsql code or as three lines of code simplified life</a></li>
<li><a href="../323902/index.html">New law on online cash registers: how the service of commercial equipment changes</a></li>
<li><a href="../323906/index.html">Monitoring windows service using Zidium</a></li>
<li><a href="../323908/index.html">Spotify: Google Cloud event subsystem migration (part 3)</a></li>
<li><a href="../323910/index.html">IBM Watson will work as a tax specialist</a></li>
<li><a href="../323912/index.html">Dark secrets of the "bright budget"</a></li>
<li><a href="../323914/index.html">Explain the effect of the last line</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>