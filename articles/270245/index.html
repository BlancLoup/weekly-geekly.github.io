<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Smooth scroll on AngularJS using requestAnimationFrame + style tips</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I had to write my smooth scrolling library for an Angular application. About what I did, and why I started it all - under the cut. Along the way, I‚Äôll...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Smooth scroll on AngularJS using requestAnimationFrame + style tips</h1><div class="post__text post__text-html js-mediator-article">  I had to write my smooth scrolling library for an Angular application.  About what I did, and why I started it all - under the cut.  Along the way, I‚Äôll tell you about my favorite tricks for decorating modules for AngularJS. <br><a name="habracut"></a><br><h4>  Instead of introducing </h4><br><div class="spoiler">  <b class="spoiler_title">Background: why another library?</b> <div class="spoiler_text">  There was a standard situation: I needed a smooth-scroll on a page with a minimalist Angular-application, and my internal perfectionist forbade me to pull for this jQuery.  I made a `bower search smooth scroll`, I saw three or four angular lines there, of which a couple didn‚Äôt mean anything, in one last commit two years ago, and only one interested me: the last commit at that time was a week ago, version 2.0 .0 (and this is already talking about something) and, judging by the dock, it was just wonderful and perfectly suited to my needs (at least, by condition).  He quickly connected and began to try - it does not work ... I carefully re-read the dock several times, I tried it and this way and that - it does not work ... Without thinking twice, I used the source code in the hope that there were mistakes in the dock, and I was horrified.  My first thought was: ‚ÄúHow could IT live to version 2.0.0 with a dozen contributors and such nonsense in the code?‚Äù Complete misunderstanding of the principles of Angular: even $ watch wasn‚Äôt elementary on the scrolling condition;  directives are badly designed: incorrect and incomprehensible work with scope and attrs, arguments are incorrectly named;  ignoring of dependency injection: global functions and variables are used everywhere, although the author himself has done the service for them, everywhere the global window and document are twitching;  in a couple of places, the code is unreasonably wrapped in setTimeout: apparently, the author does not fully understand why this is necessary (because of this there was even a bug), and, again, there is $ timeout for this;  Attributes in directives are used without prefixes (offset, duration ...), which can cause conflicts with other libs, etc.  For those who are not afraid to look with their own eyes - a link at the end. <br><br>  First of all, I quickly made a minimal pull request, especially without delving into all the code, so that at least something worked for me (I rewrote the directives completely), but when unpleasant bugs (jerky animation, triggering through time) got, I looked through the entire file and understood - to fix the situation, almost everything needs to be rewritten, and the author hardly ever will accept such a pull-request, plus - there were not enough sufficiently important features, and since I needed the scroll by the evening, I decided to quickly write your smooth-scroll version on Angular. <br></div></div><br><br>  For a long time I could not decide on what to focus on in the article: either on the library itself, or on tips on style code, or on smooth animation and debugging ... As a result, I decided to write how to spell.  So there will be a little bit of everything, alternately.  Hope not to get confused. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Goals </h4><br><ol><li>  smooth scrolling of the page when the specified condition is met </li><li>  no additional dependencies (except AngularJS) </li><li>  use smooth scrolling requestAnimationFrame instead of setTimeout </li><li>  ability to customize: indent from the top of the screen after scrolling, animation duration, easing, delay, and also indicate the scrollback callback </li><li>  show <s>your kung-fu</s> your Angular-design style (suddenly someone will throw new ideas) </li><li>  Dilute holivar (maximum plan, if I have time to finish the article by Friday) :) </li></ol><br><h4>  Go </h4><br><pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     IIFE,    global scope 'use strict' angular.module('StrongComponents.smoothScroll', []) //   .factory('Utils', Utils) //    .factory('stScroller', stScroller) // ,     .directive('stSmoothScroll', stSmoothScroll) //      }());</span></span></code> </pre> <br>  Here you can already notice one of my favorite features of the Javascript language - this is function hoisting, which allows me to focus all the ads as high as possible, and the implementation is at the bottom, so you can immediately imagine the structure of the module without looking at all the code <i>(besides this, the attentive reader already here I noticed a great topic for holivar)</i> . <br><br>  In Utils, now there is only one function ‚Äî extend, taken from the Angular sources and corrected so that undefined elements from src do not overwrite the corresponding elements from dst.  In Angular turnips on github, there is a long time Issue on this topic, but there is no time to wait until the whole thing is fixed. <br><br><div class="spoiler">  <b class="spoiler_title">Code utils</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Utils functions */</span></span> Utils.$inject = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Utils</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> service = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: extend } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> service <span class="hljs-comment"><span class="hljs-comment">/** * Extends the destination object `dst` by copying own enumerable properties * from the `src` object(s) to `dst`. Undefined properties are not copyied. * (modified angular version) * * @param {Object} dst Destination object. * @param {...Object} src Source object(s). * @return {Object} Reference to `dst`. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objs = [].slice.call(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), h = dst.$$hashKey <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, ii = objs.length; i &lt; ii; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = objs[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!angular.isObject(obj) &amp;&amp; !angular.isFunction(obj)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keys = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>, jj = keys.length; j &lt; jj; j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = keys[j] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> src = obj[key] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!angular.isUndefined(src)) { dst[key] = src } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h) { dst.$$hashKey = h } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dst } }</code> </pre><br>  Again function hoisting in all its glory. <br></div></div><br><h4>  Directive </h4><br><div class="spoiler">  <b class="spoiler_title">Full directive code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Smooth scroll directive. */</span></span> stSmoothScroll.$inject = [<span class="hljs-string"><span class="hljs-string">'$document'</span></span>, <span class="hljs-string"><span class="hljs-string">'$rootScope'</span></span>, <span class="hljs-string"><span class="hljs-string">'stScroller'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stSmoothScroll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$document, $rootScope, Scroller</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// subscribe to user scroll events to cancel auto scrollingj angular.forEach(['DOMMouseScroll', 'mousewheel', 'touchmove'], function(ev) { $document.on(ev, function(ev) { $rootScope.$broadcast('stSmoothScroll.documentWheel', angular.element(ev.target)) }) }) var directive = { restrict: 'A', scope: { stScrollIf: '=', stScrollDuration: '=', stScrollOffset: '=', stScrollCancelOnBounds: '=', stScrollDelay: '=', stScrollAfter: '&amp;' }, link: link } return directive /** * Smooth scroll directive link function */ function link(scope, elem, attrs) { var scroller = null // stop scrolling if user scrolls the page himself var offDocumentWheel = $rootScope.$on('stSmoothScroll.documentWheel', function() { if (!!scroller) { scroller.cancel() } }) // unsubscribe scope.$on('$destroy', function() { offDocumentWheel() }) // init scrolling if (attrs.stScrollIf === undefined) { // no trigger specified, start scrolling immediatelly run() } else { // watch trigger and start scrolling, when it becomes `true` scope.$watch('stScrollIf', function(val) { if (!!val) run() }) } /** * Start scrolling, add callback */ function run() { scroller = new Scroller(elem[0], { duration: scope.stScrollDuration, offset: scope.stScrollOffset, easing: attrs.stScrollEasing, cancelOnBounds: scope.stScrollCancelOnBounds, delay: scope.stScrollDelay }) scroller.run().then(function() { // call `after` callback if (typeof scope.stScrollAfter === 'function') scope.stScrollAfter() // forget scroller scroller = null }) } } }</span></span></code> </pre><br></div></div><br><h6>  Announcement </h6><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Smooth scroll directive. */</span></span> stSmoothScroll.$inject = [<span class="hljs-string"><span class="hljs-string">'$document'</span></span>, <span class="hljs-string"><span class="hljs-string">'$rootScope'</span></span>, <span class="hljs-string"><span class="hljs-string">'stScroller'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stSmoothScroll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$document, $rootScope, Scroller</span></span></span><span class="hljs-function">) </span></span>{ ... }</code> </pre><br><ul><li>  always write a docstring before defining a function: this allows you to visually share your code in addition to receiving documentation </li><li>  I like to use the <i>funcName</i> construction <i>. $ inject = [...]</i> for explicit dependency injection: this prevents the minification problem that has already been described a thousand times, plus - it allows you to rename the implemented modules, as in this case - <i>'stScroller' -&gt; Scroller</i> </li></ul><br><h6>  Directive Parameters </h6><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stSmoothScroll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) </span></span>{ ... var directive = { <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-attr"><span class="hljs-attr">scope</span></span>: { <span class="hljs-attr"><span class="hljs-attr">stScrollIf</span></span>: <span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-attr"><span class="hljs-attr">stScrollDuration</span></span>: <span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-attr"><span class="hljs-attr">stScrollOffset</span></span>: <span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-attr"><span class="hljs-attr">stScrollCancelOnBounds</span></span>: <span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-attr"><span class="hljs-attr">stScrollDelay</span></span>: <span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-attr"><span class="hljs-attr">stScrollAfter</span></span>: <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: link } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> directive ... }</code> </pre><br><ul><li>  again, using function hoisting, we immediately set up the directive and return the object, and we will deal with the implementation later, and <i>return to</i> us is not a hindrance </li><li>  All directive attributes are prefixed with <i>st-scroll</i> to avoid conflicts with other libraries. </li><li>  In scope, we define several settings, the main of which is <i>st-scroll-if</i> ‚Äî the trigger starts scrolling, and one callback </li></ul><br><h6>  Cancel automatic scrolling if the user himself ‚Äútook the wheel‚Äù </h6><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stSmoothScroll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) </span></span>{ angular.forEach([<span class="hljs-string"><span class="hljs-string">'DOMMouseScroll'</span></span>, <span class="hljs-string"><span class="hljs-string">'mousewheel'</span></span>, <span class="hljs-string"><span class="hljs-string">'touchmove'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ev</span></span></span><span class="hljs-function">) </span></span>{ $<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.on(ev, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ev</span></span></span><span class="hljs-function">) </span></span>{ $rootScope.$broadcast(<span class="hljs-string"><span class="hljs-string">'stSmoothScroll.documentWheel'</span></span>, angular.element(ev.target)) }) }) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> directive = {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> directive .... }</code> </pre><br>  Here we subscribe to all kinds of events that are generated by different browsers if the user starts scrolling the page himself.  <b>Note</b> : this is <b>not</b> done <b>in the link</b> , but in the directive function itself, in order to have one single handler for all registered elements.  A message to specific elements is sent via <i>$ rootScope. $ Broadcast (...)</i> . <br><h6>  Link function </h6><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offDocumentWheel = $rootScope.$on(<span class="hljs-string"><span class="hljs-string">'stSmoothScroll.documentWheel'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!!scroller) { scroller.cancel() } }) scope.$on(<span class="hljs-string"><span class="hljs-string">'$destroy'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ offDocumentWheel() })</code> </pre><br>  We subscribe to the sent message when the user himself starts to scroll the page to interrupt the automatic scroll, and do not subscribe to unsubscribe from it when the element is destroyed. <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attrs.stScrollIf === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { run() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { scope.$watch(<span class="hljs-string"><span class="hljs-string">'stScrollIf'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!!val) run() }) }</code> </pre><br>  Check the trigger.  If it is not specified in the attributes, then we scroll right away; otherwise, we wait for it to become <i>true</i> .  We refer to <i>attrs</i> to check for an attribute in the element.  (I hope we avoid the <i>typeof</i> and <i>"undefined"</i> discussions, not the case) <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ scroller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scroller(elem[<span class="hljs-number"><span class="hljs-number">0</span></span>], { <span class="hljs-attr"><span class="hljs-attr">duration</span></span>: scope.stScrollDuration, <span class="hljs-attr"><span class="hljs-attr">offset</span></span>: scope.stScrollOffset, <span class="hljs-attr"><span class="hljs-attr">easing</span></span>: attrs.stScrollEasing, <span class="hljs-attr"><span class="hljs-attr">cancelOnBounds</span></span>: scope.stScrollCancelOnBounds, <span class="hljs-attr"><span class="hljs-attr">delay</span></span>: scope.stScrollDelay }) scroller.run().then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> scope.stScrollAfter === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) scope.stScrollAfter() scroller = <span class="hljs-literal"><span class="hljs-literal">null</span></span> }) }</code> </pre><br>  Actually, the immediate launch of the scroll.  We transfer "without looking" all the parameters from the <i>scope</i> to the service.  We subscribe to the end of scrolling, call the callback specified in the attributes ( <i>stScroller.run ()</i> returns Promise) and clear the variable. <br><br>  It was a very simple directive.  The most interesting thing in our scrolling service.  Let's go further! <br><br><h4>  Service </h4><br><div class="spoiler">  <b class="spoiler_title">Full service code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Smooth scrolling manager */</span></span> stScroller.$inject = [<span class="hljs-string"><span class="hljs-string">'$window'</span></span>, <span class="hljs-string"><span class="hljs-string">'$document'</span></span>, <span class="hljs-string"><span class="hljs-string">'$timeout'</span></span>, <span class="hljs-string"><span class="hljs-string">'$q'</span></span>, <span class="hljs-string"><span class="hljs-string">'Utils'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stScroller</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$window, $document, $timeout, $q, Utils</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = $<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.find(<span class="hljs-string"><span class="hljs-string">'body'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">/** * Smooth scrolling manager constructor * @param {DOM Element} elem Element which window must be scrolled to * @param {Object} opts Scroller options */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Scroller</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">elem, opts</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.opts = Utils.extend({ <span class="hljs-attr"><span class="hljs-attr">duration</span></span>: <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-attr"><span class="hljs-attr">offset</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">easing</span></span>: <span class="hljs-string"><span class="hljs-string">'easeInOutCubic'</span></span>, <span class="hljs-attr"><span class="hljs-attr">cancelOnBounds</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">delay</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, opts) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elem = elem <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startTime = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.framesCount = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.frameRequest = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startElemOffset = elem.getBoundingClientRect().top <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.endElemOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.opts.offset <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isUpDirection = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startElemOffset &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.endElemOffset <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curElemOffset = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curWindowOffset = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.donePromise = $q.defer() <span class="hljs-comment"><span class="hljs-comment">// this promise is resolved when scrolling is done } Scroller.prototype = { run: run, done: done, animationFrame: animationFrame, requestNextFrame: requestNextFrame, cancel: cancel, isElemReached: isElemReached, isWindowBoundReached: isWindowBoundReached, getEasingRatio: getEasingRatio } return Scroller /** * Run smooth scroll * @return {Promise} A promise which is resolved when scrolling is done */ function run() { $timeout(angular.bind(this, this.requestNextFrame), +this.opts.delay) return this.donePromise.promise } /** * Add scrolling done callback * @param {Function} cb */ function done(cb) { if (typeof cb !== 'function') return this.donePromise.promise.then(cb) } /** * Scrolling animation frame. * Calculate new element and window offsets, scroll window, * request next animation frame, check cancel conditions * @param {DOMHighResTimeStamp or Unix timestamp} time */ function animationFrame(time) { this.requestNextFrame() // set startTime if (this.framesCount++ === 0) { this.startTime = time this.curElemOffset = this.elem.getBoundingClientRect().top this.curWindowOffset = $window.pageYOffset } var timeLapsed = time - this.startTime, perc = timeLapsed / this.opts.duration, newOffset = this.startElemOffset + (this.endElemOffset - this.startElemOffset) * this.getEasingRatio(perc) this.curWindowOffset += this.curElemOffset - newOffset this.curElemOffset = newOffset $window.scrollTo(0, this.curWindowOffset) if (timeLapsed &gt;= this.opts.duration || this.isElemReached() || this.isWindowBoundReached()) { this.cancel() } } /** * Request next animation frame for scrolling */ function requestNextFrame() { this.frameRequest = $window.requestAnimationFrame( angular.bind(this, this.animationFrame)) } /** * Cancel next animation frame, resolve done promise */ function cancel() { cancelAnimationFrame(this.frameRequest) this.donePromise.resolve() } /** * Check if element is reached already * @return {Boolean} */ function isElemReached() { if (this.curElemOffset === null) return false return this.isUpDirection ? this.curElemOffset &lt;= this.endElemOffset : this.curElemOffset &gt;= this.endElemOffset } /** * Check if window bound is reached * @return {Boolean} */ function isWindowBoundReached() { if (!this.opts.cancelOnBounds) { return false } return this.isUpDirection ? body.scrollHeight &lt;= this.curWindowOffset + $window.innerHeight : this.curWindowOffset &lt;= 0 } /** * Return the easing ratio * @param {Number} perc Animation done percentage * @return {Float} Calculated easing ratio */ function getEasingRatio(perc) { switch(this.opts.easing) { case 'easeInQuad': return perc * perc; // accelerating from zero velocity case 'easeOutQuad': return perc * (2 - perc); // decelerating to zero velocity case 'easeInOutQuad': return perc &lt; 0.5 ? 2 * perc * perc : -1 + (4 - 2 * perc) * perc; // acceleration until halfway, then deceleration case 'easeInCubic': return perc * perc * perc; // accelerating from zero velocity case 'easeOutCubic': return (--perc) * perc * perc + 1; // decelerating to zero velocity case 'easeInOutCubic': return perc &lt; 0.5 ? 4 * perc * perc * perc : (perc - 1) * (2 * perc - 2) * (2 * perc - 2) + 1; // acceleration until halfway, then deceleration case 'easeInQuart': return perc * perc * perc * perc; // accelerating from zero velocity case 'easeOutQuart': return 1 - (--perc) * perc * perc * perc; // decelerating to zero velocity case 'easeInOutQuart': return perc &lt; 0.5 ? 8 * perc * perc * perc * perc : 1 - 8 * (--perc) * perc * perc * perc; // acceleration until halfway, then deceleration case 'easeInQuint': return perc * perc * perc * perc * perc; // accelerating from zero velocity case 'easeOutQuint': return 1 + (--perc) * perc * perc * perc * perc; // decelerating to zero velocity case 'easeInOutQuint': return perc &lt; 0.5 ? 16 * perc * perc * perc * perc * perc : 1 + 16 * (--perc) * perc * perc * perc * perc; // acceleration until halfway, then deceleration default: return perc; } } }</span></span></code> </pre><br></div></div><br>  It was decided to arrange the service in the form of a ‚Äúclass‚Äù (do not hit me, I understand everything).  The constructor sets the initial values ‚Äã‚Äãof the properties needed for smooth scrolling.  Special attention is given to setting default values ‚Äã‚Äãfor scroll options: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.opts = Utils.extend({ <span class="hljs-attr"><span class="hljs-attr">duration</span></span>: <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-attr"><span class="hljs-attr">offset</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">easing</span></span>: <span class="hljs-string"><span class="hljs-string">'easeInOutCubic'</span></span>, <span class="hljs-attr"><span class="hljs-attr">cancelOnBounds</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">delay</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, opts)</code> </pre><br>  The extend function corrected above allows defining default values ‚Äã‚Äãthat will not be erased if the corresponding options were not specified in the element attributes. <br><br><div class="spoiler">  <b class="spoiler_title">Setting initial values</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elem = elem <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startTime = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.framesCount = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.frameRequest = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startElemOffset = elem.getBoundingClientRect().top <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.endElemOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.opts.offset <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isUpDirection = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startElemOffset &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.endElemOffset <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curElemOffset = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curWindowOffset = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.donePromise = $q.defer() <span class="hljs-comment"><span class="hljs-comment">//      resolve,   </span></span></code> </pre><br></div></div><br><h6>  Methods </h6><br><pre> <code class="javascript hljs"> Scroller.prototype = { <span class="hljs-attr"><span class="hljs-attr">run</span></span>: run, <span class="hljs-comment"><span class="hljs-comment">//   done: done, //   animationFrame: animationFrame, //    requestNextFrame: requestNextFrame, //    cancel: cancel, //    isElemReached: isElemReached, //     isWindowBoundReached: isWindowBoundReached, //       getEasingRatio: getEasingRatio //   easing- }</span></span></code> </pre><br>  I repeat: function hoisting allows you to succinctly describe the entire prototype.  The person reading the code can immediately imagine how the object works without flipping through the entire file in search of ads. <br><br>  We now turn to interesting points of implementation. <br><br>  Everything starts with the <i>run</i> method, in which the first frame of the animation is requested, and at the same time the scroll delay specified in the options is processed: <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $timeout(angular.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requestNextFrame), +<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.opts.delay) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.donePromise.promise } .... function requestNextFrame() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.frameRequest = $<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.requestAnimationFrame( angular.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.animationFrame)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ cancelAnimationFrame(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.frameRequest) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.donePromise.resolve() }</code> </pre><br>  This method returns promis so that the ‚Äúuser‚Äù has the ability to subscribe to the end of the animation (for example, I use this to set the focus in the input after the scrolling is completed, to avoid jerking, since different browsers will scroll the page differently when outside the screen). <br><br>  The <i>requestNextFrame</i> method requests a new animation frame and saves its identifier so that it can be canceled in the <i>cancel</i> method. <br><br>  The <i>cancel</i> method, in addition to canceling the next frame, resolves a callback. <br><br>  It is time to move to the place where all the magic of smooth scrolling takes place - the <i>animationFrame</i> method: <br><br><div class="spoiler">  <b class="spoiler_title">All method code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animationFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">time</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requestNextFrame() <span class="hljs-comment"><span class="hljs-comment">// set startTime if (this.framesCount++ === 0) { this.startTime = time this.curElemOffset = this.elem.getBoundingClientRect().top this.curWindowOffset = $window.pageYOffset } var timeLapsed = time - this.startTime, perc = timeLapsed / this.opts.duration, newOffset = this.startElemOffset + (this.endElemOffset - this.startElemOffset) * this.getEasingRatio(perc) this.curWindowOffset += this.curElemOffset - newOffset this.curElemOffset = newOffset $window.scrollTo(0, this.curWindowOffset) if (timeLapsed &gt;= this.opts.duration || this.isElemReached() || this.isWindowBoundReached()) { this.cancel() } }</span></span></code> </pre><br></div></div><br>  The first line of the method calls <i>requestNextFrame</i> to request the next frame of the animation as soon as possible.  And then there are two tricks: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.framesCount++ === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startTime = time <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curElemOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elem.getBoundingClientRect().top <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curWindowOffset = $<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.pageYOffset }</code> </pre><br><ul><li>  in the zero frame we save the start time of the animation.  This is necessary when using the <i>requestAnimationFrame</i> polyphile with a fallback on <i>setTimeout</i> .  The fact is that these two options will transfer different times to the frame callback: in the first case it will be <i>DOMHighResTimeStamp</i> , and in the second - the usual <i>Date</i> .  In all examples of using <i>requestAnimationFrame</i> with a polyfile, I saw how the authors initialize <i>startTime</i> before the animation begins, while again finding out which option will work, but I thought that you can not burden yourself with unnecessary conditions and just initialize <i>startTime</i> in the zero frame. </li><li>  the current position of the element and the current position of the screen, which will change in subsequent frames, are immediately initialized.  In the first implementation, this was not the case, and the current position was requested in each frame, but as it turned out when debugging the animation, these requests boost the recalculation of the page layout, and I had to slightly revise the scrolling algorithm to avoid brakes (proofs at the end) </li></ul><br>  Then everything is simple: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeLapsed = time - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startTime, perc = timeLapsed / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.opts.duration, newOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startElemOffset + (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.endElemOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startElemOffset) * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getEasingRatio(perc) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curWindowOffset += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curElemOffset - newOffset <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curElemOffset = newOffset $<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.scrollTo(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curWindowOffset) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeLapsed &gt;= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.opts.duration || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isElemReached() || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isWindowBoundReached()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cancel() }</code> </pre><br>  Calculate the time and percentage of completion of the animation, as well as the new position of the element and screen.  The scroll to the calculated position is called and the conditions for ending the animation are checked. <br><br><h4>  Results </h4><br>  A module written in a couple of hours does not have the disadvantages of either criticized in the introduction: the animation is smooth, the minimum necessary functionality is present. <br><br>  There is still something to do: <br><br><ul><li>  write a normal readme and make a demo page </li><li>  do the minification and throw the library in bower </li><li>  get rid of another pair of forced recalculations of the page layout when scrolling ends </li><li>  deal with the situation if at the same time trigger for two or more elements </li></ul><br><h4>  Requests </h4><br>  I poured everything on the githab in an untouched form and ask those who understand licenses and ‚Äúother open-end assets‚Äù to suggest and help to arrange this matter correctly: <br><br><ul><li>  I just copied the polyfil to the beginning of the file.  maybe it's worth it in a separate file? </li><li>  You need to choose a license for the most and arrange accordingly. </li><li>  Was it possible to just copy and change the code from Angular? </li></ul><br><h4>  Proofs and links </h4><br><ul><li>  <a href="https://github.com/johnpapa/angular-styleguide">Lovely style guide from John Papa.</a>  <a href="https://github.com/johnpapa/angular-styleguide">Who has not yet seen - be inspired, who have seen - reread</a> </li><li>  <a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a">What provokes the recalculation of the layout in browsers</a> </li><li>  <a href="https://gist.github.com/paulirish/1579671">Source code requestAnimationFrame polyfile</a> </li><li>  <a href="https://github.com/d-oliveros/ngSmoothScroll">Liba, because of which I freaked out and wrote my</a> </li><li>  <a href="https://github.com/alxdnlnko/strong-smooth-scroll">strong-smooth-scroll</a> </li></ul><br>  Thank you all for your attention! </div><p>Source: <a href="https://habr.com/ru/post/270245/">https://habr.com/ru/post/270245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270233/index.html">About Parboiled</a></li>
<li><a href="../270235/index.html">Programmer's resume: how to make it convenient?</a></li>
<li><a href="../270237/index.html">CONVERT web analytics and internet marketing conference: preliminary program</a></li>
<li><a href="../270241/index.html">Index-based programming or why do we need all these if, switch, ternary operator?</a></li>
<li><a href="../270243/index.html">Reaction to longevity: how we updated the Lingualeo frontend</a></li>
<li><a href="../270247/index.html">SWAPY with a new code generator</a></li>
<li><a href="../270249/index.html">New Intercepter-NG released [Android Edition] 1.6</a></li>
<li><a href="../270251/index.html">‚ÄúStored Procedures‚Äù in Redis</a></li>
<li><a href="../270253/index.html">What's new in Fedora 23 Workstation</a></li>
<li><a href="../270255/index.html">100 lines on canvas: part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>