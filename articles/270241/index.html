<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Index-based programming or why do we need all these if, switch, ternary operator?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently I read a topeip about the beauty of the code . In the comments, the topic of moving parentheses when writing a conditional statement gained p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Index-based programming or why do we need all these if, switch, ternary operator?</h1><div class="post__text post__text-html js-mediator-article">  Recently I read a topeip about the <a href="http://habrahabr.ru/company/geekbrains/blog/270001">beauty of the code</a> .  In the comments, the topic of moving parentheses when writing a conditional statement gained popularity.  In <a href="http://habrahabr.ru/company/geekbrains/blog/270001">one of the options, the</a> example from the article looked like this: <pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a ! == <span class="hljs-string"><span class="hljs-string">"undefined"</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b ! == <span class="hljs-string"><span class="hljs-string">"undefined"</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> c === <span class="hljs-string"><span class="hljs-string">"string"</span></span>) { call_function(a, b, c); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre>  Thinking about the conditions themselves: they are a bit strange, although they often occur.  Inside ‚Äúcall_function‚Äù, type ‚Äúa‚Äù and type ‚Äúb‚Äù will be checked, but not type ‚Äúc‚Äù.  On the other hand, the number of supported combinations of the ‚Äúa‚Äù and ‚Äúb‚Äù types supported by the function is of course, and, most likely, is fixed, which means it would be useful to see these combinations.  And <a href="http://habrahabr.ru/post/269875/">this post</a> prompted the idea that you can do without conditional operators.  So the idea was born to abandon conditional operators in favor of indices.  Although the approach is considered within the framework of Javascript, it can be successfully applied in many other languages ‚Äã‚Äãafter taking into account their syntactic features. <br><br>  Do not expect to see here pictures Rembrandt of the programming world.  The code in the article is a work by Dali.  However, as the article itself. <br><a name="habracut"></a><br>  So, this is how a expanded condition can look like (I will write in my own style and immediately in <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2580%25D1%2588%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B4%25D0%25B8%25D0%25B7%25D1%258A%25D1%258E%25D0%25BD%25D0%25BA%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0">Perfect Disjunctive Normal Form (PDNF)</a> ): <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span> ||(<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"string"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"string"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>  === <span class="hljs-string"><span class="hljs-string">"string"</span></span> )||(<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"string"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>  === <span class="hljs-string"><span class="hljs-string">"string"</span></span> )||(<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"number"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"string"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>  === <span class="hljs-string"><span class="hljs-string">"string"</span></span> )||(<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"string"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>  === <span class="hljs-string"><span class="hljs-string">"string"</span></span> )||(<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>  === <span class="hljs-string"><span class="hljs-string">"string"</span></span> )||(<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"number"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>  === <span class="hljs-string"><span class="hljs-string">"string"</span></span> )||(<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"string"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"number"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>  === <span class="hljs-string"><span class="hljs-string">"string"</span></span> )||(<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"object"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"number"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>  === <span class="hljs-string"><span class="hljs-string">"string"</span></span> )||(<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"number"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"number"</span></span> &amp;&amp;<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>  === <span class="hljs-string"><span class="hljs-string">"string"</span></span> ) ){ call_function(a, b, c); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  It turned out somehow long.  We see that the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2580%25D1%2588%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%258A%25D1%258E%25D0%25BD%25D0%25BA%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0">perfect conjunctive normal form (SKNF) is</a> more suitable here: <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp;(<span class="hljs-literal"><span class="hljs-literal">false</span></span> ||<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"string"</span></span> ||<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"number"</span></span> ||<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> a === <span class="hljs-string"><span class="hljs-string">"object"</span></span> )&amp;&amp;(<span class="hljs-literal"><span class="hljs-literal">false</span></span> ||<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"string"</span></span> ||<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"number"</span></span> ||<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> b === <span class="hljs-string"><span class="hljs-string">"object"</span></span> )&amp;&amp;(<span class="hljs-literal"><span class="hljs-literal">false</span></span> ||<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> c === <span class="hljs-string"><span class="hljs-string">"string"</span></span> ) ){ call_function(a, b, c); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre>  But then the question arises, what to do when the combination of argument types is different?  Why not cover all possible options at once.  Errors of not accounting for some combination of a multitude of conditions are common, and they are difficult to detect. <br>  Let "a" can have the types 'undefined', 'object', 'boolean', 'number', 'string', 'function', but the behavior is important for us only when 'object', 'string', 'number', the behavior with other types, the behavior is similar to 'undefined'. <br>  Let for ‚Äúb‚Äù everything will be similar. <br>  Type "c" - consider only 'string' and 'undefined'. <br>  Total, the number of options = 4 * 4 * 2, each of which corresponds to one elementary conjunction in the PDNF, but now we can distinguish them and change the behavior for each specific case. <br><br><h4>  Analogue of the conditional operator: </h4><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//     "a", "b", "c" //    //     var a_type_index = {'undefined':0, 'object':1, 'boolean':0, 'number':2, 'string':3, 'function':0}[typeof a] var b_type_index = {'undefined':0, 'object':1, 'boolean':0, 'number':2, 'string':3, 'function':0}[typeof b] var c_type_index = {'undefined':0, 'object':0, 'boolean':0, 'number':0, 'string':1, 'function':0}[typeof c] var index = a_type_index + b_type_index*4 + c_type_index*4*4</span></span></code> </pre><div class="spoiler">  <b class="spoiler_title">For demonstration purposes, I decided not to complicate the code ...</b> <div class="spoiler_text">  but then he changed his mind and decided that the universal solution was more beautiful.  I think it is convenient for many to think in numbers: <pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//     "a", "b", "c" //    //     var types = ['undefined', 'object', 'boolean', 'number', 'string', 'function'] var a_type_index = types.indexOf(typeof a) //    a_type_index = +'010230'[a_type_index] var b_type_index = types.indexOf(typeof b) b_type_index = +'010230'[b_type_index] var c_type_index = types.indexOf(typeof c) c_type_index = +'000010'[c_type_index] var index = a_type_index + b_type_index*4 + c_type_index*4*4</span></span></code> </pre></div></div>  All that is left now is to select by the index what to do: <pre> <code class="javascript hljs"> ;[ <span class="hljs-comment"><span class="hljs-comment">//c has incorrect type //b has incorrect type //types a: incorrect, object, number, string show_err_all, show_err_bc, show_err_bc, show_err_bc, //b has object type //types a: incorrect, object, number, string show_err_ac, show_err_c, show_err_c, show_err_c, //b has number type //types a: incorrect, object, number, string show_err_ac, show_err_c, show_err_c, show_err_c, //b has string type //types a: incorrect, object, number, string show_err_ac, show_err_c, show_err_c, show_err_c, //c has string type //b has incorrect type //types a: incorrect, object, number, string show_err_ab, show_err_b, show_err_b, show_err_b, //b has object type //types a: incorrect, object, number, string show_err_a, process, process, process, process, //b has number type //types a: incorrect, object, number, string show_err_a, process, process, process, process, //b has string type //types a: incorrect, object, number, string show_err_a, process, process, process, process ][index](a, b, c)</span></span></code> </pre><br>  So, the <i>first principle of index-oriented programming</i> : the <b>coverage of all options</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Naturally conditions can be any.  Why confine one conditional operator when there are others like him. <br><br><h4>  Analogue of the ternary operator: </h4><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b_status = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">//    var str_status = b_status? 'ok': 'this is false' //   var str_status = ['this is false','ok'][+b_status]</span></span></code> </pre>  The "+" sign converts the b_status variable into a numeric type, since the index must be a number.  Notice that the first expression goes to fail the condition. <br><br><h4>  Analogue of the multiple choice operator: </h4><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i_state = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">//  switch switch (i_state) { case 1: console.log('you select 1') break case 2: console.log('you select 2') break default: console.log('you select another') } //   i_state = 0|[0,1,2][i_state] //       //i_state = 0|{'one':1, 'two':2}[str_state] //i_state = ['one', 'two'].indexOf(str_state)+1 [ function(){ //default console.log('you select another') },function(){ //i_state == 1 console.log('you select 1') },function(){ //i_state == 2 console.log('you select 2') } ][i_state]</span></span></code> </pre>  Also, as for the ternary operator, the first (zero) case is for false, for the switch, the first is the default case, which is generally convenient, since it is one, its presence is mandatory - this is a certain analogue of zero. <br><br>  <i>The second principle of index-oriented programming</i> : the <b>presence of a special zero variant</b> . <br><br>  However, the idea of ‚Äã‚Äãindex-oriented programming is somewhat broader than the replacement of conditional statements.  A couple more examples. <br><br><h4>  Generating permutations from the index: </h4><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n&lt;=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">2</span></span>; i&lt;=n; i++) ret *= i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i_to_insert_order</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i_tmp = i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;n; j++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = i_tmp%(j+<span class="hljs-number"><span class="hljs-number">1</span></span>) arr[j] = a i_tmp = ~~(i_tmp/(j+<span class="hljs-number"><span class="hljs-number">1</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">correct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;n; i++){ <span class="hljs-comment"><span class="hljs-comment">// for(var j=0; j&lt;i; j++){ for(var j=i-1; j&gt;=0; j--){ //if(arr[j]&gt;=arr[i]) arr[j]++ arr[j] += arr[j]&gt;=arr[i] } } } //correct([0,0,0,0,0]) == [4,3,2,1,0] var n = 5 var arr_perm = [] for(var i=0; i&lt;factorial(n); i++){ var arr = i_to_insert_order(n, i) //arr = 0, 0..1, 0..2, 0..3, 0..4 correct(arr) arr_perm.push(arr) } arr_perm.reverse() //arr_perm.length == factorial(n) //arr_perm[0] == [0,1,2,3,4] //arr_perm[-1] == [4,3,2,1,0]</span></span></code> </pre>  A little bit of clarification: "~~ (x)" - a short recording of "Math.floor (x)", which I learned about from <a href="https://www.livecoding.tv/video/maison/playlists/html5-online-game-development/">livecoding video</a> .  When using a short recording, you should observe the restriction: 0 &lt;= x &lt;= 2147483647.9999998 (selected <a href="https://jsfiddle.net/u6sumssy/1/">experimentally</a> ).  For comparison, the limit for " <a href="https://jsfiddle.net/j0zoyL8h/2/">Math.floor</a> ": -9007199254740992 &lt;= x &lt;9007199254740993.  Array inversion is necessary to obtain permutations in <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B5%25D0%25BA%25D1%2581%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BF%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA">lexicographical order</a> .  By index we get (i_to_insert_order) one of the possible sequences for inserting elements.  In principle, it is enough to get a permutation of real elements: <pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, i, elem</span></span></span><span class="hljs-function">)</span></span>{arr.splice(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, elem)} <span class="hljs-comment"><span class="hljs-comment">//  var elements = ['word', 'symbol', 'face', 'colors', 'song'] // 35-   var order = i_to_insert_order(5, 35) var arr = [] for(var i=0; i&lt;order.length; i++) insert(arr, order[i], elements[i]) //arr == ['word', 'song', 'colors', 'symbol', 'face']</span></span></code> </pre>  But, in order to see a clear permutation, we emulate this insert.  This is what the correct function is for.  Perhaps this is not a very good example, because it blurs the main point. <br><br>  <i>The third principle of index-oriented programming</i> : <b>numbering options</b> . <br><br><h4>  Fibonacci number generation by number: </h4>  We use the abbreviated <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0_%25D0%25A4%25D0%25B8%25D0%25B1%25D0%25BE%25D0%25BD%25D0%25B0%25D1%2587%25D1%2587%25D0%25B8">Binet formula</a> .  Then, compare the result with the <a href="http://mitay.at.ua/index/currentfibonaci/0-14">table</a> . <pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> œÜ = (<span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(<span class="hljs-number"><span class="hljs-number">5</span></span>))/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib_by_index</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(œÜ, i)/<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>)) } fib_by_index(<span class="hljs-number"><span class="hljs-number">6</span></span>) == <span class="hljs-number"><span class="hljs-number">8</span></span> fib_by_index(<span class="hljs-number"><span class="hljs-number">50</span></span>) == <span class="hljs-number"><span class="hljs-number">12586269025</span></span></code> </pre><br>  And, finally, the <i>fourth principle of index-oriented programming</i> : <b>O (1) complexity algorithms</b> . <br><br>  Benefits: <ul><li>  speed (with a large number of conditions) </li><li>  resistance to <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D1%2582%25D0%25B0%25D0%25BA%25D0%25B0_%25D0%25BF%25D0%25BE_%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25B8">time attacks</a> </li></ul>  Disadvantages: <ul><li>  increased memory consumption </li><li>  you need to calculate all the conditions for the index </li></ul><br>  <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number">Number object</a> <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">permutation</a> <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0_%25D0%25A4%25D0%25B8%25D0%25B1%25D0%25BE%25D0%25BD%25D0%25B0%25D1%2587%25D1%2587%25D0%25B8">Fibonacci numbers</a> <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">computational complexity</a> <br>  Steve McConnell.  Code Complete, Second Edition.  Chapter 18: Tabular Methods </div><p>Source: <a href="https://habr.com/ru/post/270241/">https://habr.com/ru/post/270241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270229/index.html">Visual Studio Online: Continuous Integration and Testing</a></li>
<li><a href="../270231/index.html">How the second chip allows hackers to bypass the verification process of a bank card</a></li>
<li><a href="../270233/index.html">About Parboiled</a></li>
<li><a href="../270235/index.html">Programmer's resume: how to make it convenient?</a></li>
<li><a href="../270237/index.html">CONVERT web analytics and internet marketing conference: preliminary program</a></li>
<li><a href="../270243/index.html">Reaction to longevity: how we updated the Lingualeo frontend</a></li>
<li><a href="../270245/index.html">Smooth scroll on AngularJS using requestAnimationFrame + style tips</a></li>
<li><a href="../270247/index.html">SWAPY with a new code generator</a></li>
<li><a href="../270249/index.html">New Intercepter-NG released [Android Edition] 1.6</a></li>
<li><a href="../270251/index.html">‚ÄúStored Procedures‚Äù in Redis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>