<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Calendar tester" for September. Optimize tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="And again in our tape "Calendar tester . " This month Marina Tretyakov, a tester of the Kontur project. Deliveries , will tell about test optimization...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Calendar tester" for September. Optimize tests</h1><div class="post__text post__text-html js-mediator-article"><p>  And again in our tape <a href="http://t.me/QAcalendar">"Calendar tester</a> . <a href="http://t.me/QAcalendar">"</a>  This month Marina Tretyakov, a tester of the <a href="https://postavki.kontur.ru/">Kontur</a> project. <a href="https://postavki.kontur.ru/">Deliveries</a> , will tell about test optimization.  Marina will analyze specific problems and ways to solve them, and also advise how to optimize your tests and reduce the time for testing. </p><br><p> <a href="https://habr.com/company/skbkontur/blog/424349/"><img src="https://habrastorage.org/webt/wt/f_/zn/wtf_znw66msmecagrmdd6sssltm.jpeg"></a> </p><a name="habracut"></a><br><p>  First of all, let's divide all the testing according to the degree of automation in order to examine each type in the future in more detail. </p><br><p>  According to the degree of automation tests are divided into: </p><br><ol><li>  Hand held </li><li>  Automated. </li><li>  Automatic (without human intervention, at the moment - rather a myth than a reality). </li></ol><br><p>  The approach to test optimization directly depends on the degree of their automation. </p><br><h1 id="optimizacii-primenimye-ko-vsem-vidam-testov">  Optimizations applicable to all types of tests </h1><br><p>  Testing includes the steps: </p><br><ul><li>  preparation of the tested system, </li><li>  preparation of input data </li><li>  carrying out tests (manually or automatically, consider below), </li><li>  collection and analysis of results. </li></ul><br><p>  It is believed that manual regression takes the most time for testers.  However, in most cases this is not the case.  At a minimum, it is not worth asserting it until the problem is measured and proven. </p><br><p>  Consider solving common problems.  Many tips may seem very obvious to you, but as the experience of conferences and presentations of colleagues from other companies shows, these tips are still relevant and have proven their applicability and usefulness. </p><br><h3 id="problemy">  Problems: </h3><br><h3 id="1---dolgaya-podgotovka-testiruemoy-sistemy">  1. Long training of the system under test. </h3><br><p>  Questions that are important to ask before the introduction of optimizations: </p><br><ul><li>  Long regarding what? </li><li>  Who is involved in this training (testers, programmers ...)? </li><li>  How many times can you prepare a system under test in a working day?  Does this number match testing needs? </li><li>  What is the longest preparation stage and why? </li></ul><br><p>  To find the cause of this problem, it is important to ask the right question. <br>  Consider examples: </p><br><p>  <strong>Long compilation of all system modules</strong> <br>  <u>The correct question is</u> : do you need to compile all the modules? <br>  <u>Solution</u> : to compile not all modules of the system, but only those that were affected in the task, and which will participate in the release. </p><br><p>  <strong>A long manual process of updating the entire system for different "virtual" on the test bench</strong> <br>  <u>The correct question is</u> : at what point in the update is a person required to participate, and in which not? <br>  <u>Solution</u> : to automate the layout process, use special deployment tools and rolling out services or debugged release mechanisms for ‚Äúcombat‚Äù, but use them only for deploying to a test one. </p><br><p>  <strong>The long process of "spilling" the source for the "virtual" on the test bench for further compilation and rolling</strong> <br>  <u>Probable problem</u> : network interaction. <br>  <u>The correct question is</u> : long about what (gathering on a local machine, gathering on a local network)? <br>  <u>Solution</u> : the test bench and the place where the sources are located must be in the same network in order to minimize network interaction. </p><br><p>  I encountered this problem when I decided to change the test site in Yekaterinburg to Moscow.  And in the process of testing the ‚Äúlayout‚Äù of the site, we quickly noticed that the stand update did not take 3 minutes, but almost 15 minutes.  The reason was that the source code with a large number of small files was located in Yekaterinburg, and the stand in Moscow.  The layout process ‚Äúrested‚Äù on the network transfer of small files for further compilation and ‚Äúlayout‚Äù on the stand.  As a result, the code also ‚Äúwent‚Äù to Moscow :) </p><br><h3 id="2-dolgiy-sbor-i-analiz-rezultatov">  2. Long collection and analysis of results </h3><br><p>  Questions that are important to ask before the introduction of optimizations: </p><br><ul><li>  Long about what? </li><li>  What are the stages of the process of collecting and analyzing the results?  What is the longest stage and why? </li><li>  Who analyzes the results? </li><li>  Who decides on the release and on what basis?  How much time is spent making a decision? </li></ul><br><p>  <u>For example</u> : <br>  The test results are drawn up on the template, the design on the template takes most of the time when testing. </p><br><p>  <u>Solution (thanks, Cap!)</u> : Refuse to fill in the results by the template or create a template that is easier to fill.  It will be necessary to agree with the team and find out from those who read these results (do they read them?), Is there really a need for just such a template (the risk is to write test results ‚Äúin the table‚Äù). </p><br><h1 id="optimizacii-primenimye-k-ruchnym-testam">  Optimizations applicable to manual tests </h1><br><p>  These tests can be divided into two large classes: </p><br><ol><li>  conducted regularly, for example, before release (count regression testing), </li><li>  conducted rarely and only to test new functionality. </li></ol><br><p>  If the regression is carried out frequently and manually, then it makes sense to think about automation and automation payback, but in this article we will not consider automation ROI. </p><br><p>  For manual tests (not regression tests), we should speak not about test <strong>automation</strong> , but about <strong>instrumental support for</strong> testing (as advised by Alexey Barantsev at the training, which he conducted in our company).  In this case, autotests will act as a tool.  In this context, the logic and view on autotests in general will change. </p><br><blockquote>  When testing manually, first of all, it is necessary to look for routine tasks (tasks, not tests!), And to optimize them (using automation or redistribution of human resources). </blockquote><p>  For example, the routine task for tests is to prepare test data.  There are different ways to do this training: </p><br><ol><li>  manually via UI, </li><li>  manually through the API, </li><li>  by running autotests, then the data will be a side effect of these tests, </li><li>  automated via scripts / utilities / self-written tools via API or UI. </li></ol><br><p>  If you have never wondered how much time it takes to manually prepare test data, can it be time to measure it?  And it turns out that it is much more efficient to use at least the second, and preferably the 3rd and 4th approaches. </p><br><h1 id="optimizacii-primenimye-k-avtomatizirovannym-testam">  Optimizations applicable to automated tests </h1><br><p>  The problem of preparing test data here is more acute than with manual testing.  Preparation of test data should be: </p><br><ol><li>  quick, </li><li>  resistant to design / layout changes, </li><li>  resistant to possible parallel runs of tests, </li><li>  resistant to changes in the internal system architecture. </li></ol><br><p>  It is desirable that data preparation does not require additional skills and time to implement the solution. </p><br><p>  Automated test data can be prepared: </p><br><ol><li>  via UI, </li><li>  via API or HTTP requests, </li><li>  through database queries. </li></ol><br><p>  Consider the pros and cons of these approaches in more detail in the table: </p><br><img src="https://habrastorage.org/webt/rv/4c/8y/rv4c8ypxlb7spceq380djrc7upu.png"><br><p>  Preparation of test data via API or HTTP requests for a combination of pros and cons is the most optimal. </p><br><h2 id="est-ryad-naibolee-rasprostranennyh-optimizaciy-primenimyh-k-testam-provodimym-avtomatizirovanno">  There are a number of the most common optimizations applicable to automated tests: </h2><br><h4 id="parallelnost-testov">  Test parallelism </h4><br><p>  If one of the problems of tests is precisely the time they pass, while there are computing resources, you can parallelize and execute them in one of three parallelism modes: </p><br><ol><li>  Parallelism on one computer, parallelism on processor threads. </li><li>  Parallelism on different computers. </li><li>  The combination of the first and second methods, that is, if there are several computer machines, the tests pass in parallel along the threads on each and in parallel among all the machines. </li></ol><br><h4 id="udalenie-staryh-testov">  Delete old tests </h4><br><p>  If tests are written, they pass, but they don‚Äôt really check anything (for example, there was business logic before, now it‚Äôs not and tests don‚Äôt check anything), then such tests should be ruthlessly deleted, because in fact they don‚Äôt carry any meaning taking the extra time from the run.  It is also worth removing the tests, the result of passing which does not affect the decision about the possibility of release. </p><br><h4 id="primenenie-tehnik-test-dizayna-dlya-optimizacii-naborov-test-keysov">  Application of test design techniques to optimize test case sets </h4><br><p>  In manual testing, various test design techniques are required to optimize test case kits.  For autotests, you should also use the method of equivalence class breakdown, pairwise, boundary analysis and many other techniques to optimize the set of autotests. </p><br><h4 id="perenos-suschestvuyuschih-testov-i-proverok-na-drugoy-uroven">  Transferring existing tests and checks to another level </h4><br><p>  For example, there is a browser test that opens a search line, enters ‚Äúapple‚Äù, ‚Äúapples‚Äù, ‚Äúapple‚Äù, ‚Äúapples‚Äù (and so on), and looks that when searching for it, it seemed to him that a notification about buying apples in the store (test looks at the very fact of displaying the notification and no more).  Thus, a long test for UI does not in its essence check the UI, it checks the logic that the unit test can test, so this test should be removed and a unit test written instead. </p><br><h4 id="pravilnaya-dekompoziciya-testov-po-urovnyam-modulnye---integracionnye---sistemnye">  The correct decomposition of tests on the levels of ‚Äúmodular - integration - system‚Äù </h4><br><p>  I will give an example.  There is a manual script: select a product in the online store, put it in the basket and proceed to checkout.  What can be done (and it will be wrong): create exactly one test that will look for the product, add it to the cart and proceed to the checkout. </p><br><p>  In this case, it would be correct to first divide the test into three sub-scenarios: product selection, product addition to the basket, order placement.  Each scenario is divided into more atomic checks. <br>  For example: ‚Äústore opening - displaying different categories of goods for selection‚Äù - one test;  ‚ÄúSelecting categories from different product categories‚Äù is another test.  We consider each test in more detail and determine what level of tests are needed for it, the previous example can suggest which type of tests it is better to immediately issue as modular. </p><br><h1 id="populyarnaya-shema-svyazey-testiruemoy-i-testiruyuschey-sistem-pri-avtomatizirovannom-testirovanii-web-prilozheniy">  The popular connection scheme of the test and testing systems for automated testing of web applications: </h1><br><p>  To optimize automated testing of web applications, it is advisable to consider optimizing each interaction in the described scheme. </p><br><img src="https://habrastorage.org/webt/e8/7c/g2/e87cg2ftp026bsuwdxb1ufe4clm.png"><br><p>  <strong>For simplicity, consider optimizing some of the interactions:</strong> </p><br><p>  1) Interaction ‚Äútest cases - browser - database‚Äù <br>  Using the API not only to prepare the data for the test, but also to carry out a number of steps in the test. </p><br><p>  For example, if the goal is to check the UI at the end of a long chain of actions, then it is not at all necessary to carry out all actions through the UI.  After all, if in the middle of the chain in the UI something is broken, the test will not reach the end and the target check.  The tester will guess so, and if they fix this broken link in the chain, then everything that works after it?  If in this case, throughout the whole chain except for the last action, to use the API, then with a UI breakdown of any link, the tester will know whether the system will work as intended if the developers fix the broken link. </p><br><p>  2) Interaction ‚Äútest-cases - SeleniumWebDriver - browser‚Äù. </p><br><ul><li>  Closing extra tabs at the end of the test, instead of closing the browser. <br>  On my project, this optimization helped save 10 minutes in the UI test run (instead of 1 h. 10 min., Tests began to pass in 1 h.).  This optimization is connected with the logic of SeleniumWebDriver, which is used on the project - it has a very long preparation for opening the browser, but closing the tabs happens almost instantly. </li><li>  Optimization of the application cache of the system under test so that the tests run faster. </li><li>  Use headless browsers to avoid the cost of rendering elements of web pages. </li></ul><br><h1 id="v-zaklyuchenie">  Finally </h1><br><p>  For any optimization, it is necessary to clearly define for yourself the current problems in the testing process, break down the items in what they are, present possible options (better a few!) To solve them.  After that, it is required to voice them in a team, ‚Äúsell‚Äù your ideas and proposals for a solution, and only after general approval can you distribute the efforts and solve the set tasks.  The preliminary ‚ÄúBefore‚Äù rating and the ‚ÄúAfter‚Äù assessment will help to consider all the benefits from process optimization. </p><br><p>  And once again I would like to repeat: do not look for routine tests, look for routine tasks, and automate them! </p><br><p> List of calendar articles: <br>  <a href="https://habr.com/company/skbkontur/blog/433132/">Try a different approach</a> <br>  <a href="https://habr.com/company/skbkontur/blog/431460/">Reasonable pair testing</a> <br>  <a href="https://habr.com/company/skbkontur/blog/428089/">Feedback: as it happens</a> <br>  <a href="https://habr.com/company/skbkontur/blog/424349/">Optimize tests</a> <br>  <a href="https://habr.com/company/skbkontur/blog/421101/">Read the book</a> <br>  <a href="https://habr.com/company/skbkontur/blog/417287/">Analytics testing</a> <br>  <a href="https://habr.com/company/skbkontur/blog/414451/">The tester must catch the bug, read Kaner and organize a move.</a> <br>  <a href="https://habr.com/company/skbkontur/blog/358234/">Load service</a> <br>  <a href="https://habr.com/company/skbkontur/blog/353928/">Metrics in QA service</a> <br>  <a href="https://habr.com/company/skbkontur/blog/351806/">Test security</a> <br>  <a href="https://habr.com/company/skbkontur/blog/349274/">Know your customer</a> <br>  <a href="https://habr.com/company/skbkontur/blog/349300/">Disassemble backlog</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/424349/">https://habr.com/ru/post/424349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424337/index.html">Code in the style of Ruby: competently, beautifully and rationally. Beginner Example</a></li>
<li><a href="../424339/index.html">Tandem author and expert: how to make it effective?</a></li>
<li><a href="../424341/index.html">Elm. Comfortable and awkward. Composition</a></li>
<li><a href="../424343/index.html">Collaboration and access rights in DentalTap</a></li>
<li><a href="../424345/index.html">How I studied data science</a></li>
<li><a href="../424353/index.html">Background: the state Internet search engine "Sputnik" and its complex history</a></li>
<li><a href="../424355/index.html">Die casting: how it works</a></li>
<li><a href="../424361/index.html">How gamification improves user experience</a></li>
<li><a href="../424363/index.html">‚ÄúIf you want to create something really cool, you have to dig deeper and know how your code works in the system, on hardware‚Äù</a></li>
<li><a href="../424365/index.html">How stack trace works on ARM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>