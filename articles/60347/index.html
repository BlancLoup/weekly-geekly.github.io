<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Git wizardry</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction 

 In my last post I tried to highlight the style of working with 
 distributed git version control system and point out the differenc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Git wizardry</h1><div class="post__text post__text-html js-mediator-article"><h6>  1. Introduction </h6><br><br>  In my <a href="http://habrahabr.ru/blogs/Git/60030/"><b>last</b></a> post I tried to highlight the style of working with <br>  distributed git version control system and point out the differences from <br>  classic centralized SLE.  The goal was primarily a summary of the experience. <br>  work with the system without mentioning the subtleties of the syntax of individual commands. <br><br>  This topic was conceived as a direct introduction to working with git, something <br>  mean between tutorial and generalized help, which is still recommended <br>  read the above introduction.  Technical deliberately avoided <br>  the details of the git work, only common terms for SLE are used and <br>  limited to a list of referenced commands. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h6>  2 Working with a local repository </h6><br><br>  The power of any distributed systems is available to every local developer. <br>  repository in which it is possible to organize an arbitrary personal scheme <br>  development.  Git has a few basic commands for doing work on site and <br>  many auxiliary. <br><br><br><h5>  2.1 Basic commands </h5><br><br>  Basic commands - those without which it is impossible to do in the development. <br><br><br><h6>  2.1.1 <i>git init</i> - creating a repository </h6><br><br>  The git init command creates an empty repository in the directory as a directory. <br>  .git, where all information about the history of commits will be stored in the future, <br>  tags - project development: <br><br>  mkdir project-dir <br><br>  cd project-dir <br><br>  git init <br><br>  Another way to create a repository is with the git clone command, but more about that later. <br><br><br><h6>  2.1.2 <i>git add</i> and <i>git rm</i> - indexing changes </h6><br><br>  The next thing you need to know is the git add command.  It allows you to make changes to the index - temporary storage - which will then be included in the commit.  Examples <br>  use: <br><br>  git add EDITEDFILE - indexing the modified file, or a notification about <br>  creating a new one. <br><br>  git add.  - make the index all changes, including new files. <br><br>  From the index and tree of the project at the same time, you can delete the file with the git rm command: <br><br>  git rm FILE1 FILE2 - individual files <br><br>  git rm Documentation / \ *. txt is a good example of removing from git documentation, <br>  all txt files from the folder are deleted at once. <br><br>  You can reset the entire index or remove changes from a specific file from it. <br>  with the git reset command: <br><br>  git reset - reset nafig entire index. <br><br>  git reset - EDITEDFILE - remove a specific file from the index. <br><br>  The git reset command is not only used for dropping an index <br>  she will be given much more attention. <br><br><br><h6>  2.1.3 <i>git status</i> - project status, modified and not added files, indexed files </h6><br><br>  The git status command can perhaps be considered the most frequently used along with <br>  commit and index commands.  It displays information about all changes, <br>  the project directories listed in the tree compared to the last working commit <br>  branches;  separately indexed and non-indexed <br>  files.  Using it is extremely simple: <br><br>  git status <br><br>  In addition, git status indicates files with unresolved merge conflicts and <br>  files ignored by git. <br><br><br><h6>  2.1.4 <i>git commit</i> - commit commit </h6><br><br>  Commits are a basic concept in all version control systems, therefore they are committed <br>  he should easily and whenever possible quickly.  In its simplest form, enough <br>  after indexing dial: <br><br>  git commit <br><br>  If the index is not empty, then a commit will be made on its basis, after which <br>  user will be asked to comment on the changes made by calling the command <br>  edit (for example, in Ubuntu a simple text editor nano is usually called, <br>  me - emacs).  Save, and veil!  Commit ready. <br><br>  There are several keys that simplify git commit: <br><br>  git commit -a - commit, automatically indexing changes to files <br>  project.  New files <b>will not be</b> indexed!  Delete the same files <br>  will be taken into account. <br><br><br>  git commit -m "commit comment" - we comment on commit directly from the command line <br>  instead of a text editor. <br><br>  git commit FILENAME - will index and create commit based on changes <br>  single file. <br><br><br><h6>  2.1.5 <i>git reset</i> - return to a specific commit, rollback changes, ‚Äúhard‚Äù or ‚Äúsoft‚Äù </h6><br><br>  In addition to working with the index (see above), git reset allows you to reset the state <br>  project before any commit in history.  In git, this action can be two <br>  types: "soft" (soft reset) and "hard" (hard reset). <br><br><br>  "Soft" (with the key "--soft") cuts will leave your index and the whole tree intact <br>  files and project directories, will return to work with the specified commit.  Other <br>  in words, if you find an error in a commit you just made or <br>  comments to it, it is easy to rectify the situation: <br><br><ol><li>  git commit ... - incorrect commit; <br><br></li><li>  git reset --soft HEAD ^ - go to work on an already committed commit, <br>  saving all project status and indexed files <br></li><li>  edit WRONGFILE <br><br></li><li>  edit ANOTHERWRONGFILE <br><br></li><li>  add. <br><br></li></ol><br><br>  6.1.  git commit -c ORIG_HEAD - return to the last commit, will be prompted <br>  edit his message.  If the message remains the same, <br>  just change the case of the key -c: <br><br>  6.2.  git commit -C ORIG_HEAD <br><br>  Pay attention to the designation HEAD ^, it means "contact ancestor <br>  last commit.  The syntax for this relative addressing is described in more detail. <br>  will be lower in the section ‚ÄúHashes, tags, relative addressing‚Äù.  Respectively, <br>  HEAD - link to the last commit.  Reference ORIG_HEAD after a soft reset <br>  points to the original commit. <br><br><br>  Naturally, you can return to a great depth of commits, <br><br>  "Hard" rezet (key --hard) is the command that should be used with <br>  caution.  Git reset --hard will return the project tree and index to the state <br>  corresponding to the specified commit, deleting changes to subsequent commits: <br><br>  git add. <br><br>  git commit -m "destined to death" <br><br>  git reset --hard HEAD ~ 1 - no one will ever see this shameful commit. <br><br>  git reset --hard HEAD ~ 3 - or rather, the last three commit.  No one.  Never. <br><br><br>  If the command reaches the branch point, the commit will not be deleted. <br><br>  For commands to merge or siphon recent changes from a remote repository <br>  examples of the rezet will be given in the relevant sections. <br><br><br><h6>  2.1.6 <i>git revert</i> - cancellation of changes made in the past by a separate commit </h6><br><br>  There may be a situation in which you want to undo the changes made by an individual <br>  by commit  Git revert creates a new commit that applies inverse changes: <br><br><br>  git revert config-modify-tag - cancel a commit marked with a tag. <br><br>  git revert 12abacd - cancel a commit using its hash. <br><br>  To use the command, it is necessary that the project status does not differ from <br>  the state recorded by the last commit. <br><br><br><h6>  2.1.7 <i>git log</i> - a variety of information about commits in general, for individual files and different depths of immersion in history </h6><br><br>  Sometimes you need to get information about the history of commits, commits that changed <br>  separate file;  commits for a certain period of time and so on.  For these <br>  The git log command is used for targets. <br><br>  The simplest example of use is a short reference for all <br>  commits that have touched the currently active branch (about branches and branching <br>  You can find out more in detail in the section Branching and Merging): <br><br>  git log <br><br>  Get detailed information about each in the form of patches on the files from commits <br>  by adding the -p (or -u) switch: <br><br>  git log -p <br><br>  Statistics of file changes, such as the number of changed files entered into them <br>  lines, deleted files is called by key --stat: <br><br><br>  git log --stat <br><br>  For information on creating, renaming, and file access rights, the key is responsible. <br>  --summary: <br><br>  git log --smary <br><br>  To study the history of a single file, it is enough to specify as a parameter <br>  his name (by the way, in my old version of git, this method does not work, <br>  Be sure to add "-" before the "README"): <br><br>  git log README <br><br>  or, if the git version is not quite fresh: <br><br>  git log - README <br><br>  Further, only the more modern version of the syntax will be given.  maybe <br>  indicate the time starting at a specific moment (‚Äúweeks‚Äù, ‚Äúdays‚Äù, ‚Äúhours‚Äù, ‚Äús‚Äù <br>  and so on): <br><br>  git log --since = "1 day 2 hours" README <br><br>  git log --since = "2 hours" README <br><br>  git log --since = "2 hours" dir / - changes regarding a separate folder. <br><br><br>  You can build on the tags: <br><br>  git log v1 ... - all commits, starting with the tag v1. <br><br>  git log v1 ... README - all commits, including changes to the README file, starting with <br>  v1 tag <br><br>  git log v1..v2 README - all commits, including changes to the README file, starting with <br>  tag v1 and ending tag v2. <br><br>  Creating, listing, assigning tags will be given in the appropriate <br>  section below. <br><br>  Interesting features on the format of the output command provides key - pretty: <br><br><br>  git log --pretty = oneline - will output a hash to each of the commits. <br>  (here - the unique identifier of each commit, more details below). <br><br>  git log --pretty = short - concise information about commits, are given only <br>  author and comment <br><br>  git log --pretty = full / fuller - more complete information about commits named <br>  author, comment, date of creation and making commit <br><br>  In principle, the output format can be determined independently: <br><br>  git log - pretty = format: 'FORMAT' <br><br>  Format definitions can be found in the git log section of the Git Community Book. <br>  or help.  A handsome ASCII graph of commits is output using the key. <br>  --graph. <br><br><br><h6>  2.1.8 <i>git diff</i> - differences between project trees;  commits;  state index and any commit. </h6><br><br>  A kind of subset of the git log command can be considered the git diff command, <br>  defining changes between objects in a project: trees (files and <br>  directories): <br><br>  git diff will show changes not made to the index. <br><br>  git diff --cached - changes made to the index. <br><br><br>  git diff HEAD - changes in the project compared to the latest commit <br><br>  git diff HEAD ^ - last but one commit <br><br>  You can compare the "heads" of the branches: <br><br>  git diff master..experimental <br><br>  Well, or an active branch with any: <br><br>  git diff experimental <br><br><br><h6>  2.1.9 <i>git show</i> - show changes made by a separate commit </h6><br><br>  You can see the changes made by any commit in history using the git command. <br>  show: <br><br>  git show COMMIT_TAG <br><br><br><h6>  2.1.10 <i>git blame</i> and <i>git annotate</i> are helper commands that help track file changes </h6><br><br>  When working in a team, it is often required to find out exactly who wrote the specific <br>  code.  It is convenient to use the git blame command, which displays line-by-line information about <br>  Last commit, touching the line, author name and commit hash: <br><br>  git blame README <br><br>  You can also specify specific lines to display: <br><br>  git blame -L 2, + 3 README - displays information on three lines, starting with the second. <br><br>  The git annotate command works similarly, displaying both strings and information about <br>  kommitah, their touched: <br><br>  git annotate README <br><br><br><h6>  2.1.11 <i>git grep</i> - search for words by project, project status in the past </h6><br><br>  git grep, in general, simply duplicates the functionality of the famous Unix <br>  teams.  However, it allows words and their combinations to search in the past of the project, that <br>  It is very useful: <br><br>  git grep tst - search for the word tst in the project. <br><br>  git grep -c tst - count the number of references to tst in the project. <br><br><br>  git grep tst v1 - search in the old version of the project. <br><br>  The command allows to use logical AND and OR: <br><br>  git grep -e 'first' --and -e 'another' - find the lines where the first is also mentioned <br>  the word and the second. <br><br>  git grep - all-match -e 'first' -e 'second' - find the lines where it occurs though <br>  would be one of the words. <br><br><br><h5>  2.2 Branching </h5><br><br>  The branching and merging operations are the heart and soul of git, it is these capabilities that make such <br>  convenient work with the system. <br><br><br><h6>  2.2.1 <i>git branch</i> - creating, listing and deleting branches </h6><br><br>  Working with branches is a very easy procedure in git, all the necessary mechanisms. <br>  concentrated in one team: <br><br>  git branch will simply list existing branches, marking the active one. <br><br>  git branch new-branch - will create a new branch new-branch. <br><br>  git branch -d new-branch - will remove a branch if it <b>was flooded</b> (merged) with <br>  resolution of possible conflicts in the current. <br><br>  git branch -D new-branch will remove the branch <b>anyway</b> . <br><br>  git branch -m new-name-branch - rename the branch. <br><br><br>  git branch - contains v1.2 - will show those branches among which there are ancestors <br>  certain commit. <br><br><br><h6>  2.2.2 <i>git checkout</i> - switching between branches, extracting individual files from the commit history </h6><br><br>  The git checkout command allows you to switch between the latest commits (if <br>  simplified) branches: <br><br>  checkout some-other-branch <br><br>  checkout -b some-other-new-branch - will create a branch in which it will happen <br>  switching. <br><br>  If there were any changes in the current branch compared to the last commit in <br>  branch (HEAD), the command will refuse to switch in order not to lose <br>  produced work.  Ignore this fact allows the -f switch: <br><br>  checkout -f some-other-branch <br><br>  In the case when the changes must still be saved, use the -m switch.  Then the team <br>  before switching, will try to upload changes to the current branch and, after <br>  resolve possible conflicts, switch to new: <br><br>  checkout -m some-other-branch <br><br><br>  To return the file (or just pull it out from the past commit) allows a command like this: <br><br>  git checkout somefile - return somefile to the state of the last commit <br>  git checkout HEAD ~ 2 somefile ‚Äî return somefile to the state two commits back along the branch. <br><br><h6>  2.2.3 <i>git merge</i> - merge branches (resolution of possible conflicts). </h6><br><br>  Merging branches, as opposed to the usual practice of centralized systems, in git <br>  happens almost every day.  Naturally, there is a convenient interface to <br>  popular surgery: <br><br>  git merge new-feature - will try to merge the current branch and the new-feature branch. <br><br>  In the event of a conflict, commit does not occur, but on problem files <br>  special labels are placed a la svn;  the files themselves are marked in the index as <br>  "Unmerged".  Until the problems are resolved, commit <br>  will be impossible. <br><br>  For example, a conflict occurred in the TROUBLE file, which can be seen in git status: <br><br>  git merge experiment - a failed merge attempt occurred. <br><br>  git status - we look at problem places. <br><br>  edit TROUBLE - solve problems. <br><br>  git add.  - we index our changes, thereby removing tags. <br><br>  git commit - commit commit merge. <br><br>  That's all, nothing complicated.  If during the resolution process you decide not to allow <br>  conflict, just dial: <br><br>  git reset --hard HEAD - this will return both branches to their original states. <br><br><br>  If the merge commit was done, use the command: <br><br>  git reset --hard ORIG_HEAD <br><br><br><h6>  2.2.4 <i>git rebase</i> - building a flat line of commits </h6><br><br>  Suppose the developer started an additional branch to develop a separate <br>  possibilities and made several commits in it.  At the same time for any <br>  The reason for this was that commits were also made in the main branch: for example, there were <br>  flooded with changes from a remote server;  or the developer himself committed in it <br>  commits. <br><br>  In principle, you can do the usual <i>git merge</i> .  But then the line itself becomes more complicated. <br>  development, which is undesirable in too large projects where <br>  a lot of developers. <br><br>  Suppose there are two branches, master and topic, each of which had quite a few commits since the moment of branching. <br>  The git rebase command takes commits from the topic branch and overlays them on the last commit of the branch. <br>  master: <br><br><ol><li>  git-rebase master topic - a variant that explicitly states what and where <br>  is applied. <br></li><li>  git-rebase master - currently superimposed on master <br>  branch. <br><br></li></ol><br><br>  After using the command, the story becomes linear.  In the event of <br>  concurrency overlapping commits <br>  the work of the team will stop, and in problem areas of the files will appear <br>  corresponding tags.  After editing - conflict resolution - files <br>  should be indexed with git add and continue overlaying the following <br>  commits with git rebase --continue.  Alternative outputs are commands. <br>  git rebase --skip (skip the commit overlay and go to the next) or git <br>  rebase --abort (cancellation of the command and all changes made). <br><br>  With the -i (--interactive) switch, the command will work interactively. <br>  mode.  The user will be given the opportunity to determine the order of <br>  changes will automatically cause the editor to resolve conflicts and so <br>  Further. <br><br><br><h6>  2.2.5 <i>git cherry-pick</i> - applying changes made by a separate commit to the project tree </h6><br><br>  If you have a difficult development history, with several long branches <br>  developments, it may be necessary to apply changes made <br>  a separate commit of one branch, to a tree of another (currently active). <br><br>  git cherry-pick BUG_FIX_TAG - changes made by the specified commit will be <br>  applied to the tree, automatically indexed and become a commit in the active <br>  branch. <br><br>  git cherry-pick BUG_FIX_TAG -n - the key "-n" indicates that changes are necessary <br>  just apply to the project tree without indexing and creating a commit. <br><br><br><h5>  2.3 Other commands and capabilities </h5><br><br>  For the convenience of working with git, an additional concept was introduced: a tag.  Besides <br>  further will be explained the need for hashes, and its application;  shows the way <br>  access commits using relative addressing. <br><br><br><h6>  2.3.1 Hash - unique identification of objects </h6><br><br>  In git, to identify any objects, a unique one is used (that is, with <br>  tremendous probability of a unique) 40-character hash, which is determined by <br>  a hashing function based on the contents of the object.  Objects are everything: commits, <br>  files, tags, trees.  Because the hash is unique to the content, such as the file, <br>  it is very easy to compare such files - it‚Äôs enough just to compare two lines <br>  in forty characters. <br><br>  What interests us most is the fact that hashes identify commits.  In that <br>  sense hash is an advanced analogue of Subversion revisions.  A few examples <br>  using hashes as an addressing method: <br><br>  git diff f292ef5d2b2f6312bc45ae49c2dc14588eef8da2 - find the difference of the current <br>  project status and commit by number ... Well, you can see how. <br><br>  git diff f292ef5 is the same, but we leave only the first six characters.  Git <br>  understand which commit is in question if there is no other commit with such <br>  start hash. <br><br>  git diff f292 - sometimes four characters are enough. <br><br>  git log febc32 ... f292 - we read the log from the commit by commit. <br><br><br>  Of course, it‚Äôs not as convenient for a person to use hashes as a machine, which is why <br>  entered other objects - tags. <br><br><br><h6>  2.3.2 <i>git tag</i> - tags as a way to mark a unique commit </h6><br><br>  A tag is an object associated with a commit;  storing a link to the commit itself, name <br>  author, own name and some comment.  In addition, the developer can <br>  leave on such tags own digital signature. <br><br>  In addition, the git presents the so-called "lightweight tags" ("lightweight <br>  tags "), consisting only of the name and the link to the commit.  Such tags are usually <br>  used to simplify navigation through the history tree;  it's very easy to create them: <br><br>  git tag stable-1 - create a ‚Äúlightweight‚Äù tag associated with the latter <br>  by commit  If the tag is already there, another one will not be created. <br><br>  git tag stable-2 f292ef5 - mark a specific commit. <br><br>  git tag -d stable-2 - remove the tag. <br><br>  git tag -l - list tags. <br><br>  git tag -f stable-1.1 - create a tag for the last commit, replace <br>  existing, if any. <br><br>  After creating a tag, its name can be used instead of a hash in any commands. <br>  like git diff, git log and so on: <br><br><br>  git diff stable-1.1 ... stable-1 <br><br>  It makes sense to use regular tags to attach to a commit <br>  information like version number and commentary to it.  In other words, if in <br>  comments to the commit write ‚Äúfixed such and such a bug‚Äù, then in the comment to the tag by <br>  The name "v1.0" will be something like "stable version, ready to use": <br><br>  git tag -a stable - create a regular tag for the last commit;  will be called <br>  text editor to write a comment. <br><br>  git tag -a stable -m "production version" - create a regular tag, immediately specifying <br>  comment argument. <br><br>  Commands for enumeration, deletion, rewriting for ordinary tags do not differ from <br>  commands for lightweight tags. <br><br><br><h6>  2.3.3 Relative Addressing </h6><br><br>  Instead of revisions and tags, you can rely on another commit name. <br>  the mechanism is relative addressing.  For example, you can refer directly to the ancestor <br>  the last commit of the master branch: <br><br>  git diff master ^ <br><br>  If after the "bird" put a figure, then you can be addressed by several ancestors <br>  merge commits: <br><br>  git diff HEAD ^ 2 - find changes compared to the second ancestor of the latter <br>  commit in master.  HEAD here is a pointer to the last commit of the active branch. <br><br>  Similarly, a tilde can simply indicate how deep into the history of a branch <br>  need to dive: <br><br>  git diff master ^^ - what the grandfather of the current commit introduced. <br><br>  git diff master ~ 2 is the same. <br><br>  Notation can be combined to get to the desired commit: <br><br>  git diff master ~ 3 ^ ~ 2 <br><br>  git diff master ~ 6 <br><br><br><h6>  2.3.4 <i>.gitignore file</i> - we explain git which files should be ignored </h6><br><br>  Sometimes there are files in the project directories that you don‚Äôt want all the time. <br>  see in the git status summary.  For example, auxiliary text files <br>  editors, temporary files and other garbage. <br><br>  Making git status can be ignored by creating at the root or deeper in the tree <br>  (if restrictions should be only in certain directories) file <br>  .gitignore.  Ignore file patterns can be described in these files. <br>  specific format. <br><br>  An example of the contents of such a file: <br><br>  &gt;&gt;&gt;&gt;&gt;&gt;&gt; Start File <br><br>  # comments to the .gitignore file <br><br>  # ignore myself .gitignore <br><br><br>  .gitignore <br><br>  # all html files ... <br><br><br>  * .html <br><br><br>  # ... except for a certain <br><br><br>  ! special.html <br><br><br>  # do not need objectaries and archives <br><br>  *. [ao] <br><br>  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; End of File <br><br>  There are other ways to specify ignored files that you can learn about. <br>  from git help gitignore help. <br><br><br><h6>  3 "Together we are power", or the basics of working with a remote repository </h6><br><br>  Naturally, most projects still involve work in at least <br>  at least two developers who need to share code.  Next will be <br>  lists the commands required for collaborative ‚Äî possibly remote ‚Äî work. <br><br><br><h5>  3.1 Remote tracking branches </h5><br><br>  New concept here - remote branches.  Deleted branches correspond to any <br>  branch (more often master) on a remote server.  One such is created automatically when <br>  create a copy of the remote repository;  all commands related to the remote <br>  work, by default they will use this remote branch (usually <br>  called "origin"). <br><br>  Consider these commands. <br><br><br><h5>  3.2 <i>git clone</i> - creating a copy of the (remote) repository </h5><br><br>  To get started with the central repository, you should create a copy <br>  the original project with all its history locally: <br><br>  git clone / home / username / project myrepo - we clone the repository from the same machine <br>  to the myrepo directory. <br><br>  git clone ssh: // user @ somehost: port / ~ user / repository - we clone the repository, <br>  using the secure ssh protocol (for which you want to start on your machine <br>  ssh account). <br><br>  git clone git: // user @ somehost: port / ~ user / repository / project.git / - git has <br>  and own protocol. <br><br><br><h5>  3.3 <i>git fetch</i> and <i>git pull</i> - pick up changes from the central repository (from a remote branch) </h5><br><br>  To synchronize the current branch with the repository, use the git fetch and <br>  git pull. <br><br>  git fetch - pick changes to a remote branch from the default repository, <br>  main branch;  the one that was used in cloning <br>  repository  Changes will update the remote branch (remote tracking branch), after <br>  which will need to be merged with the local branch with the git merge command. <br><br>  git fetch / home / username / project - pick up changes from a specific <br>  repository <br><br>  It is also possible to use aliases for addresses created by the git remote command: <br><br>  git remote add username-project / home / username / project <br><br>  git fetch username-project - pick changes to the address specified <br>  synonym for <br><br>  Naturally, after evaluating changes, for example, using the git diff command, <br>  create a merge commit with the main: <br><br>  git merge username-project / master <br><br>  The git pull command immediately takes away the changes and merges with the active branch: <br><br>  git pull - pick up from the repository for which remote branches were created by <br>  default <br><br>  git pull username-project - pick changes from a specific repository. <br><br><br>  As a rule, the git pull command is used immediately. <br><br><br><h5>  3.4 <i>git push</i> - make changes to the remote repository (remote branch) </h5><br><br>  After working in the experimental branch, merging with the main, <br>  It is necessary to update the remote repository (remote branch).  For this <br>  use the git push command: <br><br>  git push - send your changes to the remote branch created by <br>  cloning by default. <br><br>  git push ssh: //yourserver.com/~you/proj.git master: experimental - send changes <br>  from the master branch to the experimental branch of the remote repository. <br><br>  git push origin: experimental ‚Äî in the remote repository origin, delete the experimental branch. <br><br>  git push origin master: master - to the remote master branch of the origin repository (synonym <br>  default repository) local branch branches master. <br><br><br><h6>  4 git-o-day </h6><br><br>  In this section several normal and slightly <br>  less unusual for working with git situations. <br><br><br><h5>  4.1 Normal workflow when working with a local repository </h5><br><br>  Git has extraordinary ease of use, not only as distributed <br>  version control system, but also in working with local projects.  Let's break it down <br>  the usual cycle - starting with creating a repository - the git developer‚Äôs work on <br>  own personal project: <br><br><ol><li>  mkdir git-demo <br><br></li><li>  cd git-demo <br><br></li><li>  git init <br><br></li><li>  git add. <br><br></li><li>  git commit -m "initial commit" <br><br></li><li>  git branch new-feature <br><br></li><li>  git checkout new-feature <br><br></li><li>  git add. <br><br></li><li>  git commit -m "Done with the new feature" <br><br></li><li>  git checkout master <br><br></li><li>  git diff HEAD new-feature <br><br></li><li>  git merge new-feature <br><br></li><li>  git branch -d new-feature <br><br></li><li>  git log --since = "1 day" <br><br></li></ol><br><br>  Let us examine each of the actions.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-2 - just create a working directory of the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">project. 3 - create a repository in the directory. 4 - we index all existing </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">project files (if, of course, they were in general). 5 - we create the initializing </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit. 6 - new branch, 7 - switching to it (can be done in one step </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the git checkout -b new-feature command). Next, after working directly with the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code, we index the changes made (8), commit (9). Switch to the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main branch (10), look at the differences between the last commit of the active branch and the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">last commit of the experimental </font><font style="vertical-align: inherit;">branch </font><font style="vertical-align: inherit;">(11). We merge (12) and, if there were </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no conflicts, delete the branch that is no longer needed (13). Well, just in case, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we estimate the work done for the last day (14).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why exactly? </font><font style="vertical-align: inherit;">Why abandon the linear model? </font><font style="vertical-align: inherit;">Even if only because </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the programmer has additional flexibility: he can switch </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">between tasks (branches); </font><font style="vertical-align: inherit;">there is always a ‚Äúpure pig‚Äù at hand - the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">master </font><font style="vertical-align: inherit;">branch </font><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">commits become smaller and more accurate.</font></font><br><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.2 Workflow when working with a remote repository </font></font></h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose you and a few of your partners have created a public </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repository to do some kind of common project. </font><font style="vertical-align: inherit;">What does the most </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">common git model of common work </font><font style="vertical-align: inherit;">look like </font><font style="vertical-align: inherit;">?</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">git clone </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://yourserver.com/~you/proj.git</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... it may have been some time.</font></font><br><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> git pull </font></font><br><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> git diff HEAD ^ </font></font><br><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">git checkout -b bad-feature </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... working for a while.</font></font><br><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> git commit -a -m "Created a bad feature" </font></font><br><br></li><li> git checkout master <br><br></li><li> git pull <br><br></li><li> git merge bad-feature <br><br></li><li> git commit -a <br><br></li><li> git diff HEAD^ <br> ‚Ä¶   , ,  -  .  Oops. <br><br><br></li><li> git reset --hard ORIG_HEAD <br><br></li><li> git checkout bad-feature <br> ‚Ä¶  . <br><br></li><li> git -m bad-feature good-feature <br><br></li><li> git commit -a -m ¬´Better feature¬ª <br><br></li><li> git checkout master <br><br></li><li> git pull <br><br></li><li> git merge good-feature <br><br></li><li> git push <br><br></li><li> git branch -d good-feature <br><br></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, first of all we create (1) create a copy of the remote repository (by </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">default, commands like git pull and git push will work with it). "Pulling" the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">latest updates (2); see what has changed (3); create a new branch and </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">switch to it (4); we index all changes and at the same time create a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit </font><font style="vertical-align: inherit;">from them </font><font style="vertical-align: inherit;">(5); switch to the main branch (6), update it (7); we </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merge with the bad-feature branch (8) and, after finding and resolving the conflict, we commit the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merge (9). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After committing a commit, we track changes (10), run, for example, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unit tests and with horror find that after a merger, the project collapses on most </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the tests.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In principle, tests could be run before the commit, at the time of the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merger (between points 8 and 9); </font><font style="vertical-align: inherit;">then a soft cut would suffice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, it is necessary to make a ‚Äúhard‚Äù (11) reset of the occurred merger, the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">branches returned to their original state. </font><font style="vertical-align: inherit;">Then we switch to the unsuccessful </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">branch (12), make the necessary changes and rename the branch (13). </font><font style="vertical-align: inherit;">Make a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commit (14); </font><font style="vertical-align: inherit;">go to the main branch (15), again we update it (16). </font><font style="vertical-align: inherit;">This time </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without confrontation, we merge (17), throw changes into the remote repository </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(18) and delete the branch that is now unnecessary (19). </font><font style="vertical-align: inherit;">We close the laptop, get dressed and go </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">home in the morning.</font></font><br><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 Conclusion </font></font></h6><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The topic does not address several important issues, such as the administration of a </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">public repository, integration with text editors or IDE, the </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use of SSH under Linux and Windows; </font><font style="vertical-align: inherit;">comments are welcome, and especially </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">additions to the git-o-day section. </font></font><br><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD: a note on working with a remote repository. </font><font style="vertical-align: inherit;">When working with git in terms of administration, creating public repositories, managing access, using encrypted connections, and so on, certain questions may arise; </font><font style="vertical-align: inherit;">and in this article they are not covered in any way. </font><font style="vertical-align: inherit;">For example, the above described work with a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ready-made</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> remote repository; </font><font style="vertical-align: inherit;">its deployment is not covered in any way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is all I am now collecting in a separate topic, which I will throw out here in a week and a half.</font></font><br></div><p>Source: <a href="https://habr.com/ru/post/60347/">https://habr.com/ru/post/60347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../60340/index.html">Intel Advertising</a></li>
<li><a href="../60341/index.html">Incorrect work habrapoisk</a></li>
<li><a href="../60342/index.html">Implementing FSM</a></li>
<li><a href="../60343/index.html">Online json parser</a></li>
<li><a href="../60345/index.html">We put PHP on the iPhone</a></li>
<li><a href="../60349/index.html">How do free software developers live and earn money?</a></li>
<li><a href="../60350/index.html">A systematic approach to the leader in working with the team. Do not repeat mistakes three times</a></li>
<li><a href="../60352/index.html">Alternative way to cache UserControls in Asp.net</a></li>
<li><a href="../60353/index.html">Pet Shop Boys (QR Code Video Remix)</a></li>
<li><a href="../60355/index.html">Installing Windows 7 on the EEE-PC 1000HE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>