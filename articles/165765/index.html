<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Patterns with a variable number of arguments using the example of a wrapper for Lua</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I needed to screw Lua to the project in C ++. To write wrappers by hand is too lazy (to write too much), the finished ones didn‚Äôt fit for one reason o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Patterns with a variable number of arguments using the example of a wrapper for Lua</h1><div class="post__text post__text-html js-mediator-article">  I needed to screw Lua to the project in C ++.  To write wrappers by hand is too lazy (to write too much), the finished ones didn‚Äôt fit for one reason or another.  I decided to write my own.  So I wondered how to simplify the interface as much as possible.  From the very thought of this, the terrible designs of the templates came to mind.  So it later turned out, but much easier than it seemed. <br><br>  In C ++ 11, templates with a variable number of arguments appeared; this allows writing template functions / classes in a way that was completely impossible in C ++ 03.  Such templates greatly simplify the task. <br><br>  The first thing I needed to do was write a wrapper over the simplest actions with the interpreter (one could do with simple calls to Lua C C, but I don‚Äôt want to keep a bunch of indexes of different values ‚Äã‚Äãon the stack in memory. So I wrapped them into several functions that besides from the need to pass into each function a pointer to the state of the interpreter, practically do not require indexes, since they have default values. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a result, I wanted to see an interface close to the following: <br><br><pre><code class="cpp hljs">lua.export_function(some_function);</code> </pre> <br><a name="habracut"></a><br>  You can also try.  However, the interface will still be a bit more complicated.  It is necessary to specify the name of the exported function to the interpreter.  And we will pass the address to the function. <br><br><pre> <code class="cpp hljs">lua.export_function(<span class="hljs-string"><span class="hljs-string">"some_function"</span></span>, &amp;some_function);</code> </pre><br>  We use the output of the template parameters.  Parameters can be displayed automatically if they are: <br><ul><li>  Return value of callback: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T (*callback)())</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre><br></li><li>  Callback Parameter: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*callback)(T))</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre><br></li><li>  The class to which the method belongs. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (T::*method)())</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre><br></li></ul><br>  All of these cases (and several others) can be combined.  You can take advantage of this. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, T (*function)(Args...))</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br>  Now, you can take on the actual export function.  For each function, create a lambda that will take arguments from the interpreter, pass them to the function, and then return the result to the interpreter.  Lambda should be stored all the time that an instance of the interpreter works, so I keep a pointer to each lambda inside the class and delete it in the destructor. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, T (*function)(Args...))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> function = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(Lua&amp;)&gt;([function](Lua&amp; vm) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tuple = args&lt;Args...&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply_function&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_size&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(tuple)&gt;::value&gt; ::apply(function, tuple); }); lambda(function); }</code> </pre><br>  Looks weird.  Let's try to figure it out.  First you need to get all the arguments from the interpreter. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;T, T1, Args...&gt; args(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>) { T t = arg&lt;T&gt;(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_cat(t, args&lt;T1, Args...&gt;(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre><br>  We get the i-th argument and return it, and with the help of recursion we get the remaining arguments.  But this is not enough. <br>  This function needs to be overloaded in order for the other code to be executed at the last iteration. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;T&gt; args(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;T&gt;(arg&lt;T&gt;(i)); }</code> </pre><br>  The arg function is obvious, I will not give it, all that is required is to write a few specializations. <br>  Now that we have all the arguments in one tuple, we need to pass them all to a function. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">apply_function</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... FunctionArgs, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... TupleArgs, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (*function)(Args...), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;TupleArgs...&gt;, Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply_function&lt;N<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::apply(function, tuple, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;N<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::value, args); } };</code> </pre><br>  And you need to specialize this template for the last iteration. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">apply_function</span></span></span><span class="hljs-class">&lt;0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... FunctionArgs, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... TupleArgs, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (*function)(Args...), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;TupleArgs...&gt;, Args... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*function)(args...); } };</code> </pre><br>  In addition to all this, a few more specializations are required (problems in the void type). <br><br><h4>  results </h4><br>  It turned out quite a working wrapper for exporting C ++ functions and classes to lua.  Of the obvious drawbacks, I see only a few: <br><ul><li>  Lambdas are still slower than callbacks, if you wish, you can rewrite the code without them, but you will get more sample functions. </li><li>  With each function / method call we get two recursions, the depth of which is equal to the number of arguments of the functions.  Perhaps the compiler will make the entire horde of template functions inline, I have not checked (and am not sure about this). </li><li>  Templates have a big effect on compile time.  But even on my rather weak laptop, the assembly of this wrapper and the code that uses it takes much less time than the assembly of code that uses boost, so this is not critical. </li><li>  No support for multiple inheritance - too dreary to do it. </li><li>  There is no access to metatables, which means there is no operator redefinition. </li><li>  There is no support for overloading functions, but you can simply give overloaded functions different names. </li></ul><br>  The last three points may do a little later. <br>  And now the pros: <br><ul><li>  Simple interface. </li><li>  The solution in pure C ++ 11 does not require the generation of additional code with additional tools. </li></ul><br><h5>  How to use </h5><br>  First of all, you need to create an object of the class util :: Lua, and the interpreter is initialized. <br><br><pre> <code class="cpp hljs">util::Lua vm;</code> </pre><br>  After that, you can export functions / classes. <br><br><h6>  Functions </h6><br>  It's simple.  We use only the function pointer and the name under which it will be available in lua. <br><br><pre> <code class="cpp hljs">some_function(); vm.export_function(<span class="hljs-string"><span class="hljs-string">"some_function"</span></span>, &amp;some_function);</code> </pre><br>  Types of all parameters and the return value will be defined and processed correctly. <br><br><h6>  Classes </h6><br>  The exported class must be prepared.  First you need to inherit it from util :: LuaClass so that when the object is returned to the interpreter, it is the object that is returned, not the userdata.  After you need to define three static methods. <br><ul><li>  The export_class method should export all class methods / functions. </li><li>  The export_me method should call the function Lua :: export_class &lt;A, B&gt; () </li><li>  The class_name method must return the class name. </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> util::LuaClass { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export_class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lua&amp; vm)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export_me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lua&amp; vm)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> A::export_me(Lua&amp; vm) { vm.export_class&lt;A&gt;(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export_class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lua&amp; vm)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export_me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Lua&amp; vm)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> B::export_me(Lua&amp; vm) { vm.export_class&lt;B, A&gt;(); }</code> </pre><br>  The util :: Lua :: export_class functions are passed as template parameters ‚Äî the class we want <br>  export and its parent to export and its (if it is not already done). <br><br>  The most interesting thing is going on in the export_class method.  For example: <br><br><pre> <code class="cpp hljs">vm.export_constructor&lt;A, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); vm.export_function(<span class="hljs-string"><span class="hljs-string">"static_method"</span></span>, &amp;A::static_method); vm.export_method(<span class="hljs-string"><span class="hljs-string">"method"</span></span>, &amp;A::method);</code> </pre><br>  It's simple.  We export static methods as functions, methods in a similar way, but through a separate function.  The constructor is exported as a function named new, the types of its arguments must be explicitly specified as <br>  template arguments, this is due to the fact that you cannot take a pointer to the constructor.  The nice thing is that objects created by calling such a constructor from lua will process the Garbage Collector.  When all object references are deleted, delete will be called for the C ++ object. <br><br><h5>  Code </h5><br>  All code is posted on <a href="https://github.com/alex-ac/LuaCxx/">github.com/alex-ac/LuaCxx</a> under the MIT license. <br>  I would be glad to see comments, tips, ficrequest and bug reports. <br><br><h6>  UPD </h6><br>  I almost forgot.  All code is built using g ++ 4.7.2, g ++&gt; = 4.6.4 and clang&gt; = 3.0 should also work. </div><p>Source: <a href="https://habr.com/ru/post/165765/">https://habr.com/ru/post/165765/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../165751/index.html">Ericsson sold 2,000 patents to the patent troll</a></li>
<li><a href="../165753/index.html">[Translation] As I read books on programming</a></li>
<li><a href="../165759/index.html">GitLab 4.0 and GitLab CI release</a></li>
<li><a href="../165761/index.html">How to build a design development of a very large and long project</a></li>
<li><a href="../165763/index.html">Mobile legal system ipLex.Profi</a></li>
<li><a href="../165767/index.html">Choosing a platform-specific library at runtime</a></li>
<li><a href="../165769/index.html">February 29, 2013 in Russian Railways</a></li>
<li><a href="../165775/index.html">Windows Azure Summit: large conference, free participation</a></li>
<li><a href="../165777/index.html">Electroluminescent backlight: cold neon</a></li>
<li><a href="../165779/index.html">Gamification - a fresh look at user motivation?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>