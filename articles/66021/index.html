<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ 0x (C ++ 11). Lambda expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Just the other day, I accidentally stumbled upon Habr√© on an article about lambda expressions from a new (future) C ++ standard. The article is good a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ 0x (C ++ 11). Lambda expressions</h1><div class="post__text post__text-html js-mediator-article">  Just the other day, I accidentally stumbled upon Habr√© on <a href="http://habrahabr.ru/blogs/cpp/65798/" title="Lambda expressions are now in C ++">an article about lambda expressions</a> from a new (future) C ++ standard.  The article is good and makes clear the advantages of lambda expressions, however, it seemed to me that the article was not complete enough, so I decided to try to present the material in more detail. <br><br><a name="habracut"></a><br><br><h2>  Recall the basics </h2>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Lambda expressions are one of the features of functional languages, which have recently begun to be added to imperative languages ‚Äã‚Äãlike C #, C ++ etc.  Lambda expressions are called anonymous local functions that can be created directly within an expression. <br><br>  In the last article, lambda expressions were compared with pointers to functions and functors.  So here is the first thing to be understood: <strong>lambda expressions in C ++ are a short form of writing anonymous functors</strong> .  Consider an example: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  1 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; srcVec; for (int val = 0; val &lt; 10; val++) { srcVec.push_back(val); } for_each(srcVec.begin(), srcVec.end(), [](int _n) { cout &lt;&lt; _n &lt;&lt; " "; }); cout &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre> <br><br>  In fact, this code entirely corresponds to this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  2 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class MyLambda { public: void operator ()(int _x) const { cout &lt;&lt; _x &lt;&lt; " "; } }; int main() { vector&lt;int&gt; srcVec; for (int val = 0; val &lt; 10; val++) { srcVec.push_back(val); } for_each(srcVec.begin(), srcVec.end(), MyLambda()); cout &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  The output will accordingly be as follows: <br><blockquote>  0 1 2 3 4 5 6 7 8 9 <br></blockquote><br><br>  What is worth paying attention to.  First, from <em>Listing 1,</em> we see that the lambda expression always starts with <strong>[]</strong> (the brackets may be non-empty ‚Äî more on this later), then the optional parameter list is followed, and then the function body itself.  Secondly, we did not specify the type of the return value, and by default the lambda returns <strong>void</strong> (we will see later how and why we can specify the return type explicitly).  Thirdly, as seen in <em>Listing 2</em> , a default method is generated by default (we'll return to this too). <br><br>  I don‚Äôt know about you, but I <strong>like for_each</strong> , which was written using lambda expressions, much more.  Let's try to write a slightly complicated example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  3 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; srcVec; for (int val = 0; val &lt; 10; val++) { srcVec.push_back(val); } int result = count_if(srcVec.begin(), srcVec.end(), [] (int _n) { return (_n % 2) == 0; }); cout &lt;&lt; result &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  In this case, lambda plays the role of a <em>unary predicate</em> , that is, the type of return value <strong>bool</strong> , although we have not indicated this anywhere.  If there is one <strong>return</strong> in the lambda expression, the compiler calculates the type of the return value independently.  If in the lambda expression there is an <strong>if</strong> or <strong>switch</strong> (or other complex constructions), as in the code below, then the compiler can no longer be relied upon: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  4 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; srcVec; for (int val = 0; val &lt; 10; val++) { srcVec.push_back(val); } vector&lt;double&gt; destVec; transform(srcVec.begin(), srcVec.end(), back_inserter(destVec), [] (int _n) { if (_n &lt; 5) return _n + 1.0; else if (_n % 2 == 0) return _n / 2.0; else return _n * _n; }); ostream_iterator&lt;double&gt; outIt(cout, " "); copy(destVec.begin(), destVec.end(), outIt); cout &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  The code in <em>Listing 4</em> does not compile, and, for example, Visual Studio writes an error for each <strong>return of</strong> this content: <br><pre>  "Error C3499: a lambda that has been defined as a void return type cannot return a value" </pre><br>  The compiler cannot independently calculate the type of the return value, so we must specify it explicitly: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  5 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; srcVec; for (int val = 0; val &lt; 10; val++) { srcVec.push_back(val); } vector&lt;double&gt; destVec; transform(srcVec.begin(), srcVec.end(), back_inserter(destVec), [] (int _n) -&gt; double { if (_n &lt; 5) return _n + 1.0; else if (_n % 2 == 0) return _n / 2.0; else return _n * _n; }); ostream_iterator&lt;double&gt; outIt(cout, " "); copy(destVec.begin(), destVec.end(), outIt); cout &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  Now the compilation is successful, and the output, as expected, will be as follows: <br><blockquote>  1 2 3 4 5 25 3 49 4 81 <br></blockquote><br><br>  The only thing we added in <em>Listing 5</em> is the return type for the lambda expression in the form <strong>-&gt; double</strong> .  The syntax is a bit weird and looks more like Haskell than C ++.  But it would not be possible to specify the return type ‚Äúon the left‚Äù (as in functions), because lambda must begin with <strong>[]</strong> so that the compiler can distinguish it. <br><br><h2>  Capture variables from external context </h2><br><br>  All the lambda expressions given above looked like anonymous functions because they did not store any intermediate state.  But lambda expressions in C ++ are anonymous functors, which means they can store the state!  Using lambda expressions, we write a program that displays the number of numbers that fall into the user-defined interval [lower;  upper): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  6 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;numeric&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; srcVec; for (int val = 0; val &lt; 10; val++) { srcVec.push_back(val); } int lowerBound = 0, upperBound = 0; cout &lt;&lt; "Enter the value range: "; cin &gt;&gt; lowerBound &gt;&gt; upperBound; int result = count_if(srcVec.begin(), srcVec.end(), [lowerBound, upperBound] (int _n) { return lowerBound &lt;= _n &amp;&amp; _n &lt; upperBound; }); cout &lt;&lt; result &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  Finally, we got to the point where the lambda expression does not begin with empty brackets.  As you can see in <em>Listing 6</em> , variables can appear inside square brackets.  This is called ... eeem ... <em>"</em> capture list".  What is it for?  At first glance, it may seem that the <strong>main ()</strong> function is the outer scope for a lambda expression and we can freely use the variables declared in it inside the body of the lambda expression, but this is not so.  Why?  Because in fact, the lambda body is the body of an overloaded <strong>operator () ()</strong> (how to call it ... functional function call operator) inside an anonymous functor, that is, for the code from <em>Listing 6, the</em> compiler will implicitly generate something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  7 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; class MyLambda { public: MyLambda(int _lowerBound, int _upperBound) : m_lowerBound(_lowerBound) , m_upperBound(_upperBound) {} bool operator ()(int _n) const { return m_lowerBound &lt;= _n &amp;&amp; _n &lt; m_upperBound; } private: int m_lowerBound, m_upperBound; }; int main() { vector&lt;int&gt; srcVec; for (int val = 0; val &lt; 10; val++) { srcVec.push_back(val); } int lowerBound = 0, upperBound = 0; cout &lt;&lt; "Enter the value range: "; cin &gt;&gt; lowerBound &gt;&gt; upperBound; int result = count_if(srcVec.begin(), srcVec.end(), MyLambda(lowerBound, upperBound)); cout &lt;&lt; result &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  <em>Listing 7</em> explains a little bit.  Our lambda has become a functor, inside of which we cannot directly use the variables declared in <strong>main ()</strong> , since these are non-intersecting scopes.  In order to access <strong>lowerBound</strong> and <strong>upperBound after</strong> all, these variables are stored inside the functor itself (the same ‚Äúcapture‚Äù occurs): the constructor initializes them, and they are used inside <strong>operator () ()</strong> .  I specifically gave these variables names starting with the prefix " <strong>m_</strong> " to emphasize the difference. <br><br>  If we try to change the ‚Äúcaptured‚Äù variables inside the lambda, we will fail, because by default the generated <strong>operator () () is</strong> declared as <strong>const</strong> .  In order to get around this, we can specify the <strong>mutable</strong> specifier, as in the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  8 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;numeric&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; srcVec; int init = 0; generate_n(back_inserter(srcVec), 10, [init] () mutable { return init++; }); ostream_iterator&lt;int&gt; outIt(cout, " "); copy(srcVec.begin(), srcVec.end(), outIt); cout &lt;&lt; endl &lt;&lt; "init: " &lt;&lt; init &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  Earlier, I mentioned that the list of lambda parameters can be omitted when it is empty, however, in order for the compiler to properly parse the use of the word <strong>mutable</strong> , we must explicitly specify an empty parameter list. <br>  When you run the program from <em>Listing 8,</em> we get the following: <br><blockquote>  0 1 2 3 4 5 6 7 8 9 <br>  init: 0 <br></blockquote><br><br>  As you can see, thanks to the <strong>mutable</strong> keyword, we can change the value of the ‚Äúcaptured‚Äù variable inside the body of the lambda expression, but, as one would expect, these changes do not affect the local variable, since the capture occurs by value.  C ++ allows us to capture variables by reference and even specify the <em>‚Äúcapture mode‚Äù used by default</em> .  What does this mean?  We can not specify each variable in the capture list separately: instead, you can simply specify the default capture mode, and then all the variables from the external context that are used inside the lambda will be automatically captured by the compiler.  To specify the default capture mode, there is a special syntax: <strong>[=]</strong> or <strong>[&amp;]</strong> to capture by value and by reference, respectively.  For each variable, you can specify your own capture mode, but the default mode, of course, is indicated only once, and at the very beginning of the capture list.  Here are the use cases: <br><br><pre> <code class="cpp hljs">[] <span class="hljs-comment"><span class="hljs-comment">//        [=] //      [&amp;] //      [x, y] //  x  y   [&amp;x, &amp;y] //  x  y   [in, &amp;out] //  in  ,  out ‚Äî   [=, &amp;out1, &amp;out2] //     ,  out1  out2, //     [&amp;, x, &amp;y] //     ,  x‚Ä¶</span></span></code> </pre><br><br>  It should be noted that syntax like <strong>&amp; out</strong> in this case does not mean taking the address.  It should be read more like <strong>SomeType &amp; out</strong> , that is, it is just passing a parameter by reference.  Consider an example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  9 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; srcVec; int init = 0; generate_n(back_inserter(srcVec), 10, [&amp;] () mutable { return init++; }); ostream_iterator&lt;int&gt; outIt(cout, " "); copy(srcVec.begin(), srcVec.end(), outIt); cout &lt;&lt; endl &lt;&lt; "init: " &lt;&lt; init &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  This time, instead of explicitly capturing the variable <strong>init</strong> , I specified the default capture mode: <strong>[&amp;]</strong> .  Now when the compiler encounters a variable from the external context inside the lambda body, it automatically grabs it by reference.  Here is the equivalent code in <em>Listing 9</em> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  10 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; class MyLambda { public: explicit MyLambda(int &amp; _init) : init(_init) { } int operator ()() { return init++; } private: int &amp; init; }; int main() { vector&lt;int&gt; srcVec; int init = 0; generate_n(back_inserter(srcVec), 10, MyLambda(init)); ostream_iterator&lt;int&gt; outIt(cout, " "); copy(srcVec.begin(), srcVec.end(), outIt); cout &lt;&lt; endl &lt;&lt; "init: " &lt;&lt; init &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  And accordingly, the output will be as follows: <br><blockquote>  0 1 2 3 4 5 6 7 8 9 <br>  init: 10 <br></blockquote><br><br>  Now the main thing for you is not to get confused what, where and when to pass by reference.  In fact, if we specify <strong>[&amp;]</strong> and do not specify <strong>mutable</strong> , we will still be able to change the value of the captured variable and this will affect the local one, because <strong>operator () () const</strong> implies that we cannot change what the link indicates, and this and so impossible. <br><br>  If the lambda expression has the form <strong>[=] (int &amp; _val) mutable {...}</strong> , then the variables are captured by value, but only their internal copy will change, but the parameter is passed by reference, that is, the changes will be reflected on the original.  If <strong>[] (const SomeBigObject &amp; _val) {...}</strong> , then nothing is captured, and the parameter is received via a constant link, etc. <br><br>  I understand that it is impossible to capture "by constant link".  Well, maybe we don‚Äôt need it. <br><br>  And what will happen if we write such a slightly contrived lambda expression inside a class method: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  11 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; class MyMegaInitializer { public: MyMegaInitializer(int _base, int _power) : m_val(_base) , m_power(_power) {} void initializeVector(vector&lt;int&gt; &amp; _vec) { for_each(_vec.begin(), _vec.end(), [m_val, m_power] (int &amp; _val) mutable { _val = m_val; m_val *= m_power; }); } private: int m_val, m_power; }; int main() { vector&lt;int&gt; myVec(11); MyMegaInitializer initializer(1, 2); initializer.initializeVector(myVec); return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  Despite all our expectations, the code will not be compiled, since the compiler will not be able to capture <strong>m_val</strong> and <strong>m_power</strong> : these variables are out of scope.  This is what Visual Studio says: <br><pre>  "Error C3480: 'MyMegaInitializer :: m_power': a lambda capture variable scope" </pre><br>  How to be?  To gain access to class members, you need to put <strong>this</strong> in the capture-list: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  12 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; class MyMegaInitializer { public: MyMegaInitializer(int _base, int _power) : m_val(_base) , m_power(_power) {} void initializeVector(vector&lt;int&gt; &amp; _vec) { for_each(_vec.begin(), _vec.end(), [this] (int &amp; _val) mutable { _val = m_val; m_val *= m_power; }); } private: int m_val, m_power; }; int main() { vector&lt;int&gt; myVec(11); MyMegaInitializer initializer(1, 2); initializer.initializeVector(myVec); for_each(myVec.begin(), myVec.end(), [] (int _val) { cout &lt;&lt; _val &lt;&lt; " "; }); cout &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  This program does exactly what we expected: <br><blockquote>  1 2 4 8 16 32 64 128 256 512 1024 <br></blockquote><br><br>  It should be noted that <strong>this</strong> can only be captured by value, and if you try to capture by reference, the compiler will generate an error.  Even if you write <strong>[&amp;]</strong> instead of <strong>[this]</strong> in the code in <em>Listing 12</em> , <strong>this</strong> will still be captured by value. <br><br><h2>  Other </h2><br><br>  In addition to all of the above, in the header of a lambda expression, you can specify a throw-list - a list of exceptions that lambda can generate.  For example, such a lambda cannot generate exceptions: <br><pre> <code class="cpp hljs">[] (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _n) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>() { ‚Ä¶ }</code> </pre><br>  And this only generates <strong>bad_alloc</strong> : <br><pre> <code class="cpp hljs">[=] (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; _str) <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> { ‚Ä¶ }</code> </pre><br>  Etc. <br><br>  Naturally, if it is not specified, then the lambda can generate any exception. <br><br>  Fortunately, in the final version of the standard throw-specifications declared obsolete.  Instead, they left the <strong>noexcept</strong> keyword, which says that the function should not throw an exception at all. <br><br>  Thus, the general view of the lambda expression is as follows (sorry for such a ‚Äúfree form‚Äù of grammar): <br><pre>     lambda-expression :: =
                   '[' [&lt;gripping_list&gt;] ']'
                 ['(' &lt;list_of_parameters&gt; ')' ['mutable']]
                 ['noexcept']
                 ['-&gt;' &lt;return type&gt;]
                   '{' [&lt;lambda body&gt;] '}'
</pre><br><br><h2>  Reuse lambda expressions.  Generation of lambda expressions. </h2><br><br>  All of the above is quite convenient, but the main power of lambda expressions comes from the fact that we can store the lambda in a variable or pass it as a parameter to a function.  Boost for this is the <a href="http://www.boost.org/doc/libs/1_39_0/doc/html/function.html">Function</a> class, which, if I'm not mistaken, will be included in the new STL standard (perhaps in a slightly modified form).  At the moment, you can already use the features of the updated STL, however, so far these features are in the subspace of the names <strong>std :: tr1</strong> . <br><br>  The ability to save lambda expressions allows us not only to reuse lambdas, but also to write functions that generate lambdas, and even lambdas that generate lambdas. <br><br>  Consider the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  13 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; using std::tr1::function; int main() { vector&lt;int&gt; myVec; int init = 0; generate_n(back_inserter(myVec), 10, [&amp;] { return init++; }); function&lt;void (int)&gt; traceLambda = [] (int _val) -&gt; void { cout &lt;&lt; _val &lt;&lt; " "; }; for_each(myVec.begin(), myVec.end(), traceLambda); cout &lt;&lt; endl; function&lt;function&lt;int (int)&gt; (int)&gt; lambdaGen = [] (int _val) -&gt; function&lt;int (int)&gt; { return [_val] (int _n) -&gt; int { return _n + _val; }; }; transform(myVec.begin(), myVec.end(), myVec.begin(), lambdaGen(2)); for_each(myVec.begin(), myVec.end(), traceLambda); cout &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  This program displays: <br><blockquote>  0 1 2 3 4 5 6 7 8 9 <br>  2 3 4 5 6 7 8 9 10 11 <br></blockquote><br><br>  Consider more.  Initially, we initialize the vector using <strong>generate_n ()</strong> .  Everything is simple.  Next, we create a <strong>traceLambda</strong> variable of the <strong>function</strong> type <strong>&lt;void (int)&gt;</strong> (that is, a function that takes an <strong>int</strong> and returns <strong>void</strong> ) and assign a lambda expression to it, which outputs a value and a space to the console.  Next we use the lambda just saved to display all the elements of the vector. <br><br>  After this we see a rather <strong>lambdaGen declaration</strong> , which is a lambda expression, which takes one <strong>int</strong> parameter and returns another lambda, takes an <strong>int</strong> and returns an <strong>int</strong> . <br><br>  Following this, we apply <strong>transform ()</strong> to all elements of the vector, for which we specify <strong>lambdaGen (2)</strong> as the mutational function.  In fact, <strong>lambdaGen (2)</strong> returns another lambda, which adds the number 2 to the passed parameter and returns the result.  This code, of course, is a bit contrived, because the same could be written as <br><pre> <code class="cpp hljs">transform(myVec.begin(), myVec.end(), myVec.begin(), bind2nd(plus&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(), <span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre><br>  however, as an example, quite indicative. <br><br>  Then we again display the values ‚Äã‚Äãof all the elements of the vector using the <strong>traceLambda</strong> saved earlier in the lambda. <br><br>  In fact, this code could be written even shorter.  In the new C ++ standard, the value of the <strong>auto</strong> keyword will be replaced.  If earlier, <strong>auto</strong> meant that a variable is being created on the stack, and implicitly implied if you did not specify something else ( <strong>register</strong> , for example), now it is such an analog of <strong>var</strong> in C # (that is, the type of a variable declared as <strong>auto</strong> , is determined by the compiler independently on the basis of what this variable is initialized with). <br>  It should be noted that the <strong>auto-</strong> variable will not be able to store values ‚Äã‚Äãof different types during one program run.  C ++ both was and remains a statically typed language, and the <strong>auto</strong> indication only tells the compiler to take care of the type definition itself: after initialization, changing the type of the variable will no longer be possible. <br><br>  In addition, the <strong>auto</strong> keyword is very useful when working with cycles like <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = vec.begin(); it != vec.end(); ++it) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  it is very convenient to use it with lambda expressions.  Now the code from <em>Listing 13</em> can be rewritten as: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  14 #include &lt;algorithm&gt; #include &lt;cstdlib&gt; #include &lt;functional&gt; #include &lt;iostream&gt; #include &lt;iterator&gt; #include &lt;vector&gt; using namespace std; using std::tr1::function; int main() { vector&lt;int&gt; myVec; int init = 0; generate_n(back_inserter(myVec), 10, [&amp;] { return init++; }); auto traceLambda = [] (int _val) -&gt; void { cout &lt;&lt; _val &lt;&lt; " "; }; for_each(myVec.begin(), myVec.end(), traceLambda); cout &lt;&lt; endl; auto lambdaGen = [] (int _val) -&gt; function&lt;int (int)&gt; { return [_val] (int _n) -&gt; int { return _n + _val; }; }; transform(myVec.begin(), myVec.end(), myVec.begin(), lambdaGen(2)); for_each(myVec.begin(), myVec.end(), traceLambda); cout &lt;&lt; endl; return EXIT_SUCCESS; }</span></span></code> </pre><br><br>  Perhaps, on this I will finish the description of lambda expressions.  If you have questions, corrections or comments, I will be happy to hear. <br><br>  PROFIT! <br><br> <a href="http://progg.ru/C0x-%25D0%259B%25D1%258F%25D0%25BC%25D0%25B1%25D0%25B4%25D0%25B0-%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F-C-%25D0%25A5%25D0%25B0%25D0%25B1%25D1%2580%25D0%25B0%25D1%2585%25D0%25B0%25D0%25B1%25D1%2580"><img alt="Progg it" src="http://progg.ru/image.axd?url=http%3A%2F%2Fhabrahabr.ru%2Fblogs%2Fcpp%2F66021%2F"></a> <br><br>  <strong>ETA (02.20.2012):</strong> It turned out that for some people this article is still relevant, so I corrected the syntax highlighting and corrected the information about the throw lists in the lambda declaration.  In addition to directly lambda expressions, I decided not to add other features from the new C ++ 11 standard (for example, container initialization lists), so the article remained practically intact. </div><p>Source: <a href="https://habr.com/ru/post/66021/">https://habr.com/ru/post/66021/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../66015/index.html">Streaming Video: Broadcasting with the N810</a></li>
<li><a href="../66016/index.html">Market basket analysis and association rules</a></li>
<li><a href="../66018/index.html">Zii EGG with Android on board</a></li>
<li><a href="../66019/index.html">Another PS3 exclusive has been announced: Wizardry: The Dungeon Of Captured Souls</a></li>
<li><a href="../66020/index.html">What is Zeroconf and what it is eaten with</a></li>
<li><a href="../66022/index.html">Live talk show took place. Theme of the broadcast: dubbing, localization and adaptation of full-length pictures and TV shows</a></li>
<li><a href="../66023/index.html">Multiphone from Megaphone - use alternative SIP client</a></li>
<li><a href="../66025/index.html">Puzzling 6 months later</a></li>
<li><a href="../66026/index.html">IronRuby 0.9 released</a></li>
<li><a href="../66027/index.html">OpenOffice got your ribbon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>