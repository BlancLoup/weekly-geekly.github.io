<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Textbook on the programming language D. Part 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The fifth part of the translation is D Programming Language Tutorial by Ali √áehreli . In this part the chapter Logical Expressions is translated. Chap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Textbook on the programming language D. Part 5</h1><div class="post__text post__text-html js-mediator-article">  The fifth part of the translation is <a href="http://ddili.org/ders/d.en/index.html">D Programming Language Tutorial</a> by <a href="http://ddili.org/AliCehreli_resume.html">Ali √áehreli</a> .  In this part the chapter Logical Expressions is translated.  Chapter material is designed for beginners. <br><ol><li>  <a href="http://habrahabr.ru/post/226071/">Part 1</a> </li><li>  <a href="http://habrahabr.ru/post/226565/">Part 2</a> </li><li>  <a href="http://habrahabr.ru/post/243595/">Part 3</a> </li><li>  <a href="http://habrahabr.ru/post/243687/">Part 4</a> </li></ol><a name="habracut"></a><br><br><h1>  Boolean expressions </h1><br>  The actual work that the program performs is in expressions.  Any part of a program that creates a value or a side effect is called an expression.  It is defined by a broad concept, because even a constant value, say 42, and a string value, for example ‚Äúhello‚Äù, are expressions, since they create these corresponding constants 42 and ‚Äúhello‚Äù. <br><br>  <i><b>Important:</b> Do not confuse creating a value with a variable declaration.</i>  <i>Values ‚Äã‚Äãdo not need to bind to variables.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Function calls, such as <b>writeln</b> , are expressions, by the way, because they have side effects.  In the case of <b>writeln</b> , this effect is superimposed on the standard output stream by printing characters on it.  Another example of the programs that we wrote earlier may be an assignment operation, which changes the variable that is on the left. <br><br>  Because of the creation of values, expressions may participate in other expressions.  This allows us to form more complex expressions from simpler ones.  For example, suppose that there is a function called <b>currentTemperature</b> , which returns the value of the current air temperature, this value that it produces can be directly used in the <b>writeln</b> expression: <br><br><pre><code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"It's "</span></span>, currentTemperature(),<span class="hljs-string"><span class="hljs-string">" degrees at the moment."</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  This line contains the following: <ol><li>  ‚ÄúIt's‚Äù </li><li>  currentTemperature () </li><li>  "degrees at the moment. </li><li>  <b>writeln () is an</b> expression that uses the previous three. </li></ol><br>  In this chapter, we will discuss the specific types of expressions that are used in conditional statements. <br><br>  Before going further I would like to repeat the assignment statement again, now emphasizing these two expressions that are on the left and right of it.  The assignment operator (=) assigns the value of the specified expression to the right of the expression to the left (for example, a variable). <pre> <code class="hljs objectivec">temperature = <span class="hljs-number"><span class="hljs-number">23</span></span> <span class="hljs-comment"><span class="hljs-comment">// temperature's value becomes 23</span></span></code> </pre> <br><br><h2>  Boolean expressions </h2><br>  Logical expressions are expressions that are used in Boolean algebra.  Logical expressions are what computer programs do, making decisions like "if the answer is yes, I will save the file." <br><br>  Boolean expressions can have one of two values: <b>false</b> , meaning false, and <b>true</b> , meaning true. <br><br>  I will use <b>writeln</b> expressions in the following examples.  If the line prints <b>true</b> at the end, it will mean that what is printed on this line is true.  Similarly, <b>false</b> will mean that what is printed is false.  For example, if this program output is: <blockquote>  There is coffee: true </blockquote>  it will mean "there is coffee."  Similarly: <blockquote>  There is coffee: false </blockquote>  would mean "there is no coffee."  Please note that in reality the ‚Äúis‚Äù located on the left does not mean that there is coffee.  I use the construct "... is ...: false" to mean "this is not so" or "this is false."  Logical expressions are actively used in predicates, cycles, function arguments, etc. It is important to understand how they work.  Fortunately, logical expressions are very simple to explain and easy to use. <br><br>  Below are the logical operators that are used in logical expressions: <ul><li>  The equality operator (==) answers the question ‚Äúis this equal to this?‚Äù.  It compares the two expressions to its left and returns <b>true</b> if they are equal and <b>false</b> if not.  Essentially, the value returned by the equality operator (==) is a logical expression. <br>  As an example, suppose we have these two variables: <pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> daysInWeek = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> monthsInYear = <span class="hljs-number"><span class="hljs-number">12</span></span>;</code> </pre>  Next, these are two logical expressions that use these values: <pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">daysInWeek</span></span> == <span class="hljs-number"><span class="hljs-number">7</span></span> // <span class="hljs-literal"><span class="hljs-literal">true</span></span> monthsInYear == <span class="hljs-number"><span class="hljs-number">11</span></span> // <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> </li><li>  The inequality operator (! =) Answers the question ‚Äúthis is not equal to this‚Äù.  It compares these two expressions on both sides and returns the opposite of what the operator (==) returns <pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">daysInWeek</span></span> != <span class="hljs-number"><span class="hljs-number">7</span></span> // <span class="hljs-literal"><span class="hljs-literal">false</span></span> monthsInYear != <span class="hljs-number"><span class="hljs-number">11</span></span> // <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> </li><li>  The disjunction operator (||) denotes "or", and returns <b>true</b> if any of the logical expressions is <b>true</b> <br><br>  If the value of the expression on the left is <b>true</b> , then the operator will return <b>true</b> and will not even look at the expression on the right.  If the expression on the left returns <b>false</b> , the operator returns the value of the expression on the right.  This operator is similar to the union "or" in Russian. <br><br><table border="1" cellspacing="5" cellpadding="5"><tbody><tr><th>  Left expression </th><th>  Operator </th><th>  Right expression </th><th>  Result </th></tr><tr><td>  false </td><td>  || </td><td>  false </td><td>  false </td></tr><tr><td>  false </td><td>  || </td><td>  true </td><td>  true </td></tr><tr><td>  true </td><td>  || </td><td>  false (doesn't matter) </td><td>  true </td></tr><tr><td>  true </td><td>  || </td><td>  true (doesn't matter) </td><td>  true </td></tr></tbody></table><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.stdio; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>  "", <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>  "" <span class="hljs-type"><span class="hljs-type">bool</span></span> existsCoffee = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-type"><span class="hljs-type">bool</span></span> existsTea = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; writeln("There is warm drink: ", existsCoffee || existsTea); }</code> </pre>  Because at least one of the two expressions, the true logical expression above returns true. </li><li>  The conjunction operator (&amp;&amp;) denotes "and" and returns <b>true</b> if both expressions, left and right, return <b>true</b> . <br><br>  If the value of the expression on the left is <b>false</b> , the operator will return <b>false</b> and will not even look at the expression on the right.  If the expression on the left returns <b>true</b> , then the operator returns the value of the expression on the right.  This operator is similar to the union ‚Äúand‚Äù in Russian. <table border="1" cellspacing="5" cellpadding="5"><tbody><tr><th>  Left expression </th><th>  Operator </th><th>  Right expression </th><th>  Result </th></tr><tr><td>  false </td><td>  &amp;&amp; </td><td>  false (doesn't matter) </td><td>  false </td></tr><tr><td>  false </td><td>  &amp;&amp; </td><td>  true (doesn't matter) </td><td>  false </td></tr><tr><td>  true </td><td>  &amp;&amp; </td><td>  false </td><td>  false </td></tr><tr><td>  true </td><td>  &amp;&amp; </td><td>  true </td><td>  true </td></tr></tbody></table></li><li>  The strict disjunction operator (^) answers the question ‚Äúone or the other, but not both?‚Äù.  This statement returns <b>true</b> if only one expression returns <b>true</b> , but not both. <table border="1" cellspacing="5" cellpadding="5"><tbody><tr><th>  Left expression </th><th>  Operator </th><th>  Right expression </th><th>  Result </th></tr><tr><td>  false </td><td>  ^ </td><td>  false </td><td>  false </td></tr><tr><td>  false </td><td>  ^ </td><td>  true </td><td>  true </td></tr><tr><td>  true </td><td>  ^ </td><td>  false </td><td>  true </td></tr><tr><td>  true </td><td>  ^ </td><td>  true </td><td>  false </td></tr></tbody></table>  For example, this logic that represents: "I will play chess, if only one of two friends comes."  This can be programmed as follows: <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"I will play chess: "</span></span>, jimShowedUp ^ bobShowedUp)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li><li>  The operator is strictly less (&lt;) answers the question ‚ÄúIs it less than this?‚Äù (Or ‚ÄúWill it be higher when sorting?‚Äù) <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"We beat: "</span></span>, theirScore &lt; ourScore)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li><li>  The operator strictly more (&gt;) answers the question ‚ÄúIs it more than that?‚Äù (Or ‚ÄúWill it be lower when sorting?‚Äù.) <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"They beat: "</span></span>, theirScore &gt; ourScore)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li><li>  The operator is less stringent (&lt;=) answers the question ‚ÄúIs it less or equal to this?‚Äù (Or ‚ÄúWill it be higher on sorting or on the same query?‚Äù.) <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"We were not beaten: "</span></span>, theirScore &lt;= ourScore)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li><li>  The operator is less strictly less (&gt; =) answers the question ‚ÄúIs it greater or equal to this?‚Äù (Or ‚ÄúWill it be lower or with the same query when sorting?‚Äù.) <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"We did not beat: "</span></span>, theirScore &gt;= ourScore)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li><li>  The inversion operator (!) Means "This is the opposition of something."  It differs from previous statements in that it works with only one expression and returns <b>true</b> if the expression returns <b>false</b> , and returns <b>false</b> if the expression returns <b>true</b> . <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"I will walk: "</span></span>, !existsBicycle)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li></ul><br><br><h2>  Expression grouping </h2><br>  The order in which these expressions are evaluated can be specified using parentheses.  They can also be grouped.  When expressions in brackets fall into more complex expressions, the values ‚Äã‚Äãof these expressions are calculated before they are used in the expressions in which they fall.  For example, this expression ‚Äúif there is coffee or tea, as well as a cookie or a bun, then I am happy‚Äù can be programmed in approximately the following way: <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"I am happy: "</span></span>, (<span class="hljs-name"><span class="hljs-name">existsCoffee</span></span> || existsTea) <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> (<span class="hljs-name"><span class="hljs-name">existsCookie</span></span> || existsScone))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre>  If these nested expressions were not enclosed in parentheses, then they will be executed taking into account the operators' priorities according to rules D (which were inherited from the C language).  Since the conjunction operator <b>&amp;&amp;</b> priority is higher than that of the disjunction operator <b>||</b>  , writing an expression without parentheses will not be calculated as expected. <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"I am happy: "</span></span>, existsCoffee || existsTea <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> existsCookie || existsScone)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre>  The conjunction operator <b>&amp;&amp;</b> will execute first, and the entire expression will be semantically equivalent to the following expression: <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"I am happy: "</span></span>, existsCoffee || (<span class="hljs-name"><span class="hljs-name">existsTea</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> existsCookie) || existsScone)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre>  This has a different meaning: ‚ÄúIf there is coffee or tea with cookies or a bun, then I'm happy.‚Äù <br><br><br><h2>  Reading <b>bool</b> type input </h2><br>  All <b>bool</b> values ‚Äã‚Äãabove are printed as ‚Äúfalse‚Äù or ‚Äútrue‚Äù.  But this does not work in the opposite direction: these lines are ‚Äúfalse‚Äù and ‚Äútrue‚Äù are not automatically read as values <b>false</b> and <b>true</b> .  For this reason, this input must be read as strings and then converted to values ‚Äã‚Äãof type <b>bool</b> . <br><br>  Since in one of the exercises below you need to enter ‚Äúfalse‚Äù and ‚Äútrue‚Äù, I have to use the features of D, which I have not explained to you yet.  I have described below a method that converts the specified string input data to <b>bool</b> data.  This method will solve this problem by running <b>to</b> , which is declared in the <b>std.conv</b> module.  (You may see a <b>ConvException</b> error if you type anything other than "false" or "true.") <br><br>  I hope that all parts of the code that are in <b>main ()</b> in the following programs are understandable at this stage.  <b>read_bool ()</b> is the method in which there are new, for you, language features.  Although I put in comments for what he does, you can ignore this method.  Still, it must be in the program code for compilation and correct operation. <br><br><h2>  Exercises </h2><br><ul><li>  We saw above that these <b>&lt;</b> and <b>&gt;</b> operators were used to determine when the value is greater and when less than another value, but there was no operator that answers the question ‚Äúis it between?‚Äù To determine when the value is between two other values. <br><br>  Let's assume that the programmer wrote the following code to determine when <b>value is</b> between 10 and 20. Notice that the program does not compile as described. <pre> <code class="hljs cs">import std.stdio; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">15</span></span>; writeln(<span class="hljs-string"><span class="hljs-string">"Is between: "</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üê   }</span></span></code> </pre>  Try to bracket this whole expression: <pre> <code class="hljs cs">writeln(<span class="hljs-string"><span class="hljs-string">"Is between: "</span></span>, (<span class="hljs-number"><span class="hljs-number">10</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üê  </span></span></code> </pre>  Note that this program will not compile anyway. </li><li>  While searching for a solution to this problem, the same programmer discovers that the following use of brackets allows you to compile the code: <pre> <code class="hljs cs">writeln(<span class="hljs-string"><span class="hljs-string">"Is between: "</span></span>, (<span class="hljs-number"><span class="hljs-number">10</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üê   ,   </span></span></code> </pre>  Note that the program now works as intended and displays "true".  Unfortunately, this output is confusing, because there is a bug in this program.  You can see the consequences of this bug by replacing 15 with a value greater than 20: <pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">21</span></span>;</code> </pre>  Notice that the program still displays "true", despite the fact that 21 is not less than 20. <b>Hint:</b> Remember that the type of the logical expression is <b>bool</b> .  It should not make sense when the <b>bool is</b> less than 20. </li><li>  Logical expressions that answer the question ‚ÄúIs it between?‚Äù Should, instead, answer the question: ‚ÄúIs it more than the minimum value and less than the maximum?‚Äù. <br><br>  Modify the expression in this program with this logic in mind and notice that it now displays "true", as expected.  You can also test that this logical expression works correctly with other values.  For example, when <b>value</b> is 50 or 1, this program should output ‚Äúfalse‚Äù and when <b>value</b> is 12, this program will display ‚Äútrue‚Äù. </li><li>  Suppose we can go to the beach when one of the following conditions is true: <ul><li>  If the distance to the beach is less than 10 km and there are bicycles for everyone. </li><li>  If we are less than 6, and we have a car, and one of us has a driver's license. </li></ul>  As written, the following program always displays "true."  Construct the logic so that the program will display "true" when one of the conditions above is satisfied.  (When the program asks, enter "true" or "false" for questions that begin with the words "Is there a.").  Remember to connect the <b>read_bool ()</b> method when testing the program: <pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.conv; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.string; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>("How many are we? "); <span class="hljs-type"><span class="hljs-type">int</span></span> personCount; readf(" %s", &amp;personCount); <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>("How many bicycles are there? "); <span class="hljs-type"><span class="hljs-type">int</span></span> bicycleCount; readf(" %s", &amp;bicycleCount); <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>("What is the distance to the beach? "); <span class="hljs-type"><span class="hljs-type">int</span></span> distance; readf(" %s", &amp;distance); <span class="hljs-type"><span class="hljs-type">bool</span></span> existsCar = read_bool("Is there a car? "); <span class="hljs-type"><span class="hljs-type">bool</span></span> existsLicense = read_bool("Is there a driver license? "); <span class="hljs-comment"><span class="hljs-comment">/*   'true'   ,   'true',      : */</span></span> writeln("We are going to the beach: ", <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/*     ,       ,      . */</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> read_bool(string message) { //   <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(message, "(false or true) "); //    . string <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { input = chomp(readln()); } //      <span class="hljs-type"><span class="hljs-type">bool</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>!<span class="hljs-type"><span class="hljs-type">bool</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>); //   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre>  Enter different values ‚Äã‚Äãand test this logical expression that you wrote, it works correctly. </li></ul><div class="spoiler">  <b class="spoiler_title">‚Ä¶ decision</b> <div class="spoiler_text"><ol><li>  Since the compiler takes <b>10 &lt;value</b> already as an expression, it expects a comma after it to accept it as an argument to <b>writeln</b> .  Using parentheses around the whole expression will not work, because at this time the closing bracket will be expected in the same expression. </li><li>  Grouping this expression as <b>(10 &lt;value) &lt;20</b> will remove the compile error, because in this case the first part will be calculated and then its result will be compared with <b>&lt;20</b> <br><br>  We know that the value of a logical expression, such as <b>10 &lt;value</b> , will be <b>false</b> or <b>true</b> .  <b>false</b> and <b>true</b> take the values ‚Äã‚Äã0 and 1, respectively, in integer expressions.  We will look at automatic type conversion in the following chapters.  As a result, the whole expression will be equivalent to either <b>0 &lt;20</b> or <b>1 &lt;20</b> , which both return <b>true</b> . </li><li>  The expression "greater than the minimum value and less than the maximum" can be programmed as follows: <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"Is between: "</span></span>, (<span class="hljs-name"><span class="hljs-name">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> (<span class="hljs-name"><span class="hljs-name">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> </li><li>  ‚ÄúAre there bikes for everyone‚Äù can be programmed as a <b>personCount &lt;= bicycleCount</b> or so <b>bicycleCount&gt; = personCount</b> .  The rest of this logical expression can be immediately transferred to the program code from the exercise: <pre> <code class="hljs lisp">writeln(<span class="hljs-string"><span class="hljs-string">"We are going to the beach: "</span></span>, ((<span class="hljs-name"><span class="hljs-name">distance</span></span> &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> (<span class="hljs-name"><span class="hljs-name">bicycleCount</span></span> &gt;= personCount)) || ((<span class="hljs-name"><span class="hljs-name">personCount</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> existsCar <span class="hljs-symbol"><span class="hljs-symbol">&amp;&amp;</span></span> existsLicense) )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre>  Note the location of this disjunction operator (||) makes reading easier by separating these two basic predicates. </li></ol></div></div></div><p>Source: <a href="https://habr.com/ru/post/244525/">https://habr.com/ru/post/244525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244515/index.html">The company Global Web Index presented a statistical report on the Internet preferences of Europeans in 2014</a></li>
<li><a href="../244517/index.html">Inversion of Control: Implementation Methods with PHP Examples</a></li>
<li><a href="../244519/index.html">How to warm up for a "foreign" account</a></li>
<li><a href="../244521/index.html">Elegant Java Builder</a></li>
<li><a href="../244523/index.html">Subtleties nodejs. Part II: Work with errors</a></li>
<li><a href="../244527/index.html">What will 100Gbps broadband satellite technology mean?</a></li>
<li><a href="../244529/index.html">The introduction of the software product. Features of the business consultant. Part III. Final</a></li>
<li><a href="../244531/index.html">Should Spring Boot be used in your next project?</a></li>
<li><a href="../244535/index.html">World Information Security Day</a></li>
<li><a href="../244537/index.html">Rust: abstraction and security, completely free (video from the Saratov Open-IT session)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>