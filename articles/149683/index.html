<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ avr support in gcc</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The avrgcc compiler supports C ++, but its delivery does not include either the standard library or the ABI implementation: utility functions, the cal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ avr support in gcc</h1><div class="post__text post__text-html js-mediator-article">  The avrgcc compiler supports C ++, but its delivery does not include either the standard library or the ABI implementation: utility functions, the calls of which are inserted by the compiler itself.  As a result, people try to realize the parts that they need, on their own and often do it not very well.  For example, it is often proposed to shoot yourself a leg by defining an empty function __cxa_pure_virtual (void) {} ‚Äã‚Äãor put a rake on yourself by writing caps for __cxa_guard_acquire, __cxa_guard_release and __cxa_guard_abort.  In this article, I propose to figure out what is missing for happiness, where to get it or how to write it. <br>  I know that many people think that C ++ is not needed on the microcontroller.  I ask them to read the last section of the article before writing comments. <a name="habracut"></a><br><br><h1>  Features for arduino owners </h1>  Arduino provides limited support for C ++.  But, as far as I understand, the developers of arduino do not like C ++, therefore, at the request of the workers, the first available crutch was inserted into the appropriate module.  It turned out to be a crutch described on <a href="http://www.avrfreaks.net/index.php%3Fname%3DPNphpBB2%26file%3Dviewtopic%26t%3D59453">avrfreaks</a> , and without the corrections indicated in the comments to the topic.  So first you have to get rid of it.  Delete files <ul><li>  hardware / arduino / cores / arduino / new.h </li><li>  hardware / arduino / cores / arduino / new.cpp </li></ul>  Or use the <a href="https://github.com/kibergus/arduino/blob/master/">version where it is already done</a> . <br><br><h1>  Pure virtual and remote methods </h1>  The mechanism of virtual methods, as a rule, is implemented through vtable.  This is not regulated by the standard, but is used in all compilers.  Even if you declare a method to be purely virtual, that is, not having an implementation, the vtable will still have space for a pointer to this method.  This is necessary in order for the child classes to put a pointer to the corresponding implementation at the same offset.  Instead of a pointer to the missing method, the compiler writes a pointer to the stub function __cxa_pure_virtual in the vtable.  If someone manages to call a purely virtual function, then the control will switch to a stub and it will stop the program, instead of trying to execute a random piece of memory.  Please note that this protection is almost free: the implementation of __cxa_pure_virtual, containing a single call, takes only 6 bytes of flash. <br>  A reasonable question arises, how is it possible to call a purely virtual function if it is impossible to create an object of an abstract class?  You cannot create it, but you can call it if you write strange code: <pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> B { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: B() { //   C   ,   vtable  B //        ,  //        virt(),    non_virtual(); } <span class="hljs-type"><span class="hljs-type">void</span></span> non_virtual() { //       ,     //      ,   //    B virt(); // pure virtual <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> // terminate <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> an active <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> //   (core dumped) } virtual <span class="hljs-type"><span class="hljs-type">void</span></span> virt() = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> C : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> B{ <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: virtual <span class="hljs-type"><span class="hljs-type">void</span></span> virt() {} }; <span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span>** argv) { C c; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre>  To avoid such errors, you should try not to call the methods of the object until it is initialized.  In other words, do not do the hard work in the constructor.  And for the compiler to build your application, add the implementation of the following functions: <pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> __cxa_pure_virtual(<span class="hljs-type"><span class="hljs-type">void</span></span>) { // We might want <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> <span class="hljs-keyword"><span class="hljs-keyword">diagnostics</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> uart <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> std::terminate(); } <span class="hljs-type"><span class="hljs-type">void</span></span> __cxa_deleted_virtual(<span class="hljs-type"><span class="hljs-type">void</span></span>) { // We might want <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> <span class="hljs-keyword"><span class="hljs-keyword">diagnostics</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> uart <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> std::terminate(); }</code> </pre>  You will also need the std :: terminate implementation from the standard library.  If you really need to save 2 bytes of RAM and 14 bytes of flash, you can also call abort () directly, but later I will explain why std :: terminate is preferable. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Static variables </h1>  You can declare a variable inside a function as static, which in fact makes it a global variable visible only inside the function. <pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = start; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++cnt; }</code> </pre>  In C, this code will not be collected, since a static variable must be initialized with a constant in order to immediately place the initial value in the .data section.  In C ++, this was allowed, but it was not specified what would happen if two threads tried to initialize the variable at the same time.  Many compilers have chosen to add locks and ensure thread safety in this case, and in C ++ 11 this behavior has become part of the standard.  Therefore, initialization is not a constant value of the static variable gcc will expand to the following code: gcc / cp / decl.c <pre> <code class="hljs pgsql">static &lt;<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>&gt; guard; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!guard.first_byte) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__cxa_guard_acquire (&amp;guard)) { <span class="hljs-type"><span class="hljs-type">bool</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; try { // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> initialization. flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; __cxa_guard_release (&amp;guard); // Register variable <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> destruction at <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> program. } catch { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!flag) __cxa_guard_abort (&amp;guard); } } }</code> </pre>  where guard is an integer type of sufficient size to store the flag and mutex.  Viewing the gcc source showed that its optimization only bothered on the ARM architecture: <br>  gcc / config / arm / arm.c <pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/* The generic C++ ABI says 64-bit (long long). The EABI says 32-bit. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> tree </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arm_cxx_guard_type</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TARGET_AAPCS_BASED ? integer_type_node : long_long_integer_type_node; }</code> </pre>  In all other cases, the default type is used: long_long_integer_type_node.  On avr, depending on the -mint8 option, it will be either 64 or 32 bits.  16. guard.first_byte, in which the flag is placed, is understood by the compiler as the byte with the lowest address: * (reinterpret_cast &lt;char *&gt; (g)).  An exception is the ARM platform, where only one bit of the first byte is used. <br><br><h3>  How correct? </h3>  If you do not need thread-safe static variables, disable them with the -fno-threadsafe-statics option and the compiler, instead of complex locks, will provide a simple flag check.  Implement __cxa_guard_ * in this case is not necessary.  But if you provide them (as is done in arduino), then the implementation <b>should</b> ensure correct operation in the case of simultaneous initialization of a variable from regular code and from an interrupt.  In other words, __cxa_guard_acquire should block interrupts, and __cxa_guard_release and __cxa_guard_abort should return them to their previous state.  In the case of using RTOS, I may be willing to sacrifice correctness in interrupts, leaving correctness for the two threads. The correct implementation should work like this: <pre> <code class="hljs pgsql">namespace { // guard <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> an <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> big enough <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> hold flag <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a mutex. // <span class="hljs-keyword"><span class="hljs-keyword">By</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> gcc uses long long <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> avr ABI does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> change it // So we have <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> bits available. Actually, we need <span class="hljs-number"><span class="hljs-number">16.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-type"><span class="hljs-type">char</span></span>&amp; flag_part(__guard *g) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(reinterpret_cast&lt;<span class="hljs-type"><span class="hljs-type">char</span></span>*&gt;(g)); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> uint8_t&amp; sreg_part(__guard *g) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(reinterpret_cast&lt;uint8_t*&gt;(g) + sizeof(<span class="hljs-type"><span class="hljs-type">char</span></span>)); } } <span class="hljs-type"><span class="hljs-type">int</span></span> __cxa_guard_acquire(__guard *g) { uint8_t oldSREG = SREG; cli(); // Initialization <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> static variable has <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be done <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> blocked interrupts // because <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> interrupt <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sees that somebody // <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> already doing initialization it MUST wait <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> initializations // <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> complete. That<span class="hljs-string"><span class="hljs-string">'s impossible. // If you don'</span></span>t want this overhead compile <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> -fno-threadsafe-statics <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag_part(g)) { SREG = oldSREG; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sreg_part(g) = oldSREG; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-type"><span class="hljs-type">void</span></span> __cxa_guard_release (__guard *g) { flag_part(g) = <span class="hljs-number"><span class="hljs-number">1</span></span>; SREG = sreg_part(g); } <span class="hljs-type"><span class="hljs-type">void</span></span> __cxa_guard_abort (__guard *g) { SREG = sreg_part(g); }</code> </pre><br><br><h3>  How much is </h3>  If you do not use static variables or assign constant values ‚Äã‚Äãto them, it's free.  If you specify the -fno-threadsafe-statics flag, then pay 8 bytes of RAM for the flag, and 12 bytes of flash for each variable.  If you are using thread-safe initialization, spend another 38 bytes of flash on each variable and another 44 on the entire program.  In addition, interrupts will be blocked during the initialization of static variables.  But you do not do difficult work in designers? <br>  The choice is yours, but in any case, if the library provides the __cxa_guard_ * functions, they should be implemented correctly, and not be the gag that is offered everywhere.  In general, I would recommend trying not to use static variables. <br><br><h3>  Where to get </h3>  <a href="">abi.h</a> and <a href="">abi.cpp</a> <br><br><h1>  operator new and operator delete </h1>  When it comes to the operators new and delete, someone will surely say that there is very little memory in microcontrollers, so dynamic memory is an unaffordable luxury.  These people do not know that new and delete are not only dynamic memory management.  There is also placement new, which has the object in the buffer allocated by the programmer.  Without it, you cannot write a ring buffer, which is loved by the firmware developers, through which message queues are implemented.  Well, if you are so sure that dynamic memory is not needed, then why did you write implementations for malloc and free?  So there are tasks where it was impossible to manage without them. <br><br><h3>  Types of operators new and delete </h3>  First, there is an operator new allocating memory for single objects and there is an operator new [] allocating memory for arrays.  Technically, they are distinguished by the fact that new [] remembers the size of the array in order to cause a destructor for each element during deletion.  Therefore, it is important to use the paired operator delete or operator delete [] when freeing memory. <br>  Second, each of these statements, like any function in C ++, can be overloaded.  And the standard defines three options: <ol><li><pre> <code class="hljs lisp">void* operator new(<span class="hljs-name"><span class="hljs-name">std</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:size_t</span></span> numBytes) throw(<span class="hljs-name"><span class="hljs-name">std</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:bad_alloc</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre>  will allocate a block of memory of size numBytes.  In case of an error, throws an exception std :: bad_alloc </li><li><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numBytes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nothrow_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre>  will allocate a block of memory of size numBytes.  If an error occurs, returns nullptr </li><li><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }</code> </pre>  placement new, locates the object where they said.  Used when selling containers </li></ol>  In arduino, for unknown reasons, only void * operator new (std :: size_t numBytes) throw is implemented (std :: bad_alloc), and in the event of an error it returns 0, which leads to unspecified behavior of the program, since nobody checks the returned value . <br>  With operator delete, everything is a little trickier.  There are void * operator delete (std :: size_t numBytes) and void * operator delete [] (std :: size_t numBytes).  You can overload it for other parameters, but you can not cause these overloads, because the language does not have the appropriate syntax.  There is only one case where the compiler will cause an overloaded version of the delete statement.  Imagine that you are creating an object in dynamic memory, the new operator successfully allocated memory, the constructor began to fill it, and threw an exception.  Your code has not yet received a pointer to an object, so that it cannot return the memory of the failed object to the system.  Therefore, the compiler is forced to do this by calling delete.  But what happens if the memory was ‚Äúallocated‚Äù using placement new?  In this case, you cannot call normal delete, therefore, if the constructor threw an exception, the compiler will call the overloaded version of delete with the same parameters that new was called with.  So the standard library defines three versions of operator delete and three versions of operator delete []. <br><br><h3>  Processing bad_alloc </h3>  As mentioned above, the most frequently used version of new is required to throw an exception in case of an error.  But gcc does not support exceptions to avr: they can neither be thrown nor caught.  But if they cannot be caught, then there is not a single try section in the program, which means that if an exception were thrown, then std :: terminate would be called.  Moreover, the C ++ standard allows in this case (see 15.5.1) not unwinding the stack.  Therefore, new can call std :: terminate directly and it will conform to the standard. <br>  Do not be alarmed that the standard library will take and complete the firmware!  How often can you fix something if bad_alloc occurs?  As a rule, nothing.  Your firmware can not continue to work correctly and thank God that it will end at the time of the error.  But if you know how to fix the situation, you can use the nothrow version of the new operator.  Look at this as a safe malloc, which correctly behaves if you do not check the return value. <br><br><h3>  Where to get </h3>  In uClibc ++ there is a complete and correct implementation of new and delete.  True, instead of std :: terminate, abort () is called there.  Therefore, I made a <a href="https://github.com/kibergus/StandardCplusplus">corrected</a> version.  At the same time, there are added initialization lists, std :: move and std :: forvard. <br><br><h1>  std :: terminate vs abort () </h1>  According to the avr-libc <a href="http://www.nongnu.org/avr-libc/user-manual/group__avr__stdlib.html">documentation</a> , the abort () function blocks all interrupts, and then falls into an infinite loop.  This is not what I would like.  For two reasons.  First, it leaves the device in a <b>dangerous condition</b> .  Imagine that the system controls the heating element and the program loops when it is turned on.  In case of an error, I want to go to a safe state by setting all the outputs of the board to 0. Secondly, I already know that everything is bad and I don‚Äôt have to wait until the watchdog is triggered and the system is rebooted.  This can be done immediately. <br>  If the firmware is terminated by std :: terminate, I can install my own handler and perform all the necessary actions there.  I cannot redefine abort: the mechanism provided for this in unix does not work on avr.  Therefore, I would rather spend those 2 bytes of RAM and 14 bytes of flash, which is occupied by the implementation of std :: terminate. <br><br><h1>  Exceptions </h1>  Exceptions are that part of C ++ that you have to pay a lot for, not only in the code that uses them directly, but also in the code through which the exception can fly: the compiler is forced to register the destructor of each variable created on the stack.  In addition, for exceptions, RTTI and a small backup memory buffer are needed, so that you have where to create std :: bad_alloc when memory runs out.  In addition, this is the only part of C ++ for which it is problematic, although not impossible, to calculate the execution time.  As far as I understand, anyone who understood enough to write the functions for supporting exceptions that were missing on the AVR lost the desire to do so.  There are many more important things to do too.  Therefore, there is no support for exceptions on AVR in gcc and, quite likely, there will not be. <br><br><h1>  STL </h1>  I have seen many reports that STL on a microcontroller is bad: it inflates the code and, by making complex things simple, incites to use them.  At the same time, it is silent that in STL there are such primitives as <a href="http://www.cplusplus.com/reference/algorithm/sort/">quick sorting</a> , which is much faster and more compact qsort, or <a href="http://www.cplusplus.com/reference/algorithm/binary_search/">binary search</a> , safe versions of min and max.  Do you really know the sacred way to write classical algorithms more effectively than other programmers?  And then why not use a ready-tested algorithm that takes as much space as what you have to write.  For those parts of STL that you do not use, you do not pay. <br><br><h3>  Where to get </h3>  Use <a href="https://github.com/kibergus/StandardCplusplus">uClibc ++</a> .  This library has one feature: std :: map and std :: set are implemented on top of the vector, so iterators are disabled when inserting and deleting.  In addition, they have a different complexity.  In the documentation, the author describes in detail why he did so. <br><br><h1>  What is C ++ for? </h1>  This is a topic for a separate article that I am ready to write if you are interested.  In short, with <b>proper</b> use, C ++ allows you to write solutions that are as effective as C solutions, but at the same time get more readable and more secure code through compiler checks.  And the template mechanism allows you to write efficient implementations of generalized algorithms, which is problematic in C. I also got used to it.  In any case, I highly ask you to refrain from discussing this topic now. </div><p>Source: <a href="https://habr.com/ru/post/149683/">https://habr.com/ru/post/149683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149675/index.html">The Japanese have developed a new method for three-dimensional scanning of objects.</a></li>
<li><a href="../149676/index.html">The Debian community has turned 19</a></li>
<li><a href="../149679/index.html">British authorities are threatening to storm the embassy of Ecuador</a></li>
<li><a href="../149680/index.html">Subscription Managers and Android News Aggregators</a></li>
<li><a href="../149682/index.html">Announcement of the IDCEE 2012 conference</a></li>
<li><a href="../149684/index.html">Review of Content Designers (Content Construction Kit) for CMS Joomla</a></li>
<li><a href="../149685/index.html">Black color - taboo, myth or necessity?</a></li>
<li><a href="../149686/index.html">Forth processor on VHDL</a></li>
<li><a href="../149687/index.html">Create a Qt interface style using a table as an example.</a></li>
<li><a href="../149691/index.html">Pleasant trifle in the "Express Office" - comfortable keyboard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>