<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ML Boot Camp V, solution history for 3rd place</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In mid-July, the ML.Bot Camp V machine-test contest from Mail.Ru ended. It was necessary to predict the presence of cardiovascular diseases according ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ML Boot Camp V, solution history for 3rd place</h1><div class="post__text post__text-html js-mediator-article">  In mid-July, the ML.Bot Camp V machine-test contest from Mail.Ru ended.  It was necessary to predict the presence of cardiovascular diseases according to the results of a classical medical examination.  The metric was the logarithmic loss function.  A complete description of the task is available <a href="http://mlbootcamp.ru/round/12/sandbox/">here</a> . <br><br>  Familiarity with machine learning for me began with ML Boot Camp III sometime in February 2017 and some sort of idea of ‚Äã‚Äãwhat to do with such tasks begins to take shape for me just now.  Much of what was done in contest 5 is primarily the result of studying the collection of articles on kaggle and the discussions and code examples from there.  Below is a slightly revised report on what had to be done to take 3rd place. <br><a name="habracut"></a><br><h3>  Task data </h3><br>  Dataset is formed from 100,000 real clinical tests.  Given the age, height, weight, sex, upper and lower blood pressure, cholesterol and glucose in the blood. <br><br>  In addition, there are ‚Äúsubjective‚Äù data - that patients reported about themselves when answering questions about smoking, alcohol consumption and physical activity.  This part of the data was also spoiled by the organizers, so I had no special hopes with them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The initial data contained obviously unrealistic values ‚Äã‚Äã- there were people with a height of 50 cm in 30+ years, with a pressure like 16020, with negative pressures.  This was due to errors when manually entering the data analysis. <br><br><h3>  Instruments </h3><br>  The problem was solved in python using standard for this case libraries: <br><br><ul><li>  <a href="http://pandas.pydata.org/">pandas</a> - read-write and processing of tabular data (in fact, a lot of things more, but in this case, the rest is not needed); </li><li>  <a href="http://www.numpy.org/">NumPy</a> - operations on arrays of numbers; </li><li>  <a href="http://scikit-learn.org/stable/">scikit-learn</a> - a set of tools for machine learning, including basic MO algorithms, data partitioning, validation; </li><li>  <a href="https://github.com/dmlc/xgboost">XGBoost</a> is one of the most popular implementations of gradient boosting; </li><li>  <a href="https://github.com/Microsoft/LightGBM">LightGBM</a> is an alternative to XGBoost; </li><li>  <a href="https://www.tensorflow.org/">TensorFlow</a> + <a href="https://keras.io/">Keras</a> - a library for learning and using neural networks and a wrapper for it; </li><li>  <a href="https://hyperopt.github.io/hyperopt/">Hyperopt</a> - a library for optimizing functions in a given argument space; </li></ul><br><h4>  Csv vs pickle </h4><br>  For data storage with long calculations, I first used csv until I needed to save together more complex structures than separate tables.  The pickle module proved to be very good - all the necessary data is saved or read in 2 lines of code.  Later it became save in compressed files: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> gzip.open(<span class="hljs-string"><span class="hljs-string">'../run/local/pred_1.pickle.gz'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: pickle.dump((x, y), f)</code> </pre> <br><h4>  Repository </h4><br>  All the code related to the competition lies on <a href="https://github.com/ivan-filonov/mlbootcamp_5">github</a> .  In the repository in the old / hidden old scripts, the real benefits of which was not, and left only because the results of their work were also sent to the test.  Due to errors in the code, the intermediate results of their execution were later unsuitable for use, so this part of the code had no effect on the final decisions. <br><br><h3>  First 2 weeks </h3><br>  For the first 2 weeks I cleaned the data, substituted it into the models left over from past competitions, and all this without much success.  For each new submission, all the code from one of the existing scripts was copied entirely into a new one and was already edited there.  The result - at the end of the second week, he couldn‚Äôt say right away what any of the latest scripts does and what functions it actually uses and which simply occupy space.  The code was cumbersome, hard to read, and could work for several hours and fall without saving anything useful at all. <br><br><h3>  Second 2 weeks </h3><br>  When 2 weeks after starting to copy the old scripts and it became too difficult to change them a bit, I had to start a complete rework of the entire code.  It was divided into common parts - base classes and their specific implementations. <br><br>  The general idea of ‚Äã‚Äãthe new code organization is the pipeline: data ‚Üí signs ‚Üí level 1 models ‚Üí level 2 models.  Each stage implements a separate script file, which, when launched, performs all the required calculations, saves them, intermediate results and its own data.  The script for each next stage imports the code of the previous stages and receives data for processing from their methods.  The idea behind all this is that in order to be able to run a script for one of the final models, he launched the scripts for the models at a lower level, they called the sign generators they needed, which in turn launched the desired data cleansing option.  The task of each script is to check if the file exists, where it should save its results, and if not, perform the necessary calculations and save the data. <br><br>  Behind all this was a plan to make a decision for organizing models and data for future use, simultaneously debugging it on a suitable task.  Actually this decision was the most important result of the contest, which is now gradually developing into a small library to make life easier when participating in subsequent competitions of this kind. <br><br><h3>  Overall plan </h3><br>  Initially, 2 levels of models were planned and it was necessary to prepare as many different models as possible to the 1st level.  The way to achieve this is to prepare as much as possible differently processed data, on which similar models will be trained.  But to prepare the data is a long matter.  Although working with data is the key to success (a sufficient number of added meaningful features makes it possible to get by with the simplest models), but it takes more time than we would like.  The alternative is a brute force solution, that is, relatively moderate data processing and maximum computing time. <br><br>  The simplest with this approach is to process the data in several ways, come up with several sets of additional features and use their combinations.  The result is a <a href="https://en.wikipedia.org/wiki/Random_subspace_method">random</a> version of the <a href="https://en.wikipedia.org/wiki/Random_subspace_method">Random subspace method</a> , which differs from the full version in that it is not at all random and the signs are selected immediately in groups.  So with a small number of additional features, you can get hundreds of variants of the processed data (the actual number of cleaning methods * (2 ^ number of groups of features)).  It was assumed that such an approach would give rather different solutions to simple models using different subsets of features, so that each of them would improve the quality of level 2 models. <br><br><h3>  Data preparation </h3><br>  The fact that the original data was dirty had to somehow be taken into account.  The main approaches are either to throw out all obviously impossible values ‚Äã‚Äãor try to somehow restore the original data.  Since the source of such distortions remained unknown almost to the end - we had to prepare the data in several ways, and then train different models on them. <br><br>  Each of the data processing options is implemented by a class that, when returned, returns a full dataset with corresponding changes.  Since data processing at this stage is rather fast - intermediate results were saved only for a relatively long option (2) - recovery of subjective signs using xgboost.  The rest of the data was generated on request. <br><br>  Processing options: <br><br><ol><li>  The initial data in which the spoiled values ‚Äã‚Äãof the subjective part of the test are replaced by 0.0001, to bring them to a numerical form, but to distinguish them from the intact ones. </li><li>  The spoiled subjective signs were replaced: alcohol consumption ‚Äî 0, activity ‚Äî 1. Then, for the remaining data columns, smoking was ‚Äúrestored‚Äù. </li><li>  In data with reconstructed subjective signs, extreme pressure values ‚Äã‚Äãhave been cleaned. </li><li>  In the data with the restored subjective signs (from item 2), the extreme values ‚Äã‚Äãof pressure, weight and height were cleaned. </li><li>  In the data with only purified pressures (from item 3), the weight, height, and pressure are additionally cleaned. </li><li>  Data with refined pressures is additionally converted ‚Äî any individual implausible height, weight, or pressure value is replaced with NaN. </li></ol><br><h3>  Signs of </h3><br>  Additional features were generated from the processed data.  There were very few meaningful ones - body mass index, expected pressure values ‚Äã‚Äãdepending on gender, weight and age using some old formula, etc.  Much more additional data columns were automatically obtained using rather simple methods. <br><br>  Additional attributes were generated from different variants of the processed data, but often in the same way.  Since some of the signs could require too much time to recalculate their values ‚Äã‚Äã- the columns of signs were kept separately.  The calculation of attributes in scripts was implemented in the same way as data cleansing - in each script, a method was defined that returns additional columns of attributes. <br><br>  Groups of additional features: <br><br><ol><li>  The simplest meaningful signs - <abbr title="Body mass index">BMI</abbr> , pulse pressure, averaged pressure values <math> </math> $ inline $ \ frac {ap \ _hi + x * ap \ _lo} {x + 1} $ inline $   for different x values.  Approximate formulas for calculating pressures by age / weight were also taken and the expected pressures were calculated for each patient (formulas <math> </math> $ inline $ ap \ _X = a + b * age + c * weight $ inline $   ).  Calculated from raw values. <br><br></li><li>  Same as in claim 1, but additionally, based on the available pressures, an attempt was made to restore the patient's weight.  For each of the features predicted in this way, a difference with a ‚Äúreal‚Äù value is added.  Calculated from raw value. </li><li>  The textual representation of the raw data columns, broken character by character - first with alignment to the left, then to the right.  Characters are replaced by their numeric values ‚Äã‚Äã( <a href="https://docs.python.org/3/library/functions.html">ord ()</a> ).  Where the line was too short and not enough for all columns - -1 was set. <br><br></li><li>  Same as in p.3, but the received columns are binary coded (one-hot encoding). <br><br></li><li>  The data from clause 4, but missed through the PCA is a heavy legacy of the recent mercedes competition on kaggle, where models with this shamanism looked pretty good in public and sadly in private. <br><br></li><li>  For all columns of raw raw data except age, the average values ‚Äã‚Äãof the target column are calculated.  To do this, first the values ‚Äã‚Äãof pressure, height and weight are divided by 10 and rounded, having obtained from them in this way categorical signs.  Then I divided the data into 10 folds, and for each of them, 9 other folds calculated for each category a weighted average value of the target column (sick-not ill).  Where there was nothing to calculate the average, I simply put down the global average. <br><br></li><li>  Same as in p.6, but the averages were calculated also for the signs from p.2. <br><br></li><li>  Same as in clause 7, but cleared for option # 5 are taken as the source data. <br><br></li><li>  Same as in clause 7, but cleared for option # 3 are taken as the source data. <br><br></li><li>  The raw data is clustered by the k-means method, the number of clusters is chosen arbitrarily - 2, 5, 10, 15, 25. The cluster number for each of these cases is binary coded. <br><br></li><li>  The same as in paragraph 10, but used data cleared for option # 3. </li></ol><br><h3>  Models </h3><br>  Since models can work for a very long time (tens of hours), fall with errors, or be interrupted specially - it is necessary to save not only the final results, but also intermediate data.  For this, each model is given a base name.  Further, from the model name and the name assigned to the data, the name of the file is obtained, where this data will lie.  All saving-loading go through the basic methods of the model, which ensures uniform storage of intermediate data.  Future plans are to keep data not in files, but in some database.  Lack of implementation - you can forget to update the name when copying the model and get an undefined state for the data of the original model and its copy. <br><br>  If the model has saved the results of its calculations, it only remains to access them and return them to the caller.  If there are only intermediate results - they also do not have to be re-counted.  This saves a lot of time, especially when it comes to computing for a few hours. <br><br>  The main separation of the data stored by the models is by the lifetime of the data.  Each such data group has its own base path for storage.  There are 3 such groups: <br><br><ol><li>  Temporary ones that will not be used during the following launches, for example, the best weights of neural networks for individual folds; </li><li>  These models, which will be needed in the next launches - almost everything else; </li><li>  Globally useful data that may be useful to several models, for example, additional features; </li></ol><br>  The interface for all models is common and allows not only to run them separately as regular scripts, but also to load as python modules.  If some model needs the results of the work of other models, it loads and implements them.  As a result, the description of each of the Level 2 models was reduced to the list of model names, whose results should be combined, and the indication of the need to select features by a greedy algorithm. <br><br>  Among the models were based on neural networks, which at the output could give very confident 0 or 1 or very close to extreme values.  Since, in the event of an error, such overconfidence is penalized by logloss very much - the values ‚Äã‚Äãof all models, while being preserved, were cut off so that at least 1e-5 remained to 0 or 1.  The easiest way was to add np.clip (z, 1e-5, 1-1e-5) and forget about it.  As a result, the data of all models were cut off, but most of them gave results in the range of about 0.1-0.93. <br><br><h4>  hyperopt </h4><br>  To fit the parameters of the models, <a href="https://github.com/hyperopt/hyperopt">hyperopt</a> had to be used ( <a href="https://papers.nips.cc/paper/4443-algorithms-for-hyper-parameter-optimization.pdf">details</a> ).  The results improved, but at the same time I set the number of attempts on the order of 20 for particularly slow models. And 2 days before the end of the <a href="https://johnflux.com/2017/02/10/python-hyperopt-finding-the-optimal-hyper-parameters/">article I</a> found mentioning hyperopt bootstrapping - by default, the first 20 model launches are made with random parameters, which can be seen in the <a href="https://github.com/hyperopt/hyperopt/blob/master/hyperopt/tpe.py">source</a> .  I had to urgently recount some of the models. <br><br><h4>  Level 1 models </h4><br>  A selection of input data for each model was included in the general code of level 1 models - one option is necessarily to clear the source data and 0 or more groups of features.  The collection of data and attributes into a common dataset is implemented in general for model code.  This reduced the code of individual models to specify specific source data and additional features. <br><br>  There was not enough time to make the general code for optimization, so that the individual basic models of level 1 still copy each other greatly.  In total, they turned out 2 varieties: <br><br><ul><li>  neural networks (keras) </li><li>  trees (XGBoost, LightGBM, rf, et) </li></ul><br>  The main difference between the neural network models used is the lack of hyperparameter fitting.  For the rest of the models, hyperopt was used. <br><br><h4>  Neural networks </h4><br>  I didn‚Äôt do any serious selection of parameters for neural networks, so their results were worse than boosting.  Later in the chat, I saw a mention of a network device like 64-64 with the activation of <a href="http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf">leaky relu</a> and a <a href="https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf">dropout of</a> 1-5 neurons in each layer, which gave a relatively decent result. <br><br>  I used neural networks like the following: <br><br><ul><li>  entrance; </li><li>  several hundred neurons (usually 256); </li><li>  some non-linearity, drop-out (where it was, it took values ‚Äã‚Äãof the order of 0.7, because it believed that there were too many parameters and the network was being retrained);  if, when training, the model diverged into nan-s - added batch normalization - details <a href="http://proceedings.mlr.press/v37/ioffe15.html">here</a> or <a href="https://arxiv.org/pdf/1502.03167.pdf">here</a> ; </li><li>  a hundred or two neurons (64-128); </li><li>  nonlinearity; </li><li>  a dozen or two neurons (16); </li><li>  nonlinearity; </li><li>  1 output neuron with classic sigmoid output. </li></ul><br>  Such a device migrated from previous competitions almost unchanged.  Separately, the neural networks did not show themselves, but were left to use their results in the calculation of level 2 models. <br><br>  The choice of activation functions for the inner layers is very simple - excluded from the available set all sigmoid variants (due to close to 0 gradients at the boundaries of values), ‚Äúpure‚Äù ReLU (due to the fact that the neuron that started issuing 0 at the output, from training falls out) and took something from the rest.  Initially it was <a href="https://arxiv.org/abs/1505.00853">Parametric Relu</a> , in the latest models began to take <a href="https://arxiv.org/abs/1706.02515">Scaled Exponential Linear Units</a> .  No significant differences from such a replacement could not be noticed. <br><br>  As for other models, the data for neural networks beat on folds using <a href="http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html">KFold</a> from sklearn.  For learning, at each partition it was necessary to build a model again, since I learned too late how to re-initialize the weights in the layers of the network without re-creating it. <br><br>  The networks were trained as long as the quality of the predictions on the data allocated for validation improved.  At the same time, weights for the network were maintained each time the result on validation improved.  For this, the standard callbacks and keras are for maintaining the state of the network with the best results for validation, for early termination of training if the results did not improve for a given number of passes in the training set and for reducing the learning rate if the results did not improve for several passes. <br><br>  It turned out that if the network training came to a standstill (local minimum) and the results did not improve in several passes according to the data, the learning rate decreased and if it did not help, after a few more moves the training stopped.  After training, the best state of the weights of the network was loaded for the entire duration of the training. <br><br>  At the same time, I quite late noticed the problem that arises when I try to use the same set of callback instances several times when teaching several networks.  In this case, the state of callbacks when starting learning a new network is not automatically reset to the initial one.  As a result, the learning rate for each new network declined more and more, and the best results were not maintained if they were not better than all previously obtained on all networks where the same callbacks were used. <br><br><h4>  Tree based models </h4><br>  Two variants of ‚Äútree‚Äù models were used - based on bagging <a href="http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html">random forest</a> and <a href="http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.ExtraTreesRegressor.html">extra trees</a> and 2 implementations of gradient boosting - XGBoost and LightGBM.  Both variants of the random forest showed themselves to be both on cross-validation and on public, so they remained simply because they had to spend a lot of machine time and there was hope that they would be useful when combining the results of the models.  LightGBM and XGBoost performed much better and most of the predictions on the first level were received from them. <br><br>  Each of the "tree" models after fitting the parameters was calculated for several (usually - 3) initial states of the random number generator.  All such results were stored separately for use by Level 2 models.  The predictions of the level 1 models were obtained from the result for the last used state of the RNG. <br><br>  LightGBM and XGBoost provide the ability to stop learning if the learning quality does not improve on validation for a given number of iterations.  Due to this, it was possible to simply allow them to learn 10,000 steps and stop when the results on validation stop improving.  As a result, when selecting the parameters of such models, the number of trees was not needed.  For random forest and extra trees from sklearn there is no such possibility, so I had to postpone the selection of the number of trees on the hyperopt, which, it seems, for an insufficient number of attempts, did not fully cope with the task.  It was possible to train them one at a time, each time checking the quality for validation itself, but laziness prevented it. <br><br><h4>  Few seeders </h4><br>  The result of the work of individual models strongly depends on the state of the random number generator.  To get rid of this dependence for the models of level 1, the results of training with several sids were calculated.  At the same time for each Sid, the results were stored separately.  In this case, after the end of the competition, it turned out that as a result, saved by a separate model of level 1, the result was used for the last of the seed.  The results for the rest were still saved and used by Level 2 models. <br><br><h4>  Level 2 Models </h4><br>  Due to the fact that each of the models of level 1 gave from 1 to 4 predictions, at level 2 the data contained up to 190 columns.  Baseline data and signs did not get there - only the predicted probabilities.    2       1  (      2 ). <br><br>   2     ‚Äî     ,    ,              . <br><br>    ‚Äî          2 .        ,        . <br><br>    ,      ,  ¬´¬ª  ‚Äî      ,               .         2   .            <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.BayesianRidge.html">BayesianRidge</a> ,     <a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html">Ridge</a>    .        20   . <br><br>        hyperopt   ,  -     BayesianRidge  Ridge  sklearn,             BayesianRidge        Ridge. <br><br><h4>  Validation </h4><br>      10 .       cv  0.534-0.535      0.543-0.544,    .    ,              30 .   30     ‚Äî           10 . <br><br>          0.535-0.536,        0.543        .   3       30    30    0.7  0.3   .   30 ‚Äî       cv ‚Äî  .      random_state.         0.537. <br><br>      ,      ,         ,      .    2     0.543    0.538  .   ,  12   7  3 ,      . </div><p>Source: <a href="https://habr.com/ru/post/335188/">https://habr.com/ru/post/335188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335176/index.html">Use PowerShell for IT security. Part I: Event Tracking</a></li>
<li><a href="../335178/index.html">Asynchronous decoder</a></li>
<li><a href="../335180/index.html">How the push notification service helped us make the technical support portal more visited</a></li>
<li><a href="../335184/index.html">Free network security audit with Fortinet. Part 1</a></li>
<li><a href="../335186/index.html">Sites online stores and industrial companies are most vulnerable to hacker attacks</a></li>
<li><a href="../335192/index.html">What are the bad nested classes and how to learn rails magic</a></li>
<li><a href="../335194/index.html">Why do you need SBC on the border</a></li>
<li><a href="../335196/index.html">Cryptocurrency Dash invites ... to crack your blockchain</a></li>
<li><a href="../335200/index.html">What is always worth remembering when localizing a website, so that later was not ashamed</a></li>
<li><a href="../335204/index.html">Centralized log storage for Squid Proxy or how we wrapped the logs in the database</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>