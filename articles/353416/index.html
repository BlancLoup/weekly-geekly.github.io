<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>NumPy in Python. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's Preface 
 Continuing to translate the numpy article in python. For those who have not read the first part, here: Part 1 . And all the res...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>NumPy in Python. Part 2</h1><div class="post__text post__text-html js-mediator-article"><h1>  Translator's Preface </h1><br>  Continuing to translate the numpy article in python.  For those who have not read the first part, here: <a href="https://habrahabr.ru/post/352678/">Part 1</a> .  And all the rest - enjoy reading. <br><br><ul><li>  <a href="https://habr.com/post/413381/">Part 3</a> </li><li>  <a href="https://habr.com/post/415373/">Part 4</a> </li><li>  <a href="https://engineering.ucsb.edu/~shell/che210d/numpy.pdf">Original</a> </li></ul><br><br><h1>  Other ways to create arrays </h1><br>  The arange function is similar to the range function, but returns an array: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>np.arange(<span class="hljs-number"><span class="hljs-number">5</span></span>, dtype=float) array([ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>]) &gt;&gt;&gt; np.arange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, dtype=int) array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>])</code> </pre> <br>  The zeros and ones functions create new arrays with a set dimension filled with these values.  These are probably the easiest-to-use functions for creating arrays: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>np.ones((<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), dtype=float) array([[ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>]]) &gt;&gt;&gt; np.zeros(<span class="hljs-number"><span class="hljs-number">7</span></span>, dtype=int) array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre> <a name="habracut"></a><br>  The zeros_like and ones_like functions can convert an already created array by filling it with zeros and ones, respectively: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]], float) &gt;&gt;&gt; np.zeros_like(a) array([[ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>]]) &gt;&gt;&gt; np.ones_like(a) array([[ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>]])</code> </pre> <br>  There are also a number of functions for creating special matrices.  To create a square matrix with a main diagonal, which is filled with units, we use the identity method: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>np.identity(<span class="hljs-number"><span class="hljs-number">4</span></span>, dtype=float) array([[ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>]])</code> </pre> <br>  The eye function returns a matrix with the ones on the diagonal kth line: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>np.eye(<span class="hljs-number"><span class="hljs-number">4</span></span>, k=<span class="hljs-number"><span class="hljs-number">1</span></span>, dtype=float) array([[ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>]])</code> </pre> <br><h1>  Mathematical operations on arrays </h1><br>  When we use standard mathematical operations for arrays, the principle should be observed: element - element.  This means that arrays must be the same size during addition, subtraction, and similar operations: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>], float) &gt;&gt;&gt; a + b array([<span class="hljs-number"><span class="hljs-number">6.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">9.</span></span>]) &gt;&gt;&gt; a ‚Äì b array([<span class="hljs-number"><span class="hljs-number">-4.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">-3.</span></span>]) &gt;&gt;&gt; a * b array([<span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">18.</span></span>]) &gt;&gt;&gt; b / a array([<span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>]) &gt;&gt;&gt; a % b array([<span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]) &gt;&gt;&gt; b**a array([<span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">216.</span></span>])</code> </pre> <br>  For two-dimensional arrays, the multiplication remains element-wise and does not correspond to the multiplication of matrices.  For this there are special features that we will explore later. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>]], float) &gt;&gt;&gt; b = np.array([[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]], float) &gt;&gt;&gt; a * b array([[<span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>], [<span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">12.</span></span>]])</code> </pre> <br>  If there is a discrepancy in the size, errors are thrown out: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>], float) &gt;&gt;&gt; a + b Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; ValueError: operands could <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> be broadcast together <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> shapes (<span class="hljs-number"><span class="hljs-number">3</span></span>,) (<span class="hljs-number"><span class="hljs-number">2</span></span>,)</code> </pre> <br>  However, if the dimension of the arrays does not match, they will be converted to perform mathematical operations.  This often means that a smaller array will be used several times to complete operations.  Consider this example: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], float) &gt;&gt;&gt; a array([[ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>], [ <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>], [ <span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">6.</span></span>]]) &gt;&gt;&gt; b array([<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]) &gt;&gt;&gt; a + b array([[ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">5.</span></span>], [ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">7.</span></span>], [ <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">9.</span></span>]])</code> </pre> <br>  Here, the one-dimensional array b was converted to two-dimensional, which corresponds to the size of the array a.  Essentially, b was repeated several times, for each "string" a.  Otherwise, it can be represented as: <br><br><pre> <code class="python hljs">array([[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>], [<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>], [<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]])</code> </pre> <br>  Python automatically converts arrays in this case.  Sometimes, however, when a transformation plays a role, we can use the newaxis constant to change the transformation: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.zeros((<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>], float) &gt;&gt;&gt; a array([[ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>], [<span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>]]) &gt;&gt;&gt; b array([<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]) &gt;&gt;&gt; a + b array([[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>], [<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]]) &gt;&gt;&gt; a + b[np.newaxis,:] array([[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>], [<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]]) &gt;&gt;&gt; a + b[:,np.newaxis] array([[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">-1.</span></span>], [ <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]])</code> </pre> <br>  In addition to the standard operators, numpy includes a library of standard mathematical functions that can be applied elementwise to arrays.  The functions themselves are abs, sign, sqrt, log, log10, exp, sin, cos, tan, arcsin, arccos, arctan, sinh, cosh, tanh, arcsinh, arccosh, and arctanh. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>], float) &gt;&gt;&gt; np.sqrt(a) array([ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>])</code> </pre> <br>  The floor, ceil, and rint functions return lower, upper, or closest (rounded) values: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1.1</span></span>, <span class="hljs-number"><span class="hljs-number">1.5</span></span>, <span class="hljs-number"><span class="hljs-number">1.9</span></span>], float) &gt;&gt;&gt; np.floor(a) array([ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>]) &gt;&gt;&gt; np.ceil(a) array([ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>]) &gt;&gt;&gt; np.rint(a) array([ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>])</code> </pre> <br>  Numpy also includes two important mathematical constants: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>np.pi <span class="hljs-number"><span class="hljs-number">3.1415926535897931</span></span> &gt;&gt;&gt; np.e <span class="hljs-number"><span class="hljs-number">2.7182818284590451</span></span></code> </pre> <br><h1>  Enumerating array elements </h1><br>  It is possible to iterate arrays like lists: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], int) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a: ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  For multidimensional arrays, the iteration will be carried out along the first axis, so that each loop through will return the ‚Äústring‚Äù of the array: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]], float) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a: ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x [ <span class="hljs-number"><span class="hljs-number">1.</span></span> <span class="hljs-number"><span class="hljs-number">2.</span></span>] [ <span class="hljs-number"><span class="hljs-number">3.</span></span> <span class="hljs-number"><span class="hljs-number">4.</span></span>] [ <span class="hljs-number"><span class="hljs-number">5.</span></span> <span class="hljs-number"><span class="hljs-number">6.</span></span>]</code> </pre> <br>  Multiple assignment is also available during iteration: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]], float) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (x, y) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a: ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> x * y <span class="hljs-number"><span class="hljs-number">2.0</span></span> <span class="hljs-number"><span class="hljs-number">12.0</span></span> <span class="hljs-number"><span class="hljs-number">30.0</span></span></code> </pre> <br><h1>  Basic array operations </h1><br>  To obtain any properties of arrays, there are many functions.  Elements can be summarized or multiplied: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], float) &gt;&gt;&gt; a.sum() <span class="hljs-number"><span class="hljs-number">9.0</span></span> &gt;&gt;&gt; a.prod() <span class="hljs-number"><span class="hljs-number">24.0</span></span></code> </pre> <br>  In this example, the array functions were used.  You can also use your own numpy functions: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>np.sum(a) <span class="hljs-number"><span class="hljs-number">9.0</span></span> &gt;&gt;&gt; np.prod(a) <span class="hljs-number"><span class="hljs-number">24.0</span></span></code> </pre> <br>  For most cases, both options can be used. <br>  Some functions make it possible to operate with statistical data.  These are the mean functions (arithmetic mean), variation and deviation: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>], float) &gt;&gt;&gt; a.mean() <span class="hljs-number"><span class="hljs-number">4.0</span></span> &gt;&gt;&gt; a.var() <span class="hljs-number"><span class="hljs-number">12.666666666666666</span></span> &gt;&gt;&gt; a.std() <span class="hljs-number"><span class="hljs-number">3.5590260840104371</span></span></code> </pre> <br>  You can find the minimum and maximum in the array: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>], float) &gt;&gt;&gt; a.min() <span class="hljs-number"><span class="hljs-number">1.0</span></span> &gt;&gt;&gt; a.max() <span class="hljs-number"><span class="hljs-number">9.0</span></span></code> </pre> <br>  The argmin and argmax functions return the index of the minimum or maximum element: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>], float) &gt;&gt;&gt; a.argmin() <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; a.argmax() <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  For multidimensional arrays, each of the functions can take an additional axis argument and, depending on its value, perform functions on a specific axis, putting the results of the execution into an array: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]], float) &gt;&gt;&gt; a.mean(axis=<span class="hljs-number"><span class="hljs-number">0</span></span>) array([ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>]) &gt;&gt;&gt; a.mean(axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) array([ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>]) &gt;&gt;&gt; a.min(axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) array([ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]) &gt;&gt;&gt; a.max(axis=<span class="hljs-number"><span class="hljs-number">0</span></span>) array([ <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">5.</span></span>])</code> </pre> <br>  Like lists, arrays can be sorted: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], float) &gt;&gt;&gt; sorted(a) [<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>] &gt;&gt;&gt; a.sort() &gt;&gt;&gt; a array([<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">6.</span></span>])</code> </pre> <br>  The values ‚Äã‚Äãin the array can be abbreviated to belong to a given range.  This is the same as applying min (max (x, minval), maxval) to each element x: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], float) &gt;&gt;&gt; a.clip(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) array([ <span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>])</code> </pre> <br>  Unique items can be extracted like this: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>], float) &gt;&gt;&gt; np.unique(a) array([ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">7.</span></span>])</code> </pre> <br>  For two-dimensional arrays, the diagonal can be obtained as follows: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]], float) &gt;&gt;&gt; a.diagonal() array([ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>])</code> </pre> <br>  Here is the second article came to an end.  Thank you for your attention and good luck in your endeavors!  See you soon. </div><p>Source: <a href="https://habr.com/ru/post/353416/">https://habr.com/ru/post/353416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353406/index.html">How I pumped the skills of personal effectiveness</a></li>
<li><a href="../353408/index.html">Scientific programming: part 1</a></li>
<li><a href="../353410/index.html">Device and mechanism of work of Prometheus Operator in Kubernetes</a></li>
<li><a href="../353412/index.html">What is frozen on feature freeze</a></li>
<li><a href="../353414/index.html">Analysis of the main concepts of concurrency</a></li>
<li><a href="../353418/index.html">Improving performance through access control</a></li>
<li><a href="../353422/index.html">Three-dimensional engine on Excel formulas for dummies</a></li>
<li><a href="../353424/index.html">Aircraft control system simulation</a></li>
<li><a href="../353426/index.html">How to upload custom log to Splunk + logs for Fortinet</a></li>
<li><a href="../353428/index.html">Telegram lock - prepare for the worst?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>