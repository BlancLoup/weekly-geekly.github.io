<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Class-fields-proposal or What went wrong on the tc39 committer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All of us long ago wanted normal encapsulation in JS, which could be used without unnecessary gestures. We also want convenient constructs for declari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Class-fields-proposal or What went wrong on the tc39 committer</h1><div class="post__text post__text-html js-mediator-article"><p>  All of us long ago wanted normal encapsulation in JS, which could be used without unnecessary gestures.  We also want convenient constructs for declaring class properties.  And, finally, we want all these features in the language to appear so as not to break existing applications. </p><br><p> It would seem that here it is happiness: the <a href="https://github.com/tc39/proposal-class-fields">class-fields-proposal</a> , which after many years of torment of the <a href="https://github.com/tc39">tc39 committee</a> did get to <code>stage 3</code> and even got <a href="https://www.chromestatus.com/feature/6001727933251584">implemented in chrome</a> . </p><br><p>  Honestly, I would really like to write an article just about why it is worth using a new feature of the language and how to do it, but unfortunately, the article will not be about that at all. </p><a name="habracut"></a><br><h1 id="opisanie-tekuschego-propozala">  Description of current proposal </h1><br><p>  I will not repeat here the <a href="https://github.com/tc39/proposal-class-fields">original description</a> , <a href="">FAQ</a> and <a href="https://tc39.github.io/proposal-class-fields/">changes in the specification</a> , but only briefly outline the main points. </p><br><h2 id="polya-klassa">  Class fields </h2><br><p>  Declaring fields and using them inside the class: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ x = <span class="hljs-number"><span class="hljs-number">1</span></span>; method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p>  Access to non-class fields: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ax);</code> </pre> <br><p>  It would seem that everything is obvious and we have been using this syntax for many years with the help of <a href="https://www.npmjs.com/package/babel-plugin-transform-class-properties">Babel</a> and <a href="http://www.typescriptlang.org/docs/handbook/classes.html">TypeScript</a> . </p><br><p>  Only there is a nuance.  This new syntax uses the <code>[[Define]]</code> , rather than the <code>[[Set]]</code> semantics with which we have lived all this time. </p><br><p>  In practice, this means that the code above <strong>does not equal</strong> this: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; } method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p>  And in fact, it is <strong>equivalent</strong> to this: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"x"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }); } method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p>  And, although for the example above, both approaches do, in fact, the same thing, it is a <strong>VERY SERIOUS</strong> difference, and here is why: </p><br><p>  Suppose we have such a parent class: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ x = <span class="hljs-number"><span class="hljs-number">1</span></span>; method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x); } }</code> </pre> <br><p>  Based on it, we created another one: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ x = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><p>  And they used it: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.method(); <span class="hljs-comment"><span class="hljs-comment">//   2  </span></span></code> </pre> <br><p>  After that, for some reason, class <code>A</code> was changed in a seemingly backward-compatible way: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ _x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,   ,        get x() { return this._x; }; set x(val) { return this._x = val; }; method() { console.log(this._x); } }</span></span></code> </pre> <br><p>  And for <code>[[Set]]</code> semantics, this is indeed a backward compatible change, but not for <code>[[Define]]</code> .  Now the <code>b.method()</code> call will display <code>1</code> instead of <code>2</code> in the console.  And this will happen because <code>Object.defineProperty</code> overrides the property dexryptor and, accordingly, the A / heterter from class <code>A</code> will not be called.  In fact, in the child class we <em>overshadow the</em> parent's <code>x</code> property, just as we can do it in the lexical scopa: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><p>  True, in this case the linter with his <a href="https://palantir.github.io/tslint/rules/no-shadowed-variable/"><code>no-shadowed-variable</code></a> / <a href="https://eslint.org/docs/rules/no-shadow"><code>no-shadow</code></a> rules will save us, but the likelihood of someone doing a <code>no-shadowed-class-field</code> tends to zero. </p><br><blockquote>  By the way, I will be grateful for a more successful Russian-language term for <code>shadowed</code> . </blockquote><p>  In spite of all the above, I am not an irreconcilable opponent of the new semantics (although I would prefer a different one), because it has its own positive aspects.  But, unfortunately, these advantages do not outweigh the main disadvantage - we have been using <code>[[Set]]</code> semantics for many years, because it is precisely this that is used in <code>babel6</code> and <code>TypeScript</code> , by default. </p><br><blockquote>  True, it is worth noting that in <code>babel7</code> <a href="https://babeljs.io/docs/en/babel-plugin-proposal-class-properties">default value has been changed</a> . </blockquote><p>  More original discussions on this topic can be found <a href="https://github.com/tc39/proposal-class-fields/issues/151">here</a> and <a href="https://github.com/tc39/proposal-class-public-fields/issues/42">here</a> . </p><br><h2 id="privatnye-polya">  Private fields </h2><br><p>  And now we come to the most controversial part of this proposal.  So controversial that: </p><br><ol><li>  despite the fact that it is already implemented in <a href="https://www.chromestatus.com/feature/6001727933251584">Chrome Canary</a> and public fields are already enabled by default, private ones are still flagged; </li><li>  in spite of the fact that the <a href="https://github.com/tc39/proposal-private-fields">initial propozal for private fields</a> was merged with the current one, requests are still being created for the separation of these two features (for example, <a href="https://github.com/tc39/proposal-class-fields/issues/144">one</a> , <a href="https://github.com/tc39/proposal-class-fields/issues/142">two</a> , <a href="https://github.com/tc39/proposal-class-fields/issues/148">three</a> and <a href="https://github.com/tc39/proposal-class-fields/pull/140">four</a> ); </li><li>  even some committee members (for example, <a href="https://github.com/allenwb">Allen Wirfs-Brock</a> and <a href="https://github.com/zenparsing">Kevin Smith</a> ) oppose and <a href="http://tc39.github.io/tc39-notes/2018-09_sept-26.html">offer alternatives</a> , despite <strong>stage3</strong> ; </li><li>  This propozal set a record for the number of issues - <strong>129</strong> in the <a href="https://github.com/tc39/proposal-class-fields/issues">current repository</a> + <strong>96</strong> in the <a href="https://github.com/tc39/proposal-private-fields/issues">original</a> , against <strong>126</strong> for <a href="https://github.com/tc39/proposal-bigint/issues">BigInt</a> , with what the record holder has mostly <a href="https://github.com/tc39/proposal-class-fields/issues/100">negative comments</a> ; </li><li>  I had to create a <a href="https://github.com/tc39/proposal-class-fields/issues/150">separate thread</a> with an attempt to somehow summarize all the claims against it; </li><li>  I had to write a <a href="">separate FAQ</a> , which reproves this part <br><blockquote>  however, due to a rather weak argument, such discussions also appeared ( <a href="https://github.com/tc39/proposal-class-fields/issues/133">one</a> , <a href="https://github.com/tc39/proposal-class-fields/issues/136">two</a> ) <br></blockquote></li><li>  I, personally, spent all my free time (and sometimes working time) for a long period of time, in order to sort things out and even <a href="https://github.com/tc39/proposal-class-fields/issues/134">find an explanation</a> why he is like that or offer a <a href="https://github.com/tc39/proposal-class-fields/issues/149">suitable alternative</a> ; </li><li>  I finally decided to write this review article. </li></ol><br><p>  Private fields are declared as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ #priv; }</code> </pre> <br><p>  And access to them is as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ #priv = <span class="hljs-number"><span class="hljs-number">1</span></span>; method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#priv); } }</code> </pre> <br><p>  I will not even raise the topic of the fact that the mental model behind this is not very intuitive ( <code>this.#priv !== this['#priv']</code> ) does not use the already reserved words <code>private</code> / <code>protected</code> (which will surely cause additional pain for TypeScript developers), it is not clear how to extend this for <a href="https://github.com/tc39/proposal-class-fields/issues/122">other access modifiers</a> , and the syntax itself is not very beautiful.  Although all this was the original reason that pushed me to a deeper study and participation in discussions. </p><br><p>  This all concerns the syntax where subjective esthetic preferences are very strong.  And with this one could live and get used to it over time.  If it were not for one thing: there is a very significant problem of semantics ... </p><br><h3 id="cemantika-weakmap">  <code>WeakMap</code> </h3><br><p>  Let's take a look at what is behind the existing prosobal.  We can rewrite the example from above with encapsulation and without using the new syntax, but keeping the semantics of the current proposal: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privatesForA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { privatesForA.set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, {}); privatesForA.get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).priv = <span class="hljs-number"><span class="hljs-number">1</span></span>; } method() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(privatesForA.get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).priv); } }</code> </pre> <br><blockquote>  By the way, on the basis of this semantics, one of the committee members even built a small <a href="https://github.com/zenparsing/hidden-state">utility library</a> , which allows using the private state now, in order to show that such functionality is too overestimated by the committee.  The formatted code takes only 27 lines. </blockquote><p>  In general, everything is pretty good, we get <code>hard-private</code> , which can not be reached / intercepted / tracked from the external code and we can get access to the private fields of another instance of the same class, for example: </p><br><pre> <code class="javascript hljs">isEquals(obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> privatesForA.get(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).id === privatesForA.get(obj).id; }</code> </pre> <br><p>  Well, it is very convenient, except for the fact that this semantics, in addition to encapsulation itself, also includes <code>brand-checking</code> (you can not google what it is - you can hardly find relevant information). <br>  <code>brand-checking</code> is the opposite of <code>duck-typing</code> , in the sense that it does not check the public intefrace of the object, but the fact that the object was built using trusted code. <br>  Such a check, in fact, has a certain scope - it is mainly related to the security of calling untrusted code in a single address space with a trusted and ability to exchange objects directly without serialization. </p><br><blockquote>  Although some engineers consider this to be a necessary part of proper encapsulation. </blockquote><p>  Despite the fact that this is a rather curious opportunity, which is closely related to the <code></code> pattern ( <a href="https://tvcutsem.github.io/js-membranes">short</a> and <a href="https://tvcutsem.github.io/membranes">longer</a> description), <a href="https://github.com/tc39/proposal-realms"><code>Realms</code> proposal</a> and scientific work in the field of Computer Science, which <a href="https://github.com/erights">Mark Samuel Miller</a> (he is also a member of the committee), in my experience , in the practice of most developers, this almost never occurs. </p><br><blockquote>  <a href="https://github.com/patriksimek/vm2">By the</a> way, I came across a membrane (although I didn‚Äôt know what it was then) when I rewrote <a href="https://github.com/patriksimek/vm2">vm2 to</a> fit my needs. </blockquote><br><h3 id="problema-brand-checking">  Problem <code>brand-checking</code> </h3><br><p>  As mentioned earlier, <code>brand-checking</code> is the opposite of <code>duck-typing</code> .  In practice, this means that having such code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> brands = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { brands.set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, {}); } method() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } brandCheckedMethod() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!brands.has(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">'Brand-check failed'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method()); } }</code> </pre> <br><p>  <code>brandCheckedMethod</code> can only be called with an instance of class <code>A</code> and even if an object that preserves invariants of this class acts as a target, this method will throw an exception: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> duckTypedObj = { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: A.prototype.method.bind(duckTypedObj), <span class="hljs-attr"><span class="hljs-attr">brandCheckedMethod</span></span>: A.prototype.brandCheckedMethod.bind(duckTypedObj), }; duckTypedObj.method(); <span class="hljs-comment"><span class="hljs-comment">//        1 duckTypedObj.brandCheckedMethod(); //     </span></span></code> </pre> <br><p>  Obviously, this example is rather synthetic and the benefits of such <code>duckTypedObj</code> questionable, as long as we don‚Äôt remember <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><code>Proxy</code></a> . <br>  One of the very important use cases for proxies is metaprogramming.  In order for the proxy to perform all the necessary useful work, the methods of objects that are wrapped with a proxy should be executed in the context of the proxy, and not in the context of the target, ie: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(a, { get(target, p, receiver) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> property = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, p, receiver); doSomethingUseful(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, retval, target, p, receiver); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> property === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) ? property.bind(proxy) : property; } });</code> </pre> <br><p>  Call <code>proxy.method();</code>  does the useful work declared in the proxy and returns <code>1</code> , while calling <code>proxy.brandCheckedMethod();</code>  instead of twice doing a useful job from a proxy, throw an exception, because <code>a !== proxy</code> , which means <code>brand-check</code> failed. </p><br><p>  Yes, we can perform methods / functions in the context of the real target, and not a proxy, and for some scenarios this is enough (for example, to implement the <code></code> pattern), but this is not enough for all cases (for example, to implement reactive properties: <a href="https://github.com/mobxjs/mobx">MobX 5</a> already uses a proxy for this, <a href="https://vuejs.org/">Vue.js</a> and <a href="https://aurelia.io/">Aurelia</a> experiment with this approach for future releases). </p><br><p>  In general, as long as a <code>brand-check</code> needs to be done explicitly, this is not a problem - the developer simply consciously has to decide what trade-off he is doing and whether he needs it, moreover, in the case of an explicit <code>brand-check</code> you can implement it in such a way that the error would not be thrown on trusted proxies. </p><br><p>  Unfortunately, the current proposal deprives us of this flexibility: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ #priv; method() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#priv; <span class="hljs-comment"><span class="hljs-comment">//    brand-check   } }</span></span></code> </pre> <br><p>  Such a <code>method</code> will always throw an exception if it is called not in the context of an object constructed using the constructor <code>A</code>  And the worst thing is that <code>brand-check</code> is implicit here and is mixed with another functionality - encapsulation. </p><br><p>  While <code></code> almost necessary for any code, <code>brand-check</code> has a fairly narrow range of applications.  And combining them into one syntax will result in a lot of unintentional <code>brand-check</code> in the user code, when the developer intended only to hide implementation details. <br>  And the slogan, which is used to promote this propozala <code># is the new _</code> only aggravates the situation. </p><br><blockquote>  You can also read a <a href="https://github.com/tc39/proposal-class-fields/issues/106">detailed discussion of how an existing propozal breaks a proxy</a> .  <a href="https://github.com/EisenbergEffect">One of the Aurelia developers</a> and the <a href="https://github.com/yyx990803">author Vue.js spoke in the discussion</a> . <br><br>  Also, <a href="https://github.com/tc39/proposal-class-fields/issues/158">my commentary</a> , describing in more detail the difference between different proxy usage scenarios, may seem interesting to someone.  As well as in general, <a href="https://github.com/tc39/proposal-class-fields/issues/158">all discussion of the relationship of private fields and membranes</a> . </blockquote><br><h1 id="alternativy">  Alternatives </h1><br><p>  All these discussions would make little sense if there were no alternatives.  Unfortunately, no alternative proposal even got into <strong>stage1</strong> , and, as a result, neither had the chance to be sufficiently developed.  However, I will list here the alternatives that somehow solve the problems described above. </p><br><ol><li>  <a href="https://github.com/zenparsing/proposal-private-symbols"><strong>Symbol.private</strong></a> - an alternative proposal of one of the committee members. <br><ol><li>  Solves all the above problems (although it may have its own, but, in the absence of active work on it, it is difficult to find them) </li><li>  it was once again thrown back at the <a href="http://tc39.github.io/tc39-notes/2018-09_sept-26.html">last meeting of the committee</a> due to the lack of a built-in <code>brand-check</code> , problems with the membrane pattern (although <a href="https://github.com/zenparsing/proposal-private-symbols/issues/7">this also</a> offers an adequate solution) and the lack of a convenient syntax </li><li>  convenient syntax can be built on top of the prozal itself, as shown by me <a href="https://github.com/tc39/proposal-class-fields/issues/149">here</a> and <a href="https://github.com/tc39/proposal-class-fields/issues/134">here</a> </li></ol></li><li>  <a href=""><strong>Classes 1.1</strong></a> - earlier propozal from the same author </li><li>  <a href="https://github.com/tc39/proposal-class-fields/issues/90"><strong>Using <em>private</em> as an object</strong></a> </li></ol><br><h1 id="vmesto-zaklyucheniya">  Instead of conclusion </h1><br><p>  From the tone of the article, perhaps it may seem that I condemn the committee - this is not so.  It only seems to me that during those years (depending on what to take as a starting point, it could be even decades), which the committee worked on encapsulation in JS, a lot of things in the industry changed, and the look could be blurred, which led to a false prioritization . </p><br><p>  Moreover, we, as a community, are <strong>putting</strong> pressure on <strong>tc39</strong> forcing them to release features faster, while giving very little feedback in the early stages of propozal, bringing down their indignation only at the moment when there is little that can be changed. </p><br><p>  <a href="https://github.com/tc39/proposal-class-fields/pull/140">There is an opinion</a> that in this case the process simply failed. </p><br><p>  After dipping into this with my head and communicating with some representatives, I decided that I would do my best to prevent a repetition of this situation - but I can do a little (write a review article, do the implementation <code>stage1</code> in <code>babel</code> and just that). </p><br><p>  But the most important thing is the feedback - so I would ask you to take part in this short survey.  And I, in turn, will try to bring it to the committee. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/428119/">https://habr.com/ru/post/428119/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428109/index.html">Corporate wall</a></li>
<li><a href="../428111/index.html">Arithmetic of arbitrary precision in Erlang</a></li>
<li><a href="../428113/index.html">On the question of Bezier curves, speed Arduino and one interesting site, or how I spent the weekend</a></li>
<li><a href="../428115/index.html">Web development for ecommerce: 5 technology trends for 2019</a></li>
<li><a href="../428117/index.html">Google's free tensor processors in the cloud laboratory</a></li>
<li><a href="../428121/index.html">Stan Drapkin. High-level cryptography hooks in .NET</a></li>
<li><a href="../428123/index.html">Security Week 41: Good News</a></li>
<li><a href="../428125/index.html">Who are the product analysts and why are they needed in the team?</a></li>
<li><a href="../428127/index.html">Nginx cache: all new - well forgotten old</a></li>
<li><a href="../428129/index.html">Simple fuzzy logic blinded "from what it was" for a gas turbine engine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>