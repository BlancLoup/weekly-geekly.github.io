<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a pool of objects in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 
 In this article, I will discuss how to improve the performance of a multi-threaded (and not only) C # application, in which objects are of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a pool of objects in C #</h1><div class="post__text post__text-html js-mediator-article">  Good day! <br>  In this article, I will discuss how to improve the performance of a multi-threaded (and not only) C # application, in which objects are often created for "one-off" work. <br>  A little about multithreading, non-blocking synchronization, use of the profiler built into VS2012 and a small benchmark. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2583%25D0%25BB">The object pool</a> is a parent design pattern, a set of objects initialized and ready to use. <br>  Why is it needed?  In short - to improve performance when initializing a new object leads to high costs.  But here it is important to understand that the garbage collector built into .NET does an excellent job with the destruction of light short-lived objects, therefore the applicability of the pool is limited by the following criteria: <br><ul><li>  expensive to create and / or destroy objects (examples: sockets, streams, unmanaged resources); </li><li>  clearing objects for reuse is cheaper than creating a new one (or nothing); </li><li>  very large objects. </li></ul><br>  I will explain the last point a little.  If your object occupies 85,000 bytes or more in memory, it falls into a large object heap in the second generation of garbage collection, which automatically makes it a ‚Äúlong-lived‚Äù object.  Add to this the fragmentation (this heap is not compressed) and we get the potential problem of lack of memory with constant allocation / destruction. <br>  The idea of ‚Äã‚Äãthe pool is to organize the reuse of "expensive" objects using the following scenario: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = pool.Take(); <span class="hljs-comment"><span class="hljs-comment">//    .        obj.DoSomething(); pool.Release(obj); //  ("")   ,     </span></span></code> </pre> <br>  Problems of this approach: <br><ul><li>  after performing work with an object, it may be necessary to reset it to its initial state so that previous use does not affect subsequent ones in any way; </li><li>  the pool must provide thread safety, because it is used, as a rule, in multi-threaded systems; </li><li>  the pool must handle the situation when there are no objects available for issuing in it. </li></ul><br>  Given these problems, requirements for a new class were drawn up: <br><ol><li>  Type safety pool at compile time. </li><li>  Work pool with any classes, including third-party. </li><li>  Simple use in code. </li><li>  Auto-selection of new objects in case of shortage, their user initialization. </li><li>  Limit the total number of selected objects. </li><li>  Auto-clean object when it is returned to the pool. </li><li>  Thread safety (preferably with minimal synchronization costs). </li><li>  Support for multiple instances of the pool (this implies at least the simplest control that objects return to their own pools). </li></ol><br><br><h4>  Problem solving use </h4><br>  In some implementations, to support a pool of an object, an object must implement an IPoolable interface or similar, but my task was to ensure that the pool works with any classes, even if they are closed for inheritance.  For this was created a generic shell PoolSlot, which inside contains the object itself and a link to the pool.  The pool itself is an abstract generic class for storing these slots, with two unimplemented methods for creating a new object and clearing the old one. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Pool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PoolSlot&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TakeSlot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {...} <span class="hljs-comment"><span class="hljs-comment">//  "  " public void Release(PoolSlot&lt;T&gt; slot) {...} //  "  " /* ... */ //   : protected abstract T ObjectConstructor(); //   ,    protected virtual void CleanUp(T item) {} //   ,   }</span></span></code> </pre><br><h5>  Using the example of the class SocketAsyncEventArgs </h5><br><div class="spoiler">  <b class="spoiler_title">Pool definition</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SocketClientPool</span></span> : <span class="hljs-title"><span class="hljs-title">Pool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">SocketAsyncEventArgs</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _bufferSize; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SocketClientPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bufferSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> initialCount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxCapacity</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxCapacity</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialCount &gt; maxCapacity) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IndexOutOfRangeException(); _bufferSize = bufferSize; TryAllocatePush(initialCount); <span class="hljs-comment"><span class="hljs-comment">//      protected-;           } protected override SocketAsyncEventArgs ObjectConstructor() { var args = new SocketAsyncEventArgs(); args.SetBuffer(new byte[_bufferSize], 0, _bufferSize); return args; } protected override void CleanUp(SocketAsyncEventArgs @object) { Array.Clear(@object.Buffer, 0, _bufferSize); } }</span></span></code> </pre></div></div><br>  Use in code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SocketClientPool(<span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   ,  /* ...-  ... */ var slot = pool.TakeSlot(); //     var args = slot.Object; //    -  pool.Release(slot); //    </span></span></code> </pre><br>  Or even like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slot = pool.TakeSlot()) <span class="hljs-comment"><span class="hljs-comment">//  PoolSlot  IDisposable { var args = slot.Object; }</span></span></code> </pre><br>  Those who are familiar with the asynchronous .NET model and / or asynchronous methods of the same Socket class know that using such an implementation is difficult, because the Socket.XxxAsync methods take SocketAsyncEventArgs as input, and not some PoolSlot &lt;SocketAsyncEventArgs&gt; .  It doesn't matter to call a method, but where do you get the slot in the end handler? <br>  One option is to save the slot in the SocketAsyncEventArgs.UserToken property when creating an object; for this, there is a method in the pool for overriding HoldSlotInObject. <br><div class="spoiler">  <b class="spoiler_title">Redefinition for our example</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HoldSlotInObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SocketAsyncEventArgs @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">, PoolSlot&lt;SocketAsyncEventArgs&gt; slot</span></span></span><span class="hljs-function">)</span></span> { @<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.UserToken = slot; } <span class="hljs-comment"><span class="hljs-comment">/* ...-  ... */</span></span> pool.Release(args.UserToken <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PoolSlot&lt;SocketAsyncEventArgs&gt;);</code> </pre></div></div><br>  Of course, not every object provides the user with such a property.  And if your class is still not closed from inheritance, then a special IPoolSlotHolder interface with a single property for storing the slot is offered.  And if I know that my object is guaranteed to contain a slot, then it would be logical to add TakeObject / Release methods that return / accept objects themselves (and get their slot inside), which was done in the descendant of the pool. <br><div class="spoiler">  <b class="spoiler_title">Simplified implementation of the improved pool (for objects implementing IPoolSlotHolder</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PoolEx</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">Pool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span> : <span class="hljs-title"><span class="hljs-title">IPoolSlotHolder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TakeObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span></span><span class="hljs-function">)</span></span> { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sealed</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HoldSlotInObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">, PoolSlot&lt;T&gt; slot</span></span></span><span class="hljs-function">)</span></span> { ... } <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre></div></div><br>  Next, I suggest to get acquainted with the development of the internal "kitchen". <br><br><h4>  Storage </h4><br>  To store objects "in the pool" is a collection of ConcurrentStack.  The possible use of multiple pool instances required keeping track of which of the objects was created by this particular pool. <br>  This was how the ‚Äúregistry‚Äù was entered based on the ConcurrentDictionary, which contains the ID of the slots ever created by the pool and the accessibility flag of the object (true - ‚Äúin the pool‚Äù, false - ‚Äúnot in the pool‚Äù). <br>  This made it possible to immediately kill 2 birds with one stone: to prevent the erroneous multiple return of the same object (after all, the stack does not ensure the uniqueness of the objects stored in it) and to prevent the return of objects created in another pool.  This approach was a temporary solution, and then I got rid of it. <br><br><h4>  Multithreading </h4><br>  The classic implementation of the pool involves using a semaphore (in .NET, this is Semaphore and SemaphoreSlim) for tracking the number of objects, or other synchronization primitives in conjunction with a counter, but ConcurrentStack, like ConcurrentDictionary, is thread-safe collections, so the input-output of objects is no longer required .  I will note only that the call to the ConcurrentStack.Count property causes a complete enumeration of all the elements, which takes considerable time, so it was decided to add my own element counter.  As a result, two ‚Äúatomic‚Äù pool operations were obtained - Push and TryPop, on the basis of which all the others were built. <br><div class="spoiler">  <b class="spoiler_title">Implementation of the simplest operations</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PoolSlot&lt;T&gt; item</span></span></span><span class="hljs-function">)</span></span> { _registry[token.Id] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// :  " " _storage.Push(item); //     Interlocked.Increment(ref _currentCount); } private bool TryPop(out PoolSlot&lt;T&gt; item) { if (_storage.TryPop(out item)) //      { Interlocked.Decrement(ref _currentCount); _registry[token.Id] = false; // :  "  " return true; } item = default(PoolSlot&lt;T&gt;); return false; }</span></span></code> </pre></div></div><br>  In addition to the I / O of existing objects, it is necessary to synchronize the allocation of new ones to the specified upper limit. <br>  Here we use a semaphore initialized by the maximum number of elements in the pool (upper limit) and subtract one each time when creating a new object, but the problem is that when it reaches zero, it will simply block the stream.  A call to the SemaphoreSlim.Wait (0) method, which, given the current value of the ‚Äú0‚Äù semaphore, returns false almost without delay, could be a way out of this situation, but it was decided to write a lightweight analog of this functionality.  This is how the LockFreeSemaphore class appeared, which returns false when zero is reached without delay.  For internal synchronization, it uses <a href="http://msdn.microsoft.com/ru-ru/library/801kt583.aspx">Interlocked.CompareExchange</a> fast CAS operations. <br><div class="spoiler">  <b class="spoiler_title">An example of using a CAS operation in a semaphore</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryTake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  true,     ,  false (   ) { int oldValue, newValue; do { oldValue = _currentCount; //    newValue = oldValue - 1; //    if (newValue &lt; 0) return false; //     0 -  false   } while (Interlocked.CompareExchange(ref _currentCount, newValue, oldValue) != oldValue); //        ,         return true; }</span></span></span></span></code> </pre></div></div><br>  Thus, the pool operation ‚Äútake an object‚Äù works according to the following algorithm: <br><ol><li>  We are trying to take an object from the repository, if it is not there - point 2. </li><li>  We are trying to create a new object if the semaphore is zero (the upper limit is reached) - point 3. </li><li>  The worst scenario - we expect the object to return to the bitter end. </li></ol><br><br><h4>  First results, optimization and refactoring </h4><br>  Do you need a pool of objects?  Depends on the situation.  Here are the results of a small test using the ‚Äútypical server object‚Äù, SocketAsyncEventArgs with a buffer of 1024 bytes (time in seconds, pooling is on): <br><table><tbody><tr><td>  New object requests </td><td>  One thread, no pool </td><td>  One thread, with a pool </td><td>  25 tasks * without pool </td><td>  25 tasks *, with a pool </td></tr><tr><td>  1,000 </td><td>  0.002 </td><td>  0.003 </td><td>  0.027 </td><td>  0.009 </td></tr><tr><td>  10,000 </td><td>  0.010 </td><td>  0.001 </td><td>  0.272 </td><td>  0.039 </td></tr><tr><td>  25,000 </td><td>  0.030 </td><td>  0.003 </td><td>  0.609 </td><td>  0.189 </td></tr><tr><td>  50,000 </td><td>  0.048 </td><td>  0.006 </td><td>  1.285 </td><td>  0.287 </td></tr><tr><td>  1,000,000 </td><td>  0.959 </td><td>  0.125 </td><td>  27.965 </td><td>  8.345 </td></tr></tbody></table><br>  * task - the System.Threading.Tasks.Task class from the TPL library, starting with .NET 4.0 <br>  The results of the passage of the VS2012 profiler in a multi-threaded test with a pool: <br><img src="https://habrastorage.org/storage2/525/297/bc5/525297bc53b2d01ef409749c5da15126.png"><br><br>  As you can see, everything depends on the ConcurrentStack.TryPop method, which (we will assume) has nowhere to accelerate.  In second place is an appeal to the ‚Äúregistry‚Äù, which takes about 14% each in both operations. <br>  In principle, the support of the second collection inside the pool seemed to me like a crutch, so the sign ‚Äúin the pool / not in the pool‚Äù was transferred to the slot itself, and the registry was safely removed.  Test results after refactoring (increase, as expected, 30-40%): <br><table><tbody><tr><td>  New object requests </td><td>  25 tasks with a pool </td></tr><tr><td>  25,000 </td><td>  0.098 </td></tr><tr><td>  1,000,000 </td><td>  5.751 </td></tr></tbody></table><br>  I think this can be stopped. <br><br><h4>  Conclusion </h4><br>  In brief, let me remind you how the tasks were solved: <br><ol><li>  Type safety at compile time - using generic classes. </li><li>  Working with a pool with any classes - using generic shell without inheritance. </li><li>  Ease of use - using construction (implementation by the shell IDisposable interface). </li><li>  Auto-selection of new objects is the abstract Pool.ObjectConstructor method, in which the object is initialized as you please. </li><li>  Limiting the number of objects - a lightweight version of the semaphore. </li><li>  Auto-clearing an object when it is returned is a virtual method called Pool.CleanUp, which is automatically called by the pool when it returns. </li><li>  Thread Safety ‚Äî using a collection of ConcurrentStack and CAS operations (methods of the Interlocked class). </li><li>  Support for multiple pool instances ‚Äî the Pool class is not static, not singleton, and provides validation checks. </li></ol><br><br>  Source code with unit tests and test application: <a href="https://github.com/Dem0n13/AsyncSocketServers">Github</a> <br>  If interested, I can continue the article with the implementation of asynchronous TCP and UDP socket servers for which this pool was written. </div><p>Source: <a href="https://habr.com/ru/post/175317/">https://habr.com/ru/post/175317/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../175305/index.html">FailOver Conference April 4th - free online webcast</a></li>
<li><a href="../175309/index.html">Startup marketing. Developer vs App on AppClub # 5</a></li>
<li><a href="../175311/index.html">AeroFS came out of the closed beta</a></li>
<li><a href="../175313/index.html">SAS interface: history, storage organization examples</a></li>
<li><a href="../175315/index.html">Online application development school for Windows 8. Week # 1</a></li>
<li><a href="../175319/index.html">Download management for dedicated servers</a></li>
<li><a href="../175321/index.html">CLI on python. We let the user to the server</a></li>
<li><a href="../175323/index.html">Tools and code examples for ARIA development</a></li>
<li><a href="../175327/index.html">How to quickly find bugs that interfere with the release</a></li>
<li><a href="../175329/index.html">How to find or check e-mail address</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>