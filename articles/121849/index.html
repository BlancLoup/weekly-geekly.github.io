<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generating random numbers on microcontrollers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A lot is written about random number generators, but almost always, when it comes to implementation, it is implied (or explicitly stated) that we are ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generating random numbers on microcontrollers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage/044e9e6f/baa409ed/b95d7402/d85b2da6.png"><br><br>  A lot is written about random number generators, but almost always, when it comes to implementation, it is implied (or explicitly stated) that we are talking about x86 / x64 and other ‚Äúadult‚Äù architectures.  At the same time, the forums dedicated to the development of devices on microcontrollers are full of questions ‚Äúhow do I generate a random number on% controllername%?‚Äù.  Moreover, the range of answers extends from ‚Äúsee Google / Wikipedia‚Äù to ‚Äúuse the standard function‚Äù.  Not always, this ‚Äústandard function‚Äù exists and suits the developer in all respects, more often the other way around: either the numbers are far from random, the speed is too low, or the resulting code does not fit in the free memory at all. <br>  Let's try to figure out what random number generation algorithms are, how to choose the right one, and most importantly, what are the features of the implementation of these algorithms on controllers. <br><a name="habracut"></a><br><br><h4>  Evaluation of "randomness" </h4><br>  Applications for RNG can be found very different, from toys to serious cryptography.  Accordingly, the requirements for the generator also vary greatly.  To assess the quality (level of "randomness") of the generator, there are special tests.  Here are the most basic ones: <br><ul><li>  Frequency test.  It consists in counting the number of zeros and ones in the sequence of bits.  Units and zeros should be approximately equal. </li><li>  A test for a sequence of identical bits.  Rows of the same bits are searched for, of the type 000 ... 0 or 111 ... 1.  The distribution of frequencies with which the series are encountered, depending on their length, must correspond to such a distribution for a truly random signal. </li><li>  Spectral test.  A discrete Fourier transform is applied to the source sequence.  The resulting spectrum should not have significant peaks, which would indicate the presence of periodic sequence properties. </li><li>  Autocorrelation test.  The correlation value between copies of a sequence that are shifted relative to each other is calculated.  The test allows you to find duplicate areas in a sequence. </li></ul><br>  There are special kits that include dozens of similar tests: <br>  <a href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/nissc-paper.pdf">NIST</a> - used in the AES competition for evaluating encryption algorithms. <br>  <a href="http://www.stat.fsu.edu/pub/diehard/">DIEHARD</a> is one of the most stringent existing kits. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  GPSL Algorithms </h4><br>  Any sequence generated by a strictly defined algorithm cannot be considered truly random, therefore, when speaking of algorithmic generators, the term <i>pseudo-random</i> sequence is used.  Any pseudo-random number generator (PRNG) sooner or later loops in, another thing is that this ‚Äúlate‚Äù may occur in a few milliseconds, or maybe in a few years.  The cycle length depends on the size of the internal state of the generator N (in fact, it is the amount of memory needed by the generator), and ranges from 2 <sup>(N / 2)</sup> to 2 <sup>N</sup> bits. <br>  The PRNG algorithms are invented a great many, but not all of them are convenient for implementation on microcontrollers.  We are very limited in speed and available memory, many controllers do not support real arithmetic and even multiplication commands.  Bearing in mind these limitations, consider some well-known algorithms. <br><br><h5>  Linear congruential method </h5><br>  The next member of the sequence is calculated by the formula <br>  X <sub>i + 1</sub> = (aX <sub>i</sub> + c) mod m <br>  The number <i>m</i> determines the maximum period of the sequence, the integers <i>a</i> and <i>c</i> are the "magic" coefficients.  The number <i>m is</i> reasonable to choose equal to the power of two, in which case the operation of reduction along the module reduces to discarding the higher bits.  In order to get the maximum period, you must comply with the following conditions: <br>  - <i>c</i> and m must be mutually simple, <br>  - <i>a-1</i> must be a multiple of <i>p</i> for all prime dividers <i>p of the</i> number <i>m</i> , <br>  - if <i>m is a</i> multiple of 4 (and in our case it will be a multiple), then <i>a-1</i> must be a multiple of 4. <br>  There is one more subtlety: as a result, only the high-order bits of the state variable X should be taken, since for the lower bits the statistical parameters of randomness are much worse.  A linear congruential algorithm is usually implemented as a standard rand () in many libraries. <br><br>  <b>Pros:</b> <br><ul><li>  the maximum possible period for a given size of a state variable; </li><li>  fast enough; </li><li>  often already implemented in the compiler library. </li></ul><br>  <b>Minuses:</b> <br><ul><li>  multiplication operation is required; </li><li>  not all bits are equally random. </li></ul><br>  <b>Summary:</b> fast and simple algorithm for not very demanding applications. <br><br><h5>  Fibonacci latency method </h5><br>  This algorithm uses the ratio <br>  X <sub>i</sub> = X <sub>ia</sub> - X <sub>ib</sub> , <br>  where the state variable <i>X</i> is an unsigned integer.  The magnitude of the delays <i>a</i> and <i>b</i> are not taken any, but strictly defined, to achieve the highest quality pairs (17.5), (55,24) or (97,33) are recommended.  The greater the delay, the longer the period and the better the spectral properties of the sequence.  On the other hand, for the operation of the generator, it is required to store max {a, b} of the previous numbers, which is not always acceptable.  Also, to start the generator, you need max {a, b} numbers, which are usually obtained using a simpler PRNG. <br><br>  <b>Pros:</b> <br><ul><li>  does not require multiplication operations; </li><li>  all bits of a random number are equivalent in statistical properties. </li></ul><br>  <b>Minuses:</b> <br><ul><li>  requires a large amount of memory; </li><li>  requires a large array of numbers to run. </li></ul><br>  <b>Summary:</b> very high-quality, but resource-intensive algorithm. <br><br><h5>  Shift register with linear feedback </h5><br><img src="https://habrastorage.org/storage/11f2c2e9/af4e69e8/f4fa695d/682c0ad4.gif"><br>  The state variable is stored in the length register N. Generation of the following state involves two steps: <br><ol><li>  The value of the C = X <sub>i1</sub> xor X <sub>i2</sub> xor ... X <sub>ik</sub> bit is <sub>calculated</sub> , where <i>i1, i2 ... ik</i> are the numbers of the register bits called <i>taps</i> . </li><li>  The register is shifted 1 bit to the right, the leftmost bit is C. </li></ol><br>  The generator output is the rightmost (or leftmost, or any other) bit of the register, that is, the pseudo-random sequence is generated one by one bit per iteration.  With correctly selected numbers of taps, the period of the generator will be 2 <sup>N</sup> - 1. "Minus one", since there is a prohibited zero register state.  The numbers of taps for <i>N</i> from 3 to 168 can be found in <a href="http://www.xilinx.com/support/documentation/application_notes/xapp052.pdf">this document</a> . <br>  In addition to the configuration described above, which, by the way, is called the Fibonacci configuration (not to be confused with the PRNG method of the same name!), There is a so-called  Galois configuration. <br><img src="https://habrastorage.org/storage/3f3930f0/82b7640f/01805ba5/0539c85e.gif"><br>  Instead of using the sum of the bits of the tap sequence to generate a new leftmost bit, XOR each bit of the tap sequence with the rightmost bit, then the entire register is cyclically shifted to the right.  This scheme is more difficult to understand, but easier to implement, since all XOR operations can be performed simultaneously.  For the length of the period and the quality of pseudo-random numbers, the Fibonacci and Galois schemes are equivalent. <br><br>  <b>Pros:</b> <br><ul><li>  very simple implementation, even arithmetic is not required, only bit operations and shifts; </li><li>  very fast algorithm (especially Galois scheme); </li><li>  good statistical properties. </li></ul><br>  <b>Minuses:</b> <br><ul><li>  you need to check the initial value for zero inequality. </li></ul><br>  <b>Summary:</b> very fast and fairly high-quality algorithm. <br><br><h5>  Crypt-resistant algorithms </h5><br>  For use in cryptography to GPSCH, there is one more essential requirement: <i>irreversibility</i> .  All the above algorithms do not have this property: knowing several output PRNG values, you can, having solved a simple system of equations, find the parameters of the algorithm (the very ‚Äúmagic‚Äù constants <i>a, b, s</i> , etc.).  And knowing the parameters, you can reproduce the entire pseudo-random sequence. <br>  As a cryptographically robust PRNG algorithm, you can use any sufficiently strong block cipher.  By choosing a secret key, you can get blocks of pseudo-random numbers by applying the algorithm to consecutive natural numbers.  For an N-bit block cipher, the period will be no more than 2 <sup>N.</sup>  The security of such a scheme depends entirely on the secrecy of the key. <br>  All modern cryptographic algorithms are tested for use as a PRNG, that is, using a certified algorithm, you do not need to specifically take care of the statistical and spectral properties of the output stream.  You only have to worry about the computational ‚Äúgluttony‚Äù of cryptoalgorithms.  If you need to perform a large number of encryption operations, it makes sense to choose a controller with hardware cryptographic blocks.  Often in such controllers there is also a quite good crypto-resistant hardware PRNG. <br><br><h4>  Sources of entropy </h4><br>  As already mentioned, using only deterministic algorithms, it is impossible to generate a truly random number.  Therefore, a PRNG + external <i>entropy source</i> is usually used.  The entropy source is used to set the initial value for the PRNG, and the task of the latter is to ensure the spectral and statistical purity of the sequence.  So what can be used as a source of entropy?  Yes, almost anything. <br><br><h5>  User activity </h5><br>  If the device interacts with the user in any way, it will be a pretty good solution to use the user as the source of entropy.  For example, the time it takes to press a button, measured to the nearest microsecond (or rather, its low-order bits), is completely unpredictable.  However, often the device must work autonomously, which means we lose this wonderful information channel. <br><br><h5>  Analog-to-digital converter </h5><br>  Many controllers have built-in ADCs.  And in many controllers, they are of very mediocre quality, made simply ‚Äúfor it to be‚Äù.  The low-order bits of the ADC result almost always contain significant noise, even if a constant voltage is measured.  This can be used: connect the ADC input to the supply voltage through a divider, take a few dozen measurements, take the low-order bits ‚Äî this is a great random number.  If the ADC contains a built-in preamp, turn it on, it also makes noise. <br><br><h5>  Asynchronous generators </h5><br>  You can use the difference of the periods of two unsynchronized clocks.  Most controllers contain, for example, a watchdog timer.  To increase reliability, it is clocked from a separate generator that is not related to the main clock signal.  It is enough to count the number of clocks of the main clock signal for one period of the watchdog timer.  If you select the periods so that the counter overflows many times during the measurement, you can get a fairly random number.  The disadvantage of this method is that it takes a lot of time, up to several seconds. <br><br><h5>  Real time clock </h5><br>  If the circuit has <i>a real-time clock</i> , you can use their current readings to initialize the PRNG.  For example, converting the current date / time to the <a href="http://en.wikipedia.org/wiki/UNIX-time">Unix time</a> format, we will get 32 ‚Äã‚Äãbits at once, which <i>will never</i> happen again, unless we take readings more often than once per second.  Using real-time gives a unique value, but does not give any unpredictability, so it is better to combine this method with others. <br><br><h5>  RC circuit </h5><br>  If the controller does not have any peripheral devices other than I / O ports, you can proceed as follows: one of the legs is connected to ground via a capacitor, and to the supply voltage through a resistor.  If the controller inputs have internal pull-up resistors, no external resistor is needed. <br><img src="https://habrastorage.org/storage/18c6ba9d/4c3b999c/453bbfb9/ce74f937.gif"><br>  We output the signal "0" to this port - the capacitor discharges.  We switch the port to the input mode - the capacitor starts charging.  When the voltage on it reaches the threshold, the input switches from the state "0" to "1".  Charging time is highly dependent on many factors: power supply voltage, RC circuit parameters drift, threshold instability, temperature, leakage, interference.  Measuring it with sufficient accuracy and taking the lower bits, you can get a good chance. <br><br><h5>  Noise generator </h5><br>  For many serious applications (primarily cryptography is meant), a more reliable source of entropy is required than those listed above.  In such cases, digitizing the signal from a noise generator based on <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BF%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2588%25D1%2583%25D0%25BC">thermal</a> , <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B9_%25D1%2588%25D1%2583%25D0%25BC">shot</a> , or even <a href="http://en.wikipedia.org/wiki/Quantum_noise">quantum</a> effects is used.  A noisy element is usually a special diode or zener diode, the signal from which is amplified and fed to a comparator that forms a binary bit stream. <br><img src="https://habrastorage.org/storage/9064af1e/bbb96bc6/e9f205b4/99a0afd2.gif"><br>  To ensure that the threshold of the comparator does not affect the statistical properties of the received signal, two noise generators are used, which operate on one comparator: <br><img src="https://habrastorage.org/storage/6b09bcd6/f450be35/bf2d3496/fa8bcd9d.gif"><br><br><h4>  Conclusion </h4><br>  Finally, I will tell one story from life.  It began with the next question asked on the forum ‚Äúhow do I generate a random number on the controller?‚Äù.  The author of the question explained what a device that emulates the throwing of a dice is doing as a course project.  After several unsuccessful attempts to understand the algorithms, the topstarter shared his decision: he simply threw a real cube 1000 times and scored all the free memory of the controller with the resulting numbers.  The generator brilliantly passed all tests for ‚Äúrandomness‚Äù, considering that during the demonstration it spent less than a third of its ‚Äústock‚Äù. <br>  Therefore, such a decision also has the right to life, especially if very strict requirements are imposed on the randomness of numbers, but they are not required too often.  Given the rapidly falling prices of memory, it may be reasonable to provide a device with a flash drive with a ‚Äúmargin of chaos‚Äù that will last for the entire lifetime of the device. <br>  Thank you for attention! <br><br>  <b>UPD1:</b> As was rightly noted in the comments, if an attack on the RNG is intended, and the attacker will have hardware access to the device, external sources of entropy need to be used with great caution, since it is not very difficult to replace the signal from an external source.  Internal sources should be used, in addition to external sources. <br>  It is also a good idea to accumulate entropy all the free time, and use it when you need to generate another random number.  Usually in such cases, so-called.  <i>Entropy pool</i> is an array, on which one of the PRNG functions is periodically performed, and where data from entropy sources are constantly mixed. <br><br>  <b>UPD2:</b> In many cases, the contents of the Entropy pool (sorry, I don‚Äôt know the normal Russian translation) are useful to save in the EEPROM so that after switching off and on the device it does not accumulate again.  First of all, it is related to the entropy obtaining by the method of asynchronous generators: under sufficiently stable conditions, after each switch-on, the same sequence can be generated. <br>  If an attack is expected, take action against spoofing the EEPROM contents.  If the controller allows, block reading / erasing / writing using lock bits, when turned on, check the integrity of the EEPROM, at least with the help of the simplest checksums. </div><p>Source: <a href="https://habr.com/ru/post/121849/">https://habr.com/ru/post/121849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../121841/index.html">This software makes hacker life easier, and ours with you is more difficult.</a></li>
<li><a href="../121843/index.html">Debugger Canvas - a new way to debug code in Visual Studio</a></li>
<li><a href="../121845/index.html">The servers of EVE Online, Minecraft and The Escapist magazine were attacked</a></li>
<li><a href="../121846/index.html">Organization of change history in SQL Server and Linq 2 SQL</a></li>
<li><a href="../121847/index.html">Counting the number of bits set in a file</a></li>
<li><a href="../121852/index.html">Check GUNNARS points</a></li>
<li><a href="../121853/index.html">We write web service using gSOAP</a></li>
<li><a href="../121854/index.html">Review of the official VKontakte application for Android</a></li>
<li><a href="../121855/index.html">New search features: voice, image, instant result discovery</a></li>
<li><a href="../121856/index.html">Mikogo 4.0 - a utility for screen sharing, webinars, online conferences and remote access</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>