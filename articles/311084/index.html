<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Taming asynchronous processes in Android with RxJava. Yandex experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone, my name is Alexey Agapitov and today I want to tell you how to 
 using a library like RxJava, you can easily handle many 
 asynchronou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Taming asynchronous processes in Android with RxJava. Yandex experience</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello everyone, my name is Alexey Agapitov and today I want to tell you how to <br>  using a library like RxJava, you can easily handle many <br>  asynchronous processes in your Android application. </p><br><p>  We will look at how to create our own cold and hot sequences, reversing <br>  attention to some nuances when using RxJava, and also consider <br>  how powerful are the tools provided by this library <br>  operators. </p><br><p>  I will talk about everything on the example of the application Yandex. Real estate and its <br>  home screen with a map. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/520/ecd/211/520ecd2115354ba1883234f864238027.png" alt="Screenshot"></div><br><p>  To begin with, we will look at the screen and see what is happening on it and what will we <br>  to be implemented. </p><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">GIF, 13 mb</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/files/921/3d7/be2/9213d7be22794864995ae44609172bd0.gif" alt="Gif"></div></div></div><br><p>  First of all, there is an interaction with the card: a person can move the card <br>  and points will appear on it with ads matching its filters. <br>  Points can be single announcements, new buildings, houses and clusters, <br>  combining many ads.  Note that single ads can be <br>  marked as viewed (this flag is stored locally on the device). </p><br><p>  The filters themselves change on a different screen, but they must be used when requesting <br>  points of interest on the map. </p><br><p>  Another component of the query is the geographical object for which we are looking <br>  ads. </p><br><p><img src="https://habrastorage.org/files/95e/4a8/474/95e4a84745734ff89f7a833579fc73c6.png" alt="Screenshot geoobject"></p><br><p>  This element is necessary to quickly turn on / off the search in this object or in the area that is now open on the map. </p><br><p>  Thus, the points on the map must be updated for each of the listed <br>  actions (map, filter or geoobject change).  For the sake of brevity, we will not <br>  consider the possibility of drawing objects on the map, we believe that such objects <br>  are a special case of a geoobject. </p><br><p>  In addition, we have two processes occurring in other threads: getting points from the web API and checking which of these points have already been viewed on this device (for this we refer to the database). </p><br><p>  Given that the map, filters and geoobject change faster and more often than answers with points from the server arrive, it is necessary to use only the most recent results and discard previous ones. </p><br><p>  Thus, we need to implement a screen containing a considerable amount of <br>  asynchronous processes dependent on each other. </p><br><h2>  Comparing RxJava with the traditional Android approach </h2><br><p>  In the traditional approach to Android, to monitor each of the considered <br>  processes we would use callbacks.  When a change event occurs <br>  constituent elements on the map (for example, they moved the map), we read the rest <br>  components and we connect them in one request which we execute. </p><br><p>  When implementing this approach, there are some difficulties. </p><br><ol><li>  Callbacks do not combine well with each other: <br><ol><li>  harder to read the code - harder to understand the connections of callbacks with each other, to determine <br>  who depends on whom, callbacks are separated by code and it‚Äôs harder to navigate; </li><li>  code flexibility is lost - there is less opportunity for it <br>  reuse, it is more difficult to make changes to existing solutions. </li></ol></li><li>  You must explicitly store the additional state associated with the executable. <br>  asynchronous operation and its callback.  The more such state variables, <br>  the more likely to make a mistake (for example, when working with multiple threads). </li></ol><br><p>  We chose the RxJava library for the following reasons: </p><br><ol><li>  The presence of a universal abstraction over asynchronous processes of any nature <br>  (event model, multi-threaded processing) called Observable - <br>  observed sequence; </li><li>  The ability to change the sequence through the use of operators and <br>  a large number of useful operators; </li><li>  Ability to combine sequences with each other; </li><li>  Reducing the number of state variables by using <br>  sequences and operators; </li><li>  Stability and quality of the library implementation; </li></ol><br><p>  We use this library in the application for a variety of purposes - starting with <br>  background loading and data processing and ending with processing multiple <br>  events occurring in the user interface. </p><br><h2>  Implementation </h2><br><p>  Let's look at examples of how the library is used in our application. </p><br><h3>  Watching map changes </h3><br><p>  First, take a look at the change in the state of the map.  To do this, we use the following sequence, which reports that the coordinate borders of the map have changed: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;BoundingBox&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeMapBoundingBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MapController mapController)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable.OnSubscribe&lt;BoundingBox&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BoundingBox&gt; subscriber)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> OnMapListener listener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnMapListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMapActionEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MapEvent mapEvent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (mapEvent.getMsg()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MapEvent.MSG_SCALE_END: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MapEvent.MSG_SCROLL_END: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MapEvent.MSG_ZOOM_END: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subscriber.isUnsubscribed()) { subscriber.onNext(getViewportBoundingBox(mapController)); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }; mapController.addMapListener(listener); <span class="hljs-comment"><span class="hljs-comment">//    -    subscriber.add(Subscriptions.create(() -&gt; { mapController.removeMapListener(listener); })); } }); }</span></span></code> </pre> <br><p>  In this implementation, two main parts: </p><br><ol><li>  creating and adding a map event listener </li><li>  deleting a given listener when unsubscribed from the sequence. </li></ol><br><p>  Notice that we create and register a listener inside OnSubscribe, that is, when the sequence has become active (someone has subscribed to it). </p><br><p>  Here we are dealing with a classic example of a cold sequence - one that releases new elements while it is signed.  An excellent example of the implementation of such sequences is the <a href="https://github.com/JakeWharton/RxBinding">RxBinding</a> library, which allows you to monitor the events in widgets present in the standard API, as well as the support library. </p><br><h3>  Watching filters change </h3><br><p>  Now consider the second component of the request for points - filters.  Suppose we have a class that stores current filters and provides methods for updating them.  And we want to observe the change in the value of this field.  We can go the same way as in the case of the map, adding a field with an observer of changes to this field and notifying the observer when the field has changed.  But, the field may have a lot of observers, which means that either it is necessary to store their array, or use the operators <a href="http://reactivex.io/documentation/operators/refcount.html">share</a> , <a href="http://reactivex.io/documentation/operators/publish.html">publish</a> + <a href="http://reactivex.io/RxJava/javadoc/rx/observables/ConnectableObservable.html">autoConnect</a> when creating the sequence <br>  in order to send the event to multiple sequence watchers.  However, I want to make it transparent for the consumer, and here we will be helped by a class from the RxJava library, such as Subject, to which we will pass all the listed <br>  duties. </p><br><p>  Subject is a sequence that can simultaneously have multiple subscribers who receive all the data and notifications about its completion or error.  At the same time, work with Subject occurs using the same methods that its subscribers possess: <code>onNext</code> , <code>onCompleted</code> , <code>onError</code> .  That is, Subject itself is a subscriber, and therefore, if necessary, he can subscribe to another sequence and relay it to all his subscribers. </p><br><p>  Let's look at an example of what this gives us: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FilterHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PublishSubject&lt;Filter&gt; subject = PublishSubject.create(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Filter current; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;Filter&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> emitCurrentValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emitCurrentValue ? subject.startWith(current) : subject; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Filter filter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.current = filter; subject.onNext(filter); } }</code> </pre> <br><p>  As you can see, when setting a new value, we send it to all subscribers.  In this case, we use <a href="http://reactivex.io/documentation/subject.html">PublishSubject</a> , which sends freshly <a href="http://reactivex.io/documentation/subject.html">received</a> data, to all of its subscribers.  In principle, it would be possible to use <a href="http://reactivex.io/documentation/subject.html">ReplaySubject</a> , which is able to store the latest received data and repeat it for those subscribers who have subscribed after receiving this data.  But in this case, we would have to change the implementation of the <code>observeChanges</code> method ‚Äî instead of sending the current value, we would have missed it. </p><br><p>  Similarly, you can extend existing classes and add them <br>  reactive capabilities. </p><br><p>  Subject is an example of a hot sequence, that is, it remains active and will receive / send items, even if nobody has subscribed to it.  The main thing is to remember that a Subject can accept new sequence elements in <code>onNext</code> and send them to its subscribers until it has called <code>onCompleted</code> or <code>onError</code> . </p><br><p>  This is important in those situations when the data / event source is infinite and there are no calls for <code>onCompleted</code> and <code>onError</code> , so calling these methods on a Subject sending this data to its subscribers can lead to unexpected effects. </p><br><p>  Monitoring the third component of the request to the API for points - a geoobject is similar <br>  filters and implemented using Subject. </p><br><p>  Finally, you need to put these three elements together and send them in a network request. </p><br><h3>  API call </h3><br><p>  To access the API, we use the well-known library Retrofit, and all the results of network calls are represented as Observable. </p><br><p>  As a result, the method in the network layer will look like this: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Observable&lt;ClustersData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getClusters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MapBoundingBox box, Filter filter, GeoObject geo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   API }</span></span></code> </pre> <br><h3>  Putting it all together </h3><br><p>  So, we combine all the listed asynchronous processes: </p><br><pre> <code class="java hljs">Observable.combineLatest( observeMapBoundingBox(mapController).debounce(<span class="hljs-number"><span class="hljs-number">300L</span></span>, TimeUnit.MILLISECONDS, AndroidSchedulers.mainThread()), filterHolder.observeChanges(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), observeGeoObject(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), SearchRequest::clusters<span class="hljs-comment"><span class="hljs-comment">//      ) .switchMap(request -&gt; networkHelper .getClusters(request.boundingBox, request.filter, request.geoObject) .observeOn(AndroidSchedulers.mainThread()) .doOnError(handleErrorAction())//  .onErrorResumeNext(Observable.empty())//  ) .observeOn(Schedulers.computation()) //  ,      .map(this::processViewedClusters) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;ClustersData&gt;() { @Override public void onCompleted() { } @Override public void onError(Throwable e) { //     ,    } @Override public void onNext(ClustersData clustersData) { //    } });</span></span></code> </pre> <br><p>  We use the <a href="http://reactivex.io/documentation/operators/combinelatest.html">combineLatest</a> operator to follow the changes in each of the three values, and when one of them changes, we create an object describing <br>  network request. </p><br><p>  This operator works as follows: it waits until each of the sequences passed to it provides one element and calls a function that converts all these elements into some other object.  Then, each time a new element appears in any of the sequences, the operator again calls this function passing it the new value and the last values ‚Äã‚Äãof the others. </p><br><p><img src="https://habrastorage.org/files/071/748/573/071748573074439aafef271b763d9700.png" alt="CombineLatest operator"></p><br><p>  Thus, it is very similar to <a href="http://reactivex.io/documentation/operators/zip.html">zip</a> , with the only difference being that it uses the last known values ‚Äã‚Äãof the elements, unless the sequences provide new ones.  This is convenient when you combine sequences that produce elements with different frequencies, for example, a change in the state of the map, which happens more often than filters. </p><br><p>  After the network request object is built, we go directly to the request.  To do this, we refer to the object responsible for interacting with the API, and pass the parameters we collected to it.  There are two interesting points here. </p><br><p>  But first, consider the <a href="http://reactivex.io/documentation/operators/flatmap.html">flatMap</a> operator, which for each element of the original sequence returns a new sequence, and then merges them all into one resultant sequence. </p><br><p><img src="https://habrastorage.org/files/d57/0ee/aa9/d570eeaa943f4af689e8790c5d32326c.png" alt="Flatmap operator"></p><br><p>  The <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html">switchMap</a> operator works the same way, with the only difference being that it unsubscribes from the sequence received from the previous element, switches to a new one and waits for results from it. </p><br><p><img src="https://habrastorage.org/files/f11/8c9/38e/f118c938ec1d4c7fabce75c12b3c39c5.png" alt="SwitchMap operator"></p><br><p>  This is necessary because network requests are slow, so if, for example, a person has moved the map, the previous request loses its relevance and we must request new points. </p><br><p>  The second point is to suppress network errors with the help of the <code>doOnError</code> and <code>onErrorResumeNext</code> (with which we return an empty sequence). <br>  This is done so that the sequence <em>map / filters / geo-object -&gt; network request -&gt; points on the map</em> does not break if one of the requests ends with a (network) error - in fact, in this case the new map changes will not give any result, and network errors may well occur, and we need to handle them. </p><br><p>  The next step after receiving points on the map is to identify those that the user has already viewed.  For this, a database query is made, after which all scanned points are flagged.  Since this is a long operation, we release the network scheduler and switch calculations to computation: <code>observeOn(Schedulers.computation())</code> .  To query the database, we use <a href="https://bitbucket.org/littlerobots/cupboard">Cupboard</a> and our Rx wrappers on top of it, but in this case we managed the usual synchronous method, although you could use the method that returns <code>Observable</code> . </p><br><p>  You, probably, have already noticed that the <a href="http://reactivex.io/documentation/operators/debounce.html">debounce</a> operator appeared in the sequence of monitoring the change in the position of the card, which allows you to drop extra elements if they all came at a specified time interval.  This is necessary in order not to make too often requests to the server while the user is viewing the map.  By default, this operator uses the computation-scheduler, but since we know that our events occur in the main thread, we can override it with the scheduler for the main flow.  This avoids unnecessary switching of streams at a given place, and also saves the computation-scheduler from unnecessary tasks (since the number of threads in it is by default limited by the number of cores). </p><br><p>  And now let's summarize. </p><br><h4>  A small amount of code. </h4><br><p>  All the logic fit into one sequence, in which the movement of data and the logic of their processing are understood. </p><br><p>  Subjectively, such code seems simpler than if we used callbacks.  But here we must make a reservation that this requires at least a knowledge of the basics of RxJava. </p><br><h4>  More simple implementation </h4><br><p>  All the work on synchronization and storage of the intermediate state of asynchronous operations was passed on to the library.  As a result, we keep a minimum of the intermediate state.  This reduces the likelihood of errors when working with multiple threads and asynchronous processes. </p><br><p>  In addition, instead of implementing the processing of a set of asynchronous processes, we operate on data streams and implement our business tasks directly.  At the same time, it is easy to add new processing steps to our sequence and change existing ones. </p><br><p>  I also want to mention that the code with sequences is easier to test, because <br>  the sequence can be replaced with the one needed for testing (in the case of callbacks this will be more difficult). </p><br><p>  For example, you can replace all sequences associated with an interface with <br>  predefined values ‚Äã‚Äãusing the <a href="http://reactivex.io/documentation/operators/just.html">just</a> operator. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/311084/">https://habr.com/ru/post/311084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311066/index.html">We make our first browser 2d game with physics</a></li>
<li><a href="../311068/index.html">Springboard Calling Magic Functions in PHP 7</a></li>
<li><a href="../311070/index.html">Partner Workshop "1C" - Open Sunday - the full program is available.</a></li>
<li><a href="../311076/index.html">Internet of things security: progress, hype and headache</a></li>
<li><a href="../311078/index.html">Development in InterSystems Cach√© in your favorite IDE</a></li>
<li><a href="../311086/index.html">NanoFL: Brief Feature Description</a></li>
<li><a href="../311088/index.html">Creating a blog engine with Phoenix and Elixir / Part 1. Introduction</a></li>
<li><a href="../311090/index.html">MapReduce in Qt Concurrent</a></li>
<li><a href="../311092/index.html">‚ÄúTrue, true truth and statistics‚Äù or ‚Äú15 probability distributions for all occasions‚Äù</a></li>
<li><a href="../311094/index.html">Yield: what, where and why</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>