<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Swift for data scientist: quick dive in 2 hours</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Google announced that TensorFlow is moving to Swift . So put all your business aside, throw away Python and learn Swift urgently. And the language, I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Swift for data scientist: quick dive in 2 hours</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/v4/ws/hf/v4wshfglz2sovj1gajc7ppesx20.png"></p><br><p>  Google announced that <a href="https://medium.com/tensorflow/introducing-swift-for-tensorflow-b75722c58df0">TensorFlow is moving to Swift</a> .  So put all your business aside, throw away Python and learn Swift urgently.  And the language, I must say, is rather strange in places. </p><br><a name="habracut"></a><br><p>  For starters, watch a small presentation explaining why Swift and how TensorFlow is associated with it: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Yze693W4MaU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  The developers of TensorFlow, of course, do not forget about Python yet, but Swift will be the basis of the framework.  Although it will be possible to write <a href="">python-like code in it</a> .  But it will still be executed by the Python interpreter, and this again means slowly, non-parallelly, inefficiently from memory, without type control and everything else. </p><br><p>  Therefore, we learn Swift from scratch.  Well, not quite from scratch: it is assumed that you already program well in Python, and therefore many Swift constructions will be described further in comparison with similar Python constructions. <br>  The article in no way claims a detailed description of the language.  This is only the first very superficial acquaintance with the basic features of the language for those who know Python. </p><br><h1 id="obschie-slova">  Common words </h1><br><p>  Swift is a pretty new language.  This is good because it is based on a vast base of earlier languages.  But at the same time, it is very bad, because it is not yet devoid of completely ‚Äúchildhood diseases‚Äù.  Therefore, language evolves very quickly. <br>  Despite the fact that the Internet is full of articles and tutorials on Swift - all of them are already outdated.  Numerous recipes with StackOverflow probably will not work for you either, because they belong to previous versions of the language. </p><br><p>  The chronology of the latest events: in March 2016, Swift 2.2 was released, and in September - already ‚Äústrongly different‚Äù Swift 3, after a year - ‚Äúagain another‚Äù Swift 4. Current version 4.1, although Swift for Tensorflow is already 4.2-dev.  Until the end of the year, Swift 5 will be released, in which there will be <a href="https://github.com/apple/swift-evolution/blob/master/proposals">even more innovations</a> even in the language itself, not to mention libraries. </p><br><p>  In general, TLDR: the language is not yet ready for serious development for data science.  Therefore, I allowed myself to spend only two hours to get acquainted with the language in its current form, so that in six months it would be easier to dive into Swift 5 with the already new version of TensorFlow. </p><br><h1 id="peremennye-i-konstanty">  Variables and constants </h1><br><p>  All variables are strongly typed, so when declaring it is necessary to specify the data type.  Fortunately, the compiler is able to determine the type of the initial value. </p><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intConst = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> strConst = <span class="hljs-string"><span class="hljs-string">"strings should be in double quotes"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nonInitVar: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-comment"><span class="hljs-comment">//         var intVar = 10 var floatVar = 10.0 var doubleVar: Double = 10.5 var strVar = "double quotes only"</span></span></code> </pre> <br><p>  As you may have guessed, constants are declared using <code>let</code> , and variables through <code>var</code> .  As a good form and to optimize the calculations for all values ‚Äã‚Äãthat will not change during the execution of the program, it is recommended to <code>let</code> .  Otherwise, everything is simple and clear. </p><br><h1 id="diapazon">  Range </h1><br><p>  In Python, there is a <code>slice</code> , and in Swift, there is a whole bunch of <code>Range</code> types: open, closed, incomplete from below, etc. <br>  They are set quite literally in literals (but it could have been even shorter): </p><br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">5</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/  1  5  1..&lt;5 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   5 ...5 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    5 2‚Ä¶ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  2  </span></span></code> </pre> <br><p>  You can use the <code>stride</code> function to specify ranges with a step other than one, or with non-integer numbers: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> i </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stride</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to: </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">by</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1</span></span></span></span></span><span class="hljs-function">)</span></span> { print(i) }</code> </pre> <br><p>  or </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> i </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stride</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, through: </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">by</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1</span></span></span></span></span><span class="hljs-function">)</span></span> { print(i) }</code> </pre> <br><p>  It is impossible to guess, you just need to know that in the first case (with <code>to</code> ) the range is open on the right (ie, 0.5 does not turn on). </p><br><h1 id="stroki">  Strings </h1><br><p>  Each language has its own monstrous stupidity.  Swift's developers decided that they would have lines.  First, there are two string types, String and Substring.  They are very similar, but differ only in that the Substring does not have its own memory region, and it always points to some String for a piece of memory.  The idea is clear and correct, but all these nuances could be easily hidden in the implementation of String. </p><br><p>  Further worse.  How to get a substring from a string?  You think there is something like in Python - <code>str[1:10]</code> .  Nothing like this!  Cannot index strings with integers.  So how should it be? </p><br><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">str</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">str</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">str</span></span>.startIndex, offsetBy: <span class="hljs-number"><span class="hljs-number">1</span></span>) ..&lt; <span class="hljs-keyword"><span class="hljs-keyword">str</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">str</span></span>.startIndex, offsetBy: <span class="hljs-number"><span class="hljs-number">10</span></span>)]</code> </pre> <br><p>  I am not kidding.  This is the official way to work with strings.  Every stupid idea has a long and meaningless explanation.  This case is <a href="">no exception</a> . </p><br><p>  Notice again the string <code>str[str.index(str.startIndex, offsetBy: 1) ..&lt; str.index(str.startIndex, offsetBy: 10)]</code> .  Everything is invariant in it, except for two integers.  In other words, 84 of 87 characters are superfluous! </p><br><p>  To make it human, we write an extension for a standard type String: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Character</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[index(startIndex, offsetBy: i)] } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>(r: <span class="hljs-type"><span class="hljs-type">Range</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Substring</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-type"><span class="hljs-type">Array</span></span>(r) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> start = index(startIndex, offsetBy: a[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = index(startIndex, offsetBy: a[-<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s[start...end] } }</code> </pre> <br><p>  Starting ... does not work!  The compiler swears: </p><br><pre> <code class="hljs vhdl"><span class="hljs-literal"><span class="hljs-literal">error</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'subscript</span></span>' <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> unavailable: cannot subscript <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> an <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span>, see the documentation comment <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> discussion</code> </pre> <br><p>  The fact is that <a href="">in Swift there is an explicit hardcode</a> that prohibits the creation of a <code>subscript</code> method that accepts a range of integers. </p><br><p>  Okay, let's go the other way, 10 times longer, apparently this is the Swift-way: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Character</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[index(startIndex, offsetBy: i)] } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>(bounds: <span class="hljs-type"><span class="hljs-type">Range</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Substring</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> start = index(startIndex, offsetBy: bounds.lowerBound) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = index(startIndex, offsetBy: bounds.upperBound) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[start ..&lt; end] } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>(bounds: <span class="hljs-type"><span class="hljs-type">ClosedRange</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Substring</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> start = index(startIndex, offsetBy: bounds.lowerBound) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = index(startIndex, offsetBy: bounds.upperBound) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[start ... end] } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>(bounds: <span class="hljs-type"><span class="hljs-type">PartialRangeFrom</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Substring</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> start = index(startIndex, offsetBy: bounds.lowerBound) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = index(endIndex, offsetBy: -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[start ... end] } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>(bounds: <span class="hljs-type"><span class="hljs-type">PartialRangeThrough</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Substring</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = index(startIndex, offsetBy: bounds.upperBound) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[startIndex ... end] } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">subscript</span></span>(bounds: <span class="hljs-type"><span class="hljs-type">PartialRangeUpTo</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Substring</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> end = index(startIndex, offsetBy: bounds.upperBound) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[startIndex ..&lt; end] } }</code> </pre> <br><p>  And as an exercise, copy all of this text again for the <code>Substring</code> type.  Language is not for brevity, it is already clear. </p><br><p>  But now you can work normally with strings: </p><br><pre> <code class="hljs markdown">var str = "Some long string" let char = str[<span class="hljs-string"><span class="hljs-string">4</span></span>] var substr = str[<span class="hljs-string"><span class="hljs-string">3 ‚Ä¶&lt; 8</span></span>] let endSubstr = str[<span class="hljs-string"><span class="hljs-string">4‚Ä¶</span></span>] var startSubstr = str[<span class="hljs-string"><span class="hljs-string">...5</span></span>] let subSubStr = str[<span class="hljs-string"><span class="hljs-string">...8</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2..</span></span>][<span class="hljs-string"><span class="hljs-string">1..&lt;4</span></span>]</code> </pre> <br><h1 id="tuple">  Tuple </h1><br><p>  The immutable sequence of values, or <code>tuple</code> , is a little different in Swift than in Python.  Here, it‚Äôs more like a mix of <code>tuple</code> and <code>namedtuple</code> . </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> tuple = (100, <span class="hljs-string"><span class="hljs-string">"value"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(tuple.0) // 100 <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(tuple.1) // <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(tuple.2) // <span class="hljs-literal"><span class="hljs-literal">true</span></span> var person = (name: <span class="hljs-string"><span class="hljs-string">"John"</span></span>, age: 24) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(person.name, person.age) //     <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> tuple2 = (10, name: <span class="hljs-string"><span class="hljs-string">"john"</span></span>, age: 32, 115) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(tuple2.1) // john <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(tuple2.name) // john</code> </pre> <br><p>  But you cannot unpack the <code>tuple</code> in the function arguments.  It used to be possible.  <a href="">Then banned</a> .  Perhaps in the future they will introduce back. </p><br><h1 id="kollekcii-massivy-mnozhestva-i-slovari">  Collections: Arrays, Sets, and Dictionaries </h1><br><p>  The array ( <code>Array</code> ) is similar to the python <code>list</code> so that its size can be changed, but all the elements of the array must have the same data type.  With <code>Set</code> the same story: as in the Python set, you can change the composition of elements, but not the type.  In the dictionary, you will have to define two types: for keys and for elements. </p><br><pre> <code class="hljs markdown">let immutableArray = [<span class="hljs-string"><span class="hljs-string">5, 10, 15</span></span>] var intArr = [<span class="hljs-string"><span class="hljs-string">10, 20, 30</span></span>] var nonInitIntArr: [<span class="hljs-string"><span class="hljs-string">Int</span></span>] var emptyArr: [<span class="hljs-string"><span class="hljs-string">Int</span></span>] = [<span class="hljs-string"></span><span class="hljs-string"></span>] var otherEmptyArr = [<span class="hljs-string"><span class="hljs-string">Int</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) var names: [String] = ["John", "Anna"] var noninitSet: Set<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">String</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> var emptySet: Set<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> = [] var otherEmptySet = Set<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>() var emptyDict: Dictionary<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Int,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">String</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> = [] var strToArrDict: Dictionary<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">String,</span></span></span></span><span class="xml"><span class="hljs-tag"> [</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Int</span></span></span></span><span class="xml"><span class="hljs-tag">]&gt;</span></span></span></span> var fullDict: Dictionary<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">String,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> = ["john": 24, "anna": 22] let allKeys = fullDict.keys let allVals = fullDict.values</code> </pre> <br><p>  By the way, if you try to iterate through the dictionary in the most expected way: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fullDict.keys { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(k, fullDict[k]) }</code> </pre> <br><p>  then suddenly get a bunch of warnings from the compiler, because the type of values ‚Äã‚Äãin the <code>fullDict</code> dictionary is not actually <code>Int</code> , but <code>Optional&lt;Int&gt;</code> (that is, it can be <code>nil</code> or <code>int</code> ).  Let's talk about <code>Optional</code> separately, and it is more convenient to iterate with tuples: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (key, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fullDict { print(key, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) }</code> </pre> <br><h1 id="cikly">  Cycles </h1><br><p>  Standard collection bypass: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> collection { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  It is convenient to work with ranges: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span>.<span class="hljs-number"><span class="hljs-number">.10</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  If indices are needed selectively, the construction is dramatically lengthened: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> i </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stride</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to: </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">by</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  There is also </p><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> someBool { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... } repeat { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> otherBool</code> </pre> <br><h1 id="funkcii">  Functions </h1><br><p>  Everything as expected: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg1: Int, arg2: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-comment"><span class="hljs-comment">// do this // do that return someInt }</span></span></code> </pre> <br><p>  The apparent difference from Python can be seen in the fact that the argument can have not only the name and type, but also a label: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     } //        fn1(a: 1, b: 10) func fn2(from a: Int, to b: Int){ // ... } //        fn2(from: 1, to: 10) fn2(a: 1, b: 10) //     func fn3(_ a: Int, to b: Int){ // _ -      } //      fn3(1, to: 10)</span></span></code> </pre> <br><p>  There are lambdas, here they are called <code>closure</code> </p><br><pre> <code class="hljs rust">{ (arg1: Int, arg2: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; Bool <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... return someBool })</span></span></code> </pre> <br><p>  Naturally, closure can be passed to functions.  And here a new suddenness opens: </p><br><pre> <code class="hljs coffeescript">someFunc() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> that <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> someInt }</code> </pre> <br><p>  It looks like the definition of a function, but without the word <code>func</code> .  But in reality it is a call to the function <code>someFunc</code> , to which the last argument is passed to the <code>closure</code> specified in curly brackets.  By the way, if <code>closure</code> is the only function argument, then parentheses can be omitted. </p><br><pre> <code class="hljs pgsql">let descArray = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.sorted { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> &gt; <span class="hljs-meta"><span class="hljs-meta">$1</span></span> } let firstValue = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.sorted { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> &gt; <span class="hljs-meta"><span class="hljs-meta">$1</span></span> }.first</code> </pre> <br><h1 id="klassy-i-struktury">  Classes and Structures </h1><br><p>  To create complex data types, classes and structures are provided: </p><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyStructure</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attr1: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(arg1: <span class="hljs-type"><span class="hljs-type">Int</span></span>) { attr1 = arg1 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg1: Int, arg2: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Float</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... return 0.0 //        Float } } class MyClass { public var attr1: Int private var count = 0 init(arg1: Int) { attr1 = arg1 } public func method1(arg1: Int, arg2: String) -&gt; Float { // ‚Ä¶ return 0.0 //        Float } }</span></span></code> </pre> <br><p>  It looks like there is no difference, but it is still there: </p><br><ul><li>  default structures are immutable, so methods that change attribute values ‚Äã‚Äãshould be preceded by the <code>mutating</code> ; </li><li>  structures are always passed by value, and classes by reference; </li><li>  classes can be inherited. </li></ul><br><p>  As you already know by the lines, classes and structures have a convenient <code>subscript</code> method (analogous to the python <code>__getitem__</code> and <code>__setitem__</code> ), which allows indexing the data so that instead of: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = someClass.getItem(itemIndex) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = someClass.getSubsetOfItems(fromIndex: <span class="hljs-number"><span class="hljs-number">0</span></span>, toIndex: <span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre><br><p>  write more compact: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = someClass[itemIndex] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aFewItems = someClass[<span class="hljs-number"><span class="hljs-number">0</span></span>...<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre> <br><p>  It is implemented like this: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myData = [<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> subscript(i: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> myData[i]! } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { myData[i] = newValue } } }</code> </pre> <br><p>  You probably ask: what is <code>newValue</code> for?  And this is another implicit convention - if no arguments are <code>set</code> for <code>set</code> ', then the value is passed through the variable <code>newValue</code> . <br>  So, what does the exclamation mark after <code>myData[i]</code> mean? </p><br><h1 id="optional">  Optional </h1><br><p>  In a strongly typed language, a special way of dealing with missing values ‚Äã‚Äãis needed.  In Swift, there is an Optional for this, which takes the value of the type defined during the declaration of a variable or the value <code>nil</code> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> opt: Optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> short: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> anOpt: Optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oneMore: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = nil</code> </pre> <br><p>  How to work with it? </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> opt == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" "</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" ="</span></span>, opt!) <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  Operator <code>!</code>  designed to force unpacking (eng. ‚Äúforce unwrapping‚Äù) values.  If <code>opt</code> was <code>nil</code> , you will get a runtime crash. </p><br><p>  Another more recommended construction is the <code>if-let</code> block: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> val = short { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"val - ''  short,  Int: "</span></span>, val) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"short  nil"</span></span>) }</code> </pre> <br><p>  There is an operator for expanding an optional with assigning a default value to it <code>??</code>  which is simply called a nil-coalescing operator. </p><br><pre> <code class="hljs swift"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(oneMore ?? <span class="hljs-number"><span class="hljs-number">0.0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,    0.0</span></span></code> </pre> <br><p>  In addition, Swift allows you to conveniently get the value of the attribute, even if it is packed in the depth of a complex structure: </p><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let cityCode = person?.contacts?.phone?.cityCode { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -  print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) }</code> </pre> <br><h1 id="python">  Python </h1><br><p>  Swift for Tensorflow claims to work with Python so that you can write Python-like code: </p><br><pre> <code class="hljs vbscript">import Python <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> np = Python.import(<span class="hljs-string"><span class="hljs-string">"numpy"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = np.arange(<span class="hljs-number"><span class="hljs-number">15</span></span>).reshape(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = np.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>([<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>])</code> </pre> <br><p>  But now it does not work and you can only write like this: </p><br><pre> <code class="hljs vbscript">import Python <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> np = Python.import(<span class="hljs-string"><span class="hljs-string">"numpy"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = np.arange.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: <span class="hljs-number"><span class="hljs-number">15</span></span>).reshape.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = np.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>])</code> </pre> <br><p>  When it will be done in a normal way, it is not yet known, because changes in the language are needed, and the <a href="https://gist.github.com/lattner/a6257f425f55fe39fd6ac7a2354d693d">proposal for a change</a> has not even been submitted, although it is being <a href="https://forums.swift.org/t/pitch-3-introduce-user-defined-dynamically-callable-types/12232">actively discussed</a> (for the third time and so far to no avail). </p><br><p>  In addition, Swift can now only work with Python 2.7 installed in / usr / local / lib / python27 (again, the hardcode).  Not compatible with any virtual environments.  Due to the difference between Python 2 and 3 from the point of view of C-data structures and C-calls, this problem will not be solved in the near future either. </p><br><h1 id="tensorflow">  Tensorflow </h1><br><p>  Finally we got to the main thing, for which everything was started. </p><br><p>  Let's start with the multiplication of matrices: </p><br><pre> <code class="hljs lua">import TensorFlow var tensor = Tensor(<span class="hljs-string"><span class="hljs-string">[[1.0, 2.0], [2.0, 1.0]]</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span>.<span class="hljs-number"><span class="hljs-number">.100000</span></span> { tensor = tensor * tensor - tensor }</code> </pre> <br><p>  It looks more beautiful, shorter and clearer than on Python with <code>tf.while_loop</code> along with creating a session and initializing variables.  That's just so far slower, and at times.  And the GPU, of course, is not supported. </p><br><p>  By the way, for matrix multiplication it is necessary to use not <code>*</code> and not <code>@</code> , but the remarkable  sign.  Try typing it from the keyboard. </p><br><p>  Let's make a neural network already! .. Although we won't do it: there is no documentation, there are no ready-made layers, there are no optimizers - in general, there is nothing yet.  Of course, you can manually multiply the tensors, calculate the gradients and change the weights (see the above <a href="https://www.youtube.com/watch%3Fv%3DYze693W4MaU">video</a> and the <a href="https://github.com/tensorflow/swift-models/blob/master/MNIST/MNIST.swift">only example</a> ).  But we will not do this, of course. </p><br><h1 id="vyvod">  Conclusion </h1><br><p>  The language is interesting, only for real use in data science is not yet ready.  Let's wait. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/354876/">https://habr.com/ru/post/354876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354866/index.html">Dapp features that make life easier</a></li>
<li><a href="../354868/index.html">How much is the habraburger</a></li>
<li><a href="../354870/index.html">The experience of creating a mobile application: it did not work the first time</a></li>
<li><a href="../354872/index.html">Richard Hamming: Chapter 11. Coding Theory - II</a></li>
<li><a href="../354874/index.html">MIT course "Computer Systems Security". Lecture 1: Introduction: Threat Models, Part 1</a></li>
<li><a href="../354878/index.html">Richard Hamming: Chapter 15. Digital Filters - 2</a></li>
<li><a href="../354880/index.html">Is it possible to consciously refuse functional programming?</a></li>
<li><a href="../354882/index.html">LAppS application server for microservice architecture</a></li>
<li><a href="../354884/index.html">The city falls asleep, hackers wake up</a></li>
<li><a href="../354886/index.html">ReactiveValidation: data validation in WPF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>