<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>UHCI, or the very first USB</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear reader! I was asked to write about UHCI - well, I write. 

 Perhaps this article is useful to you if, for example, you do not have suff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>UHCI, or the very first USB</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/89/wk/ye/89wkyeuwi_jbnzlge2bawtlabum.png"><br><br>  Good day, dear reader!  I was asked to write about UHCI - well, I write. <br><br>  Perhaps this article is useful to you if, for example, you do not have sufficient skills in writing drivers and reading the documentation for the hardware.  A simple example: if you want to write your own OS for a mini-PC, so that some kind of Windows or another Linux distribution will not load hardware, and you will use all its power solely for your own purposes. <br><a name="habracut"></a><br><h2>  What is UHCI? </h2><br>  I think that once again not to be sprayed on what and why, just leave a link to my previous article on EHCI.  <a href="https://habr.com/post/426421/">Tyk here</a> <br>  UHCI - Universal Host Controller Interface, works as a PCI device, but, unlike EHCI, it uses ports instead of MMIO (Memory-Mapped-IO). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/nk/bl/--/nkbl--cqrxvs21lcitfothfcw4k.png"><br><br><h2>  Terms to be used further </h2><br><ul><li>  USB Driver (USBD) - USB driver itself </li><li>  HC (Host Controller) - the host controller, or simply our UHCI </li><li>  Host Controller Driver (HCD) - a driver that connects hardware and USBD </li><li>  USB Device - USB device itself </li></ul><br><h2>  Types of data transfer </h2><br>  Isochronous ‚Äî an isosynchronous transfer that has a specified data transfer rate.  It can be used, for example, for USB microphones, etc. <br><br>  Interrupt - Small, spontaneous data transfers from the device.  Interrupt transfer type supports devices that require a predictable service interval, but do not necessarily provide a predictable data flow.  Commonly used for devices such as keyboards and pointing devices that may not produce data for long periods of time, but require a quick response when they have data to send. <br><br>  Control - The type of transmission of information about the device status, state and configuration.  The Control type is used to provide a control channel from Host to USB devices.  Control transfers always consist of a setup phase and zero or more data phases, followed by a state phase.  It is imperative that the transfer of control to the specified endpoint is processed in FIFO mode.  If control is passed to the same endpoint, the rotation can lead to unpredictable behavior. <br><br>  Bulk - the type of data transfer.  Used, for example, in MassStorage devices. <br><br><img src="https://habrastorage.org/webt/j1/d5/4a/j1d54aqfs0iicr_-dfpmkwx8d_e.png"><br><br>  Here is the distribution of 1ms of time - processing of one frame. <br><br><h2>  Time distribution </h2><br>  The host controller supports real-time data delivery, generating a Start Of Frame (SOF) packet every 1 ms.  A SOF packet is generated when the SOF counter in the host controller expires (Figure 3).  The host controller initializes the SOF counter for a 1 ms frame time.  Small changes can be made to this value (and, therefore, the frame time period) by programming the register of changes in the SOF.  This feature allows minor changes to be made during the frame time period, if necessary, to maintain real-time synchronization across the entire USB system. <br><br>  The host controller includes the frame number in each SOF packet.  This frame number uniquely identifies the frame period in real time.  The frame termination condition (EOF) occurs at the end of the time interval of 1 ms, when the host controller starts the next frame time, generating another SOF packet with the corresponding frame number.  During a frame period, data is transmitted in the form of packets of information.  The frame time period is strictly enforced by the host controller, and data packets in the current frame cannot exceed the EOF limits (see Chapter 11 in the USB specification).  The host controller supports synchronization of data transmission between frames in real time, associating the frame number with the execution of a specific entry in the frame list.  The host controller's frame counter generates a frame number (11-bit value) and includes it in each SOF packet.  The counter is programmed through registers and increases each frame period.  The host controller uses the lower 10 bits of the frame number as an index in the list of frames with 1024 frames, which is stored in system memory.  Thus, since the frame counter controls the selection of a record from the frame list, the host controller processes each entry in the list in a given frame period.  The host controller is incremented to the next entry in the frame list for each new frame.  This ensures that isochronous transfers are performed in a specific frame. <br><br>  Figure 3: <br><br><img src="https://habrastorage.org/webt/d8/pj/iw/d8pjiwyjanx3yse7tmmtnyeooqe.png"><br><br><h2>  UHCI structure </h2><br>  It's all exactly the same as with EHCI.  Example of requests to HC: <br><br><img src="https://habrastorage.org/webt/io/1d/sm/io1dsmtielklqhm84nhekufybj4.png"><br><br><h2>  Setup and access to UHCI </h2><br>  And so, as I said earlier, UHCI works through ports, which means that we need to know the base of the UHCI registers from PCI. <br><br><img src="https://habrastorage.org/webt/gz/ql/3f/gzql3fejuar2ko92q8dnok-ehpi.png"><br><br>  At offset 0x20 is 4 bytes - IO Base.  Regarding IO Base, we can use the following registers: <br><br><img src="https://habrastorage.org/webt/jk/a5/od/jka5odl_cbgmqxcdsix8e-1tkl0.png"><br><br><h2>  UHCI registers </h2><br><ul><li>  USBCMD - register to control HC'om.  Bits: <ul><li>  Bit 6 is a flag that the device is configured and initialized successfully. </li><li>  Bit 1 - HC Reset.  Set to reset HC'a. </li><li>  Bit 0 - Run / Stop.  Displays HC status.  1 - works, 0 - no. </li></ul></li><li>  USBSTS - Status Register.  Bits: <ul><li>  Bit 5 - HC Halted.  An error has occurred, or the controller has successfully completed the HC Reset. </li><li>  Bit 4 - Host Controller Process Error.  The bit is set to 1 when a critical error has occurred and the HC cannot continue execution of the queues and TD. </li><li>  Bit 3 - Host System Error.  PCI error. </li><li>  Bit 1 - Error Interrupt.  Indicates that an error occurred and HC generated an interrupt. </li><li>  Bit 0 - Interrupt.  Indicates that the HC generated an interrupt. </li></ul></li><li>  USBINTR - Interrupt Setup Register.  Bits: <ul><li>  Bit 2 - IOC - Interrupt on complete - generates an interrupt upon completion of the transaction. </li></ul></li><li>  FRNUM - The number of the current frame (Take it &amp; 0x3FF for the correct value). </li><li>  FLBASEADD - Frame List Base Address - the address of the frame list. </li><li>  PORTSC - Port status and control - register status and control of the port.  Bits: <ul><li>  Bit 9 - Port Reset - 1- port reset. </li><li>  Bit 8 ‚Äî Indicates that a Low-speed device is connected to the port. </li><li>  Bit 3 ‚Äî Indicates that the port enabled state is changed. </li><li>  Bit 2 - indicates whether the port is enabled </li><li>  Bit 1 ‚Äî Indicates that the device is connected to the port. </li><li>  Bit 0 - indicates that the device is connected to the port. </li></ul></li></ul><br><h2>  Structures </h2><br><h3>  Frame list pointer </h3><br><img src="https://habrastorage.org/webt/oc/y8/a6/ocy8a6is-xd60i9bxmtdjjyqcdy.png"><br><br><h3>  Transfer Descrptor </h3><br><img src="https://habrastorage.org/webt/jz/sh/bl/jzshblpig4inzxxtzkzxlmvsvq8.png"><br><br><h5>  TD CONTROL AND STATUS </h5>  .  Bits: <br><ul><li>  Bits 28-27 - error counter, similar to EHCI. </li><li><ul><li>  Bit 26 - 1 = Low-speed device, 0 = Full-speed device. </li><li>  Bit 25 - 1 = isosynchronous TD </li><li>  Bit 24 - IOC </li><li>  Bits 23-16 - Status: </li><li>  Bit 23 - Indicates that this is an active TD </li><li>  Bit 22 - Stalled </li><li>  Bit 21 - Data Buffer Error </li><li>  Bit 20 - Babble Detected </li><li>  Bit 19 - NAK </li></ul></li><li>  Bits 10-0: the number of bytes transmitted by the host controller. </li></ul><br><h5>  TD Token </h5><br><ul><li>  Bits 31:21 - Max Packet Len, similar to EHCI </li><li>  Bit 19 - Data Toggle, similar to EHCI </li><li>  Bits 18:15 - End point number </li><li>  Bits 18:14 is the device address </li><li>  Bits 7: 0 - PID.  In = 0x69, Out = 0xE1, Setup = 0x2D </li></ul><br><h3>  Queue head </h3><br><img src="https://habrastorage.org/webt/-4/pb/ia/-4pbiakp01iozcmkne4q1tums4i.png"><br><br><h2>  Code </h2><br>  Initialize and configure HC: <br><br><pre><code class="cpp hljs">PciBar bar; PciGetBar(&amp;bar, id, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~bar.flags &amp; PCI_BAR_IO) { <span class="hljs-comment"><span class="hljs-comment">// Only Port I/O supported return; } unsigned int ioAddr = bar.u.port; UhciController *hc = VMAlloc(sizeof(UhciController)); hc-&gt;ioAddr = ioAddr; hc-&gt;frameList = VMAlloc(1024 * sizeof(u32) + 8292); hc-&gt;frameList = ((int)hc-&gt;frameList / 4096) * 4096 + 4096; hc-&gt;qhPool = (UhciQH *)VMAlloc(sizeof(UhciQH) * MAX_QH + 8292); hc-&gt;qhPool = ((int)hc-&gt;qhPool / 4096) * 4096 + 4096; hc-&gt;tdPool = (UhciTD *)VMAlloc(sizeof(UhciTD) * MAX_TD + 8292); hc-&gt;tdPool = ((int)hc-&gt;tdPool / 4096) * 4096 + 4096; memset(hc-&gt;qhPool, 0, sizeof(UhciQH) * MAX_QH); memset(hc-&gt;tdPool, 0, sizeof(UhciTD) * MAX_TD); memset(hc-&gt;frameList, 0, 4 * 1024); // Frame list setup UhciQH *qh = UhciAllocQH(hc); qh-&gt;head = TD_PTR_TERMINATE; qh-&gt;element = TD_PTR_TERMINATE; qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;asyncQH = qh; for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = 2 | (u32)(uintptr_t)qh; IoWrite16(hc-&gt;ioAddr + REG_INTR, 0); IoWrite16(hc-&gt;ioAddr + REG_CMD, IoRead16(hc-&gt;ioAddr + REG_CMD)&amp;(~1)); unsigned short cfg = PciRead16(id, 4); PciWrite16(id, 4, cfg &amp; (~1)); PciWrite16(id, 0x20, (short)-1); unsigned short size = ~(PciRead16(id, 0x20)&amp;(~3)) + 1; PciWrite16(id, 0x20, hc-&gt;ioAddr); PciWrite16(id, 4, cfg | 5); // Disable Legacy Support IoWrite16(hc-&gt;ioAddr + REG_LEGSUP, 0x8f00); // Disable interrupts IoWrite16(hc-&gt;ioAddr + REG_INTR, 0); // Assign frame list IoWrite16(hc-&gt;ioAddr + REG_FRNUM, 0); IoWrite32(hc-&gt;ioAddr + REG_FRBASEADD, (int)hc-&gt;frameList); IoWrite16(hc-&gt;ioAddr + REG_SOFMOD, 0x40); // Clear status IoWrite16(hc-&gt;ioAddr + REG_STS, 0xffff); // Enable controller IoWrite16(hc-&gt;ioAddr + REG_CMD, 0x1); // Probe devices UhciProbe(hc, size);</span></span></code> </pre> <br>  Endpoint Requests and Control Requests: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static void UhciDevControl(UsbDevice *dev, UsbTransfer *t) { UhciController *hc = (UhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; // Determine transfer properties uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint endp = 0; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors UhciTD *td = UhciAllocTD(hc); if (!td) { return; } UhciTD *head = td; UhciTD *prev = 0; // Setup packet uint toggle = 0; uint packetType = TD_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? TD_PACKET_IN : TD_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; while (it &lt; end) { td = UhciAllocTD(hc); if (!td) { return; } toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) { packetSize = maxSize; } UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet td = UhciAllocTD(hc); if (!td) { return; } toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? TD_PACKET_OUT : TD_PACKET_IN; UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, 0, 0); // Initialize queue head UhciQH *qh = UhciAllocQH(hc); UhciInitQH(qh, t, head); // Wait until queue has been processed UhciInsertQH(hc, qh); UhciWaitForQH(hc, qh); } // ------------------------------------------------------------------------------------------------ static void UhciDevIntr(UsbDevice *dev, UsbTransfer *t) { UhciController *hc = (UhciController *)dev-&gt;hc; // Determine transfer properties uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; // Create queue of transfer descriptors UhciTD *td = UhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } UhciTD *head = td; UhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = TD_PACKET_IN; //Here for compiler, on some last expression hadn't worked if (t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80) packetType = TD_PACKET_IN; else packetType = TD_PACKET_OUT; uint packetSize = t-&gt;len; UhciInitTD(td, prev, speed, addr, endp, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head UhciQH *qh = UhciAllocQH(hc); UhciInitQH(qh, t, head); // Schedule queue UhciInsertQH(hc, qh); if(t-&gt;w) UhciWaitForQH(hc, qh); }</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/429422/">https://habr.com/ru/post/429422/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429410/index.html">Port 22 SSH port or not</a></li>
<li><a href="../429414/index.html">Future VR Video - Google's VR180</a></li>
<li><a href="../429416/index.html">Build a chat bot using Azure Bot</a></li>
<li><a href="../429418/index.html">.NET Standard 2.1</a></li>
<li><a href="../429420/index.html">PlayStation Classic uses PCSX ReARMed emulator for work, there are no proprietary solutions.</a></li>
<li><a href="../429424/index.html">In California, there will be a robot from Daimler and Bosch</a></li>
<li><a href="../429426/index.html">QGIS and Tile Export</a></li>
<li><a href="../429430/index.html">Own VPN client on JavaScript. Part 3 - OpenVPN component</a></li>
<li><a href="../429432/index.html">Own VPN client on JavaScript. Part 4 - Configs Component</a></li>
<li><a href="../429434/index.html">Own VPN client on JavaScript. 5 part - Electron component Vpn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>