<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Inheritance of combinatorial parsers on Julia</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Combinatorial (monadic) parsers are quite well known ( wikibooks ). They are a library of small parsers that recognize simple grammar elements, and wa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Inheritance of combinatorial parsers on Julia</h1><div class="post__text post__text-html js-mediator-article">  Combinatorial (monadic) parsers are quite well known ( <a href="http://ru.wikibooks.org/wiki/%25D0%259C%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25B4%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D1%258B_%25D0%25BF%25D0%25B0%25D1%2580%25D1%2581%25D0%25B5%25D1%2580%25D0%25BE%25D0%25B2">wikibooks</a> ).  They are a library of small parsers that recognize simple grammar elements, and ways to combine several parsers into one (combine - from here and the name).  They are monadic because one of the ways of combining, generating a parser of the rest of the text based on the result of parsing the beginning satisfies the conditions imposed on the mathematical object ‚Äúmonad‚Äù.  In Haskell, this allows you to take advantage of the powerful service provided by the language and libraries.  In other languages, the name ‚Äúmonadic‚Äù can be safely ignored - this will not interfere with their implementation and use, including the operation ‚Äúbind‚Äù mentioned above. <br><br>  The most simple combinatorial parsers are implemented in languages ‚Äã‚Äãwith support for closures, but you can also use the classic OOP (an example is described by Rebecca Parsons in Martin Fowler's book "Subject-oriented languages"). <br>  The advantages of combinatorial parsers include ease of use (writing in a programming language is almost the same as the usual grammar description), preprocessor independence (like yacc / bison, happy or <a href="http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual026.html">ocamlyacc</a> ), the ability to implement some elements that do not fit into context-free grammar, right on general purpose programming language. <br><br>  The disadvantages are the difficulty of compiling error messages, the inability to work with left-recursive grammar (leads to looping), as well as the fact that it is very easy to make this parser not efficient in speed and memory.  (One of the reasons is that the compiler cannot optimize in terms of grammar, as it works at the level of a programming language. But there are other subtleties that need attention if efficiency is required.) <br>  As an alternative, you can consider the implementation in the form of macros (for example, <a href="http://caml.inria.fr/pub/docs/tutorial-camlp4/tutorial002.html">OCaml streams parsers</a> ).  In Perl6, grammar support is built into the language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Inheritance </h1>  A percer of a specific language consists of many more specialized parsers that reference each other.  In this regard, parsers resemble the methods of a certain object.  There is a desire to generate parsers for new versions of languages, replacing individual sub-parsers (as is done in the design pattern ‚Äútemplate method‚Äù from OOP).  For experiments with this approach (as well as in the order of learning the next language), I chose the <a href="http:/">Julia</a> language - dynamically-typed with a special approach to inheritance (similar to CLOS from Common Lisp and R). <br>  Unlike conventional combinatorial parsers, the inheritance approach is experimental (although it is supported in some form by the OCaml macro library and Perl6).  While it generates not very readable code.  Source code is available on <a href="">Github</a> . <br><a name="habracut"></a><br><h1>  Implementation </h1><br>  Regular combinatorial parsers are a function that receives a string (or another immutable stream) and returns a container (array) of pairs ‚Äî the result of parsing, the remainder of the unparsed text.  If unsuccessful recognition returns an empty container.  It is important that the input stream can be reused - using file descriptors will require special wrappers. <br><br>  To control inheritance, a parameter has been added to all these functions - the grammar to which the parser refers.  Julia allows for multiple dispatching (the choice of a specific method according to the types of several arguments - as opposed to method overloading in C ++ and Java dispatching occurs dynamically), but I use the type of only the first argument, as in normal OOP. <br><br>  Inheritance tree in Julia can only be built on abstract types, but the leaves can be specific types, instances of which can be created. <br><br><pre><code class="hljs pgsql">abstract Grammar <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Gmin &lt;: Grammar <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> geof(g::Grammar, s) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> length(s) == <span class="hljs-number"><span class="hljs-number">0</span></span> [((),s)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> empty <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  This describes the abstract type Grammar, a concrete borderless entry that is a subtype of Grammar, and a parser that recognizes the end of a line.  If we want to transfer a text representation, other than lines, to the two simplest persers (geof and getTocken, extracting one character from the stream), we can use multiple dispatching and specialize the second argument s - the other parsers will work through them without knowing the flow representation.  'empty' is an array of type [Any]. <br><br>  Julia supports the redefinition of many operators (except those requiring special support in a language such as '&amp;', which may not compute the second argument), and I used this: <br><br><pre> <code class="hljs lisp"> &gt;(<span class="hljs-name"><span class="hljs-name">g</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:Grammar</span></span>, p1, p2) = (<span class="hljs-name"><span class="hljs-name">g</span></span>,s) -&gt; reduce((<span class="hljs-name"><span class="hljs-name">a</span></span>,r) -&gt; let local v local s v,s = r [a, p2(<span class="hljs-name"><span class="hljs-name">g</span></span>,s)] end, empty, p1(<span class="hljs-name"><span class="hljs-name">g</span></span>,s))</code> </pre><br>  The (combinator) '&gt;' method concatenates two parsers (if the first is applied successfully, the second is applied to the remainder of the string), and the result of the first parser is ignored, and the result of the combination is the result of the second.  Similarly defined methods are '&lt;', '-' (concatenation of several parsers, the results of all are combined into an array), '|'  (alternative - recognizes a string recognized by any of the parsers).  There is also a '+' combinator - a limited alternative that ignores parsers after the first successfully applied.  It does not allow organizing a return to an earlier partner if an error occurred later.  This is important for efficiency, especially in lazy languages, such as Haskell, where the possibility of such a return leads to the accumulation in memory of a large number of uncalculated values, but it is also useful in energetic ones. <br><br>  Check how it works: <br><br><pre> <code class="hljs pgsql">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>("Parsers.jl") julia&gt; g = Gmin() Gmin() julia&gt; (-(g,getTocken, getTocken, getTocken))(g,"12345") <span class="hljs-number"><span class="hljs-number">1</span></span>-element <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: (<span class="hljs-type"><span class="hljs-type">Char</span></span>[<span class="hljs-string"><span class="hljs-string">'1'</span></span>,<span class="hljs-string"><span class="hljs-string">'2'</span></span>,<span class="hljs-string"><span class="hljs-string">'3'</span></span>],"45") julia&gt; (|(g,getTocken, getTocken, getTocken))(g,"12345") <span class="hljs-number"><span class="hljs-number">3</span></span>-element <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{(<span class="hljs-type"><span class="hljs-type">Char</span></span>,ASCIIString),<span class="hljs-number"><span class="hljs-number">1</span></span>}: (<span class="hljs-string"><span class="hljs-string">'1'</span></span>,"2345") (<span class="hljs-string"><span class="hljs-string">'1'</span></span>,"2345") (<span class="hljs-string"><span class="hljs-string">'1'</span></span>,"2345") julia&gt; (+(g,getTocken, getTocken, getTocken))(g,"12345") <span class="hljs-number"><span class="hljs-number">1</span></span>-element <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{(<span class="hljs-type"><span class="hljs-type">Char</span></span>,ASCIIString),<span class="hljs-number"><span class="hljs-number">1</span></span>}: (<span class="hljs-string"><span class="hljs-string">'1'</span></span>,"2345")</code> </pre><br>  There is a slight inconvenience - the need to add a grammar object everywhere (in this case of the Gmin type).  I went for it for the sake of the possibility of inheritance - classical combinatorial parsers are written easier. <br><br>  I will also note the useful functions of 'lift', which allows to ‚Äúraise‚Äù the function in the parser and 'gfilter', which checks the value returned by the parser. <br><br><pre> <code class="hljs coffeescript"> lift(g::Grammar, f, p) = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g,s)</span></span></span><span class="hljs-function"> -&gt;</span></span> map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r)</span></span></span><span class="hljs-function"> -&gt;</span></span> (f(r[<span class="hljs-number"><span class="hljs-number">1</span></span>]),r[<span class="hljs-number"><span class="hljs-number">2</span></span>]), p(g,s)) julia&gt; lift(g,int,getTocken)(g,<span class="hljs-string"><span class="hljs-string">"12"</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>-element Array{(Int64,ASCIIString),<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">49</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"2"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> julia&gt; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(|(g,gfilter(g,(c) -&gt; c==</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'+'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, getTocken),gfilter(g,(c) -&gt; c==</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'*'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, getTocken)))(g,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"*123"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 1-element Array{</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Char,ASCIIString)</span></span></span><span class="hljs-function">,1}: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'*'</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"123"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br><br>  Parsers can be recursive: <br><br><pre> <code class="hljs pgsql">cut(g::Grammar,n) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n==<span class="hljs-number"><span class="hljs-number">0</span></span>); mreturn(g,[]) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (-(g,getTocken,cut(g,n<span class="hljs-number"><span class="hljs-number">-1</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; cut(g,<span class="hljs-number"><span class="hljs-number">4</span></span>)(g,"12345678") <span class="hljs-number"><span class="hljs-number">1</span></span>-element <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: (<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>[<span class="hljs-string"><span class="hljs-string">'1'</span></span>,<span class="hljs-string"><span class="hljs-string">'2'</span></span>,<span class="hljs-string"><span class="hljs-string">'3'</span></span>,<span class="hljs-string"><span class="hljs-string">'4'</span></span>],"5678")</code> </pre><br><br><h1>  Bit monadic </h1><br><pre> <code class="hljs coffeescript">mreturn(g::Grammar, v) = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g,s)</span></span></span><span class="hljs-function"> -&gt;</span></span> [(v,s)] mbind(g::Grammar, p, fp) = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g,s)</span></span></span><span class="hljs-function"> -&gt;</span></span> reduce(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,v)</span></span></span><span class="hljs-function">-&gt;</span></span>[a,fp(g,v[<span class="hljs-number"><span class="hljs-number">1</span></span>])(g,v[<span class="hljs-number"><span class="hljs-number">2</span></span>])], empty, p(g,s))</code> </pre><br>  In Haskell, these functions are called 'return' (this is a function, not a language operator) and '&gt;&gt; =' (often pronounced as 'bind'). <br>  What do these strange functions do? <br><br>  'mreturn' is nothing - it just completes successfully, without either reading from the incoming line and returning a predetermined value.  This is not only a deep mathematical sense, it often replaces complex logic, which otherwise would have to be applied with the help of 'lift'. <br><br>  'mbind' is more complicated.  It takes two arguments, a parser, and a function that is applied to the result of the first parser, and returns a parser that will be applied as follows: <br><br><pre> <code class="hljs pgsql">julia&gt; mbind(g, lift(g, (c) -&gt; c-<span class="hljs-string"><span class="hljs-string">'0'</span></span>, getTocken), cut)(g,"23456") <span class="hljs-number"><span class="hljs-number">1</span></span>-element <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: (<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>[<span class="hljs-string"><span class="hljs-string">'3'</span></span>,<span class="hljs-string"><span class="hljs-string">'4'</span></span>],"56")</code> </pre><br>  By the way, this technique is convenient to use when parsing binary formats, where it is often found that the length of the record is stored just before the record itself. <br><br><h1>  Arithmetic </h1><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-type"><span class="hljs-type">Arith</span></span> &lt;: <span class="hljs-type"><span class="hljs-type">Grammar</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArithExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Arith</span></span> end</code> </pre> <br>  For the arithmetic parser, the abstract subtype Grammar and its concrete implementation are declared. <br>  It defines the gnumber function (g :: Arith, base), which creates a ‚Äúgreedy‚Äù number parser in a given number system and a 'snumber' parser that parses a number in the decimal number system. <br><br>  ‚ÄúGreed‚Äù is expressed in the fact that if the parser found one digit, it will not stop until it reads everything.  This allows you not to try to apply the following parsers to the under-parsed number, which significantly affects performance. <br><br>  Now we define addition and multiplication. <br><br><pre> <code class="hljs coffeescript">amul(g::Arith,s) = lift(g, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> -&gt;</span></span> x[<span class="hljs-number"><span class="hljs-number">1</span></span>]*x[<span class="hljs-number"><span class="hljs-number">2</span></span>], -(g, snumber, +(g, &gt;(g, gfilter(g, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c)</span></span></span><span class="hljs-function"> -&gt;</span></span> c == <span class="hljs-string"><span class="hljs-string">'*'</span></span>, getTocken), amul), mreturn(g,<span class="hljs-number"><span class="hljs-number">1</span></span>))))(g,s) asum(g::Arith,s) = lift(g, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> -&gt;</span></span> x[<span class="hljs-number"><span class="hljs-number">1</span></span>]+x[<span class="hljs-number"><span class="hljs-number">2</span></span>], -(g, amul, +(g, &gt;(g, gfilter(g, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c)</span></span></span><span class="hljs-function"> -&gt;</span></span> c == <span class="hljs-string"><span class="hljs-string">'+'</span></span>, getTocken), asum), mreturn(g,<span class="hljs-number"><span class="hljs-number">0</span></span>))))(g,s)</code> </pre><br>  Here it is worth paying attention that the rule is used (in BNF) <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">amul</span></span> = snumber (<span class="hljs-string"><span class="hljs-string">'*'</span></span> amul | <span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br>  not simpler <pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">amul</span></span> = snumber <span class="hljs-string"><span class="hljs-string">'*'</span></span> amul | snumber</code> </pre> <br>  The fact is that combinatorial parsers do not have the ability to optimize the grammar, like parser generators, and using the second rule will result in the number being parsed several times. <br><br>  We try how it works: <pre> <code class="hljs pgsql">julia&gt; a=ArithExpr() ArithExpr() julia&gt; asum(a,"12+34*56") <span class="hljs-number"><span class="hljs-number">1</span></span>-element <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: (<span class="hljs-number"><span class="hljs-number">1916</span></span>,"") julia&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>+<span class="hljs-number"><span class="hljs-number">34</span></span>*<span class="hljs-number"><span class="hljs-number">56</span></span> <span class="hljs-number"><span class="hljs-number">1916</span></span></code> </pre><br><br><h1>  And now inheritance! </h1><br>  Some languages ‚Äã‚Äãallow you to specify numbers in an arbitrary number system.  For example, in Erlang, the number system can be specified before the number explicitly with the help of the '#' sign.  Create a new ‚Äúarithmetic‚Äù by redefining the snumber in it, which would write numbers like in Erlang. <br><br>  A new snumber always starts with an old one.  In order to address the redefined parser, we need the function 'cast', which allows you to take the parser from a specific grammar, bypassing inheritance. <pre> <code class="hljs lisp">cast(<span class="hljs-name"><span class="hljs-name">g</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:Grammar</span></span>,p) = (<span class="hljs-name"><span class="hljs-name">_</span></span>,s) -&gt; p(<span class="hljs-name"><span class="hljs-name">g</span></span>,s)</code> </pre> <br><br>  The implementation itself uses already familiar techniques: <pre> <code class="hljs coffeescript"> abstract GArith &lt;: Arith type GExpr &lt;: GArith end snumber(g::GArith, s) = mbind(g, cast(ArithExpr(),snumber), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g,v)</span></span></span><span class="hljs-function"> -&gt;</span></span> (+(g, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&gt;(g, gfilter(g, (c) -&gt; c == </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'#'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, getTocken), gnumber(g,v)))</span></span></span><span class="hljs-function">, mreturn</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g,v)</span></span></span><span class="hljs-function">)))</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g,s)</span></span></span></span></code> </pre><br><br>  Check how it works: <pre> <code class="hljs pgsql">julia&gt; c = GExpr() GExpr() julia&gt; asum(a,"12+34*13#12") <span class="hljs-number"><span class="hljs-number">1</span></span>-element <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: (<span class="hljs-number"><span class="hljs-number">454</span></span>,"#12") julia&gt; asum(c,"12+34*13#12") <span class="hljs-number"><span class="hljs-number">1</span></span>-element <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: (<span class="hljs-number"><span class="hljs-number">522</span></span>,"")</code> </pre><br><br><h1>  A little about the language </h1><br>  Julia was clearly created under the influence of the R language, and is trying to correct some of his flaws.  The language was developed with a bias in the direction of performance (which sometimes brings in R) - for this LLVM is involved.  In comparison with R, Julia has a more convenient closure syntax, a more developed type system (in particular, there are tuples / tuples).  But the rejection of curly braces in favor of the 'end' keyword seems to me to make the usual syntax more cumbersome. <br>  Just as in R, indices start at one.  In my opinion, this is an unfortunate decision, reflecting nematematists' fear of zero, but many like it. <br><br>  Of course, so rich and well-organized libraries, as in R, in Julia yet. <br><br>  An important application for Julia is likely to be, as for R, data analysis.  And to extract this data, you will have to read various text formats.  I hope my library will someday be useful for this. </div><p>Source: <a href="https://habr.com/ru/post/241632/">https://habr.com/ru/post/241632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241622/index.html">"Finishing" Asterisk CDR Viewer for yourself</a></li>
<li><a href="../241624/index.html">Moscow region under Probkoskom</a></li>
<li><a href="../241626/index.html">Our electronics: the top 10 developments of the company Promwad</a></li>
<li><a href="../241628/index.html">How much do you need to eat pizza to create a service for students</a></li>
<li><a href="../241630/index.html">Once again about the study and work of an IT person in Germany</a></li>
<li><a href="../241636/index.html">The history of virtualization: The rapid development at the turn of the millennia</a></li>
<li><a href="../241638/index.html">The New York Times and Axel Springer invest in Dutch startup Blendle, designed to eliminate the disadvantages of the content access model by subscription.</a></li>
<li><a href="../241640/index.html">Samsung set a record speed of 7.5 Gbps in 5G networks</a></li>
<li><a href="../241642/index.html">ZeroNights 2014: no taboo topics</a></li>
<li><a href="../241644/index.html">Bitcasa: pay more, get less or go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>