<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Once again about finding the greatest concentration in a cloud of points</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once again, I came across a task - to find the place of their greatest concentration in a cloud of points. This time the situation was this: 


- Ther...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Once again about finding the greatest concentration in a cloud of points</h1><div class="post__text post__text-html js-mediator-article">  Once again, I came across a task - to find the place of their greatest concentration in a cloud of points.  This time the situation was this: <br><ul><li>  There is a certain amount (it can be considered that no more than 16 million) of measurements of a parameter set  The number of parameters in the set is from 2 to 5. </li><li>  measurement of parameters can be relatively successful - then their result will be close to the true (the parameters and type of distribution are unknown), or not successful - then the result will be random (again with unknown distribution parameters).  It is impossible to determine by single measurement whether it was successful. </li><li>  We can assume that the point of condensation exists.  If there are several of them with similar quality (which is not formally defined), any one can be issued. </li><li>  the answer must be given in one pass on the source data: to recalculate them or to save them entirely - expensive. </li><li>  And, as usual, I want the algorithm to look simpler and work faster. </li></ul><br><a name="habracut"></a><br>  For simplicity, we can assume that the measured values ‚Äã‚Äãof the parameters are real numbers from 0 to 1. I would like to get the result with a resolution of 3 decimal places for the case of 5 parameters, and 4 or more - for 4 or less parameters. <br><br>  It is clear that a large number of reference points make the methods based on the processing of pairs of points questionable.  Even an effective search for the distance to the nearest point will require considerable effort to implement. <br><br>  The construction of histograms is also not easy: even the desired cell size is not known in advance.  It is possible, for example, that all measurements will give results in a ball with a diameter of 0.1, and successful ones will be localized in a region of size 0.003.  And it will be necessary to give the position of this area (in the N-dimensional space!) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It would be possible to construct histograms of the distribution of individual parameters, hoping that the condensation of N-dimensional points can be restored according to the positions of the condensations of the projections of points to individual coordinates, but it‚Äôs better to leave this option as a spare: parasitic areas of thickening. <br><br>  The variant that seemed to me the most promising is the use of <a href="http://en.wikipedia.org/wiki/K-d_tree">kd tree</a> .  If we build a binary tree, each node of which corresponds to dividing a region of space into two parts by one of the coordinates (the coordinates are iterated over the cycle - x <sub>1</sub> , x <sub>2</sub> , ..., x <sub>k</sub> , x <sub>1</sub> , x <sub>2</sub> , ...), and find the number of points caught in each of the areas you can do so. <br><br>  Let the points be N. Choose a value of K less than N, for example, K = [sqrt (N)] or K = [N <sup>2/3</sup> ].  Let us find the region of the smallest volume (that is, lying at the greatest depth of the tree) containing at least K points.  If there are several such areas, take the one with the most points.  After that, we will begin to divide it in half (go down the tree further), each time choosing half, in which there are more points.  When we have reached the sheet (for example, a separate point), we give it out as an answer. <br><br>  You can find examples in which this algorithm misses the main condensation area and chooses some local anomaly instead, or as a response gives a point far from the center of condensation, but you can expect that in most cases its answers will be more or less adequate.  Unfortunately, building a kd tree is expensive, and it takes a lot of memory.  I am ready to allocate 8 bytes per point, but it would be undesirable to spend more. <br><br>  To save time and memory, I decided to build a kd tree implicitly. <br><br>  Suppose we have a point (x <sub>1</sub> , x <sub>2</sub> , ..., x <sub>k</sub> ).  We write its coordinates in binary <br>  x <sub>1</sub> = 0.x <sub>11</sub> x <sub>12</sub> x <sub>13</sub> ... <br>  x <sub>2</sub> = 0.x <sub>21</sub> x <sub>22</sub> x <sub>23</sub> ... <br>  x <sub>3</sub> = 0.x <sub>31</sub> x <sub>32</sub> x <sub>33</sub> ... <br>  ... <br><br>  And let's build a 64-bit integer <br>  P = x <sub>11</sub> x <sub>21</sub> ... x <sub>k1</sub> x <sub>12</sub> ... x <sub>k2</sub> ... <br><br>  This number represents the path through the tree to a depth of 64 levels.  In addition, it allows you to restore the coordinates of the point with the required accuracy. <br><br>  If we sort the codes P for all points in ascending order, we get points in the tree traversal order.  For any two points P <sub>a</sub> and P <sub>b,</sub> it is easy to find the deepest node, the common descendants of which they are: it is enough to find the leading nonzero bit in the number P <sub>a</sub> ^ P <sub>b</sub> .  And all the necessary fragments of the problem on such a representation are solved in several lines: <br><br>  Search for the level at which the smallest point is located containing at least K points: <br><pre><code class="hljs matlab">ulong mask=ulong.MaxValue; K--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=K;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;m_np;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) mask=Math.Min(mask,m_Arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]^m_Arr[iK]);</code> </pre> <br>  Here, m_Arr is an array of codes, m_np is the number of filled elements in it, and mask is a number, the most significant bit of which defines the desired level. <br><br>  Search for a region at the found level containing the maximum number of points (we know that there are at least K): <br><pre> <code class="hljs matlab"> mask=InvMask(mask); int ms=<span class="hljs-number"><span class="hljs-number">0</span></span>,me=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;m_np-K;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++){ ulong a=m_Arr[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]; int h=<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>+K; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(((a^m_Arr[h])&amp;mask)==<span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(h&lt;m_np<span class="hljs-number"><span class="hljs-number">-1</span></span> &amp;&amp; ((a^m_Arr[h+<span class="hljs-number"><span class="hljs-number">1</span></span>])&amp;mask)==<span class="hljs-number"><span class="hljs-number">0</span></span>) h++; K=hi; ms=<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; me=<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=h; } }</code> </pre><br>  Here InvMask (mask) is the calculation of a mask containing 1 in all digits older than the most significant non-zero bit of the mask.  Calculates ms - the beginning of the desired area and me - its end. <br><br>  Search for a heavier descendant: <br><br><pre> <code class="hljs vbscript"> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> h=(ms+<span class="hljs-keyword"><span class="hljs-keyword">me</span></span>)/<span class="hljs-number"><span class="hljs-number">2</span></span>; ulong samp=m_Arr[h]; ulong cb=samp^m_Arr[ms],ce=samp^m_Arr[<span class="hljs-keyword"><span class="hljs-keyword">me</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cb&gt;ce) { ms=h; ce=InvMask(ce); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ms&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ((m_Arr[ms<span class="hljs-number"><span class="hljs-number">-1</span></span>]^samp)&amp;ce)==<span class="hljs-number"><span class="hljs-number">0</span></span>) ms--; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">me</span></span>=h; cb=InvMask(cb); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">me</span></span>&lt;m_np<span class="hljs-number"><span class="hljs-number">-1</span></span> &amp;&amp; ((m_Arr[<span class="hljs-keyword"><span class="hljs-keyword">me</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>]^samp)&amp;cb)==<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">me</span></span>++; }</code> </pre><br><br>  Here the descent is not necessarily one level. <br>  Thus, the task of searching for thickening is solved. <br><br>  The whole program was packed in 100 lines, the source code (in C #) can be found <a href="">here</a> . <br><br>  The real problem has a slightly more complicated wording.  The range of change of parameters is not known in advance, in addition, the measurements in the sample may be more than the planned 16 million, and ‚Äúgood‚Äù measurements may go closer to the end.  But small modifications of the algorithm can cope with these problems.  For example, if a place in the array is over, and the points continue to flow, we can sort and thin out the array of already typed codes - this will not affect the position and quality of the thickening. <br><br>  In conclusion, there are several examples of work (two parameters, 10 ^ 5 and 10 ^ 7 points - for one real and several synthetic examples).  It can be seen that the algorithm still needs to be improved (to clarify the position found), and that for the real case it is too prudent, simpler solutions would suffice.  But I want to be a little safe. <br><br><img src="http://img-fotki.yandex.ru/get/4512/17510987.b1/0_91321_e4b4775d_XL.jpg"><br><br><img src="http://img-fotki.yandex.ru/get/2714/17510987.b1/0_91320_72b180a2_XL.jpg"><br><br><img src="http://img-fotki.yandex.ru/get/5603/17510987.b1/0_9131f_5c683118_XL.jpg"><br><br><img src="http://img-fotki.yandex.ru/get/2714/17510987.b1/0_9131e_19ac9c8f_XL.jpg"><br><br><img src="http://img-fotki.yandex.ru/get/58191/17510987.b1/0_9131d_b798116b_XL.jpg"><br><br><img src="http://img-fotki.yandex.ru/get/5504/17510987.b1/0_9131c_ed961b28_XL.jpg"><br><br><img src="http://img-fotki.yandex.ru/get/5603/17510987.b1/0_9131b_b8752578_XL.jpg"><br><br><img src="http://img-fotki.yandex.ru/get/5504/17510987.b1/0_9131a_a8f8e62_XL.jpg"><br><br><img src="http://img-fotki.yandex.ru/get/4512/17510987.b1/0_91319_8769adc9_XL.jpg"></div><p>Source: <a href="https://habr.com/ru/post/137652/">https://habr.com/ru/post/137652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137641/index.html">Continuous monitoring of the JVM with Zabbix</a></li>
<li><a href="../137643/index.html">Designing synchronous circuits. Quick Start with Verilog HDL</a></li>
<li><a href="../137644/index.html">Why do companies need mobile apps or why there are so much junk in Markets</a></li>
<li><a href="../137647/index.html">‚ÄúGeolans‚Äù - a new phenomenon in the market of services</a></li>
<li><a href="../137650/index.html">Automatic image rotation on the monitor</a></li>
<li><a href="../137655/index.html">Udacity creates curriculum and will issue diplomas</a></li>
<li><a href="../137657/index.html">Anonymous hackers have posted a record of negotiations between the FBI and the British Police‚Äôs cybercrime unit</a></li>
<li><a href="../137661/index.html">Putin proposes to introduce Internet democracy</a></li>
<li><a href="../137662/index.html">Droider Show # 26. Hipster terrorist</a></li>
<li><a href="../137663/index.html">Scartel postpones the introduction of LTE in Moscow for six months (March ‚Üí September)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>