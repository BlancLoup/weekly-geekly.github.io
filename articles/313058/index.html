<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Architecture and programming computer Texas Instruments TI-99 / 4a</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Computer Texas Instruments TI-99 / 4a is almost unknown outside the United States, but it was very popular there (produced more than two million cars)...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Architecture and programming computer Texas Instruments TI-99 / 4a</h1><div class="post__text post__text-html js-mediator-article">  Computer <a href="https://en.wikipedia.org/wiki/Ti-99">Texas Instruments TI-99 / 4a is</a> almost unknown outside the United States, but it was very popular there (produced more than two million cars).  Although this computer was created as a home one, an essential feature (which largely determined its architecture, and then its fate) was that it was based on the already existing serious mini-computer <a href="https://en.wikipedia.org/wiki/TI-990">TI-990</a> , assembled on conventional TTL logic.  In fact, the TMS9900 microprocessor in the TI99 / 4A computer is an implementation of the TI-990, but in the form of a chip.  The TI-990 was released in 1975, and the TMS9900 in 1976. <br><br><img src="https://habrastorage.org/files/a89/457/759/a89457759c394eb991969ca9f12b0922.jpg" align="right" title="TI-99 / 4a with speech synthesizer (right)">  Thus, TI99 / 4a (in 1979 a slightly simpler TI-99/4 was released, and in 1981 already TI-99 / 4a) inherited an extremely strange architecture for home computers.  First, the TMS9900 microprocessor in it is 16-bit - with an honest 16-bit data bus (this is in the late 1970s!).  Secondly, there are no registers on the chip (except for PCs, flags, and the WP ‚Äúregister‚Äù pointer).  What can be called registers is in a separate chip of 16-bit static RAM of 256 bytes in size and can be addressed simultaneously as a memory and (first 16 words) as registers R0..R15.  This is called "scratchpad". <br>  There is no hardware stack; instead, saving values ‚Äã‚Äãwhen calling subprograms is done by changing the WP register start pointer in this same RAM (resembles register windows in Sparcs).  In ancestor (TI-990), this was also used to switch context when implementing multitasking. <br>  Although the clock frequency of the TMS9900 is 3 MHz, the instructions take quite a lot of clock cycles - no less than 8. At the same time, even multiplication and division are implemented (124 cycles). <br><a name="habracut"></a><br> <a href=""><img src="https://habrastorage.org/files/af4/172/da3/af4172da38844895a55f3fae80f80fd7.jpg" align="left" title="TI-990 (left rack)"></a>  Everything, except for the processor, alas, is more ascetic.  In addition to the tiny static RAM mentioned, there is also video memory - 16kb of slow 8-bit DRAM, which is accessed via a video controller. <br><br>  In other words, without additional peripherals, the TI99 / 4A is a 16-bit computer with 256 bytes of RAM, built-in BASIC ROMs and programs on cartridges (up to 8kB of honestly addressable ROM or more, with different tricks). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It‚Äôs impossible to load a normal program into a bare computer even from a cassette.  There is no RAM for this (256 bytes are not counted, and the rest is video memory). <br><br>  Therefore, the minimum adequate configuration of the computer is a PEB (Peripheral Expansion Box) - a special large basket for expansion cards, a drive and a 32kb memory expansion.  Or NanoPEB - modern device, including all of the above. <br><br>  For PEB / NanoPEB, you also need an Editor / Assembler cartridge (without which you can download and run only programs in Basic and which at the same time contains the above-mentioned additional 32kb of RAM). <br><br> <a href=""><img src="https://habrastorage.org/files/eca/cd4/e87/ecacd4e8752a4d6a801522282b032d32.jpg" align="right" title="TMS9900 microprocessor"></a>  The TMS9918 video controller (also used in MSX and ColecoVision) supports graphic (256x192, 15 colors) and text modes, allows changing the character generator, can output simultaneously 32 hardware sprites 8x8 and 16x16 (however, no more than four pieces can be in one line at a time). <br>  The sound is output via the TMS9919 (its analog, SN76489, was used in IBM PCjr, BBC Micro, ColecoVision, some Sega consoles): <br><br>  4 channels (three rectangle generators and one noise), 16 volume levels. <br><br>  It is believed that such an uneven architecture in terms of digit capacity and in some places turned out to be due to the fact that the 8-bit version of the TMS9900 processor (TMS9985) was not ready in time. <br><br>  As for software, TI99 / 4A was intended for educational purposes (in fact, as opposed to Atari and Commodore).  In conjunction with the oddities of the architecture described above, this led to the fact that there are very few good games on it (if any).  The fact that the computer was distributed exclusively in the United States, added to this the absence of the demoscene (my intro 99tro seemed to be the second on this platform). <br><br><h2>  MODERN CONDITION OF AFFAIRS </h2><br>  As already mentioned, with bare TI99 / 4a there is little that can be done, except to start something from the cartridges (if any).  The PEB extension basket required for normal operation is quite expensive and takes up a lot of space.  Since historically it turned out that all serious development and in general any actions with TI were tied to that very PEB, modern fans of the machine followed the path of its emulation (no one seemed to bother with the ROM cartridge emulator). <br><br>  A modern substitute for PEB is <a href="http://webpages.charter.net/nanopeb/">NanoPEB</a> .  With some patience, it can be found on ebay or at individual sellers for 50 ... 80e. <br><br>  This device is plugged into the right computer port (the same as the speech synthesizer. Including you can plug it in through the synthesizer) and emulate 32kb of additional RAM, three drives (on the CompactFlash card) and an RS-232 port. <br><br>  There is also a CF7 + device, in which everything is the same, but instead of RS-232 there is a parallel port of Centronics. <br><br>  In itself, the presence of NanoPEB allows you to download only programs in BASIC (and from the standard TI BASIC it is impossible to start the program in machine codes, except for very dirty and nontrivial hacks). <br><br>  Therefore, an Editor / Assembler (EA) cartridge stuck to the upper port is absolutely necessary.  With it, you can already download and run normal programs.  The cartridge is also searched on ebay.  It seems to be, instead, you can use the cartridge Extended Basic (XB). <br><br>  To transfer programs to a CompactFlash card, you must use special utilities.  The most popular is ti99dir (under Windows). <br><br>  It is worth mentioning the project <a href="http://codehackcreate.com/archives/category/projects/f18a">F18A</a> - the implementation of the video controller TMS9918A on the FPGA, with a number of additions.  Those.  the video chip in the usual TI-99 / 4a is replaced with a new one, with all the old software going as before, but it becomes possible to display the image on a VGA monitor, install previously unavailable video modes, etc. <br><br><h2>  DEVELOPMENT </h2><br>  In addition to the Basic programs, about which we will not speak, there are two main formats in which the program can be represented in machine codes - for loading from disk through the Editor / Assembler and for the cartridge. <br><br>  Files uploaded through EA are called EA3 (because in Editor / Assembler you need to select the third menu item ‚ÄúLOAD AND RUN‚Äù to load them).  They can run in any area of ‚Äã‚Äãmemory (i.e., EA will link when loaded).  For the emulator, such files are stored on a disk image (.DSK) and are in Dis / Fix 80 format. <br><br>  Also, less often, there may be memory image files called EA5 (loaded into EA by selecting the fifth menu item - ‚ÄúRUN PROGRAM FILE‚Äù).  These are already linked files attached to memory addresses.  The emulator is also stored in disk images as ‚ÄúProgram‚Äù. <br><br>  Loading a program from a disk in codes necessarily requires an Editor / Assembler cartridge (or equivalent). <br><br>  The programs for cartridges are tightly bound to addresses and are simply a binary that is stitched into ROM (for emulators, this is the .RPK format, less often - .BIN). <br><br>  There are two significantly different approaches to writing programs in assembly language.  The first is the use of so-called.  GPL language.  This is somewhere between Extended Basic (XB) and Assembler, both in performance and in features.  Those.  for all of the intensively used subroutines existing in the ROM and, importantly, should be included interrupts. <br><br>  The second option - the assembler, which will be discussed. <br><br>  The main unusualness of the TI-99 / 4A, in fact, in the processor TMS9900.  From most processors that were used in home computers of the time, it is distinguished by the following: <br><br>  Physically, there are only three registers in the processor - ST (flags), PC (command pointer) and WP (workspace pointer).  Registers R0-R15 are in static RAM outside the chip.  The address from which they start is stored in the WP register and can be changed.  It is usually set to&gt; 8300 (the sign "&gt;" means a hexadecimal system, the sign ":" - binary). <br><br>  From&gt; 8300 to&gt; 83FF there are 256 bytes of static 16-bit RAM called ‚Äúscratchpad‚Äù. <br><br>  Working with it is about 2 times faster than with the rest of the dynamic 8-bit (standard extension 32kb). <br><br>  There are many addressing modes, and with one command you can, for example, transfer a value from a memory cell to another, changing it at the same time. <br><br>  There is no stack in the processor - it is supposed to use the mapping of registers to any memory area using the LWPI addr command to save and restore the context. <br>  The subprograms are called by the BL <a href="https://habr.com/users/addr/" class="user_link">ADDR</a> command, which writes the following address to the R11 register.  Accordingly, B * R11 (also known as RT) is used for return.  There is also a BLWP that also preserves the workspace in addition to the return address (but it is also slow). <br><br>  Usually, first of all, turn off all interrupts and set the beginning of the registers to the beginning of the static RAM.  Therefore, the preparation of the program looks like this: <br><br><pre><code class="hljs sql">DEF <span class="hljs-keyword"><span class="hljs-keyword">START</span></span> WRKSP EQU &gt;<span class="hljs-number"><span class="hljs-number">8300</span></span> <span class="hljs-keyword"><span class="hljs-keyword">START</span></span> LIMI <span class="hljs-number"><span class="hljs-number">0</span></span> LWPI WRKSP ... * <span class="hljs-keyword"><span class="hljs-keyword">SOME</span></span> CODE HERE <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">START</span></span></code> </pre> <br>  Because of this register architecture, programming features appear.  Namely: <br><br>  1. Registers can be addressed not only as R1, R2, etc., but (since they are in the address space) and as memory cells.  This, in particular, allows you to work separately with the lower and upper bytes of the register, which for this purpose are given in advance by constants: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">ws0</span></span> equ &gt;<span class="hljs-number"><span class="hljs-number">8300</span></span> ; <span class="hljs-attribute"><span class="hljs-attribute">Workspace</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-attribute"><span class="hljs-attribute">Register</span></span> direct low-byte access R0L equ ws0+<span class="hljs-number"><span class="hljs-number">1</span></span> ; <span class="hljs-attribute"><span class="hljs-attribute">Workspace</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> R0 low byte R1L equ ws0+<span class="hljs-number"><span class="hljs-number">3</span></span> ; <span class="hljs-attribute"><span class="hljs-attribute">Workspace</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> R1 low byte R2L equ ws0+<span class="hljs-number"><span class="hljs-number">5</span></span> ; <span class="hljs-attribute"><span class="hljs-attribute">Workspace</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> R2 low byte</code> </pre><br>  However, it is clear that it is far from always in the command that you can simply replace the register with a memory (for this command, the addressing mode you just may not have) <br><br>  On the other hand, it is still necessary, because  there are few commands working with register halves (MOVB, SWPB, AB, SB, some logic). <br><br>  Of course, regardless of the current workspace installed, there is always access to any register in any workspace (at the corresponding address in memory). <br><br>  2. Since there is no stack (sometimes, however, it is simulated programmatically), saving and restoring registers is done by switching the workspace.  If you use it intensively, the available 256 bytes of fast SRAM will end quickly - they are always lacking. <br><br>  To show what the code looks like for the TMS9900, a small example is Hello World: <br><br><pre> <code class="hljs sql"> DEF <span class="hljs-keyword"><span class="hljs-keyword">START</span></span> WRKSP EQU &gt;<span class="hljs-number"><span class="hljs-number">8300</span></span> VDPWD EQU &gt;<span class="hljs-number"><span class="hljs-number">8</span></span>C00 * VDP RAM write <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> VDPWA EQU &gt;<span class="hljs-number"><span class="hljs-number">8</span></span>C02 * VDP RAM <span class="hljs-keyword"><span class="hljs-keyword">read</span></span>/write address <span class="hljs-keyword"><span class="hljs-keyword">START</span></span> LIMI <span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> interrupts LWPI WRKSP * <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> workspace * <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> VDP RAM <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> address (<span class="hljs-keyword"><span class="hljs-keyword">low</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">high</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) LI R0,&gt;<span class="hljs-number"><span class="hljs-number">0000</span></span> ORI R0,&gt;<span class="hljs-number"><span class="hljs-number">4000</span></span> SWPB R0 MOVB R0,@VDPWA SWPB R0 MOVB R0,@VDPWA LI R1,HELLOWORLD * <span class="hljs-keyword"><span class="hljs-keyword">ascii</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> address LI R2,<span class="hljs-number"><span class="hljs-number">12</span></span> * total chars NEXTCHAR MOVB *R1+,@VDPWD * put <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> screen <span class="hljs-built_in"><span class="hljs-built_in">DEC</span></span> R2 JNE NEXTCHAR LOOPBACK JMP LOOPBACK * <span class="hljs-keyword"><span class="hljs-keyword">stop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nothing</span></span> HELLOWORLD <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span> <span class="hljs-string"><span class="hljs-string">'HELLO WORLD!'</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BYTE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">START</span></span></code> </pre><br>  This is a modern (not quite traditional) TMS9900 assembler.  In the original, in addition to the absence of colons after the labels, the registers were not written as R with a number, but as a simple number.  Those.  LI 4.5 and MOV 7.8 in the old assembler are LI R4.5 and MOV R7, R8 in the new one. <br><br>  As it is easy to see, this did not add much readability, so now they write R (although, even modern assemblers understand the old version of the record).  Some people, however, interfere with both syntaxes.  As a result, in the same source code one can find a number of SLA R5.0 mnemonics (shift R5 to the left by the number of bits from the register R0) and SLA R5.1 (shift R5 to the left by _ one _ digit). <br><br>  Some (medical :) interest is the command X, which executes the instruction, the code of which is transmitted to it as a parameter. <br><br><pre> <code class="hljs markdown">;       B <span class="hljs-emphasis"><span class="hljs-emphasis">*R11 LI R9,&gt;045B ;   B *</span></span>R11 X R9 ;        LI R1,&gt;1234 LI R0,&gt;0201 ;   LI R1,xxx X R0 DATA &gt;1234 ;   xxx (&gt;1234)   </code> </pre><br>  It is believed that X can be used for debugging purposes, as well as for navigating through tables.  Well and in any situations where the self-modifying code is necessary. <br><br><h2>  MEMORY CARD </h2><br><blockquote>  <b>&gt; 0000 -----------</b> <br>  Console ROM <br>  <b>&gt; 2000 -----------</b> <br>  Low memory expansion <br>  <b>&gt; 4000 -----------</b> <br>  Peripheral cards ROM <br>  <b>&gt; 6000 -----------</b> <br>  Cartridge ROM / RAM <br>  <b>&gt; 8000 -----------</b> <br>  Scratchpad RAM memory mapped devices <br>  (C&gt; 8300 to&gt; 83FF is static RAM of 256 bytes. <br>  Processor registers are most often displayed starting from&gt; 8300.  C&gt; 8400 to&gt; 9C02 addresses for access to video, sound, synthesizer, GROM) <br>  <b>&gt; A000 -----------</b> <br>  High memory expansion <br>  (standard RAM expansion is 32kb. C&gt; A000 usually starts a typical disk-loading program) <br>  ... <br>  <b>&gt; FFFF</b> </blockquote><br>  As for the ROM, the TI-99 / 4a uses the so-called GROM.  They are not displayed entirely in the address space of the processor, and the data is accessed sequentially ‚Äî the starting address of the data in the GROM is entered at a special address and then the data is read from there at another special address.  At the same time, the current address of the GROM data is increased automatically, with each reading. <br><br>  Printing character strings from GROM <br><br><pre> <code class="hljs perl"> li r<span class="hljs-number"><span class="hljs-number">0</span></span>, &gt;0874 ; starting GROM address of small character set GROMSC movb r<span class="hljs-number"><span class="hljs-number">0</span></span>,@GROMWA ; set GROM <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> pointer to address <span class="hljs-number"><span class="hljs-number">06</span></span>B<span class="hljs-number"><span class="hljs-number">0</span></span> (high part) nop ; <span class="hljs-keyword"><span class="hljs-keyword">wait</span></span> a beat (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sure <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> necessary) movb @WR0LB,@GROMWA ; set GROM <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> pointer to address <span class="hljs-number"><span class="hljs-number">06</span></span>B<span class="hljs-number"><span class="hljs-number">0</span></span> (low part) li r<span class="hljs-number"><span class="hljs-number">0</span></span>,&gt;<span class="hljs-number"><span class="hljs-number">0000</span></span>+(<span class="hljs-number"><span class="hljs-number">8</span></span>*<span class="hljs-number"><span class="hljs-number">32</span></span>*<span class="hljs-number"><span class="hljs-number">8</span></span>) ; VDP Pattern Table start address movb @R0L,@vdpwa ; Send low byte of VDP RAM <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> address ori r<span class="hljs-number"><span class="hljs-number">0</span></span>,&gt;<span class="hljs-number"><span class="hljs-number">4000</span></span> ; Set <span class="hljs-keyword"><span class="hljs-keyword">read</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span> bits <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> to <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> (<span class="hljs-number"><span class="hljs-number">01</span></span>) movb r<span class="hljs-number"><span class="hljs-number">0</span></span>,@vdpwa ; Send high byte of VDP RAM <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> address li r1,GROMRD li r2,<span class="hljs-number"><span class="hljs-number">32</span></span> nextchar: movb *r1,@vdpwd movb *r1,@vdpwd movb *r1,@vdpwd movb *r1,@vdpwd movb *r1,@vdpwd movb *r1,@vdpwd movb *r1,@vdpwd ; movb *r1,@vdpwd clr @vdpwd ; skip one byte dec r2 jne nextchar</code> </pre><br><h2>  GRAPHICS </h2><br>  To display graphics and text, the video chip VDP TMS9918a is installed in the TI-99 / 4a, which is also used in <a href="https://en.wikipedia.org/wiki/MSX">MSX1</a> and <a href="https://en.wikipedia.org/wiki/ColecoVision">ColecoVision</a> . <br>  VDP allows you to display graphics with a resolution of 256x192 in 15 not very good colors (+1 transparent, through which the background shines) and single-color sprites - 32 pieces in one size 8x8 or 16x16 with a significant limitation: no more than 4 sprites on one line. <br><br>  In VDP 16kb DRAM and it is distributed between graphics (text), colors and sprites. <br><br>  Video memory is not displayed in the address space of the processor.  To write to it, you must first write to the specific address the starting address in the video memory, which will be recorded, and then write the necessary values ‚Äã‚Äãin a row to another address (one).  At the same time, each next value will be in video memory at an increasing address by one. <br><br>  Depending on the video mode and memory allocation, you can choose the best one - from the point of view of convenience of addressing, memory used and the number of colors (in a pixel block) mode.  At its core, all modes - text.  In the sense that in all cases there is the concept of ‚Äúcharacters‚Äù (characters) that can be placed in different places on the screen and which can be changed.  But, since it is possible to reprogram characters so that their appearance matches their code, then in fact the mode is already ‚Äúgraphic‚Äù.  However, this is typical of many video controllers of the 1980s.  Even in a relatively modern VGA there was such an opportunity (the author used it to implement a fast 640x400 mode with a separate memory for colors). <br><br>  Most often, TI uses Graphic Mode I (the computer turns on in this mode when it is turned on and initialized).  In it you can set two colors (background and image) on the 8x8 block.  Total blocks 32x24.  The only advantage of this mode is the relatively high color change rate. <br><br>  There is also Multicolor mode - a graphics mode with a resolution of 64x48, where each large pixel is given a color (but at this resolution, except for drawing some kind of plasma or ANSI art) and a pair of purely text modes of 40x24 characters - color and monochrome. <br><br>  The most powerful and interesting mode in VDP is the so-called Graphic Mode II (aka ‚Äúbitmap mode‚Äù).  This mode allows you to use two colors (background and image) inside an 8x1 pixel block.  In other words - 2 colors for every 8 horizontal pixels.  Unfortunately, the order of the blocks (which are pixels, their colors) is extremely inconvenient for everything except the output of characters - bytes go from top to bottom 0-8, then the next to the right again from top to bottom 8-15, etc.  to the right edge.  Then everything repeats again from left to right. <br><br>  When setting the mode, addresses are also set for attributes (Color Table), bitmap (Pattern), order of the characters that form blocks for the Namemap, data for Sprites data and Sprites Attributes.  Addresses can be set not any - there are just several options that should be chosen so that in the end, without any overlaps, all 16384 bytes of video memory are rationally used.  For example, for my intro "99tro" I allocated the memory like this (Graphics Mode II): <br><br><blockquote>  &gt; 0000 -&gt; 1800 Pattern table - 6144 bytes (&gt; 1800) <br>  &gt; 1800 -&gt; 2000 Sprite patterns - 64 sprites x 32 bytes = 2048 bytes (&gt; 800) <br>  &gt; 2000 -&gt; 3800 Color table - 6144 bytes (&gt; 1800) <br>  &gt; 3800 -&gt; 3b00 Name table - 768 bytes (&gt; 300) <br>  &gt; 3b00 -&gt; 3b80 Sprite attrs = 32 sprites x 4 bytes = 128 bytes (&gt; 80) </blockquote><br>  Sprites can be in two sizes - 8x8 or 16x16 (all sprites switch at once) and you can additionally stretch them (all at once) twice. <br>  The total number of sprites is displayed simultaneously on the screen 32 (but not more than 4 in one line).  At the same time, 2k of memory for Sprite patterns is enough for two sets of 32 sprites 16x16 each. <br><br>  Individually for each sprite, you can set the following parameters (via the Sprite attrubutes area, for each byte in the series): <br><br><blockquote>  0 - vertical coordinate (-32 - 191) <br>  1 - horizontal coordinate (0-255).  255 - sprite for the right edge of the screen. <br>  2 - pointer to the place where to get the pattern (in the Sprites patterns) <br>  3 - bits 4-7 define color, bit 0 - early clock (shifts the sprite horizontally 32 pixels to the left) </blockquote><br>  The lack of direct addressing of video memory in combination with its unsuccessful organization and the absence of transfer commands in the processor more than a byte at a time - does not allow it to be updated quickly.  For example, the implementation of horizontal smooth scrolling of the area of ‚Äã‚Äã256x8 pixels while playing VGM music in parallel almost completely takes the ray retraction time over the frame.  Those.  there‚Äôs almost no time left. <br><br>  In games (modern), this problem is solved in rather clever ways, when scrolling does not update the entire scrolling area, but only requiring changes.  Accordingly, the contents of the screen is thought out in such a way that these changes were minimal.  Also commonly used is Graphics Mode I with a lower color resolution (two colors per 8x8 block). <br><br>  As in many other systems, in TI-99 / 4a, it is highly desirable to render the image by following the vertical retrace.  To do this, VDP generates a corresponding interrupt - at the beginning of drawing the bottom of the frame. <br><br> <a href=""><img src="https://habrastorage.org/files/eb9/5dc/01d/eb95dc01d4784d03b2dc5af00d822098.jpg" align="right" title="Raster effects on TI-99 / 4a and two emulators"></a>  The following options exist: <br><br>  1. Interrupts can be disabled completely (LIMI 0 + instruction specifically for VDP ‚Äî by setting the corresponding bit in register 1).  In this case, everything will be faster, but you will not be able to track the return path of the beam in any way. <br><br>  2. Interrupts enable completely (LIMI 2 and VDP).  Then you can hang your own interrupt handler that will do something. <br><br>  3. Enable interrupts in VDP, but disable them with the LIMI 0 instruction. In this case, no handlers will not be called, but you can monitor the return path of the beam manually by checking the bit in the VDP status register (after reading the register, this bit is automatically reset. If it is not reset, then another interrupt will not be generated). <br><br><pre> <code class="hljs lua">vwait: movb &gt;<span class="hljs-number"><span class="hljs-number">8802</span></span>,r12 ; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> VDP <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> register andi r12,&gt;<span class="hljs-number"><span class="hljs-number">8000</span></span> jeq vwait ; Wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> vsync</code> </pre><br><br>  A quite typical scheme is when interrupts from VDP are turned on, common ones are turned off (LIMI 0), but in the main loop for a short period of time they are turned on (LIMI 2) so that the processor hanging on the interrupt (for example, playing music) sometimes gets control. <br><br>  Not all emulators correctly mimic this interruption.  But, let's say, MESS does it more or less adequately.  In the picture you can see a simple test - the color of the frame changes with some delay relative to the vertical retrace (on a real TI and on two emulators, MESS and js99er). <br><br><h2>  SOUND </h2><br><h3>  1. Standard sound </h3><br>  For music and sound effects in the TI-99 / 4a installed chip TMS9919 (analogues: SN76489, SN76496).  It is quite simple: three independent tone generators and one noise.  15 volume levels. <br><br>  Since this is a fairly popular chip (used in some consoles, in IBM PCjr / Tandy-1000, etc.), there is a lot of information on it. <br><br>  For TI-99 / 4a there is a MOD2PSG tracker (it normally starts under Win7 64bit).  In particular, it allows you to upload psgmod files and export vgm and epsgmod. <br><br>  There are two working players - EPSGMOD Player by Tursi (requires data in epsgmod format, hangs its handler on the VDP interrupt). <br><br>  It is connected as follows: <br><br><pre> <code class="hljs scala"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span></span>: lwpi &gt;<span class="hljs-number"><span class="hljs-number">8320</span></span> li r0,musicdata bl <span class="hljs-meta"><span class="hljs-meta">@SGPLAY</span></span> again: limi <span class="hljs-number"><span class="hljs-number">2</span></span> limi <span class="hljs-number"><span class="hljs-number">0</span></span> ; .... your code (vsync etc..) ... b <span class="hljs-meta"><span class="hljs-meta">@again</span></span> musicdata: bcopy <span class="hljs-string"><span class="hljs-string">"music.epsgmod"</span></span> copy <span class="hljs-string"><span class="hljs-string">"test_music_playervbr.a99"</span></span> copy <span class="hljs-string"><span class="hljs-string">"test_music_player.a99"</span></span> end start</code> </pre><br>  With this connection of the player, it is necessary to remove REF and END from its sources (since they are oriented to use with traditional assembler). <br><br>  Note that in the main loop for an instant interrupts are enabled (limi 2).  This is necessary for the operation of the player, which operates on interruptions of VDP from the return path of the beam (occurring every 1/60 of a second).  The subroutine SGTICK of the player is called. <br><br>  Accordingly, it is important that for the NTSC version of the computer and the music should also be NTSC (the frame rate should be the same). <br><br>  The second player (of the same author) loses files of the VGM format (also includes the VGMComp utility for compressing VGM).  This handler does not hang up, you need to call manually with a frequency of 60Hz. <br><br>  It looks like this: <br><br><pre> <code class="hljs vhdl"> def start vdpsta equ &gt;<span class="hljs-number"><span class="hljs-number">8802</span></span> ; VDP RAM status start: limi <span class="hljs-number"><span class="hljs-number">0</span></span> lwpi ws0 ; player expects our workspace <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be &gt;<span class="hljs-number"><span class="hljs-number">8300</span></span> clr r2 li r1,musicdata bl @stinit again: clr r12 ; set CRU base (doesn<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> need <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>, but provides delay) tb <span class="hljs-number"><span class="hljs-number">2</span></span> ; check VDP interrupt input (Tests a CRU <span class="hljs-built_in"><span class="hljs-built_in">bit</span></span>) jeq <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> set, skip calling music movb @vdpsta,r12 ; read status <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>, which <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> turn clears the interrupt <span class="hljs-built_in"><span class="hljs-built_in">bit</span></span> bl @stplay ; call play <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> - it returns <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the wrong workspace * check <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> song <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> movb @songwp+<span class="hljs-number"><span class="hljs-number">14</span></span>,r3 jne notdone clr r2 ; play again li r1,musicdata bl @stinit notdone: lwpi &gt;<span class="hljs-number"><span class="hljs-number">8300</span></span> ; so restore the right one ; .... your code (vsync etc..) ... b @again musicdata: bcopy <span class="hljs-string"><span class="hljs-string">"music.vgm"</span></span> copy <span class="hljs-string"><span class="hljs-string">"tiplayer.a99"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> start</code> </pre><br>  In my opinion, the second version of the player has better quality (although it may depend on the particular music) and manual challenge is more flexible than the handler (which you yourself can hang if you really need) - you do not need to enable interrupts. <br><br>  He also has a 30Hz player version.  At the same time, it should also be called with a frequency of 60 Hz, but it will be used every second call.  Accordingly, the processor load is reduced, but the sound quality of music (depending on the effects used in it) may potentially drop. <br><br>  Apparently, there is a bug in the player (or when exporting to VGM), which creates incomprehensible problems with looping music. <br><br><h3>  2. Speech synthesizer </h3><br><img src="https://habrastorage.org/files/38d/c8f/84e/38dc8f84e8a54b63b08f33331ff7f1d7.jpg" align="right" title="Speech synthesizer from the inside">  Since the speech synthesizer is a very popular peripheral device for the TI-99 / 4a, quite a few programs use it.  The synthesizer connects to the port on the right side of the computer (if you have a NanoPEB, you can plug it directly into the synthesizer).  Inside there is a ROM with data for words, an LPC decoder (TMS5220) and a DAC. <br><br>  There are two modes of operation.  In the first, the computer indicates to the synthesizer which words from the ROM should be pronounced (there are few words).  In the second (Speak-External) it is possible to transfer directly compressed LPC data, which the synthesizer will simply reproduce.  For packing data using the ancient program QBox Pro, which runs under WinXP (the process is shown <a href="https://www.youtube.com/watch%3Fv%3DwVDE-6TtmFQ">here</a> ). <br><br>  The synthesizer can be controlled directly from the program in assembler.  If you just want to play, then you need a cartridge - for example, Speech Editor (allows you to pronounce the typed text, and also adds commands to the standard BASIC to play words).  Cartridge Terminal Emulator allows you to pronounce individual phonemes and connect them into arbitrary words. <br><br>  In the most famous emulators, the synthesizer is supported.  It is believed that the best support (fully emulated piece of hardware) is implemented in MESS / MAME. <br><br>  Below is an example that says the word ‚ÄúHELLO‚Äù by taking LPC data from a synthesizer ROM.  Documentation indicates that status checking is not possible if the code is executed in RAM on an 8-bit bus (i.e., the code is required to be in a 16-bit scratchpad), but after checking on emulators and a real computer, I think this is reinsurance (probably, as and in the case of VDP, all these requirements apply to some very early versions of iron).  This is a short code: <br><br><pre> <code class="hljs pgsql">; speaks <span class="hljs-string"><span class="hljs-string">'HELLO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> speech synth ROM def <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> SPCHRD equ &gt;<span class="hljs-number"><span class="hljs-number">9000</span></span> ; addr <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> synth SPCHWT equ &gt;<span class="hljs-number"><span class="hljs-number">9400</span></span> ; addr <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> synth (&gt;<span class="hljs-number"><span class="hljs-number">10</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">read</span></span>, &gt;<span class="hljs-number"><span class="hljs-number">4</span></span>x - <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span>-Address, &gt;<span class="hljs-number"><span class="hljs-number">50</span></span> - speak, &gt;<span class="hljs-number"><span class="hljs-number">60</span></span> = speak-ext ) H50 BYTE &gt;<span class="hljs-number"><span class="hljs-number">50</span></span> ; speak command <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>: limi <span class="hljs-number"><span class="hljs-number">0</span></span> ; loading speech address (<span class="hljs-number"><span class="hljs-number">5</span></span> nibbles <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> data required) <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> &gt;<span class="hljs-number"><span class="hljs-number">4</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span>-Address command ; &gt;<span class="hljs-number"><span class="hljs-number">4</span></span>x &gt;<span class="hljs-number"><span class="hljs-number">4</span></span>x &gt;<span class="hljs-number"><span class="hljs-number">4</span></span>x &gt;<span class="hljs-number"><span class="hljs-number">4</span></span>x &gt;<span class="hljs-number"><span class="hljs-number">40</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> marker &gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) li r0,&gt;<span class="hljs-number"><span class="hljs-number">351</span></span>a ; address <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-string"><span class="hljs-string">'HELLO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synth ROM li r2,<span class="hljs-number"><span class="hljs-number">4</span></span> ; <span class="hljs-number"><span class="hljs-number">4</span></span> nibbles loadlp: src r0,<span class="hljs-number"><span class="hljs-number">4</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> least significant nibble mov r0,r1 src r1,<span class="hljs-number"><span class="hljs-number">4</span></span> andi r1,&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>f00 ; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> particular nibble ori r1,&gt;<span class="hljs-number"><span class="hljs-number">4000</span></span> ; put <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &gt;<span class="hljs-number"><span class="hljs-number">4</span></span>x00 <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> movb r1,@SPCHWT ; <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> nibble <span class="hljs-type"><span class="hljs-type">dec</span></span> r2 jne loadlp li r1,&gt;<span class="hljs-number"><span class="hljs-number">4000</span></span> movb r1,@SPCHWT ; <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> fifth nibble (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> marker) movb @H50,@SPCHWT ; <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> speak command loopback: b @loopback <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span></code> </pre><br>  Addresses of all words from ROM can be found in the book Editor Assembler Manual. <br><br>  If you want to play an arbitrary speech converted to LPC using QBox Pro, in the simplest case, the code will look like this: <br><br><pre> <code class="hljs pgsql"> def SPEAK SPEAK li r2,<span class="hljs-number"><span class="hljs-number">1750</span></span> ; number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> speech BYTEs <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> poke (see <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> QBox data) li r3,speech ; speech data address limi <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> interrupts <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> movb *r3+,@&gt;<span class="hljs-number"><span class="hljs-number">9400</span></span> ; poke a BYTE <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> speech data <span class="hljs-type"><span class="hljs-type">dec</span></span> r2 jeq quit ; repeat <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> data jmp <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> go <span class="hljs-string"><span class="hljs-string">'round again quit limi 2 ; interrupts allowed rt speech ; 10 Voiced 4 Unvoiced 8 kHz 5220 ; [Coded LPC] ; ....   *.sfm    QBox Pro ; nb bytes: [1750] end</span></span></code> </pre><br>  For QBox Pro, you need to prepare a wav speech file.  Better sound clear male speech.  One phrase will take about kilobytes. <br><br>  Send singing or notes - will not work.  After encoding in LPC, such sounds will be completely unrecognizable. <br><br>  Settings and operations in QBox Pro: <br><br><pre> <code class="hljs sql">byte 8khz 5220 Project/Add files <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> Process/<span class="hljs-keyword"><span class="hljs-keyword">Medium</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bit</span></span> rate /OK Edit/Concatenations <span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span>/Concatenation/<span class="hljs-keyword"><span class="hljs-keyword">Concat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>/ <span class="hljs-string"><span class="hljs-string">"TEST"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span>/Phrase/OK <span class="hljs-keyword"><span class="hljs-keyword">Format</span></span>/LPC <span class="hljs-number"><span class="hljs-number">10</span></span>V, <span class="hljs-number"><span class="hljs-number">4</span></span>UV /OK <span class="hljs-keyword"><span class="hljs-keyword">Project</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">Save</span></span></code> </pre><br>  Result: test.sfm <br><br><h2>  CROSS-MEANS </h2><br>  To develop and test software on a PC, and then download them to a TI-99 / 4a, you need the following: <br><br>  Iron: <br><br>  - PC / Win7 (64bit is good) <br>  - TI-99 / 4a <br>  - Cartridge Editor / Assembler (or any other, allowing you to download and run programs in machine codes) <br>  - NanoPEB or CF7 + (to emulate the drive and load the program from the CompactFlash card in the TI-99 / 4a) <br><br>  Soft: <br><br>  - One of the many TI-99 / 4a emulators is MESS / MAME or js99er (and preferably several). <br>  - The xdt99 package, which includes the assembler and utilities for working with files and disk images (in particular, xvm99 for recording a disk image on a CompactFlash card, in the required format for NanoPEB) <br><br>  Organization of the process: <br><br>  The programs for the cartridge and for loading from disk are different things.  Not only in terms of format (RPK and DSK), but also in terms of working with memory (the second version uses a 32kb memory expansion).  If there is a goal to eventually run the code on a real machine, you need to focus on the disk version.  And consider it. <br><br>  Emulators are significantly different from each other, the best name is very difficult.  This is not only a question of the quality of emulation, but also of the convenience / ease of launching the finished program. <br>  The most famous: mess (mame), js99er, v9t9, classic99. <br><br>  All of them are not perfect.  It is quite possible to expect a 10% difference in speed between the emulator and the real piece of hardware (specifically, I observed that mess and js99er execute the entire code a little faster than the real TI. In the same NTSC) <br><br>  When used as an xdt99 assembler, the process looks like this: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">xas99</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.py</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-R</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--jumpstart</span></span> %1<span class="hljs-selector-class"><span class="hljs-selector-class">.a99</span></span> (  )</code> </pre> <br>  The -R option allows you to normally name the registers in the source text (r0, r1, ...).  In the traditional assembler TMS9900, the registers in commands are simply written in numbers, which introduces wild confusion. <br><br><pre> <code class="hljs perl">xdm99.py work.dsk -a %1.obj -n %1-O -f DIS/FIX8<span class="hljs-number"><span class="hljs-number">0</span></span> (      )</code> </pre> <br>  It is necessary to take into account that the object file is a text file with hexadecimal codes inside.  Although this is not the final binary file, nevertheless, because of the peculiarities of downloading programs to the TI-99 / 4a (via Editor / Assembler), it is often considered a ready-made program.  All the more convenient that it is usually not tied to a specific area of ‚Äã‚Äãmemory at boot time. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the final binary file is required, for the xas99 one should add the parameter "-i". Then you will need to download it not through point 3, but through point 5 in the Editor / Assembler. If you need a final binary file more than 8k, without splitting into separate parts, instead of -i you need to use -b. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additionally, you can get the listing file .lst by specifying the parameter "-L". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The special image of the cartridge for automatic loading somewhat simplifies the work (see ‚Äújumpstarting‚Äù in the documentation on xdt99). The image allows you to do without the Editor / Assembler in the emulator, pressing the buttons in it and entering the file name. Ready code is loaded from disk automatically when you select a cartridge. For example, mess (mame) in this case starts like this:</font></font><br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">mame64</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.exe</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ti99_4a</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-peb</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:slot8</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tifdc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-peb</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:slot2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">speech</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-flop1</span></span> %1<span class="hljs-selector-class"><span class="hljs-selector-class">.dsk</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-cart</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jumpstart</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rpk</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-window</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-ui_active</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-skip_gameinfo</span></span></code> </pre> <br>   ,    -debug (      ,     ‚Äî  ` ) <br><br>  ¬´ti99_4a¬ª  NTSC   (..  ).  PAL    ti99_4ae. <br>   ,   -    -.     60,   50.    , ,     (    NTSC,   PAL). <br><br>        -   ,     -speed 20 <br><br>      CompactFlash   NanoPEB   xvm99.py <br><br><pre> <code class="hljs tex"><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PHYSICALDRIVE</span></span></span></span>2 1 -w work.dsk</code> </pre> <br> ,     PHYSICALDRIVE2       CF (      !).  Windows     <br><br><pre> <code class="hljs php">wmic diskdrive <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> brief /format:<span class="hljs-keyword"><span class="hljs-keyword">list</span></span></code> </pre> <br>    CF        ,     ‚Äî .. DSK1  1). <br><br>  CF    FAT16,      TI   NanoPEB  TI Basic  ¬´call format(1)¬ª,  1 ‚Äî    . <br><br>   : <br><br><pre> <code class="hljs tex">xvm99.py <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PHYSICALDRIVE</span></span></span></span>2 1 -i</code> </pre> <br>      TI     Editor/Assembler  NanoPEB.  NanoPEB,  .     ¬´2¬ª ‚Äî ¬´Editor/Assembler¬ª,    3 ( 5),  DSK1._   ENTER. <br>     . <br><br><h2>  1 ‚Äî  99TRO </h2><br>    TI-99/4a    <a href="http://www.youtube.com/watch%3Fv%3DNR0YOCODR7g">¬´99tro¬ª</a> <a href="https://github.com/petersobolev/99tro">()</a> ‚Äî  invitation intro  Chaos Constructions'2016,   Revision'2016.     (   ‚Äî   !)     . <br><br>    ,        cracktro  Commodore 64,            TI-99/4a.  ,  -   ,    ,        . <br><br> <a href=""><img src="https://habrastorage.org/files/2c4/9b9/219/2c49b921920e4890937dae015dcd71ce.jpg" align="right" title=" 99tro"></a>         : <br><br> ‚Äî   ,         <br><br> ‚Äî    (       )          (    16-, ..   VDP   8- ). <br><br> ‚Äî VDP        ( , TMS9918 ‚Äî     ).      ,        . <br><br> ‚Äî     ‚Äî  4   (  ,        ), ,           . <br><br> ‚Äî   (vgm)     .       Tursi,  2-20%  30 ,    .        10-15%. <br><br> ‚Äî     (  ,        Vectrex ‚Äî      ,   , ,  ,     ,  ) <br><br> ‚Äî       .     ,  ,   PC,    ,   PC    TI,      TI,  Editor/Assembler,    ,  DSK1._,  ENTER,   ( ). <br><br>         ,     (,  ,            ): <br><br> ‚Äî / CHAOS CONSTRUCTIONS'2016    <br> ‚Äî         <br> ‚Äî    ,    ,     <br> ‚Äî     <br> ‚Äî   (vgm) <br><br>   -    TI-99/4a,          ‚Äî Graphics mode II (Bitmap).      , ..    16  , ,       . <br><br> ,    ,         (    demo  intro) ‚Äî       . ,   ,      ,   . <br>      bitmap    . <br><br><img src="https://habrastorage.org/files/f39/c5f/bd4/f39c5fbd43ab482899a70031f92c46a0.jpg" align="right" title="      NTSC">       Photoshop,       VDP    Convert9918        ‚Äî ..     ,    ( 15-       2   8  )    .  ,      NTSC  ,      ,   ‚Äî  CRT     ,    (  ,   ). <br><br>  ,    ,        16    () .    TI-99/4a     (  ,  15). <br><br>  ,         NTSC .   ,        ( PAL    ,   ). <br><br>          (Matthew Hagerty)  .  .            TMS9900  ,      ,           . <br><br>             VRAM.     8  . <br><br>     ,     bitmap' ‚Äî     -       . <br><br>   ‚Äî      ,         (      ,   ). <br><br>  ,        ..  ,     ,   ,   .      ‚Äî . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The text behind the cursor is written in the middle of the screen. I had many ideas on how to implement it beautifully, but in the end I had to give up on all of them because of the slow video memory and VDP bugs. As a result, one letter is drawn for each iteration of the loop (i.e., 8 bytes of video memory are updated). For all possible eight lines of text, a background with a smooth transition between shades of blue and gray is set in advance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The pulsing cursor is a sprite for which the image is taken cyclically from four memory locations - i.e. It turns out four frames of a square of a different size.</font></font><br><br>       ,        16x16 (  ‚Äî     ).              (   ). <br><br>       Magellan. <br><br>      workspace    ‚Äî    (      workspace,     scratchpad ‚Äî  16- RAM, -           ),         (  ,    .) <br><br>     intro    22.  , ,    (12kb)  RLE   (1.8).  ,    -   6-7 (     ,     ). <br><br><h2>  2 ‚Äî  Speechtro </h2><br>     <a href="https://www.youtube.com/watch%3Fv%3DJJneJzWwd7U">¬´Speechtro¬ª</a> <a href="https://github.com/petersobolev/speechtro">()</a>     99tro    DIHALT'2016 (     1kb low end intro). <br><br>     : <br><br> <strong>1.</strong>  -,    (  TI-99/4a   ,      ‚Äî MESS/MAME  js99er). <br> <strong>2.</strong>          . <br><br><img src="https://habrastorage.org/files/b24/a4f/760/b24a4f76061d41b8a70ae33dbfc937c9.jpg" align="right" title=" Speechtro">           . <br><br>        (      LPC   1     ).      ,   ,          .        .        ,      ¬´¬ª. , -,    , -  ,   . <br><br>   ,        (    ,      ).     (          TI    ‚Äî MESS  js99er),      ‚Äî        .  Graphics Mode 2   8x1        ,      1         .   ,    15 (     10),  ,    . <br><br>     .   TI-99/4a ,   (  GROM)      ,        GROM   () ‚Äî           . <br>   ¬´small caps¬ª    AZ ( ),   . <br><br> ,     ,   8x8. <br>          ()       . <br><br><h2>     TI-99/4a </h2><br><ul><li> <a href="https://www.youtube.com/watch%3Fv%3D-f0_5YI65i4">   CC'2016: ¬´ 'Texas Instruments TI-99/4a' 1980     ¬ª</a> </li><li> <a href="http://www.unige.ch/medecine/nouspikel/ti99/titechpages.htm">    TI-99/4a</a> </li><li> <a href="http://atariage.com/forums/forum/119-ti-994a-development">     TI-99/4a</a> </li><li> <a href="https://computerarchive.org/files/mirror/ftp.whtech.com/"> ,   ..</a> </li><li> <a href="http://endlos99.github.io/xdt99/"> -    </a> </li><li> <a href="http://webpages.charter.net/nanopeb/">NanoPEB (CF7+)</a> </li><li> <a href="http://atariage.com/forums/topic/250540-flash-rom-cart/">  ( NanoPEB)</a> </li><li> <a href="">   ,  </a> </li><li> <a href="http://atariage.com/forums/topic/218904-playground/">      scratchpad ( Editor/Assembler    )</a> </li><li> <a href="http://js99er.net/">   js</a> </li><li> <a href="http://www.cs1er.com/">  </a> </li><li>  <a href="http://www.harmlesslion.com/cgi-bin/showprog.cgi%3FTI994A">Useful software</a> </li><li> <a href="http://spectra99.sourceforge.net/">   </a> </li></ul><br>  <a href="http://enlight.ru/roi/">Here</a> you can see my works for different retro platforms, and <a href="https://github.com/petersobolev">here</a> their sources are on github. <br><br>  ,        <a href="http://chaosconstructions.ru/">Chaos Constructions</a> ,    (  )      ,      - . <br><br> PS         </div><p>Source: <a href="https://habr.com/ru/post/313058/">https://habr.com/ru/post/313058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313044/index.html">How will virtual offices affect our lives?</a></li>
<li><a href="../313048/index.html">Personal experience of receiving the Blue Card in Germany 2015-2016. Part 1: Job Search</a></li>
<li><a href="../313052/index.html">Dissect OpenVPN. Part 1. Static keys</a></li>
<li><a href="../313054/index.html">RailsClub 2016: podcasts with Ivan Nemytchenko and Ilya Zykin</a></li>
<li><a href="../313056/index.html">Translation of excerpts from Robert Heinlein‚Äôs book, Take Your Government Back - part 17</a></li>
<li><a href="../313062/index.html">Programming & Music: Buttervo Frequency Filter. Part 3</a></li>
<li><a href="../313064/index.html">Customer support operator, manager, programmer</a></li>
<li><a href="../313066/index.html">Overview of options for implementing failover clusters: Stratus, VMware, VMmanager Cloud</a></li>
<li><a href="../313068/index.html">Media: German military hacked into the network of the Afghan mobile operator to find out the whereabouts of the hostage</a></li>
<li><a href="../313070/index.html">Java Continuations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>