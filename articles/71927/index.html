<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Async hearts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, several events happened that changed the familiar look of the Python web development landscape: Facebook acquired the Friendfeed servic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Async hearts</h1><div class="post__text post__text-html js-mediator-article">  Some time ago, several events happened that changed the familiar look of the Python web development landscape: Facebook acquired the Friendfeed service and immediately opened the source code of the project's technology ‚Äî the http server and the Tornado microform.  At the same time, the developer of Friendfeed published a note in his blog in which he cited the reasons why it was decided to develop from scratch his own asynchronous web server. <br><br>  The article is an excursion into the very heart of this and competing (Twisted.web) projects, their asynchronous data processing cycles. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://bret.appspot.com/entry/tornado-web-server">The</a> developer's <a href="http://bret.appspot.com/entry/tornado-web-server">note</a> contained criticism of Twisted, a popular framework for building asynchronous applications, as untested and unstable;  The results of comparing the performance of a simple application on Twisted.web (Twisted subset, specializing in the http protocol and web development) and Tornado were presented.  Naturally, the latter in these tests turned out to be more effective. <br><br>  One of the key programmers Twisted <a href="http://glyph.twistedmatrix.com/2009/09/what-i-wish-tornado-were.html">could not</a> stand aside and gave the reasons why Friendfeed would not have reinvented the bike and used the existing tools;  in the next <a href="http://glyph.twistedmatrix.com/2009/09/diesel-case-study-in-that-thing-i-just_24.html">post he</a> pointed to another development - Orbited Comet-server, which was ported to Twisted for reasons of greater stability and ease of development. <br><br>  From the point of view of the web developer, Tornado and Twisted.web are not very different, because they are microframes that provide only the most basic tools for working with queries, authorization, and so on, and cannot compare with such giants as Django or, if you go beyond Python world, Ruby on Rails. <br><br><h3>  Asynchrony </h3><br><br>  The heart, soul, and the main difference between both applications from competitors is asynchronous processing of requests by the server, which allows to gain in performance due to the rejection of context switches typical of synchronous servers that produce many processes or threads. <br><br>  All actions are performed by a single process (thread) in a single cycle, the ‚Äúevent loop‚Äù (event loop), similar to those found in frameworks for building interfaces. <br><br><h3>  Performance </h3><br><br>  As mentioned above, the gain compared with the classical synchronous servers is achieved by creating such a single cycle of calculations, which would allow to abandon the switching of the context of the kernel. <br><br>  Such a cycle is present in both Tornado (ioloop) and Twisted (various implementations of the reactor).  Let's try to understand each of them, determine the reasons for performance gains on the Tornado http server, evaluate the code and architectural solutions of each of the asynchronous servers. <br><br><h3>  Tornado (ioloop) </h3><br><br>  The Tornado ioloop module uses the default epoll mechanism for working with non-blocking sockets.  If there is no one on the platform (in fact, only Linux with version 2.6 and later kernels are suitable) is not provided, then <br>  universal select is used. <br><br>  The implementation of the main loop is extremely simple; it fits in a couple of small files: epoll.c is the wrapper for epoll, ioloop.py is the implementation of the loop. <br><br>  In epoll.c in the Python function, epoll_create, epoll_ctl, epoll_wait are wrapped and the epoll module is declared.  This module is compiled and used if the standard language module for asynchronous work with sockets (select module) does not support epoll (does not contain the epoll class). <br><br>  So, the event loop itself is located in the start method of the IOLoop class of the ioloop.py module.  Below are parts of this method with somewhat expanded explanations: <br><br><pre> def start (self):
     self._running = True
     while true:
         # Default timeout between event handler call cycles
         # avoids hanging the event pool
         poll_timeout = 0.2

         # Create a list of event handlers
         callbacks = list (self._callbacks)
         for callback in callbacks:
             # Remove the handler from the list of unused and execute
             if callback in self._callbacks:
                 self._callbacks.remove (callback)
                 self._run_callback (callback)
	
	 # If there are handlers, there is no need for a delay between cycles
         if self._callbacks:
             poll_timeout = 0.0

	 # If there are event handlers that are executed with a time delay, and specified
         # time has passed - we execute such handlers. 
         if self._timeouts:
             now = time.time ()
             while self._timeouts and self._timeouts [0] .deadline &lt;= now:
                 timeout = self._timeouts.pop (0)
                 self._run_callback (timeout.callback)
             # the next set of events will be collected either standard time
	     # delays, or if you need to call the delayed handler earlier, 
             # through the time set for this handler
             if self._timeouts:
                 milliseconds = self._timeouts [0] .deadline - now
                 poll_timeout = min (milliseconds, poll_timeout)
	 # If some handler decided to stop the work, we exit the loop
         if not self._running:
             break

	 # Next, pool events are collected for a specified time.
         try:
             event_pairs = self._impl.poll (poll_timeout)
         except Exception, e:
             if e.args == (4, "Interrupted system call"):
                 logging.warning ("Interrupted system call", exc_info = 1)
                 continue
             else:
                 raise

	 # For given file descriptors (sockets), events are pulled out and 
	 # with them their handlers are called (for example, functions that read data from sockets - fdopen)
         self._events.update (event_pairs)
         while self._events:
             fd, events = self._events.popitem ()
             try:
                 self._handlers [fd] (fd, events)
             except KeyboardInterrupt:
                 raise
             except OSError, e:
                 if e [0] == errno.EPIPE:
                     # occurs when a client connection is lost
                     pass
                 else:
                     logging.error ("Exception in I / O handler for fd% d",
                                   fd, exc_info = True)
             except:
                 logging.error ("Exception in I / O handler for fd% d",
                               fd, exc_info = True)
</pre><br><br>  Here, in general, and all.  Calls pending for a certain time (or one cycle) and handlers of incoming events are cyclically called.  The data received by the handlers is not read / written completely, but gradually, through buffers. <br><br>  All other levels of the framework are written in the same simple and uncluttered style: http-server, request handlers and individual connections. <br><br><h3>  Twisted (reactor) </h3><br><br>  The twisted.internet.reactor module from the framework is the same event loop that executes event handlers and possible errors. <br><br>  By default, the web server reactor (as well as the framework as a whole) uses the select engine of event distribution for non-blocking sockets;  This mechanism is universal for Unix and Win32 platforms, although it is slightly inferior in efficiency to kqueue (FreeBSD) or epoll reactors (only for Linux) <br><br>  Consider the operation of the reactor EPollReactor, as an analogue of the main mechanism used in Tornado (ioloop, working with epoll). <br><br>  The reactor contains several dictionaries, around which all asynchronous loop logic is concentrated.  Dictionaries are declared in the class constructor: <br><br><pre> class EPollReactor (posixbase.PosixReactorBase):
     implements (IReactorFDSet)
     def __init __ (self):
         self._poller = _epoll.epoll (1024)
         self._reads = {}
         self._writes = {}
         self._selectables = {}
         posixbase.PosixReactorBase .__ init __ (self)
</pre><br><br>  This is where the event pool itself is created (_poller);  dictionaries (_reads and _writes) containing mappings of whole numbers of file descriptors to random numbers.  As a matter of fact, these are simply sets of descriptors for reading (_reads) and writing (_writes) data. <br><br>  Of interest is the cycle of asynchronous event processing itself, so we omit the description of the utility methods declared in the reactor class (and its base class). <br><br>  The iteration of a sample of events and their processing is as follows (comments are translated and, if possible, expanded): <br><br><pre>     def doPoll (self, timeout):
         if timeout is None:
             timeout = 1
         # convert the iteration delay (event collection time) to milliseconds
         timeout = int (timeout * 1000) 
    
         try:
             # The number of selected events is limited by the number of monitored
             # I / O objects (number selected heuristically)
             # and the cycle locking time passed in the argument to the loop-calling function.
             l = self._poller.wait (len (self._selectables), timeout)
    
    
         except IOError, err:
             if err.errno == errno.EINTR:
                 return
             # In case of interruption of waiting by a signal, we exit the iteration;
             # in all other cases it is assumed that errors could occur 
	     # only on the side of the application and it is worth passing the exception further
             raise
    
         # If during the collection of events there were no errors, proceed
         # call event handlers on handles.
         _drdw = self._doReadOrWrite
         for fd, event in l:
             try:
                 selectable = self._selectables [fd]
             except KeyError:
                 pass
             else:
                 log.callWithLogger (selectable, _drdw, selectable, fd, event)
</pre> <br><br>  The self._doReadOrWrite reactor method (renamed to _drdw) is passed a handle, an event that occurred on it, and an event handler (if one was found).  Let's look at the method itself: <br><br><pre>     def _doReadOrWrite (self, selectable, fd, event):
         why = None
         inRead = False
         if event &amp; _POLL_DISCONNECTED and not (event &amp; _epoll.IN):
             why = CONNECTION_LOST
         else:
             try:
                 if event &amp; _epoll.IN:
                     why = selectable.doRead ()
                     inRead = True
                 if not why and event &amp; _epoll.OUT:
                     why = selectable.doWrite ()
                     inRead = False
                 if selectable.fileno ()! = fd:
                     why = error.ConnectionFdescWentAway (
                           'Filedescriptor went away')
                     inRead = False
             except:
                 log.err ()
                 why = sys.exc_info () [1]
         if why:
             self._disconnectSelectable (selectable, why, inRead)
</pre><br><br>  Here, events of receipt and recording of data from / to the handle are processed, error handling takes place, if any. <br><br>  Thus, at the lowest level, Tornado and Twisted are similar, differences begin at higher levels of abstraction.  The development from the Friendfeed team makes just a few simple add-ons on the loop (HttpStream -&gt; HttpConnection -&gt; HttpServer and others).  The cycles here are based solely on epoll or select. <br><br>  Twisted Framework is built on special abstractions (like Deferred);  its reactors are implemented for a wider range of solutions: poll, epoll, select, kqueue (MacOS and freeBSD), a couple of tools under Win32;  There are reactors that are built into the framework framework for building interfaces (PyGTK, wxWidgets). <br><br><h3>  findings </h3><br><br>  Strictly speaking, it is difficult to compare the universal network framework and specialized application.  The Tornado code is much simpler and more concise as a whole, more responsive to the pythonic principle.  Only the absence of tests is puzzling, which is considered indecent in modern development. <br><br>  On the other hand, Twisted is a versatile tool that, with all its really wide possibilities, preserves its harmony and consistency;  and in this sense, it can be compared to a great Qt (in the original implementation for C ++).  Http-server - just a special case of its use.  Code greater <br>  parts of the framework components are well tested, it even provides its own testing tool (Trial). <br><br>  Naturally, Twisted, like any generalizing system, is inferior in performance to specialized development. <br><br>  Another reason why Twisted is inferior in efficiency to Tornado and another high-performance asynchronous framework Diesel is more advanced error handling, which adds reliability but hides cherished RPS. <br><br>  So, the main advantage of Twisted is universality.  Tornado - performance. <br><br>  What to choose?  Decide for yourself.  Both frameworks provide the web programmer with a very spartan set of development tools, clearly inferior in the simplicity of Django and the comprehensive fullness of Zope;  both win speeds (up to a 20-30 percent increase compared to Apache solutions). </div><p>Source: <a href="https://habr.com/ru/post/71927/">https://habr.com/ru/post/71927/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../71909/index.html">True value of things</a></li>
<li><a href="../71912/index.html">It b ... charging!</a></li>
<li><a href="../71917/index.html">Custom Action in WiX</a></li>
<li><a href="../71921/index.html">Program from SysInternals turns your PC into a virtual machine</a></li>
<li><a href="../71923/index.html">iPhone OS 3.1.2</a></li>
<li><a href="../71928/index.html">Secretarial content management</a></li>
<li><a href="../71930/index.html">Captcha? Do not!</a></li>
<li><a href="../71931/index.html">Different Master Pages for landline and mobile browsers</a></li>
<li><a href="../71937/index.html">Bahama botnet steals Google search traffic!</a></li>
<li><a href="../71939/index.html">HTML5: caching offline applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>