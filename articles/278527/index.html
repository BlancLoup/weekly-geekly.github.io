<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Correct work with date and time</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Almost all projects face problems caused by improper handling and storage of date and time. Even if the project is used in one time zone, anyway, afte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Correct work with date and time</h1><div class="post__text post__text-html js-mediator-article">  Almost all projects face problems caused by improper handling and storage of date and time.  Even if the project is used in one time zone, anyway, after the transition to winter / summer time, you can get unpleasant surprises.  In this case, few people are puzzled by the implementation of the correct mechanism from the start, because it seems that there can be no problems with this, since everything is trivial.  Unfortunately, later reality shows that it is not. <br><a name="habracut"></a><br>  Logically, you can select the following types of values ‚Äã‚Äãrelated to the date and time: <br><br><ul><li>  <a href="https://habr.com/ru/post/278527/">Date and time</a> - ‚Äúmaterial for medical analysis was collected on January 15, 2014 at 13:17:15‚Äù </li><li>  <a href="https://habr.com/ru/post/278527/">Date without time</a> - for example, ‚Äúa new contract comes into force on February 2, 2016‚Äù </li><li>  <a href="https://habr.com/ru/post/278527/">Time interval</a> - ‚Äúthe report was generated in 3 minutes 15 seconds‚Äù </li><li>  <a href="https://habr.com/ru/post/278527/">Schedule of scheduled events</a> - ‚Äúthe import of data from another system should occur every weekday at 10:00‚Äù </li></ul><br>  Consider each item separately, not forgetting the <a href="https://habr.com/ru/post/278527/">general recommendations</a> . <br><br><a name="1"></a><h2>  date and time </h2><br>  Suppose the laboratory that collected the material for analysis is in the time zone +2, and the central branch, in which the timely execution of analyzes is monitored, is in the +1 belt.  The time given in the example was noted when the material was collected by the first laboratory.  The question arises - what time should the central office see?  It is obvious that the software of the central office should show January 15, 2014 12:17:15 - an hour less, since according to their hours the event occurred at this very moment. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider one of the possible chains of actions, through which the data from the client to the server and vice versa, allows you to always correctly display the date / time according to the current client time zone: <br><br><ol><li>  The value is created on the client, for example, on March 2, 2016 at <b>15</b> : 13: 36, the client is in the time zone +2. </li><li>  The value is converted to a string representation for transmission to the server - ‚Äú2016-03-02T <b>15</b> : 13: 36 + 02: 00‚Äù. </li><li>  Serialized data is transferred to the server. </li><li>  The server deserializes the time into a date / time object, leading it to its current time zone.  For example, if the server is running at +1, then the object will contain March 2, 2016 <b>14</b> : 13: 36. </li><li>  The server saves the data to the database, while it does not contain any information about the time zone - the most commonly used date / time types simply do not know anything about it.  Thus, the database will be saved on March 2, 2016 <b>14</b> : 13: 36 in the ‚Äúunknown‚Äù time zone. </li><li>  The server reads data from the database and creates the corresponding object with the value March 2, 2016 <b>14</b> : 13: 36.  And since the server works in the time zone +1, then this value will be interpreted in the framework of the same time zone. </li><li>  The value is converted to a string representation for transmission to the client - ‚Äú2016-03-02T <b>14</b> : 13: 36 + 01: 00‚Äù. </li><li>  Serialized data is sent to the client. </li><li>  The client deserializes the resulting value into a date / time object, leading it to its current time zone.  For example, if it is -5, then the displayed value should be March 2, 2016 <b>09</b> : 13: 36. </li></ol><br>  It seems to be all holistic, but let's think that in this process can go wrong.  In fact, problems here can happen at almost every step. <br><br><ul><li>  Time on the client can be formed without a time zone at all - for example, the DateTime type in .NET with DateTimeKind.Unspecified. </li><li>  The serialization mechanism can use a format that does not include a time zone offset. </li><li>  When deserializing into an object, the time zone offset can be ignored, especially in self-made deserializers, both on the server and on the client. </li><li>  When reading from a database, a date / time object can be formed without a time zone at all - for example, the DateTime type in .NET with DateTimeKind.Unspecified.  Moreover, with DateTime in .NET, in practice this is exactly what happens if, immediately after reading, no other DateTimeKind is explicitly specified. </li><li>  If the application servers working with the common database are in different time zones, there will be a serious confusion in the time shifts.  The date / time value written to the database by server A and read by server B will differ noticeably from the same initial value written by server B and read by server A. </li><li>  Transferring application servers from one zone to another will lead to incorrect interpretation of already stored date / time values. </li></ul><br>  But the most serious flaw in the chain described above is the use of the local time zone on the server.  If there is no daylight saving time, then there will be no additional problems.  But otherwise you can get a lot of unpleasant surprises. <br><br>  The rules for daylight saving time are, strictly speaking, variable.  Different countries may sometimes change their rules, and these changes must be incorporated in advance into system updates.  In practice, situations of incorrect operation of this mechanism have repeatedly been encountered, which, as a result, were solved by installing hotfixes of either the operating system or third-party libraries used.  The likelihood of repeating the same problems is not zero, so it‚Äôs best to have a way to avoid them guaranteed. <br><br>  Taking into account the above considerations, we formulate the most reliable and simple approach to the transfer and storage of time: <b>on the server and in the database, all values ‚Äã‚Äãshould be brought to UTC time zone</b> . <br><br>  Consider what this rule gives us: <br><br><ul><li>  When sending data to the server, the client must transfer the time zone offset so that the server can correctly convert the time to UTC.  The alternative is to require the client to do this conversion, but the first option is more flexible.  When receiving data back from the server, the client will transfer the date and time to his local time zone knowing that he will come to UTC in any case. </li><li>  In UTC there are no transitions to summer and winter time, respectively, the associated problems will be irrelevant. </li><li>  When reading from the database on the server, it is not necessary to convert the time values, it is enough just to explicitly indicate that it corresponds to UTC.  In .NET, for example, this can be achieved by setting the DateTimeKind for the time object to DateTimeKind.Utc. </li><li>  The difference in time zones between servers working with a common database, as well as the transfer of servers from one zone to another, does not affect the correctness of the received data. </li></ul><br>  To implement such a rule, it is enough to take care of three things: <br><br><ol><li>  Make the serialization and deserialization mechanism such that the date / time values ‚Äã‚Äãare correctly transferred from UTC to the local time zone and back. </li><li>  Ensure that the server-side deserializer creates date / time objects in UTC. </li><li>  Make it so that when reading from the database, date / time objects are created in UTC.  This item is sometimes provided without code changes ‚Äî just the system time zone on all servers is set to UTC. </li></ol><br>  The above considerations and recommendations work well <b>with a combination of two conditions</b> : <br><br><ul><li>  In the system requirements there is no need to display the local time and / or time zone offset exactly in the form in which it was saved.  For example, on air tickets, the time of departure and arrival must be printed in the time zone corresponding to the location of the airport.  Or if the server sends to print invoices created in different countries, each should end up with local time, and not converted to the server time zone. </li><li>  All date and time values ‚Äã‚Äãin the system are ‚Äúabsolute‚Äù - i.e.  describe a point in time in the future or the past, which corresponds to the only value in UTC.  For example, ‚Äúthe launch of the launch vehicle took place at 11:00 pm Kyiv time‚Äù, or ‚Äúthe meeting will be held from 1:30 pm to 2:30 pm Minsk time‚Äù.  In different time zones, the numbers for these events will be different, but they will describe the same point in time.  But it may happen that software requirements imply ‚Äúrelative‚Äù local time for some cases.  For example, "this TV show will go from 9:00 to 10:00 in the morning in each country where there is a branch of the TV channel."  It turns out that the show of the program is not one event, but several, and all of them can potentially occur at different time intervals on an ‚Äúabsolute‚Äù scale. </li></ul><br>  For cases where the first condition is violated, the task can be solved using data types that contain the time zone, both on the server and in the database.  Below is a small list of examples for different platforms and DBMS. <br><table><tbody><tr><td>  .NET </td><td>  Datetimeoffset </td></tr><tr><td>  Java </td><td>  org.joda.time.DateTime, java.time.ZonedDateTime </td></tr><tr><td>  MS SQL </td><td>  datetimeoffset </td></tr><tr><td>  Oracle PostgreSQL </td><td>  TIMESTAMP WITH TIME ZONE </td></tr><tr><td>  Mysql </td><td>  - </td></tr></tbody></table><br>  Violation of the second condition is a more complicated case.  If this ‚Äúrelative‚Äù time needs to be stored just for display, and there is no task to determine the ‚Äúabsolute‚Äù moment of time when an event has come or will come for a given time zone - simply deny the time conversion.  For example, the user entered the beginning of the transfer for all branches of a television company on March 25, 2016 at 9:00, and it will be transmitted, displayed and displayed in this form.  But it may happen that some scheduler should automatically perform special actions one hour before the start of each program (send out notifications or check the presence of some data in the broadcaster's database).  Reliable implementation of such a scheduler is not a trivial task.  Suppose the scheduler is aware of what time zone each branch is located in.  And one of the countries where there is a branch, after some time decides to change the time zone.  The case is not as rare as it may seem - I have counted more than 10 similar events in this and two previous years ( <a href="http://www.timeanddate.com/news/time/">http://www.timeanddate.com/news/time/</a> ).  It turns out that either users must keep their time zone bindings up to date, or the scheduler must automatically take this information from global sources such as the Google Maps Time Zone API.  I do not undertake to offer a universal solution for such cases, I just note that such situations require serious study. <br><br>  As can be seen from the above, <b>there is no single approach covering 100% of cases</b> .  Therefore, you must first clearly understand from the requirements which of the above situations will be in your system.  Most likely, everything will be limited to the first proposed approach with storage in UTC.  Well, the described exceptional situations do not cancel it, but simply add other solutions for particular cases. <br><br><a name="2"></a><h2>  Date without time </h2><br>  Suppose that the date and time are displayed correctly, taking into account the client's time zone.  Let us turn to the dates without time and the example specified for this case at the beginning - ‚Äúthe new contract comes into force on February 2, 2016‚Äù.  What will happen if for such values ‚Äã‚Äãto use the same types and the same mechanism as for ‚Äúordinary‚Äù dates with time? <br><br>  Not all platforms, languages ‚Äã‚Äãand DBMS have types that store only the date.  For example, in .NET there is only the DateTime type, there is no separate ‚Äújust Date‚Äù.  Even if when creating such an object, only the date was indicated, the time is still present, and it is equal to 00:00:00.  If we transfer the value ‚ÄúFebruary 2, 2016 00:00:00‚Äù from the belt with offset +2 to +1, we get ‚ÄúFebruary 1, 2016 23:00:00‚Äù.  For the above example, this would be equivalent to the fact that in one time zone a new contract will begin on February 2, and in the other on February 1.  From a legal point of view, this is absurd and so, of course, should not be.  <b>The general rule for "pure" dates is extremely simple - such values ‚Äã‚Äãshould not be converted at any one save and read step.</b> <br><br>  There are several ways to avoid conversion for dates: <br><br><ul><li>  If the platform supports a type that represents a date without time, then it should be used. </li><li>  Add a special attribute to object metadata that will tell the serializer that the time zone for this value should be ignored. </li><li>  Send the date from the client and back as a string, and store as a date.  This approach is inconvenient if the client needs to not only display the date, but also perform some operations on it: comparison, subtraction, etc. </li><li>  Transfer and store as a string, and convert to date for formatting only, taking into account the client‚Äôs regional settings.  It has even more drawbacks than the previous version - for example, if in the stored string of the date part are not in the order of "year, month, day", then it will be impossible to do an effective indexed search by date range. </li></ul><br>  You can, of course, try to give a counterexample and say that a contract makes sense only within the country in which it is concluded, the country is in the same time zone, and therefore it is possible to unambiguously determine the time of its entry into force.  But even in this case, users from other time zones will not be interested at what point in their local time this event will occur.  And even if there was a need to show this point in time, then it would be necessary to display not only the date, but also the time, which contradicts the original condition. <br><br><a name="3"></a><h2>  Time interval </h2><br>  With the storage and processing of time intervals, everything is simple: their value does not depend on the time zone, so there are no special recommendations here.  They can be stored and transmitted as the number of units of time (integer or floating point, depending on the required accuracy).  If second accuracy is important, then how is the number of seconds, if millisecond, then how is the number of milliseconds, etc. <br><br>  But the calculation of the interval can have pitfalls.  Suppose we have a typical C # code that counts the time interval between two events: <br><br><pre><code class="hljs sql">DateTime <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> = DateTime.Now; //... DateTime <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = DateTime.Now; double hours = (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>).TotalHours;</code> </pre> <br>  At first glance, there are no problems here, but this is not so.  Firstly, there may be problems with unit testing of such code, but we'll talk about this a little later.  Secondly, let's imagine that the initial moment of time fell on winter time, and the final one - on summer time (for example, the number of working hours is measured in this way, and the workers have a night shift). <br><br>  Suppose the code works in a time zone in which daylight saving time in 2016 occurs on the night of March 27, and simulate the situation described above: <br><br><pre> <code class="hljs sql">DateTime <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> = DateTime.Parse(<span class="hljs-string"><span class="hljs-string">"2016-03-26T20:00:15+02"</span></span>); DateTime <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = DateTime.Parse(<span class="hljs-string"><span class="hljs-string">"2016-03-27T05:00:15+03"</span></span>); double hours = (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>).TotalHours;</code> </pre><br>  This code will result in 9 hours, although in fact between these moments 8 hours have passed.  You can easily see this by changing the code like this: <br><br><pre> <code class="hljs sql">DateTime <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> = DateTime.Parse(<span class="hljs-string"><span class="hljs-string">"2016-03-26T20:00:15+02"</span></span>).ToUniversalTime(); DateTime <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> = DateTime.Parse(<span class="hljs-string"><span class="hljs-string">"2016-03-27T05:00:15+03"</span></span>).ToUniversalTime(); double hours = (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>).TotalHours;</code> </pre><br>  Hence the conclusion - <b>any arithmetic operations with date and time must be done using either UTC values ‚Äã‚Äãor types that store time zone information</b> .  And then translate back to local if necessary.  From this point of view, the original example is easy to fix by changing DateTime.Now to DateTime.UtcNow. <br><br>  This nuance does not depend on a particular platform or language.  Here is a similar Java code that has the same drawback: <br><br><pre> <code class="java hljs">LocalDateTime start = LocalDateTime.now(); <span class="hljs-comment"><span class="hljs-comment">//... LocalDateTime end = LocalDateTime.now(); long hours = ChronoUnit.HOURS.between(start, end);</span></span></code> </pre><br>  It is also easily fixed - for example, using ZonedDateTime instead of LocalDateTime. <br><br><a name="4"></a><h2>  Scheduled events schedule </h2><br>  Schedule scheduled events - a more difficult situation.  There is no universal type allowing storing timetables in standard libraries.  But such a task does not arise so rarely, so ready-made solutions can be found without problems.  A good example is the cron scheduler format, which is used in one form or another by other solutions, for example, Quartz: <a href="http://quartz-scheduler.org/api/2.2.0/org/quartz/CronExpression.html">http://quartz-scheduler.org/api/2.2.0/org/quartz/CronExpression.html</a> .  It covers almost all scheduling needs, including variants of the second Friday of the month. <br><br>  In most cases, writing your scheduler does not make sense, since there are flexible time-tested solutions, but if for some reason you need to create your own mechanism, then at least the schedule format can be borrowed from cron. <br><br><a name="5"></a><h2>  General recommendations </h2><br>  In addition to the above recommendations on the storage and processing of different types of time, there are several others that I would also like to say. <br><br>  First, about using static class members to get the current time - DateTime.UtcNow, ZonedDateTime.now (), etc.  As it was said, using them directly in the code can seriously complicate unit testing, since without special framework frameworks it is impossible to replace the current time.  Therefore, if you plan to write unit tests, you should make sure that the implementation of such methods can be replaced.  To solve this problem, there are at least two ways: <br><br><ul><li>  Highlight the IDateTimeProvider interface with a single method that returns the current time.  Then add a dependency on this interface in all code points where you need to get the current time.  With normal program execution, a ‚Äúdefault‚Äù implementation will be injected into all these places, which returns the actual current time, and in unit tests any other necessary implementation will be injected.  This method is the most flexible in terms of testing. </li><li>  Make your own static class with a method to get the current time and the ability to install any implementation of this method from the outside.  For example, in the case of C # code, this class may expose the UtcNow property and the SetImplementation method (Func &lt;DateTime&gt; impl).  Using a static property or method to get the current time eliminates the need to explicitly assign dependencies on an additional interface everywhere, but from the point of view of OOP principles, this is not an ideal solution.  However, if for some reasons the previous version does not fit, then you can use this. </li></ul><br>  An additional problem that should be solved during the transition to its implementation of the current time provider is the control that no one ‚Äúin the old manner‚Äù continues to use standard classes.  This problem is easily solved in most code quality control systems.  In essence, it boils down to searching for an ‚Äúundesirable‚Äù substring in all files except where the default implementation is declared. <br><br>  The second thing about getting the current time is that you <b>can't trust the customer</b> .  The current time on users' computers can be very different from the real one, and if there is logic tied to it, then this difference can spoil everything.  All places where there is a need to get the current time should, if possible, be performed on the server side.  And, as mentioned earlier, all arithmetic operations with time must be performed either in UTC values ‚Äã‚Äãor using types that store time zone offsets. <br><br>  And one more thing I wanted to mention is the <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601 standard</a> , which describes the date and time format for exchanging information.  In particular, the string representation of the date and time used in serialization must conform to this standard to prevent potential compatibility problems.  In practice, it is extremely rare to have to implement the formatting itself, so the standard itself can be useful mainly for informational purposes. </div><p>Source: <a href="https://habr.com/ru/post/278527/">https://habr.com/ru/post/278527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278511/index.html">Third Beta Candidate - Vivaldi 1.0.403.20</a></li>
<li><a href="../278513/index.html">Meet linear models</a></li>
<li><a href="../278519/index.html">March 8, moms and programming</a></li>
<li><a href="../278521/index.html">Informational messages in 1C. How can I do that</a></li>
<li><a href="../278523/index.html">The threshold for entry into Angular 2 - theory and practice</a></li>
<li><a href="../278533/index.html">(La) TeX on Habrahabr</a></li>
<li><a href="../278535/index.html">libuniset2 is a library for creating ACS. It is better to see once ... Part 1</a></li>
<li><a href="../278537/index.html">libuniset2 is a library for creating ACS. It is better to see once ... Part 2 (Running the simulator)</a></li>
<li><a href="../278539/index.html">Preparing for the CISA exam. Business Continuity Practices</a></li>
<li><a href="../278541/index.html">We invite you to a round table on gaming industry trends.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>