<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From Oracle yes to Postgres</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It just so happens that with Oracle our organization has been working for a long time and tightly. I myself became acquainted with Oracle Database at ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From Oracle yes to Postgres</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/e23/3ac/7ff/e233ac7ffe814a80a9f360c443b45aa0.jpg">  It just so happens that with Oracle our organization has been working for a long time and tightly.  I myself became acquainted with Oracle Database at the time of version 6 and, since then, have not experienced any discomfort.  All spoiled market relations.  Recently, we began to notice that the Customer looks at our projects much more favorably if they use free <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D1%2583%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B1%25D0%25B0%25D0%25B7%25D0%25B0%25D0%25BC%25D0%25B8_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">DBMS</a> .  On the porting of one of these projects my story will be ... <br><a name="habracut"></a><br>  The choice of a free DBMS was, for me, a long and difficult affair, but, in the end, came down to two well-known alternatives.  <a href="https://ru.wikipedia.org/wiki/PostgreSQL">PostgreSQL</a> attracted rich (and still evolving) functionality, while <a href="https://ru.wikipedia.org/wiki/MySQL">MySQL was</a> luring performance and ‚Äúzero‚Äù administration.  Since Oracle has spoiled us and we all knew and loved <a href="https://ru.wikipedia.org/wiki/SQL">SQL</a> , numerous and new-fangled <a href="https://ru.wikipedia.org/wiki/NoSQL">NoSQL</a> variants disappeared back in the semi-finals. <br><br>  It is difficult to say which of the DBMS I would end up with if it weren‚Äôt for one shabashka that gave me the opportunity to touch both PostgreSQL and MySQL live, slowly comparing them and making, in my opinion, a well-grounded decision.  In addition to the functionality, of course, compared and performance.  I will not tell the details, but one of the principal moments of ‚Äúshabashki‚Äù was the ability to quickly and reliably ( <a href="https://ru.wikipedia.org/wiki/ACID">ACID</a> , yes) insert a large number of records into the database.  On this topic and the test was conducted: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ca9/c21/525/ca9c2152598b4505829addb71bd757ec.PNG"></div><br>  The ordinate axis defers the number of records of fixed length, stored in the database every second.  The number in the "legend" means the size of the transaction.  It should be noted here that MySQL was measured "as is", and PostgreSQL using a small <a href="http://habrahabr.ru/post/177957/">patch</a> that provided the ability to work with <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">partitioned tables</a> and <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">materialized views that I was used to</a> .  Since it was a question of ‚Äúsafe‚Äù storage, <a href="https://ru.wikipedia.org/wiki/MyISAM">MyISAM</a> on the graph is presented solely for the sake of completeness and understanding of where the ‚Äútheoretical maximum‚Äù of the desired performance on the used hardware is located. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since the testing itself was carried out for a long time and no <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B2%25D0%25B5%25D1%2580%25D0%25B4%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BD%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BF%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C">SSD</a> on the available iron even smelled, the absolute values ‚Äã‚Äãshown in the graph should not be treated as a dogma.  Of course, you can save data even faster, but I was interested in the performance ratio of various DBMS that worked in (almost) the same conditions.  It came as a surprise to me that PostgreSQL, even weighted by partitioning triggers, works almost as fast as MySQL using <a href="https://ru.wikipedia.org/wiki/InnoDB">InnoDB</a> , and on large transactions (1000 records and more) it starts to catch up with MyISAM! <br><br>  As you can easily guess, the graph shown above finally convinced me that I should switch to PostgreSQL.  Re-creating tables with overriding column types (number in numeric and integer, varchar2 in varchar and text ...) was trivial.  <a href="https://ru.wikipedia.org/wiki/XML">XML</a> and <a href="https://ru.wikipedia.org/wiki/XSLT">XSLT</a> helped in data transfer. <br><br><div class="spoiler">  <b class="spoiler_title">About the benefits of XML</b> <div class="spoiler_text">  Strictly speaking, XML helped even earlier.  One of the features of our product is storing in the database descriptions of business entities in the form of ordinary tabular data (I do not think that it is very original in this).  Comparing such ‚Äúmetadata‚Äù for two different schemes was a real headache, until I wrote a small package that unloads them into XML descriptions.  Sorting tags inside descriptions allowed comparing them as ordinary text files.  XSLT has added a picture, having provided automatic generation of SQL scripts from files of descriptions. <br></div></div><br>  It remains to ensure the operability of all SQL-code written for Oracle.  Most of the requests worked, some earned after minor cosmetic changes.  First of all, I created a <a href="http://en.wikipedia.org/wiki/DUAL_table">dual</a> table: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> dual ( x <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> dual(x) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'x'</span></span>);</code> </pre> <br>  Not that it was impossible to do without it, but in our queries it was used so often that it was simply inappropriate to rewrite them.  In order for PostgreSQL to be ‚Äúsatisfied,‚Äù we had to add more strictness to queries: <br><br><div class="spoiler">  <b class="spoiler_title">Oracle version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> b.id <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, b.name <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> list_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_obj_list_value <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> list_value ), acme_list_value b <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b.id = list_value</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">PostgreSQL version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> b.id <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, b.name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> list_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_obj_list_value <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> list_value ) a, acme_list_value b <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b.id = a.list_value</code> </pre><br></div></div><br>  All <a href="http://www.orafaq.com/wiki/Inline_view">inline view</a> must be named, and it is highly desirable to use the ' <b>as</b> ' keyword in front of column aliases.  For most columns, it can be omitted, but when using names like 'name' or 'value', this leads to an error.  The next step was to replace the platform-specific code with the corresponding constructs supported in both Oracle and PostgreSQL.  We are talking about <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions105.htm">nvl</a> and <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions040.htm">decode</a> , as well as the outdated syntax of the <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/queries006.htm">external connection</a> .  The first two are easily replaced with standard (and more flexible) <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/functions023.htm">coalesce</a> and <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/expressions004.htm">case</a> , in the case of using an external connection, the query should be rewritten: <br><br><div class="spoiler">  <b class="spoiler_title">Oracle version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ot.name, mv.str_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_object o, acme_meta_value mv, acme_obj_type ot <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.id = :object_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ot.id = o.obj_type_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> mv.owner_id(+) = ot.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> mv.param_id(+) = <span class="hljs-number"><span class="hljs-number">9520</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">PostgreSQL version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ot.name, mv.str_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_object o <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_meta_value mv <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (mv.owner_id = ot.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> mv.param_id = <span class="hljs-number"><span class="hljs-number">9520</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_obj_type ot <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (ot.id = o.obj_type_id) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.id = :object_id</code> </pre><br></div></div><br>  <a href="http://oracle-base.com/articles/9i/ansi-iso-sql-support.php">ANSI Join is</a> supported by Oracle from version 9 and, in my opinion, is more convenient (although less concise) than the outdated version using <b>(+)</b> .  You should not try to combine different forms of connection in a single SQL query.  If we used outer join, then for inner joints it is quite logical to use <a href="http://www.orafaq.com/wiki/Inner_join">inner join</a> , rather than listing the tables in the <b>from</b> phrase, separated by commas. <br><br>  The main part of the work on the migration of SQL-code was associated with the rewriting of hierarchical queries.  The <a href="http://www.adp-gmbh.ch/ora/sql/connect_by.html">connect by</a> phrase in PostgreSQL is naturally not supported.  Meanwhile, there were a large number of requests of the following form: <br><br><div class="spoiler">  <b class="spoiler_title">An example of using a hierarchical query</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> t.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_object t, acme_obj_ref_value rv <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> rv.object_id = t.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rv.attr_id = <span class="hljs-number"><span class="hljs-number">220102</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rv.ref_value = :object_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.obj_type_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ot.id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_obj_type ot <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">prior</span></span> ot.id = ot.parent_id <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ot.id = <span class="hljs-number"><span class="hljs-number">200335</span></span> )</code> </pre><br></div></div><br>  A simple rewriting of such queries using <a href="http://en.wikipedia.org/wiki/Hierarchical_and_recursive_queries_in_SQL">CTE</a> would not allow them to become platform-independent.  Although Oracle (starting with version 11.2) <a href="http://citforum.ru/database/oracle/recursive/">supports</a> recursive queries, their syntax differs from that used in <a href="http://www.postgresql.org/docs/9.2/static/queries-with.html">PostgreSQL</a> .  In particular, in PostgreSQL, the use of the recursive keyword is mandatory, but Oracle does not "understand" it.  Fortunately, in most cases, the hierarchical part of the request could be ‚Äúhidden‚Äù in the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25B1%25D0%25B0%25D0%25B7%25D1%258B_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">view</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Oracle version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> acme_arm(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ot.id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_obj_type ot <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">prior</span></span> ot.id = ot.parent_id <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ot.id = <span class="hljs-number"><span class="hljs-number">200335</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">PostgreSQL version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> acme_arm(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">recursive</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_obj_type <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">200335</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_obj_type a <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (t.id = a.parent_id) ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t</code> </pre><br></div></div><br>  Rewriting the <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_9016.htm">merge</a> operators turned out to be more ‚Äúpuzzling‚Äù (fortunately, they were not used as often as hierarchical queries).  PostgreSQL does not support this operator, but it does support the use of the <b>from</b> and <b>returning phrases</b> in the <b>update</b> statement, the latter returning a full resultset (similar to the <b>select</b> statement), which allows it to be used in the <b>with</b> phrase.  I'll just leave it here: <br><br><div class="spoiler">  <b class="spoiler_title">Oracle version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> acme_obj_value d <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> object_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_state_tmp ) s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (d.object_id = s.object_id) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-keyword"><span class="hljs-keyword">matched</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> d.date_value = <span class="hljs-keyword"><span class="hljs-keyword">least</span></span>(l_dt, d.date_value) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">matched</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> (d.id, d.object_id, d.date_value) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (acme_param_sequence.nextval, s.object_id, l_dt)</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">PostgreSQL version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> object_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_state_tmp ), upd <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> acme_obj_value <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> date_value = <span class="hljs-keyword"><span class="hljs-keyword">least</span></span>(l_dt, d.date_value) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> acme_obj_value.object_id = s.object_id <span class="hljs-keyword"><span class="hljs-keyword">returning</span></span> acme_obj_value.object_id ) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> acme_obj_value(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, object_id, date_value) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nextval</span></span>(<span class="hljs-string"><span class="hljs-string">'acme_param_sequence'</span></span>), s.object_id, l_dt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> s.object_id <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> object_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> upd)</code> </pre><br></div></div><br>  In this example, you can see that working with <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28310/views002.htm">sequences</a> in PostgreSQL is also different from Oracle.  Of course, in Oracle, it was possible to define a function similar to the one that gets the values ‚Äã‚Äãfrom sequences in PostgreSQL, but rewriting the Oracle code (as well as the Java code) could be avoided.  In addition, this approach could be associated with additional overhead. <br><br>  A lot of joy brought work with <a href="http://www.postgresql.org/docs/9.2/static/functions-datetime.html">date and time</a> .  The fact is that the type of <a href="http://psoug.org/reference/date_func.html">date</a> commonly used in Oracle accustomed to some negligence in dealing with its values.  We can assume that such a value is a number, the integer part determines the number of days elapsed from a certain ‚Äúmagic‚Äù date, and the fractional one defines the time, to the nearest second.  After some getting used to (as with most features of Oracle), this is quite convenient, but PostgreSQL is much stricter with regard to data types. <br><br><pre> <code class="sql hljs">date '2001-09-28' + interval '1 hour'</code> </pre><br>  Thus, you can add a constant interval to the date, but what if you need to add a variable value?  The search expression is not at all obvious: <br><br><pre> <code class="sql hljs">date '2001-09-28' + (to_char(p_hours, '99') || ' hour')::interval</code> </pre><br>  Space in the line before the ' <b>hour</b> ' is required!  Also, it can be noted that the rigor of PostgreSQL extends to the conversion of numeric values ‚Äã‚Äãto string values ‚Äã‚Äã(and vice versa, of course).  The mask is required, even if it consists of some nines.  Implicit conversions, so familiar after working with Oracle, do not work. <br><br>  The remaining requests have undergone less radical changes.  The revision required all the code working with strings, simply because the corresponding functions in <a href="http://psoug.org/reference/string_func.html">Oracle</a> and <a href="http://www.postgresql.org/docs/9.2/static/functions-string.html">PostgreSQL</a> look different.  The <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28286/pseudocolumns009.htm">rownum</a> column, where it still remained, had to be replaced with windowed <a href="http://www.postgresql.org/docs/9.2/static/functions-window.html">row_number ()</a> .  In cases where the condition on rownum was used to limit the number of rows to be displayed, requests were overwritten using the phrase <a href="http://www.postgresql.org/docs/9.2/static/queries-limit.html">limit</a> . <br><br>  We should also talk about table functions.  And in <a href="http://docs.oracle.com/cd/B28359_01/appdev.111/b28425/pipe_paral_tbl.htm">Oracle</a> and <a href="http://www.postgresql.org/docs/9.2/static/functions-srf.html">PostgreSQL</a> they are.  The implementation is different, of course, but referring to them from the SQL query looks similar.  Unfortunately, as in the case of the recursive CTE, everything is spoiled by the presence of one keyword: <br><br><div class="spoiler">  <b class="spoiler_title">Oracle version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(acme_table_fuction(...))</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">PostgreSQL version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_table_fuction(...)</code> </pre><br></div></div><br>  It remains to deal with the <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_6006.htm">packages</a> .  There is no such thing in PostgreSQL, but upon closer inspection, it turns out that it doesn‚Äôt really need it.  Indeed, why are packages in Oracle?  If we set aside global variables and initialization code (which we do not use), the main advantage of packages is that they break dependency chains.  When changing database objects, only implementations of dependent packages are invalidated, but not their headers.  The ability to make recursive calls inside packets is one consequence of this fact. <br><br>  In PostgreSQL, the dependency mechanism is not implemented.  Recursive calls to stored functions (there are no procedures in PostgreSQL) are also in order.  In order to make the client code have to make a minimum of changes, it is enough to ensure only the appearance of the fact that we continue to work with packages.  PostgreSQL schemas are perfect for this.  Of course, in such a ‚Äúpackage‚Äù, it will not be possible to implement ‚Äúprivate‚Äù functions, but this is not a very big problem.  Here's what the code will look like: <br><br><div class="spoiler">  <b class="spoiler_title">Package emulation in PostgreSQL</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> acme_utils.get_str_res(<span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> acme_utils.c_str_res_ot(); <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> acme_utils.c_str_res_id_attr(); <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> acme_utils; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> acme_utils; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> acme_utils.c_str_res_ot() <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20069</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; $$ language plpgsql IMMUTABLE; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> acme_utils.c_str_res_id_attr() <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">20070</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; $$ language plpgsql IMMUTABLE; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> acme_utils.get_str_res(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> p_res_id <span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> res <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.name <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_object o <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_obj_value rid <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (rid.object_id = o.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rid.attr_id = acme_utils.c_str_res_id_attr()) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.obj_type_id = acme_utils.c_str_res_ot() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rid.num_value = p_res_id; return res; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; $$ language plpgsql STABLE;</code> </pre><br></div></div><br>  The need to remove all objects before the ‚Äúre-creation‚Äù of the scheme is a bit tiring, but you can live.  You can see in the text the unusual word ' <b><a href="http://www.postgresql.org/docs/9.2/static/plpgsql-statements.html">strict</a></b> '.  It provides familiar Oracle behavior when trying to fetch zero or more than one record.  Among other memorable moments, I can mention a <a href="http://www.postgresql.org/docs/9.2/static/plpgsql-statements.html">strange construction</a> that calculates the number of rows modified by the last query: <br><br><div class="spoiler">  <b class="spoiler_title">Oracle version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> acme_resource_tmp(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, device_id, profile_id, owner_id, type_id, res_num, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> acme_main_sequence.nextval, t.device_id, t.profile_id, r.id, p.type_id, t.num, t.value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_state_tmp t <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_profile_detail p <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (p.profile_id = t.profile_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p.param_id = t.param_id) <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_resource r <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (r.device_id = t.device_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r.owner_id <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>); l_ic := sql%rowcount;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">PostgreSQL version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> acme_resource_tmp(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, device_id, profile_id, owner_id, type_id, res_num, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nextval</span></span>(<span class="hljs-string"><span class="hljs-string">'acme_main_sequence'</span></span>), t.device_id, t.profile_id, r.id, p.type_id, t.num, t.value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_state_tmp t <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_profile_detail p <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (p.profile_id = t.profile_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p.param_id = t.param_id) <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_resource r <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (r.device_id = t.device_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r.owner_id <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>); get diagnostics l_ic = row_count;</code> </pre><br></div></div><br>  Of course, the implementation of all packages had to be rewritten, since there were not so many of them.  From my previous narration, it can be understood that the entire rewritten SQL code is divided into three categories: <br><br><ol><li>  Requests that by small rewriting were able to lead to a platform-independent form </li><li>  Queries that managed to hide platform-specific fragments in views </li><li>  Certainly platform-specific code </li></ol><br>  There are no difficulties with the first two.  The latter category may cause some problems if platform-specific constructs are present in queries generated by the client.  The point is that you don't want to rewrite Java code.  Even less desire to divide the source into two versions, working with different DBMS.  Unfortunately, it was not possible to completely eliminate platform-dependent constructs from client code.  For the most part, the <b>table</b> keyword in table function queries interfered.  There were also references to sequences and some hierarchical queries. <br><br>  It was decided to store all platform-dependent queries in the database, loading them into the program cache, at the first call.  Initially it was assumed that each of the databases would store their versions of queries, but it turned out to be more convenient to store queries at the same time for all used DBMS.  In Oracle, the <a href="http://docs.oracle.com/javadb/10.10.1.2/ref/rrefclob.html">CLOB</a> field was used to store query text, while in PostgreSQL, <a href="http://www.postgresql.org/docs/9.2/static/datatype-character.html">text was used</a> .  To ensure consistency, the CLOB to varchar2 conversion was used, which <a href="https://docs.oracle.com/cd/B28359_01/server.111/b28320/limits001.htm">limited the</a> maximum request size to 4000 characters (one request did get out of this size, but since it was intended for the PostgreSQL version, it was not necessary to ‚Äúcompress‚Äù it).  The <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions179.htm">to_char</a> transformation <a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions179.htm">itself</a> had to be hidden using the view: <br><br><div class="spoiler">  <b class="spoiler_title">Oracle version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> acme_query(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.name, to_char(c.clob_value) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_object a <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_obj_list_value b <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (b.object_id = a.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.attr_id = <span class="hljs-number"><span class="hljs-number">10061</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_obj_value c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (c.object_id = a.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.attr_id = <span class="hljs-number"><span class="hljs-number">10062</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.obj_type_id = <span class="hljs-number"><span class="hljs-number">10004</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.list_value = <span class="hljs-number"><span class="hljs-number">10061</span></span>;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">PostgreSQL version</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> acme_query(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.name, c.clob_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> acme_object a <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_obj_list_value b <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (b.object_id = a.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.attr_id = <span class="hljs-number"><span class="hljs-number">10061</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> acme_obj_value c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (c.object_id = a.id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.attr_id = <span class="hljs-number"><span class="hljs-number">10062</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.obj_type_id = <span class="hljs-number"><span class="hljs-number">10004</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.list_value = <span class="hljs-number"><span class="hljs-number">10062</span></span>;</code> </pre><br></div></div><br>  Summarizing, I can say that the work was not so terrible as it seemed at the beginning.  Most of it was related to rewriting hierarchical queries and Oracle packages, and most of the problems were related to more strict SQL syntax and the absence of the usual implicit conversions in PostgreSQL.  The scope of work could be less if we initially used more strict and platform-independent code in Oracle. <br><br></div><p>Source: <a href="https://habr.com/ru/post/216057/">https://habr.com/ru/post/216057/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216043/index.html">Webinar Recording - Microsoft 70-410 Exam Preparation and Webinar 70-411 Invitation</a></li>
<li><a href="../216047/index.html">Using Redis EXPIRE to Track Rails Online Audiences</a></li>
<li><a href="../216049/index.html">Concurrency: 6 ways to live with shared state</a></li>
<li><a href="../216051/index.html">Sony PlayStation 4: Human Tested</a></li>
<li><a href="../216055/index.html">The German company is developing self-learning manipulators a la "Doc Ock"</a></li>
<li><a href="../216059/index.html">iToilet. Office toilet is free</a></li>
<li><a href="../216063/index.html">Adaptation of Microsoft Project Server 2010 to the specifics of the company's project management system</a></li>
<li><a href="../216065/index.html">Conference Runet 2014</a></li>
<li><a href="../216067/index.html">PostgreSQL feature highlight: the rapid transformation of the old master in the stand-by with pg_rewind</a></li>
<li><a href="../216069/index.html">Google has released a new version of Google Play (4.6.16) with a new password protection option against uncontrolled purchases</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>