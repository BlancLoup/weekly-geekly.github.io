<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Static analyzer HuntBugs: check IntelliJ IDEA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As many remember, for a while I developed the FindBugs static bytecode Java analyzer. However, there were so many problems in FindBugs that I decided ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Static analyzer HuntBugs: check IntelliJ IDEA</h1><div class="post__text post__text-html js-mediator-article"><p> As many remember, for a while I developed the FindBugs static bytecode Java analyzer.  However, there were so many problems in FindBugs that I decided that it would be easier to write a new bytecode analyzer.  I haven't very creatively called it HuntBugs.  Development is conducted on <a href="https://github.com/amaembo/huntbugs">GitHub</a> .  It is still in the early development stage, sometimes buggy and covers about 35% of the diagnostics from FindBugs, but at the same time it adds its own interesting pieces.  You can try on your Maven-project using the command <code>mvn one.util:huntbugs-maven-plugin:huntbugs</code> (the report is written in <code>target/huntbugs/report.html</code> ).  Alternatively, you can manually build from the gita and launch the <code>one.util.huntbugs.HuntBugs</code> command line <code>one.util.huntbugs.HuntBugs</code> , which can be used as input to JAR files or directories with .class files. </p><br><p>  Sometime later, when the project is a little older, I will tell about it in more detail.  And in this article I will show you what interesting things HuntBugs found in <a href="https://github.com/JetBrains/intellij-community">IntelliJ IDEA Community Edition</a> .  I downloaded from the official site and installed the latest version of this IDE, and then set HuntBugs on the file <code>lib/idea.jar</code> , in which almost everything lies.  I like to test static analysis on IDEA, because it is an IDE, in which there is a very good static analyzer itself and the developers clearly use it.  It is interesting to see what remains after it. </p><a name="habracut"></a><br><p>  The format of this article is not very different from what <a href="https://habrahabr.ru/company/pvs-studio/blog/">PVS-Studio</a> does: errors, pieces of code, explanations.  Of course, the article included only the most interesting. </p><br><h1>  Field is assigned to itself </h1><br><p>  As a rule, no one admits errors like <code>this.field = this.field</code> , not even the newest IDE usually warns about such.  However, HuntBugs can look a little deeper.  Here is the <a href="">code snippet</a> : </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> myLastOffsetInNewTree; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNewOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ASTNode node)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> optimizedResult = haveNotCalculated; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myLastNode == prev) { ... optimizedResult = myLastOffsetInNewTree; myLastNode = node; myLastOffsetInNewTree = optimizedResult; ... } }</code> </pre> <br><p>  The field <code>myLastOffsetInNewTree</code> loaded into the local variable <code>optimizedResult</code> , and then for some reason again stored in the field, although during this time it could not change.  The last grafting is strange, either it needs to be removed, or something else was meant. </p><br><h1>  An integer value is passed to the rounding method </h1><br><p>  Sometimes there are errors with untimely conversion of integer type to fractional.  Not always it can be caught, but <a href="">here it turned out</a> : </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = icon.getIconWidth(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = icon.getIconHeight(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.ceil((actionButton.getWidth() - width) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.ceil((actionButton.getHeight() - height) / <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  Here, rounding up ( <code>Math.ceil</code> ) is used twice, but the argument in both cases is an integer, since in Java the division of an integer into an integer yields an integer (rounded down).  Probably meant to divide by <code>2.0</code> or otherwise switch to fractional numbers before dividing. <code>(int)Math.ceil</code> current behavior suits you, then <code>(int)Math.ceil</code> should be removed: this part of the code is useless. </p><br><h1>  Switch branch is unreachable due to expression range </h1><br><p>  A very curious <a href="">piece of code</a> , which, apparently, someone once automatically generated, and now no one understands whether this is correct and what should be there: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> state = getState() &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span>; tokenType = fixWrongTokenTypes(tokenType, state); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> do not know when this happens! switch (state) { case __XmlLexer.DOCTYPE: tokenType = XmlTokenType.XML_DECL_START; break; } }</span></span></code> </pre> <br><p>  The <code>__XmlLexer.DOCTYPE</code> is 24, but <code>state = getState() &amp; 0xF</code> is executed above, so the <code>state</code> value can only be from 0 to 15 and the switch branch is not guaranteed to be executed.  Perhaps when the source file of the lexer was changed again, the constants were regenerated with different values, and this file was forgotten to be regenerated.  Anyway, the code is very suspicious, as evidenced by the comment. </p><br><h1>  Synchronization on getClass () rather than class literal </h1><br><p>  This <a href="">fragment of the MatcherImpl class is</a> synchronized to <code>getClass()</code> .  And this is done in a public non-final class, which actually has a <a href="">subclass of Matcher</a> .  As a result, when executing this code from a subclass, synchronization will occur not according to <code>MatcherImpl.class</code> , but according to <code>Matcher.class</code> .  The problem is aggravated by the fact that in the same class there is an <a href="">explicit synchronization</a> on <code>MatcherImpl.class</code> and both critical sections (which may not be mutually exclusive) update the same static field <code>lastMatchData</code> .  As a result, the whole point of synchronization is lost.  Normally <code>synchronized(getClass())</code> is wrong; use the explicit <code>synchronized(MatcherImpl.class)</code> class literal <code>synchronized(MatcherImpl.class)</code> . </p><br><h1>  Exception created and dropped rather than thrown </h1><br><p>  Quite a common error in Java: an exception object was created, but not thrown.  For example, <a href="">here</a> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OperationNotSupportedException(); }</code> </pre> <br><p>  IDEA itself also warns about such situations.  <a href="">Another similar place</a> . </p><br><h1>  Invariant loop condition </h1><br><p>  Here is another <a href="">auto-generated file</a> .  In principle, everything is probably okay, and nothing can be edited, but in hand-written code it would look suspicious: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> r = ...; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value(b, l + <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!empty_element_parsed_guard_(b, <span class="hljs-string"><span class="hljs-string">"json"</span></span>, c)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; c = current_position_(b); }</code> </pre> <br><p>  Here, a cycle with a condition on a local variable <code>r</code> , whose value does not change in a cycle, therefore either we don‚Äôt go into a cycle at all, or we never quit by a condition (only by <code>break</code> ).  If this was really implied, then in such cases it is better to write <code>if(r) { while(true) { ... } }</code> to emphasize the intention to make an infinite loop. </p><br><h1>  The switch operator has identical branches </h1><br><p>  Duplicate branches of the <code>switch</code> sometimes look reasonable, but when there is a large piece of code in them, <a href="">like here</a> , you should take a closer look: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ((((PsiWildcardType)x).isExtends() ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) + (((PsiWildcardType)y).isExtends() ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* ? super T1, ? super T2 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constraints != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; xType != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; yType != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { constraints.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subtype(yType, xType)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> balance(xType, yType, balancer, constraints); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* ? extends T1, ? super T2 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constraints != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; xType != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; yType != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { constraints.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subtype(xType, yType)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> balance(xType, yType, balancer, constraints); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* ? super T1, ? extends T2*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* ? extends T1, ? extends T2*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constraints != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; xType != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; yType != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { constraints.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subtype(xType, yType)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> balance(xType, yType, balancer, constraints); }</code> </pre> <br><p>  Not immediately noticeable, but <code>case 1</code> and <code>case 3</code> exactly the same (and differ from case 0).  If this was meant, it may be wiser to combine <code>case 1</code> and <code>case 3</code> , so that it is easier to read and maintain the code. </p><br><h1>  The same condition is repeatedly checked </h1><br><p>  For some reason, the same condition is checked twice in <a href="">this code</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offsetToScroll &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offsetToScroll &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... } }</code> </pre> <br><p>  Maybe just the internal check should be removed, and maybe something else would be checked.  <a href="">Here is another</a> similar case.  Or <a href="">another</a> interesting case: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> PsiElement &amp;&amp; ((PsiElement)o).isValid() &amp;&amp; ((PsiElement)o).isPhysical() || o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ProjectRootModificationTracker || o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> PsiModificationTracker || o == PsiModificationTracker.MODIFICATION_COUNT || o == PsiModificationTracker.OUT_OF_CODE_BLOCK_MODIFICATION_COUNT || <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;&lt; o == PsiModificationTracker.OUT_OF_CODE_BLOCK_MODIFICATION_COUNT || // &lt;&lt;&lt; o == PsiModificationTracker.JAVA_STRUCTURE_MODIFICATION_COUNT;</span></span></code> </pre> <br><p>  And <a href="">here</a> repeated conditions are not very close and it is even more difficult to notice them: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUPPORTED_TYPES.contains(token) || StdArrangementTokens.Regexp.NAME.equals(token) || StdArrangementTokens.Regexp.XML_NAMESPACE.equals(token) || KEEP.equals(token) || BY_NAME.equals(token) || SUPPORTED_TYPES.contains(token);</code> </pre> <br><p>  The <code>SUPPORTED_TYPES.contains(token)</code> checked twice.  Of course, HuntBugs carefully watches so that nothing changes between these conditions.  If in intermediate conditions <code>token</code> reassigned, such a construction would have the right to exist. </p><br><h1>  Numeric comparison is always true or false </h1><br><p>  <a href="">Here</a> is just a redundant check rather than a real error: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = myPanels.length; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Dimension preferredSize = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.getPreferredSize(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; size &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> preferredSize; }</code> </pre> <br><p>  The <code>size</code> variable contains the length of the array, which can never be negative.  It is not clear why to check <code>size &gt;= 0</code> .  Even if there is no error, I believe that such checks should be deleted, because they confuse the reader.  It is not known if the author may have meant <code>size &gt; 0</code> , then this is a mistake. </p><br><h1>  Chain of private methods is never called </h1><br><p>  Typically, IDEs easily find private methods that are never invoked, and offer to remove them.  But <a href="">such a case</a> is not always determined: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonSchemaObject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JsonSchemaObject current, String name)</span></span></span><span class="hljs-function"> </span></span>{ JsonSchemaObject schema = current.getProperties().get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (schema != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schema; schema = getChildFromList(name, current.getAnyOf()); <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;&lt; if (schema != null) return schema; ... } @Nullable private static JsonSchemaObject getChildFromList(String name, List&lt;JsonSchemaObject&gt; of) { if (of == null) return null; JsonSchemaObject schema; for (JsonSchemaObject object : of) { schema = getChild(object, name); // &lt;&lt;&lt; if (schema != null) return schema; } return null; }</span></span></code> </pre> <br><p>  These two private methods call each other recursively, but nobody calls them outside.  HuntBugs sees this situation and says that both methods are not really used. </p><br><h1>  Useless String.substring (0) </h1><br><p>  Honestly, I did not expect to see such a diagnosis in the production code, it is too trivial.  But no, there are also <a href="">trivial errors</a> : </p><br><pre> <code class="java hljs">String str = (String)value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.startsWith(<span class="hljs-string"><span class="hljs-string">"\""</span></span>)) { str = str.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>); str = StringUtil.trimEnd(str, <span class="hljs-string"><span class="hljs-string">"\""</span></span>); }</code> </pre> <br><p>  Apparently, the author meant to delete the first character of a string, but for some reason, he wrote not <code>substring(1)</code> , but <code>substring(0)</code> (this call simply returns the original string).  This is the second case (in addition to the dropped exception), when IDEA itself also highlights the problem area. </p><br><h1>  Result of integer multiplication promoted to long </h1><br><p>  This warning does not always lead to real danger, but nevertheless I want to <a href="">set an example</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> length = myIndexStream.length(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> totalCount = length / INDEX_ENTRY_SIZE; <span class="hljs-comment"><span class="hljs-comment">// INDEX_ENTRY_SIZE = 26 for(int i=0; i&lt;totalCount; i++) { final long indexOffset = length - (i + 1) * INDEX_ENTRY_SIZE;</span></span></code> </pre> <br><p>  First, it is already suspicious that the loop variable is of type <code>int</code> , and not <code>long</code> (it is possible that a separate diagnosis should be made for such a situation).  If totalCount exceeds 2 <sup>31</sup> , then the loop will never end.  But all right, this is only possible with a length of index length greater than 52 gigabytes, which is still quite a lot.  However, the problems in this code will begin at a length of more than 2 gigabytes.  Since <code>i</code> and <code>INDEX_ENTRY_SIZE</code> are of type <code>int</code> , multiplication will be performed on 32-bit signed integers and successfully overflow.  Already after this, the result of the multiplication will be reduced to <code>long</code> and after performing the subtraction, the offset may well be more length.  Probably, such large caches have never been there, but it will be unpleasant when they appear.  The fix is ‚Äã‚Äãsimply to declare the <code>long</code> loop variable. </p><br><h1>  And what about Kotlin? </h1><br><p>  It is known that the IntelliJ IDEA part is written in Kotlin, which is also compiled into Java bytecode.  Static bytecode analyzers can formally analyze any language, but in fact, if the analyzer is sharpened in Java, then there will be a lot of false positives for other languages.  Often they are taken because the language compiler generates some specific constructions (for example, implicit checks).  Sometimes, however, such a false trigger is a reason to get accustomed to the compiler code generator.  For example, the <code>com.intellij.configurationStore.FileBasedStorageKt</code> class.  In the class itself there is the <a href="">following line</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val XML_PROLOG = <span class="hljs-string"><span class="hljs-string">"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"</span></span>.toByteArray()</code> </pre> <br><p>  In the <code>java.lang.String</code> class, the <code>toByteArray()</code> method is <code>toByteArray()</code> known to be known.  This is Kotlin's <a href="">extension-method</a> , and the inline-method (which the compiler embeds directly at the place of use), by default it executes <code>String.getBytes(Charsets.UTF_8)</code> .  Let's see what this line was compiled in Kotlin.  I will not show directly baytkod, and I will transform it to more clear code on Java: </p><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"</span></span>; Charset charset = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mask = <span class="hljs-number"><span class="hljs-number">1</span></span>; Object obj = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//         ‚Äî    //  - nop -   if(obj != null) { throw new UnsupportedOperationException("Super calls with default arguments not supported in this target, function: toByteArray"); } if(mask &amp; 1 == 0) { charset = kotlin.text.Charsets.UTF_8; } //   - nop XML_PROLOG = kotlin.jvm.internal.Intrinsics.checkExpressionValueIsNotNull(((String)str).getBytes(charset), "(this as java.lang.String).getBytes(charset)");</span></span></code> </pre> <br><p>  It can be seen that the line has grown incredibly.  The variable <code>mask</code> is associated with the transfer of the default parameter (Dmitry Jemerov told about this at JPoint - see <a href="http://javapoint.ru/presentation/day_1/track_4/KotlinBytecodePerformance-2016-04-22-JPoint.pdf">slide 40 and below</a> . Here, obviously, a lot of excess, and HuntBugs rightly swears at <code>obj != null</code> (comparing <code>null</code> with <code>null</code> ), and <code>mask &amp; 1</code> Although the author of the code is absolutely not guilty, I suppose, over time, Kotlin's compiler will be smarter and will generate less garbage. </p><br><h1>  Conclusion </h1><br><p>  Here you can write a plain text about the importance of static analysis, which <a href="https://habrahabr.ru/users/andrey2008/" class="user_link">Andrey2008</a> and his colleagues write after their articles, but you <a href="https://habrahabr.ru/users/andrey2008/" class="user_link">already</a> know everything.  Interestingly, even in the code that is developed using static analysis, we managed to find a lot of suspicious places just by checking it with a new tool.  Of course, not everything got into the article.  In addition to false triggers, there are quite a few messages important, but boring.  Many messages about performance.  For example, string concatenation in a loop is 59 pieces.  Or bypassing Map values ‚Äã‚Äãthrough <code>keySet()</code> + <code>get()</code> , when faster through <code>values()</code> is 18 pieces.  A large number of potential problems with multithreading.  Let's say nonatomic volatile updates are 50 pieces.  Or suspicious <code>wait()</code> / <code>notify()</code> usage scenarios - 8 pieces. </p><br><p>  Use static analysis and follow the news! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/301626/">https://habr.com/ru/post/301626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301616/index.html">Email marketing for cloud service</a></li>
<li><a href="../301618/index.html">Lean is a real topic, a buzzword or a natural opportunity to make money. Or at least not lose</a></li>
<li><a href="../301620/index.html">Optical Networks: A New Stage of Internet Development</a></li>
<li><a href="../301622/index.html">Project.json changes</a></li>
<li><a href="../301624/index.html">New virtual servers OVH in comparison with domestic state employees</a></li>
<li><a href="../301628/index.html">I have long wanted to tell you something</a></li>
<li><a href="../301632/index.html">How Microsoft implemented Yammer (Part I)</a></li>
<li><a href="../301636/index.html">Add dependencies to CDI. Part 1</a></li>
<li><a href="../301640/index.html">IPython notebook data processing for SEO tasks</a></li>
<li><a href="../301642/index.html">Positive Hack Days VI WAF Bypass Contest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>