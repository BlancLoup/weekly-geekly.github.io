<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>delete, new [] in C ++ and urban legends about their combination</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If in C ++ code an array of objects was created with the help of ‚Äúnew []‚Äù, you should delete this array with the help of ‚Äúdelete []‚Äù and in no case wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>delete, new [] in C ++ and urban legends about their combination</h1><div class="post__text post__text-html js-mediator-article">  If in C ++ code an array of objects was created with the help of ‚Äúnew []‚Äù, you should delete this array with the help of ‚Äúdelete []‚Äù and in no case with the help of ‚Äúdelete‚Äù (without parentheses).  A reasonable question: not what? <br><br>  This question can get a wide range of unreasonable answers.  For example, ‚Äúonly the first object will be deleted, the rest will leak‚Äù or ‚Äúonly the first object‚Äôs destructor will be called‚Äù.  The following "explanations" usually do not stand any serious criticism. <br><br>  In accordance with the C ++ Standard, the behavior is undefined in this situation.  All assumptions are nothing more than popular urban legends.  Let us examine in detail why. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will need a cunning plan with an example that would confound the supporters of urban legends.  Here is such a harmless will be ok: <br><br><blockquote><pre> <code class="hljs pgsql"><code class="cpp"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: ~<span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>() { printf( "Class::~Class()" ); } }; <span class="hljs-type"><span class="hljs-type">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code></code> </pre></blockquote><br>  There is only one object in the array.  If you believe any of the two legends above, ‚Äúeverything will be fine‚Äù - there is nothing to leak and nowhere, destructors will be called exactly as needed. <br><br>  Go to codepad.org, paste the code into the form, we get the output: <br><br><pre>  memory clobbered before allocated block
 Exited: ExitFailure 127
 42 75 67 20 61 73 73 61 73 73 69 6E 20 77
 61 6E 74 65 64 20 2D 20 77 77 77 2E 61 62
 62 79 79 2E 72 75 2F 76 61 63 61 6E 63 79
</pre><br>  MEMORY WHAT ???  What was it? <br><br>  Second example: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre></blockquote><br>  Issuance: <br><br><pre>  No errors or program output. </pre><br>  Here at least everything looks good.  What's happening?  Why it happens?  Why is the behavior different? <br><br>  The reason is what happens inside. <br><br>  When ‚Äúnew Type [count]‚Äù is found in the code, the program must allocate enough memory to store the specified number of objects.  For this, it uses the function "operator new [] ()".  This function allocates memory ‚Äî usually inside just a call to malloc () and checking the return value (if necessary, calling new_handler () and throwing an exception).  Then objects are constructed in the allocated memory - the required number of constructors is called.  The result of "new Type [count]" is the address of the first element of the array. <br><br>  When ‚Äúdelete [] pointer‚Äù appears in the code, the program should destroy all the objects in the array, causing destructors for them.  For this (and only for this) she needs to know the number of elements. <br><br>  The important point: in the construction ‚Äúnew Type [count]‚Äù the number of elements was indicated explicitly, and only the address of the first element receives ‚Äúdelete []‚Äù. <br><br>  Where does the program find out the number of elements?  Since she only has the address of the first element, she must calculate the length of the array based on that address alone.  How this is done depends on the implementation, the following method is usually used. <br><br>  When executing ‚Äúnew Type [count]‚Äù, the program allocates enough memory to fit not only objects, but also an unsigned integer (usually of the size_t type) indicating the number of objects.  This number is written to the beginning of the selected area, then objects are placed.  When compiling "new Type [count]", the compiler inserts code into the program that implements these whistles. <br><br>  So, when executing ‚Äúnew Type [count]‚Äù, the program allocates a little more memory, writes the number of elements to the beginning of the allocated memory block, calls the constructors and returns the address of the first element to the calling code.  The address of the first element will differ from the address returned by the memory allocation function ‚Äúoperator new [] ()‚Äù. <br><br>  When executing ‚Äúdelete []‚Äù, the program takes the address of the first element passed to ‚Äúdelete []‚Äù, determines the address of the beginning of the block (subtracting exactly the same number as was added when executing ‚Äúnew []‚Äù), reads the number of elements from the beginning of the block, calls the required number of destructors, then calls the function ‚Äúoperator delete [] ()‚Äù, passing it the address of the beginning of the block. <br><br>  In both cases, the calling code does not work with the address that was returned by the memory allocation function and later transferred to the memory free function. <br><br>  Now back to the first example.  When ‚Äúdelete‚Äù is executed (without parentheses), the calling code has no idea that it is necessary to play a sequence with an address offset.  Most likely, it calls the destructor of a single object, then passes to the function ‚Äúoperator delete ()‚Äù an address that differs from the previously returned function ‚Äúoperator new [] ()‚Äù. <br><br>  What is going to happen?  In this implementation, the program crashes.  Since the Standard says that behavior is undefined, this is valid. <br><br>  For comparison, the Visual C ++ 9 program by default comes with error messages in the debug version, but it seems to work fine (at least, the _heapchk () function returns _HEAP_OK, _CrtDumpMemoryLeaks () does not issue any messages).  This is also permissible. <br><br>  Why is the behavior different in the second example?  Most likely, the compiler took into account that the type char has a trivial destructor, i.e.  there is no need to do anything to destroy objects, but rather just freeing the memory, therefore, the number of elements should not be stored, which means that you can immediately return the same address returned by the function "operator new [] ()" to the calling code.  No address offsets - just like when calling ‚Äúnew‚Äù (without parentheses).  This behavior of the compiler is fully consistent with the Standard. <br><br>  Something is missing‚Ä¶ <br><br>  Have you already noticed that the functions of allocating and freeing memory with square brackets or without are found above?  These are not typos - they are two different pairs of functions, they can be implemented in completely different ways.  Even when the compiler tries to save money, it always calls the function ‚Äúoperator new [] ()‚Äù when it sees in the code ‚Äúnew Type [count]‚Äù, and always calls the function ‚Äúoperator new ()‚Äù when it sees in the code ‚Äúnew Type‚Äù . <br><br>  Typically, the implementation of the functions ‚Äúoperator new ()‚Äù and ‚Äúoperator new [] ()‚Äù are the same (both cause malloc ()), but they can be replaced - you can define your own, and you can replace both one pair and both, you can also replace these functions separately for any selected class.  The standard allows you to do this as much as you like (of course, you need to adequately replace the pair function of freeing memory). <br><br>  This provides rich opportunities for indefinite behavior.  If your code causes the memory to be released by the ‚Äúwrong‚Äù function, this can lead to any consequences, such as heap corruption, memory corruption, or immediate program termination.  In the first example, the implementation of the ‚Äúoperator delete ()‚Äù function could not manage the address given to it and the program crashed. <br><br>  The most enjoyable part of this story is that you can never argue that using ‚Äúdelete‚Äù instead of ‚Äúdelete []‚Äù (and vice versa, too) leads to some specific result.  The standard says that behavior is undefined.  Even a fully compliant Standard compiler is not required to give you a program with any adequate behavior.  The behavior of the program, to which you will refer in comments and disputes, is only observable - anything can happen inside.  You are just stating the behavior you observe. <br><br>  In the second example, everything looks fine ... on this implementation.  On another implementation, the functions ‚Äúoperator new ()‚Äù and ‚Äúoperator new [] ()‚Äù can be, for example, implemented on different heaps (Windows allows you to create more than one heap per process).  What happens when I try to return a block to the ‚Äúwrong‚Äù pile? <br><br>  By the way, relying on some specific behavior in this situation, you automatically get an intolerable code.  Even if the current implementation of "everything works", when switching to another compiler, changing the version of the compiler, or even updating the C ++ runtime, you may be extremely unpleasantly surprised. <br><br>  How to be?  To accept, not to confuse ‚Äúdelete‚Äù and ‚Äúdelete []‚Äù and most importantly - not to waste time on ‚Äúplausible‚Äù explanations of what allegedly will happen if you mix them up.  While you argue, other developers will do something useful, and you will be more likely to earn the Darwin Award. <br><br>  <i>Dmitry Mescheryakov</i> <i><br></i>  <i>Product Development Department</i> </div><p>Source: <a href="https://habr.com/ru/post/117208/">https://habr.com/ru/post/117208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../117200/index.html">Visual demonstration of sorting algorithms</a></li>
<li><a href="../117202/index.html">Site Skolkovo</a></li>
<li><a href="../117204/index.html">Flash Player 10.2 + vdpau + 64-bit</a></li>
<li><a href="../117205/index.html">Access to information by Facebook applications (in pictures)</a></li>
<li><a href="../117207/index.html">Waiting for MIX'11: what to look for?</a></li>
<li><a href="../117210/index.html">CERN has selected HP network equipment to upgrade its campus network</a></li>
<li><a href="../117211/index.html">OAuth 2.0 support for the VKontakte platform</a></li>
<li><a href="../117212/index.html">Published AirPort Express Private Key</a></li>
<li><a href="../117213/index.html">True Java Elastic Cloud @ JavaOne - closed beta-test</a></li>
<li><a href="../117214/index.html">Google bought a Canadian music startup Pushlife</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>