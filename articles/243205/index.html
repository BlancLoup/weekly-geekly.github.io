<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Finger Trees (Part 2. Operations)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article will consist of 3 parts: 
 Finger Trees (Part 1. Introduction) 
 Finger Trees (Part 2. Operations) 
 Finger trees (part 3. Application) 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Finger Trees (Part 2. Operations)</h1><div class="post__text post__text-html js-mediator-article">  The article will consist of 3 parts: <br>  <a href="http://habrahabr.ru/post/240783/">Finger Trees (Part 1. Introduction)</a> <br>  Finger Trees (Part 2. Operations) <br>  Finger trees (part 3. Application) <br><h4>  Finger Trees as Sequences </h4><br><img src="https://habrastorage.org/files/2d6/b7a/e92/2d6b7ae9214d47f6b9eac851893f3b25.png"><br>  <i>In the first part of the article, we looked at finger trees as a promising structure as non-mutable sequences.</i>  <i>And they learned how to create finger trees.</i>  <i>I want to note, learned to create so that it became impossible in principle to build the wrong trees.</i>  <i>Now our task is to learn how to work with finger trees as with sequences: learn how to attach to the beginning and end of a sequence, learn how to easily separate sequences from both ends, and also connect several trees into one.</i> <br><a name="habracut"></a><br>  The motivation for developing this strange structure is the desire to have a tree as a sequence, which would allow you to quickly have access to the end and the beginning.  In this section, we will implant operations that allow us to see sequences in finger trees. <br><h4>  Attach to start and end </h4><br>  Let's start by adding a finger tree to the beginning.  Ideally, we would like to add an element simply by adding it to the tree prefix.  But this will only work for trees that have 1, 2 or 3 elements in their prefix, and absolutely will not work for a finger tree, which has 4 elements in its prefix.  Just because the prefix can not be longer than four.  To avoid the prefix of length 5, we wrap 3 of these 5 elements, wrap them in <code>Node</code> using the <code>Branch3</code> construction, and attach them to a deeper finger tree: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  &lt;|    .      :   infixr 5 &lt;| (&lt;|) :: a -&gt; FingerTree a -&gt; FingerTree a --   #1.      ,  1  x &lt;| Empty = Single x --   #2:   ,     1 -- ,         'Affix a'  x &lt;| Single y = Deep [x] Empty [y] --  :      4 ,   --   2      ,    --           ,     x &lt;| Deep [a, b, c, d] deeper suffix = Deep [x, a] (node &lt;| deeper) suffix where node = Branch3 bcd --  :       x &lt;| tree = tree { prefix = affixPrepend x $ prefix tree }</span></span></code> </pre><br>  All this we can apply for joining the right, because we have the same access to the right end of the tree, as well as to the left end: <br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">infixl</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> |&gt; (|&gt;) :: FingerTree a -&gt; a -&gt; FingerTree a Empty |&gt; y = Single y Single x |&gt; y = Deep [x] Empty [y] Deep prefix deeper [a, b, c, d] |&gt; y = Deep prefix (deeper |&gt; node) [d, y] where node = Branch3 abc tree |&gt; y = tree { suffix = affixAppend y $ suffix tree }</code> </pre><br>  Now we can build a finger tree easily using joining to the beginning and to the end of it. <br><pre> <code class="haskell hljs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> empty = <span class="hljs-type"><span class="hljs-type">Empty</span></span> &gt; 't' &lt;| empty |&gt; 'x' |&gt; 'y' |&gt; 'z' |&gt; 'w' |&gt; 'm' <span class="hljs-type"><span class="hljs-type">Deep</span></span> {prefix = <span class="hljs-type"><span class="hljs-type">One</span></span> 't', deeper = <span class="hljs-type"><span class="hljs-type">Single</span></span> (<span class="hljs-type"><span class="hljs-type">Branch3</span></span> 'x' 'y' 'z'), suffix = <span class="hljs-type"><span class="hljs-type">Two</span></span> 'w' 'm'}</code> </pre><br>  Although we implemented the joining to the beginning and the end of the finger tree, it seems that we did not get much in terms of efficiency because of the trees, because if we are unlucky and the tree already has many prefixes of length 4, we should go deep into the tree to add items.  As a result, the worst case of adding to the beginning and end is <code>O(lg n)</code> , where <code>n</code> is the number of elements. <br>  Until the worst case gets better, the conversion for the typical case is improved.  In most cases of adding, the user attaches many elements to the string, each time only saving the new modified tree and discarding the old one.  Let us analyze this case, assuming that we transform <code>m</code> additions into a series <br>  Analyzing the asymptomatics of this case, we note that first comes the non-recursive part, which is constant in time.  The initial tree is small ( <code>Empty</code> or <code>Single x</code> ), or if we can immediately add an element, modifying the prefix, the addition takes <code>O(1)</code> time.  The recursive case (when the affix is ‚Äã‚Äã4 in length) is more complicated to calculate.  However, when we add to an affix of length 4, we instantly rebalance a tree with an affix of length 2. So, we know that the next operation will be instantaneous and take a constant time, and there is no need to go to another level.  From this we can deduce that no more than half of the join operations do not need a recursive case of switching to the second level of the finger tree.  And after each recursive case, there must be at least one non-recursive one.  Similar logic applies to the second layer: we know that only a quarter of operations can be possible to go deep into the third layer.  Continuing this logic, the nth layer of the finger tree can be visited only in one of every <code>2n-1</code> actions.  So, the total time for all <code>m</code> additions in the worst case will be <br>  <code>T=m+1/2m+1/4m+1/8m+‚ãØ</code> , <br>  However, even if we assume an infinite number of layers, the time will be finite - <code>2m</code> (which is easy to see if you notice the formula of a geometric series).  In the real case, <code>O(m)</code> time will be spent for <code>m</code> additions, and although in the worst case the time of one operation will be <code>O(lg n)</code> , where <code>n</code> is the number of elements in the tree, the amortized time for this case will be only <code>O(1)</code> for any addition from the beginning or from the end. <br><br><h4>  View (First and Last) </h4><br>  In the previous paragraph, we looked at the implementation of the join operation from the beginning <code>(|&gt;)</code> and from the end <code>(&lt;|)</code> elements in a sequence (sequence) based on a finger tree.  But, in addition to adding elements, there is an urgent need to look at them and delete them.  Both of these operations are based on a more universal operation ‚Äî a preview, which we will implement below. <br>  We need a viewing operation in 2 versions: a view on the right ( <code>viewr</code> ) and a view on the left ( <code>viewl</code> ).  Each of them takes one element from the end (left or right, respectively) and returns the element along with the rest of the finger tree. <br>  In order to make it clearer, we need the equivalent of the following function for lists: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--    ,   `Maybe`, --        ,  . listViewL :: [a] -&gt; Maybe (a, [a]) listViewL [] = Nothing listViewL (x:xs) = Just (x, xs)</span></span></code> </pre><br>  The simplest implementation for a finger tree might look like this: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--       --   Maybe (a, FingerTree a). data View a = Nil | View a (FingerTree a) deriving Show viewl :: FingerTree a -&gt; View a viewl Empty = Nil --     viewl (Single x) = View x Empty --    viewl (Deep prefix deeper suffix) = View first $ Deep (fromList rest) deeper suffix where --  ,       , --      first:rest = toList prefix</span></span></code> </pre><br>  We can even test the implementation, how to work with an empty tree: <br><pre> <code class="haskell hljs">&gt; viewl empty <span class="hljs-type"><span class="hljs-type">Nil</span></span> &gt; viewl exampleTree <span class="hljs-type"><span class="hljs-type">View</span></span> 't' (<span class="hljs-type"><span class="hljs-type">Deep</span></span> {prefix = <span class="hljs-type"><span class="hljs-type">One</span></span> 'h', deeper = <span class="hljs-type"><span class="hljs-type">Deep</span></span> {prefix = <span class="hljs-type"><span class="hljs-type">Two</span></span> (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'i' 's') (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'i' 's'), deeper = <span class="hljs-type"><span class="hljs-type">Empty</span></span>, suffix = <span class="hljs-type"><span class="hljs-type">Two</span></span> (<span class="hljs-type"><span class="hljs-type">Branch3</span></span> 'n' 'o' 't') (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'a' 't')}, suffix = <span class="hljs-type"><span class="hljs-type">Three</span></span> 'r' 'e' 'e'})</code> </pre><br>  And, although this design seems to work, the implementation has a serious leak.  Do you see her? <br>  The following code block shows the problem: <br><pre> <code class="haskell hljs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">View</span></span> _ rest = viewl exampleTree &gt; viewl rest <span class="hljs-comment"><span class="hljs-comment">--     1  4 !</span></span></code> </pre><br>  When we write this case for viewl, which deals with the constructor <code>Deep</code> , we simply remove the element from the left prefix.  But this will work only for as long as we have at least 1 element, but as soon as we want to pull the element from the inside, the tree will be wrong.  In the block described above, we tried to use viewl to create a finger tree, which would contain 0 elements in the prefix, which of course illegally and instantly causes an error. <br>  Therefore, we need to take into account this case, and count the number of elements in the prefix of the finger tree.  If there is only one element, we cannot simply remove it; instead, we must use the <code>viewl</code> for a deeper finger tree to get the <code>Node a</code> branch.  This <code>Node a</code> contains 2 or 3 values, so we can safely pull out one prefix element, and instead replace it with the prefix contained in <code>Node a</code> , so the transformation always guarantees the size of the affix between 1 and 4 elements.  The following implementation of viewl works for all cases (we still use the <code>View a</code> data structure described earlier): <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--      viewl :: FingerTree a -&gt; View a viewl Empty = Nil --     viewl (Single x) = View x Empty --    --    Deep   --       --    ,     viewl (Deep [x] deeper suffix) = View x rest where rest = --    : case viewl deeper of --          View node rest' -&gt; --      Deep (fromList $ toList node) rest' suffix --           --      --        Nil -&gt; case suffix of [x] -&gt; Single x [x, y] -&gt; Deep [x] Empty [y] --   2 ,    ,  --   .  --  -         [x, y, z] -&gt; Deep [x, y] Empty [z] [x, y, z, w] -&gt; Deep [x, y, z] Empty [w] -- ,     Deep --          viewl (Deep prefix deeper suffix) = View first $ Deep (fromList rest) deeper suffix where first:rest = toList prefix</span></span></code> </pre><br>  With this new <code>viewl</code> implementation, our crash test will work perfectly <br><pre> <code class="haskell hljs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">View</span></span> _ rest = viewl exampleTree &gt; viewl rest <span class="hljs-type"><span class="hljs-type">View</span></span> 'h' (<span class="hljs-type"><span class="hljs-type">Deep</span></span> {prefix = <span class="hljs-type"><span class="hljs-type">Two</span></span> 'i' 's', deeper = <span class="hljs-type"><span class="hljs-type">Deep</span></span> {prefix = <span class="hljs-type"><span class="hljs-type">One</span></span> (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'i' 's'), deeper = <span class="hljs-type"><span class="hljs-type">Empty</span></span>, suffix = <span class="hljs-type"><span class="hljs-type">Two</span></span> (<span class="hljs-type"><span class="hljs-type">Branch3</span></span> 'n' 'o' 't') (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'a' 't')}, suffix = <span class="hljs-type"><span class="hljs-type">Three</span></span> 'r' 'e' 'e'})</code> </pre><br>  The right <code>viewl</code> , <code>viewr</code> implemented almost completely the same, only using prefixes instead of suffixes and vice versa. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">viewr</span></span> :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">View</span></span> a viewr <span class="hljs-type"><span class="hljs-type">Empty</span></span> = <span class="hljs-type"><span class="hljs-type">Nil</span></span> viewr (<span class="hljs-type"><span class="hljs-type">Single</span></span> x) = <span class="hljs-type"><span class="hljs-type">View</span></span> x <span class="hljs-type"><span class="hljs-type">Empty</span></span> viewr (<span class="hljs-type"><span class="hljs-type">Deep</span></span> prefix deeper [x]) = <span class="hljs-type"><span class="hljs-type">View</span></span> x rest <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> rest = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> viewr deeper <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-comment"><span class="hljs-comment">--    ,   View node rest' -&gt; Deep prefix rest' (fromList $ toList node) --    ,      Nil -&gt; case prefix of [x] -&gt; Single x [x, y] -&gt; Deep [x] Empty [y] [x, y, z] -&gt; Deep [x] Empty [y, z] [x, y, z, w] -&gt; Deep [x] Empty [y, z, w] viewr (Deep prefix deeper suffix) = View suffixLast $ Deep prefix deeper (fromList suffixInit) where suffixLast = last $ toList suffix suffixInit = init $ toList suffix</span></span></code> </pre><br>  We use the function in the same way as <code>viewl</code> , we can view the end of the sequence <br><pre> <code class="haskell hljs">&gt; viewr exampleTree <span class="hljs-type"><span class="hljs-type">View</span></span> 'e' (<span class="hljs-type"><span class="hljs-type">Deep</span></span> {prefix = <span class="hljs-type"><span class="hljs-type">Two</span></span> 't' 'h', deeper = <span class="hljs-type"><span class="hljs-type">Deep</span></span> {prefix = <span class="hljs-type"><span class="hljs-type">Two</span></span> (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'i' 's') (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'i' 's'), deeper = <span class="hljs-type"><span class="hljs-type">Empty</span></span>, suffix = <span class="hljs-type"><span class="hljs-type">Two</span></span> (<span class="hljs-type"><span class="hljs-type">Branch3</span></span> 'n' 'o' 't') (<span class="hljs-type"><span class="hljs-type">Branch2</span></span> 'a' 't')}, suffix = <span class="hljs-type"><span class="hljs-type">Two</span></span> 'r' 'e'})</code> </pre><br>  Since we have the necessary primitives to view, we can easily create the remaining few functions for finger trees, similar to <code>head</code> , <code>tail</code> , <code>last</code> , <code>init</code> , and <code>null</code> for lists <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">treeHead</span></span> :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; a treeHead tree = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> viewl tree <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nil</span></span> -&gt; error <span class="hljs-string"><span class="hljs-string">"no elements in tree"</span></span> <span class="hljs-type"><span class="hljs-type">View</span></span> x _ -&gt; x treeTail :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a treeTail tree = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> viewl tree <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nil</span></span> -&gt; error <span class="hljs-string"><span class="hljs-string">"no elements in tree"</span></span> <span class="hljs-type"><span class="hljs-type">View</span></span> _ xs -&gt; xs treeLast :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; a treeLast tree = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> viewr tree <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nil</span></span> -&gt; error <span class="hljs-string"><span class="hljs-string">"no elements in tree"</span></span> <span class="hljs-type"><span class="hljs-type">View</span></span> x _ -&gt; x treeInit :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a treeInit tree = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> viewr tree <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nil</span></span> -&gt; error <span class="hljs-string"><span class="hljs-string">"no elements in tree"</span></span> <span class="hljs-type"><span class="hljs-type">View</span></span> _ xs -&gt; xs isEmpty :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> isEmpty tree = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> viewl tree <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nil</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">True</span></span> _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre><br>  And in particular, this allows us to easily convert lists into finger trees and vice versa: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--       . instance IsList (FingerTree a) where type Item (FingerTree a) = a toList tree = case viewl tree of Nil -&gt; [] View x xs -&gt; x : toList xs fromList = foldr (&lt;|) Empty</span></span></code> </pre><br>  The use of finger trees has become much simpler: <br><pre> <code class="haskell hljs">&gt; [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.6</span></span>] :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Deep</span></span> {prefix = <span class="hljs-type"><span class="hljs-type">Two</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>, deeper = <span class="hljs-type"><span class="hljs-type">Single</span></span> (<span class="hljs-type"><span class="hljs-type">Branch3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>), suffix = <span class="hljs-type"><span class="hljs-type">One</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>}</code> </pre><br><br><h4>  Concatenation </h4><br>  Another operation that we can implement using finger trees is concatenation / join.  For this, we have all the necessary functions for a simple connection, since we can recursively browse and attach elements.  The easiest implementations will be: <br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--     &gt;&lt; . (&gt;&lt;) :: FingerTree a -&gt; FingerTree a -&gt; FingerTree a left &gt;&lt; Empty = left left &gt;&lt; right = let View first rest = viewl right in (left |&gt; first) &gt;&lt; rest</span></span></code> </pre><br>  And although this implementation works well, this implementation is very slow.  In terms of asymptotic time, this is the same as using the toList function to decompose a finger tree, merge two lists, and convert back to a finger tree.  We have previously shown that <code>|&gt;</code> takes <code>O(1)</code> amortized time, but this procedure will be done <code>O(m)</code> times, where <code>m</code> is the number of elements in the right tree, which we pass to the function <code>&gt;&lt;</code> .  As a result, the total time <code>O(m)</code> - linearly depends on the number of elements that we attach. <br>  We will try to create much better by utilizing the structure of the finger tree.  Before doing this, we need a helper function called nodes, which can convert the list of elements into a list of nodes of elements: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">nodes</span></span> :: [a] -&gt; [<span class="hljs-type"><span class="hljs-type">Node</span></span> a] nodes xs = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> xs <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; error <span class="hljs-string"><span class="hljs-string">"not enough elements for nodes"</span></span> [x] -&gt; error <span class="hljs-string"><span class="hljs-string">"not enough elements for nodes"</span></span> [x, y] -&gt; [<span class="hljs-type"><span class="hljs-type">Branch2</span></span> xy] [x, y, z] -&gt; [<span class="hljs-type"><span class="hljs-type">Branch3</span></span> xyz] x:y:rest -&gt; <span class="hljs-type"><span class="hljs-type">Branch2</span></span> xy : nodes rest</code> </pre><br>  For every 2 elements of the original list, the nodes will contain only one in the new list of nodes.  In the order of connection, an odd number of elements, nodes will contain <code>Branch3</code> on the left side.  As a result, we are sure that the function of nodes, if given a list of elements, always create a list of <code>n/2</code> nodes.  This we need in the future. <br>  Next, we will redefine concatenation in terms of a slightly strange operator, which we call ‚Äúconnect with the middle‚Äù ( <code>concatWithMiddle</code> ).  The connector takes two <code>FingerTree a</code> values ‚Äã‚Äãfor the connection, as well as a list of items between the two trees. <br>  Implementing the same connection using a mid-connector is a trivial task ‚Äî just use an empty list as an additional argument. <br><pre> <code class="haskell hljs">(&gt;&lt;) :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a left &gt;&lt; right = concatWithMiddle left [] right concatWithMiddle :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; [a] -&gt; <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a concatWithMiddle = unimplemented <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> unimplemented = error <span class="hljs-string"><span class="hljs-string">"Soon to come!"</span></span></code> </pre><br>  Things are <code>concatWithMiddle</code> - implement <code>concatWithMiddle</code> .  We need a special case if we have trees with constructors <code>Empty</code> or <code>Single</code> .  In these cases, the compound is reduced to <code>O(1)</code> addition. <br>  Here we keep a list of additional elements in the middle also in order to use several attachments at both ends. <br>  In addition to the boundary cases, we must take care of the main case, when both trees have the constructor <code>Deep</code> .  Here we will also return <code>Deep</code> along with: <br>  prefix equal to the prefix of the left tree, <br>  suffix equal to the suffix of the right tree <br>  deep inner tree equal to recursive call <code>concatWithMiddle</code> <br>  We must also remember the suffix of the left tree and the prefix of the right tree.  By combining with the middle elements passed to <code>concatWithMiddle</code> .  While deep finger trees store <code>Node a</code> nodes instead of <code></code> values, we use the helper function to create a list of nodes that we pass recursively to the <code>concatWithMiddle</code> function.  It certainly sounds weird, but it should be readable from code: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">concatWithMiddle</span></span> :: <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; [a] -&gt; <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">FingerTree</span></span> a <span class="hljs-comment"><span class="hljs-comment">--  :         concatWithMiddle Empty [] right = right concatWithMiddle Empty (x:xs) right = x &lt;| concatWithMiddle Empty xs right concatWithMiddle (Single y) xs right = y &lt;| concatWithMiddle Empty xs right concatWithMiddle left [] Empty = left concatWithMiddle left xs Empty = concatWithMiddle left (init xs) Empty |&gt; last xs concatWithMiddle left xs (Single y) = concatWithMiddle left xs Empty |&gt; y --  :    concatWithMiddle left mid right = Deep (prefix left) deeper' (suffix right) where --  concatWithMiddle   ,     deeper' = concatWithMiddle (deeper left) mid' (deeper right) --      ,      --      ,    concatWithMiddle. mid' = nodes $ (toList $ suffix left) ++ mid ++ (toList $ prefix right) --  &gt;&lt;    . (&gt;&lt;) :: FingerTree a -&gt; FingerTree a -&gt; FingerTree a left &gt;&lt; right = concatWithMiddle left [] right</span></span></code> </pre><br>  We can test, just as before, by looking at how 2 <code>exampleTree &gt;&lt; exampleTree</code> : <br><pre> <code class="haskell hljs">&gt; putStrLn $ toList $ exampleTree &gt;&lt; exampleTree thisisnotatreethisisnotatree &gt; putStrLn $ toList $ concatWithMiddle exampleTree <span class="hljs-string"><span class="hljs-string">" "</span></span> exampleTree thisisnotatree thisisnotatree</code> </pre><br>  Although it is clear that this code is functioning (no matter how punny it sounds), it is not entirely clear what we won, and whether we even won in terms of guaranteed asymptotic execution time.  If we look at the base case of <code>concatWithMiddle</code> , we still find a ton of attachments!  Each time we recurse inside the layer, we add elements to the median list (from unused affixes).  Is it possible to achieve <code>O(m)</code> after this in the base case? <br>  Surprisingly enough, the answer is no.  We can prove that the base case will still take <code>O(1)</code> amortized time.  The magic here is in the use of nodes.  As we showed, when the function of nodes was determined, nodes guarantee the output list of no more than half of the elements of the input list.  Using this property, we can easily track that the maximum length of the average list can be any during the counting. <br>  When the counting begins, we know that the length of the average list is zero, because we passed the function <code>concatWithMiddle</code> an empty list in our definition <code>&gt;&lt;</code> .  At each step, we add 2 affixes (suffix and prefix) to the middle list before adding nodes to it.  We know that affixes have no more than 4 elements, which means that for the first iteration we will add no more than 8 elements, the output length after the function of nodes will be close to 8, but no more than 8. Indeed, if we start with a list less than or equal to 8 elements, then the length is divided in half, at the output we get again 8 or less elements.  You can look at the example when we start with an empty middle list, and we will add 8 elements per step. <br>  Step 0. The middle list is empty, 0 items <br>  Step 1: Add 8 elements (4 from suffix, 4 from prefix).  The function of nodes reduces the length by half, so the final list has 4 elements <br>  Step 2: Add 8 elements.  A total of 12, the nodes shorten the length to 6 <br>  Step 3: Add 8 elements.  A total of 14, the nodes reduce the length to 7 <br>  Step 4: Add 8 elements.  Only 15 knots shorten the length to 7 <br>  Note that the last 2 steps both had a list of the same size - once the calculations reach the limit - the average list reaches length 7, which is <code>O(1)</code> (constant), as a result we can confidently say that the base case occupies <code>O(1)</code> amortized execution time, since there will be no more than 8 connections. <br>  Since the base case will consume constant time, the main one who invests time in the execution of our <code>&gt;&lt;</code> function, is recursion.  Each recursive step, when we look into the deep trees of both the right and left trees of the <code>concatWithMiddle</code> function <code>concatWithMiddle</code> , we proceed to the base case immediately when at least one of the trees does not contain a <code>Deeper</code> constructor.  The depth of these trees grows logarithmically with the growth of elements in it, if the finger tree consists of <code>n</code> elements, then its depth will be <code>O(lg n)</code> .  And the runtime is proportional to the minimum depth of both trees, our asymptotic time limit is <code>O(min(lg n,lg m))=O(lg(min(m,n)))</code> , where <code>n</code> and <code>m</code> <br>  - the number of elements in the right and left tree, respectively. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Well, in this part of the article we learned how to easily work with finger trees as with sequences. <br>  However, the potential of finger trees is not exhausted.  In the final part of the article, we will consider the additional possibilities of finger trees. </div><p>Source: <a href="https://habr.com/ru/post/243205/">https://habr.com/ru/post/243205/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243195/index.html">Rakes, which I stepped on when crossing CRM with Google Calendar</a></li>
<li><a href="../243197/index.html">DEV Labs 2014 - online conference for Oracle developers</a></li>
<li><a href="../243199/index.html">Haxe: convert source code</a></li>
<li><a href="../243201/index.html">The smartest marketers in the world. Learn from Amazon</a></li>
<li><a href="../243203/index.html">FreeBSD, dhcp, ip unnumbered and everything is all all ...</a></li>
<li><a href="../243207/index.html">Python implementation of the event-driven paradigm using coroutines</a></li>
<li><a href="../243209/index.html">Are you a pirate? Are you a pirate?</a></li>
<li><a href="../243211/index.html">Oil Rows in R</a></li>
<li><a href="../243213/index.html">Asterisk + Lua + regular update of DEF codes</a></li>
<li><a href="../243215/index.html">Internet Explorer: Moving to live Edge mode - the next step for the web to just work</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>