<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Idiom Kotlin, a set of good practices</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To fully unleash the full benefits of Kotlin , we‚Äôll review some of the approaches we use in Java . Many of them can be replaced with the best counter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Idiom Kotlin, a set of good practices</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/d7c/41f/bb5/d7c41fbb554644e0be8f303b554d6a2a.png"><br><br>  To fully unleash the full benefits of <i>Kotlin</i> , we‚Äôll review some of the approaches we use in <i>Java</i> .  Many of them can be replaced with the best counterparts from <i>Kotlin</i> .  Let's take a look at how we can write idiomatic code in <i>Kotlin</i> . <br><a name="habracut"></a><br>  <i>I present to your attention the translation of the article about the idiomatic <i>Kotlin</i> .</i>  <i>In many ways, the author has shown quite well how to write on <i>Kotlin</i> and use the built-in language features for writing simple and expressive code.</i> <br><br><blockquote>  Note: the list below is not exhaustive and only expresses my humble opinion.  Moreover, some language features should be used with extreme caution.  When abused, they can make the code less readable.  For example, when you are trying to compress everything into one unreadable expression. <br>  <i>Philipp Hauer</i> </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Comparison of Kotlin‚Äôs built-in capabilities with common patterns and Java idioms. </h2><br>  In <i>Java,</i> you have to write quite a lot of boilerplate code to implement some patterns and idioms.  Fortunately, many patterns have built-in support right in the <i>Kotlin</i> language or in its standard library: <br><table><tbody><tr><th>  <i>Java</i> idioms or patterns </th><th>  Implementation in <i>Kotlin</i> </th></tr><tr><td>  Optional </td><td>  Nullable values </td></tr><tr><td>  Getters, setters, <i>Backing field</i> </td><td>  Properties (properties) </td></tr><tr><td>  Static class for utilities </td><td>  Top-level functions, extension functions </td></tr><tr><td>  Immutability, Value Objects </td><td> <code>data class</code> with immutable properties, <code>copy()</code> </td></tr><tr><td>  Fluent Setter (Wither) </td><td>  Named arguments, and arguments with a default value, <code>apply()</code> </td></tr><tr><td>  Method Chaining </td><td>  Arguments with default value </td></tr><tr><td>  Singleton </td><td> <code>object</code> </td> </tr><tr><td>  Delegation </td><td>  Delegating properties <code>by</code> </td></tr><tr><td>  Lazy initialization (thread safe) </td><td>  Delegating properties <code>by: lazy()</code> </td></tr><tr><td>  Observer </td><td>  Delegating properties <code>by: Delegates.observable()</code> </td></tr></tbody></table><br><h2>  Functional programming </h2><br>  Among other advantages, functional programming allows to reduce side effects, which in turn makes the code: <br><br>  - less error prone <br>  - easier to understand <br>  - easier to test <br>  - flow safe <br><br>  Compared to <i>Java 8</i> , <i>Kotlin has</i> better functional programming support: <br>  - immutability, <code>val</code> for variables and properties, immutable <code>data classes</code> , <code>copy()</code> <br>  - all expressions return a result: <code>if</code> , <code>when</code> and <code>try-catch</code> are expressions.  You can combine them with other expressions and functions. <br>  - functions as first class types <br>  - brief lambda expressions <br>  - Kotlin API collections <br><br>  All this allows us to write a functional code in a safe, concise and expressive way.  And as a result, it is possible to write pure functions (without side effects) much easier. <br><br><h2>  Using expressions: </h2><br><pre> <code class="hljs cmake">// Don't fun getDefaultLocale(deliveryArea: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>): Locale { val deliverAreaLower = deliveryArea.toLowerCase() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (deliverAreaLower == <span class="hljs-string"><span class="hljs-string">"germany"</span></span> || deliverAreaLower == <span class="hljs-string"><span class="hljs-string">"austria"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Locale.GERMAN } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (deliverAreaLower == <span class="hljs-string"><span class="hljs-string">"usa"</span></span> || deliverAreaLower == <span class="hljs-string"><span class="hljs-string">"great britain"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Locale.ENGLISH } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (deliverAreaLower == <span class="hljs-string"><span class="hljs-string">"france"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Locale.FRENCH } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Locale.ENGLISH }</code> </pre><br><pre> <code class="hljs haskell">// <span class="hljs-type"><span class="hljs-type">Do</span></span> fun getDefaultLocale2(deliveryArea: <span class="hljs-type"><span class="hljs-type">String</span></span>) = when (deliveryArea.toLowerCase()) { <span class="hljs-string"><span class="hljs-string">"germany"</span></span>, <span class="hljs-string"><span class="hljs-string">"austria"</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Locale</span></span>.<span class="hljs-type"><span class="hljs-type">GERMAN</span></span> <span class="hljs-string"><span class="hljs-string">"usa"</span></span>, <span class="hljs-string"><span class="hljs-string">"great britain"</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Locale</span></span>.<span class="hljs-type"><span class="hljs-type">ENGLISH</span></span> <span class="hljs-string"><span class="hljs-string">"france"</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Locale</span></span>.<span class="hljs-type"><span class="hljs-type">FRENCH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Locale</span></span>.<span class="hljs-type"><span class="hljs-type">ENGLISH</span></span> }</code> </pre><br>  The rule of thumb is: every time you write <code>if</code> keep in mind that it can be replaced by a shorter entry with <code>when</code> . <br><br>  <code>try-catch</code> is also a useful expression: <br><br><pre> <code class="hljs python">val json = <span class="hljs-string"><span class="hljs-string">"""{"message":"HELLO"}"""</span></span> val message = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { JSONObject(json).getString(<span class="hljs-string"><span class="hljs-string">"message"</span></span>) } catch (ex: JSONException) { json }</code> </pre><br><h2>  Top-level functions, extension functions </h2><br>  In <i>Java,</i> we often create static classes with static methods for utilities.  The direct implementation of this pattern in <i>Kotlin</i> will look like this: <br><br><pre> <code class="hljs cmake">//Don't object StringUtil { fun countAmountOfX(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>): Int{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.length - <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.replace(<span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>).length } } StringUtil.countAmountOfX(<span class="hljs-string"><span class="hljs-string">"xFunxWithxKotlinx"</span></span>)</code> </pre><br>  <i>Kotlin</i> allows you to remove unnecessary wraps in a class using top-level functions.  Often, we can also add some extension functions to improve readability.  So, our code becomes more like a ‚Äústory telling‚Äù. <br><br><pre> <code class="hljs sql">//<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> fun String.countAmountOfX(): <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>).length } <span class="hljs-string"><span class="hljs-string">"xFunxWithxKotlinx"</span></span>.countAmountOfX()</code> </pre><br><h2>  Named arguments instead of <i>Fluent Setter</i> . </h2><br>  Returning to <i>Java</i> , <i>fluent setters</i> (also called "Wither") are used to emulate named arguments and arguments with a default value.  This allows you to make the list of parameters more readable and less prone to errors: <br><br><pre> <code class="hljs vhdl">//Don<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> val config = SearchConfig() .setRoot(<span class="hljs-string"><span class="hljs-string">"~/folder"</span></span>) .setTerm(<span class="hljs-string"><span class="hljs-string">"kotlin"</span></span>) .setRecursive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) .setFollowSymlinks(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre><br>  In <i>Kotlin,</i> named and default arguments are used for the same purpose, but are also built into the language at the same time: <br><br><pre> <code class="hljs pgsql">//<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> val config2 = SearchConfig2( root = "~/folder", term = "kotlin", <span class="hljs-keyword"><span class="hljs-keyword">recursive</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, followSymlinks = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> )</code> </pre><br><h2>  <code>apply()</code> to combine object initialization calls </h2><br><pre> <code class="hljs vhdl">//Don<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> val dataSource = BasicDataSource() dataSource.driverClassName = <span class="hljs-string"><span class="hljs-string">"com.mysql.jdbc.Driver"</span></span> dataSource.url = <span class="hljs-string"><span class="hljs-string">"jdbc:mysql://domain:3309/db"</span></span> dataSource.username = <span class="hljs-string"><span class="hljs-string">"username"</span></span> dataSource.password = <span class="hljs-string"><span class="hljs-string">"password"</span></span> dataSource.maxTotal = <span class="hljs-number"><span class="hljs-number">40</span></span> dataSource.maxIdle = <span class="hljs-number"><span class="hljs-number">40</span></span> dataSource.minIdle = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  The <code>apply()</code> extension function helps to merge object initialization code.  In addition, we do not need to repeat the name of the variable over and over again. <br><br><pre> <code class="hljs sql">//<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> val dataSource = BasicDataSource().apply { driverClassName = <span class="hljs-string"><span class="hljs-string">"com.mysql.jdbc.Driver"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">url</span></span> = <span class="hljs-string"><span class="hljs-string">"jdbc:mysql://domain:3309/db"</span></span> username = <span class="hljs-string"><span class="hljs-string">"username"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">password</span></span> = <span class="hljs-string"><span class="hljs-string">"password"</span></span> maxTotal = <span class="hljs-number"><span class="hljs-number">40</span></span> maxIdle = <span class="hljs-number"><span class="hljs-number">40</span></span> minIdle = <span class="hljs-number"><span class="hljs-number">4</span></span> }</code> </pre><br>  <code>apply()</code> is also very useful when interacting with <i>Java</i> libraries from <i>Kotlin</i> . <br><br><h2>  No overloading of methods to simulate arguments with a default value. </h2><br>  No need to overload methods and constructors to implement arguments with a default value (also called a method chain of "method chaining" or a chain of constructors of "constructor chaining") <br><br><pre> <code class="hljs dos">//Don't fun <span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(name: String){ <span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(name, true) } fun <span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(name: String, recursive: Boolean){ }</code> </pre><br>  All this is a crutch.  For this purpose, <i>Kotlin</i> has arguments with a default value: <br><br><pre> <code class="hljs sql">//<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> fun (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">recursive</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span>){ }</code> </pre><br>  In fact, the default arguments remove almost all cases of method and constructor overloads, because the overload is mostly used to create arguments with a default value. <br><br><h2>  Brevity and conciseness with <i>Nullability</i> </h2><br><h3>  Avoid <code>if-null</code> checks. </h3><br>  <i>The Java</i> method of checking for <code>null</code> cumbersome and makes it easy to miss the error. <br><br><pre> <code class="hljs erlang">//Don't <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (order == null || order.customer == null || order.customer.address == null){ throw IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Invalid Order"</span></span>) } val city = order.customer.address.city</code> </pre><br>  Every time you write a <code>null</code> check, stop.  <i>Kotlin</i> provides an easier way to handle these situations.  Most often, can you use a secure call <code>?.</code>  or just an operator "elvis" <code>?:</code> <br><br><pre> <code class="hljs pgsql">//<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> val city = <span class="hljs-keyword"><span class="hljs-keyword">order</span></span>?.customer?.address?.city ?: throw IllegalArgumentException("Invalid Order")</code> </pre><br><h3>  Avoid type checking </h3><br>  All of the above is also true for type checks: <br><br><pre> <code class="hljs erlang-repl">//Don't if (service !is CustomerService) { throw IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"No CustomerService"</span></span>) } service.getCustomer()</code> </pre><br>  Using <code>as?</code>  and <code>?:</code> you can check the type, automatically convert it to a smart cast, or throw an exception if the type is not the one we expect.  All in one expression! <br><br><pre> <code class="hljs pgsql">//<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? CustomerService ?: throw IllegalArgumentException("No CustomerService") service.getCustomer()</code> </pre><br><h3>  Avoid calling without checks with <code>!!</code> </h3><br><pre> <code class="hljs erlang-repl">//Don't order!!.customer!!.address!!.city</code> </pre><br><blockquote>  Surely you noticed that <code>!!</code>  look pretty rough.  It's almost like you shout at the compiler.  So it does not look random.  The <i>Kotlin</i> language developers are trying to slightly push you to find the best solution so as not to use an expression that cannot be verified by the compiler. <br>  <i>Kotlin in Action, Dmitry Zhemerov and Svetlana Isakova.</i> </blockquote><br><h3>  Use <code>let()</code> </h3><br>  In some situations, <code>let()</code> allows you to replace <code>if</code> .  But you need to use it with care so that the code remains readable.  However, I really want you to think about using <code>let()</code> . <br><br><pre> <code class="hljs pgsql">val <span class="hljs-keyword"><span class="hljs-keyword">order</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Order</span></span>? = findOrder() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ dun(<span class="hljs-keyword"><span class="hljs-keyword">order</span></span>.customer) }</code> </pre><br>  With <code>let()</code> no additional variable is needed.  So further we deal with one expression: <br><br><pre> <code class="hljs swift">findOrder()?.<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { dun(it.customer) } <span class="hljs-comment"><span class="hljs-comment">//or findOrder()?.customer?.let(::dun)</span></span></code> </pre><br><h2>  Using Value Objects </h2><br>  It is very easy to write immutable value objects with <code>data classes</code> .  Even if they contain only one property.  There is no longer any reason not to use them. <br><br><pre> <code class="hljs cmake">//Don't fun send(<span class="hljs-keyword"><span class="hljs-keyword">target</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>){}</code> </pre><br><pre> <code class="hljs sql">//<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> fun send(target: EmailAddress){} // expressive, readable, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">safe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> EmailAddress(val <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>)</code> </pre><br><h2>  Functions consisting of a single expression </h2><br><pre> <code class="hljs dos">// Don't fun mapToDTO(entity: SnippetEntity): SnippetDTO { val dto = SnippetDTO( code = entity.code, <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> = entity.<span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, author = "${entity.author.firstName} ${entity.author.lastName}" ) return dto }</code> </pre><br>  With functions consisting of a single expression, and named arguments, we can simply, briefly and expressively describe the relationship between objects: <br><br><pre> <code class="hljs lisp">// Do fun mapToDTO(<span class="hljs-name"><span class="hljs-name">entity</span></span>: SnippetEntity) = SnippetDTO( <span class="hljs-name"><span class="hljs-name">code</span></span> = entity.code, date = entity.date, author = <span class="hljs-string"><span class="hljs-string">"${entity.author.firstName} ${entity.author.lastName}"</span></span> ) val dto = mapToDTO(<span class="hljs-name"><span class="hljs-name">entity</span></span>)</code> </pre><br>  If you prefer the extension functions, you can, using them, make the announcement and use at the same time more concise and expressive.  At the same time, we do not pollute our value objects with additional logic. <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> fun SnippetEntity.toDTO() = SnippetDTO( code = code, <span class="hljs-type"><span class="hljs-type">date</span></span> = <span class="hljs-type"><span class="hljs-type">date</span></span>, author = "${author.firstName} ${author.lastName}" ) val dto = entity.toDTO()</code> </pre><br><h2>  Prefer using constructor parameters in property initialization. </h2><br>  Think twice before you use the initialization block (init block) in the body of the constructor just to initialize the properties. <br><br><pre> <code class="hljs cmake">// Don't class UsersClient(baseUrl: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, appName: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) { private val usersUrl: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span> private val httpClient: HttpClient init { usersUrl = <span class="hljs-string"><span class="hljs-string">"$baseUrl/users"</span></span> val builder = HttpClientBuilder.create() builder.setUserAgent(appName) builder.setConnectionTimeToLive(<span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS) httpClient = builder.build() } fun getUsers(){ //call service using httpClient <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> usersUrl } }</code> </pre><br>  It should be noted that in the initialization of properties you can refer to the parameters of the main constructor (and not only in the <code>init</code> block).  <code>apply()</code> can also help group initialization code and get by with one expression. <br><br><pre> <code class="hljs sql">// <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UsersClient(baseUrl: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, appName: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val usersUrl = <span class="hljs-string"><span class="hljs-string">"$baseUrl/users"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val httpClient = HttpClientBuilder.create().apply { setUserAgent(appName) setConnectionTimeToLive(<span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS) }.build() fun getUsers(){ //<span class="hljs-keyword"><span class="hljs-keyword">call</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> httpClient <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> usersUrl } }</code> </pre><br><h2>  <code>object</code> for stateless implementations </h2><br>  <code>object</code> from <i>Kotlin is</i> useful when you need to implement a framework interface that does not store state.  For example, the interface <i>Converter</i> from <i>Vaadin 8</i> . <br><br><pre> <code class="hljs sql">//<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> StringToInstantConverter : Converter&lt;<span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, Instant&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy HH:mm:ss Z"</span></span>) .withLocale(Locale.UK) .withZone(ZoneOffset.UTC) override fun convertToModel(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>?, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: ValueContext?) = try { Result.ok(Instant.from(DATE_FORMATTER.parse(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>))) } catch (ex: DateTimeParseException) { Result.error&lt;Instant&gt;(ex.message) } override fun convertToPresentation(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: Instant?, <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>: ValueContext?) = DATE_FORMATTER.format(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) }</code> </pre><br>  To see more detailed information on <a href="https://blog.philipphauer.de/kotlin-practice-spring-boot-vaadin/">Kotlin, Spring Boot and Vaadin</a> interactions <a href="https://blog.philipphauer.de/kotlin-practice-spring-boot-vaadin/">, see this post.</a> <br><br><h2>  Destructing </h2><br>  On the one hand, destructuring is useful when it is necessary to return several values ‚Äã‚Äãfrom a function.  We can use either our own <code>data class</code> (which is preferable), or use <code>Pair</code> (which is less expressive, due to the fact that the pair does not preserve the semantics) <br><br><pre> <code class="hljs haskell">//<span class="hljs-type"><span class="hljs-type">Do</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ServiceConfig</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">host</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">port</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) fun createServiceConfig(): </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ServiceConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ServiceConfig</span></span></span><span class="hljs-class">("</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">api</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">domain</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">", 9389) } //destructuring in action: val (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">host</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">port</span></span></span><span class="hljs-class">) = createServiceConfig()</span></span></code> </pre><br>  On the other hand, destructuring can also be convenient for multiple iteration of <code>map</code> elements: <br><br><pre> <code class="hljs sql">//<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> = mapOf(<span class="hljs-string"><span class="hljs-string">"api.domain.io"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">9389</span></span>, <span class="hljs-string"><span class="hljs-string">"localhost"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((host, port) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>){ //... }</code> </pre><br><h2>  Special structures to create structures </h2><br>  <code>listOf</code> , <code>mapOf</code> , and infix function <code>to</code> can be used to quickly create structures (such as <i>JSON</i> ).  Of course, this is still not as compact as in <i>Python</i> and <i>JavaScript</i> , but better than in Java. <br><br>  <i>Note: Andrey Breslav recently at Jpoint 2017 said that they are thinking about how to improve this, so we can hope for some improvements in the foreseeable future.</i> <br><br><pre> <code class="hljs pgsql">//<span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> val customer = mapOf( "name" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> "Clair Grube", "age" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>, "languages" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> listOf("german", "english"), "address" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> mapOf( "city" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> "Leipzig", "street" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> "Karl-Liebknecht-Stra√üe 1", "zipCode" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> "04107" ) )</code> </pre><br>  True, you usually have to use the <code>data class</code> or object mapping to create JSON.  But sometimes (including in tests), such a record is very useful. <br><br><h2>  Sources </h2><br>  You can find the source code on my GitHub project <a href="https://github.com/phauer/blog-related/tree/master/kotlin-idiomatic">idiomatic kotlin</a> . <br><br>  <i>I hope this translation seemed useful to you.</i>  <i>I would be very grateful to all those who noticed any inaccuracies or errors in the translation and write about it in correspondence.</i> <i><br></i>  <i>Thanks for attention!</i> </div><p>Source: <a href="https://habr.com/ru/post/328218/">https://habr.com/ru/post/328218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328204/index.html">Where to go for those who have decided to leave Ubuntu Unity</a></li>
<li><a href="../328206/index.html">Using the NSProxy class on a simple example</a></li>
<li><a href="../328208/index.html">Adding to_string simplifies development and debugging code on Elixir</a></li>
<li><a href="../328210/index.html">Exhibitions and conferences on virtual reality 2017</a></li>
<li><a href="../328212/index.html">Reverse Engineering "Kazakov", the last part: the second breath</a></li>
<li><a href="../328220/index.html">Table design</a></li>
<li><a href="../328224/index.html">Taiwan and Hong Kong: promising markets with huge opportunities</a></li>
<li><a href="../328226/index.html">Docker container with Postgres data for integration testing and easy extension</a></li>
<li><a href="../328228/index.html">How to define?</a></li>
<li><a href="../328230/index.html">Tables in responsive design - 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>