<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>No free lunch. Introduction to participation in data analysis competitions on the Kaggle platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The purpose of the article is to acquaint a wide audience with data analysis competitions on Kaggle . I will talk about my approach to participation o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>No free lunch. Introduction to participation in data analysis competitions on the Kaggle platform</h1><div class="post__text post__text-html js-mediator-article">  The purpose of the article is to acquaint a wide audience with data analysis competitions on <a href="https://www.kaggle.com/">Kaggle</a> .  I will talk about my approach to participation on the example of Outbrain click prediction of the competition, in which I took part and took the 4th place out of 979 teams, having finished the first of the speakers alone. <br><br>  To understand the material knowledge of machine learning is desirable, but not necessary. <br><a name="habracut"></a><br>  About myself - I work as a Data Scientist / Software Engineer in <a href="http://www.captify.co.uk/">captify.co.uk</a> .  This is Kaggle's second serious competition, the previous result 24/2125, also solo.  I am engaged in machine learning for about 5 years, programming - 12. <a href="https://www.linkedin.com/in/andrewcherednychenko">Linkedin profile</a> . <br><br><h2>  About machine learning and the Kaggle platform </h2><br>  The main task of machine learning is to build models that can predict results based on input data that differs from those previously reviewed.  For example, we want to predict the value of shares of a particular company after a specified time, taking into account the current value, market dynamics and financial news. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here, the future value of the shares will be a prediction, and the current value, dynamics and news will be input data. <br><br>  <a href="https://www.kaggle.com/">Kaggle</a> is primarily a platform for data analysis and machine learning competitions.  The range of tasks is completely different - the classification of whales into species, the identification of cancerous tumors, the assessment of property values, and so on.  The company organizer forms the problem, provides data and sponsors the prize fund.  At the time of writing, 3 competitions are active, the total prize fund of 1.25M $ is a <a href="https://www.kaggle.com/competitions">list of active competitions</a> . <br><br>  My last competition is <a href="https://www.kaggle.com/c/outbrain-click-prediction">Outbrain click prediction</a> , the task is to predict what kind of advertising the user will hit from the ones shown to him.  The competition is sponsored by Outbrain promoting various content, such as blogs or news.  They place their ad units on a variety of different resources, including cnn.com, washingtonpost.com and others.  Since the company that receives money for user clicks, they are interested in showing users content that is potentially interesting to them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2f/85d/529/a2f85d5298e2375df63afd7b01fe5111.png"><br><br>  The formal description of the task - it is necessary to arrange the advertisement shown to the user in this block in a descending order according to the probability of clicking on the advertisement. <br><br>  The amount of data provided is quite large, for example, a clicklog file in the 80GB area.  An exact description of the input data can be obtained on <a href="https://www.kaggle.com/c/outbrain-click-prediction/data">the competition page</a> . <br><br>  The data provided are divided into 2 parts - those for which the participants know which banner the user will click on (training data), and data for which the result must be predicted - test ones.  At the same time, Kaggle knows the actual results for the test data. <br><br>  Competitors use training data to build models that predict results for test data.  In the end, these predictions are loaded back, where the platform, knowing the real results, shows the accuracy of the predictions. <br><br><h2>  General plan for participation in competitions </h2><br><ol><li>  Analysis of the task and available data <br></li><li>  Search and study of possible solutions <br></li><li>  Development of a local accuracy assessment mechanism <br></li><li>  Generating features for the model <br></li><li>  Implementation (if there is no ready-made algorithm) + model building <br></li><li>  Accuracy Assessment <br></li><li>  Iterating points 4-6, adding new models (most of the time) <br></li><li>  Ensemble and stack of models (optional) <br></li><li>  Teaming (optional) <br></li></ol><br><h2>  Beginning of work </h2><br><h3>  Input data </h3><br>  First of all, it is necessary to understand the data that are available to participants of the competition.  On the Data page, as a rule, there is a description of the structure and semantics, and on the Competition Rules page, a description of whether it is possible to use external data sources, and if so, whether it is worth sharing them with the others. <br><br>  The first thing I usually do is pump out all the data and understand the structure, the dependencies, so that they answer the formulation of the problem.  For these purposes it is convenient to use <b>Jupyter</b> + <b>Python.</b>  We build different graphs, statistical metrics, look at the distribution of data - we do everything that helps to understand the data. <br><br>  For example, let's build the distribution of the number of advertisements in one ad unit: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b2/085/569/4b2085569e7c745cf7e6e0223e029475.png"><br><br>  Also, on Kaggle there is a Kernels section, where the code can be executed directly in their laptops and usually there are guys who make various visualizations of the available dataset - this is how we start using other people's ideas. <br><br>  If you have questions about the structure, dependencies or data values, you can search for the answer on the forum, or you can try to guess yourself and get an advantage over those who have (yet) not guessed. <br><br>  Also, there are often Leaks in the data - dependencies, for example, temporary, which allow us to understand the value of the target variable (prediction) for a subset of the tasks. <br><br>  For example, in Outbrain click prediction, from the data in the click-log it was possible to understand that the user clicked on a certain advertisement.  Information about such leaks can be published on the forum, and can be used by participants without publicity. <br><br><h3>  Analysis of approaches to solving the problem </h3><br>  When everything is clear with the formulation of the task and the input data in general, I start collecting information - reading books, studying similar competitions, scientific publications.  This is a wonderful period of competition, when it is possible in a very tight time frame, to significantly expand their knowledge in solving problems like this. <br><br>  Studying such competitions, I review its forum, where the winners as a rule describe their approaches + I study the source code of the solutions that is available. <br><br>  Reading publications introduces the best at the present results and approaches.  It is also great when you can find the original or re-created source code. <br><br>  For example, the last two Click-Prediction competitions were won by the same team.  A description of their decisions + source codes + reading the forums of these competitions gave an idea about the direction from which to begin work. <br><br><h2>  First code </h2><br><br><h3>  Version control </h3><br>  I always start by initializing the version control repository.  You can lose important pieces of code even at the very beginning, it is very unpleasant to restore it later.  I usually use Git + Bitbucket (free private repositories) <br><br><h3>  Local (cross) validation </h3><br>  Validation, or testing of predictions, is an assessment of their accuracy based on the selected metric. <br>  For example, in Outbrain click prediction, you need to predict which of the ads shown will click on the user.  The data provided are divided into two parts: <br><br><table><tbody><tr><td>  Data type <br></td><td>  Advertising ID for each impression <br></td></tr><tr><td>  Training <br></td><td>  Known to all <br></td></tr><tr><td>  Test <br></td><td>  It is known only to the organizers of the competition. <br></td></tr></tbody></table><br>  The training of models takes place on the training data, in the hope that the accuracy on the test data will also improve, and it is assumed that the test and training data are taken from one sample. <br><br>  In the process of learning, there is often a moment when the accuracy with respect to the training data increases, but with respect to the test data, it begins to fall.  This happens because the power (Capacity) of the model allows you to remember or adjust to the test set. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a1d/979/fe4/a1d979fe4eb725eab83953cd0325dc3c.png"><br>  This phenomenon is called re-training (overfit), how to deal with it, we will talk below, until it is enough to understand that <b>it is necessary to check the accuracy on data that the model did not see</b> . <br><br>  Although Kaggle makes it possible to assess the accuracy of the solution (relative to test data) by uploading it to the site, this evaluation approach has several disadvantages: <br><br><ol><li>  Limit on the number of weekly decisions per day.  Often 2-5 <br></li><li>  Latency of this approach - counting solutions for a test suite, writing to a file, loading a file <br></li><li>  Nontriviality of automation <br></li><li>  Probability of retraining relative to test data <br></li></ol><br>  It would be nice to have a local accuracy assessment system that will allow: <br><br><ol><li>  Quickly evaluate accuracy based on selected metrics <br></li><li>  Automate brute force algorithms and / or hyperparameters <br></li><li>  Store assessment results along with other information for later analysis. <br></li><li>  Exclude retraining with respect to the test sample <br></li></ol><br>  Local (cross) validation is perfect for this purpose.  The idea is simple - we divide the training set into a training and validation set and we will use the validation set for assessing accuracy, comparing algorithms, but not for teaching. <br><br>  There are many validation methods, as well as ways to separate data, it is important to follow a few simple rules: <br><br><ol><li>  The separation should not change over time to eliminate the effect on the result.  For this example, you can save separate validation and training sets, save row indexes or use standard random.seed <br></li><li>  If you have features that are built on the entire data set ‚Äî for example, the frequency of clicking on a specific advertisement depending on time, such signs should be counted only using the training set, but not validation, thus knowing the answer will not ‚Äúflow‚Äù "In model <br></li><li>  If the data is arranged depending on time - for example, in the test set there will be data from the future, relative to the training set, you must observe the same distribution in the separation of the training / validation set <br></li></ol><br>  You can check the adequacy of local validation by comparing the improvement shown locally with the actual improvement obtained after loading the solution on Kaggle.  Well, when changes in local assessment give an idea of ‚Äã‚Äãthe real improvement. <br><br><h2>  We build models </h2><br><h3>  Introduction </h3><br>  A model can be represented as a black box or a function that receives data at the input and returns the result.  Results may be of a different type, most commonly used: <br><table><tbody><tr><td>  Model type <br></td><td>  Return type <br></td><td>  Example <br></td></tr><tr><td>  Regression <br></td><td>  Real number <br></td><td>  Cost of N stock after 1 minute <br></td></tr><tr><td>  Classification <br></td><td>  Category <br></td><td> Payable / Insolvent Borrower <br></td></tr></tbody></table><br>  In Outbrain competition, it was necessary to rank an advertisement according to the probability that a user would click on it.  A simple and effective way to achieve this is to use the task of classification, predict the likelihood of clicking, and sort the advertisements in a block according to the probabilities issued by the classifier: <br><br>  Classifier predictions: <br><table><tbody><tr><td>  Displayid <br></td><td>  Adid <br></td><td>  Clickprob <br></td></tr><tr><td>  five <br></td><td>  55 <br></td><td>  0.001 <br></td></tr><tr><td>  five <br></td><td>  56 <br></td><td>  0.03 <br></td></tr><tr><td>  five <br></td><td>  57 <br></td><td>  0.05 <br></td></tr><tr><td>  five <br></td><td>  58 <br></td><td>  0.002 <br></td></tr></tbody></table><br>  The format in which decisions of the problem are made: <br><table><tbody><tr><td>  Displayid <br></td><td>  Adids <br></td></tr><tr><td>  five <br></td><td>  57 56 58 55 <br></td></tr></tbody></table><br>  Evaluation metric (evaluation metric) - a function that shows how accurately the prediction corresponds to real data.  For each type of task, there are many metrics - for example, regression is often used based on the difference of squares of values.  The competition used <a href="https://www.kaggle.com/wiki/MeanAveragePrecision">MEAP (Mean Average Precision)</a> - a metric that takes into account not only the number of correct answers, but also the difference in sorting order. <br><br><h3>  Input parameters </h3><br>  Consider the simplest algorithm, when we believe that the user most likely will click on the most popular advertisement - the one that has the maximum click-through rate (CTR) ratio.  In this case, the input parameters to the model are 2 values ‚Äã‚Äã- the advertisement id and whether the advertisement was clicked.  Special machine learning is not here, the usual statistical metric. <br><br>  Suppose this is our training data, even under displayId, we group advertisements shown to one user in one block: <br><table><tbody><tr><td>  displayId <br></td><td>  adId <br></td><td>  clicked <br></td></tr><tr><td>  one <br></td><td>  one <br></td><td>  0 <br></td></tr><tr><td>  one <br></td><td>  2 <br></td><td>  one <br></td></tr><tr><td>  2 <br></td><td>  one <br></td><td>  one <br></td></tr><tr><td>  2 <br></td><td>  3 <br></td><td>  0 <br></td></tr></tbody></table><br>  To form the first feature, we use the formula adClicked = max adId sum (adId, clicked == 1) / sum (adId) <br><br>  Input values ‚Äã‚Äãare conveniently represented as a vector for one case (often called a feature vector), and matrices for the entire data set are denoted by X. The target variable (Clicked in our case) is y <br><table><tbody><tr><td>  displayId <br></td><td>  adId <br></td><td>  feature_1 <br></td></tr><tr><td>  one <br></td><td>  one <br></td><td>  0.5 <br></td></tr><tr><td>  one <br></td><td>  2 <br></td><td>  one <br></td></tr><tr><td>  2 <br></td><td>  one <br></td><td>  0.5 <br></td></tr><tr><td>  2 <br></td><td>  3 <br></td><td>  0 <br></td></tr></tbody></table><br>  Now, when forming the answer, for each displayId, we sort the displayed advertisements by feature_1 and get the answer in the form: <br><br>  display_id, ad_id <br>  1.2 1 <br>  2.1 3 <br><br>  The first thing to do is to verify the accuracy of the model using the validation mechanism we have already developed.  A model based on frequency with anti-aliasing returns the result significantly better than random predictions: <br><table><tbody><tr><td>  Model name <br></td><td>  Result <br></td></tr><tr><td>  Random guess <br></td><td>  0.47793 <br></td></tr><tr><td>  Frequency with smoothing <br></td><td>  0.63380 <br></td></tr></tbody></table><br>  You can expand the model and calculate the CTR based on the user‚Äôs region as well, and consider statistics for all adId * country * state combinations encountered: <br><table><tbody><tr><td>  adId <br></td><td>  Country <br></td><td>  State <br></td><td>  clicked <br></td></tr><tr><td>  one <br></td><td>  US <br></td><td>  CA <br></td><td>  0 <br></td></tr><tr><td>  2 <br></td><td>  US <br></td><td>  Tx <br></td><td>  one <br></td></tr><tr><td>  one <br></td><td>  UK <br></td><td>  one <br></td><td>  one <br></td></tr></tbody></table><br>  adClicked = max adId sum (adId, clicked == 1, country == displayCountry, state == displayState) / sum (adId) <br><br>  It is important to build attributes for training only from the training data set, excluding the validation and test sets, otherwise we will not be able to adequately assess the accuracy of the model.  If k-fold cross validation is used, such signs will have to be built k times. <br>  Another approach is to generate features in such a way as to reduce the re-training of the model.  For example, I added statistics on the frequency of clicks only for those ads where the number of views is N&gt; 10 (the value is selected during validation).  Motivation - if we add frequencies where the number of ad views == 1, an algorithm with sufficient complexity (for example, a decision tree) will determine the possibility of this feature unambiguously predict the answer and can only use it for prediction, while it is clear that this solution will be quite naive. <br><br>  The whole process of generating features from the input data is often called Feature Engineering, and is often a decisive factor in successful competition, since the algorithms and meta-algorithms for teaching models are generally public. <br><br><h3>  Outbrain competition features </h3><br>  I considered several common groups of features that define: <br><br><ol><li>  User - the one who shows ads <br></li><li>  Advertiser <br></li><li>  Context + Time <br></li></ol><br>  Consider each group in more detail: <br><br><h4>  Custom tags </h4><br>  Using a training set of data and a log of page views, you can choose a lot of interesting things about the user - which advertisements / advertising campaigns he clicked and which ones he always ignored.  Since meta information about the pages led by the advertising (landing page) was given, it is possible to identify which categories of pages or topics \ entities are interesting to the user - if the landing page is sport.cnn, and the user reads sports news often at this time of the day or on this day of the week , it can be tried to use as a sign. <br><br>  These and similar signs will help to later find users with similar preferences and through them to predict whether the user will click on an advertisement. <br><br>  I did the selection of signs manually - based on the change in the accuracy of the estimate before / after the addition. <br><br><h4>  Advertiser Signs </h4><br>  Here it is worth starting with a simple listing of advertising information / landing-page | of an advertising campaign + CTR similar signs based on geo-location, time of day, day of the week ‚Äî for example, stateCTRCamp: the frequency of clicks on an advertising campaign (combines advertisements) in some state <br><br><h4>  Context </h4><br>  By context, I mean both the page on which the ad is displayed and the time of display + user information: geo + device type  Knowing the time, you can list all the advertisements and pages that the user visited / clicked yesterday \ the day before yesterday \ in the last hour.  You can determine the content that is popular at the moment and so on. <br><br><h4>  Used signs </h4><br>  country, state, platform, county, pageDocumentCategories, countryCTRAdv, campaignId, advertiserId, userDocsSeenFromLogYesterday, userClickedThisAdvertiserTimes, hourOfDay, userDocsClickedToday, lastAdvUserClicked <br><br>  The total number of signs - about 120, the absolute majority - developed manually, for example userDocsSeenFromLogYesterday - documents from the click of the log viewed by the user yesterday (relative to the targeted advertising display).  more extended (incomplete) list in the <a href="https://www.kaggle.com/c/outbrain-click-prediction/discussion/27926">technical description of the</a> solution on the competition forum. <br><br>  Most of the features used are categorical ‚Äî for example, country, and one-hot-encoding is used to turn it into a binary one.  Some numerical features were also converted into binary characters by assigning them to a numerical interval, for smoothing some the formula log (x + 1) was used. <br><br>  Coded features occurring less than 10 times are not counted.  The total number of coded features&gt; 5M, hash has not been applied to reduce the dimension. <br><br><h3>  An example of the simplest model is logistic regression </h3><br><br>  Let us construct a logistic regression model that receives simple numerical features as input ‚Äî the frequency of clicks in the country and state: <br><br>  countryAdCTR = sum (adId, clicked == 1, country == displayCountry) / sum (adId) <br>  stateAdCTR = sum (adId, clicked == 1, state == displayState) / sum (adId) <br><br>  The formula for the probability of clicking on advertising will be: <br><br>  y * = f (z), z = w1 * countryAdCTR + w2 * stateAdCTR, f (z) = 1 / (1 + e (-z)) <br><br>  <a href="https://en.wikipedia.org/wiki/Logistic_function">f (z) is a logistic function</a> , returns values ‚Äã‚Äãin the interval [0: 1].  The learning algorithm selects the coefficients w1 and w2 in such a way as to reduce the difference between y * and y - i.e.  maximizes the similarity of predictions and real values. <br><br>  Add the categorization attributes of the advertiser and view_page_domain to the model, having previously converted them to binary using the one-hot-encoding method, for example: <br><br>  Categorical: <br><table><tbody><tr><td>  Sample <br></td><td>  Advertiser <br></td></tr><tr><td>  one <br></td><td>  Adidas <br></td></tr><tr><td>  2 <br></td><td>  Nike <br></td></tr><tr><td>  3 <br></td><td>  BMW <br></td></tr></tbody></table><br>  One-hot-encoded: <br><table><tbody><tr><td>  Sample <br></td><td>  Isadidas <br></td><td>  Isnike <br></td><td>  Isbmw <br></td></tr><tr><td>  one <br></td><td>  one <br></td><td>  0 <br></td><td>  0 <br></td></tr><tr><td>  2 <br></td><td>  0 <br></td><td>  one <br></td><td>  0 <br></td></tr><tr><td>  3 <br></td><td>  0 <br></td><td>  0 <br></td><td>  one <br></td></tr></tbody></table><br>  The formula will be: <br><br>  z = w1 * countryAdCTR + w2 * stateAdCTR + w3 * advertiser + w4 * view_page_domain <br><br>  Since the advertiser and view_page is a vector, both w3 and w4 will also be vectors <br><br>  In CTR prediction, it is very important to take into account the interaction of signs, for example, the page on which the advertisement and advertiser is shown - the probability of clicking on Gucci ads on the Vogue page is completely different than on Adidas ads. The model can be complemented by the interaction between the advertiser and view_page: <br><br>  z = w1 * countryAdCTR + w2 * stateAdCTR + w3 * advertiser + w4 * view_page_domain + w5 * advertiser * view_page_domain <br><br>  We already know that the advertiser and view_page are vectors, which means that the dimension of the vector w5 will be the length of the vector advertiser * the length of the vector view_page. <br><br>  There are several problems with this - at first, it will be a very large vector - all possible domains on which advertisements are multiplied by the number of all possible advertisers.  Secondly - it will be very sparse (sparse) and most of the values ‚Äã‚Äãwill never take the value 1 - we will never meet most of the combinations in real life. <br><br><h3>  Factorization Machines (FM) </h3><br>  FM is well suited for CTR prediction problems, since it explicitly takes into account the interaction of features, while solving the problem of sparseness of data.  A wonderful description can be found in the original <a href="http://www.algo.uni-konstanz.de/members/rendle/pdf/Rendle2010FM.pdf">publication</a> , here I will describe the main idea - each value of the attribute receives an integer vector of length k, and the result of the interaction of signs - the scalar product (dot-product) of vectors - see the formula in the publication in the Model Equation section. <br><br><h3>  Outbrain competition model </h3><br><h4>  Field-aware Factorization Machines (FFM) </h4><br>  During the analysis of the best models, I discovered that the last 2 competitions on CTR prediction were won by the guys with the model (ensemble) <a href="https://github.com/guestwalk/libffm">Field-aware Factorization Machines (FFM)</a> .  This is a continuation of FM, but now the signs are divided into n fields - a kind of group of signs, such as a group of signs consisting of documents viewed earlier, a group of other advertisements in this ad unit, and so on.  Now each feature is represented as n vectors of dimension k - it has a different representation in each other group of features, which allows for more accurate consideration of the interaction between groups of features.  Description and details are also in the <a href="http://www.csie.ntu.edu.tw/~cjlin/papers/ffm.pdf">publication</a> . <br><br><h4>  FFM training </h4><br>  FFMs are highly susceptible to retraining; an early stop is used to combat this ‚Äî after each iteration of the model improvement, accuracy is assessed on the validation set.  If the accuracy falls, the training stops.  I made a few changes to the standard library code, the main of which was the added quality assessment based on the MEAP metric that was used to calculate the result on Kaggle, instead of the standard logloss. <br><br>  One of the teams that ranked in the top 3 also added the possibility of pairwise optimization in FFM. <br><br>  To be able to stop early when learning the whole model, I randomly divided the training set in the 95/5 distribution and used 5% as validation. <br><br>  The final result is a simple average of the results of the work of 5 models on different random distributions with slightly different sets of features. <br><br>  This method of mixing the results on subsamples of a training set is called bagging (bootstrap aggregation) and often allows to reduce the variance, which improves the result.  Also, it usually works well for mixing the results of gradient boosting models (xgboost / lightGBM) <br><br><h4>  What did not work </h4><br>  Models based on gradient booming, consistently gave worse results (comparable to FM), pairwise optimization slightly improved the picture.  Also, the <a href="https://pdfs.semanticscholar.org/daf9/ed5dc6c6bad5367d7fd8561527da30e9b8dd.pdf">generation of features for FFM based on tree leaves from boosting</a> did not work for me.  The FFM ‚Üí FFM or XGBOOST ‚Üí FFM stack was consistently worse than the FFM on the entire data set. <br><table><tbody><tr><td>  Model name <br></td><td>  Result <br></td></tr><tr><td>  My best single model result <br></td><td>  0.69665 <br></td></tr><tr><td>  My best result (mix of 5 models) <br></td><td>  0.69778 <br></td></tr><tr><td>  1st place best result <br></td><td>  0.70145 <br></td></tr></tbody></table><br>  <a href="https://www.kaggle.com/c/outbrain-click-prediction/leaderboard">Final results</a> <br><br><h2>  Code, infrastructure and hardware </h2><br><h3>  Code </h3><br>  The initial merging of files was done using Python, and I usually use Jupyter for data mining and analysis purposes.  I also filtered out the click-log only for users found in the training \ test sets, which made it possible to reduce it from 80 to 10GB. <br><br>  The original Feature engineering was also written in Python, however, given the huge amount of data, which means the time needed to process them, I quickly switched to Scala.  The difference in speed at an approximate estimate was about 40 times. <br><br>  To quickly iterate and estimate the improvement in accuracy, I used a subset of data, about 1/10 of the total. <br><br>  This allowed to get the result about 5-10 minutes after the launch + the models were placed in the memory of the laptop. <br><br>  Generating input files for the final model takes about 3 hours on a 6-core machine.  Total recorded files&gt; 500GB.  The approximate learning and prediction time was 10-12 hours, memory usage was about 120GB. <br><br>  The whole process is automated using scripts. <br><br><h3>  Iron </h3><br>  Most of the work was done on a Dell Alienware laptop (32GB RAM).  For the past few weeks, I also used a workstation (i7-6800, 128GB RAM) and in the last week memory optimized x4large and x8large AWS machines, up to 2x in parallel. <br><br><h2>  Thanks </h2><br>  The article is dedicated to my dear wife, who is very difficult to experience the time when her husband is at home, but at the same time he is not. <br><br>  Thanks also to Artem Zaik for comments and reviews. <br><br><h2>  Conclusion </h2><br>  From my point of view, participation in competitions at Kaggle and the like is a great way to learn how to solve real problems using real data and evaluating your decisions against real competitors.  Speaking at a high level also often requires the allocation of a large amount of time and effort, especially with full-time work and personal life has not been canceled, so such competitions can be viewed as competitions also with oneself - to win first and foremost yourself. </div><p>Source: <a href="https://habr.com/ru/post/323938/">https://habr.com/ru/post/323938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323928/index.html">All programmers get into # TAI</a></li>
<li><a href="../323930/index.html">On the market, a cow man sold</a></li>
<li><a href="../323932/index.html">IL2CPP: P / Invoke wrappers for types and methods</a></li>
<li><a href="../323934/index.html">How to make a sidebar in 5 lines of code</a></li>
<li><a href="../323936/index.html">Do hint services suggest well? We measure the usefulness of autocompletion web services</a></li>
<li><a href="../323940/index.html">Kanban in engineering product management</a></li>
<li><a href="../323942/index.html">Go digest Events, articles, interesting projects from the world of Go [March 1 - 14, 2017]</a></li>
<li><a href="../323944/index.html">Digest of practical materials on working with IaaS</a></li>
<li><a href="../323946/index.html">The world's first search engine: Historical excursion</a></li>
<li><a href="../323948/index.html">Scientists cured AI from forgetfulness</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>