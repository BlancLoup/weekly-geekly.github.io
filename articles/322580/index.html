<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Wayland to replace the X Window System</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous post, we learned why the X Window System is one of the most successful open source projects in history, and it‚Äôs time to replace it wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Wayland to replace the X Window System</h1><div class="post__text post__text-html js-mediator-article"><p>  In the <a href="https://habrahabr.ru/post/321470/">previous post,</a> we learned why the X Window System is one of the most successful open source projects in history, and it‚Äôs time to replace it with a new solution for the Linux graphical environment.  In the same article, we‚Äôll find out how <em>Wayland</em> is - the most likely candidate for a replacement for X. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/bb8/fc1/16d/bb8fc116db00da7b8dbd701de4eef069.png"><br><p><br></p><a name="habracut"></a><br><h3 id="glossariy-wayland">  Wayland Glossary </h3><br><p>  It makes sense to first deal with some definitions and terminology. </p><br><p>  <strong>Compositor</strong> - Composite window manager is one of the central concepts of <em>Wayland</em> and around it.  Nowhere is it really defined what it is, but this term is used as if everyone knows everything.  In any case, I did not find any definition in Russian.  Fortunately, examples clarify the essence of the matter.  Here is a list of them in the context of <em>Wayland</em> : </p><br><ul><li> <code>KWin</code> - KDE Display Server, </li><li>  <code>Mutter</code> is the GNOME display server, </li><li>  <code>Weston</code> - the reference composite manager for <em>Wayland</em> , </li><li>  <code>Enlightenment</code> - desktop GUI, </li><li>  <code>Marco</code> is the MATE window manager. </li></ul><br><p>  As we can see, this is nothing more than window managers familiar to us, although in fact not.  These are <em>display servers</em> , which all the same differ in their functionality from WM.  The former interact with user input / output devices, with iron, and control the flow of client program data.  The latter are responsible for displaying windows and placing them in the window interface system. </p><br><p>  <em>Illustration from wikipedia <a href="https://en.wikipedia.org/wiki/Display_server">page</a></em> . </p><br><img src="https://habrastorage.org/files/3c0/31d/ed1/3c031ded17a64409a9608f057d2a4f2f.png"><br><p><br></p><br><p>  But to say that there is a clear semantic and terminological boundary between all these servers, managers <del>  and composers </del>  , it would be a hoax.  For example, <code>KWin</code> is both a display server and WM, just like <code>Enlightenment</code> .  For this article, a <em>composite window manager</em> (abbreviated as KOM) and a <em>display server</em> will be equivalent to the term <em>Compositor</em> . </p><br><pre> <code class="hljs pgsql">$ eix -c enlightenment; eix -ce kwin [N] x11-wm/enlightenment (<span class="hljs-number"><span class="hljs-number">1.0</span></span><span class="hljs-number"><span class="hljs-number">.17</span></span>): Enlightenment <span class="hljs-keyword"><span class="hljs-keyword">Window</span></span> Manager (e16) [I] kde-plasma/kwin (<span class="hljs-number"><span class="hljs-number">5.8</span></span><span class="hljs-number"><span class="hljs-number">.5</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)@<span class="hljs-number"><span class="hljs-number">01.02</span></span><span class="hljs-number"><span class="hljs-number">.2017</span></span>): KDE <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> manager</code> </pre> <br><p>  A composite manager, or a display server, may also be referred to as a <em>composite window manager</em> . </p><br><pre> <code class="hljs pgsql">$ eix -c mutter [N] x11-wm/mutter (<span class="hljs-number"><span class="hljs-number">3.20</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>): GNOME <span class="hljs-number"><span class="hljs-number">3</span></span> compositing <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> manager based <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Clutter</code> </pre> <br><p>  <strong>Weston</strong> - Reference Wayland Protocol Display Server.  Recently <a href="https://www.linux.org.ru/news/opensource/13247666">came the</a> second version of the COM. <br>  <strong>EGL</strong> is the platform-independent equivalent of the OpenGL GLX / AGL / WGL software interfaces, developed by the Khronos Group.  EGL provides an infrastructure set for quick application setup and scene initialization. </p><br><ul><li>  Mechanisms for creating rendering areas (window, pixel map, pixel buffer) so that client APIs can draw and separate them onto them. </li><li>  Creating a graphical context for client APIs. </li><li>  Synchronization of rendering by client APIs as well as native rendering APIs of the platform. </li></ul><br><p>  EGL, unlike GLX / AIGLX, can only perform <em>direct rendering</em> , in which applications through DRI2 / DRI3 can safely and quickly access video equipment bypassing the X server. </p><br><p>  <strong>GLES</strong> - A subset of OpenGL designed specifically for embedded systems - mobile phones, tablets, computers, game consoles. </p><br><h3 id="arhitektura-wayland">  Wayland architecture </h3><br><p>  So what is <em>Wayland</em> ?  As with the X Window System, this is a protocol and its implementation.  <em>Wayland</em> is a protocol for interaction between COM and clients, as well as its library implementation in C.  The client can be a custom application, an X server, or another display server. </p><br><ul><li>  Goal: radically simplify the Linux graphical environment compared to X. </li><li>  Uses Unix Domain Sockets, no network transparency. </li><li>  Mainly uses EGL and DRI. </li><li>  I / O devices are managed entirely from the kernel. </li><li>  Buffer allocation and rendering completely on the client side. </li></ul><br><p>  At the lowest level of the protocol, the client and KOM synchronize messages, exchange ordered objects using the IPC libraries <code>libwayland-client</code> and <code>libwayland-server</code> .  At this level, the methods for controlling the window interface are not defined - only messages transmitted via Unix Domain Sockets, objects and events. </p><br><pre> <code class="xml hljs">+-------------------+ +-------------------+ | | | | | Client | | Compositor | +-------------------+ +-------------------+ | libwayland-client | | libwayland-server | +-------------------+ +--+----------------+ | | | Wayland | User space | protocol | +---------------------------------------------------+ | Kernel space | +---+ | | | +------&gt;|IPC|<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">----+</span></span></span><span class="hljs-tag"> | | +</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">---</span></span></span><span class="hljs-tag">+ | +</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">---------------------------------------------------</span></span></span><span class="hljs-tag">+</span></span></code> </pre> <br><p>  Objects created by the client are represented by the <code>wl_proxy</code> structure, which contains the message identifier transmitted to the server via a socket, the <code>void</code> data pointer, and a pointer to the static <code>wl_interface</code> object.  Messages are sent using the <code>wl_proxy_marshal</code> structure. </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> inline void wl_surface_attach(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wl_surface</span></span></span></span> *wl_surface, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wl_buffer</span></span></span></span> *buffer, int32_t x, int32_t y) { wl_proxy_marshal((<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wl_proxy</span></span></span></span> *) wl_surface, WL_SURFACE_ATTACH, buffer, x, y); }</code> </pre> <br><p>  <em>Wayland</em> is an asynchronous, object-oriented protocol designed to handle messages.  The message sent from the client to the server is a <em>call</em> , and in the opposite direction an <em>event</em> .  Each message consists of 32-bit words, the values ‚Äã‚Äãare presented in the order of the host bytes. </p><br><p>  <em>Illustration from the <a href="https://wayland.freedesktop.org/architecture.html">main page of</a> Wayland</em> . </p><br><img src="https://habrastorage.org/files/6c0/3a8/612/6c03a8612e0848a597c44400e6d83ded.png"><br><p><br></p><br><p>  How do these blocks interact? </p><br><ol><li>  The kernel registers an event and sends a COM to it. </li><li>  KOM in its scene graph finds the window to which this event should be delivered and he knows exactly what type of transformation should be applied to the object.  KOM translates screen coordinates into local ones for a given window by inverse transformation. </li><li>  The client, fulfills the event, updating the graphical interface, renders and notifies the COM about the changes. </li><li>  The CLC collects from the clients all the data for the territories in which the contents of the dependent buffer differ from the surface area, and then rearranges the screen.  Next, the display server loads the new page, using the ioctl call to the addressed KMS. </li></ol><br><p>  How does the rendering work?  Clients independently render their windows in a separate buffer, passing information about updates to the display server, which combines the contents of the buffers of different applications to form the final output, taking into account possible nuances, such as overlapping windows and transparency. </p><br><h3 id="wayland-vs-x">  Wayland vs.  X </h3><br><p>  So why is <em>Wayland</em> different for the better?  Let's go over the main points in order to understand for what it was all going.  For me personally, it‚Äôs enough that the <code>xorg.conf</code> configuration file is missing.  However, the fruitful influence of direct hands on editing this file has already been discussed in the comments to the previous post. </p><br><ol><li>  Versions permeate the protocol from top to bottom.  Each interface has one or another version, each protocol object implements a specific version of its interface.  This <strong>eliminates the situation with the constant conflicts of versions of</strong> X due to the fact that version negotiation is tied to clients and not to the connection.  If the application supports one version of the extension, the toolkit is another and X11 is the third, then it is impossible to predict what the application will receive. </li><li>  Working with input devices in <em>Wayland is</em> very similar to <code>Xinput 2.2</code> minus the <code>Xinput 2.2</code> obsolete code and Master / Slave order between input devices.  The global object is a <code>seat</code> , i.e. a <em>place</em> defines a group of input devices, including a mouse, keyboard, and a touch screen.  The nightmarish multitouch problems will disappear. </li><li>  <em>Wayland,</em> in contrast to X, <strong>does not have an</strong> API for rendering, and therefore does not deal with arts.  All he needs is buffers full of client pixels, and then he conducts them so that Appendix A does not spoil anything in the buffers containing the pictures of Appendix B. Clients determine which pixels are in the buffers and are responsible for the image that will be displayed on screen! </li></ol><br><p><img src="https://habrastorage.org/files/b64/a95/69b/b64a9569b1a046ab8724df1181732731.png"><br></p><br><ol><li>  <em>Wayland</em> is minimal.  Recall what X was a state in a state, with a full set of OS kernel functions, and even had its own print server, after someone got the idea to add print support for glxgears.  So, all this in <em>Wayland is</em> not and never will be.  Clients are carrying the main burden on themselves, and this is great, since they themselves will not want to bend under the weight of compatibility of UI elements 30 years ago. </li><li>  Mandatory compositing.  This does not mean that 3D effects are inevitable.  Layout means a seamless image that does not shake or jump.  <em>Wayland's</em> motto is <del>  not a single gap </del>  <em>every frame is beautiful</em> .  Each pixel in its place, as the client conceived and implemented.  For comparison, how does the X Composite extension work?  For desktop effects, the GL layout quite pulls the strap, but when you watch the video in the browser, problems immediately begin.  The browser window and the subwindow with the flash player are not synchronized at all.  For them, events are processed independently and it remains only to hope that the two streams will not diverge significantly in time.  For this reason, while scrolling through the window with the active Youtube video, the image may jump and twitch. </li><li>  No fonts on the server, customers can handle it.  Already cope. </li><li>  X suffers from unconsciousness, which is why the notorious <code>xfree86.conf/xorg.conf</code> is needed to remember the settings for two or more monitors, graphic cards.  We are not going to be bored without these <em>killer features</em> in the coming post-X era? </li></ol><br><h3 id="oshibochnye-suzhdeniya-ob-x-i-wayland">  Wrong judgments about X and Wayland </h3><br><p>  There are a number of consistently incorrect opinions on this subject. </p><br><ul><li>  X is unix.  Well, how to say, <em>do one thing to the</em> principle <em>, but do it well.</em> Unix cumbersome omnivorous X clearly contradicts. </li><li>  Network transparency X. Yes, it was-was, but it has passed since X moved to <code>DRI2</code> and shared memory, and both cannot work on the network.  Everything revolves on the slow synchronous <code>Xlib</code> , and the exhaust is obtained as with VNC, if not worse. </li><li>  <em>Wayland is</em> written by those who do not understand X. Nothing is farther from the truth - it is written by those X developers who are tired of constantly patching holes and repairing crutches.  A good example is Daniel Stone, one of three people on earth who <a href="http://www.opennet.ru/opennews/art.shtml%3Fnum%3D36080">know exactly</a> how the X keyboard binding works. </li><li>  <em>Wayland</em> imposes 3D.  It is not, only the layout is required.  This has already been said above. </li></ul><br><h3 id="ispolzovannye-materialy-i-poleznye-ssylki">  Used materials and useful links </h3><br><p>  <a href="http://www.phoronix.com/scan.php%3Fpage%3Darticle%26item%3Dx_wayland_situation">The Wayland Situation: Facts About X vs.</a>  <a href="http://www.phoronix.com/scan.php%3Fpage%3Darticle%26item%3Dx_wayland_situation">Wayland</a> <br>  <a href="http://www.opennet.ru/opennews/art.shtml%3Fnum%3D34118">Layer development status for running X11 applications over Wayland</a> <br>  <a href="https://wayland.freedesktop.org/docs/html/">Wayland Documentation</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322580/">https://habr.com/ru/post/322580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322564/index.html">Prospects for the development of public data</a></li>
<li><a href="../322566/index.html">Authorization in ASP.NET Core MVC</a></li>
<li><a href="../322570/index.html">Technical support 3CX responds: sound files are not played and iOS client does not ‚Äúwake up‚Äù</a></li>
<li><a href="../322572/index.html">"Moisten" objects using Cuckoo</a></li>
<li><a href="../322574/index.html">Watching user</a></li>
<li><a href="../322584/index.html">JQuery Masonry - dynamic layout, typeset without ‚Äúholes‚Äù</a></li>
<li><a href="../322586/index.html">Penguin grub color</a></li>
<li><a href="../322588/index.html">Translation of the ESRI Interior Building Data Model Concept (BISDM)</a></li>
<li><a href="../322592/index.html">The experience of creating a course on Android development on Udemy</a></li>
<li><a href="../322596/index.html">Implementing OOP inheritance in classes that work with SQL and MS Entity Framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>