<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Shadowplay LED Watch on the Arduino Uno Platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instead of intro 


 So, our team of three people was faced with the task: to assemble a small hardware project in a very short time, preferably on th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Shadowplay LED Watch on the Arduino Uno Platform</h1><div class="post__text post__text-html js-mediator-article"><h3>  Instead of intro </h3><br><img src="https://habrastorage.org/files/48b/451/4a6/48b4514a6fd144ba8e19798a1588bd87.JPG"><br><br>  So, our team of three people was faced with the task: to assemble a small hardware project in a very short time, preferably on the Arduino platform.  It is worth making a reservation that up to that moment we were familiar with circuitry, for the most part, in theory.  And that means - neither the experience with a soldering iron (practically), nor, all the more, the experience with an Arduino. <br><br>  Suddenly, we stumbled upon <a href="http://arduino-projects.ru/projects/shadowplay-clock/">an article</a> dedicated to the project Shadowplay Clock.  This wall clock, designed by a team of Viennese designers, the time on which you can see by touching your finger to their center.  The LEDs light up in such a way that the finger shadow in the center shows the time.  It was decided to create the same (or very similar), but at home.  The above article, as you can see, does not contain a detailed description of the project.  From all this it followed that we ourselves had to figure out how this device worked, and bring it to life.  What we actually do. <br><a name="habracut"></a><br><h3>  Materials </h3><br>  To create watches you need: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  fiberboard blanks </li><li>  60 diode LED strip </li><li>  Arduino uno </li><li>  RTC DS1307 real time clock module </li><li>  button </li><li>  bread board </li><li>  shift register 74HC595 (x2) </li><li>  8-bit register latch 74HC573N (x8) </li><li>  4-16 K155ID3 decoder </li><li>  open drain inverter IN74HC05AN (x10) </li><li>  Power Supply </li></ul><br><h3>  Let's get started </h3><br>  So, the algorithm of the device: <br><br><ol><li>  When power is applied, the LEDs turn on in the specified combination.  In the original Shadowplay, all the LEDs light up, but it seemed to us that it would be more interesting to launch some combination as a screensaver. </li><li>  When you press the button (yes, we also moved away from the original and inserted a small button in the center), the time is read from the RTC module. </li><li>  The read time is converted into a binary code (mask) and entered into registers. </li><li>  Depending on the mask, the required diode is lit. </li></ol><br><h4>  Hardware </h4><br>  When we finally decided on the idea of ‚Äã‚Äãthe project, first of all we tried to mentally sketch out approximate versions of schemes for its implementation.  The main question was how to address 60 LEDs.  As a matter of fact, the answer to this question determined the way of constructing practically the whole scheme. <br><br>  The first option that came to mind was associated with the use of decoders.  The scheme was a cascade of four decoders 4 - 16 and one decoder 2 - 4, both of which with decoding enable inputs.  Such a cascade made it possible to provide addressing to 64 outputs, which was enough to connect 60 LEDs. <br><br>  However, then the question arose about how with this scheme at the same time get to work (address) more than one LED (after all, we needed to provide the clock with at least the minute and hour hands).  This is where the main drawback of this scheme manifested itself - the decoder cannot, by definition, address more than one output simultaneously. <br><br>  This flaw forced us to abandon the idea of ‚Äã‚Äãa cascade of decoders.  In addition, now we have another requirement for the future scheme - support for the simultaneous operation of a different number of LEDs. <br><br>  To satisfy this requirement, we thought that it would be possible to allow each LED to store its state.  Registers are well suited for this purpose, where each individual digit corresponds to the state of one of the LEDs.  We decided to use registers for 8 bits, as they are more common and more practical.  Accordingly, in our scheme, we need 8 such registers to provide support for 60 LEDs. <br><br>  Then we thought about how to manage the state of LEDs with Arduino through registers.  Each register for normal operation must receive all 8 bits entirely.  Arduino Uno, of course, provides enough outputs for transmitting several bits at the same time, but this approach would not be rational.  In addition, there are only 8 registers in the scheme, which means you need to address them somehow.  For this purpose, we added a descrambler and two 8-bit shift registers connected by a cascade to the circuit.  One shift register stores an 8-bit state mask that will be loaded into one of 8 regular registers, the number of which is stored in the second shift register.  Accordingly, a descrambler is connected to the second shift register.  For these purposes, a decoder is enough for 3 to 8. <br><br>  To remove the inversion from the required number of outputs, we used two inverter circuits KR1533LN1.  This, of course, somewhat complicated the scheme. <br><br>  Another task was the operating voltage of the LEDs equal to 12 volts compared with 5 volts of logic chips.  The proposed solution was to use an open drain inverter.  Such a microcircuit plays the role of a key that closes (with logical 1) or opens (with logical 0) one of the contacts of the LED with the ground, thereby turning on or off the LED.  The circuit assumes work from 12 volts, in accordance with the operating voltage of the LEDs, therefore, in order to get 5 volts for logic chips, a stabilizer KR142EN5A with two capacitors was added to the circuit. <br><br>  Some inputs of certain microcircuits imply a constant value at the input, so they were brought to the ground or power supply.  In this case, these are the following inputs: <br><br><ul><li>  Inverse reset MR input in both shift registers through the load register is connected to the output of the stabilizer at 5 volts. </li><li>  The inverse enable input output OE in both shift registers is connected directly to ground. </li><li>  The inverted enable input of the E0 decoder is connected to ground </li></ul><br><br><img src="https://habrastorage.org/files/994/7dc/3c6/9947dc3c61754b44b034f4670f846fbc.png"><br><br>  The circuit is controlled by four inputs (E1, SH, ST, DS).  The purpose and signal levels of each of them will be discussed in more detail below: <br><br>  Input E1 is designed to enable the decoder.  In our case, initially there are two control inputs E1, E0 on the decoder, and both of them are inverse.  Output will be enough and one, so the second (E0) can be brought to the ground.  The state of the decoder ‚Äúby default‚Äù is operational until you have a high signal level at E1.  In order to do the opposite, we connected this input to the inverter.  Without this, the decoder may issue incorrect control signals to the registers, for example, at the time of updating the data in the shift register.  As already mentioned, a 3 by 8 decoder can be used in the circuit, which can have one non-inverse control input, which will make it possible to easily solve all the problems described above without unnecessary wires and a soldering iron. <br><br>  When applying a single signal level to E1, the decoder decodes the address of the register located in the corresponding shift register, and sends a signal to the desired output.  After that, the decoder is turned off again by applying a low level signal to E1.  Such a switching of the decoder generates a signal at the desired output, the front and the fall of which serve to register the clock pulse for snapping into itself the data stored on the bus. <br><br>  The following three inputs are intended to control shift registers.  It is worth starting with the simplest thing - DS data entry.  This input, as the name implies, is intended for data transmission.  Since the shift registers in the circuit are connected in cascade, DS is the corresponding output of one of them.  The input of the second shift register is connected to the output of the last digit of the first register.  The result is a single shift register for 16 bits, of which only 12 bits are used. <br><br>  The SH input is the clock input.  This input is supplied with a meander, which is responsible for loading and shifting data in each of the registers, respectively, this contact of the circuit is connected to the SHCP pins of both registers. <br><br>  The last pin of the ST is the data latch on the register outputs.  A pulse is fed to this input, but it is fed only when the data in the shift register are loaded finally and it is required to fix them at the output of the registers.  Only after the application of this signal, the loaded data inside the register on the first row of triggers fall on the second row of triggers and become available on the bus.  ST is a contact connected to the STcp pins of both registers. <br><br>  It remains to explain the layout of the two outputs of the MR and OE shift registers.  The first input (MR) is responsible for resetting data within the register.  In this scheme, this possibility is not required, therefore, a high signal level is applied to this output through the load. <br><br>  The second register input (OE) is responsible for disabling the second row of triggers inside the shift register from the bus, i.e., the enable input.  This function is also not required, so the output starts on the ground. <br><br>  Another contact not described above is designed to remove the level of the signal from the button in the center of the clock, the button's pattern is typical and represents the load and key, depending on the position of which a low or high signal is applied to the Arduino.  Depending on the button state, the clock works either in the screen saver mode or in the time display mode. <br>  Connecting to an Arduino has no features, except that the SH pin ideally connects to the SCK digital pin.  The remaining outputs of the circuit can be connected to any of the available general-purpose digital inputs.  In our case, the connection is as follows: <br><br><ul><li>  Arduino pin13 (SCK) - SH circuit output </li><li>  Arduino pin 11 - output circuit ST Arduino pin 8 - output circuit DS Arduino pin 5 - output circuit E1 Arduino pin 3 - output button Arduino pin GND - circuit ground (also connects to the power supply ground) <br>  After the design was completed, work began on the basis for the clock. <br><br>  The blanks were made of fiberboard: a circle with a diameter of 36 cm - the back of the clock;  and a ring measuring 36 cm (outer diameter) \ 26 cm (inner diameter) - the front part.  In the original, Shadowplay has a circle diameter of 72 cm, but 36 was enough for us. The LED tape, previously cut into 60 pieces (diode + resistor), is glued to the circle.  On the border of the circle drilled holes.  Through them, the wires connected to the LEDs will be connected to the breadboard, which is located on the back of the circle. <br><br><img src="https://habrastorage.org/files/c46/3ff/f0b/c463fff0b95e402eaf9b4274301f04ba.jpg"><br><br>  In fact, the LEDs brought a lot of headaches.  Simply sticking them to the surface of the circle, we did not slightly calculate.  The result was that the shadow LEDs were not bright enough.  And therefore it was necessary to spend a lot of time to ‚Äúlift‚Äù their degrees by 50 - 60, placing triangular cardboard linings under each of them.  Yes, 60 small cardboard triangles.  Therefore note: do not repeat our bitter experience - stock up on pads in advance. <br><br><img src="https://habrastorage.org/files/871/643/435/87164343503642ba802ead947d81ab6a.JPG"><br><br>  We were running out of time, and there was no time to erase the PCB.  Therefore, a volitional decision was made - to assemble the project on a breadboard.  The fact that such a scheme is not easy enough to assemble on a breadboard, we found out much later.  Well, negative experience is also an experience. <br><br><div class="spoiler">  <b class="spoiler_title">Development board and general view of the device from behind.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f95/9cc/f6d/f959ccf6d1c34b58ac31411eb3477a99.jpg"><br></div></div><br>  Yes, yes, we are ashamed. <br><br>  It was originally planned to make an exact copy of Shadowplay.  However, the way in which the user's finger is detected in the center of the device was not described in the article.  After reflection, we came to the conclusion that a photoresistor is possible for these purposes.  However, they soon abandoned this idea, since  the photoresistor may have a random response.  The device can be in conditions of varying degrees of illumination, which means it will not always be able to detect a finger with 100% probability.  The preference was given to the button, which we placed in the center of the structure.  It has one more advantage besides reliability.  Despite its small size, the shadow of it is perfect for the role of a clock hand.  Thus, if desired, the device can be programmed to work continuously in the clock mode and without putting a finger. <br><br>  After the whole circuit was soldered (long sleepless nights of painstaking work with a soldering iron and tweezers), the inverters' leads are connected to the LEDs, a solemn moment has come - the first attempt to turn on the device.  And, lo and behold, the diodes really burned!  But not all.  At first, it appeared that something was nevertheless wrongly welded.  However, as it turned out, the reason was different.  Since at the first start we connected not all the control inputs of logic chips, but only the most necessary ones, an ambiguity in the voltage levels appeared on the remaining unplugged inputs.  In addition, the circuit was assembled on a mock-up board, with a large pile of wires, and not etched. The wires were significantly affected by electromagnetic radiation. Consequently, at the slightest voltage jump due to pickup on non-connected inputs, the logic element could work.  As a result, any object in close proximity to the board caused EMP and, accordingly, unpredictable behavior of logic, and with it the LEDs. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/uy-cLHOz-5M%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhguk2BZR26JnLOJvZE1v3KhKJdRKg" frameborder="0" allowfullscreen=""></iframe><br><br>  As a result, the problem had a fairly simple solution.  It was enough to initialize the inputs of all the logic elements on the circuit.  Those.  fully connect the circuit so that there are no unused inputs, (inputs, outputs do not affect this problem, because the logic of the chips does not depend on them), and everything fell into place. <br><br><h4>  Software part </h4><br>  So, the hardware is finished (practically).  It was the turn of writing a program for Arduino.  First of all, it is necessary to configure the RTC module, namely, add time to it.  The chip is based on a high-precision DS1307 module, the connection interface is I2C.  The internal calendar in it is calculated to 2100, taking into account leap years.  Due to the battery charge, the module can operate autonomously for about one year.  Below is a diagram of the connection of RTC to Arduino, found on <a href="http://zelectro.cc/RTC_DS1307_arduino">this site</a> .  It also took a lot of information about the RTC module. <br><br><img src="https://habrastorage.org/files/c76/129/084/c761290840164f52a699e8f7d0c23a50.jpg"><br><br>  After that, it remained only to write a code that reads the time from the RTC, converts it into a mask and sends it to the board. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Time.h&gt; #include &lt;DS1307RTC.h&gt; char REG [8]; tmElements_t te; int c,reset=1; void setup() { pinMode(13, OUTPUT); pinMode(11, OUTPUT); pinMode(8, OUTPUT); pinMode(5, OUTPUT); pinMode(3, INPUT); Serial.begin(57600); //      RTC   //te.Hour = 18; //te.Minute = 50; //te.Second = 0; //te.Day = 20; // //te.Month = 4; //  //te.Year = CalendarYrToTm(2016); //RTC.write(te); } void loop() { if(digitalRead(3)) // ,     {RTC.read(te); SetShadowTime(te.Hour,te.Minute,te.Second,2); //       delay(900); reset=1; } else //    ,   {wait1(); reset=1; } //  for(int j = 0; j&lt;8 ; j++) SetUpLightByMask(j,0); } //=======================================================================  void SetUpLightByMask(int RegNum, char LightMask) //          { digitalWrite(5, LOW); digitalWrite(11, LOW); shiftOut(8, 13, MSBFIRST, LightMask); shiftOut(8, 13, LSBFIRST, RegNum); digitalWrite(11, HIGH); digitalWrite(5, HIGH); } void digitalClockDisplay() { //    RTC  ,    RTC RTC.read(te); Serial.print(te.Hour); Serial.print(" : "); Serial.print(te.Minute); Serial.print(" :"); Serial.print(te.Second); Serial.print(" "); Serial.print(te.Day); Serial.print(" "); Serial.print(te.Month); Serial.print(" "); Serial.print(tmYearToCalendar(te.Year)); Serial.println(); } //     ,     , ,        : //0 -  ,1 -   , 2 -     void SetShadowTime(int Hours, int Minutes, int Seconds, int param){ int h,hshift,m,s; for(int j = 0; j&lt;8 ; j++) REG[j] = 0; if(Hours &gt;= 12) Hours -= 12; h = Hours + 6; if(h &gt;= 12) h -= 12; hshift = (int) Minutes / 12; REG[(int)(((h*5)+hshift)/8)] = REG[(int)(((h*5)+hshift)/8)] | 1&lt;&lt;(((h*5)+hshift)%8); if(param == 1) {m = Minutes + 30; if(m &gt;= 60) m -= 60; REG[(int)(m/8)] = REG[(int)(m/8)] | 1&lt;&lt;(m%8); } if(param == 2) {m = Minutes + 30; if(m &gt;= 60) m -= 60; REG[(int)(m/8)] = REG[(int)(m/8)] | 1&lt;&lt;(m%8); s = Seconds + 30; if(s &gt;= 60) s -= 60; REG[(int)(s/8)] = REG[(int)(s/8)] | 1&lt;&lt;(s%8); } for(int j = 0; j&lt;8 ; j++) SetUpLightByMask(j,REG[j]); } void wait1() //     {for(int a = 0; a &lt; 8; a++) {c=0; for(int b = 0; b &lt; 8; b++) {c = c &lt;&lt; 1; c = c | 1; SetUpLightByMask(a, c); delay(10); } } for(int a = 0; a &lt; 8; a++) {c=255; for(int b = 0; b &lt; 8; b++) {c = c &lt;&lt; 1; SetUpLightByMask(a, c); delay(10); } } }</span></span></span></span></code> </pre> <br></div></div><br><h4>  Assembly </h4><br>  You can assume the device is almost ready.  It remains only to collect all the component parts together and run.  The development board and the remaining parts (Arduino, RTC) were attached to the back of the watch.  A ring hiding the details of the implementation is fixed over the circle with LEDs.  To divert the user's attention from the imperfections of the design, the ring was painted with a ‚Äúa la microcircuit‚Äù pattern.  And finally - plugged into the outlet.  Result below: <br><br>  We are sorry for the quality of the photo. <br><br><div class="slideshow"><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.slideshare.net/slideshow/embed_code/61634811&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhjB_Zt14H9WDFSPzOvFYbXaNmZGrg" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></div><br><br>  Here is a small example of what combinations you can run as a ‚Äúsplash screen‚Äù: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/KbbakER89U0%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhle8B3FHcctmbTxmdWrrZ0TVJPmw" frameborder="0" allowfullscreen=""></iframe><br><br>  But, in fact, the clock is in working condition: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/SIPI6ug_dls%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi1aRYTUVwq0rYOugWjAWTqHxPMiQ" frameborder="0" allowfullscreen=""></iframe><br><br>  The movement of the arrows here is slightly accelerated to show that both the minute and the hour are shifted. <br><br>  And yes, anticipating a question that you probably want to ask.  How to distinguish between hour, minute and second hands?  There was a lot of controversy on this topic.  Various solutions were proposed for this problem: from the multi-colored illumination of the arrows to the alternate switching on of the arrows (first hourly, minutely after a short time, etc.).  However, looking at the original, we realized that Viennese designers, in principle, did not bother with this issue.  It was decided to turn a blind eye to this little flaw.  It will probably be eliminated in the future. <br><br><h4>  Total </h4><br>  What we have? <br><br><ul><li>  Watch, like the Viennese designers, only with their own hands. </li><li>  With a flick of the wrist, the watch turns into an elegant lamp. </li><li>  The ability to easily programmatically change the order of flashing LEDs, which gives an infinite variety of combinations. </li></ul><br>  We do not claim the absolute correctness of our circuit and software solutions.  As already mentioned, negative experience is also an experience.  Maybe this article will help someone avoid our mistakes. <br><br>  Thanks for attention! </li></ul></div><p>Source: <a href="https://habr.com/ru/post/394107/">https://habr.com/ru/post/394107/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../394097/index.html">[HATE] Pain. RusMARC format</a></li>
<li><a href="../394099/index.html">Apple sent its people to a user who has lost files in iTunes</a></li>
<li><a href="../394101/index.html">Poll: what language is used in your OS</a></li>
<li><a href="../394103/index.html">Wind and ice on mars</a></li>
<li><a href="../394105/index.html">A smart bluetooth swab tells you when it's time to change</a></li>
<li><a href="../394109/index.html">Committee of the State Duma approved a bill on total tapping users</a></li>
<li><a href="../394111/index.html">How long or where to quickly store information on disk</a></li>
<li><a href="../394113/index.html">AOC and Jide have released all-in-one PC on Remix OS</a></li>
<li><a href="../394115/index.html">How much is your idea?</a></li>
<li><a href="../394119/index.html">The failure of the United States of RD-180 engines threatens some programs of NASA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>