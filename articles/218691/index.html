<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Diagnosing a Heartbleed Error in OpenSSL. (The final diagnosis has not yet been made, although the treatment is already in full swing)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's Preface  Starting to translate this article, I assumed that the author understood the problem. 
 However, as some users of Habr have righ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Diagnosing a Heartbleed Error in OpenSSL. (The final diagnosis has not yet been made, although the treatment is already in full swing)</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">Translator's Preface</b> <div class="spoiler_text">  Starting to translate this article, I assumed that the author understood the problem. <br>  However, as some users of Habr have rightly shown (thanks to <a href="https://habrahabr.ru/users/vbart/" class="user_link">VBart</a> ), not everything is so simple and the mention by the author of malloc, mmap and sbrk confused him even more. <br>  In connection with this article is of more historical interest than technical. <br>  <b>Update</b> The author updated his post in the same way as the discussion in the comments to this translation. <br></div></div><br><br>  When I wrote about a <a href="http://blog.existentialize.com/the-story-of-the-gnutls-bug.html">bug in GnuTLS</a> , I said that this is not the last serious error in the TLS stack that we will see.  However, I did not expect that everything would be so pitiable. <br><br>  <a href="http://heartbleed.com/">Error in Heartbleed</a> is a particularly nasty bug.  It allows an attacker to read up to 64 KB of memory, and security researchers say: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  Without using any confidential information or credentials, we were able to steal the secret keys used for our X.509 certificates, usernames and passwords, instant messages, email and important business documents and communication. </blockquote><br><a name="habracut"></a><br><h4>  Bug </h4><br>  <a href="http://git.openssl.org/gitweb/%3Fp%3Dopenssl.git%3Ba%3Dcommitdiff%3Bh%3D96db9023b881d7cd9f379b0c154650d6c108e9a3">The fix</a> starts here in <i>ssl / d1_both.c</i> : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dtls1_process_heartbeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SSL *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = &amp;s-&gt;s3-&gt;rrec.data[<span class="hljs-number"><span class="hljs-number">0</span></span>], *pl; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> hbtype; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> payload; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Use minimum padding */</span></span></code> </pre> <br><br>  So, first we get a pointer to the data in the SSLv3 entry, which looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ssl3_record_st</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> type; <span class="hljs-comment"><span class="hljs-comment">/* type of record */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-comment"><span class="hljs-comment">/* How many bytes available */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> off; <span class="hljs-comment"><span class="hljs-comment">/* read/write offset into 'buf' */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data; <span class="hljs-comment"><span class="hljs-comment">/* pointer to the record data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *input; <span class="hljs-comment"><span class="hljs-comment">/* where the decode bytes are */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *comp; <span class="hljs-comment"><span class="hljs-comment">/* only used with decompression - malloc()ed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> epoch; <span class="hljs-comment"><span class="hljs-comment">/* epoch number, needed by DTLS1 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> seq_num[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* sequence number, needed by DTLS1 */</span></span> } SSL3_RECORD;</code> </pre><br><br>  The structure that describes the records contains type, length, and data.  Let's <b>go</b> back to <b>dtls1_process_heartbeat</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Read type and payload length first */</span></span> hbtype = *p++; n2s(p, payload); pl = p;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Translator's note: code n2s (c, s);</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> n2s(c,s) ((s=(((unsigned int)(c[0]))&lt;&lt; 8)| \ (((unsigned int)(c[1])) )),c+=2)</span></span></code> </pre><br></div></div><br><br>  The first byte of the SSLv3 entry is a type of heartbeat.  The macro <i>n2s</i> takes two bytes from <i>p</i> and puts them in <i>payload</i> .  This is actually the length of the payload.  Please note that the actual length in the SSLv3 entry is not checked. <br>  The variable <i>pl then</i> receives the ‚Äúheartbeat‚Äù data provided by the requester. <br>  Further, the following occurs in the function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buffer, *bp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r; <span class="hljs-comment"><span class="hljs-comment">/* Allocate memory for the response, size is 1 byte * message type, plus 2 bytes payload length, plus * payload, plus padding */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    ,   * 1    ,  2  -    , *   ,   */</span></span> buffer = OPENSSL_malloc(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + payload + padding); bp = buffer;</code> </pre><br><br>  Allocated as much memory as requested by the requester: up to 65535 + 1 + 2 + 16, to be precise. <br>  The variable <i>bp</i> is the pointer used to access this memory.  Then: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Enter response type, length and copy payload */</span></span> *bp++ = TLS1_HB_RESPONSE; s2n(payload, bp); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(bp, pl, payload);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Memcpy Translator's Note</b> <div class="spoiler_text"><h5>  TITLE </h5><br>  <b>memcpy</b> - copies memory area <br><h5>  SYNTAX </h5><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; void *memcpy(void *dest, const void *src, size_t n);</span></span></span></span></code> </pre><br><h5>  DESCRIPTION </h5><br>  The memcpy () function copies n bytes from the src memory area to the dest memory area.  Memory areas cannot intersect.  Use memmove (3) if memory areas overlap. <br><h5>  RETURN VALUES </h5><br>  The memcpy () function returns a pointer to dest. <br><h5>  COMPLIANCE </h5><br>  SVID 3, BSD 4.3, ISO 9899 </div></div><br><br>  The macro <i>s2n</i> does the opposite of the macro <i>n2s</i> : it takes a 16-bit value and puts it in two bytes.  It then sets the same requested payload length. <br><div class="spoiler">  <b class="spoiler_title">Translator's note: code s2n (c, s);</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> s2n(s,c) ((c[0]=(unsigned char)(((s)&gt;&gt; 8)&amp;0xff), \ c[1]=(unsigned char)(((s) )&amp;0xff)),c+=2)</span></span></code> </pre><br></div></div><br><br>  Then the <i>payload</i> bytes from <i>pl</i> , the user-supplied data are copied to the newly allocated <i>bp</i> array.  After that, all this is sent back to the user. <br>  So where is the mistake? <br><br><h4>  User controls payload and pl </h4><br><br>  What if the requester does not actually send payload bytes, as it should? <br>  What if <i>pl</i> really only contains one byte? <br>  Then memcpy will read from memory everything that was near the SSLv3 entry. <br><br>  And, apparently, there are many different things nearby. <br><br>  There are two ways to allocate memory dynamically using <i>malloc</i> (at least in Linux): using <a href="http://linux.die.net/man/2/sbrk">sbrk (2)</a> and using <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap (2)</a> .  If <i>sbrk</i> is allocated <i>memory</i> , the old heap-grows-up rules are used, which limits what can be found with it, although using several queries (especially simultaneous) you can still find some interesting things.  [This section initially contained my skepticism about PoC due to the nature of how the heap works through sbrk.  However, many readers have reminded me that <i>mmap</i> can be used instead in <i>malloc</i> , and that changes everything.  Thank!] <br><br><div class="spoiler">  <b class="spoiler_title">Update from the author - this part is removed from the original article.</b> <div class="spoiler_text">  However, if <i>mmap is</i> used, ‚ÄúBets are made!‚Äù.  Any unused memory can be allocated to <i>mmap</i> .  This is the goal of most Heartbleed attacks. <br><br>  And the most important thing: the more your requested block, the more likely it will be served by <i>mmap</i> , and not <i>sbrk</i> . <br><br>  Operating systems that do not use <i>mmap</i> to implement <i>malloc</i> are likely to be slightly less vulnerable. <br></div></div><br><br>  The location of <i>bp</i> doesn‚Äôt really matter at all.  The location of <i>pl</i> , however, is of paramount importance.  Memory for it is almost certainly allocated with sbrk () due to the mmap threshold in malloc ().  However, memory for interesting materials (for example, documents or user information) is very likely to be allocated to mmap () and may be available from <i>pl</i> .  Several simultaneous queries will also make available some interesting data. <br><br>  So what does this mean?  Well, the memory allocation models for <i>pl</i> dictate to us what we can read.  One of the discoverers of the vulnerability said this: <br><br><blockquote>  Heap memory allocation models make the compromise of a private key unlikely # heartbleed # dontpanic. <br><br>  - Neil Mehta (@ neelmehta) April 8, 2014 <br></blockquote><br><br><h4>  Correction </h4><br>  The most important part of the fix is ‚Äã‚Äãthis: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Read type and payload length first */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span> &gt; s-&gt;s3-&gt;rrec.length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* silently discard */</span></span> hbtype = *p++; n2s(p, payload); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + payload + <span class="hljs-number"><span class="hljs-number">16</span></span> &gt; s-&gt;s3-&gt;rrec.length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* silently discard per RFC 6520 sec. 4 */</span></span> pl = p;</code> </pre><br><br>  This code does two things: the first check stops the heartbeat of zero length. <br>  The second if performs a check to make sure that the actual length of the record is long enough.  Like this. <br><br><h4>  Lessons </h4><br>  What can we learn from this? <br><br>  I'm a C fan.  It was my first programming language, and it was the first language that I was comfortable using for professional purposes.  But now I see his limitations more clearly than ever before. <br><br>  After Heartbleed and the <a href="http://blog.existentialize.com/the-story-of-the-gnutls-bug.html">GnuTLS bug,</a> I think we should do three things: <br><br><ul><li>  Pay for security audits of critical security infrastructure elements like OpenSSL. </li><li>  Write a lot of unit- and integration tests for these libraries. </li><li>  Start writing alternative implementations in safer languages. </li></ul><br><br>  Given how hard it is to write safely in C, I see no other options. </div><p>Source: <a href="https://habr.com/ru/post/218691/">https://habr.com/ru/post/218691/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218681/index.html">The smallest Habra-karmograf - for munin</a></li>
<li><a href="../218683/index.html">InterSystems Cach√© Development for Linux</a></li>
<li><a href="../218685/index.html">In the footsteps of the Bremen musicians, or "How do we build the information protection of Russia" correctly</a></li>
<li><a href="../218687/index.html">Announced the world's fastest accelerator AMD Radeon R9 295X2</a></li>
<li><a href="../218689/index.html">[Woman's View] Highscreen Thor Overview: Masculinity and the Power of Eight Cores</a></li>
<li><a href="../218695/index.html">Sberbank and Khan Academy</a></li>
<li><a href="../218697/index.html">Particles System in crowd modeling (2)</a></li>
<li><a href="../218699/index.html">Microsoft released a set of updates, April 2014</a></li>
<li><a href="../218703/index.html">Microsoft Security Essentials continues to work on Windows XP after April 8, 2014</a></li>
<li><a href="../218705/index.html">Yandex opened registration for its programming championship</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>