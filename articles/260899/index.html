<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the magic of patterns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Patterns in C ++ are metaprogramming tools and implement a compile-time polymorphism. What it is? 
 This is when we write code with polymorphic behavi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the magic of patterns</h1><div class="post__text post__text-html js-mediator-article">  Patterns in C ++ are metaprogramming tools and implement a compile-time polymorphism.  What it is? <br>  This is when we write code with polymorphic behavior, but the behavior itself is determined at the compilation stage - that is, in contrast to the polymorphism of virtual functions, the resulting binary code will already have constant behavior. <br><a name="habracut"></a><br><h4>  What for? </h4><br><img src="https://habrastorage.org/files/79e/863/79e/79e86379e2074b68b1070ffebb533855.jpg" alt="image"><br>  We use templates for beauty.  Every C ++ developer knows what beauty is, beauty is when the code is <b>compact</b> , clear <b>and fast</b> . <br><br><h4>  Meta-magic and implicit interfaces </h4><br>  What is a program?  A metoprogram is a program whose result will be another program.  For C ++, the compiler deals with the execution of metaprograms, and the result is a binary file. <br><br><img src="https://habrastorage.org/files/d57/f93/a59/d57f93a59876477d9b5ed1b93003a9f3.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Templates are used for writing metaprograms. <br>  What else is different polymorphism of templates from the polymorphism of virtual functions?  If a class has an explicit interface that we defined in the class declaration, then later in the program objects of this type can be used in accordance with this very interface.  But for templates, we use implicit interfaces, i.e.  using a type object, we define <b>an implicit type interface</b> that the compiler will display when building a metaprogram. <br><br><h4>  First spells: magic club </h4><br><img src="https://habrastorage.org/files/44a/939/523/44a9395234514e3aac13b9df40b34bba.jpg" alt="image"><br><br>  Let us make our template specific and see what types we have obtained for various template parameters: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> CHAR; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ B&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; b; B&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; c; B&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; uc; B&lt;<span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; sc; B&lt;CHAR&gt; C; B&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; c1; B&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>&gt; c21; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"b="</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(b).name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"c="</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(c).name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"C="</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(C).name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"sc="</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(sc).name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"uc="</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(uc).name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"c1="</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(c1).name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"c21="</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(c21).name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  The output of the program shows that the <b>types of template instantiations are different</b> even for equivalent types - unsigned char &amp; char.  However, they are identical for char &amp; CHAR, since  typedef does not create a type, but only gives it a different name.  They are identical for expressions 1 and 2-1, since  the compiler evaluates expressions and instead of 2-1 uses 1. <br><br>  From this it follows that we cannot use separate compilation for templates without additional problems: <br><div class="spoiler">  <b class="spoiler_title">ah</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; template &lt;typename T&gt; class A { public: void f(); };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"export.h"</span></span></span><span class="hljs-meta"> int main() { A</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int&gt; a; af(); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">a.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ah"</span></span></span><span class="hljs-meta"> template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename T&gt; void A&lt;T&gt;::f() { cout &lt;&lt; "A&lt;t&gt;::f" &lt;&lt; endl; } template class A&lt;int&gt;;</span></span></span></span></code> </pre><br></div></div><br>  In general, the C ++ standard has the <b>export keyword</b> for this, but this feature is too hard to implement and is missing in most compilers.  There are compilers that support it, but I do not advise it to be used in portable code. <br><br>  In addition to classes, there are also function templates: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t, T d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"func"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ func(<span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre><br>  If the compiler can deduce the type of the parameter of the template from the type of the parameters - it will do so, and we do not need to specify it in the code.  If not, we can define an enable function: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(c, i); };</code> </pre><br>  It does not incur any overhead. <br><br><h4>  Specialization is a new level. </h4><br><img src="https://habrastorage.org/files/03f/dbb/095/03fdbb095e7d4de4a1f2c7181c7e9b3a.jpg" alt="image"><br><br>  Usually using patterns we want to write a universal code, but in some cases we may lose in performance.  To solve the problem, there is a special spell - template specialization.  Specialization is a redefinition of a template with a specific type or type <b>class</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; template&lt;typename T&gt; T func(T t) { cout &lt;&lt; "func" &lt;&lt; endl; }; template&lt;typename T&gt; T * func(T *t) { cout &lt;&lt; "func with pointer!" &lt;&lt; endl; }; int main() { func(2); int i = 2; func(&amp;i); }</span></span></span></span></code> </pre><br>  The compiler will choose the most appropriate specialization, in the example it is the type class ‚Äúpointer to type‚Äù. <br><br><h4>  Sinister Magic: Recursion </h4><br>  The specializations and the fact that we can use templates in templates will give one very interesting opportunity - recursion of compile time. <br><br><img src="https://habrastorage.org/files/daf/38d/b99/daf38db99759416caa81553b157a041a.png" alt="image"><br><br>  The simplest and most popular example is the calculation of a series or a polynomial, say, the sum of a series of natural numbers: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; template &lt;int i&gt; int func() { return func&lt;i-1&gt;()+i; }; template &lt;&gt; int func&lt;0&gt;() { return 0; }; int main () { cout &lt;&lt; func&lt;12&gt;() &lt;&lt; endl; return 0; };</span></span></span></span></code> </pre><br>  We look ... It works!  Cool?  Increase the number of iterations to 500: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; func&lt;<span class="hljs-number"><span class="hljs-number">500</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Now compilation takes more time, while the program execution time is constant!  Miracles! <br><br><h4>  Do not make a goat if you wanted a thunderstorm </h4><br>  There are a couple of moments. <br><br><img src="https://habrastorage.org/files/c96/db8/017/c96db80179db441eb140ef125bcc64e2.png" alt="image"><br><br>  The default recursion depth is limited by default to the implementation, for the new gcc it is 900, for older versions it is less.  Parameter <br><pre> <code class="bash hljs">$ g++ recursion.cpp -ftemplate-depth=666666666</code> </pre><br>  removes this restriction. <br><br>  The second pitfall - do not wait for error reports.  Change the amount by factorial: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func&lt;i<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;() * i; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> func&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }; ... <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; func&lt;<span class="hljs-number"><span class="hljs-number">500</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  We get an incorrect result, and no warning. <br><br>  The third point is obvious: we can create too many almost identical template instantiations and, <b>instead of a performance boost, get a gain of a binary code</b> . <br><br><h4>  Powerful spells of the ancients </h4><br>  Is it possible to combine the magic of inheritance with patterned magic? <br><br><img src="https://habrastorage.org/files/dbb/648/719/dbb648719b8541b9b9e221a5721695ff.png" alt="image"><br><br>  The ancients used for this spell <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> .  The idea is simple: apply non-virtual inheritance and provide polymorphic behavior by explicitly casting the heir type to the parent type.  Let's look at <a href="">an example of use</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Filtrator&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiltratorImpl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ Filtrator* filtrator = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Filtrator* &gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); ‚Ä¶ filtrator-&gt;find_and_read_message(info, collection); } }; ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CIFSFiltrator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FiltratorImpl&lt;CIFSFiltrator&gt; { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_and_read_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PacketInfo&amp; info)</span></span></span><span class="hljs-function"> </span></span>{...} ... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCFiltrator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FiltratorImpl&lt;RPCFiltrator&gt; { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_and_read_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PacketInfo&amp; info)</span></span></span><span class="hljs-function"> </span></span>{...} ... };</code> </pre><br>  We get <b>inherited inline methods</b> with polymorphic behavior!  Who will say that this is not cool - my enemy forever. <br><br>  The ancients also advise adding something like this to the parent constructor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_member_function_pointer&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(&amp;Filtrator::find_and_read_message)&gt;::value)</code> </pre><br>  So that the demons, awakened by a powerful spell, could not harm the mage that caused them. <br><br><img src="https://habrastorage.org/files/2b2/93c/42d/2b293c42d9eb4d66a8f2f3b976768ff4.jpg" alt="image"><br><br>  There are still many secret techniques, ancient and not so.  I hope not to meet soon / * in hell * /, and may the power of the ancients be with you. </div><p>Source: <a href="https://habr.com/ru/post/260899/">https://habr.com/ru/post/260899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260889/index.html">Microsoft cloud services popularity rating in 2015</a></li>
<li><a href="../260891/index.html">Copy dallas keys. Record on rw1990 (rw1990.1)</a></li>
<li><a href="../260893/index.html">Streets and Heroes</a></li>
<li><a href="../260895/index.html">How I painted the design of the application for the contest Mail.Ru Group</a></li>
<li><a href="../260897/index.html">Small joys of structured metadata</a></li>
<li><a href="../260903/index.html">Snowden: NSA is spying on foreign antivirus companies</a></li>
<li><a href="../260907/index.html">Google implements proprietary code in free (?) Chromium</a></li>
<li><a href="../260911/index.html">Development of MMO RPG - a practical guide. Server (Part 2)</a></li>
<li><a href="../260913/index.html">PentestBox - portable assembly of popular security utilities</a></li>
<li><a href="../260917/index.html">Ansible and ChatOps or how to manage 100+ servers from the chat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>