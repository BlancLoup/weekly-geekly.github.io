<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bluebird: belt with tools for the asynchronist</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Asynchrony. Asynchrony never changes. Node.js used asynchrony to get big rps for io operations. TC39 has added promises to the specification for deali...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bluebird: belt with tools for the asynchronist</h1><div class="post__text post__text-html js-mediator-article"><p>  Asynchrony.  Asynchrony never changes.  Node.js used asynchrony to get big rps for io operations.  TC39 has added promises to the specification for dealing with Kolbak hell.  Finally, we have standardized async / await.  But asynchrony never changes.  Wait, is it turning blue in the sky?  It looks like bluebird carries in his beak a belt with tools for those of us who are tightly hooked on thenable objects and all this asynchronous noodles. </p><br><p><img src="https://habrastorage.org/webt/6c/b9/b0/6cb9b0hhjixkkaqkfdbs9dusuy8.jpeg"></p><a name="habracut"></a><br><p>  If someone is unfamiliar, bluebird is a library that implements the functionality of promis for javascript.  If you are unlikely to drag it into the client build, as there is no 21Kb gzipped, then you just don‚Äôt have to use it on the server side.  Bluebird is still faster than the native implementation.  You may not believe the word, but download the repository and run benchmarks on the latest version of Node.js (9.xx).  More details about the benefits can be found in a brief overview of the <a href="http://bluebirdjs.com/docs/why-bluebird.html">architectural principles of the</a> library. </p><br><p>  In addition to happiness, the library gives many methods straight from tomorrow, complementing the basic mechanism of promises.  Therefore, I propose to get acquainted with the most interesting of the methods.  I hope this will encourage you to dive deeper into the documentation, as there is still a lot of tasty stuff. </p><br><p>  Let's start with a fairly easy and well-known, watching for new features in ECMAScript, namely - finally.  The exact same method is now part of the specification (entered into the release ES2018).  Allows you to register a handler that is triggered regardless of the final state of the promis (fullfiled, rejected). </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// - 1 - // after fullfill -&gt; always Promise.resolve(42) .then(() =&gt; console.log('after fullfill')) .catch(() =&gt; console.log('after reject')) .finally(() =&gt; console.log('always')); // - 2 - // after reject -&gt; always Promise.reject(42) .then(() =&gt; console.log('after fullfill')) .catch(() =&gt; console.log('after reject')) .finally(() =&gt; console.log('always'));</span></span></code> </pre> <br><p>  This method, like the good old then and catch, returns a new promise to which you can subscribe.  It is important that in the event of a transition to the rejected state, the handler in finally is not considered a successful error handling, so it will continue to propagate until the first catch handler. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// - 1 - // after fullfill -&gt; always -&gt; a bit later Promise.resolve(42) .then(() =&gt; console.log('after fullfill')) .finally(() =&gt; console.log('always')) .then(() =&gt; console.log('a bit later')); // - 2 - // after reject -&gt; always -&gt; a bit later Promise.reject(42) .catch(() =&gt; console.log('after reject')) .finally(() =&gt; console.log('always')) .then(() =&gt; console.log('a bit later')); // - 3 - // always -&gt; after reject Promise.reject(42) .then(() =&gt; console.log('after fullfill')) .finally(() =&gt; console.log('always')) .then(() =&gt; console.log('never')) .catch(() =&gt; console.log('after reject'));</span></span></code> </pre> <br><p>  And, of course, you can return a promise from the finally handler.  The remaining chain will wait for it to complete by calling subsequent handlers. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// always -&gt; after 1s Promise.resolve(42) .finally(() =&gt; { console.log('always'); return delay(1000); }) .then(() =&gt; console.log('after 1s')); function delay(ms) { return new Promise(resolve =&gt; setTimeout(resolve, ms)); }</span></span></code> </pre> <br><p>  Moving on.  The guys pumped over the catch method - with it you can easily filter the errors that we want to handle: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeannonizationError</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigBrotherWatchingYouError</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// - 1 - // better run Promise.reject(new DeannonizationError()) .catch(DeannonizationError, () =&gt; console.log('better run')) .catch(BigBrotherWatchingYouError, () =&gt; console.log('too late')); // - 2 - // too late Promise.reject(new BigBrotherWatchingYouError()) .catch(DeannonizationError, () =&gt; console.log('better run')) .catch(BigBrotherWatchingYouError, () =&gt; console.log('too late')); // - 3 - // oh no Promise.reject(new BigBrotherWatchingYouError()) .catch(DeannonizationError, BigBrotherWatchingYouError, () =&gt; console.log('oh no'));</span></span></code> </pre> <br><p>  This encourages writing error handling in a more atomic style with good potential for code reuse.  Also, in addition to the prototype, you can use the predicate function: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// predicate Promise.reject({ code: 42 }) .catch(error =&gt; error.code === 42, () =&gt; console.log('error 42')); // shorthand for checking properties Promise.reject({ code: 42 }) .catch({ code: 42 }, () =&gt; console.log('error 42'));</span></span></code> </pre> <br><p>  One of the most remarkable methods of the library and it is extremely strange that it is not in the standard - any. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 42 Promise.any([ Promise.reject(40), // error Promise.reject(41), // error Promise.resolve(42), // success ]).then(x =&gt; console.log(x));</span></span></code> </pre> <br><p>  Allows you to wait for at least one promise from the transmitted array.  If in more detail, the promise created by the any method will go to the fullfiled state when any of the promises go to this state.  The handler in then gets the value from this allowed promise: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 500 Promise.any([ delay(1000), delay(500), delay(700), ]).then(x =&gt; console.log(x)); function delay(ms) { return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(ms), ms)); }</span></span></code> </pre> <br><p>  In case all transmitted promises are terminated with an error, the aggregating promise will also go into the rejected state.  The handler in catch will receive a <a href="http://bluebirdjs.com/docs/api/aggregateerror.html">special error</a> that combines the reasons for the failure of all promises.  Note that the order of errors depends on the order of their occurrence, and not on the original order of promises. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// - 1 - // 40 -&gt; 41 -&gt; 42 Promise.any([ Promise.reject(40), Promise.reject(41), Promise.reject(42), ]).catch(error =&gt; error.forEach(x =&gt; console.log(x))); // - 2 - // 500 -&gt; 700 -&gt; 1000 Promise.any([ delayAndReject(1000), delayAndReject(500), delayAndReject(700), ]).catch(error =&gt; error.forEach(x =&gt; console.log(x))); function delayAndReject(ms) { return new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(ms), ms)); }</span></span></code> </pre> <br><p>  In essence, the any method is a special version of the some method with the count parameter equal to 1. Thus, through some, we can explicitly set the conditions for the aggregate promise to go to the fulfilled state: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// [40, 41] Promise.some([ Promise.resolve(40), Promise.resolve(41), Promise.reject(42), ], 2).then(x =&gt; console.log(x));</span></span></code> </pre> <br><p>  If you often need to simultaneously run an asynchronous operation for each element of the array and then wait for all the results, then you are familiar with this code: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3] const promises = [1, 2, 3].map(x =&gt; Promise.resolve(x)); Promise.all(promises) .then(x =&gt; console.log(x));</span></span></code> </pre> <br><p>  Blue Bird provides us with a shortcut for this: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.map([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], x =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(x)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x));</code> </pre> <br><p>  The only thing you should pay attention to: for a function passed as a mapper, the third parameter instead of an array is its length.  Also, the map method has a settings object passed after the mapper.  At the moment there is only one option - concurrency - controlling how many promises can be run in parallel: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// start of 1000ms timer // start of 2000ms timer // end of 1000ms timer // start of 3000ms timer // end of 2000ms timer // end of 3000ms timer // after 4000ms Promise.map([1000, 2000, 3000], x =&gt; delay(x), { concurrency: 2 }) .then(x =&gt; console.log('after 4000ms')); function delay(ms) { console.log(`start of ${ms}ms timer`); return new Promise(resolve =&gt; setTimeout(() =&gt; { console.log(`end of ${ms}ms timer`); resolve(); }, ms)); }</span></span></code> </pre> <br><p>  And what will happen if you set the concurrency to 1?  True, promises will be performed sequentially.  There is also a shortcut for this: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// start of 1000ms timer // end of 1000ms timer // start of 2000ms timer // start of 3000ms timer // end of 2000ms timer // end of 3000ms timer // after 6000ms Promise.mapSeries([1000, 2000, 3000], x =&gt; delay(x)) .then(x =&gt; console.log('after 6000ms')); function delay(ms) { console.log(`start of ${ms}ms timer`); return new Promise(resolve =&gt; setTimeout(() =&gt; { console.log(`end of ${ms}ms timer`); resolve(); }, ms)); }</span></span></code> </pre> <br><p>  Often there is a situation when you need to transfer some intermediate data between promise handlers within the chain.  You can use Promise.all and destructuring for this purpose.  Another option would be to use a shared context bound to handlers in then and catch using the bind method: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// {x: 42, y: 43} Promise.resolve(42) .bind({}) .then(function (x) { this.x = x; return Promise.resolve(43); }) .then(function (y) { this.y = y; }) .then(function () { console.log(this) });</span></span></code> </pre> <br><p>  For cases where a function that returns a promise can have synchronous returns, you can use the method utility, which resolves them automatically.  For example, it will be useful when memorizing asynchronous operations.  Unlike try, method returns a higher order function: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.method(semiAsyncFunction)() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'I handle both sync and async results'</span></span>, x)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">semiAsyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">420</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay(<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ms</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(ms), ms)); }</code> </pre> <br><p>  The tap method is useful if you need to insert side effects that do not change the data into an existing chain, for example, for logging: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// log 42 // process 42 Promise.resolve(42) .tap(x =&gt; console.log(`log ${x}`)) .then(x =&gt; console.log(`process ${x}`));</span></span></code> </pre> <br><p>  If the side effect is an asynchronous operation, and it is important to wait for its execution, we usually return the promise from the handler: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// start logging // log 42 // process 42 Promise.resolve(42) .tap(x =&gt; asyncLogging(x)) .then(x =&gt; console.log(`process ${x}`)); function asyncLogging(x) { console.log('start logging'); return new Promise(resolve =&gt; setTimeout(() =&gt; { console.log(`log ${x}`); resolve(); }, 1000)); }</span></span></code> </pre> <br><p>  There is also a version of the method for errors: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// log error 42 // process error 42 Promise.reject(42) .tapCatch(x =&gt; console.log(`log error ${x}`)) .catch(x =&gt; console.log(`process error ${x}`));</span></span></code> </pre> <br><p>  Also, as with catch, you can filter: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeannonizationError</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigBrotherWatchingYouError</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// log deannonimization // process deannonimization Promise.reject(new DeannonizationError()) .tapCatch(DeannonizationError, x =&gt; console.log('log deannonimization')) .tapCatch(BigBrotherWatchingYouError, x =&gt; console.log('log bbwy')) .catch(DeannonizationError, () =&gt; console.log('process deannonimization')) .catch(BigBrotherWatchingYouError, () =&gt; console.log('process bbwy')); // log bbwy // process bbwy Promise.reject(new BigBrotherWatchingYouError()) .tapCatch(DeannonizationError, x =&gt; console.log('log deannonimization')) .tapCatch(BigBrotherWatchingYouError, x =&gt; console.log('log bbwy')) .catch(DeannonizationError, () =&gt; console.log('process deannonimization')) .catch(BigBrotherWatchingYouError, () =&gt; console.log('process bbwy'));</span></span></code> </pre> <br><p>  The next feature is being reviewed by TC39 as part of a broader topic - cancellation of asynchronous operations.  While it has not yet been delivered, we can be content with little and learn how to cancel promises: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.config({ <span class="hljs-attr"><span class="hljs-attr">cancellation</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'We will never see this'</span></span>)); promise.cancel(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ms</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(resolve, ms)); }</code> </pre> <br><p>  Some asynchronous operations can be undone.  When creating a promise, Bluebird will provide you with a special method for registering a callback called upon cancellation: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.config({ <span class="hljs-attr"><span class="hljs-attr">cancellation</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'We will never see this'</span></span>)); promise.cancel(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ms</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject, onCancel</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'and this one too'</span></span>); resolve(); }, ms); onCancel(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> clearTimeout(timer)); }); }</code> </pre> <br><p>  It is useful to set time limits for the operation.  Then we have a timeout method that will reject the promise with a TimeoutError error in the event of a timeout: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Time's up! delay(1000) .timeout(100) .then(() =&gt; console.log(`We will never see this`)) .catch(Promise.TimeoutError, error =&gt; console.log(`Time's up!`)) function delay(ms) { return new Promise(resolve =&gt; setTimeout(resolve, ms)); }</span></span></code> </pre> <br><p>  And finally, for mental relief.  If, due to insuperable circumstances, it is necessary to postpone the launch of an asynchronous operation, then the delay method will help: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`after 1s`</span></span>));</code> </pre> <br><p>  On this we should say goodbye.  Try the blue bird in your pet projects, and then take it with you to production.  See you at JS open spaces! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/352064/">https://habr.com/ru/post/352064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352052/index.html">Linux containers: isolation as a technological breakthrough</a></li>
<li><a href="../352054/index.html">How do we predict the end date and project evaluation using a neural network?</a></li>
<li><a href="../352056/index.html">Why does the Heap32Next () function work so slowly on Windows 7?</a></li>
<li><a href="../352060/index.html">Accelerating the enumeration of processes and threads in Windows</a></li>
<li><a href="../352062/index.html">How to explain to relatives who you are in the IT world on the example of buns</a></li>
<li><a href="../352066/index.html">New solution for maintaining the availability of IT infrastructure: Veeam Availability Orchestrator</a></li>
<li><a href="../352068/index.html">Installing Facebook image recognition package. All rake in one place</a></li>
<li><a href="../352070/index.html">Apache Ignite: in-memory distributed computing</a></li>
<li><a href="../352072/index.html">The end of procrastination or what is ICIGAI?</a></li>
<li><a href="../352074/index.html">A tale about how an HTTP / 2 Client engineer overclocked</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>