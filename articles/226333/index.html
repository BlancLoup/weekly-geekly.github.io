<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reduced component connectivity of C ++ code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We get rid of the drawbacks of the classic OOP and write in C ++ in a modular style. 

 By the will of fate, I had to maintain and develop a project o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reduced component connectivity of C ++ code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/994/c1d/d6a/994c1dd6a72291a5ec0a8d7003f34cee.jpg"><br>  We get rid of the drawbacks of the classic OOP and write in C ++ in a modular style. <br><a name="habracut"></a><br>  By the will of fate, I had to maintain and develop a project of average complexity written in C ++.  The project is written in the classic OOP style and well structured by modules and classes.  I must say that before this I spent a lot of time developing a project in Java and Apache Tapestry 5. In particular, I understood the ideology of its IOC container very well.  Therefore, some of the ideas copied from there. <br>  So the project is structured, but any minor change in almost any header file will recompile half of the project.  I do not have much attention to syntactic details when writing code (forgetting the inclusion of headers, namespaces, etc. is normal for me), so it happens that you have to correct errors and recompile again 2-3 times and it takes a lot of time.  Therefore, I decided to introduce into the project a number of practices to reduce the component code connectivity of what I want to share.  Just want to make a warning.  The project requires compatibility with C ++ 98, so everything that goes beyond its framework is implemented using Boost. <br><br><h4>  Variable lifetime </h4><br>  One of the basic principles of OOP is encapsulation.  This includes the rule that a variable should only be available where it is used.  Availability is almost equivalent to the lifetime of automatic variables.  Therefore, if a variable of type <code>MyStack</code> is a private member of class A, then all users of the class must also import the header MyStack.h.  If this variable is used by only one function and does not contain a state, then it must be made generally static.  In addition, you should not forget that automatic variables live to the end of the block and use this to destroy more unnecessary variables by adding brackets to the block of code. <br><br><h4>  PImpl </h4><br>  The problem of hiding the implementation of the private part of the class is partially solved by the implementation pointer (Pimpl).  I would not like to re-retell in detail what Pimpl is, as there are enough articles on this topic.  Here, for example, at the coat of arms of Sutter: <br><ul><li>  <a href="http://www.gotw.ca/gotw/024.htm">GotW # 24: Compilation Firewalls</a> <br></li><li>  <a href="http://www.gotw.ca/gotw/028.htm">GotW # 28: The Fast Pimpl Idiom</a> <br></li><li>  <a href="http://herbsutter.com/gotw/_100/">GotW # 100: Compilation Firewalls</a> <br></li><li>  <a href="http://herbsutter.com/gotw/_101/">GotW # 101: Compilation Firewalls, Part 2</a> <br></li></ul><br>  I will only make my comments and give my implementation of the idiom. <br><ol><li>  Idiom does not hide public constructors that take parameters for implementation.  This problem can be solved by combining interfaces and object factories. <br></li><li>  Do not forget to move all unnecessary for the public part of the include in the module with the implementation. <br></li><li>  To hide the extra code from my eyes, I implemented the PImpl module compatible with C ++ 98 <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> PIMPL_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIMPL_H </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///idea from GotW #101: Compilation Firewalls, Part 2s http://herbsutter.com/gotw/_101/ #include &lt;boost/scoped_ptr.hpp&gt; template&lt;typename T&gt; class PImpl { private: boost::scoped_ptr&lt;T&gt; m; public: PImpl() : m(new T) { } template&lt;typename A1&gt; PImpl(A1&amp; a1) : m(new T(a1)) { } //    2  9  ‚Ä¶. template&lt;typename A1, typename A2, typename A3, typename A4, typename A5, typename A6 , typename A7, typename A8, typename A9, typename A10&gt; PImpl(A1&amp; a1, A2&amp; a2, A3&amp; a3 , A4&amp; a4, A5&amp; a5, A6&amp; a6, A7&amp; a7, A8&amp; a8, A9&amp; a9, A10&amp; a10) : m(new T(a1, a2, a3, a4, a5 , a6, a7, a8, a9, a10)) { } PImpl(const PImpl&amp; orig) : m(new T(*orig)) { } T* operator-&gt;() const { return m.get(); } T&amp; operator*() const { return *m.get(); } PImpl&amp; operator=(const PImpl&amp; orig) { m.reset(new T(*orig)); return *this; } }; #endif /* PIMPL_H */</span></span></span></span></code> </pre><br></div></div><br></li><li>  In all classes, the implementation declaration looks like <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class">;</span></span> PImpl&lt;Impl&gt; me;</code> </pre><br>  <code>me</code> borrowed from VBA <br></li><li>  If a pointer to the public part is required (to call public methods), then the public <code>this</code> is passed to the <code>Impl</code> constructor <code>Impl</code> first parameter and is stored in the <code>ppub</code> field <br></li><li>  An implementation with a full declaration is always declared as a <code>struct</code> since it has scope only in the current module. <br></li><li>  An implementation usually has to have constructors and overloaded operators that completely repeat public ones.  For copy constructors and <code>operator=</code> don't forget to set <code>me</code> and <code>ppub</code> . <br></li><li>  Declarations of Impl functions in Java style.  As you know, functions declared and defined immediately in a class are inline functions.  We should not forget that inline is only a tip to the compiler, which it may not take into account, therefore, most likely, large functions will not be inline, but there will be less boilerplate for declarations and definitions of functions. <br></li><li>  About unit testing.  As it is known, in unit testing, it is often required to have stubs instead of the implementations on which the module under test depends.  If the object on which our code depends is implemented with <code>PImpl</code> , then we can very simply replace the current implementation with a stub using the linker.  Testing the same hidden implementation is possible by including the implementation code in the test module using the #include directive. <br><div class="spoiler">  <b class="spoiler_title">A comprehensive example of the above</b> <div class="spoiler_text"><pre> <code class="cpp hljs">------- Hasher.h ------ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;PImpl.h&gt; class Hasher { class Impl; //   class  struct    PImpl&lt;Impl&gt; me; //   public: Hasher(); void execute(); int getResults(); }; ------- Hasher.cpp ------ #include ‚ÄúHasher.h‚Äù #include &lt;HashLib.h&gt; #include ‚ÄúSecTokens.h‚Äù // . struct      struct Hasher::Impl { Hasher* ppub; //    HashContext cnt; int hash; Impl(Hasher* ppub): ppub(ppub) { } void prepare() { HashLib::createContext(cnt); hash = 0; } void update(int val) { HashLib::updateHash(cnt, hash, val); } void finalize() { HashLib::releaseContext(cnt); } }; Hasher::Hasher(): me(this) { //     } void Hasher::execute() { me-&gt;prepare(); me-&gt;update(SecTokens::one); me-&gt;update(SecTokens::two); me-&gt;finalize(); } int Hasher::getResults(){ return me-&gt;hash; } ------- Cryptor.h ------ #include &lt;string&gt; #include &lt;PImpl.h&gt; class Cryptor { class Impl; PImpl&lt;Impl&gt; me; public: Cryptor(std::string salt); std::string crypt(std::string plain); }; ------- Cryptor.cpp ------ #include &lt;CryptoLib.h&gt; #include ‚ÄúCryptor.h‚Äù struct Cryptor::Impl { std::string salt; CryptoContext cnt; Impl(std::string salt): me(salt) { } void prepare() { CryptoLib::createContext(cnt); } void update(std::string plain) { CryptoLib::updateHash(cnt, plain); } std::string finalize() { return CryptoLib::releaseContext(cnt); } }; Cryptor::Cryptor(std::string salt): me(salt) { } std::string Cryptor::crypt(std::string plain) { me-&gt;prepare(); me-&gt;update(plain); return me-&gt;finalize(); } ------- MockHasher.cpp ------ #include ‚ÄúHasher.h‚Äù struct Hasher::Impl { }; void Hasher::execute() { } int Hasher::getResults(){ return 4; } ------- TestCryptor.cpp ------ #include ‚ÄúCryptor.cpp‚Äù int main(int argc, char** argv) { Cryptor::Impl impl(‚Äúsalt‚Äù); impl.prepare(); //   impl  prepare impl.update(‚Äútext‚Äù); //   impl  update std::string crypto=impl.finalize(); //    crypto }</span></span></span></span></code> </pre><br></div></div><br>  So there is a class <code>Cryptor</code> (a wrapper for a certain <code>CryptoLib</code> ) for which you need to write a test and a class <code>Hasher</code> (a wrapper for a certain <code>HashLib</code> ) on which <code>Cryptor</code> depends.  but <code>Cryptor</code> still depends on the <code>HashLib</code> and <code>SecTokens</code> , and this is absolutely not necessary for us to test <code>Cryptor</code> .  Instead, prepare MockHasher.cpp. <br>  The Cryptor.cpp code is included in TestCryptor.cpp, so to build the test, we compile and compile only TestCryptor.cpp and MockHasher.cpp.  I do not cite examples based on unit testing libraries as this is not the case for this article. <br></li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Revise the inclusion of header files </h4><br>  It's simple.  The header should be included as late as possible during the parsing of the code, but preferably at the beginning of the file.  Those.  if only the class implementation uses a third-party header, then transfer it to the class implementation module from the class header. <br><br><h4>  Callbacks and functors instead of public functions </h4><br>  There is a module in the project in which I carry out all platform-specific functions.  It is called <code>Platform</code> .  It turns out the module with functions unrelated to each other, which I simply declared in the same namespace <code>platform</code> .  In the future, I am going to replace the module with implementation depending on the platforms.  But the trouble is.  One of the functions should fill in the &lt;key, value&gt; class pairs (this is <code>std::map</code> , but with a specific comparator) declared generally in the private part of another public class <code>Settings</code> . <br>  You can bring a private class into public visibility and break the Platform header into several headers.  Then the fill function will not be included in classes unrelated to this fill and they will not become dependent on this <code>std::map</code> .  I am not in favor of producing header files, except that changing the scope of the template comparator from a private to a more general one will result in an increase in component connectivity.  Any change in it will recompile everything that depends on the platform-specific placeholder. <br>  Another way is to use the <code>boost::bind</code> and callback functions.  The placeholder function will take a pointer to the function. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillDefaults</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(boost::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">) &gt; setDefault)</span></span></span></span>;</code> </pre><br>  instead <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillDefaults</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ci_less&gt;&amp; defaults)</span></span></span></span>;</code> </pre><br>  Create a callback in the private part of <code>Settings</code> : <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setDefault</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ defaults[key] = value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillDefaults</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ platform::fillDefaults(boost::bind(&amp;SettingsManager::Impl::setDefault, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, _1, _2)); }</code> </pre><br>  instead <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillDefaults</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ platform::fillDefaults(defaults); }</code> </pre><br>  Using pimpl, it is sometimes more convenient to make a public function in the form of a wrapper for the same private.  Using the example above function <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hasher::execute() { me-&gt;prepare(); me-&gt;update(SecTokens::one); me-&gt;update(SecTokens::two); me-&gt;finalize(); }</code> </pre><br>  can be represented as <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hasher::Impl::execute() { prepare(); update(SecTokens::one); update(SecTokens::two); finalize(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hasher::execute() { me-&gt;execute(); }</code> </pre><br>  but you can do it with the bind functor <br><pre> <code class="cpp hljs">------- Hasher.h ------ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/functions.hpp&gt; #include &lt;PImpl.h&gt; class Hasher { class Impl; //   class  struct    PImpl&lt;Impl&gt; me; //   public: Hasher(); boost::function&lt;void()&gt; execute; int getResults(); }; ------- Hasher.cpp ------ //‚Ä¶‚Ä¶... Hasher::Hasher(): me(this), execute(boost::bind(&amp;Hasher::Impl::execute, &amp;*me)) { } int Hasher::getResults(){ return me-&gt;hash; }</span></span></span></span></code> </pre><br>  We got rid of the function definition <br>  Now execute can be called as before. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Hasher&amp; h)</span></span></span><span class="hljs-function"> </span></span>{ h.execute(); }</code> </pre><br>  and, for example, sent to a performance in a separate performer <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Hasher&amp; h, boost::asio::io_service&amp; executor)</span></span></span><span class="hljs-function"> </span></span>{ executor.post(h.execute); }</code> </pre><br>  instead <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Hasher&amp; h, boost::asio::io_service&amp; executor)</span></span></span><span class="hljs-function"> </span></span>{ executor.post(boost::bind(&amp;Hasher::execute, &amp;h)); }</code> </pre><br>  The boilerplate of the wrapper function declaration transformed into the boilerplate of the ad boost functor and remained only in the constructor. <br>  It should be noted that there is a downside.  <code>execute</code> now a public class field and a new value can be randomly assigned to it during execution, which cannot happen to the function.  Also, the usual redefinition of the virtual method is no longer available, although this problem is solved simply. <br>  Thus we get the pleasures of higher-order functions as in JavaScript. <br>  A few words about functors beyond the main theme.  Suppose we have created a functor and want to make another functor based on it with a smaller number of arguments. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ boost::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; functor1(boost::bind(myFunction, _1, _2)); boost::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; functor2(boost::bind(functor1, <span class="hljs-number"><span class="hljs-number">4</span></span>, _1)); }</code> </pre><br>  Here this call boost :: bind (functor1, 4, _1) hurts the eye.  Why not combine function pointer and bind, because they are rarely used separately.  Then the code above will look like: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ Bindable&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; functor1(boost::bind(myFunction, _1, _2)); Bindable&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; functor2(functor1.bind(<span class="hljs-number"><span class="hljs-number">4</span></span>, _1)); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Bindable code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> BINDABLE_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BINDABLE_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/bind.hpp&gt; #include &lt;boost/function.hpp&gt; template&lt;typename Signature&gt; struct Bindable : public boost::function&lt;Signature&gt; { Bindable() { } template&lt;typename T&gt; Bindable(const T&amp; fn) : boost::function&lt;Signature&gt;(fn) { } template&lt;typename NewSignature, typename A1&gt; Bindable&lt;NewSignature&gt; bind(const A1&amp; a1) { return boost::bind(this, a1); } //    2  9  template&lt;typename NewSignature, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10&gt; Bindable&lt;NewSignature&gt; bind(const A1&amp; a1, const A2&amp; a2, const A3&amp; a3, const A4&amp; a4, const A5&amp; a5, const A6&amp; a6, const A7&amp; a7, const A8&amp; a8, const A9&amp; a9, const A10&amp; a10) { return boost::bind(*this, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); } }; #endif /* BINDABLE_H */</span></span></span></span></code> </pre><br></div></div><br><h4>  Hiding Designer Parameters </h4><br>  First you need to decide what types of constructor parameters can be: <br><ol><li>  configuration parameters for a particular instance of the instance.  Usually these are parameters of a simple type - flags, strings, metrics.  However, there is no possibility to hide these parameters; <br></li><li>  objects derived from the global scope for the work implementation.  Here we will hide them. <br></li></ol><br>  A question may arise: ‚Äúwhy transfer the globally accessible objects to the constructor, if you can refer to them at any time?‚Äù.  Yes it is.  But there are several reasons why it is better not to do this: <br><ol><li>  retrieving a global object can be a resource-intensive operation, then it‚Äôs better to cache it in the class field <br></li><li>  retrieving a global object can have complex syntax, for example <code>globalStorage.getProfiles().getProfile(‚ÄúDefault‚Äù)</code> .  In order not to repeat such an expression, an object or a link to it is also best stored in the class field. <br></li><li>  You may need to modify a copy of the global object.  Then the copy must also be in the class field. <br></li><li>  it may be necessary to replace the object used for debugging purposes.  Then only one extraction and assignment call to the class field is changed. <br></li></ol><br><br><h5>  Inheritance.  Factories and interfaces </h5><br>  Using absolutely abstract classes as interfaces (a header file is enough) and creating a descendant with the necessary constructor parameters, you can avoid publishing parameters.  In this case, a factory is used to create an instance.  This may be a factory method, declared in the interface and defined in the implementation module, or it may be an independent class whose object returns a new object or a pointer to a new object. <br>  I have long been inclined to think that if I can use inheritance or composition, I choose composition.  Additionally, I was convinced of the correctness of this approach by getting the error Pure Virtual Function Called <br><br><h5>  Composition </h5><br>  If the idiom pimpl is embedded in the class, then when creating a private implementation, you can pass to the constructor not the parameters of the public part constructor, but objects from the global scope.  those.  In a public constructor, there are no global value parameters, only flags, etc.  the parameters that you really need to know and set in the area of ‚Äã‚Äãthe code that creates the instance. <br><br><h4>  Structuring files, modularity and lazy initialization </h4><br>  The project contains about 50 ‚Äú.cpp‚Äù files plus header files.  Files are logically distributed in directories - subsystems.  The code contains a number of global variables of simple types and an object to access shared objects of user types.  Accessing objects may look like this. <br><pre> <code class="cpp hljs">globalStorage.getHoster()-&gt;invoke();</code> </pre><br>  or so: <br><pre> <code class="cpp hljs">Profile pr=globalStorage.getProfiles()-&gt;getProfile(‚ÄúDefault‚Äù);</code> </pre><br>  Similar to the <code>Platform</code> discussed above, all who use <code>globalStorage</code> forced to know that the <code>GlobalStorage</code> interface is <code>GlobalStorage</code> with all external types.  But <code>GlobalStorage</code> should really return an object of a given type (or implementing a specified interface) and there is no way to solve the problem as in <code>Platform</code> . <br><br>  So, the next goal is to convert the subsystems into something similar to Apache Tapestry 5 IOC modules, simplify access to global objects (hereinafter services are analogous to Tapestry services) and transfer the configuration of services into a separate file in the IOC module.  As a result, we get the most real components (see <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Component-oriented programming</a> ) <br>  Just want to say that we are not talking about a full-fledged IOC container.  The described example is only a generalization of the Singleton service template and the Factory.  Using this approach, you can also implement <a href="http://tapestry.apache.org/shadowbuilder-service.html">Shadow services</a> (the field of service is presented as an independent service) and other sources of services. <br><br><h5>  Configuration services module IOC </h5><br>  Create <div class="spoiler">  <b class="spoiler_title">header IOC.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"InjectPtr.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///Helper interface class. Only for visual marking of needed methods. ///We can't do virtual template members namespace ioc { ///methods like http://tapestry.apache.org/defining-tapestry-ioc-services.html#DefiningTapestryIOCServices-ServiceBuilderMethods ///Like public @InjectService or @Inject annotation ///ServiceId Case http://tapestry.apache.org/defining-tapestry-ioc-services.html#DefiningTapestryIOCServices-ServiceIds template&lt;typename T, size_t ID&gt; InjectPtr&lt;T&gt; resolve(); ///Singleton or factory case template&lt;typename T&gt; InjectPtr&lt;T&gt; resolve(); };</span></span></span></span></code> </pre><br></div></div><br>  now instead <br><pre> <code class="cpp hljs">boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Hoster&gt; hoster = globalStorage.getHoster();</code> </pre><br>  the call will look like <br><pre> <code class="cpp hljs">InjectPtr&lt;Hoster&gt; hoster = ioc::resolve&lt;Hoster&gt;();</code> </pre><br>  As you can see, this design does not import anything extra.  If you need to get <code>Hoster</code> in the code, you should take care of importing its header yourself.  The second parameter of the <code>resolve</code> method template is the service identifier.  It is used in case there are several services with one interface. <br><br>  <code>InjectPtr</code> is a smart pointer to an object with delayed (lazy) initialization.  Inside stores <code>boost::shared_ptr</code> on <code>boost::shared_ptr</code> on a stored object.  The latter is initialized during the first dereference of <code>InjectPtr</code> .  To create an instance of a stored object, <code>InjectPtr</code> gets a functor factory. <br><div class="spoiler">  <b class="spoiler_title">InjectPtr code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> INJECT_PTR_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INJECT_PTR_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cassert&gt; #include &lt;cstddef&gt; #include &lt;boost/shared_ptr.hpp&gt; #include &lt;boost/scoped_ptr.hpp&gt; #include &lt;boost/make_shared.hpp&gt; #include &lt;boost/function.hpp&gt; #include &lt;boost/thread/mutex.hpp&gt; ///Pointer to lazy instantiative object template&lt;typename T&gt; class InjectPtr { private: typedef boost::function&lt;T*() &gt; Factory; boost::shared_ptr&lt; boost::shared_ptr&lt;T&gt; &gt; px; boost::shared_ptr&lt; boost::scoped_ptr&lt;boost::mutex&gt; &gt; instantiateMutex; Factory factory; public: ///Main constructor. Take factory for future instantiate object InjectPtr(Factory factory) : px(boost::make_shared&lt;boost::shared_ptr&lt;T&gt; &gt;()) , instantiateMutex(boost::make_shared&lt;boost::scoped_ptr&lt;boost::mutex&gt; &gt;(new boost::mutex)) , factory(factory) { } InjectPtr() : px(boost::make_shared&lt;boost::shared_ptr&lt;T&gt; &gt;()) , instantiateMutex(boost::make_shared&lt;boost::scoped_ptr&lt;boost::mutex&gt; &gt;()) { } InjectPtr(boost::shared_ptr&lt;T&gt; pObject) : px(boost::make_shared&lt;boost::shared_ptr&lt;T&gt; &gt;(pObject)) { assert(*px != 0); } InjectPtr(InjectPtr const &amp;orig) : px(orig.px) , instantiateMutex(orig.instantiateMutex) , factory(orig.factory) { } InjectPtr &amp; operator=(InjectPtr const &amp; orig) { px = orig.px; instantiateMutex = orig.instantiateMutex; factory = orig.factory; return *this; } virtual ~InjectPtr() { } T &amp; operator*() { instantiate(); return **px; } T * operator-&gt;() { instantiate(); return &amp;**px; } bool operator!() const { return !*px; } void operator==(InjectPtr const&amp; that) const { return *px == that-&gt;px; } void operator!=(InjectPtr const&amp; that) const { return *px != that-&gt;px; } boost::shared_ptr&lt;T&gt; sharedPtr() { instantiate(); return *px; } void instantiate() { if (!*px &amp;&amp; factory) { { boost::mutex::scoped_lock lock(**instantiateMutex); if (!*px) { px-&gt;reset(factory()); } } instantiateMutex-&gt;reset(); } } Factory getFactory() const { return factory; } void setFactory(Factory factory) { if(!*px &amp;&amp; !this-&gt;factory){ if(!*instantiateMutex) instantiateMutex-&gt;reset(new boost::mutex); this-&gt;factory = factory; } } }; template&lt;class T, class U&gt; InjectPtr&lt;T&gt; static_pointer_cast(InjectPtr&lt;U&gt; r) { return InjectPtr&lt;T&gt;(boost::static_pointer_cast&lt;T&gt;(r.sharedPtr())); } #endif /* INJECT_PTR_H */</span></span></span></span></code> </pre><br></div></div><br>  <code>InjectPtr</code> thread safe.  During the creation of the object, the operation is blocked by the mutex. <br>  Go to the IOC configuration file.  We do full specializations of a <code>ioc::resolve</code> method <code>ioc::resolve</code> <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">------- IOCModule.h ------ <span class="hljs-comment"><span class="hljs-comment">//      #ifndef IOCMODULE_H #define IOCMODULE_H #include &lt;boost/functional/factory.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;IOC.h&gt; #endif /* IOCMODULE_H */ ------- IOCModule.cpp ------ #include "Hoster.h" #include "SomeService.h" #include "InjectPtr.h" #include &lt;IOCModule.h&gt; #include &lt;IOC.h&gt; //Module like http://tapestry.apache.org/tapestry-ioc-modules.html //Now only for: - To provide explicit code for building a service using namespace ioc; ///methods like http://tapestry.apache.org/defining-tapestry-ioc-services.html#DefiningTapestryIOCServices-ServiceBuilderMethods template&lt;&gt; InjectPtr&lt;SomeService&gt; resolve&lt;SomeService&gt;() { static InjectPtr&lt;Hoster&gt; result(boost::bind(boost::factory&lt;SomeService*&gt;())); return result; } ///Hoster takes SomeService in constructor template&lt;&gt; InjectPtr&lt;Hoster&gt; resolve&lt;Hoster&gt;() { static InjectPtr&lt;Hoster&gt; result(boost::bind(boost::factory&lt;Hoster*&gt;(), resolve&lt;SomeService&gt;())); return result; }</span></span></code> </pre><br></div></div><br>  GCC guarantees locking even when creating a static local variable of a function.  But the standard does not guarantee this.  I had to change the code and remove the <code>InjectPtr</code> keeper into a global static variable, which is probably initialized before the program code was launched.  You can, of course, in separate variables, but then you have to invent a name for each.  Here <code>CoreStorage</code> is the keeper for the Core IOC module: <br><div class="spoiler">  <b class="spoiler_title">IOCModule.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Hoster.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomeService.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"InjectPtr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;IOCModule.h&gt; #include &lt;IOC.h&gt; //Module like http://tapestry.apache.org/tapestry-ioc-modules.html //Now only for: - To provide explicit code for building a service using namespace ioc; struct CoreStorage { InjectPtr&lt;SomeService&gt; someService; InjectPtr&lt;Hoster&gt; hoster; }; static CoreStorage storage; ///methods like http://tapestry.apache.org/defining-tapestry-ioc-services.html#DefiningTapestryIOCServices-ServiceBuilderMethods template&lt;&gt; InjectPtr&lt;SomeService&gt; resolve&lt;SomeService&gt;() { if(!storage.someService.getFactory()) { storage.someService.setFactory(boost::bind(boost::factory&lt;SomeService*&gt;())); } return storage.someService; } ///Hoster takes SomeService in constructor template&lt;&gt; InjectPtr&lt;Hoster&gt; resolve&lt;Hoster&gt;() { if(!storage.hoster.getFactory()) { storage.hoster.setFactory(boost::bind(boost::factory&lt;Hoster*&gt;(), resolve&lt;SomeService&gt;())); } return storage.hoster; }</span></span></span></span></code> </pre><br></div></div><br><h5>  IOC module header files </h5><br>  This clause slightly increases the component connectivity within the IOC module, but reduces it during inter-module interaction. <br><br>  For the interaction of IOC modules, it is convenient to create an interface header of the IOC module of the same name with the module itself.  It should contain: <br><ul><li>  the inclusion of class-level public interfaces at the IOC module level; <br></li><li>  full declarations of public at the level of the IOC module of transfers and simple structures; <br></li><li>  definitions of the preprocessor public at the level of the IOC module. <br></li></ul><br>  It is also convenient to have a private module header that imports a public one and does: <br><ul><li>  preliminary announcements of all project classes; <br></li><li>  full declarations of internal for IOC module transfers and simple structures; <br></li><li>  internal for IOC module definitions of preprocessor. <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/226333/">https://habr.com/ru/post/226333/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226323/index.html">Waterfall and Agile: and yet, where does the effect come from?</a></li>
<li><a href="../226325/index.html">An interesting task for the interview, currying and partial application of the function</a></li>
<li><a href="../226327/index.html">What should "PHP Junior Developer without experience" know?</a></li>
<li><a href="../226329/index.html">Apple Metal API: what's the trick?</a></li>
<li><a href="../226331/index.html">Setting up a remote interpreter on Pycharm for Django</a></li>
<li><a href="../226335/index.html">How did SQL Server switch every two to three hours to using a non-optimal query execution plan?</a></li>
<li><a href="../226337/index.html">Let's play evolution? Genetic Algorithms in a Screensaver</a></li>
<li><a href="../226339/index.html">How to assemble an electric bike in seven days</a></li>
<li><a href="../226341/index.html">We sit, do not touch anyone, we repair old headphones</a></li>
<li><a href="../226343/index.html">Gamification or gamification</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>