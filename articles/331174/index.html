<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fuzzy search by name</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. The problem with the search, service or product occurs on the vast majority of sites. And for the most part, the realization of such an oppo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fuzzy search by name</h1><div class="post__text post__text-html js-mediator-article">  Good day.  The problem with the search, service or product occurs on the vast majority of sites.  And for the most part, the realization of such an opportunity is limited to searching for the exact word that was entered in the search box. <br><br>  If there is time, and the customer wants a little more, then the Google implementation of the most popular algorithm (which is the ‚ÄúLevenshtein distance‚Äù) and enter it. <br><br>  In this article, I will describe a strongly modified algorithm based, however, at Levenshtein distances, and give examples of C # code for a fuzzy search by name, for example: cafes, restaurants, or certain services ... In general, everything that can be listed and has from one to several words in its composition: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Yandex, Mail, ProjectArmata, world of tanks, world of warships, world of warplanes, etc. <br><a name="habracut"></a><br>  For those unfamiliar with the algorithm, I recommend reading first the articles " <a href="https://habrahabr.ru/post/123320/">Implementing a Fuzzy Search</a> ," " <a href="https://habrahabr.ru/post/114997/">Fuzzy Search in the Text and the Dictionary,</a> " or its description in my presentation under the slider. <br><br><div class="spoiler">  <b class="spoiler_title">Levenshtein distance algorithm</b> <div class="spoiler_text">  Levenshtein distance is the most popular algorithm in the network for finding the degree of difference between two words.  Namely, what is the minimum number of actions that must be performed to obtain the second from the first line. <br><br>  There are only three such actions: <br><br>  ‚Ä¢ Delete <br>  ‚Ä¢ Insert <br>  ‚Ä¢ Replacement <br><br>  For example, for 2 lines "CONNECT" and "CONEHEAD" you can build the following conversion table: <br><br><img src="https://habrastorage.org/web/cea/924/73c/cea92473cd7d4daca7e3a5734474cd0d.png"><br><br>  In theory, transaction prices may depend on the type of operation (insert, delete, replace) and / or on the symbols involved in it.  But in general: <br><br>  w (a, Œµ) is the cost of deleting the character ‚Äúa‚Äù, equals 1 <br>  w (Œµ, b) is the insertion price of the character ‚Äúb‚Äù, equals 1 <br>  w (a, b) - the price of replacing the character ‚Äúa‚Äù with the character ‚Äúb‚Äù equals 1 <br><br>  Everywhere put units. <br><br>  And from the point of view of mathematics, the calculation looks like this. <br><br>  Let S1 and S2 be two lines (of length M and N respectively) over some alphabet, then the editorial distance (Levenshtein distance) d (S1, S2) can be calculated by the following recurrent formula: <br><br><img src="https://habrastorage.org/web/650/aa9/63c/650aa963c8f74bcaa8230b4bda98e12c.png"><br><br>  The "default implementation" of the Levenshtein algorithm was made by two mathematicians Vanger and Fisher [not to be confused with a chess player]. <br><br>  And it looks like in C # like this: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Int32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">levenshtein</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String a, String b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(a)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(b)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Length; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(b)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(a)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.Length; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } Int32 cost; Int32[,] d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[a.Length + <span class="hljs-number"><span class="hljs-number">1</span></span>, b.Length + <span class="hljs-number"><span class="hljs-number">1</span></span>]; Int32 min1; Int32 min2; Int32 min3; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Int32 i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= d.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { d[i, <span class="hljs-number"><span class="hljs-number">0</span></span>] = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Int32 i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= d.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { d[<span class="hljs-number"><span class="hljs-number">0</span></span>, i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Int32 i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= d.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>); i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Int32 j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= d.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>); j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { cost = Convert.ToInt32(!(a[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] == b[j - <span class="hljs-number"><span class="hljs-number">1</span></span>])); min1 = d[i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j] + <span class="hljs-number"><span class="hljs-number">1</span></span>; min2 = d[i, j - <span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>; min3 = d[i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j - <span class="hljs-number"><span class="hljs-number">1</span></span>] + cost; d[i, j] = Math.Min(Math.Min(min1, min2), min3); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d[d.GetUpperBound(<span class="hljs-number"><span class="hljs-number">0</span></span>), d.GetUpperBound(<span class="hljs-number"><span class="hljs-number">1</span></span>)]; }</code> </pre> <br>  <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance">Taken from here</a> . <br><br>  And visually, the work of the algorithm for the words ‚ÄúPrisoner‚Äù and ‚ÄúDagestan‚Äù is as follows: <br><br><img src="https://habrastorage.org/web/d51/0f6/7ca/d510f67ca03b4bcba004b6b2ba03c665.png"><br><br>  The extreme right-bottom corner of the matrix indicates how different the words are.  From the matrix, that in this particular case, the difference between the words is 3 conditional parrots. <br><br>  If it is not clear, then we will look at these words in another representation: <br><br>  _ A <b>R</b> E S T A N T <br>  D A <b>G</b> E S T A N <br><br>  Thus, it turns out that in order to turn the word ‚ÄúArrestant‚Äù and ‚ÄúDagestan‚Äù, you need to add one letter ‚ÄúD‚Äù, replace one letter ‚ÄúP‚Äù with ‚ÄúG‚Äù and remove the letter ‚ÄúT‚Äù.  Since  All actions have a weight of 1, then the difference in words is 3 parrots. <br><br>  If the words completely coincide, then the distance will be 0. That's the whole theory, everything ingenious is simple. <br></div></div><br>  And it would seem - this is it!  Everything is invented for us and there is nothing to do at all, but there is a problem ... <br><br>  1) Taking weight coefficient 1 is always not quite right, because the probability of a typo depends on several specific factors: the distance of the keys on the keyboard, phonetic groups, and even the banal speed of typing. <br>  2) The idea of ‚Äã‚ÄãLevenshtein is designed to ‚Äúfind differences between words,‚Äù rather than part of words, which is critical for dynamic output as letters are entered. <br>  3) The names of the services have in their structure more than one word, then the person may simply not remember in what order they go. <br><br>  We also take into account several factors, such as: <br><br>  ‚Ä¢ keyboard layout in another language <br>  ‚Ä¢ transliteration of characters <br><br>  We will try to solve these problems in this article. <br><br>  To begin with, let's agree that all the words we will lead to one single register.  In my version of the code, I chose lower case, this will be reflected in the references that we need (these references will be given in the course of the description).  In the article itself, I will resort to different writing styles, for example, ‚ÄúCamelCase‚Äù - ProjectArmata, but this is done solely for the convenience of human perception, from the point of view of analysis, the register is one (lower).  And yet, we will take as a basis not the classical, but the optimized version of the code for finding the Levenshtein distance <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance">from here</a> : <br><br>  Adjust it a little by removing the reordering of words.  For Levenshtein's algorithm, word order does not matter, but for us it will be important for other reasons.  As a result, we got the following: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LevenshteinDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(String.IsNullOrEmpty(source)){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(String.IsNullOrEmpty(target)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target.Length; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(String.IsNullOrEmpty(target)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source.Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = target.Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = source.Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> distance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>, m + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// Initialize the distance 'matrix' for(var j = 1; j &lt;= m; j++) distance[0, j] = j; var currentRow = 0; for(var i = 1; i &lt;= n; ++i){ currentRow = i &amp; 1; distance[currentRow, 0] = i; var previousRow = currentRow ^ 1; for(var j = 1; j &lt;= m; j++){ var cost = (target[j - 1] == source[i - 1] ? 0 : 1); distance[currentRow, j] = Math.Min(Math.Min( distance[previousRow, j] + 1, distance[currentRow, j - 1] + 1), distance[previousRow, j - 1] + cost); } } return distance[currentRow, m]; }</span></span></code> </pre> <br>  Let's start improving the search algorithm with changes in weighting factors.  First we make the insertion and deletion coefficients equal to 2. <br><br>  Those.  the lines will change: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= m; j++) distance[<span class="hljs-number"><span class="hljs-number">0</span></span>, j] = j * <span class="hljs-number"><span class="hljs-number">2</span></span>; ... distance[currentRow, <span class="hljs-number"><span class="hljs-number">0</span></span>] = i * <span class="hljs-number"><span class="hljs-number">2</span></span>; ... distance[previousRow, j] + <span class="hljs-number"><span class="hljs-number">2</span></span> ... distance[currentRow, j - <span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  And here is the line for calculating the replacement rate of characters, we, turning into a function CostDistanceSymbol: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cost = (target[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] == source[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  And we will consider two factors: <br><br>  1) Keyboard distance <br>  2) Phonetic groups <br><br>  In this regard, for more convenient work with source and target objects, we will turn them into an object: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Word</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   public string Text { get; set; } //   public List&lt;int&gt; Codes { get; set; } = new List&lt;int&gt;(); }</span></span></code> </pre><br>  To do this, you will need the following auxiliary directories: <br><br>  The ratio of key codes of the Russian keyboard: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SortedDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; CodeKeysRus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SortedDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { { <span class="hljs-string"><span class="hljs-string">''</span></span> , <span class="hljs-number"><span class="hljs-number">192</span></span> }, { <span class="hljs-string"><span class="hljs-string">'1'</span></span> , <span class="hljs-number"><span class="hljs-number">49</span></span> }, { <span class="hljs-string"><span class="hljs-string">'2'</span></span> , <span class="hljs-number"><span class="hljs-number">50</span></span> }, ... { <span class="hljs-string"><span class="hljs-string">'-'</span></span> , <span class="hljs-number"><span class="hljs-number">189</span></span> }, { <span class="hljs-string"><span class="hljs-string">'='</span></span> , <span class="hljs-number"><span class="hljs-number">187</span></span> }, { <span class="hljs-string"><span class="hljs-string">''</span></span> , <span class="hljs-number"><span class="hljs-number">81</span></span> }, { <span class="hljs-string"><span class="hljs-string">''</span></span> , <span class="hljs-number"><span class="hljs-number">87</span></span> }, { <span class="hljs-string"><span class="hljs-string">''</span></span> , <span class="hljs-number"><span class="hljs-number">69</span></span> }, ... { <span class="hljs-string"><span class="hljs-string">'_'</span></span> , <span class="hljs-number"><span class="hljs-number">189</span></span> }, { <span class="hljs-string"><span class="hljs-string">'+'</span></span> , <span class="hljs-number"><span class="hljs-number">187</span></span> }, { <span class="hljs-string"><span class="hljs-string">','</span></span> , <span class="hljs-number"><span class="hljs-number">191</span></span> }, }</code> </pre> <br>  The ratio of key codes for the English keyboard <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SortedDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; CodeKeysEng = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SortedDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { { <span class="hljs-string"><span class="hljs-string">'`'</span></span>, <span class="hljs-number"><span class="hljs-number">192</span></span> }, { <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-number"><span class="hljs-number">49</span></span> }, { <span class="hljs-string"><span class="hljs-string">'2'</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span> }, ... { <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-number"><span class="hljs-number">189</span></span> }, { <span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-number"><span class="hljs-number">187</span></span> }, { <span class="hljs-string"><span class="hljs-string">'q'</span></span>, <span class="hljs-number"><span class="hljs-number">81</span></span> }, { <span class="hljs-string"><span class="hljs-string">'w'</span></span>, <span class="hljs-number"><span class="hljs-number">87</span></span> }, { <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-number"><span class="hljs-number">69</span></span> }, { <span class="hljs-string"><span class="hljs-string">'r'</span></span>, <span class="hljs-number"><span class="hljs-number">82</span></span> }, ... { <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>, <span class="hljs-number"><span class="hljs-number">188</span></span> }, { <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>, <span class="hljs-number"><span class="hljs-number">190</span></span> }, { <span class="hljs-string"><span class="hljs-string">'?'</span></span>, <span class="hljs-number"><span class="hljs-number">191</span></span> }, };</code> </pre> <br>  Thanks to these two reference books, mathematically speaking, we can transform two different character spaces into one single universal. <br><br>  And the following relations will be fair there: <br><br>  private static SortedDictionary &lt;int, List&gt; DistanceCodeKey = new SortedDictionary &lt;int, <br><br><pre> <code class="cs hljs">List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">/* '`' */</span></span> { <span class="hljs-number"><span class="hljs-number">192</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(){ <span class="hljs-number"><span class="hljs-number">49</span></span> }}, <span class="hljs-comment"><span class="hljs-comment">/* '1' */</span></span> { <span class="hljs-number"><span class="hljs-number">49</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(){ <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">87</span></span>, <span class="hljs-number"><span class="hljs-number">81</span></span> }}, <span class="hljs-comment"><span class="hljs-comment">/* '2' */</span></span> { <span class="hljs-number"><span class="hljs-number">50</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(){ <span class="hljs-number"><span class="hljs-number">49</span></span>, <span class="hljs-number"><span class="hljs-number">81</span></span>, <span class="hljs-number"><span class="hljs-number">87</span></span>, <span class="hljs-number"><span class="hljs-number">69</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span> }}, ... <span class="hljs-comment"><span class="hljs-comment">/* '-' */</span></span> { <span class="hljs-number"><span class="hljs-number">189</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(){ <span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">219</span></span>, <span class="hljs-number"><span class="hljs-number">221</span></span>, <span class="hljs-number"><span class="hljs-number">187</span></span> }}, <span class="hljs-comment"><span class="hljs-comment">/* '+' */</span></span> { <span class="hljs-number"><span class="hljs-number">187</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(){ <span class="hljs-number"><span class="hljs-number">189</span></span>, <span class="hljs-number"><span class="hljs-number">219</span></span>, <span class="hljs-number"><span class="hljs-number">221</span></span> }}, <span class="hljs-comment"><span class="hljs-comment">/* 'q' */</span></span> { <span class="hljs-number"><span class="hljs-number">81</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(){ <span class="hljs-number"><span class="hljs-number">49</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">87</span></span>, <span class="hljs-number"><span class="hljs-number">83</span></span>, <span class="hljs-number"><span class="hljs-number">65</span></span> }}, <span class="hljs-comment"><span class="hljs-comment">/* 'w' */</span></span> { <span class="hljs-number"><span class="hljs-number">87</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(){ <span class="hljs-number"><span class="hljs-number">49</span></span>, <span class="hljs-number"><span class="hljs-number">81</span></span>, <span class="hljs-number"><span class="hljs-number">65</span></span>, <span class="hljs-number"><span class="hljs-number">83</span></span>, <span class="hljs-number"><span class="hljs-number">68</span></span>, <span class="hljs-number"><span class="hljs-number">69</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span> }}, ... <span class="hljs-comment"><span class="hljs-comment">/* '&gt;' */</span></span> { <span class="hljs-number"><span class="hljs-number">188</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(){ <span class="hljs-number"><span class="hljs-number">77</span></span>, <span class="hljs-number"><span class="hljs-number">74</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>, <span class="hljs-number"><span class="hljs-number">76</span></span>, <span class="hljs-number"><span class="hljs-number">190</span></span> }}, <span class="hljs-comment"><span class="hljs-comment">/* '&lt;' */</span></span> { <span class="hljs-number"><span class="hljs-number">190</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(){ <span class="hljs-number"><span class="hljs-number">188</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>, <span class="hljs-number"><span class="hljs-number">76</span></span>, <span class="hljs-number"><span class="hljs-number">186</span></span>, <span class="hljs-number"><span class="hljs-number">191</span></span> }}, <span class="hljs-comment"><span class="hljs-comment">/* '?' */</span></span> { <span class="hljs-number"><span class="hljs-number">191</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(){ <span class="hljs-number"><span class="hljs-number">190</span></span>, <span class="hljs-number"><span class="hljs-number">76</span></span>, <span class="hljs-number"><span class="hljs-number">186</span></span>, <span class="hljs-number"><span class="hljs-number">222</span></span> }}, };</code> </pre> <br>  Those.  we take the keys standing around the other key.  You can verify this by the example of the figure: <br><br><img src="https://habrastorage.org/web/6c3/c97/93d/6c3c9793dcd346fb8bdef514f41bd630.gif"><br><br>  Yes, I know that in addition to the QWERTY keyboard, there are other layouts, and then the table of keyboard distances will not match, but we take the most common option. <br><br>  If someone knows a better way - please write. <br><br>  Now we are ready for the first stage - calculating the weight of the error symbol in the CostDistanceSymbol function: <br><br>  As it was before, if the characters are the same, then the distance is 0: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.Text[sourcePosition] == target.Text[targetPosition]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  If the key codes are the same, then the distance is also 0: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.Codes[sourcePosition] != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; target.Codes[targetPosition] == target.Codes[targetPosition]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  If you have a question why we compare key codes after comparing characters, the answer is simple - we want the words ‚ÄúWater‚Äù and ‚ÄúDjlf‚Äù to be perceived the same way.  And the characters that can be typed on different layouts, for example, ";" or "," regardless of the layout, were also perceived the same way. <br><br>  Further, we are only looking at the codes how closely the key codes are from each other.  If close, then distance 1, and if not, then 2 (exactly the same weight as when inserting or deleting): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultWeight = <span class="hljs-number"><span class="hljs-number">0</span></span>; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; nearKeys; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!DistanceCodeKey.TryGetValue(source.Codes[sourcePosition], <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> nearKeys)) resultWeight = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resultWeight = nearKeys.Contains(target.Codes[searchPosition]) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  In fact, such a small refinement covers a huge number of random errors ranging from the wrong layout, ending with a miss by the key. <br><br>  But after the typing errors, a person simply may not know how words are spelled.  For example: pike, posh.  test <br><br>  Such words are not only in Russian, but also in English.  Similar cases we also need to take into account.  For the English words, we take as a basis the work of <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.14.3856%26rep%3Drep1%26type%3Dpdf">Zobel and Dart on phonetic groups</a> . <br><br>  "Aeiouy", "bp", "ckq", "dt", "lr", "mn", "gj", "fpv", "sxz", "csz" <br><br>  And for Russian, I will compile myself on a whim: <br><br>  ‚ÄúYiy‚Äù, ‚Äúee‚Äù, ‚Äúaya‚Äù, ‚Äúoee‚Äù, ‚Äúyu‚Äù, ‚Äúsc‚Äù, ‚Äúoa‚Äù, ‚Äúyo‚Äù <br><br>  These phonetic groups are converted into an object of the type: <br><br><pre> <code class="cs hljs">PhoneticGroupsEng = { { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, { <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-string"><span class="hljs-string">'i'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-string"><span class="hljs-string">'u'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>} }, { <span class="hljs-string"><span class="hljs-string">'e'</span></span>, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'i'</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>, <span class="hljs-string"><span class="hljs-string">'u'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>} } ... }</code> </pre><br>  This can be done by hand or as I write code, but the result will be the same.  And now after checking the key code, you can check the letters for entering the phonetic group with the same logic of finding errors as in the previous step: <br><br><pre> <code class="cs hljs">List&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; phoneticGroups; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PhoneticGroupsRus.TryGetValue(target.Text[targetPosition], <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> phoneticGroups)) resultWeight = Math.Min(resultWeight, phoneticGroups.Contains(source.Text[sourcePosition]) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PhoneticGroupsEng.TryGetValue(target.Text[targetPosition], <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> phoneticGroups)) resultWeight = Math.Min(resultWeight, phoneticGroups.Contains(source.Text[sourcePosition]) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  In addition to the above missed typos, there are typos "typing speed" of the text.  This is when two consecutive letters people, when typing, confused places.  Moreover, this is such a common mistake that a certain mathematician Frederick Damerau modified the Levenshtein algorithm by adding a transposition (permutation) of characters. <br><br>  From a programmatic point of view, we add the following to the LevenshteinDistance function: <br><br><img src="https://habrastorage.org/web/9d6/f43/fad/9d6f43fad6194de08c09142d853d7b78.png"><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; j &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; source.Text[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] == target.Text[j - <span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; source.Text[i - <span class="hljs-number"><span class="hljs-number">2</span></span>] == target.Text[j - <span class="hljs-number"><span class="hljs-number">1</span></span>]) { distance[currentRow, j] = Math.Min(distance[currentRow, j], distance[(i - <span class="hljs-number"><span class="hljs-number">2</span></span>) % <span class="hljs-number"><span class="hljs-number">3</span></span>, j - <span class="hljs-number"><span class="hljs-number">2</span></span>] + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Remark</b> <div class="spoiler_text">  The optimized code that we took as a basis has the following form of initialization of the distance matrix: var distance = new int [2, m + 1]; <br><br>  Therefore, this section of the code ‚Äúdistance [(i - 2)% 3, ...‚Äù will not work in its current form, I will give the correct version of the function at the end of the article. <br></div></div><br>  Thus, we have completed the first paragraph to refine the code.  Go to the second paragraph.  Recall that the Levenshtein idea is intended to ‚Äúfind differences between words,‚Äù and not part of the words, which is critical for dynamic output results as letters are entered. <br><br>  For example, in the directory there are two words: <br><br>  ‚Ä¢ ‚ÄúProjectArmata‚Äù <br>  ‚Ä¢ "Yak" <br><br>  Entering the query ‚ÄúPro‚Äù in the search bar, we get ‚ÄúYak‚Äù as a higher priority, due to the fact that replacing two characters and deleting one will be only 3 parrots (taking into account unit coefficients and the classical Levenshtein algorithm, without our modifications), Adding part of the word "jectArmata" 10 parrots. <br><br>  The most logical in this situation is not to compare the whole word, but only a part of the desired word with the entered string. <br><br>  Since  the search query consists of three characters ‚ÄúPro‚Äù, we will take the first three characters from the word ‚ÄúProjectArmata‚Äù, i.e.  ‚ÄúPro‚Äù and get 100% match.  For this particular case - perfect.  But let's consider some more options.  Suppose we have in the database, there is the following set of words: <br><br>  ‚Ä¢ "Communal" <br>  ‚Ä¢ "Conveyor" <br>  ‚Ä¢ "The colony" <br>  ‚Ä¢ ‚ÄúCosmetics‚Äù <br><br>  The search query will look like ‚Äúcom‚Äù.  As a result, words will have the following match factors: <br><br>  Communal - 0 <br>  Conveyor - 1 <br>  Colony - 1 <br>  Cosmetics - 1 <br><br>  If everything is normal with the word ‚ÄúKommunalka‚Äù, then the other three words look somehow uniform ... Although it is clear that, perhaps, the person described himself in one letter and he is looking for ‚ÄúCosmetics‚Äù, and not Conveyor or Colony.  And our task is to give him the most suitable result, and not just everything.  Especially, as Damerau said - most of the errors are transpositions of letters. <br><br>  To eliminate such a mistake, we do a little refinement: <br><br>  Take not the first ‚Äún‚Äù letters, but ‚Äún + 1‚Äù letters, where n is the number of letters in the query.  And then the coefficients when querying "Com" will be as follows: <br><br>  Communal - 1 <br>  Cosmetics - 1 <br>  Conveyor - 2 <br>  Colony - 2 <br><br>  ‚ÄúCosmetics‚Äù was corrected, but ‚ÄúKommunalka‚Äù left ... But I like this option more for what reasons.  Usually, if a search is required, initially the information is shown to the user in the form of a drop-down list, under the search line, as letters are entered.  The length of this drop-down list is limited in size to 3-7 entries.  As a consequence, if there are only three entries, then in the second version they will appear: ‚ÄúCommunal‚Äù, ‚ÄúCosmetics‚Äù and ‚ÄúConveyor‚Äù [as  he is stupid first in issuing because of a guid, or simply because of the date of creation].  And in the first case there will be ‚ÄúCommunal‚Äù, ‚ÄúConveyor‚Äù, ‚ÄúColony‚Äù and no ‚ÄúCosmetics‚Äù, since  she was not lucky for other reasons ... <br><br>  Of course, this problem has other solutions.  For example, sort first, by ‚Äún‚Äù letters, and then, take those groups of words from whom the indices coincided and additionally re-sort the ‚Äún + 1‚Äù letters and you can again, and again ... Here it is solved individually depending on the data in the database , solvable problem, computing power. <br><br>  Let's not now focus on solving the above problem ... We are only in the middle of the road and I still have something to tell. <br><br>  The following nuance in the correct search results comes to us from the times of the USSR.  Then they loved to make names consisting of several words combined into one.  And now it is relevant: <br><br>  Consumer union <br>  GazPromBank <br>  Agricultural Bank <br>  ProjectArmata <br>  BankURALSIB <br>  Etc. <br><br>  [ps  I know that some of the names are separated by spaces, but I needed to pick some vivid examples] <br><br>  But, if we follow our algorithm, we always take the first "n + 1" letters from the word.  And if a person picks up the word "Bank", he will not receive an adequate issuance.  Since  we will compare the lines: <br><br>  "Bank" <br>  "Potre" <br>  "Gazpr" <br>  Rosse <br>  "Proje" <br><br>  To find the word "bank" regardless of position, we will need to make a floating window for the phrase and return the smallest coefficient: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRangeWord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Word source, Word target</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> rangeWord = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.MaxValue; Word croppedSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Word(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = Math.Min(source.Text.Length, target.Text.Length + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= source.Text.Length - length; i++) { croppedSource.Text = target.Text.Substring(i, length); croppedSource.Codes = target.Codes.Skip(i).Take(length).ToList(); rangeWord = Math.Min(LevenshteinDistance(croppedSource, target) + (i * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">10.0</span></span>), rangeWord); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rangeWord; }</code> </pre> <br>  As you can see, to the error obtained after calculating the Levenshtein distance, we add another value (i * 2 / 10.0).  If with ‚Äúi * 2‚Äù everything is clear, this is a mistake of inserting letters at the beginning of a word, like the classical algorithm for finding the Levenshtein distance, but why do we divide it by 10?  The bottom line is that if we just leave ‚Äúi * 2‚Äù, then words that are stupidly shorter in length will fall into the issue of claim and we will again get away from the name of the banks.  And so the coefficient has to be divided by 10, which is to reduce this offset.  Why exactly 10?  For our base, it was more or less normal, but I do not exclude that it can be divided into more.  Everything depends on the length of the words and how similar the words are.  I will give the calculation of the most suitable coefficient a little later. <br><br>  With words, as well as the search unit, sort of sorted out, now go to the phrases.  And first, again, a few examples: <br><br>  ‚Ä¢ warface <br>  ‚Ä¢ world of tanks <br>  ‚Ä¢ world of warplanes <br>  ‚Ä¢ world of ships <br><br>  Let's understand what we basically need from searching for a phrase.  We need the missing words to be added, the extra phrases deleted, and also that they change places.  Somewhere I have already said this ... And, exactly, I remembered ... At the beginning of the article, when I was talking about the words and the function of Levenshtein distance.  In order not to waste your time, I will immediately say that it did not work out in its pure form, but inspired by her, she managed to write code applicable to phrases. <br><br>  As with the implementation of the Levenshtein distance function, if one of the phrases is empty, then we return an error value equal to the insertion or deletion [depending on which side the empty phrase came from] of all the letters. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!source.Words.Any()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!search.Words.Any()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> search.Words.Sum(w =&gt; w.Text.Length) * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!search.Words.Any()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source.Words.Sum(w =&gt; w.Text.Length) * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">100</span></span>; }</code> </pre> <br>  Those.  we summarize the number of letters in the phrase multiplied by 2 (this coefficient was chosen at the beginning of the article for letters) and multiplied by 100. These 100 are the most controversial coefficient in the whole algorithm.  For what it will be needed more clearly presented below, and then I will explain that, in theory, it must be calculated, and not just taken from the ceiling. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; search.Words.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> minRangeWord = <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; source.Words.Count; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> currentRangeWord = GetRangeWord(source.Words[j], search.Words[i], translation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentRangeWord &lt; minRangeWord) { minRangeWord = currentRangeWord; minIndex = j; } } result += minRangeWord * <span class="hljs-number"><span class="hljs-number">100</span></span> + (Math.Abs(i - minIndex) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  In this code, we match each word from the record in the database with each of the search query and take the smallest coefficients for each word.  The total coefficient for the phrase is as follows: <br><br>  result + = minRangeWord * 100 + (Math.Abs ‚Äã‚Äã(i - minIndex) / 10.0); <br><br>  As you can see, all the logic is the same as described earlier, the minimum coefficient for the word minRangeWord is multiplied by our 100 and summed up with the coefficient that shows how close the word is to its most suitable position (Math.Abs ‚Äã‚Äã(i - minIndex) / 10.0). <br><br>  A multiplication of 100 is used to compensate for the incremental coefficient that may occur when searching for the most suitable position of the search word in the previous step.  As a result, this coefficient can be calculated as the largest between the phrase in the search line and all the words in the database.  Not phrases, namely words.  But for this, it would be necessary to measure the Levenshtein distance with our modifications to ‚Äúempty‚Äù with our modifications, which is very wasteful in terms of resources. <br><br>  Those.  get rid of the function GetRangeWord and take the maximum value of the deviation of the phrase ‚Äúi * 2‚Äù from the most appropriate place.  And then take the highest value to bring it to the nearest larger tenfold number (10, 100, 1000, 10000, 100000, etc.).  Thus we get two values: <br><br>  The first is the value to which the mixed word should be divided in the GetRangeWord function.  The second is the value that you need to multiply minRangeWord to compensate for the previous offset.  In this way we will get accurate indicators of phrase similarity.  But in practice one can neglect large deviations, and estimate the average approximately ... What I actually did. <br><br>  In principle, everything.  The main questions I have left out are just a slight refinement of the ‚Äútransliteration of characters‚Äù.  The difference between the above described search and the search in transliteration is that, in the CostDistanceSymbol function, we will not adjust the response values ‚Äã‚Äãby key distance, since  The issue in this case will not be correct. <br><br>  It can also be noted that the adequate output of the result begins with 3 characters in the search string; if the symbol is smaller, it is better to use a more clumsy method with accurate string matching. <br><br>  Next, I will give the most complete code of all the above described, but first: <br><br>  1) This code was written by me personally in my free time. <br>  2) The algorithm was thought out by me personally in my free time. <br><br>  Separately, I want to say thank you for the links and inspiration: Dmitry Panyushkin, Pavel Grigorenko. <br>  The names that are given in the article are taken from public sources and belong to their owners.  Not an advertisement. <br><br>  Thanks to everyone who read.  Criticism and advice are welcome. <br><br><div class="spoiler">  <b class="spoiler_title">Full code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DistanceAlferov</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Word</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Text { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Codes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AnalizeObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Origianl { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;Word&gt; Words { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Word&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LanguageSet</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnalizeObject Rus { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnalizeObject(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnalizeObject Eng { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnalizeObject(); } List&lt;LanguageSet&gt; Samples { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;LanguageSet&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Tuple&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt; datas</span></span></span><span class="hljs-function">)</span></span> { List&lt;KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; codeKeys = CodeKeysRus.Concat(CodeKeysEng).ToList(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> datas) { LanguageSet languageSet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LanguageSet(); languageSet.Rus.Origianl = data.Item1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.Item1.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { languageSet.Rus.Words = data.Item1.Split(<span class="hljs-string"><span class="hljs-string">' '</span></span>).Select(w =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Word() { Text = w.ToLower(), Codes = GetKeyCodes(codeKeys, w) }).ToList(); } languageSet.Eng.Origianl = data.Item2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.Item2.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { languageSet.Eng.Words = data.Item2.Split(<span class="hljs-string"><span class="hljs-string">' '</span></span>).Select(w =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Word() { Text = w.ToLower(), Codes = GetKeyCodes(codeKeys, w) }).ToList(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Samples.Add(languageSet); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; Search(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> targetStr) { List&lt;KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; codeKeys = CodeKeysRus.Concat(CodeKeysEng).ToList(); AnalizeObject originalSearchObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnalizeObject(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetStr.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { originalSearchObj.Words = targetStr.Split(<span class="hljs-string"><span class="hljs-string">' '</span></span>).Select(w =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Word() { Text = w.ToLower(), Codes = GetKeyCodes(codeKeys, w) }).ToList(); } AnalizeObject translationSearchObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnalizeObject(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetStr.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { translationSearchObj.Words = targetStr.Split(<span class="hljs-string"><span class="hljs-string">' '</span></span>).Select(w =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> translateStr = Transliterate(w.ToLower(), Translit_Ru_En); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Word() { Text = translateStr, Codes = GetKeyCodes(codeKeys, translateStr) }; }).ToList(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (LanguageSet sampl <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Samples) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> languageType = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> cost = GetRangePhrase(sampl.Rus, originalSearchObj, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tempCost = GetRangePhrase(sampl.Eng, originalSearchObj, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cost &gt; tempCost) { cost = tempCost; languageType = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//    tempCost = GetRangePhrase(sampl.Rus, translationSearchObj, true); if (cost &gt; tempCost) { cost = tempCost; languageType = 2; } tempCost = GetRangePhrase(sampl.Eng, translationSearchObj, true); if (cost &gt; tempCost) { cost = tempCost; languageType = 3; } result.Add(new Tuple&lt;string, string, double, int&gt;(sampl.Rus.Origianl, sampl.Eng.Origianl, cost, languageType)); } return result; } private double GetRangePhrase(AnalizeObject source, AnalizeObject search, bool translation) { if (!source.Words.Any()) { if (!search.Words.Any()) return 0; return search.Words.Sum(w =&gt; w.Text.Length) * 2 * 100; } if (!search.Words.Any()) { return source.Words.Sum(w =&gt; w.Text.Length) * 2 * 100; } double result = 0; for (int i = 0; i &lt; search.Words.Count; i++) { double minRangeWord = double.MaxValue; int minIndex = 0; for (int j = 0; j &lt; source.Words.Count; j++) { double currentRangeWord = GetRangeWord(source.Words[j], search.Words[i], translation); if (currentRangeWord &lt; minRangeWord) { minRangeWord = currentRangeWord; minIndex = j; } } result += minRangeWord * 100 + (Math.Abs(i - minIndex) / 10.0); } return result; } private double GetRangeWord(Word source, Word target, bool translation) { double minDistance = double.MaxValue; Word croppedSource = new Word(); int length = Math.Min(source.Text.Length, target.Text.Length + 1); for (int i = 0; i &lt;= source.Text.Length - length; i++) { croppedSource.Text = source.Text.Substring(i, length); croppedSource.Codes = source.Codes.Skip(i).Take(length).ToList(); minDistance = Math.Min(minDistance, LevenshteinDistance(croppedSource, target, croppedSource.Text.Length == source.Text.Length, translation) + (i * 2 / 10.0)); } return minDistance; } private int LevenshteinDistance(Word source, Word target, bool fullWord, bool translation) { if (String.IsNullOrEmpty(source.Text)) { if (String.IsNullOrEmpty(target.Text)) return 0; return target.Text.Length * 2; } if (String.IsNullOrEmpty(target.Text)) return source.Text.Length * 2; int n = source.Text.Length; int m = target.Text.Length; //TODO    ( ) int[,] distance = new int[3, m + 1]; // Initialize the distance 'matrix' for (var j = 1; j &lt;= m; j++) distance[0, j] = j * 2; var currentRow = 0; for (var i = 1; i &lt;= n; ++i) { currentRow = i % 3; var previousRow = (i - 1) % 3; distance[currentRow, 0] = i * 2; for (var j = 1; j &lt;= m; j++) { distance[currentRow, j] = Math.Min(Math.Min( distance[previousRow, j] + ((!fullWord &amp;&amp; i == n) ? 2 - 1 : 2), distance[currentRow, j - 1] + ((!fullWord &amp;&amp; i == n) ? 2 - 1 : 2)), distance[previousRow, j - 1] + CostDistanceSymbol(source, i - 1, target, j - 1, translation)); if (i &gt; 1 &amp;&amp; j &gt; 1 &amp;&amp; source.Text[i - 1] == target.Text[j - 2] &amp;&amp; source.Text[i - 2] == target.Text[j - 1]) { distance[currentRow, j] = Math.Min(distance[currentRow, j], distance[(i - 2) % 3, j - 2] + 2); } } } return distance[currentRow, m]; } private int CostDistanceSymbol(Word source, int sourcePosition, Word search, int searchPosition, bool translation) { if (source.Text[sourcePosition] == search.Text[searchPosition]) return 0; if (translation) return 2; if (source.Codes[sourcePosition] != 0 &amp;&amp; source.Codes[sourcePosition] == search.Codes[searchPosition]) return 0; int resultWeight = 0; List&lt;int&gt; nearKeys; if (!DistanceCodeKey.TryGetValue(source.Codes[sourcePosition], out nearKeys)) resultWeight = 2; else resultWeight = nearKeys.Contains(search.Codes[searchPosition]) ? 1 : 2; List&lt;char&gt; phoneticGroups; if (PhoneticGroupsRus.TryGetValue(search.Text[searchPosition], out phoneticGroups)) resultWeight = Math.Min(resultWeight, phoneticGroups.Contains(source.Text[sourcePosition]) ? 1 : 2); if (PhoneticGroupsEng.TryGetValue(search.Text[searchPosition], out phoneticGroups)) resultWeight = Math.Min(resultWeight, phoneticGroups.Contains(source.Text[sourcePosition]) ? 1 : 2); return resultWeight; } private List&lt;int&gt; GetKeyCodes(List&lt;KeyValuePair&lt;char, int&gt;&gt; codeKeys, string word) { return word.ToLower().Select(ch =&gt; codeKeys.FirstOrDefault(ck =&gt; ck.Key == ch).Value).ToList(); } private string Transliterate(string text, Dictionary&lt;char, string&gt; cultureFrom) { IEnumerable&lt;char&gt; translateText = text.SelectMany(t =&gt; { string translateChar; if (cultureFrom.TryGetValue(t, out translateChar)) return translateChar; return t.ToString(); }); return string.Concat(translateText); } #region    static Dictionary&lt;char, List&lt;char&gt;&gt; PhoneticGroupsRus = new Dictionary&lt;char, List&lt;char&gt;&gt;(); static Dictionary&lt;char, List&lt;char&gt;&gt; PhoneticGroupsEng = new Dictionary&lt;char, List&lt;char&gt;&gt;(); #endregion static DistanceAlferov() { SetPhoneticGroups(PhoneticGroupsRus, new List&lt;string&gt;() { "", "", "", "", "", "", "" }); SetPhoneticGroups(PhoneticGroupsEng, new List&lt;string&gt;() { "aeiouy", "bp", "ckq", "dt", "lr", "mn", "gj", "fpv", "sxz", "csz" }); } private static void SetPhoneticGroups(Dictionary&lt;char, List&lt;char&gt;&gt; resultPhoneticGroups, List&lt;string&gt; phoneticGroups) { foreach (string group in phoneticGroups) foreach (char symbol in group) if (!resultPhoneticGroups.ContainsKey(symbol)) resultPhoneticGroups.Add(symbol, phoneticGroups.Where(pg =&gt; pg.Contains(symbol)).SelectMany(pg =&gt; pg).Distinct().Where(ch =&gt; ch != symbol).ToList()); } #region     /// &lt;summary&gt; ///    /// &lt;/summary&gt; private static Dictionary&lt;int, List&lt;int&gt;&gt; DistanceCodeKey = new Dictionary&lt;int, List&lt;int&gt;&gt; { /* '`' */ { 192 , new List&lt;int&gt;(){ 49 }}, /* '1' */ { 49 , new List&lt;int&gt;(){ 50, 87, 81 }}, /* '2' */ { 50 , new List&lt;int&gt;(){ 49, 81, 87, 69, 51 }}, /* '3' */ { 51 , new List&lt;int&gt;(){ 50, 87, 69, 82, 52 }}, /* '4' */ { 52 , new List&lt;int&gt;(){ 51, 69, 82, 84, 53 }}, /* '5' */ { 53 , new List&lt;int&gt;(){ 52, 82, 84, 89, 54 }}, /* '6' */ { 54 , new List&lt;int&gt;(){ 53, 84, 89, 85, 55 }}, /* '7' */ { 55 , new List&lt;int&gt;(){ 54, 89, 85, 73, 56 }}, /* '8' */ { 56 , new List&lt;int&gt;(){ 55, 85, 73, 79, 57 }}, /* '9' */ { 57 , new List&lt;int&gt;(){ 56, 73, 79, 80, 48 }}, /* '0' */ { 48 , new List&lt;int&gt;(){ 57, 79, 80, 219, 189 }}, /* '-' */ { 189 , new List&lt;int&gt;(){ 48, 80, 219, 221, 187 }}, /* '+' */ { 187 , new List&lt;int&gt;(){ 189, 219, 221 }}, /* 'q' */ { 81 , new List&lt;int&gt;(){ 49, 50, 87, 83, 65 }}, /* 'w' */ { 87 , new List&lt;int&gt;(){ 49, 81, 65, 83, 68, 69, 51, 50 }}, /* 'e' */ { 69 , new List&lt;int&gt;(){ 50, 87, 83, 68, 70, 82, 52, 51 }}, /* 'r' */ { 82 , new List&lt;int&gt;(){ 51, 69, 68, 70, 71, 84, 53, 52 }}, /* 't' */ { 84 , new List&lt;int&gt;(){ 52, 82, 70, 71, 72, 89, 54, 53 }}, /* 'y' */ { 89 , new List&lt;int&gt;(){ 53, 84, 71, 72, 74, 85, 55, 54 }}, /* 'u' */ { 85 , new List&lt;int&gt;(){ 54, 89, 72, 74, 75, 73, 56, 55 }}, /* 'i' */ { 73 , new List&lt;int&gt;(){ 55, 85, 74, 75, 76, 79, 57, 56 }}, /* 'o' */ { 79 , new List&lt;int&gt;(){ 56, 73, 75, 76, 186, 80, 48, 57 }}, /* 'p' */ { 80 , new List&lt;int&gt;(){ 57, 79, 76, 186, 222, 219, 189, 48 }}, /* '[' */ { 219 , new List&lt;int&gt;(){ 48, 186, 222, 221, 187, 189 }}, /* ']' */ { 221 , new List&lt;int&gt;(){ 189, 219, 187 }}, /* 'a' */ { 65 , new List&lt;int&gt;(){ 81, 87, 83, 88, 90 }}, /* 's' */ { 83 , new List&lt;int&gt;(){ 81, 65, 90, 88, 67, 68, 69, 87, 81 }}, /* 'd' */ { 68 , new List&lt;int&gt;(){ 87, 83, 88, 67, 86, 70, 82, 69 }}, /* 'f' */ { 70 , new List&lt;int&gt;(){ 69, 68, 67, 86, 66, 71, 84, 82 }}, /* 'g' */ { 71 , new List&lt;int&gt;(){ 82, 70, 86, 66, 78, 72, 89, 84 }}, /* 'h' */ { 72 , new List&lt;int&gt;(){ 84, 71, 66, 78, 77, 74, 85, 89 }}, /* 'j' */ { 74 , new List&lt;int&gt;(){ 89, 72, 78, 77, 188, 75, 73, 85 }}, /* 'k' */ { 75 , new List&lt;int&gt;(){ 85, 74, 77, 188, 190, 76, 79, 73 }}, /* 'l' */ { 76 , new List&lt;int&gt;(){ 73, 75, 188, 190, 191, 186, 80, 79 }}, /* ';' */ { 186 , new List&lt;int&gt;(){ 79, 76, 190, 191, 222, 219, 80 }}, /* '\''*/ { 222 , new List&lt;int&gt;(){ 80, 186, 191, 221, 219 }}, /* 'z' */ { 90 , new List&lt;int&gt;(){ 65, 83, 88 }}, /* 'x' */ { 88 , new List&lt;int&gt;(){ 90, 65, 83, 68, 67 }}, /* 'c' */ { 67 , new List&lt;int&gt;(){ 88, 83, 68, 70, 86 }}, /* 'v' */ { 86 , new List&lt;int&gt;(){ 67, 68, 70, 71, 66 }}, /* 'b' */ { 66 , new List&lt;int&gt;(){ 86, 70, 71, 72, 78 }}, /* 'n' */ { 78 , new List&lt;int&gt;(){ 66, 71, 72, 74, 77 }}, /* 'm' */ { 77 , new List&lt;int&gt;(){ 78, 72, 74, 75, 188 }}, /* '&lt;' */ { 188 , new List&lt;int&gt;(){ 77, 74, 75, 76, 190 }}, /* '&gt;' */ { 190 , new List&lt;int&gt;(){ 188, 75, 76, 186, 191 }}, /* '?' */ { 191 , new List&lt;int&gt;(){ 190, 76, 186, 222 }}, }; /// &lt;summary&gt; ///     /// &lt;/summary&gt; private static Dictionary&lt;char, int&gt; CodeKeysRus = new Dictionary&lt;char, int&gt; { { '' , 192 }, { '1' , 49 }, { '2' , 50 }, { '3' , 51 }, { '4' , 52 }, { '5' , 53 }, { '6' , 54 }, { '7' , 55 }, { '8' , 56 }, { '9' , 57 }, { '0' , 48 }, { '-' , 189 }, { '=' , 187 }, { '' , 81 }, { '' , 87 }, { '' , 69 }, { '' , 82 }, { '' , 84 }, { '' , 89 }, { '' , 85 }, { '' , 73 }, { '' , 79 }, { '' , 80 }, { '' , 219 }, { '' , 221 }, { '' , 65 }, { '' , 83 }, { '' , 68 }, { '' , 70 }, { '' , 71 }, { '' , 72 }, { '' , 74 }, { '' , 75 }, { '' , 76 }, { '' , 186 }, { '' , 222 }, { '' , 90 }, { '' , 88 }, { '' , 67 }, { '' , 86 }, { '' , 66 }, { '' , 78 }, { '' , 77 }, { '' , 188 }, { '' , 190 }, { '.' , 191 }, { '!' , 49 }, { '"' , 50 }, { '‚Ññ' , 51 }, { ';' , 52 }, { '%' , 53 }, { ':' , 54 }, { '?' , 55 }, { '*' , 56 }, { '(' , 57 }, { ')' , 48 }, { '_' , 189 }, { '+' , 187 }, { ',' , 191 }, }; /// &lt;summary&gt; ///     /// &lt;/summary&gt; private static Dictionary&lt;char, int&gt; CodeKeysEng = new Dictionary&lt;char, int&gt; { { '`', 192 }, { '1', 49 }, { '2', 50 }, { '3', 51 }, { '4', 52 }, { '5', 53 }, { '6', 54 }, { '7', 55 }, { '8', 56 }, { '9', 57 }, { '0', 48 }, { '-', 189 }, { '=', 187 }, { 'q', 81 }, { 'w', 87 }, { 'e', 69 }, { 'r', 82 }, { 't', 84 }, { 'y', 89 }, { 'u', 85 }, { 'i', 73 }, { 'o', 79 }, { 'p', 80 }, { '[', 219 }, { ']', 221 }, { 'a', 65 }, { 's', 83 }, { 'd', 68 }, { 'f', 70 }, { 'g', 71 }, { 'h', 72 }, { 'j', 74 }, { 'k', 75 }, { 'l', 76 }, { ';', 186 }, { '\'', 222 }, { 'z', 90 }, { 'x', 88 }, { 'c', 67 }, { 'v', 86 }, { 'b', 66 }, { 'n', 78 }, { 'm', 77 }, { ',', 188 }, { '.', 190 }, { '/', 191 }, { '~' , 192 }, { '!' , 49 }, { '@' , 50 }, { '#' , 51 }, { '$' , 52 }, { '%' , 53 }, { '^' , 54 }, { '&amp;' , 55 }, { '*' , 56 }, { '(' , 57 }, { ')' , 48 }, { '_' , 189 }, { '+' , 187 }, { '{', 219 }, { '}', 221 }, { ':', 186 }, { '"', 222 }, { '&lt;', 188 }, { '&gt;', 190 }, { '?', 191 }, }; #endregion #region   /// &lt;summary&gt; ///   =&gt; ASCII (ISO 9-95) /// &lt;/summary&gt; private static Dictionary&lt;char, string&gt; Translit_Ru_En = new Dictionary&lt;char, string&gt; { { '', "a" }, { '', "b" }, { '', "v" }, { '', "g" }, { '', "d" }, { '', "e" }, { '', "yo" }, { '', "zh" }, { '', "z" }, { '', "i" }, { '', "i" }, { '', "k" }, { '', "l" }, { '', "m" }, { '', "n" }, { '', "o" }, { '', "p" }, { '', "r" }, { '', "s" }, { '', "t" }, { '', "u" }, { '', "f" }, { '', "x" }, { '', "c" }, { '', "ch" }, { '', "sh" }, { '', "shh" }, { '', "" }, { '', "y" }, { '', "'" }, { '', "e" }, { '', "yu" }, { '', "ya" }, }; #endregion }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vitaly Alferov, 2017 </font></font></div><p>Source: <a href="https://habr.com/ru/post/331174/">https://habr.com/ru/post/331174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331162/index.html">‚ÄúMy most important test is not to break the driver‚Äù - Dave Cramer about developing a JDBC driver for PostgreSQL</a></li>
<li><a href="../331164/index.html">Draw thick lines in WebGL</a></li>
<li><a href="../331166/index.html">About Qt licenses (and a little about the company)</a></li>
<li><a href="../331168/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ267 (June 12 - 18, 2017)</a></li>
<li><a href="../331170/index.html">How to do static code analysis in Swift</a></li>
<li><a href="../331176/index.html">Interactive credit card for payment input</a></li>
<li><a href="../331178/index.html">How to keep 20 thousand VPN clients on servers for $ 5</a></li>
<li><a href="../331180/index.html">Cloud security: reality or myth?</a></li>
<li><a href="../331182/index.html">The first selection of materials on the digitalization of insurance</a></li>
<li><a href="../331184/index.html">Entertaining layout with viewing area units</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>