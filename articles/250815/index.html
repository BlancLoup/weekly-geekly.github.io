<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free data structures. Concurrent maps: skip list</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In previous articles ( one , two ), we considered the classic hash map with a hash table and a list of collisions. A lock-free ordered list was built,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free data structures. Concurrent maps: skip list</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/8c7/b2e/0af/8c7b2e0afb03482f937552ced9015c43.png" align="right"><br>  In previous articles ( <a href="http://habrahabr.ru/post/250383/">one</a> , <a href="http://habrahabr.ru/post/250523/">two</a> ), we considered the classic hash map with a hash table and a list of collisions.  A lock-free ordered list was built, which served as the basis for the lock-free hash map. <br>  Unfortunately, the lists are characterized by the linear complexity of the search for <code>O(N)</code> , where <code>N</code> is the number of elements in the list, so our lock-free ordered list algorithm itself is of little interest for large <code>N</code> <br>  Or does it represent? .. <br><a name="habracut"></a><br>  There is a rather curious data structure - <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA_%25D1%2581_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25BF%25D1%2583%25D1%2581%25D0%25BA%25D0%25B0%25D0%25BC%25D0%25B8">skip-list</a> , based on a simple, simply-connected list.  It was first described in 1990 by W.Pugh, the translation of his original article <a href="http://habrahabr.ru/post/230413/">is</a> in Habr√©.  This structure is of interest to us, since, having the lock-free ordered list algorithm, it is quite easy to implement a lock-free skip-list. <br>  To begin with - a little about the principles of building a skip-list.  A skip-list is a multi-level list: each element (sometimes called a tower) has a certain height <code>h</code> . <br><img src="https://habrastorage.org/files/8db/c03/c8d/8dbc03c8de784d9298fa1d0e6cd4968d.png"><br>  Height <code>h</code> is chosen randomly from the range <code>[1, Hmax]</code> , where <code>Hmax</code> is the maximum possible height, usually 16 or 32. The probability that the height of the tower is one is <code>P[h == 1] = 1/2</code> .  The probability of height <code>k</code> is: <br><img src="https://habrastorage.org/files/043/43b/ec8/04343bec8f304a4385e169832068b333.png"><br>  Despite the seeming difficulty of calculating the height, it can be calculated quite simply, for example, like this: <code>h = lsb( rand() )</code> , where <code>lsb</code> is the number of the least significant bit of the number. <br><div class="spoiler">  <b class="spoiler_title">Magic 1/2</b> <div class="spoiler_text">  In fact, the constant <code>1/2</code> is my simplification, the original article deals with <code>0 &lt; p &lt; 1</code> and explores the behavior of the skip-list for various values ‚Äã‚Äãof <code>p</code> .  But for practical implementation, <code>p = 1/2</code> is the best value, I think. <br></div></div><br>  It turns out that the greater the level, the more the list at this level is sparse compared to the lower ones.  This rarefaction, along with probabilistic nature, gives an estimate of the complexity of the search for <code>O(log N)</code> , the same as for binary self-balancing trees. <br>  Skip-list search is quite simple: starting from the head tower, which has a maximum height, we go through the highest level until we find an element with a key larger than the desired one (or do not lean into the tail tail), go down to the level below, look for similarly in it, etc., until we get to level 0, the lowest;  key search example 34: <br><img src="https://habrastorage.org/files/b28/85a/101/b2885a101afe42688d477063144c6fbf.png"><br><br><h2>  Lock-free skip list </h2><br>  To build a lock-free skip-list, we already have a lock-free algorithm for each level.  It remains to develop methods of working with levels.  It would seem impossible to atomically insert a node-tower with a height of, say, 20, because for this you need to <i>atomically</i> change 20 pointers!  It turns out that this is not necessary, it is enough to be able to atomically change <i>one</i> pointer, - what we already know how to do in the lock-free list. <br>  Consider how the insertion in the lock-free skip-list.  We will insert an element-tower with a height of 5 with a key of 23. The first stage we look for the position of the insert, moving through the levels from top to bottom.  As a result, we have an array of <code>prev[]</code> insertion positions at each level: <br><img src="https://habrastorage.org/files/0a1/aac/e6e/0a1aace6ed9a42b0a3ee3b68c45ceef2.png"><br>  Next, insert a new element at level 0, the lowest.  We can do the insert in the lock-free list: <br><img src="https://habrastorage.org/files/ad4/3a0/ba3/ad43a0ba3fae43da8119df1cdccd3d35.png"><br>  Everything - the element becomes part of the list, it can be found, it becomes <i>attainable</i> , despite the fact that the entire tower has not yet been completely inserted into the skip-list. <br>  Next, we <s>slowly</s> insert our tower into the levels above, from the bottom up: <br><img src="https://habrastorage.org/files/a53/4d6/83c/a534d683ccf245febadea4955bf74371.png"><br>  These inserts are of secondary importance, they are designed to increase the efficiency of the search, but in no way affect the attainability of the new key. <br>  Deleting an element occurs in two phases: first, we find the element to be deleted and mark it as logically deleted using the marked pointer technique.  The difficulty is that for the tower we have to mark all levels of the element, starting from the highest: <br><img src="https://habrastorage.org/files/ac4/65c/493/ac465c493b1644f4a188eba2d497172d.png"><br>  After all levels of the tower element are marked, a physical deletion is made (more precisely, the exclusion of an element from the list, since the memory is deleted under the element by Hazard Pointer or RCU), also from top to bottom: <br><img src="https://habrastorage.org/files/b4c/d98/6d8/b4cd986d8fe04c8cb75d492eac04126b.png"><br>  At each level, an algorithm is used to insert / remove from the usual lock-free ordered list, which we have already considered. <br><br>  As you can see, the insertion / deletion procedures from the lock-free skip-list are multi-step, at each step interference with competing operations is possible, therefore, when programming the skip-list, special care is needed.  For example, when inserting, we first look for positions in lists at all levels and form arrays of <code>prev[]</code> .  It is possible that in the process of inserting the list at some level will change and these positions will become invalid.  In this case, you should update <code>prev[]</code> , that is, find the inserted element, and continue the insertion, starting from the level at which the bummer occurred. <br>  More interesting is the situation when the simultaneous insertion of the key <code>K</code> and its removal occurs.  This is quite possible: the insertion is considered successful when we have linked the item at level 0 of the list.  After that, the element is already reachable and it is quite possible to remove it, despite the fact that it is not fully inserted into the upper levels.  To resolve insertion and deletion collisions, the order is very important: the insertion is done from the bottom up, and the deletion (more precisely, its first phase is a logical removal, marked pointer) - counter-flow, from the top down.  In this case, the insertion procedure is sure to see at any level a deletion flag and immediately stop its work. <br>  The removal procedure can also be competitive in both of its phases.  In the phase of logical deletion, when tags are put on the tower from top to bottom, we are not afraid of competition.  But in the phase of excluding a deleted item from the lists, any change in the skip-list, that is, breaking the <code>prev[]</code> and <code>found[]</code> arrays, which determine the position of the deleted item, leads to the fact that we need to re-create these arrays.  But the labels are already marked and the search function simply will not find the item to be deleted!  To resolve this situation, we endow the search function with an unusual job: if it finds an element marked at any level, the search function eliminates (unlink) this element from the list of this level, that is, it helps to remove elements.  After exclusion, the function resumes the search from the very beginning, that is, from the top level (variations are possible here, but the simplest thing is to start from the beginning).  This is a typical example of mutual help, often found in lock-free programming: one thread helps another to do its work.  That is why the <code>find()</code> function in many lock-free containers is not constant - a search can change the container. <br>  What else is characterized by skip-list?  First, it is an <i>ordered</i> map, unlike a hash map, that is, it supports extracting the minimum <code>extract_min()</code> and maximum <code>extract_max()</code> keys. <br>  Secondly, the skip-list is gluttonous for the Hazard Pointrer (HP) scheme: with a maximum tower height of 32 elements of the arrays of <code>prev[]</code> and <code>found[]</code> , which determine the desired position, should be protected by hazard pointers, that is, we need at least 64 hazard pointer'a (in fact, in the implementation of libcds - 66).  This is quite a lot for the HP circuit, see <a href="http://habrahabr.ru/company/ifree/blog/202190/">its device</a> for details.  For the <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> scheme, the implementation of the <code>find()</code> method presents some complexity, since this method can remove elements, and the RCU scheme requires that the <s>deletion of an</s> exception (unlink) of an element from the list be under the critical section of the RCU, and the <s>removal of the</s> memory allocation is outside the critical section, otherwise deadlock is possible. <br>  An interesting practical task is the implementation of towers for a height of more than 1. Now in the implementation of the skip-list in the library <a href="https://github.com/khizmax/libcds">libcds, the</a> memory for towers with a height of more than 1 is distributed separately from the memory for the element even for the intrusive variant.  Considering the probabilistic nature of the height, it turns out that for 50% of the elements memory allocation is done, this can affect performance, and also negatively affects memory fragmentation.  There is an idea of ‚Äã‚Äãa tower with a height of no more than <code>h_min</code> distributed by one block and only for the high ones ‚Äúto distribute‚Äù the memory under the tower: <br><pre> <code class="hljs swift">template &lt;size_t <span class="hljs-type"><span class="hljs-type">Hmin</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tower</span></span></span><span class="hljs-class"> </span></span>{ tower * next[<span class="hljs-type"><span class="hljs-type">Hmin</span></span>]; tower * high_next; <span class="hljs-comment"><span class="hljs-comment">//     &gt;= Hmin };</span></span></code> </pre><br>  If <code>Hmin = 4</code> , then with this construction, 93% of the elements will not require the allocation of additional memory for <code>next</code> - <code>high_next</code> to be <code>nullptr</code> . <br><div class="spoiler">  <b class="spoiler_title">skip-list: bibliography</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/4f9/d0d/62e/4f9d0d62ede7420d89781f216a220c0a.png" align="right"><br>  W.Pugh, a year or two after the publication of his work on the skip-list, presented another work on competitive implementation based on accurate locking (fine-grained locks). <br>  The most cited work on the lock-free skip-list is the 2003 K.Fraser <a href="http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Practical lock-freedom</a> dissertation, which presents several skip-list algorithms both on the basis of transactional memory and on the MCAS software implementation (CAS over several memory cells) .  This work is now, in my opinion, purely theoretical interest, since the software emulation of transactional memory is quite difficult, as well as MCAS.  Although with the release of Haswell implementation of transactional memory in the iron went to the masses ... <br>  The implementation of the skip-list in libcds is based on the monograph <a href="http://www.amazon.com/The-Multiprocessor-Programming-Revised-Reprint/dp/0123973376">The Art of Multiprocessor Programming, which</a> I have repeatedly cited.  ‚ÄúOn motives‚Äù because the original algorithm is given for Java and has, it seems to me, several errors, which, perhaps, were corrected in the second edition.  Or it is not a bug for Java at all. <br>  There is also <a href="http://www.cse.yorku.ca/~ruppert/Mikhail.pdf">Fomichev‚Äôs dissertation</a> , devoted to the question of resuming the search in the event of detected conflicts in the skip-list.  As I mentioned above, <code>find()</code> when it detects a marked (marked) element, tries to remove it from the list and <i>resumes searching from the very beginning</i> .  Fomichev proposes a mechanism for arranging back-reference back links to resume work from some previous element rather than from the beginning, which, in principle, should affect the performance for the better.  The back-reference support algorithm in the current state is quite complex and it is unclear whether the gain will be made or whether the code supporting the relevance will eat it. <br></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the next article we will try to consider another extensive class of data structures that are the basis for associative containers ‚Äî trees, or more precisely, their competitive implementation. <br><div class="spoiler">  <b class="spoiler_title">Lock-free data structures</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/company/ifree/blog/195770/">Start</a> <br>  Basics: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/195948/">Atomicity and atomic primitives</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/196548/">Where did the memory barriers go from</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/197520/">Memory model</a> </li></ul><br>  Inside: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/202190/">Memory management circuits</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/216013/">Stack evolution</a> </li><li>  <a href="http://habrahabr.ru/company/ifree/blog/219201/">Another treatise</a> </li><li>  <a href="http://habrahabr.ru/post/230349/">Queue dissection</a> </li><li>  <a href="http://habrahabr.ru/post/250383/">Concurrent maps: warm up</a> </li><li>  <a href="http://habrahabr.ru/post/250523/">Concurrent maps: rehash, no rebuild</a> </li><li>  <a href="http://habrahabr.ru/post/250815/">Concurrent maps: skip list</a> </li><li>  <a href="https://habrahabr.ru/post/251267/">Concurent maps: trees</a> </li><li>  <a href="https://habrahabr.ru/post/314948/">Iterators: multi-level array</a> </li><li>  <a href="https://habrahabr.ru/post/317882/">Iterable list</a> </li></ul><br>  Outside: <br><ul><li>  <a href="http://habrahabr.ru/company/ifree/blog/196834/">Introduction to libcds</a> </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/250815/">https://habr.com/ru/post/250815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250803/index.html">Centralized logs for applications using heka + elasticsearch + kibana</a></li>
<li><a href="../250807/index.html">Visual brute force on the example of solving a 3D puzzle</a></li>
<li><a href="../250809/index.html">Using an alternative memory allocator in a C / C ++ project</a></li>
<li><a href="../250811/index.html">Apache Spark Introduction</a></li>
<li><a href="../250813/index.html">Spatial positioning system for aviation (using FPGA)</a></li>
<li><a href="../250817/index.html">The mathematical problem of 100 boxes and the rescue of prisoners</a></li>
<li><a href="../250819/index.html">Black Swift - at Embedded World Conference</a></li>
<li><a href="../250821/index.html">The quality of data networks. Software and hardware measurements</a></li>
<li><a href="../250823/index.html">Pebble: accelerometer, example of use</a></li>
<li><a href="../250825/index.html">Web technologies through the eyes of a C ++ programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>