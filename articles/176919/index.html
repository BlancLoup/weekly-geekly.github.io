<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a custom component from scratch. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 Greetings again, colleagues. 

 In my previous article, I talked about the basics of creating a custom component using the example of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a custom component from scratch. Part 2</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br><br>  Greetings again, colleagues. <br><br>  In my <a href="http://habrahabr.ru/post/176643/">previous</a> article, I talked about the basics of creating a custom component using the example of a simple but nice piano keyboard. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/888/cee/dcd/888ceedcd36a37fa40d45e2f44a8f85b.png"><br><br>  In this article, under the cut, we will continue to wind the <s>whistles and ...</s> additional features of our keyboard.  On the agenda: <br><br><ol><li>  Preserving component state when rotating screen </li><li>  adding backlight in overscroll </li><li>  XML parameter passing </li><li>  Multitouch Zoom </li></ol><a name="habracut"></a><br><br><h4>  Preserving component state when rotating screen </h4><br>  Now we can detect this behavior in our component.  If we scroll to any position, then rotate the screen, the scroll will be at zero.  Obviously, this is because when the screen is rotated, the Activity is recreated, respectively, the View is also recreated. <br>  The first thing that comes to mind is to use the <code>onSaveInstanceState()</code> method of our activation, pull the value of the scroll from the component and save, and later, when you re-create, set the scroll to our component.  And it will work, but it can hardly be called the right approach.  Imagine that we have not one parameter to be saved, but ten, or not one component, but ten ... with ten parameters. <br>  Fortunately, the internal mechanisms of Android already provide for the automatic saving of the state of all components that have an identifier.  After all, you don‚Äôt need to do anything to keep the Listroll scrolling around when you turn, right?  So we will take advantage of what is already in View and will manage the preservation of the state of the component from the inside, not from the outside. <br>  And this is done surprisingly simple.  We need to override the methods of the View <code>onSaveInstanceState()</code> class and <code>onRestoreInstanceState(Parcelable state)</code> .  However, there is a small difference from the analogues in the activation.  There we deal with the <code>Bundle</code> , here we have Parcelable.  We need to make our own Parcelable class, which must be derived from <code>android.view.View.BaseSavedState</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SavedState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseSavedState</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xOffset; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> instrumentWidth; <span class="hljs-comment"><span class="hljs-comment">//          :) SavedState(Parcelable superState) { super(superState); } @Override public void writeToParcel(Parcel out, int flags) { super.writeToParcel(out, flags); out.writeInt(xOffset); out.writeInt(instrumentWidth); } public static final Parcelable.Creator&lt;SavedState&gt; CREATOR = new Parcelable.Creator&lt;SavedState&gt;() { public SavedState createFromParcel(Parcel in) { return new SavedState(in); } public SavedState[] newArray(int size) { return new SavedState[size]; } }; private SavedState(Parcel in) { super(in); xOffset = in.readInt(); instrumentWidth = in.readInt(); } }</span></span></code> </pre><br><br>  This is how it looks in our case.  Now it only remains to use it: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Parcelable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSaveInstanceState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SavedState st = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SavedState(<span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onSaveInstanceState()); st.xOffset = xOffset; st.instrumentWidth = xOffset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> st; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRestoreInstanceState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Parcelable state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(state <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> SavedState)) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onRestoreInstanceState(state); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } SavedState ss = (SavedState) state; <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onRestoreInstanceState(ss.getSuperState()); xOffset = ss.xOffset; xOffset = ss.instrumentWidth; };</code> </pre><br><br>  Is done.  If you now rotate the screen, the scroll will not be lost.  But there is another little cosmetic detail that I would add.  In our component, when turning, there is a high probability that the width of the keyboard will change, as we change its height (less in landscape mode), the keys will become narrower or wider.  Therefore, our static xOffset value loaded after re-creation needs to be adjusted.  This is done very simply.  First, we will keep the old width of our keyboard when recreating.  That is why in the code above I also save the instrumentWidth field in our SavedState. <br>  In our onDraw (), where we initialize the component after resizing it, we will add the following modifications: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (measurementChanged) { measurementChanged = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; keyboard.initializeInstrument(getMeasuredHeight(), getContext()); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> oldInstrumentWidth = instrumentWidth; instrumentWidth = keyboard.getWidth(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ratio = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) instrumentWidth / oldInstrumentWidth; <span class="hljs-comment"><span class="hljs-comment">//          xOffset = (int) (xOffset * ratio); }</span></span></code> </pre><br><br>  Now if our scroll before the turn was, for example, at the beginning of the second octave, it will remain there after the turn. <br>  So, we successfully save the state of our component when turning.  Now let's add another visual beauty, namely the effect of glow on the sides when the scroll reaches the end of the tool. <br><br><h4>  Glow effect for overscroll </h4><br>  As one would expect, a ready-made component has already been made for us, which is able to draw these very edges correctly, but we need to insert it correctly and voila.  This component is called <a href="http://developer.android.com/reference/android/widget/EdgeEffect.html">EdgeEffect</a> .  But we will not use it, since it appeared only in ICS.  We will use the <a href="https://developer.android.com/reference/android/support/v4/widget/EdgeEffectCompat.html">EdgeEffectCompat</a> class, which is accessible by the compatibility library and is a wrapper over EdgeEffect.  Unfortunately, this means that in versions where the effect is not supported, this class will serve as a simple stub and nothing will happen. <br>  So, we need two copies - for the left and right edges. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EdgeEffectCompat leftEdgeEffect; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EdgeEffectCompat rightEdgeEffect;</code> </pre><br><br>  They are initialized in a simple way in the activity. <br><br>  Now, draw.  Like the scrollbars, the effect is drawn on top of all the content, so it makes sense to put it in the draw () method.  Here I honestly admit that what goes further is done by analogy with the way it is implemented in the ViewPager class.  In general, we can draw an effect with on exactly the same result in onDraw, but, in general, this is in my opinion even more beautiful, because in onDraw we draw our own, in draw - system effects. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.draw(canvas); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> needsInvalidate = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> overScrollMode = ViewCompat.getOverScrollMode(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (overScrollMode == ViewCompat.OVER_SCROLL_ALWAYS || (overScrollMode == ViewCompat.OVER_SCROLL_IF_CONTENT_SCROLLS)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!leftEdgeEffect.isFinished()) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> restoreCount = canvas.save(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = getHeight() - getPaddingTop() - getPaddingBottom(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = getWidth(); canvas.rotate(<span class="hljs-number"><span class="hljs-number">270</span></span>); canvas.translate(-height + getPaddingTop(), <span class="hljs-number"><span class="hljs-number">0</span></span>); leftEdgeEffect.setSize(height, width); needsInvalidate |= leftEdgeEffect.draw(canvas); canvas.restoreToCount(restoreCount); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rightEdgeEffect.isFinished()) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> restoreCount = canvas.save(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = getWidth(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = getHeight() - getPaddingTop() - getPaddingBottom(); canvas.rotate(<span class="hljs-number"><span class="hljs-number">90</span></span>); canvas.translate(-getPaddingTop(), -width); rightEdgeEffect.setSize(height, width); needsInvalidate |= rightEdgeEffect.draw(canvas); canvas.restoreToCount(restoreCount); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { leftEdgeEffect.finish(); rightEdgeEffect.finish(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needsInvalidate) { ViewCompat.postInvalidateOnAnimation(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre><br><br>  So what happens here.  First, we check if our component supports an overscroll, and, if so, draw both effects in succession.  The fact is that EdgeEffect does not support the direction in which it is drawn, so in order to correctly display the effect on the left or right, we need to rotate our canvas in the right way. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!leftEdgeEffect.isFinished()) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> restoreCount = canvas.save(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = getHeight() - getPaddingTop() - getPaddingBottom(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = getWidth(); canvas.rotate(<span class="hljs-number"><span class="hljs-number">270</span></span>); canvas.translate(-height + getPaddingTop(), <span class="hljs-number"><span class="hljs-number">0</span></span>); leftEdgeEffect.setSize(height, width); needsInvalidate |= leftEdgeEffect.draw(canvas); canvas.restoreToCount(restoreCount); }</code> </pre><br><br>  Here we are consistently: <br><ol><li>  Save the canvas using canvas.save () </li><li>  we calculate its height minus paddings and set the size of the effect using the leftEdgeEffect.setSize (height, width) method; </li><li>  Rotate the canvas 270 degrees and position it correctly. </li></ol><br><br>  I want to present it more clearly.  Let's remove the canvas transformations: <br><br><img src="https://habrastorage.org/storage2/032/e7d/f28/032e7df2872403cc1205aba94bb04649.png"><br><br>  This is what the default effect looks like.  Always down.  If we add only a rotation of 270, we will see that the effect is drawn in the right direction, but at the very top corner of the canvas. <br><br><img src="https://habrastorage.org/storage2/641/44a/90e/64144a90ec6a3e764fd39451a7575165.png"><br><br>  And only after adding the displacement of the canvas, we see that the effect is in place. <br><br><img src="https://habrastorage.org/storage2/8d6/469/9ec/8d64699ec802cfdd3149d55da707b51b.png"><br><br>  But I ran ahead, because while we have the effect, though drawn, but it does not activate when scrolling. <br>  Here we need to go back to our gesture detector and modify onScroll. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MotionEvent e1, MotionEvent e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distanceX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distanceY)</span></span></span><span class="hljs-function"> </span></span>{ resetTouchFeedback(); xOffset += distanceX; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xOffset &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { leftEdgeEffect.onPull(distanceX / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) getMeasuredWidth()); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xOffset &gt; instrumentWidth - getMeasuredWidth()) { rightEdgeEffect.onPull(distanceX / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) getMeasuredWidth()); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!awakenScrollBars()) { invalidate(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br><br>  First, we stopped limiting xOffset to bounds, as we did before, plus we call the onPull method for the corresponding effect. <br>  It is important to note here that since we stopped limiting the xOffset variable here, we need to do it in other places where it can cause an error, for example in the onDraw method and computeHorizontalScrollOffset ().  Perhaps there is a more beautiful way to do this, but he has not yet come to my mind. <br>  The final touch we want to add is the scroll speed absorption when our edge reaches the edge.  To do this, add the following code to our <code>onDraw</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scroller.isOverScrolled()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xOffset &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { leftEdgeEffect.onAbsorb(getCurrentVelocity()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rightEdgeEffect.onAbsorb(getCurrentVelocity()); } } <span class="hljs-comment"><span class="hljs-comment">// ... @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) private int getCurrentVelocity() { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) { return (int) scroller.getCurrVelocity(); } return 0; }</span></span></code> </pre><br><br>  Unfortunately, the <code>Scroller.getCurrVelocity()</code> method is available to us only starting from ICS, so I marked the method as aimed at API 14+.  Yes, this is far from ideal, but, again, this is what we have. <br>  Now, when trying to scroll beyond View, we get a beautiful glow in the style of Holo. <br><br><h4>  Add component parameters to XML </h4><br><br>  Before proceeding directly to adding parameters, I will add a small feature to our component.  Suppose that when you click on the key, we will see a circle with the name of this note. <br>  This is done trivially.  I started an array of Note objects. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ArrayList&lt;Note&gt; notesToDraw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Note&gt;();</code> </pre><br><br>  and each time I click on the key, I define a note by the midi code of the key and add it to the array.  In detail how this happens can be seen in the code on the githaba. <br><br>  Now in the Keyboard class, I add the method drawOverlays (ArrayList) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawOverlays</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayList&lt;Note&gt; notes, Canvas canvas)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstVisibleKey = getFirstVisibleKey(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastVisibleKey = getLastVisibleKey(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Note note : notes) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> midiCode = note.getMidiCode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (midiCode &gt;= firstVisibleKey &amp;&amp; midiCode &lt;= lastVisibleKey) { drawNoteFromMidi(canvas, note, midiCode, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawNoteFromMidi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Canvas canvas, Note note, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> midiCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> replica)</span></span></span><span class="hljs-function"> </span></span>{ Key key = keysArray[midiCode - Keyboard.START_MIDI_CODE]; overlayTextPaint.setColor(circleColor); canvas.drawCircle(key.getOverlayPivotX(), key.getOverlayPivotY(), overlayCircleRadius, overlayTextPaint); String name = note.toString(); overlayTextPaint.getTextBounds(name, <span class="hljs-number"><span class="hljs-number">0</span></span>, name.length(), bounds); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = bounds.right - bounds.left; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = bounds.bottom - bounds.top; overlayTextPaint.setColor(Color.BLACK); canvas.drawText(name, key.getOverlayPivotX() - width / <span class="hljs-number"><span class="hljs-number">2</span></span>, key.getOverlayPivotY() + height / <span class="hljs-number"><span class="hljs-number">2</span></span>, overlayTextPaint); }</code> </pre><br><br>  ... and draw a note as a circle and text.  As you probably already guessed, I did it so that we could customize the parameters of this circle and text via XML. <br><br>  Let's customize the color, circle radius, and text size in the XML attributes of our View.  First you need to announce them.  The &lt;declare-styleable&gt; tag is used for this. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">declare-styleable</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"PianoView"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"overlay_color"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">format</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"color"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"overlay_circle_radius"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">format</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dimension"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"overlay_circle_text_size"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">format</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dimension"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">attr</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">declare-styleable</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  add this definition to attrs.xml.  Now, we need to load them in our component.  In the constructor, add the following code <br><br><pre> <code class="java hljs">TypedArray pianoAttrs = context.obtainStyledAttributes(attrs, R.styleable.PianoView); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> circleColor; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> circleRadius; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> circleTextSize; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { circleColor = pianoAttrs.getColor(R.styleable.PianoView_overlay_color, Color.GREEN); circleRadius = pianoAttrs.getDimension(R.styleable.PianoView_overlay_circle_radius, TypedValue .applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="hljs-number"><span class="hljs-number">24</span></span>, context.getResources().getDisplayMetrics())); circleTextSize = pianoAttrs.getDimension(R.styleable.PianoView_overlay_circle_text_size, TypedValue .applyDimension(TypedValue.COMPLEX_UNIT_SP, <span class="hljs-number"><span class="hljs-number">12</span></span>, context.getResources().getDisplayMetrics())); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { pianoAttrs.recycle(); }</code> </pre><br><br>  using the getXXX method, we get the value of the attribute type XXX.  If the attribute is missing, the second argument specifies the default value. <br><br>  It remains now to indicate them in our markup.  To do this, you first need to declare a namespace in the header: <code>xmlns:piano="http://schemas.android.com/apk/res-auto"</code> , after which we get the following markup file: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RelativeLayout</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:piano</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:tools</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/tools"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tools:context</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".PianoDemoActivity"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">com.evilduck.piano.views.instrument.PianoView</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@+id/instrument_view"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"300dip"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">piano:overlay_circle_radius</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"18dip"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">piano:overlay_circle_text_size</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"18sp"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">piano:overlay_color</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#00FF00"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RelativeLayout</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  In this way, we can make our components as flexible as the standard components of the platform. <br><br><h4>  Multi-touch support </h4><br>  The last thing I wanted to talk about today is basic zoom support with a multitouch gesture. <br>  To create the zoom effect, we will use the <a href="https://developer.android.com/reference/android/view/ScaleGestureDetector.html">ScaleGestureDetector</a> component.  It is absolutely analogous to the GestureDetector in terms of use in the code, it differs, only the listener passed to it: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OnScaleGestureListener scaleGestureListener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OnScaleGestureListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScaleEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ScaleGestureDetector detector)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScaleBegin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ScaleGestureDetector detector)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ScaleGestureDetector detector)</span></span></span><span class="hljs-function"> </span></span>{ scaleX *= detector.getScaleFactor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scaleX &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { scaleX = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scaleX &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { scaleX = <span class="hljs-number"><span class="hljs-number">2</span></span>; } ViewCompat.postInvalidateOnAnimation(PianoView.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } };</code> </pre><br><br>  we introduced the scaleX variable, which will express the level of our zoom and limit it to 1 and 2. <br>  Another question is how we will zoom our keyboard.  For this article, I chose the simplest option - just convert the canvas.  Yes, it is not perfect, and will lead to a distortion of the picture.  That's right - based on the scaleX value, increase the width of the keys, the radius of the circles and the text.  This is specific to my task and is not related to the zoom as a whole.  Therefore, we simply scale the canvas: <br><br><pre> <code class="java hljs">canvas.save(); <span class="hljs-comment"><span class="hljs-comment">//    canvas.scale(scaleX, 1.0f); canvas.translate(-localXOffset, 0); keyboard.updateBounds(localXOffset, canvasWidth + localXOffset); keyboard.draw(canvas); if (!notesToDraw.isEmpty()) { keyboard.drawOverlays(notesToDraw, canvas); } canvas.restore();</span></span></code> </pre><br><br>  Done, if you make a pushing gesture with your fingers, we will see how the keyboard grows wide: <br><br><img src="http://habrastorage.org/storage2/417/6c6/3ad/4176c63ada7a5001ca41910ae0bb0b81.png"><br><br><h4>  Conclusion </h4><br>  This is the end of the second part of my series of articles.  I hope that this will help someone quickly understand the intricacies of creating custom components and improve the quality of their projects. <br>  The finished example is still available on my github: <a href="http://goo.gl/VDeuw">goo.gl/VDeuw</a> . <br>  Also, I strongly recommend that you read this article from the official documentation: <br>  <a href="http://developer.android.com/training/gestures/index.html">developer.android.com/training/gestures/index.html</a> <br>  In the third article I will try to highlight the issues of optimization, the use of bitmaps instead of programmatically drawing text, circles, consider what pixel redrawing occurs in our component, and how you can get rid of them. </div><p>Source: <a href="https://habr.com/ru/post/176919/">https://habr.com/ru/post/176919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../176901/index.html">Trainings Nokia Developers Workshop in Russia</a></li>
<li><a href="../176909/index.html">Autoprefixer - the ultimate solution to the prefix problem in CSS</a></li>
<li><a href="../176911/index.html">We return privacy or big brother watching me on the standard settings. Part 3. We set up Facebook and VKontakte</a></li>
<li><a href="../176913/index.html">Highlights for upcoming US immigration reform</a></li>
<li><a href="../176915/index.html">Lexicon and pirates</a></li>
<li><a href="../176927/index.html">Best Practices for Backup Policy</a></li>
<li><a href="../176931/index.html">Speed ‚Äã‚ÄãFirefox</a></li>
<li><a href="../176933/index.html">Android NDK: OpenSL ES</a></li>
<li><a href="../176935/index.html">Tunnel modeling v0.1 - pseudocode</a></li>
<li><a href="../176937/index.html">The second life of payphones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>