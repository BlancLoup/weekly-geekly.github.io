<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Utilize Groovy DSL features for configuring Java applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prehistory 


 Hello! I would like to tell the story of the terrible configs and how they managed to comb and make sane. I am working on a rather larg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Utilize Groovy DSL features for configuring Java applications</h1><div class="post__text post__text-html js-mediator-article"><h2 id="predystoriya">  Prehistory </h2><br><p>  Hello!  I would like to tell the story of the terrible configs and how they managed to comb and make sane.  I am working on a rather large and relatively old project that is constantly finishing and growing.  The configuration is set using mapping xml-files to java-bins.  Not the best solution, but it has its advantages - for example, when creating a service, you can transfer a bin with the configuration responsible for its section to it.  However, there are downsides.  The most significant of them is that there is no normal inheritance of configuration profiles.  At some point, I realized that in order to change one setting, I had to edit about 30 xml files, one for each of the profiles.  This could not continue any longer, and a willful decision was made to rewrite everything. </p><br><h2 id="trebovaniya">  Requirements </h2><br><ul><li>  Inheritance and redefinition (or fallback).  It should be possible to set a certain basic profile, inherit from it the children and redefine or add to them the places that are necessary </li><li> Mapping in java-bins.  I didn‚Äôt want to rewrite the use of the configuration from bins to the mongodb.directory.host type for the whole project, use maps from map too. </li><li>  Ability to write comments in the config.  Not critical, but comfortable and pleasant. </li></ul><br><p>  I would like the config to look like this: </p><br><div class="spoiler">  <b class="spoiler_title">Typical DSL script on groovy</b> <div class="spoiler_text"><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">name</span></span> = <span class="hljs-string"><span class="hljs-string">"MyTest"</span></span> description = <span class="hljs-string"><span class="hljs-string">"Apache Tomcat"</span></span> http { <span class="hljs-attribute"><span class="hljs-attribute">port</span></span> = <span class="hljs-number"><span class="hljs-number">80</span></span> secure = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } https { <span class="hljs-attribute"><span class="hljs-attribute">port</span></span> = <span class="hljs-number"><span class="hljs-number">443</span></span> secure = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } mappings = [ { <span class="hljs-attribute"><span class="hljs-attribute">url</span></span> = <span class="hljs-string"><span class="hljs-string">"/"</span></span> active = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, { <span class="hljs-attribute"><span class="hljs-attribute">url</span></span> = <span class="hljs-string"><span class="hljs-string">"/login"</span></span> active = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ]</code> </pre> </div></div><br><p>  As I achieved it - under a cat. <a name="habracut"></a></p><br><h2 id="mozhet-dlya-etogo-uzhe-est-biblioteka">  Maybe for this there is already a library? </h2><br><p>  Probably yes.  However, from those that I found and looked, nothing came up to me.  Most of them are designed for reading configs, merging them into one large one and then working with the received config via separate properties.  Almost no one knows how to mapping bins, and it is too long to write dozens of converters for converters.  The most promising seemed to be the <a href="https://github.com/lightbend/config">lightbend config</a> , with its nice HOCON format and inheritance / redefinition out of the box.  And she was almost able to fill in a java-bin, but as it turned out, she doesn‚Äôt know how to map and expands very poorly.  While I was experimenting with it, a colleague looked at the resulting configs and said: ‚ÄúThis is somewhat similar to Groovy DSL‚Äù.  So it was decided to use it. </p><br><h2 id="chto-eto-takoe">  What it is? </h2><br><p>  DSL (domain-specific language, domain-specific language) is a language "sharpened" for a specific scope, in our case - for the configuration of our particular application.  An example can be seen in the spoiler before the cut. </p><br><p>  Running groovy scripts from a java application is easy.  You just need to add groovy depending, for example, Gradle </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'org.codehaus.groovy:groovy-all:2.3.11'</span></span></code> </pre> <br><p>  and use GroovyShell </p><br><pre> <code class="java hljs"> GroovyShell shell = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroovyShell(); Object value = shell.evaluate(pathToScript);</code> </pre> <br><h2 id="kak-eto-rabotaet">  How it works? </h2><br><p>  All magic is based on two things. </p><br><h3 id="delegirovanie">  Delegation </h3><br><p>  To begin with, the groovy script is compiled into bytecode, a class is created for it, and when the script is run, the run () method of this class is called, containing all the script code.  If the script returns some value, then we can get it as the result of <code>evaluate()</code> .  In principle, it would be possible in the script to create our beans with the configuration and return them, but in this case we will not get a nice syntax. </p><br><p>  Instead, we can create a script of a special type - <a href="http://docs.groovy-lang.org/latest/html/api/groovy/util/DelegatingScript.html">DelegatingScript</a> .  Its peculiarity is that it can pass a delegate object to it, and all calls to methods and work with fields will be delegated to it.  The documentation for the link is an example of use. <br>  Let's create a class that will contain our config </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyObjectSupport</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String description; }</code> </pre> <br><p>  <code>@Data</code> - annotation from the <a href="https://projectlombok.org/">lombok</a> library: adds getters and setters to fields and implements toString, equals and hashCode.  Thanks to her, POJO turns into bin. </p><br><p>  <code>GroovyObjectSupport</code> is the base class for "java-objects that want to appear as groovy-objects" (as written in the documentation).  Later I will show what it is for.  At this stage, you can do without it, but let it be right away. </p><br><p>  Now create a script that will fill in its fields. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> = "MyTestServer" description = "Apache Tomcat"</code> </pre> <br><p>  It's all obvious.  So far, as you see, we do not use any features of DSL, I will tell about them later. </p><br><p>  And finally run it from java </p><br><pre> <code class="java hljs">CompilerConfiguration cc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompilerConfiguration(); cc.setScriptBaseClass(DelegatingScript.class.getName()); <span class="hljs-comment"><span class="hljs-comment">//      groovy     DelegatingScript GroovyShell sh = new GroovyShell(Main.class.getClassLoader(), new Binding(), cc); DelegatingScript script = (DelegatingScript)sh.parse(new File("config.groovy")); ServerConfig config = new ServerConfig(); //     script.setDelegate(config); //    run()  " "  config     name  description script.run(); System.out.println(config.toString());</span></span></code> </pre> <br><p>  <code>ServerConfig(name=MyTestServer, description=Apache Tomcat)</code> is the result of the lombok implementation of toString (). </p><br><p>  As you can see, everything is quite simple.  The config is a real executable groovy-code, you can use all features of the language in it, for example, substitutions </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">def</span></span> postfix = <span class="hljs-string"><span class="hljs-string">"server"</span></span> name = <span class="hljs-string"><span class="hljs-string">"MyTest </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${postfix}</span></span></span><span class="hljs-string">"</span></span> description = <span class="hljs-string"><span class="hljs-string">"Apache Tomcat </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${postfix}</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br><p>  will return us <code>ServerConfig(name=MyTest server, description=Apache Tomcat server)</code> </p><br><p>  And in this script you can even set breakpoints and debug! </p><br><h2 id="vyzov-metodov">  Method call </h2><br><p>  We now turn to the actual DSL.  Suppose we want to add connector settings to our config.  They look like this: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connector</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyObjectSupport</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> secure; }</code> </pre> <br><p>  Add the fields for the two connectors, http and https, to our server config: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyObjectSupport</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String description; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connector http; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connector https; }</code> </pre> <br><p>  We can set the connectors from the script using the groovy code </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.example.Connector <span class="hljs-comment"><span class="hljs-comment">//... http = new Connector(); http.port = 80 http.secure = false</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Execution result</b> <div class="spoiler_text"><p> <code>ServerConfig(name=MyTest, description=Apache Tomcat, http=Connector(port=80, secure=false), https=null)</code> </p> </div></div><br><p>  As you can see, it worked, but, of course, this syntax is completely unsuitable for configuration.  Let's rewrite the config as we would like it to look: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">name</span></span> = <span class="hljs-string"><span class="hljs-string">"MyTest"</span></span> description = <span class="hljs-string"><span class="hljs-string">"Apache Tomcat"</span></span> http { <span class="hljs-attribute"><span class="hljs-attribute">port</span></span> = <span class="hljs-number"><span class="hljs-number">80</span></span> secure = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } https { <span class="hljs-attribute"><span class="hljs-attribute">port</span></span> = <span class="hljs-number"><span class="hljs-number">443</span></span> secure = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">The result is an exception.</b> <div class="spoiler_text"><p>  <code>Exception in thread "main" groovy.lang.MissingMethodException: No signature of method: config.http() is applicable for argument types: (config$_run_closure1) values: [config$_run_closure1@780cb77]</code> . </p></div></div><br><p>  It looks like we are trying to call the <code>http(Closure)</code> method, and groovy cannot find it from either the delegate object or the script.  We could, of course, declare it in the ServersConfig class: </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Closure closure)</span></span></span><span class="hljs-function"> </span></span>{ http = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Connector(); closure.setDelegate(http); closure.setResolveStrategy(Closure.DELEGATE_FIRST); closure.call(); }</code> </pre> <br><p>  And similar - for https.  This time everything is fine: </p><br><div class="spoiler">  <b class="spoiler_title">Execution result</b> <div class="spoiler_text"><p> <code>ServerConfig(name=MyTest, description=Apache Tomcat, http=Connector(port=80, secure=false), https=Connector(port=443, secure=true))</code> </p> </div></div><br><p>  Here we need to clarify what we have done, because this is the first step to DSL.  We declared a method that accepts the <code>groovy.lang.Closure</code> parameter, creates a new object for our <code>groovy.lang.Closure</code> field, delegates it to the received closure, and executes the closure code.  Line </p><br><pre> <code class="java hljs">closure.setResolveStrategy(Closure.DELEGATE_FIRST);</code> </pre> <br><p>  means that when accessing fields or methods, groovy will first look at the delegate, and only then, if it does not find anything suitable, on the closure.  For the script, this strategy is used by default, for closing it must be set manually. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><p>  The <a href="https://logback.qos.ch/">logback</a> library, which can be configured via groovy, uses exactly this approach.  They explicitly implemented all the methods that are used in their DSL. </p></div></div><br><p>  In principle, we already have some DSL, but it is far from ideal.  Firstly, I would like to avoid manually writing the code to install each field, and secondly, I would like to avoid duplicating the code for all classes of bins that are used in our config.  And here the second component of the groovy DSL magic comes to our rescue ... </p><br><h3 id="methodmissing">  methodMissing () </h3><br><p>  Each time groovy encounters a method call that is not present in the object, it tries to call methodMissing ().  As parameters, the name of the method that they tried to call and the list of its arguments are passed there.  Remove the http and https methods from the ServerConfig class and declare the following instead: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodMissing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, Object args)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(name + <span class="hljs-string"><span class="hljs-string">" was called with "</span></span> + args.toString()); }</code> </pre> <br><p>  args is actually of type <code>Object[]</code> , but groovy is looking for a method with exactly that signature.  Check: </p><br><pre> <code class="hljs pgsql">http was <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> [Ljava.lang.<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>;@<span class="hljs-number"><span class="hljs-number">16</span></span>aa0a0a https was <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> [Ljava.lang.<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>;@<span class="hljs-number"><span class="hljs-number">691</span></span>a7f8f ServerConfig(<span class="hljs-type"><span class="hljs-type">name</span></span>=MyTest, description=Apache Tomcat, http=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, https=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre> <br><p>  Exactly what is needed!  It remains only to expand the arguments and, depending on the type of the parameter, set the values ‚Äã‚Äãof the fields.  In our case, an array of one element of the Closure class is passed there.  For example, let's do this: </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodMissing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, Object args)</span></span></span><span class="hljs-function"> </span></span>{ MetaProperty metaProperty = getMetaClass().getMetaProperty(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metaProperty != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Closure closure = (Closure) ((Object[]) args)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Object value = getProperty(name) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? metaProperty.getType().getConstructor().newInstance() : getProperty(name); closure.setDelegate(value); closure.setResolveStrategy(Closure.DELEGATE_FIRST); closure.call(); setProperty(name, value); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"No such field: "</span></span> + name); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">checks and exceptions</b> <div class="spoiler_text"><p>  I omit almost all checks and catch exceptions so as not to clutter up the code.  In a real project, of course, you can't do that right. </p></div></div><br><p>  Here we see several calls specific for groovy objects. </p><br><ul><li>  we see that the method called by name matches one of the fields by referring to the metaclass.  The metaclass is present in each groovy object and works approximately as reflection, but more convenient.  Metaclass, in particular, allows you to receive information about fields and access to them through accessors, even if the fields themselves are private.  This will come in handy later. </li><li>  we get the type of the field through the same metaclass to create a new instance of it.  Here we are counting on the fact that all classes that we are going to use in configs have a default constructor, but in principle no one bothers to make the logic as complex as you need. </li><li>  we get the value of the field through getProperty () and set the new value through setProperty ().  These are methods from GroovyObjectSupport and they access the field via accessors if they find them, or directly.  This saves us from having to change the field through reflection or some other not very convenient way, especially if this field is somewhere in the heir class. </li></ul><br><p>  So far we have added methodMissing and all dsl-buns for only one class, ServerConfig.  We could implement the same method for Connection, but why duplicate the code?  Let's create some basic class for all our config-bins, say, GroovyConfigurable, transfer methodMissing to it, and inherit ServerConfig and Connector. </p><br><div class="spoiler">  <b class="spoiler_title">Something like this</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyConfigurable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyObjectSupport</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodMissing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, Object args)</span></span></span><span class="hljs-function"> </span></span>{ MetaProperty metaProperty = getMetaClass().getMetaProperty(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metaProperty != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Closure closure = (Closure) ((Object[]) args)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Object value = getProperty(name) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? metaProperty.getType().getConstructor().newInstance() : getProperty(name); closure.setDelegate(value); closure.setResolveStrategy(Closure.DELEGATE_FIRST); closure.call(); setProperty(name, value); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"No such field: "</span></span> + name); } } } <span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyConfigurable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String description; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connector http; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connector https; } <span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connector</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyConfigurable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> secure; }</code> </pre> </div></div><br><p>  It all works, even though GroovyConfigurable knows nothing about the fields of its heirs! </p><br><h3 id="nasledovanie">  Inheritance </h3><br><p>  The next step is to make it possible to include in the config some parent config and redefine some separate fields.  It should look something like this. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'parent.groovy'</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = "prod" https { port = <span class="hljs-number"><span class="hljs-number">8080</span></span> }</code> </pre> <br><p>  Groovy allows you to import classes, but not scripts.  The easiest way is to implement the include method in our GroovyConfigurable class.  Add the path to the script itself and a couple of methods: </p><br><div class="spoiler">  <b class="spoiler_title">Groovyconfigurable</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> URI scriptPath; <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">include</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        URI uri = Paths.get(scriptPath).getParent().resolve(path).toUri(); runFrom(uri); } @SneakyThrows public void runFrom(URI uri) { this.scriptPath = uri; //  ,     main- CompilerConfiguration cc = new CompilerConfiguration(); cc.setScriptBaseClass(DelegatingScript.class.getName()); GroovyShell sh = new GroovyShell(Main.class.getClassLoader(), new Binding(), cc); DelegatingScript script = (DelegatingScript)sh.parse(uri); script.setDelegate(this); script.run(); }</span></span></code> </pre> </div></div><br><p>  Let's make the parent.groovy config, in which we will describe a certain basic config: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">name</span></span> = <span class="hljs-string"><span class="hljs-string">"PARENT NAME"</span></span> description = <span class="hljs-string"><span class="hljs-string">"PARENT DESCRIPTION"</span></span> http { <span class="hljs-attribute"><span class="hljs-attribute">port</span></span> = <span class="hljs-number"><span class="hljs-number">80</span></span> secure = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } https { <span class="hljs-attribute"><span class="hljs-attribute">port</span></span> = <span class="hljs-number"><span class="hljs-number">443</span></span> secure = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  In config.groovy, we leave only what we want to override: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "parent.groovy" <span class="hljs-type"><span class="hljs-type">name</span></span> = "MyTest" https { port = <span class="hljs-number"><span class="hljs-number">8080</span></span> }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Execution result</b> <div class="spoiler_text"><p> <code>ServerConfig(name=MyTest, description=PARENT DESCRIPTION, http=Connector(port=80, secure=false), https=Connector(port=8080, secure=true))</code> </p> </div></div><br><p>  As you can see, the name has been redefined, just like the port field in https.  The secure field in it remains from the parent config. </p><br><p>  You can go even further and make it possible to include not the whole config, but its individual parts!  To do this, in methodMissing, you need to add a check that the field to be set is also GroovyConfigurable and set the path to the parent script. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> methodMissing(String <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> args) { MetaProperty metaProperty = getMetaClass().getMetaProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (metaProperty != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Closure closure = (Closure) ((<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>[]) args)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = getProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? metaProperty.getType().getConstructor().newInstance() : getProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> instanceof GroovyConfigurable) { ((GroovyConfigurable) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>).scriptPath = scriptPath; } closure.setDelegate(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); closure.setResolveStrategy(Closure.DELEGATE_FIRST); closure.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(); setProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> IllegalArgumentException("No such field: " + <span class="hljs-type"><span class="hljs-type">name</span></span>); } }</code> </pre> </div></div><br><p>  This will allow us to include not only the whole script, but also its parts!  For example, so </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">http</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">include</span></span> <span class="hljs-string"><span class="hljs-string">"http.groovy"</span></span> }</code> </pre> <br><p>  where http.groovy is </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">port</span></span> = <span class="hljs-number"><span class="hljs-number">90</span></span> secure = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  This is an excellent result, but there is a small problem. </p><br><h3 id="generics">  Generics </h3><br><p>  Let's say we want to add mappings and their status to our server config. </p><br><div class="spoiler">  <b class="spoiler_title">config</b> <div class="spoiler_text"><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">name</span></span> = <span class="hljs-string"><span class="hljs-string">"MyTest"</span></span> description = <span class="hljs-string"><span class="hljs-string">"Apache Tomcat"</span></span> http { <span class="hljs-attribute"><span class="hljs-attribute">port</span></span> = <span class="hljs-number"><span class="hljs-number">80</span></span> secure = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } https { <span class="hljs-attribute"><span class="hljs-attribute">port</span></span> = <span class="hljs-number"><span class="hljs-number">443</span></span> secure = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } mappings = [ { <span class="hljs-attribute"><span class="hljs-attribute">url</span></span> = <span class="hljs-string"><span class="hljs-string">"/"</span></span> active = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, { <span class="hljs-attribute"><span class="hljs-attribute">url</span></span> = <span class="hljs-string"><span class="hljs-string">"/login"</span></span> active = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Mapping.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mapping</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyConfigurable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String url; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> active; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">ServerConfig.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroovyConfigurable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String description; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connector http; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Connector https; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Mapping&gt; mappings; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Running ...</b> <div class="spoiler_text"><p> <code>ServerConfig(name=MyTest, description=Apache Tomcat, http=Connector(port=80, secure=false), https=Connector(port=443, secure=true), mappings=[config$_run_closure3@14ec4505, config$_run_closure4@53ca01a2])</code> </p> </div></div><br><p>  Oops.  Type erasure in all its glory.  Unfortunately, magic ends here and we have to correct what we read with our hands.  For example, using a separate method <code>GroovyConfigurable#postProcess()</code> </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MetaProperty metaProperty : getMetaClass().getProperties()) { Object value = getProperty(metaProperty.getName()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Collection.class.isAssignableFrom(metaProperty.getType()) &amp;&amp; value <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Collection) { <span class="hljs-comment"><span class="hljs-comment">//      ParameterizedType collectionType = (ParameterizedType) getClass().getDeclaredField(metaProperty.getName()).getGenericType(); //       ,  ,    ,    //  ,      Class itemClass = (Class)collectionType.getActualTypeArguments()[0]; //      ,       GroovyConfigurable //   , ,    if (GroovyConfigurable.class.isAssignableFrom(itemClass)) { Collection collection = (Collection) value; //      ,    ,      Collection newValue = collection.getClass().newInstance(); for (Object o : collection) { if (o instanceof Closure) { //      Object item = itemClass.getConstructor().newInstance(); ((GroovyConfigurable) item).setProperty("scriptPath", scriptPath); ((Closure) o).setDelegate(item); ((Closure) o).setResolveStrategy(Closure.DELEGATE_FIRST); ((Closure) o).call(); ((GroovyConfigurable) item).postProcess(); //     ? newValue.add(item); } else { newValue.add(o); } } setProperty(metaProperty.getName(), newValue); } } } }</span></span></code> </pre> </div></div><br><p>  It turned out, of course, ugly, but it does its work.  In addition, we wrote it for only one base class, and do not need to repeat for the heirs.  After calling <code>config.postProcess();</code>  we will get usable bins. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Of course, the code given here is just a small (simplest) part of what is needed in a real library for configuration, and the more complicated your use case is, the more manual processing and checks must be added.  For example, support for maps, enums, nested generics, etc.  The list is endless, but for my needs I had enough of what I quoted in the article.  I hope this helps you too and your configs will become more beautiful and comfortable! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/358594/">https://habr.com/ru/post/358594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358580/index.html">IP PBX Zeon + RetailCRM = Effective Internet Sales</a></li>
<li><a href="../358582/index.html">We build an effective interaction between engineering and product teams.</a></li>
<li><a href="../358584/index.html">Error notification: from each circuit in its own way</a></li>
<li><a href="../358586/index.html">Announcement mitap Sync.NET # 6 in Kharkov</a></li>
<li><a href="../358588/index.html">Application Monitoring with Prometheus</a></li>
<li><a href="../358596/index.html">John Carmack: My stories about Steve Jobs</a></li>
<li><a href="../358600/index.html">Features of API development: which API is good?</a></li>
<li><a href="../358602/index.html">How to unleash the potential of a product manager? 30 typical PM interview questions</a></li>
<li><a href="../358604/index.html">PHP, GDB and arrays</a></li>
<li><a href="../358608/index.html">Each serverless platform has servers.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>