<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Say a word about poor recursion, or all that you did not know and do not want to know about it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recursion: see recursion. 
 All programmers are divided into 11 2 categories: who does not understand recursion, who already understood, and who learn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Say a word about poor recursion, or all that you did not know and do not want to know about it</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Recursion: see recursion. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/f06/315/6af/f063156af4cb822f9dd7c57e7d11cc3c.jpg" align="right" width="200">  All programmers are divided into 11 <sub>2</sub> categories: who does not understand recursion, who already understood, and who learned to use it.  In general, the guiller of me is exclusively cardboard, so you, the reader, will still have to comprehend the Tao Recursion on your own, I will only try to give a few magic pendels in the right direction. <br><br>  Applied programming is always engaged in solving applied problems by applying the efforts of a programmer to achieve results in non-ideal conditions.  It is on the basis of the imperfect nature of this world and the limited resources that the need for programmers develops: after all, some people need to help theorists shove their harmonious and beautiful theory into practice. <br><br><blockquote>  - How is it folded? <br>  - Excellent!  Only the hand sticks out of the suitcase a little. </blockquote><br>  It is precisely trying to place the harmonious theory of the algorithm into a hard backpack of real resources and you have to constantly cut to the living, repack, and instead of the beautiful and slim Fibonacci definitions: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"fib(n) defined for n&gt;=0"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) + fib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n</code> </pre> <br>  you have to fence all sorts of dirty khaki, ranging from: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @memoized def fib(n): if n&lt;0: raise Exception("fib(n) defined for n&gt;=0") if n&gt;1: return fib(n-1) + fib(n-2) return n</span></span></code> </pre><br>  And ending in general: <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"fib(n) defined for n&gt;=0"</span></span>) n0 = <span class="hljs-number"><span class="hljs-number">0</span></span> n1 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): n0, n1 = n1, n0+n1 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n0</code> </pre><br><a name="habracut"></a><br><h3>  So what is recursion? </h3><br>  Recursion, in fact, is proof by induction.  We tell how to get a result for a certain state, assuming that we have a result for a different set of states, and also tell how to get a result in those states to which everything slides one way or another. <br><br><blockquote>  If you are waiting for guests and suddenly noticed a stain on your suit, do not be upset.  This is fixable. <br>  For example, vegetable oil stains are easily displayed with gasoline.  Gasoline stains are easily removed with an alkali solution. <br>  Stains from alkali disappear from the vinegar essence.  Traces of vinegar essences must be rubbed with sunflower oil. <br>  Well, how to remove the stains from sunflower oil, you already know ... </blockquote><br><img src="http://quicklatex.com/cache3/ql_1dac222e33449b46030e39778127cda1_l3.png" width="200" align="right">  Now let's take a classic example: traversing a tree in depth.  But no, let's consider another example: we need to print a tree of expressions in the form of a reverse Polish record.  That is, for tree 1 we want to print ‚Äú2 2 +‚Äù and for tree 2 ‚Äú2 2 + 2 2 + *‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">tex</b> <div class="spoiler_text"><pre> <code class="hljs tex"><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">begin</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{tikzpicture}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">node</span></span></span></span> (is-root) {+} child { node {2} } child { node {2} }; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">path</span></span></span></span> (is-root) +(0,+0.5<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tikzleveldistance</span></span></span></span>) node {<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textit</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{Tree 1}</span></span></span></span>}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">end</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{tikzpicture}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">begin</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{tikzpicture}</span></span></span></span> <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">node</span></span></span></span> (is-root) {*} child { node {+} [sibling distance=1cm] child {node{2}} child {node{2}} } child { node {+} [sibling distance=1cm] child {node{2}} child {node{2}} }; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">path</span></span></span></span> (is-root) +(0,+0.5<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tikzleveldistance</span></span></span></span>) node {<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textit</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{Tree 2}</span></span></span></span>}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">end</span></span></span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{tikzpicture}</span></span></span></span></code> </pre></div></div><br><br>  As it is easy to see, the task turns into a simple ‚Äútree-by-depth walkthrough‚Äù: for each node we display the contents of all its child elements, after which we output the node itself.  That is, the code will be: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value=None, children=[])</span></span></span><span class="hljs-function">:</span></span> self.value = value self.children = children <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> node.children: printTree(child) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> node.value, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> tree1 = TreeNode(<span class="hljs-string"><span class="hljs-string">"+"</span></span>, [ TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>), TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>) ]) tree2 = TreeNode(<span class="hljs-string"><span class="hljs-string">"*"</span></span>, [ TreeNode(<span class="hljs-string"><span class="hljs-string">"+"</span></span>, [ TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>), TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>) ]), TreeNode(<span class="hljs-string"><span class="hljs-string">"+"</span></span>, [ TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>), TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>) ]) ]) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Tree1:"</span></span>, printTree(tree1) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Tree2:"</span></span>, printTree(tree2) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: main()</code> </pre><br><br>  It would seem that everything is fine!  The code works fine as long as the tree meets the requirements: any node has an array of children (possibly empty) and some value.  Who will say what else requirement for this tree? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/880/b1a/4b7/880b1a4b7c06afff547606dd909d527f.gif"><br><br>  I will not torment.  Requirement: not very large depth of the tree.  How so?  That's how: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(depth)</span></span></span><span class="hljs-function">:</span></span> root = TreeNode(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) node = root <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(depth): node = TreeNode(<span class="hljs-string"><span class="hljs-string">"--"</span></span>, [ node ]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">depthTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(depth)</span></span></span><span class="hljs-function">:</span></span> tree = buildTree(depth) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Tree of depth"</span></span>, depth, <span class="hljs-string"><span class="hljs-string">":"</span></span>, printTree(tree) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10000</span></span>): depthTest(d)</code> </pre><br>  Launch, and oops!  "Tree of depth 997: RuntimeError: maximum recursion depth exceeded."  We climb into the documentation, and find the function <a href="https://docs.python.org/2/library/sys.html">sys.getrecursionlimit</a> .  And now let's move away from the world of interpreted languages, and move on to the world of languages ‚Äã‚Äãthat run directly on the processor.  For example, in C ++. <br><br>  Mentally rewrite 1-in-1 this code in C ++ (I will leave this task to the reader as a warm-up), and try to find the limit when the application rests on the restriction ... <br><br><div class="spoiler">  <b class="spoiler_title">for the lazy</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">#include &lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; #include &lt;vector&gt; #include &lt;iostream&gt; using namespace std; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TreeNode { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> value_; vector&lt;TreeNode*&gt; children_; TreeNode(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; value, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vector&lt;TreeNode*&gt;&amp; children): value_(value), children_(children) {} virtual ~TreeNode() {} }; void printTree(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TreeNode* node) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(auto i : node-&gt;children_) printTree(i); cout &lt;&lt; node-&gt;value_ &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; } TreeNode* buildTree(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> depth) { auto root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, {}); auto node = root; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;depth; i++) { vector&lt;TreeNode*&gt; children; children.push_back(node); node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-string"><span class="hljs-string">"--"</span></span>, children); } return node; } void depthTest(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> depth) { auto tree = buildTree(depth); cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Tree of depth "</span></span> &lt;&lt; depth &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>; printTree(tree); cout &lt;&lt; endl; } <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> d=<span class="hljs-number"><span class="hljs-number">60000</span></span>;; d+=<span class="hljs-number"><span class="hljs-number">16384</span></span>) { depthTest(d); } }</code> </pre></div></div><br>  Run ... "Bus error (core dumped)".  Judging by gdb, at the moment of dropping a stack with a depth of 104790 frames.  And what happens if we want to print not just in a row through spaces, but also output "{" and "}" around expressions?  Well, that is, for tree 1, for the result to be {2 2 +} and for tree 2 - {{2 2 + {2 2 +} *}?  Rewrite ... <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node)</span></span></span><span class="hljs-function">:</span></span> opened = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> node.children: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> opened: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"{"</span></span>, opened = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> printTree(child) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> node.value, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> opened: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"}"</span></span>,</code> </pre><br><br>  Nothing has changed, still falls when trying to print a tree with a depth of 997. And now the same thing, but on the pros ... Oops.  Depth of the stack in the fall - 87327. Stop.  We just added one local variable that does not affect the algorithm and the essence of what is happening, and the tree size limit was reduced by 17%!  And now the funniest thing - it all strongly depends on the compiler options, on which platform it runs, in which OS and with which settings. <br><br>  But this is not the funny thing.  Let's imagine that this function is used by another function.  All is well, if it is the only one - we can calculate how much the actual steps are less than the maximum depth.  And if this function is used from another recursive?  Then the capabilities of this function will depend on the depth of the other function. <br><br>  In this way, our beautiful simple algorithm stops suddenly getting into our imperfect suitcase.  Let the reader imagine how good it is to have such limitations in the service, which is launched in production and provides some service to unsuspecting hackers, who only do what they poke into this service with their dirty fuzzy testers. <br><br><h3>  So what's the problem? </h3><br>  <b>The use of a recursive algorithm implies the use of an almost uncontrollable resource: a call stack</b> . <br><br>  First, we can‚Äôt know exactly how much has been used.  Secondly, we can not know exactly how much is left.  Thirdly, we cannot guarantee the availability of a certain size of this resource for each challenge.  In the 4th, we can not fix the flow of this resource.  Thus, we become dependent on the resource, which is damn difficult to control and distribute.  As a result, we cannot guarantee any characteristics of this function / service.  Well, if our service works in a managed context: java, python, .net, and so on.  It‚Äôs bad if the service works in an uncontrolled environment: <a href="http://stackoverflow.com/questions/7826992/browser-javascript-stack-size-limit">javascript</a> (which is generally <a href="https://www.safaribooksonline.com/library/view/high-performance-javascript/9781449382308/ch04s03.html">bad</a> ).  Even worse, if the service runs on C ++, and the <a href="http-openssl-cve-2014-0221">depth of the</a> <a href="http://www.openwall.com/lists/oss-security/2014/08/27/1">recursion</a> <a href="https://bugs.mageia.org/show_bug.cgi%3Fid%3D12842">depends</a> on the data transmitted by the user. <br><br><h3>  What to do? </h3><br>  If we are not working on a microcontroller, we can not worry about the size of the stack: for the usual chain of calls it should be enough.  Provided, of course, that we care about the hygiene of local variables: large objects and arrays are allocated using memory (new / malloc).  However, the use of recursion implies that instead of a limited number of calls, we will have them simply countable. <br><br>  So, to get rid of the problems created by recursion, you can do the following (from simple to complex): <br>  - Hard to limit the maximum size / format / number in the incoming data.  Hi, <a href="https://ru.wikipedia.org/wiki/Zip-%25D0%25B1%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B0">zip bombs</a> and their ilk - sometimes even a small incoming package can make a big fuss. <br>  - Hard to limit the maximum depth of calls to some number.  It is important to remember that this number should be VERY small.  That is about hundreds.  And be sure to add tests that verify that the program with this maximum number does not break.  And with the maximum number on all possible execution branches (hello to allocating local variables on demand).  And don't forget to check this test on different compilation options and after each build. <br>  - Tightly limit the amount of stack used.  Using complex bypass maneuvers and knowledge of the practical implementation of execution in hardware, you can get the stack size that is used now (such as taking the address of a local volatile variable).  In some cases (for example, through libunwind in linux), you can also get the available stack volume for the current thread, and take a difference between them.  When using this method, it is important to have tests that verify that the cut-off is guaranteed and with all the input data options ‚Äî for example, it can be fun if the test is performed in one method that is recursive after 3-4 others.  And it may fall in the intermediate ... But only in the release mode, after the inline of some functions, for example.  However, tests for the maximum allowable complexity are also important here, so as not to accidentally cut off some of the valid input requests that clients actually use. <br>  - The best way: <b>get rid of recursion</b> . <br><br><blockquote>  And do not lie, that you are free and holy - you are captivated and not free. <br>  I opened the sky before you! <br>  Times change their course - Look at the palms ... <br><br>  Infinite sweetness of freedom <br>  Reject freedom <br>  <a href="http://www.lib.ru/KSP/kalugin.txt">Sergey Kalugin</a> </blockquote><br>  Yes Yes.  After comprehending the Tao of recursion, you also comprehend the Tao of non-recursion.  Almost all recursive algorithms have non-recursive counterparts.  Starting from more efficient (see above Fibonacci), and ending with equivalent, using a queue in memory instead of a call stack. <br><br>  Canonical non-recursive implementation of traversing the tree in depth: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node)</span></span></span><span class="hljs-function">:</span></span> stack = [ (node, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) ] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> len(stack)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>: i = len(stack)<span class="hljs-number"><span class="hljs-number">-1</span></span> node, visited, opened = stack[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> visited: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reversed(node.children): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> opened: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"{"</span></span>, opened = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> stack.append( (child, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) ) visited = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> stack[i] = (node, visited, opened) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> node.value, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> opened: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> stack[i]</code> </pre><br>  It is easy to see that the algorithm has not changed, but instead of using the call stack, the stack array is used in memory, which stores both the processing context (in our case, the opened flag) and the processing context (in our case, before or after the children are processed).  In cases when you need to do something between each of the recursive calls, or add processing phases.  Note: this is an optimized algorithm that pushes all the children onto the stack at once, and that is why it is folding in the reverse order.  This ensures that the same order as the original non-recursive algorithm is preserved. <br><br>  Here is the same code, only written "in the forehead", keeping the context (at the same time, outputting commas between elements): <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node)</span></span></span><span class="hljs-function">:</span></span> stack = [ (node, <span class="hljs-number"><span class="hljs-number">0</span></span>) ] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> len(stack)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>: i = len(stack)<span class="hljs-number"><span class="hljs-number">-1</span></span> node, phase = stack[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> phase &lt; len(node.children): child = node.children[phase] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> phase == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"{"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> phase &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">","</span></span>, stack.append( (child, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) stack[i] = (node, phase+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> node.value, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> phase&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> stack[i]</code> </pre><br>  Yes, the transition to non-recursive technologies is not completely free: we pay periodically more expensive - dynamic memory allocation for the organization of the stack.  However, it pays off: not all local variables are saved to the ‚Äúmanual stack‚Äù, but only the minimum necessary context, the size of which can already be controlled.  The second item of expenditure: code readability.  The code written in a non-recursive form is somewhat more difficult for perception due to branching from the current state.  The solution to this problem lies already in the area of ‚Äã‚Äãcode organization: making steps into separate functions and competently naming them. <br><br><h3>  Misadventure </h3><br>  Despite the existence of a certain ‚Äúde-taxation tax‚Äù, I personally consider it obligatory to be paid in any place where data is processed, in one way or another, received from the user. <br><br>  <b>And how do you not use recursion?</b> </div><p>Source: <a href="https://habr.com/ru/post/256351/">https://habr.com/ru/post/256351/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256337/index.html">Services on the conveyor. How is the information infrastructure of WebCanape?</a></li>
<li><a href="../256339/index.html">Doing yourself to open it up, or the Right to pre-edit</a></li>
<li><a href="../256345/index.html">Control robots created with LEGO¬Æ Mindstorms¬Æ NXT Brick using the Wolfram Language (Mathematica)</a></li>
<li><a href="../256347/index.html">Checking the Haiku operating system (BeOS family) with PVS-Studio. Part 1</a></li>
<li><a href="../256349/index.html">GSM module control with AVR</a></li>
<li><a href="../256353/index.html">Using the driver keys of the lower and upper levels of the IR2110 - an explanation and examples of schemes</a></li>
<li><a href="../256355/index.html">godebug - cross-platform debugger for Go</a></li>
<li><a href="../256357/index.html">IT resources under control</a></li>
<li><a href="../256359/index.html">The correct bonus for your new server</a></li>
<li><a href="../256361/index.html">New spam: How scammers use interactive robots from the cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>