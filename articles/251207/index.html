<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About busting on the example of generating crosswords</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the article " Algorithm of Crossword Formation ", several heuristics were proposed, which were implemented in the program of automatic generation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About busting on the example of generating crosswords</h1><div class="post__text post__text-html js-mediator-article">  With the article " <a href="http://habrahabr.ru/post/249899/">Algorithm of Crossword Formation</a> ", several heuristics were proposed, which were implemented in the program of automatic generation of crossword puzzles.  Despite the fact that the proposed heuristics are well developed, even they did not allow for a reasonable time to generate a crossword puzzle for the most complex of the grids: <br><br><img src="http://habrastorage.org/files/019/87c/95c/01987c95c1154581bb753ff80758c3a7.png" alt="image"><br>  <i>This and all subsequent figures are taken from the original article.</i> <br><br>  In this article, I would like to discuss a much simpler solution that allows you to solve this problem. <br><a name="habracut"></a><br>  The proposed solution is based on two main ideas: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Correct brute force </li><li>  Do not perform the same actions again. </li></ol><br>  All code is written in Scala. <br><br><h4>  Data structures </h4><br>  Imagine a crossword box in the form of a two-dimensional list of cells (Cell): <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> field: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Cell</span></span>]] = readField(<span class="hljs-string"><span class="hljs-string">"cross.in"</span></span>)</code> </pre> <br>  In addition, each cell is either a protein and must contain a letter (Letter), or black, and must remain empty (Empty): <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Letter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">-</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span></span></code> </pre><br>  A word is a sequence of letters: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Word</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val letters: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Letter</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  A dictionary is a set of words grouped by length: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dictionary: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Set</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]] = readWords(<span class="hljs-string"><span class="hljs-string">"cross.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"WINDOWS-1251"</span></span>).groupBy(_.size)</code> </pre><br><h4>  Word highlighting </h4><br>  Note that there are no words in the field description.  We will take the word vertical or horizontal set of (future) letters, bounded by empty cells, or the edges of the board. <br>  Let's learn how to highlight words on one line: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extractWords</span></span></span></span>(row: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Cell</span></span>]): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">Word</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rest = row.dropWhile(_ == <span class="hljs-type"><span class="hljs-type">Empty</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    if (rest.isEmpty) Seq() //    else { //      ,      val word = new Word(rest.takeWhile(_ != Empty).map(_.asInstanceOf[Letter])) //         word +: extractWords(rest.dropWhile(_ != Empty)) } }</span></span></code> </pre><br>  To select all the words, select the words from the rows, transpose the field and select the words from the columns.  At the same time, remove single-letter words. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> words = (field.flatMap(extractWords) ++ field.transpose.flatMap(extractWords)).filter(_.letters.size != <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  For a quick search for intersecting words, we will store information in (future) letters, which words pass through them and the number of the letter in this word: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Letter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> words = <span class="hljs-type"><span class="hljs-type">Array</span></span>.empty[(<span class="hljs-type"><span class="hljs-type">Word</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>)] } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (word &lt;- words; (letter, index) &lt;- word.letters.zipWithIndex) { letter.words :+= (word, index) }</code> </pre><br><h4>  Bust </h4><br>  In the search procedure, we will transfer two mappings (Map): variants and assignment.  In words, for each word that has not yet been considered, there is a list of words that can stand in this place (initially all the words of the required length), and in the assignment, the recorded values ‚Äã‚Äãof the words already considered (initial empty): <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  def search(variants: Map[Word, List[String]], assignment: Map[Word, String]) //  search(words.map(w =&gt; (w, random.shuffle(dictionary(w.letters.size).toList))).toMap, Map.empty)</span></span></code> </pre><br>  Note that when you call, you shuffle the words in the list, so that with different launches there will be different crosswords. <br><br>  Now we can write the first version of busting: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span></span>(variants: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Word</span></span>, <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]], assignment: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Word</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (variants.isEmpty) { <span class="hljs-comment"><span class="hljs-comment">//    -   dump(assignment) } else { //        val (word, vars) = variants.head //    for (variant &lt;- vars) { //      var newVariants = variants - word //   ,   ,     for ((letter, char) &lt;- word.letters.zip(variant); (other, index) &lt;- letter.words; if newVariants.contains(other)) { //    ,      (index)    newVariants = newVariants.updated(other, variants(other).filter(var =&gt; var(index) == char)) } //   search(newVariants, assignment.updated(word, variant)) } } }</span></span></code> </pre><br>  Unfortunately, in a reasonable time, this iteration is not able to find a solution even for the simplest of the grids (9x9) mentioned in the original <br>  article: <br><br><img src="http://habrastorage.org/files/f8d/765/2b7/f8d7652b780e4297908fac274111c562.png" alt="image"><br><br><h4>  Correct brute force </h4><br>  Fortunately, this problem is easy to fix.  To do this, simply select the correct order of consideration.  Now the first available word is taken in the search. <br><br>  Are there more effective strategies?  There is, and one of them was proposed back in 1965 in the article <a href="http://dl.acm.org/citation.cfm%3Fid%3D321300">SW Golomb, LD Baumert Backtrack Programming // Journal of the ACM Volume 12 Issue 4, 1965</a> .  Unfortunately, I was not able to find this article in the public domain, but the idea itself is very simple: it is necessary to sort through the thing for which there are fewer options. <br><br>  In our case, this means that we should not take an arbitrary word, but one that has the least suitable options left: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (word, vars) = variants.minBy(_._2.size)</code> </pre><br>  Note that with this we get two nice bonuses for free.  First, if for some word there are no options left, then it will be immediately selected and this branch will be cut off without further search.  Secondly, if there is only one option left for the word, then it will be immediately put in place, which will reduce brute force in future. <br><br>  This optimization allows you to instantly find solutions for the 9x9 grid and in more than 50% of cases, find a solution for the ‚Äúsimple‚Äù 15x15 grid: <br><br><img src="http://habrastorage.org/files/cf0/cc0/31e/cf0cc031e0f646b8a5cff51d5fbc2071.png" alt="image"><br><br>  However, the 11x11 grid and the 15x15 ‚Äúcomplex‚Äù grid still require too much time. <br><br><h4>  Do not perform the same actions again. </h4><br>  As in most programs, in our enumeration most of the time is occupied by the innermost cycle, in which we remove the ‚Äúinappropriate‚Äù words: <br><br><pre> <code class="scala hljs">newVariants = newVariants.updated(other, variants(other).filter(_(index) == char))</code> </pre><br>  At first glance, there is no loop in this line, but in fact it is hidden in the implementation of the filter method.  How can we save time here?  And let's cache the results of this cycle! <br><br>  Note that here lists of words are calculated, in which some of the letters are fixed and some are not known.  We will represent such a "partial" word in the form of a mask of the format " <code>???</code> ", that is, indicating question marks instead of unknown letters. <br><br>  Now in the search, we will not operate with lists of "suitable" words, but with masks + cache the results of the calculation of lists: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span></span>(masks: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Word</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>], assignment: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Word</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (masks.isEmpty) { <span class="hljs-comment"><span class="hljs-comment">//    -   dump(assignment) } else { //       val (word, mask) = masks.minBy(w =&gt; cache(w._2).size) //   for (variant &lt;- cache(mask)) { var newVariants = masks - word //  ""  for ((letter, char) &lt;- word.letters.zip(variant); (other, index) &lt;- letter.words; if newVariants.contains(other)) { val oldMask = masks(other) val newMask = oldMask.updated(index, char) //  ,     cache.getOrElseUpdate(newMask, cache(oldMask).filter(_(index) == char)) newVariants = newVariants.updated(other, newMask) } search(newVariants, assignment.updated(word, variant)) } } }</span></span></code> </pre><br>  Before using the new search function, you need to fill the cache with words from the dictionary and generate initial masks for all words: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((length, variants) &lt;- dictionary) { cache.getOrElseUpdate(<span class="hljs-string"><span class="hljs-string">"?"</span></span> * length, random.shuffle(variants.toList).toArray) } search(words.map(w =&gt; (w, <span class="hljs-string"><span class="hljs-string">"?"</span></span> * w.letters.length)).toMap, <span class="hljs-type"><span class="hljs-type">Map</span></span>.empty)</code> </pre><br>  Adding caching allows iteration to find a solution even for the most complex grid: <br><br><img src="http://habrastorage.org/files/019/87c/95c/01987c95c1154581bb753ff80758c3a7.png" alt="image"><br><br>  A crossword puzzle, generated in 30 seconds (in fact, in this case, lucky with random, the crossword is quickly generated somewhere in one of 20 cases): <br><br><pre> Akast Ahum Ahum 
 lager aloa lara 
 anami rokk erma 
 radio transmitter 
 young tinder     
    aarne phloem 
 maar ketch actor 
 antidepressants 
 atasu aapa yauk 
 Kartli whole    
     insi clouds 
 addition 
 Raha Alla Anand 
 head loik Kindy 
 anna aedie cake  
</pre><br><h4>  findings </h4><br>  The use of a pair of simple optimizations made it possible to easily implement a solution that is better than a heuristic solution based on a deep knowledge of the subject area.  Choose the correct brute force and do not repeat the same calculations! <br><br><ul><li>  <a href="http://pastebin.com/ghV8WKC3">Source</a> </li><li>  <a href="http://pastebin.com/hDa3tQ2W">Input examples</a> </li><li>  <a href="http://crossword.ucoz.ru/download.htm">Dictionaries</a> (at the end of the page, the link is taken from the comment to the <a href="http://habrahabr.ru/post/249899/">original post</a> ) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/251207/">https://habr.com/ru/post/251207/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251191/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ36 (February 16 - 22, 2015)</a></li>
<li><a href="../251193/index.html">Naming complex actions in the REST API</a></li>
<li><a href="../251197/index.html">Weekly io.js, February 20, 2015</a></li>
<li><a href="../251199/index.html">We write a bot for MMORPG with assembler and draenei. Part 2</a></li>
<li><a href="../251205/index.html">Penguin talking</a></li>
<li><a href="../251209/index.html">Ethical hacking and penetration testing courses. New set</a></li>
<li><a href="../251211/index.html">Objective-C Runtime for Si-Schnick. Part 3</a></li>
<li><a href="../251215/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ148 (February 16 - 22, 2015)</a></li>
<li><a href="../251217/index.html">What is the "abstract developer"?</a></li>
<li><a href="../251223/index.html">PHP Digest number 57 - interesting news, materials and tools (February 9 - 22, 2015)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>