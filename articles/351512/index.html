<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A note about the new linux kernel interface - gpio uapi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Starting with the 4.6-r1 kernel version, we have a new interface available for interacting with the gpio kernel subsystem. Now there are three officia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A note about the new linux kernel interface - gpio uapi</h1><div class="post__text post__text-html js-mediator-article"><p>  Starting with the 4.6-r1 kernel version, we have a new interface available for interacting with the gpio kernel subsystem.  Now there are three official ways to work with gpio and receive interruptions from them.  It makes no sense to delve into the needs for this subsystem, for a small part of it is harsh everyday life, for the other part a fun hobby, and for all together in the core a new opportunity for interaction was provided. </p><br><p>  The note is of a popular nature, since we will not touch upon the main advantages that came with the innovation, namely the simplification of working with gpio in the context of the kernel. </p><a name="habracut"></a><br><h1 id="novyy-interfeys-uapi-gpio">  New uapi gpio interface </h1><br><p>  <a href="">https://github.com/torvalds/linux/blob/master/include/uapi/linux/gpio.h</a> </p><br><p>  First, now <strong>gpiochip</strong> is really a device and can be seen in <strong>devfs</strong> as <strong>gpiochipN</strong> , where N is the chip number assigned in <strong>the initialization order</strong> .  Secondly, all setup is now done via <strong>ioctl</strong> .  And thirdly, reading and writing, surprisingly, is accomplished through read / write calls, albeit with the help of a special <a href="">struct gpiohandle_data</a> structure. </p><br><h2 id="gpio-mockup">  gpio-mockup </h2><br><p>  Starting with the v4.9-rc1 kernel version (it will actually be used only in versions older than v4.12-rc1), a virtual <strong>gpio</strong> device has become available, with support for managing states via <strong>debugfs</strong> . </p><br><p>  Consider the difference between <strong>sysfs</strong> and <strong>uapi</strong> in userspace. </p><br><h3 id="inicializaciya-gpio-mockup">  Gpio-mockup initialization </h3><br><p>  Options: </p><br><ul><li>  gpio_mockup_ranges - pairs of numbers to initialize gpiochips, in the form of "base, end", where base is the starting number, end is the end of the range. </li><li>  gpio_mockup_named_lines is a boolean parameter, if specified, assigns each line a label in the form of gpio-mockup-A..ZN, where N is the sequence number of the line in the bank. </li></ul><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># modprobe gpio-mockup gpio_mockup_ranges=0,8,8,16</span></span></code> </pre> <br><p>  <strong>With</strong> this command we created two <strong>gpiochip</strong> with 8 lines each, with ranges [0-8), [8,16).  We'll talk about <strong>gpio_mockup_named_lines</strong> later. </p><br><h2 id="sravnenie-sysfs-i-uapi">  Sysfs versus uapi </h2><br><p>  With the help of the new driver, we consider the differences between the two systems from the user's point of view. </p><br><h3 id="informaciya-o-gpiochips">  Information about gpiochip's </h3><br><h4 id="sysfs">  sysfs </h4><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># cat /sys/class/gpio/gpiochip*/base 0 8 # cat /sys/class/gpio/gpiochip*/ngpio 8 8 # cat /sys/class/gpio/gpiochip*/label gpio-mockup-A gpio-mockup-B</span></span></code> </pre> <br><h4 id="uapi">  uapi </h4><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpiochip_info</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">chip_info</span></span></span><span class="hljs-class">;</span></span> ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &amp;chip_info);</code> </pre> <br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># ./lsgpio | grep GPIO\ chip GPIO chip: gpiochip1, "gpio-mockup-B", 8 GPIO lines GPIO chip: gpiochip0, "gpio-mockup-A", 8 GPIO lines</span></span></code> </pre> <br><h3 id="zadanie-linii-kak-vhoda-i-chtenie-znacheniya">  Setting the line as an input and reading the value </h3><br><h4 id="sysfs-1">  sysfs </h4><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># echo in &gt; /sys/class/gpio/gpio0/direction # cat /sys/class/gpio/gpio0/value</span></span></code> </pre> <br><h4 id="uapi-1">  uapi </h4><br><pre> <code class="hljs haskell"> struct gpiohandle_request req; req.lineoffsets[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; req.flags = <span class="hljs-type"><span class="hljs-type">GPIOHANDLE_REQUEST_INPUT</span></span>; req.lines = <span class="hljs-number"><span class="hljs-number">1</span></span>; struct gpiohandle_data <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; ioctl(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fd</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GPIO_GET_LINEHANDLE_IOCTL</span></span></span><span class="hljs-class">, &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req</span></span></span><span class="hljs-class">); ioctl(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fd</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GPIOHANDLE_GET_LINE_VALUES_IOCTL</span></span></span><span class="hljs-class">, &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br><h3 id="zadanie-linii-kak-vyhoda">  Set line as output </h3><br><h4 id="sysfs-2">  sysfs </h4><br><pre> <code class="hljs kotlin"> # echo high &gt; /sys/<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio0</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">direction</span></span></span></span></code> </pre> <br><h4 id="uapi-2">  uapi </h4><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpiohandle_request</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req</span></span></span><span class="hljs-class">;</span></span> req.lineoffsets[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; req.flags = GPIOHANDLE_REQUEST_OUTPUT; req.default_values[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; req.lines = <span class="hljs-number"><span class="hljs-number">1</span></span>; ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &amp;req);</code> </pre> <br><h3 id="edge-handling">  Edge handling </h3><br><h4 id="sysfs-3">  sysfs </h4><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># echo both &gt; /sys/class/gpio/gpio0/edge</span></span></code> </pre> <br><h4 id="uapi-3">  uapi </h4><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpioevent_request</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ereq</span></span></span><span class="hljs-class">;</span></span> ereq.lineoffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; ereq.eventflags = GPIOEVENT_REQUEST_BOTH_EDGES; ioctl(fd, GPIO_GET_LINEEVENT_IOCTL, &amp;ereq);</code> </pre> <br><h3 id="polling-on-events">  Polling on events </h3><br><p>  The kernel documentation for <strong>sysfs</strong> specifies the use of <strong>EPOLLPRI</strong> and <strong>EPOLLERR</strong> (or <strong>except fds</strong> for select), which in principle is typical for any <strong>sysfs_notify</strong> call, <strong>not</strong> necessarily for the <strong>gpio</strong> subsystem. </p><br><p>  For uapi, EPOLLIN is sufficient. </p><br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.data.fd = ereq.fd; <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.events = EPOLLIN; epoll_ctl(epollfd, EPOLL_CTL_ADD, ereq.fd, &amp;<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>);</code> </pre> <br><p>  We are <strong>reading an</strong> event with a time <strong>stamp</strong> and type <strong>GPIOEVENT_EVENT_RISING_EDGE</strong> or <strong>GPIOEVENT_EVENT_FALLING_EDGE</strong> . </p><br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> gpioevent_data <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>; read(pin-&gt;fd, &amp;<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>));</code> </pre> <br><p>  <strong>EPOLLET</strong> for uapi works according to the epoll documentation. </p><br><h3 id="labels">  labels </h3><br><h4 id="malenkaya-remarka-dlya-sysfs">  Small note for sysfs </h4><br><p>  The name of the contact <strong>gpioN</strong> to which everyone is so accustomed, generally speaking, is not canonical, but is used if the contact has not been given a name, for example, in Device Tree. </p><br><pre> <code class="hljs pgsql"> // drivers/gpio/gpiolib-sysfs.c // <span class="hljs-type"><span class="hljs-type">int</span></span> gpiod_export(struct gpio_desc *<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, <span class="hljs-type"><span class="hljs-type">bool</span></span> direction_may_change) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = gpio_chip_hwgpio(<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chip-&gt;names &amp;&amp; chip-&gt;names[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>]) ioname = chip-&gt;names[<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>]; dev = device_create_with_groups(&amp;gpio_class, &amp;gdev-&gt;dev, MKDEV(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), data, gpio_groups, ioname ? ioname : "gpio%u", desc_to_gpio(<span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>));</code> </pre> <br><p>  Let's try <strong>gpio-mockup</strong> with the <strong>gpio_mockup_named_lines</strong> option: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment"># modprobe gpio-mockup gpio_mockup_ranges=0,8,8,16 gpio_mockup_named_lines=1 # echo 0 &gt; /sys/class/gpio/export # ls /sys/class/gpio/gpio-mockup-A-0 active_low device direction edge power subsystem uevent value</span></span></code> </pre> <br><p>  As we see, the contact name has acquired the form <strong>gpio_chip_label</strong> - <strong>gpio_offset</strong> , but this is true only for the <strong>gpio-mockup driver</strong> . </p><br><pre> <code class="hljs perl"> // drivers/gpio/gpio-mockup.c // static <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gpio_mockup_name_lines(struct device *dev, struct gpio_mockup_chip *chip) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; gc-&gt;ngpio; i++) names[i] = devm_kasprintf(dev, GFP_KERNEL, <span class="hljs-string"><span class="hljs-string">"%s-%d"</span></span>, gc-&gt;label, i);</code> </pre> <br><p>  There is no way to "guess" in advance whether a name exists for a contact without using <strong>uapi</strong> , and searching for an exported "named" line is difficult if the name is not known in advance (again, if known, then we need the name and offset on the known <strong>gpiochip</strong> ). </p><br><h4 id="uapi-4">  uapi </h4><br><p>  The uapi interface allows us to see the names of the lines without initialization: </p><br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#./lsgpio | grep gpio-mockup-A GPIO chip: gpiochip0, "gpio-mockup-A", 8 GPIO lines line 0: "gpio-mockup-A-0" unused [output] ... line 7: "gpio-mockup-A-7" unused [output]</span></span></code> </pre> <br><p>  With the corresponding device tree file (example is taken from the kernel documentation): </p><br><pre> <code class="hljs pgsql"> gpio-<span class="hljs-type"><span class="hljs-type">line</span></span>-names = "MMC-CD", "MMC-WP", "VDD eth", "RST eth", "LED R", "LED G", "LED B", "Col A", "Col B", "Col C", "Col D", "Row A", "Row B", "Row C", "Row D", "NMI button", "poweroff", "reset";</code> </pre> <br><p>  We would see the name in the <strong>struct gpioline_info</strong> for each contact, unfortunately, few people name the contacts, even for the distributed SBC. </p><br><h3 id="vozmozhnosti-uapi--nedostupnye-dlya-sysfs">  Uapi features not available for sysfs </h3><br><p>  Now we list the advantages inaccessible to the old interface. </p><br><p>  I consider the main advantage to be the timestamp assigned to the event in the upper half of the interrupt handler.  What is indispensable for applications that are important is the accuracy of measuring the time between events. </p><br><pre> <code class="hljs pgsql"> le-&gt;<span class="hljs-type"><span class="hljs-type">timestamp</span></span> = ktime_get_real_ns();</code> </pre> <br><p>  If the device driver allows, the line can optionally be configured as an open collector ( <strong>GPIOLINE_FLAG_OPEN_DRAIN</strong> ) or an open emitter ( <strong>GPIOLINE_FLAG_OPEN_SOURCE</strong> ), this innovation can be easily transferred to <strong>sysfs</strong> , but this will not be the case with Linus Werli. </p><br><p>  Also, the new api allows you to assign custom labels to each contact during initialization in the <strong>struct gpiohandle_request</strong> field <strong>consumer_label</strong> . </p><br><p>  And finally, it allows you to "read" and "write" immediately a group of states for contacts. </p><br><h3 id="zaklyuchenie-po-sravneniyu">  Conclusion compared </h3><br><p>  Subjectively, <strong>uapi</strong> looks more cumbersome than <strong>sysfs</strong> , but do not forget that we compared management through standard utilities GNU cat and echo and C code, if you compare C code for each of the interfaces, you get about the same in complexity and volume. </p><br><p>  The important point is that when using <strong>sysfs, the</strong> line remains initialized until the user asks for the reverse or before rebooting.  uapi frees the line immediately after closing the file descriptor. </p><br><h2 id="preimuschestva-uapi">  Uapi advantages </h2><br><ul><li>  Saves us syscall (do not forget about the need for lseek after reading gpio / value). </li><li>  Initialization of an array of inputs or outputs. </li><li>  Read or write an array of inputs or outputs. </li><li>  Open drain and Open source </li><li>  Custom tags </li><li>  "Real time nanosecond timestamp" transmitted in the event </li></ul><br><h2 id="kritika-uapi">  Uapi criticism </h2><br><p>  There is no official or unofficial criticism, or I have not found it.  Therefore, we will manage a couple of your own thoughts. </p><br><ul><li>  It is not clear why they avoided push-pull, debounce, and pull-up, pull-down. </li><li>  In <strong>struct gpioevent_data,</strong> it would be nice to add the value parameter with the current line value </li></ul><br><h1 id="kritika-sysfs-gpio">  Criticism sysfs gpio </h1><br><p>  Let's finish with the official criticism of the sysfs interface.  Linus Werli (maintainer in the core of the gpio subsystem and pinctrl) in the comments to the patches put forward the following theses: </p><br><ul><li>  It is impossible to turn off several lines at once in one call </li><li>  For sysfs to work, the corresponding key must be enabled in the kernel configuration </li><li>  In the event of a gpio application crash, the lines remain in the "initialized" state </li><li>  Difficult to find the required line </li><li>  "Sysfs is horribly broken" ¬© </li></ul><br><p>  In general, and, frankly, I believe that sysfs is quite normal for those tasks that are assigned to gpio in userspace.  There is something romantic about it, when people who are not even familiar with the fundamentals of electrical engineering could light the lights with <strong>echo</strong> .  With the help of the new interface, such a direct connection is not felt, since additional utilities for interaction are now required. </p><br><blockquote>  But GPIOs are often used together as a group.  Consider a pair of GPIOs used as an I2C bus;  one line handles data </blockquote><p>  I can‚Äôt say anything about the first thesis, I have never come across such a need, in the end you can immediately initialize the contacts as inputs or outputs in the <strong>device tree</strong> .  I know that this functionality would be useful to those who need <strong>bit-banging</strong> in <strong>user-space</strong> , but here there is one but, on <strong>pure</strong> linux, <strong>bit-banging</strong> is possible except for very low-frequency things, and at least <a href="https://www.kernel.org/pub/linux/kernel/projects/rt/">PREEMPT_RT patch is needed</a> . </p><br><p>  The second thesis is also strange I can not imagine such a saving of space that would be necessary to disable sysfs. </p><br><p>  The third one is even stranger, maybe you just don‚Äôt need to crash the application? </p><br><p>  Regarding the fourth, I can say that nothing fundamentally has changed.  If specified in the platform driver or in the device tree label for gpiochip is true, then the ‚Äúsearch‚Äù is simple, and if they are called ‚Äúdevils-like‚Äù, then the interface will not help here. </p><br><p>  In general, I could not find a clear answer.  I don‚Äôt mind the new interface, I‚Äôm even for it, but such diligent instillation of the old interface is incomprehensible and unpleasant for me personally. </p><br><h1 id="utility">  Utilities </h1><br><p>  For uapi, they are far from being as many as for sysfs. </p><br><h2 id="linux-kernel-gpio-tools">  Linux kernel gpio tools </h2><br><p>  <a href="https://github.com/torvalds/linux/tree/master/tools/gpio">https://github.com/torvalds/linux/tree/master/tools/gpio</a> </p><br><ul><li>  gpio-event-mon - <strong>gpio</strong> line event tracking utility </li><li>  gpio-hammer - enables / disables the line n times with a fixed frequency </li><li>  lsgpio - an example of listing <strong>gpiochip</strong> and lines </li></ul><br><h2 id="libgpiod">  libgpiod </h2><br><p>  <a href="https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/">https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/</a> </p><br><p>  From the author of <strong>gpio-mockup drivers</strong> and <strong>irq-sim</strong> comrade Bartosz'a Go≈Çaszewski. </p><br><p>  Positioned by the author as a library, to facilitate work with gpio through the new interface uapi, also contains a set of useful utilities. </p><br><ul><li>  gpiodetect - gpiochip listing with name, label and number of lines </li><li>  gpioinfo - gpiochip listing with name, offset, label and line status </li><li>  gpioget - read line status </li><li>  gpioset - set the state of the line, and if necessary, keep the line occupied until the specified time, signal or user input has expired </li><li>  gpiofind - finds a line by name and displays the <strong>gpiochipN</strong> device and line offset </li><li>  gpiomon is the same as gpio-event-mon </li></ul><br><h1 id="materialy">  Materials </h1><br><ol><li>  <a href="https://www.kernel.org/doc/Documentation/gpio/gpio-legacy.txt">GPIO Interfaces (legacy)</a> </li><li>  <a href="https://www.kernel.org/doc/Documentation/devicetree/bindings/gpio/gpio.txt">Specifying GPIO information for devices</a> </li><li>  <a href="https://lwn.net/Articles/645810/">A fresh water bottle</a> </li><li>  <a href="https://lwn.net/Articles/646920/">Linus W. comment</a> </li><li>  <a href="https://lwn.net/Articles/730829/">simulated interrupts</a> </li><li>  <a href="https://lkml.org/lkml/2016/3/17/76">GPIO bulk changes for kernel v4.6</a> </li></ol><br><h2 id="videomaterialy">  Video </h2><br><ol><li>  <a href="https://www.youtube.com/watch%3Fv%3DlQRCDl0tFiQ">GPIO for Engineers and Makers, Linus Walleij</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DcdTLewJCL1Y">New GPIO Interface for User Space, Bartosz Golaszewski</a> </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351512/">https://habr.com/ru/post/351512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351498/index.html">Use Reflection.Emit to precompile expressions in MSIL</a></li>
<li><a href="../351500/index.html">SellAnyCar: how auto auctions work in the desert</a></li>
<li><a href="../351504/index.html">Introduction to Angular Modules - Root Module</a></li>
<li><a href="../351506/index.html">Where worlds are created: jobs 22 game developers</a></li>
<li><a href="../351510/index.html">Rather simple and effective algorithm for recognition and tracking of movement</a></li>
<li><a href="../351514/index.html">Restore Microsoft Money online features. Account authentication</a></li>
<li><a href="../351516/index.html">Kotlin's current development</a></li>
<li><a href="../351518/index.html">Listen Top 50 Developer Podcasts</a></li>
<li><a href="../351520/index.html">We count servers, workstations, licenses, spill updates and automate IT processes.</a></li>
<li><a href="../351522/index.html">We invite to MiniAiCup # 2. This time we messed up the AgarIO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>