<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to render a frame Middle Earth: Shadow of Mordor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Middle Earth: Shadow of Mordor was released in 2014. The game itself was a big surprise, and the fact that it was the spin-off of the storyline of the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to render a frame Middle Earth: Shadow of Mordor</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ow/br/se/owbrsedfx4zll9o8sxbxx2fbnza.gif"></div><br>  <a href="https://en.wikipedia.org/wiki/Middle-earth:_Shadow_of_Mordor" rel="noopener">Middle Earth: Shadow of Mordor</a> was released in 2014.  The game itself was a big surprise, and the fact that it was the spin-off of the storyline of the Lord of the Ring universe turned out to be quite unexpected.  The game has gained great success, and at the time of this writing, the company <a href="https://en.wikipedia.org/wiki/Monolith_Productions" rel="noopener">Monolith</a> has already released a sequel - Shadow of War.  The graphics of the game is very beautiful, especially considering that it was released for different generations of consoles, including the Xbox 360 and PS3.  The PC version is pretty well polished, contains additional graphic options and high-resolution texture packs that fully reveal the potential of the game. <br><br>  The game uses a relatively new deferred renderer DX11.  I used <a href="https://github.com/baldurk/renderdoc">Renderdoc</a> to deeply explore the techniques of rendering the game.  When working, the maximum possible graphics parameters (ultra) were used and all possible ‚Äúgadgets‚Äù were included, such as order-independent transparency, tessellation, occlusion in screen space, and various motion blur. <br><a name="habracut"></a><br><h2>  Frame </h2><br>  Here is a frame that we will analyze.  The player is on the wooden platform in the Udun region.  Shadow of Mordor uses mechanics that are similar to the mechanics of games like Assassin's Creed, where you can climb buildings and towers, and then enjoy the surrounding digital landscape from the rooftops. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/325/3e0/73d3253e0323327f95babf989f060f93.jpg" alt="image"></div><br><h2>  Preliminary passage of the depths </h2><br>  Approximately 140 first render calls perform a quick preliminary run to render the largest relief elements and buildings to the depth buffer.  Most objects do not fall into this preliminary passage, but it helps when there are a very large number of draw calls in the game and you can look far into the distance.  Interestingly, a character who is always in the center of the screen and occupies a decent share of screen space does not get into this passage.  As in many other open world games, the engine uses inverse z values.  Such a technique binds the near plane to the value 1.0, and the distant one - to the value 0.0 to improve accuracy at large distances and prevent z-conflicts.  Read more about the accuracy of the z-buffer <a href="https://developer.nvidia.com/content/depth-precision-visualized">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/ba6/57d/181ba657ddc430ee3a892e852cc276e9.png" alt="image"></div><br><h4>  G-buffer </h4><br>  Immediately after this, the G-buffer pass begins, running in approximately 2,700 draw calls.  If you read my <a href="http://www.elopezr.com/castlevania-lords-of-shadow-2-graphics-study/">previous analysis of Castlevania: Lords of Shadow 2</a> or studied other similar articles, then this passage should be familiar to you.  The property of the surfaces is written into a set of buffers, which are then read in the light calculation passes to calculate the reactions of the surfaces to light.  In Shadow of Mordor, the classic deferred renderer is used, but to achieve this goal, a relatively small number of G-buffer render targets is used (3).  For comparison: The Unreal Engine in this pass uses 5-6 buffers.  G-buffer has the following scheme: <br><br><h5>  Normal buffer </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="#0000ff">B</font></strong> </td><td>  <strong>A</strong> </td></tr><tr><td>  <strong>Normal.x</strong> </td><td>  <strong>Normal.y</strong> </td><td>  <strong>Normal.z</strong> </td><td>  <strong>ID</strong> </td></tr></tbody></table><br>  The normal buffer stores normals in world space in the ‚Äú8 bits per channel‚Äù format.  This is barely enough, and sometimes not enough at all to describe smoothly varying flat surfaces.  If you look closely, it can be seen in some puddles in the game.  The alpha channel is used as an ID to mark various types of objects.  For example, I found out that 255 refers to a character, 128 to an animated part of the flag, and the sky is marked ID 1, because later these identifiers are used to filter it at the adding stage (the sky gets its own radial bloom). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/jf/y8/zajfy84cg-abqarjiybgm3qcztw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9k/aq/4v/9kaq4vempyj-n14_kdfte3d51ss.png"></div><br>  <i>In the original article, these and many other images are animated for greater clarity, so I recommend to look there.</i> <br><br><h5>  Albedo Buffer </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="#0000ff">B</font></strong> </td><td>  <strong>A</strong> </td></tr><tr><td>  <strong>Albedo.r</strong> </td><td>  <strong>Albedo.g</strong> </td><td>  <strong>Albedo.b</strong> </td><td>  <b>Cavity Occlusion</b> </td></tr></tbody></table><br>  The albedo buffer stores all three components of albedo and small-scale occlusion (sometimes called the cavity occlusion), which is used for shading small details that cannot be achieved with a shadow map or post-processing in screen space.  It is mainly used for decorative purposes, such as tears and folds on clothes, small cracks in wood, small patterns on Talion's clothes, etc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t6/ul/bz/t6ulbzqtlw3ncodrlnd49uxtmwa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/28/52/lr/2852lrdq75bxtqpkywvutfsm4se.png"></div><br>  When processing enemies in a shader, albedo takes into account the texture of the blood (interestingly, Talion never gets visible wounds).  The blood texture is the input to the rendering stage of the clothing and body of the enemies, but it does not set the color of blood, which is the input to the constant buffer, but determines the blood multipliers / levels to control the amount of blood displayed.  The normal orientation is also used to scale the effect, allowing you to control the direction of the blood spatter.  Then, albedo is essentially set off by the brightness of the wounds received by the enemy, taken from the appropriate place on the blood map, and also modifies other properties, such as specular, to obtain a convincing blood effect.  I was not able to find the part of the frame in which the map is rendered, but I assume that they are recorded right at the beginning of the frame when the sword is affected and then used here. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1y/_r/rt/1y_rrtgi8bsuryvjmqmpdvzwpfk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/tv/nu/mitvnumojb0zx4qhzohrgrj810e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/wx/t7/qpwxt7y4r-k3ugakdasysx1vtvm.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6d/-r/lz/6d-rlzgi7fvdep6xrxnakmjp9yg.png"></div><br><h5>  Specular buffer </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="#0000ff">B</font></strong> </td><td>  <strong>A</strong> </td></tr><tr><td>  <b>Roughness</b> </td><td>  <b>Specular Intensity</b> </td><td>  <b>Fresnel</b> </td><td>  <b>Subsurface Scattering Factor</b> </td></tr></tbody></table><br>  The specular buffer contains other surface properties that can be expected in games, such as roughness (this is not really roughness, but a scaled degree of specular, but it can be interpreted in this way), specular intensity, which scales albedo to get the right color specular, reflectivity factor (commonly referred to as F0 in the literature, because it is the input to the Fresnel mirror response) and the subsurface scattering component (subsurface scattering).  The latter component is used to illuminate translucent materials, such as thin fabric, plants and leather.  If we later dive into the study of the lighting shader, we find that the variation uses the <a href="https://seblagarde.wordpress.com/2011/08/17/hello-world/">normalized specular model according to Blinn-Fong</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/rv/8c/qxrv8c9xk-4-akibiogsgnvxszw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wv/xw/_f/wvxw_f6h-5vgmu6cvlucuum3sei.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/f3/v1/fbf3v1y8ardyfkjtshlv8zf5ld8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/zq/lz/qlzqlzbbxwy_mlx05pwxwpxmrga.png"></div><br><h5>  Deferred decals </h5><br>  As we saw above, the Shadow of Mordor displays in some detail traces of blood on wounded characters.  When Talion swings his sword, the entourage also receives his share of dark orcish blood.  However, another technique is used for the environments - <a href="https://mtnphil.wordpress.com/2014/05/24/decals-deferred-rendering/">deferred decals</a> .  This technique consists of projecting a set of flat textures onto the surface of what was previously rendered.  Thus, the contents of the G-Buffer are replaced with this new content before executing the lighting pass.  In the case of blood, simply bloody sprays are sufficient, and when rendering many decals in turn, a rather gloomy landscape is quickly created. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8_/zo/no/8_zonoux0rx6h_cemftpprebcke.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/sc/qn/pkscqng3m2s0c2hj-e-fs1eonis.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/a4/uf/rs/a4ufrsgki8blucgm4g8zq3n95ha.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dj/jl/3c/djjl3c5s2dsimxwtoim-c5vk3rg.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wj/hj/cb/wjhjcbcfdu0ts1kpnmh_2_tvhdq.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/tk/fi/8rtkfinzlyym0jweyx0gpizv4zs.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/ns/pw/uhnspwmomqsrlnoctsokx8q878a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/7m/70/di7m700h63pqtmaiydgrezyt0w4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/ky/sz/8tkyszkhinic56jqebsteeudram.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0a/tu/kj/0atukjo4vjzv3djehm6sttjhqps.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-5/vm/ja/-5vmjatrsxyfdjhqm5nhsmu_vxw.png"></div><br>  The last thing rendered in the G-Buffer Pass is the sky, a very high resolution sky texture (8192 √ó 2048) in the HDR BC6H format.  I had to perform a slight tonal correction, because in HDR all colors are too dark. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/6b2/dda/95a6b2dda3a632aebe8fc902f143232d.jpg" alt="image"></div><br><h3>  Tessellation </h3><br>  A very interesting "trick" of the game (if it is included) is tessellation.  It is used for many different things, from relief to character rendering (as well as props and character objects).  Here, tessellation does not subdivide the low poly mesh, but creates polygons from a point cloud, applying the necessary degree of subdivision depending on the criteria of the level of detail, for example, from the distance to the camera.  An interesting example is the Talion cloak, which is transmitted to the GPU as a point cloud (after physics simulation), and the tessellation shader recreates polygons. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1i/jf/3i/1ijf3ikncscrhyvhjyyan6kdx80.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wj/fp/il/wjfpil_rw7_t1z7pxrfntobcrse.png"></div><br><h3>  Order-independent transparency </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b78/f09/897/b78f09897b7ed45f990f51f91291c967.png"></div><br>  One of the first things that struck me with its strangeness is the passage of hair treatment, because it performs a very complex special shader.  In the graphics options mentioned option OIT (Order-Independent Transparency) for the hair, that is, it should be it.  First, it performs output to a separate buffer and counts the total number of overlapping transparent pixels, while simultaneously maintaining the properties in a ‚Äúdeep‚Äù structure, similar to a G-buffer.  Later, another shader sorts the individual fragments according to their depth.  It seems that the arrows are also rendered in this way (probably, their feathering requires proper sorting).  This is a very subtle effect that does not add much graphic differences, but still it is an interesting detail.  Here is a simple example: the image above displays the number of overlapping fragments (the redder, the more fragments).  Normal transparency is still sorted into CPU and rendered as traditional alpha.  Only individual entities enter the OIT pass. <br><br><h3>  Shadows of mordor </h3><br>  SoM has many sources of shadows.  In addition to traditional shadow maps of dynamic light sources, SoM uses dual-channel ambient occlusion in screen space, microscale occlusion created for almost all objects in the game, and an occlusion texture similar to a height map with a top view. <br><br><h5>  Occlusion in screen space </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cb/58c/fc5/2cb58cfc57777d65a15af4813977c962.png"></div><br>  The first pass renders with G-buffer ambient and specular occlusion in screen space.  The shader itself is a huge unfolded loop, a sampling and full-size depth map, and a previously reduced average depth map, looking for adjacent samples in a given pattern.  It uses a 4 √ó 4 square texture to select pseudo-random vectors in search of occlusion sources.  It renders a noisy occlusion buffer, which is then smoothed out by a simple blur in two passes.  The most interesting feature here is that there are two different channels of occlusion: one is used as specular occlusion, and the other as diffuse occlusion.  In standard implementations, SSAO computes one channel that applies to all baked lighting.  It also reads the SSAO card for transmission in the directional lighting passage, where it is applied. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/xf/kj/rexfkjx49htyufzecfeg2n7lsau.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dl/va/nz/dlvanzzg8bpcqughsrout8kaxlg.png"></div><br><h5>  Shadow maps </h5><br>  The next event is the rendering of the shadow map.  Since the action of the game mainly takes place in open spaces, most of the light and shadows are taken from the main directional light.  It uses <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416307(v%3Dvs.85).aspx">cascading shadow maps</a> (a variation of which is <a href="http.developer.nvidia.com/GPUGems3/gpugems3_ch10.html">parallel divided shadow maps</a> ), a fairly standard shadow overlay technique at long distances, which consists of rendering the same scene from a single point of view of the light source for different areas of space.  Usually, shadow maps far from the camera coverage area are either at greater distances or have a lower resolution than the previous ones, essentially reducing the resolution in areas where details are still not required due to the fact that the geometry is too far away.  In this scene, the game renders three cascades of shadows 4096 √ó 4096 (in fact, there is room for four in the game).  The upper cascade is very close to Taleon, and the lower one includes mountains and objects very far from the camera.  When working with shadows, the game uses the same trick with the inverse z coordinate as in the depth map. \ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/7bc/a65/3477bca65b8cff92dfcfd68c9d66b8a8.jpg"></div><br><h5>  Shadow buffer </h5><br>  The next step is creating the shadow buffer.  This is a single-channel texture, based on occlusion information from previous shadow maps, the coding shading factor in the interval [0, 1].  To create a smoothness around the edges, the shadow map is sampled 4 times using the state of a special bilinear sampler, which receives 4 samples and compares them with a given value (this is called <a href="http.developer.nvidia.com/GPUGems/gpugems_ch11.html">Percentage Close Filtering</a> ).  Getting multiple samples and averaging their results is often called <a href="http://developer.download.nvidia.com/shaderlibrary/docs/shadow_PCSS.pdf">Percentage Closer Soft Shadows</a> .  In addition to reading the shadow map, the last component of the specular buffer (i.e., subsurface scattering coefficient) is also sampled, which is multiplied by the light bleed factor.  It seems that it is necessary to eliminate the shading from these objects so that a little more light passes through them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7f/b55/63f/b7fb5563faae1553e0f970374ee0b774.jpg"></div><br><h5>  Texture of directed projections </h5><br>  Another source of light and shadows is a top view texture, which is sampled by a directional light source.  This is the hue of the color added to the color of the directional light source plus the effect of global shading applied to the directional light.  It seems that some of them were created manually on top of an automatically generated level map with a top view.  It seems that the edges of the shadows for static geometry are manually corrected (perhaps to avoid conflicts with a real shadow map), and some parts also appear a little tinted by hand.  Probably, the task of this texture is the low-cost addition of large-scale ambient occlusion and light imitations of global illumination in addition to directional lighting.  The images below show shade, occlusion, and the product of both factors, giving us an idea of ‚Äã‚Äãwhat the final color mask looks like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6v/vf/6a/6vvf6aaf5khdrbclmwpzp9_faka.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/fs/fe/7efsferrjbdtsu9megpk0gtfidc.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/bk/sv/sdbksv3a4jlkgzxui4nvl-suylq.png"></div><br>  The result of all lighting passes is saved in the render target format R11G11B10F.  This is how the result looks like.  I performed a tonal correction of the results in order to make the impact of directional lighting on the level more obvious. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/28e/a63/f2a28ea6372642667b3778dfc32b193f.jpg"></div><br>  All distant mountains (not shown in the image above) are also illuminated with directional light, but they are highlighted as a separate case so that you can better control the lighting.  Some are scaled, but those further are actually flat textures (impostors) with cleverly created normals and albedo maps.  They have special sources of directional lighting, affecting only the mountains. <br><br><h3>  Static lighting </h3><br>  Shadow of Mordor uses a very memory-demanding implementation of static lighting, which uses very large volumetric textures.  The image below shows the three static textures of the lighting volume used to diffuse lighting of a portion of this area.  Each of them is a huge compressed texture of 512x512x128 BC6H, that is, they occupy 32 MB for texture or 96 MB in general (we play with the maximum quality settings).  The texture of the color indicates the intensity entering the voxel.  The other two denote the strength or magnitude of this intensity along all six directions xyz and -xyz, and the normal is used to select the three components (positive or negative xyz, those that most coincide with the normal).  Having constructed this vector, we take its vector product to the square of the normal, and this becomes the scaling factor for intensity.  The formula looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l9/yw/vk/l9ywvkgxuoti8bbppke_2c8o068.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/j3/uf/ezj3ufolhefyqxafjqskci0msho.png"></div><br>  Static Light Volumes also render a cubic map for specular lighting, which is probably captured in the center of the SLV.  Interestingly enough, volume textures store HDR values ‚Äã‚Äãcompressed in BC6H, and cubic maps are stored in BC3 (DXT5) format, which cannot store floating point values.  To compensate for this limitation, the alpha channel retains its brightness, which then scales from 1-10.  This is a slightly strange decision and for me it looks more like a legacy implementation.  Do not forget that the game was released for the previous generation of consoles, which do not support the new formats of HDR textures. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k3/qo/z-/k3qoz-zblorjdxi7jyqthripztg.png"></div><br>  The frames below show the ‚Äúbefore and after‚Äù results, taking into account the effects of the average image.  For visualization, I performed a tone correction. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4i/iq/yo/4iiqyosjg2tmdud840rxbhstofa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/su/of/cd/suofcd-ls4myfuivd5vqb9ykbgi.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/37/rq/wb/37rqwb76ngards_rywaxhb_x9xw.png"></div><br><h3>  Atmospheric fog </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9af/086/c47/9af086c474cada9250daae007ec3c8bc.jpg"></div><br>  In Shadow of Mordor there is a weather system and time of day, thanks to which the sun shines or it rains during the game in Mordor.  This system is controlled by the sum of the components, and one of the most important is fog.  Shadow of Mordor uses a fairly simple but physically valid model of atmospheric fog, including <a href="https://www.youtube.com/watch%3Fv%3DtwSg2zbjjnA">Rayleigh's</a> single scattering, as well as spherical particle scattering (Mie scattering). <br><br>  It begins by calculating the position of the camera relative to the <a href="https://en.wikipedia.org/wiki/Earth_radius">center of the earth</a> .  Several trigonometric formulas allow us to determine where the camera is in the atmosphere, where the pixel is, and how far the beam has traveled in the atmosphere for a given maximum atmosphere height.  In our case, the atmosphere is given a height of 65,000 meters above the surface of the planet.  Taking this information into account, the Rayleigh and spherical particle coefficients are used to calculate the types of fog particle densities and its colors.  These densities obscure the already shadowed pixels, scattering the light that enters the camera from the shadowed surface, and contributes to the fog.  When simulating such a scattering, the brightness and direction of the sun are taken into account. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/at/id/yeatidzdiemga1gntnm1zg9uz8k.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zj/39/zr/zj39zryuhmwdyadmcp0nb_g1uz8.png"></div><br><h3>  Exposure and tone correction </h3><br>  When calculating the shutter speed, a fairly standard approach is used: consistently reducing the resolution of the brightness buffer calculated from the main HDR-color buffer into a chain of textures, each of which is half the size of the previous texture, starting with a 1/3 texture from the main frame buffer.  With this decrease in resolution, 4 samples are taken, averaging the values ‚Äã‚Äãof the neighboring pixels, that is, after converting all the average values ‚Äã‚Äãinto a single texel, the final result becomes the average brightness.  After the texture reaches a size of 16 √ó 9 texels, a compute shader runs, summarizing all the remaining texels.  This value is immediately read in the tone correction pass to change the brightness values. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ig/bi/h4/igbih41dc2x9aytucfgq1z_iuye.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/os/gw/t8/osgwt8co0pqgvomovsydsemapuw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/bc/qv/qhbcqvqxy5hgvtn9x0c9kd1an6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g-/dw/fm/g-dwfm48oqtvuu1bizc1sikm7sq.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zg/8w/oz/zg8wozwpviq0nnt4-kef9b9azis.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/56/ik/dc/56ikdcoixmrbo0whghswhxdzxhk.png"></div><br>  In the case of tone correction, the variant operator Reinhard is used, the optimized formula of which can be found <a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">here</a> and <a href="http://duikerresearch.com/2015/09/filmic-tonemapping-for-real-time-rendering/">here</a> .  In the code on hlsl it will look like this: <br><br><pre><code class="cpp hljs">float3 hdrColor = tex2D(HDRTexture, uv.xy); hdrColor *= exposureValue; <span class="hljs-comment"><span class="hljs-comment">// This was calculated by the compute shader in the luminance downsampling pass float3 x = max(0.0, hdrColor - 0.004); float3 finalColor = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);</span></span></code> </pre> <br>  If we plot this curve, we will see that this operator discards 10% of the white values ‚Äã‚Äãeven at the input value 2.0, while at the same time forcing a small part of the lower interval to be completely black.  This creates an unsaturated, dark image. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/ea1/097/cc2ea10970239fb761b995496c049a8b.jpg" alt="image"></div><br><h3>  Alpha Stage </h3><br>  The alpha stage is a bit unusual because it renders objects directly into the LDR buffer.  Other games will render them in the HDR buffer, so that they can participate in the passage of the excerpt.  Anyway, the previously calculated brightness texture is limited to all objects lit by alpha (in some cases, for example, for objects emitting light, the shutter speed is calculated using shader constants rather than texture search), and therefore the shutter speed is applied when drawing automatically, and not executed in postprocessing.  A very specific use case for the alpha game is to switch to the ghost mode (in it, the ghost of Celebrimbor, who forged the all-powerful rings in the LOTR universe, is rendered on top of the player‚Äôs character; thus, the game shows that he is always there, albeit invisible).  The game passes into the meshes of both characters several parameters that control the opacity and allow the game to partially obscure Talion and gradually show Celebrimor.  Other objects in the game in ghost mode also render ghost versions over opaque objects, such as enemies and towers.  Here is another scene with the transition to the ghostly world. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ux/ca/zs/uxcazsok9pqzuusfrb__dutdphw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6g/1c/9e/6g1c9esdqit50db_mbck516ma-0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/dq/ss/f_dqss-avlzlyrb4s6_z6kqog0e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uw/yy/va/uwyyvakydfnsksy49ntfltpbwp8.png"></div><br><h3>  Rain </h3><br>  In the main frame, which we investigated, there is no rain, but the weather is such an important part of the game that I would like to mention it here.  It is generated and simulated in the GPU, and rendered right at the end of the alpha stage.  A compute shader runs, simulating and writing positions to the buffer.  These positions are taken by another shader, which with the help of the instanced indirect call renders as many copies of quads as the number of positions was calculated in the previous pass.  Vertex shader has a simple quad, which, if necessary, is deformed and turns to the camera.  So that the rain does not penetrate the surfaces, the vertex shader also reads elevation maps from the top view, which allows you to deflect all drops below the overlapping surface.  This elevation map is rendered right at the beginning of the frame.  The same vertex shader tells the pixel shader where to get the sample from the drop texture;  if the drop is close to the surface, it selects the area of ‚Äã‚Äãthe texture containing the spray animation.  In addition, rain drops are performed in a pixel shader to calculate fog for perfect blending with the rest of the scene.  Here is a screenshot from the same point of view on a rainy day. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/yv/ds/xvyvds_w25ybjxilgvr5crbcpo4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3c/ox/ax/3coxaxhejifprppkaheiahszfcm.png"></div><br>  When the rain effect is activated, the specular buffer is globally modified to create wet surfaces, and rain waves are rendered into the normal buffer.  Animation is hidden, so only one frame of looped animation is used.  The normal buffer shown below is modified to show the waves rendered to the buffer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ur/du/mz/urdumzhuebf1o2pnud_b2ztlfik.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p3/cv/t_/p3cvt_qq7vo9txgwycf7l2oec2y.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/3d/u3/vc3du3ytthqfsw1h7vwzr0tfxom.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6y/tk/rk/6ytkrkj0w38kvccrtrjpey95c_w.png"></div><br><h3>  Lens Flares and Bloom </h3><br>  After the alpha rendering is complete, lens flares are rendered on top.  A series of biased quads are rendered, starting from the point where directional light comes from (in our case, the sun).  Immediately after this, the bloom is executed.  This is a fairly standard technique, which consists of a series of reduced in size and blurry textures containing pixels whose brightness exceeds a certain threshold.  Two bloom passes are used, common with Gaussian blur for the whole scene and a special radial blur applied only to the sky.  Radial blur is one of the operations in which a special ID from the G-buffer of normal maps is used, because only sky pixels are taken into account.  As a bonus, this blur will sample the depth map and can create low-cost <a href="https://en.wikipedia.org/wiki/Crepuscular_rays">twilight rays</a> .  Since at this stage we are working with the LDR buffer, the bloom threshold value differs from the value from the HDR carpet (values ‚Äã‚Äãabove the threshold, usually 1.0, lead to the calculation), and this means that the bloom obtained from it is a bit limited.  In any case, this is a game for the benefit and here are the results.  In the pictures below, the bloom mip-textures look a bit strange, because each pixel is scaled to the brightness contained in the alpha channel.  This brightness was calculated earlier, at the stage of tone correction.  In the final compositing, bloom is computed as <strong>bloom.rgb ¬∑ bloom.a ¬∑ bloomScale</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h3/2y/ra/h32yra8lvz_-pxsab9raxyfobei.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/le/2k/dx/le2kdxxuaqtjrdnhdvxfobubyhw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jb/kz/mk/jbkzmkd2ans3vxvs_we9eowudvs.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xs/gs/dg/xsgsdgnvhckxgckfhs7k4hvpc7u.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v3/yr/hh/v3yrhhxazolya5nu8fn7id66p6k.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q8/r1/wl/q8r1wlekxf0tae6ivo6bfyjngie.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gw/5c/tj/gw5ctjh8owpukokne73nskb4n48.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8k/te/sg/8ktesgsr6ser_l6ssaorfcpniww.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j6/u6/ts/j6u6tsvqcjuwqqzepsfeogf330i.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/tf/vg/eetfvgkcuahvbbonuhfnpinh32w.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m-/zw/bc/m-zwbcp4qvnr69vn1unq1clh3ws.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/ta/-s/eita-ssnu2cqzwkspcrjan42-ua.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/db/cb/cs/dbcbcsoo_znq2ex30ixasi-c8le.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i4/ja/ro/i4jarols6px4f0nnbai-rk5r87u.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/na/ag/mj/naagmjq8e75kxcxmyhberqpslag.png"></div><br><h3>  Antialiasing + Depth of Field </h3><br>  There is nothing special to say about these two operations; industry standard approaches are used.  A simple FXAA anti-aliasing pass is performed immediately after bloom compositing with an LDR image, and the depth of field is performed directly behind it.  For depth of field, the game renders two reduced blurred versions of the final buffer.  The pixel depth is then used to blend the blurred and normal images, which has a defocusing effect.  For the sake of clarity in this capture, I exaggerated the effect of depth of field.  The game has a built-in screenshots mode that allows you to easily adjust these conditions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ug/et/zf/ugetzfmh2jbbcpvrzb1e6dpwbhu.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p_/x4/fk/p_x4fkleolfxxnpvs9vnveywipy.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/vg/bp/bivgbpqa_nmzkx4zgiuzmu3nm6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w2/vn/hg/w2vnhg6eoxe92rjat51qf65pggo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uf/0g/kj/uf0gkjnripqq4ctkcpsremqrqnk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/k5/z4/bxk5z47piwcgchqepehqpyypwgu.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/dc/xq/uedcxqx7svcjyq6g0-tp4uc1gho.png"></div><br><h3>  Motion blur </h3><br>  Motion blur consists of two passes.  First, data from the previous and current camera orientation is transferred to the full-speed buffer.  In this case, the two channels of the texture are filled with speed in the screen space.  Now channel r contains the magnitude of the pixel change in the horizontal direction of the screen, and channel g contains the vertical one.  This is how radial stripes are obtained when moving the camera.  The character is rendered anew, this time filling the blue channel based on its current and previous postures, as is the case with the camera.  The blue channel is used to mark whether visualization should be rendered.  The alpha channel is also filled with a constant value (0.0598), but I have not investigated either its value or its goals.  The resolution of the velocity buffer decreases to a very small texture by averaging a relatively wide neighborhood of the velocities in the original texture.  In the last pass, this gives each pixel a rough idea of ‚Äã‚Äãwhat the blur radius will be in the current blur pass. <br><br>  The blur pass then reads out both velocity textures, a depth map, the original color buffer, and a noise texture.  The latter is used to hide the effect of the mirror image, which can occur with this type of blur with a large radius.  Then, the image buffer is sampled several times in the direction indicated by the velocity buffer, the colors are averaged, which causes the image to be blurred in the direction of the motion vectors.  This effect also scales in accordance with the frame rate at which the game works.  For this capture, I had to limit the game to 30fps, because at 60fps and above it is barely noticeable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zn/4r/-7/zn4r-7rgnvx9zuh6asjnzqxknno.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/x_/yu/hrx_yug350grzjbnn6r6d9b7spa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/94/i5/bc/94i5bcpjozmzuykcwfh9vksqjk8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/mr/zo/n7mrzoppnprexpqv5h7uj-xobvu.png"></div><br><h3>  Color correction </h3><br>  The final pass color correction is performed using the "color cubes".  A color cube is a 3D texture, the rgb components of which are attached to the xyz coordinates of the texture.  These xyz coordinates contain the color with which we must replace the original color.  In our case, the lookup table (LUT) is neutral (i.e. the coordinates and color contain the same value), so I modified the same scene using the presets that the game provides in the camera editor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-i/dk/rd/-idkrdltmru5ndotkyzhmdbwth4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/az/-x/it/az-xitiqseycg8t_mz0kuhjxh1m.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/p0/ds/emp0dsyarj3nhdi-s453p0p0rsa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1e/9q/fa/1e9qfapyuezjdafa8licevb6csu.png"></div><br><h3>  Final shot </h3><br>  After the creation of the main frame is completed, the UI is rendered in a separate buffer.  This ensures that regardless of the UI size selected for the back buffer, it will always be rendered clear and beautiful in the native window size, while the game can change the resolution if necessary to ensure speed.  At the end, both textures are mixed together based on the alpha data of the UI, and then rendered to the final frame buffer, which is ready for display on the screen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cv/ba/t9/cvbat95whbpymp0cfpnjmohp_oo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i0/y0/qm/i0y0qmb9x6liyqlpcd4vs2rli3y.png"></div><br>  I hope you enjoyed my analysis.  I want to thank <a href="http://www.adriancourreges.com/" rel="noopener">Adrian Correge</a> for the amazing work that inspired me to study graphics, as well as the team at <a href="https://www.lith.com/">Monolith</a> for this truly unforgettable game. </div><p>Source: <a href="https://habr.com/ru/post/430518/">https://habr.com/ru/post/430518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430506/index.html">The dark art of resurrection: how to recover data from damaged media</a></li>
<li><a href="../430508/index.html">DevOps: what is it really</a></li>
<li><a href="../430510/index.html">How to write code that will be understood by everyone?</a></li>
<li><a href="../430512/index.html">How do freelancers live: do not work with ‚Äúall-knowing‚Äù clients and allow yourself to grow</a></li>
<li><a href="../430514/index.html">Blockchain Charity - DataArt won the Malta Blockchain Summit</a></li>
<li><a href="../430520/index.html">Meet Spring Data MongoDB</a></li>
<li><a href="../430522/index.html">Do you need a corporate culture in IT? Confession brand manager of the Krasnodar studio Plarium</a></li>
<li><a href="../430524/index.html">Neural Network Architecture</a></li>
<li><a href="../430526/index.html">Slot machines: where did they come from in the USSR and how are they arranged</a></li>
<li><a href="../430528/index.html">Programming with PyUSB 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>