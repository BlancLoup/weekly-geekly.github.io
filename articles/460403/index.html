<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Advantages and disadvantages of HugePages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The translation of the article was prepared for students of the Linux Administrator course. 



 Earlier, I talked about how to test and enable the us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Advantages and disadvantages of HugePages</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/-w/lp/l5/-wlpl5yurwmjrqrh5ufgru7fejm.png"></p><br><p>  <em>The translation of the article was prepared for students of <a href="https://otus.pw/NPlx/">the Linux Administrator</a> course.</em> </p><br><hr><br><p>  Earlier, I talked about how to test and enable the use of Hugepages in Linux. <br>  This article will be useful only if you really have where to use Hugepages.  I have met many people who are deceived by the prospect that Hugepages will magically improve performance.  Still, hugepaging is a complex topic, and if used improperly, it can reduce performance. <a name="habracut"></a></p><br><h1 id="chast-1-proveryaem-chto-hugepages-vklyucheny-v-linux-original-zdeshttpstechoverflownet20130801checking-if-hugepages-are-enabled-in-linux">  Part 1: Verify that hugepages are included in Linux (the original is <a href="https://techoverflow.net/2013/08/01/checking-if-hugepages-are-enabled-in-linux/">here</a> ) </h1><br><p>  <strong>Problem:</strong> <br>  You need to check if HugePages are enabled on your system. </p><br><p>  <strong>Decision:</strong> <br>  It is quite simple: </p><br><pre><code class="plaintext hljs">cat /sys/kernel/mm/transparent_hugepage/enabled</code> </pre> <br><p>  You will get something like this: </p><br><pre> <code class="plaintext hljs">always [madvise] never</code> </pre> <br><p>  You will see a list of available options ( <em>always, madvise, never</em> ), while the current active option will be enclosed in parentheses (default <em>madvise</em> ). </p><br><p>  <em>madvise</em> means that <code>transparent hugepages</code> enabled only for memory areas that explicitly request hugepages using <a href="http://linux.die.net/man/2/madvise">madvise (2)</a> . </p><br><p>  <em>always</em> means that <code>transparent hugepages</code> are always on and for all processes.  This usually improves performance, but if you have a use case where many processes consume a small amount of memory, then the total memory load may increase dramatically. </p><br><p>  <em>never</em> means that <code>transparent hugepages</code> will not turn on even when requested using madvise.  To learn more, consult your Linux kernel <a href="http://lwn.net/Articles/423592/">documentation</a> . </p><br><h4 id="kak-izmenit-znachenie-po-umolchaniyu">  How to change the default value </h4><br><p>  <strong>Option 1</strong> : Directly change <code>sysfs</code> (after a reboot, the parameter will return to the default value): </p><br><pre> <code class="plaintext hljs">echo always &gt;/sys/kernel/mm/transparent_hugepage/enabled echo madvise &gt;/sys/kernel/mm/transparent_hugepage/enabled echo never &gt;/sys/kernel/mm/transparent_hugepage/enabled</code> </pre> <br><p>  <strong>Option 2</strong> : Change the system default by recompiling the kernel with the changed configuration (this option is recommended only if you are using your own kernel): </p><br><ul><li>  To set always to default, use: <br><pre> <code class="plaintext hljs">CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS=y # Comment out CONFIG_TRANSPARENT_HUGEPAGE_MADVISE=y</code> </pre> </li><li>  To set madvise by default, use: <br><pre> <code class="plaintext hljs">CONFIG_TRANSPARENT_HUGEPAGE_MADVISE=y # Comment out CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS=y</code> </pre> </li></ul><br><h1 id="chast-2-preimuschestva-i-nedostatki-hugepages">  Part 2: Advantages and disadvantages of HugePages </h1><br><p>  We will try to selectively explain the advantages, disadvantages and possible errors when using Hugepages.  Since a technologically complex and pedantic article is likely to be hard for people to understand who are deceived, considering Hugepages to be a panacea, I will sacrifice accuracy for the sake of simplicity.  Just keep in mind that many topics are really complex and therefore greatly simplified. </p><br><p>  Please note that we are talking about 64-bit x86 systems running on Linux, and that I simply assume that the system supports transparent hugepages (since it is not a drawback that hugepages are not replaced), as it happens in almost any modern Linux environment. </p><br><p>  <em>In the links below I will attach more technical descriptions.</em> </p><br><h4 id="virtualnaya-pamyat">  Virtual memory </h4><br><p>  If you are a C ++ programmer, you know that objects in memory have specific addresses (pointer values). </p><br><p>  However, these addresses do not necessarily reflect the physical addresses in memory (addresses in RAM).  They are addresses in virtual memory.  The processor has a special MMU (memory management unit) module that helps the kernel match virtual memory with physical location. </p><br><p>  This approach has many advantages, but the most basic of them are: </p><br><ul><li>  Performance (for various reasons); </li><li>  Isolation of programs, that is, none of the programs can read from the memory of another program. </li></ul><br><h4 id="chto-takoe-stranicy">  What are pages? </h4><br><p>  Virtual memory is divided into pages.  Each individual page points to a specific physical memory, it may indicate an area in RAM, or it may indicate an address assigned to a physical device, such as a video card. </p><br><p>  Most of the pages you are dealing with point to either RAM or are swapped, that is, they are stored on a hard disk or SSD.  The kernel controls the physical layout of each page.  If you access a spoofed page, the kernel stops the thread that is trying to access the memory, reads the page from the hard disk / SSD into RAM, and then continues the thread. </p><br><p>  This process is transparent to the stream, that is, it does not necessarily read directly from the hard disk / SSD.  The size of normal pages is 4096 bytes.  Hugepages size is 2 megabytes. </p><br><h4 id="bufer-associativnoy-translyacii-tlb">  Associative translation buffer (TLB) </h4><br><p>  When a program accesses a page of memory, the CPU must know which physical page to read data from (that is, have a virtual address card). </p><br><p>  The kernel has a data structure (page table) that contains all the information about the pages used.  Using this data structure, you can map a virtual address to a physical address. </p><br><p>  However, the page table is quite complex and slow, so we simply cannot analyze the entire data structure every time when a process accesses memory. </p><br><p>  Fortunately, there is a TLB in our processor that caches the mapping of virtual and physical addresses.  This means that despite the fact that we need to analyze the page table during the first attempt to gain access, all subsequent references to the page can be processed in the TLB, which ensures quick work. </p><br><p>  Since it is implemented as a physical device (which makes it primarily fast), its capacity is limited.  Therefore, if you want to access more pages, TLB will not be able to store a match for all of them, and as a result your program will run much slower. </p><br><h4 id="hugepages-prihodyat-na-pomosch">  Hugepages come to the rescue </h4><br><p>  So what can we do to avoid a TLB overflow?  (We assume that the program still needs the same amount of memory). </p><br><p>  This is where the Hugepages appear.  Instead of 4096 bytes, requiring just one TLB entry, one TLB entry can now indicate a whopping 2 megabytes.  We will assume that the TLB has 512 entries; here, without Hugepages, we can match: </p><br><pre> <code class="plaintext hljs">4096 b‚ãÖ512=2 MB</code> </pre> <br><p>  Whereas we can compare with them: </p><br><pre> <code class="plaintext hljs">2 MB‚ãÖ512=1 GB</code> </pre> <br><p>  That is why Hugepages is awesome.  They can improve performance without much effort.  But there are significant reservations. </p><br><h4 id="podmena-hugepages">  Substitution Hugepages </h4><br><p>  The kernel automatically keeps track of how often each page of memory is used.  If there is not enough physical memory (RAM), the kernel will move less important (less commonly used) pages to the hard disk in order to free up some of the RAM for more important pages. <br>  In principle, the same goes for Hugepages.  However, the kernel can swap only whole pages, not individual bytes. </p><br><p>  Suppose we have this program: </p><br><pre> <code class="plaintext hljs">char* mymemory = malloc(2*1024*1024); //     Hugepage! //  mymemory -  //    , //      mymemory // ... //       putchar(mymemory[0]);</code> </pre> <br><p>  In this case, the kernel will need to replace (read) as much as 2 megabytes of information from the hard disk / SSD only for you to read one byte.  As for ordinary pages, from a hard disk / SSD it is necessary to read only 4096 bytes. </p><br><p>  Therefore, if the hugepage is replaced, its reading is faster only if you need to access the entire page.  This means that if you are trying to access randomly to different parts of the memory and just read a couple of kilobytes, you should use regular pages and do not worry about anything else. </p><br><p>  On the other hand, if you need to access much memory consistently, hugepages will increase your productivity.  However, you need to check it yourself (and not using the example of abstract software) and see what works faster. </p><br><h4 id="allokaciya-v-pamyati">  Memory allocation </h4><br><p>  If you write in C, you know that you can request arbitrarily small (or almost arbitrarily large) heap memory with <code>malloc()</code> .  Suppose you need 30 bytes of memory: </p><br><pre> <code class="plaintext hljs">char* mymemory = malloc(30);</code> </pre> <br><p>  It may seem to the programmer that you are ‚Äúrequesting‚Äù 30 bytes of memory from the operating system and returning a pointer to some virtual memory.  But in fact, <code>malloc ()</code> is simply a C function that calls the inside of the <a href="https://en.wikipedia.org/wiki/Sbrk">brk and sbrk functions</a> to request or free memory from the operating system. </p><br><p>  However, it is inefficient to request more and more memory for each location;  Most likely, a memory segment has already been freed <code>(free())</code> , and we can reuse it.  <code>malloc()</code> implements quite complex algorithms for reusing freed memory. </p><br><p>  At the same time, everything happens unnoticed for you, so why should you care?  Because the <code>free()</code> call does not mean that the <a href="http://stackoverflow.com/a/3860495/2597135">memory is returned immediately to the operating system</a> . </p><br><p>  There is such a thing as memory fragmentation.  In extreme cases, there are heap segments where only a few bytes are used, while everything between them has been freed <code>(free())</code> . </p><br><p>  Please note that memory fragmentation is an incredibly complex topic, and even minor changes in the program can significantly affect it.  In most cases, programs do not cause significant memory fragmentation, but you should keep in mind that if there is a problem with fragmentation in a certain area of ‚Äã‚Äãthe heap, hugepages can only aggravate the situation. </p><br><h4 id="vyborochnoe-primenenie-hugepages">  Selective application of hugepages </h4><br><p>  After reading the article, you have determined which parts of your program can benefit from using hugepages, and which parts are not.  So should hugepages even be included? </p><br><p>  Fortunately, you can use <code>madvise()</code> to enable hugepaging only for those memory areas where it will be useful. </p><br><p>  To get started, check that hugepages work in madvise () mode, using the <a href="https://techoverflow.net/2013/08/01/checking-if-hugepages-are-enabled-in-linux/">instructions</a> at the beginning of the article. </p><br><p>  Then, use <code>madvise()</code> to tell the kernel exactly where to use hugepages. </p><br><pre> <code class="plaintext hljs">#include &lt;sys/mman.h&gt; //    ,    size_t size = 256*1024*1024; char* mymemory = malloc(size); //   hugepages‚Ä¶ madvise(mymemory, size, MADV_HUGEPAGE); // ‚Ä¶    madvise(mymemory, size, MADV_HUGEPAGE | MADV_SEQUENTIAL)</code> </pre> <br><p>  Note that this method is just a recommendation to the kernel for managing the memory.  This does not mean that the kernel will automatically use hugepages for a given memory. </p><br><p>  Refer to the <a href="https://linux.die.net/man/2/madvise">madvise manpage</a> documentation to learn more about memory management and <code>madvise()</code> , this topic has an incredibly steep learning curve.  Therefore, if you intend to really understand it well, prepare to read and test for a few weeks before relying on at least some positive result. </p><br><p>  <strong>What to read?</strong> </p><br><ul><li>  <a href="https://www.ibm.com/developerworks/community/blogs/fe313521-2e95-46f2-817d-44a4f27eba32/entry/benefits_of_huge_pages%3Flang%3Den">IBM OpenStack article on hugepages</a> </li><li>  <a href="https://docs.oracle.com/database/121/UNXAR/appi_vlm.htm">Transparent hugepages vs non-transparent hugepages</a> </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D1%2583%25D1%2584%25D0%25B5%25D1%2580_%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D1%2586%25D0%25B8%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D0%25B8">WLipedia article about TLB</a> </li><li>  <a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt">Linux kernel documentation on transparent hugepages</a> </li><li>  <a href="http://serverfault.com/a/133306/203908">StackOverflow: Hugepages are prone to memory fragmentation</a> </li><li>  <a href="https://msdn.microsoft.com/en-us/library/ms810627.aspx">Microsoft Virtual Memory Management Article</a> </li></ul><br><hr><br><p>  <em>Have a question?</em>  <em>Write in the comments!</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/460403/">https://habr.com/ru/post/460403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460393/index.html">Background: what to expect from Fedora Silverblue</a></li>
<li><a href="../460397/index.html">Quick start with WebComponents</a></li>
<li><a href="../460399/index.html">SVG download indicator on Vue.js</a></li>
<li><a href="../4604/index.html">Syndication reaction</a></li>
<li><a href="../46040/index.html">The concept of the mechanism for correcting typos</a></li>
<li><a href="../460405/index.html">Why do we need hidden game mechanics</a></li>
<li><a href="../460409/index.html">Arduino and keyboard (full guide)</a></li>
<li><a href="../46041/index.html">Electronic First Aid Guide</a></li>
<li><a href="../460411/index.html">Insane GIF Converter in Animated Telegram Stickers</a></li>
<li><a href="../460413/index.html">7 useful sites and applications for learning English</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>