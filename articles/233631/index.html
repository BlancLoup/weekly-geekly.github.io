<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search for a path through NavMesh in ActionScript - CrossBridge port Recast Navigation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about the experience of porting C ++ code to ActionScript using the FlasCC compiler and show how I managed to port a fairl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search for a path through NavMesh in ActionScript - CrossBridge port Recast Navigation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/52e/6f1/2af/52e6f12af9c24ad293b4d50c7a71ff6f.png"><br><br>  In this article I will talk about the experience of porting C ++ code to ActionScript using the <a href="http://www.adobe.com/devnet-docs/flascc/README.html">FlasCC</a> compiler and show how I managed to port a fairly large amount of useful code that solves the problem of finding a path.  At the end there will be a demo and a link to the repository with the code.  In the meantime, a few words about how it all began. <br><a name="habracut"></a><br>  I am working on an indieproject.  This is a top-view shooter (similar to Crimsonland).  I am writing a project on AS3.  The game space is continuous (not in cells) and is based on the Nape physics engine.  Impassable areas (walls) are described by a set of convex polygons.  The problem arises of navigating agents (monsters) on such a map. <br><br>  What are some ideas for solving this problem? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. The space can be divided into cells and reduced to the task of finding a path on a checkered field.  For this, there are already ready-made solutions on Flash.  But I did not like this option because it forces the agent to always move from a certain cell to a neighboring one.  This decision also does not take into account the size of the agent, which may be different. <br><br>  2. You can build a cross graph.  If the agent cannot reach the target in a straight line, then the algorithm finds the targets closest to the agent, a couple of nodes of the graph and builds a route along the graph between them.  I implemented this approach in my project as a temporary one.  It was set up like this: in the level editor, nodes were set (waypoints), without specifying any links.  During the loading of the level, the system determined the direct passability between all possible pairs of nodes and thus defined the connections between them.  This decision suited me for a while, but soon some shortcomings began to annoy me: <br>  - The size of the agents is still not taken into account.  It would be great if on the basis of patency for agents of different sizes it was possible to build situations in the game. <br>  - Nodes have to be set in the editor manually.  It is unpleasant that in general this topic has to constantly return.  And the quality of the routes depends on how well the nodes are placed. <br>  - Routes are not optimal.  Often a situation began to arise when the agent first goes ‚Äúfrom the target‚Äù to the nearest node and only starts following from it, since  other nodes in the straight cross was not. <br>  - Agents do not take into account the existence of each other.  When moving a crowd of monsters, the linearity of their movement is very noticeable and does not look realistic. <br><br>  3. Another approach is the navigation mesh.  The idea is this: the passable area of ‚Äã‚Äãthe map is covered by a set of convex polygons adjoining each other.  Inside each polygon, the agent can move freely.  This is a very good solution for my case, I began to look for what tools exist on the Flash.  It turned out that in general there is nothing.  But there is a C ++.  The toolbox is called <a href="https://github.com/memononen/recastnavigation">Recast Navigation</a> - this is a pretty serious thing and it has absolutely everything you need.  For the sake of fairness, I‚Äôll note that there is a Rekast demo ported through Alchemy on Github, but this is only a demo that cannot be reused. <br><br>  And then I realized that I needed it.  I began to think how to transfer it to AS3.  Moving a little aside, I‚Äôm saying that before using the Nape physics engine, I tried to use Box2D, which is available in Flash in two versions: rewritten to AS3 and ported using Alchemy.  The version rewritten on AS3 had the disadvantage that every change, whether it was a corrected error or a new functionality, required the manual transfer of the corresponding code to the Flash version of the engine.  At some point he was simply abandoned.  But I liked the port through Alchemy in principle.  In addition to just a set of functions that repeat the API of the original engine, the author added an AS3 set of wrapper classes for the corresponding classes and structures in C ++.  Thus, the API in the Flash version hid from the developer the need to follow the transfer of pointers, operating simply with wrapper classes. <br><br>  I decided to port everything through <a href="http://adobe-flash.github.io/crossbridge/">CrossBridge</a> (formerly Alchemy).  CrossBridge is a Cygwin based environment with its own gcc compiler.  The compiler is called FlasCC and it outputs ActionScript bytecode at the output.  The general work flow is this: Each method in C ++ is associated with a method in AS3, which repeats the prototype of the C ++ function as accurately as possible.  A set of such functions is compiled using FlasCC in swc.  Then this swc connects to the project, in which another swc is created with the final API (with documentation) hiding pointers, memory allocations, etc. from the AS3 developer. <br><br>  Like the original code, I decided to make this port open.  All code is here: <a href="https://github.com/Rokannon/Crossbridge-Recast-Navigation">github.com/Rokannon/Crossbridge-Recast-Navigation</a> <br>  The repository with the original code in C ++ added as a submodule. <br><br>  A small demo of what happened, you can see here: <br>  <a href="http://work.rokannon.com/navmesh_demo">work.rokannon.com/navmesh_demo</a> <br>  In the panel on the right, you need to select the source mesh, which describes the level geometry.  Next, you need to scroll the panel down, click "Build" and wait a little while NavMesh is built.  In the panel on the left there are two tools that demonstrate the capabilities of the toolset: finding a path and navigating a crowd of agents. <br><br>  Transferred not all functions, but very many.  So the code can already be used.  Subscribe to the repository to follow the updates. <br><br>  At this official part is over.  Thanks for attention.  If someone has any questions - ask. <br><br>  Well, then, for those who are interested in the subtleties of implementation, I described the techniques that I used when porting C ++ code to AS3. <br><br><h4>  Simplest example </h4><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;AS3\AS3.h&gt; // ,     AS3. float testFunc(x:float, y:float) { return x + y; } void _testFunc() __attribute__((used, annotate("as3sig:public function internal_testFunc(x:Number, y:Number):Number"), annotate("as3package:ctest"))); void _testFunc() { float x; AS3_GetScalarFromVar(x, x); //    -,  - AS3. float y; AS3_GetScalarFromVar(y, y); AS3_Return(x + y); }</span></span></span></span></code> </pre> <br><br>  Running CrossBridge can compile this code: <br><pre> <code class="bash hljs">/cygdrive/c/Crossbridge_1.0.1/sdk/usr/bin/g++ <span class="hljs-string"><span class="hljs-string">"main.cpp"</span></span> -emit-swc=ctest -o <span class="hljs-string"><span class="hljs-string">"out.swc"</span></span></code> </pre><br>  As a result, the resulting swc will have the function internal_testFunc (x: Number, y: Number): Number that performs the same as testFunc in C ++.  Absolutely all functions are ported to this pattern.  The prefix internal_ is chosen specifically because  completely hide this method from the final swc will not work. <br><br><h4>  Structures </h4><br>  This class is used as a base for the class wrapper structures: <br><pre> <code class="actionscript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">package</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctest</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> c_internal; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CBase</span></span></span><span class="hljs-class"> </span></span>{ c_internal <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr:int; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:Boolean </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:void </span></span>{ CModule.free(ptr); } } }</code> </pre><br>  What does it make sense to pay attention here?  A wrapper class stores the address of the structure or class that wraps it.  There are no pointers in AS3.  Instead, they simply use int.  The variable ptr should be available everywhere except for the final API, so it is hidden by the special custom namespace c_internal. <br><br>  Consider the following structure in C ++: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyStruct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y };</code> </pre><br>  Such a structure as a wrapper class will correspond to: <br><pre> <code class="actionscript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">package</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctest</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> c_internal; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CBase</span></span></span><span class="hljs-class"> </span></span>{ c_internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SIZE:int = <span class="hljs-number"><span class="hljs-number">0</span></span>; c_internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OFFSET_X:int = offset(<span class="hljs-number"><span class="hljs-number">4</span></span>); c_internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OFFSET_Y:int = offset(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">offset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size:int)</span></span></span><span class="hljs-function">:int </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (SIZE += size) - size; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:int </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CModule.read32(ptr + OFFSET_X); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value:int)</span></span></span><span class="hljs-function">:void </span></span>{ CModule.write32(ptr + OFFSET_X, value); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:int </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CModule.read32(ptr + OFFSET_Y); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value:int)</span></span></span><span class="hljs-function">:void </span></span>{ CModule.write32(ptr + OFFSET_Y, value); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:Boolean </span></span>{ ptr = CModule.alloc(SIZE); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr != <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre><br>  Here, a small trix allows you to conveniently calculate the indents of all the fields and get the size of the structure as a bonus.  But there is one pitfall associated with <a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/">memory alignment</a> : Roughly speaking, if the data does not fit completely into one word (4 bytes), then their indentation should be a multiple of 4 bytes.  For example, the structure: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExampleStruct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z }</code> </pre><br>  It is located by bytes like this: <code>XY 0 0 ZZZZ</code> .  And <code>sizeof(ExampleStruct)</code> is 8, not 6 bytes. <br><br><h4>  Functions with pointers in arguments </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;AS3\AS3.h&gt; void addNum(MyStruct* s, int n) { s-&gt;x += n; s-&gt;y += n; } void _addNum() __attribute__((used, annotate("as3sig:public function internal_addNum(s_ptr:int, n:int):void"), annotate("as3package:ctest"))); void _testFunc() { MyStruct* s; AS3_GetScalarFromVar(s, s_ptr); int n; AS3_GetScalarFromVar(n, n); addNum(s, n); }</span></span></span></span></code> </pre><br>  To hide the need for a pointer from the developer, the final API will have the following function: <br><pre> <code class="actionscript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">package</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctest</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> c_internal; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s:MyStruct, n:int)</span></span></span><span class="hljs-function">:void </span></span>{ internal_addNum(s.ptr, n); } }</code> </pre><br><br><h4>  Pointer functions </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;AS3\AS3.h&gt; MyStruct* sum(MyStruct* s1, MyStruct* s2) { s1-&gt;x += s2-&gt;x; s1-&gt;y += s2-&gt;y; return s1; } void _sum() __attribute__((used, annotate("as3sig:public function internal_sum(s1_ptr:int, s2_ptr:int):int"), annotate("as3package:ctest"))); void _testFunc() { MyStruct* s1; AS3_GetScalarFromVar(s1, s1_ptr); MyStruct* s2; AS3_GetScalarFromVar(s2, s2_ptr); AS3_Return(sum(s1, s2)); }</span></span></span></span></code> </pre><br>  Since the wrapper does not store any data about the structure / class being wrapped except the address, it is convenient to add it as an optional argument to the API method: <br><pre> <code class="actionscript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">package</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctest</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> c_internal; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s1:MyStruct, s2:MyStruct, resultMyStruct:MyStruct = null)</span></span></span><span class="hljs-function">:MyStruct </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultMyStruct == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { resultMyStruct = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyStruct(); } resultMyStruct.ptr = <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>(s1.ptr, s2.ptr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resultMyStruct; } }</code> </pre><br>  A similar technique is used to refer to the elements of an array. </div><p>Source: <a href="https://habr.com/ru/post/233631/">https://habr.com/ru/post/233631/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../233621/index.html">Rust on examples. Part 2</a></li>
<li><a href="../233623/index.html">How we went to the project [#tceh] for 5 years and what, apart from the brain, is not enough for Russian IT startups</a></li>
<li><a href="../233625/index.html">Madrobots goes to war: how do we open a point in "Mega"</a></li>
<li><a href="../233627/index.html">Smart Watch Moto360 lit up in BestBuy prices with a price of $ 249.99</a></li>
<li><a href="../233629/index.html">NASA presented a prototype origami system for spacecraft photovoltaic cells</a></li>
<li><a href="../233635/index.html">Interesting facts about the work of technical support</a></li>
<li><a href="../233637/index.html">Concurrent programming for beginners in the Elixir / Erlang VM YaP using the example of the ‚ÄúEuler's horse‚Äù task</a></li>
<li><a href="../233639/index.html">Is communal paradise available for everyone? The story of the sad end</a></li>
<li><a href="../233641/index.html">Wind turbine from 3D printer: AirEnergy3D</a></li>
<li><a href="../233643/index.html">Memcached in PHP Kohana and its testing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>