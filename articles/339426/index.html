<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monads for Go-programmers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Monads are used to build a function (function composition) and get rid of the tedious monotony associated with it. After seven years of programming on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monads for Go-programmers</h1><div class="post__text post__text-html js-mediator-article"><p> Monads are used to build a function (function composition) and get rid of the tedious monotony associated with it.  After seven years of programming on Go, the need to repeat <code>if err != nil</code> becomes a routine.  Every time I write this line, I thank the Gophers for a readable language with excellent tools, but at the same time curse me for feeling punished by Bart Simpson. </p><br><p><img src="https://habrastorage.org/webt/59/d6/38/59d638937aba5572324945.png"></p><a name="habracut"></a><br><p>  <a href="https://anvaka.github.io/common-words/">I suspect that this feeling is shared by many</a> , but </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> != nil { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Printf(<span class="hljs-string"><span class="hljs-string">"This should still be interesting to a Go programmer "</span></span> + <span class="hljs-string"><span class="hljs-string">"considering using a functional language, despite %v."</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">err</span></span>) }</code> </pre> <br><p>  Monads are needed not only to hide error handling from us, but also for list inclusions, and for consistency, and for other tasks. </p><br><h2 id="ne-chitayte-eto">  Don't read it </h2><br><p>  Eric Meyer (Erik Meijer) in his article <a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0">Introduction to Functional Programming Course on Edx</a> asks you not to write about monads anymore, because a lot has been said about them already. </p><br><p>  In addition to reading this article, I recommend watching <a href="https://www.youtube.com/playlist%3Flist%3DPLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Bartosz Milevski‚Äôs</a> series <a href="https://www.youtube.com/playlist%3Flist%3DPLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">of category theory videos</a> , which ends with a presentation with a <a href="https://www.youtube.com/watch%3Fv%3DgHiyzctYqZ0%26t%3D4s%26index%3D19%26list%3DPLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">better explanation of the monads</a> I‚Äôve met. </p><br><p>  Do not read further! </p><br><h2 id="funktory">  Functors </h2><br><p>  Okay (sigh) ... Just remember: I warned you. <br>  Before monads, we need to deal with functors.  A functor is a superclass of a monad, that is, all monads are functors.  I will use functors in further explaining the essence of monads, so do not skip this section. </p><br><p>  A functor can be considered a container containing one type of element. </p><br><p>  For example: </p><br><ul><li>  Slice with elements of type T: <code>[]T</code> - container, the elements of which are arranged in a list. </li><li>  Tree <code>type Node&lt;T&gt; struct { Value T; Children: []Node&lt;T&gt; }</code>  <code>type Node&lt;T&gt; struct { Value T; Children: []Node&lt;T&gt; }</code> - a container whose elements are arranged in the form of a tree. </li><li>  Channel <code>&lt;-chan T</code> is a container and looks like a pipe through which water flows. </li><li>  The <code>*T</code> pointer is a container that can be empty or contain one element. </li><li>  The function <code>func(A) T</code> is a container like a safe that you have to open with a key to see the item stored in it. </li><li>  The multiple return values <code>func() (T, error)</code> is a container that may contain one element.  The error can be viewed as part of the container.  Hereinafter, we will call <code>(T, error)</code> tuple. </li></ul><br><p>  Programmers who do not own Go, but other languages: Go does not have algebraic data types or union types.  This means that instead of returning a function value <strong>or an</strong> error, a value <strong>and</strong> an error are returned here, and one of them is usually nil.  Sometimes we break the agreement and return value and error, both not nil, just to try to confuse each other.  Or have some fun. </p><br><p>  The most popular way to get combined types in Go is to have an interface (abstract class) and a type switch in the interface type. </p><br><p>  Another criterion, without which the container is not considered a functor, is the need to implement the <code>fmap</code> function for this type of container.  The <code>fmap</code> function applies a function to each element in a container without changing the container or structure. </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">B</span></span>, aContainerOfA <span class="hljs-type"><span class="hljs-type">Container</span></span>&lt;<span class="hljs-type"><span class="hljs-type">A</span></span>&gt;) <span class="hljs-type"><span class="hljs-type">Container</span></span>&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;</code> </pre> <br><p>  Using the <code>map</code> function as a slice is a classic example that you could see in mapreduce in Hadoop, Python, Ruby, and almost any other language: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">func</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fmap</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">func</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">B</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">as</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">B</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">bs </span></span>:= <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]b, len(as)) for i, a := range as { bs[i] = <span class="hljs-built_in"><span class="hljs-built_in">f</span></span>(a) } <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bs</span></span> }</code> </pre> <br><p>  We can also implement <code>fmap</code> for the tree: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(A)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">atree</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">&gt;) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">&gt;</span></span> { btree := Node&lt;B&gt;{ Value: f(atree.Value), Children: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Node&lt;B&gt;, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(atree.Children)), } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, c := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> atree.Children { btree.Children[i] = fmap(f, c) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> btree }</code> </pre> <br><p>  Or for the channel: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(A)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> &lt;-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">) &lt;-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span></span> { out := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> B, <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(in)) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> in { b := f(a) out &lt;- b } <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(out) }() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out }</code> </pre> <br><p>  Or for the pointer: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">B</span></span>, a *<span class="hljs-type"><span class="hljs-type">A</span></span>) *<span class="hljs-type"><span class="hljs-type">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } b := f(*a) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;b }</code> </pre> <br><p>  Or for the function: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">B</span></span>, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">c</span></span></span></span><span class="hljs-function"><span class="hljs-params"> C)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> { a := g(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(a) } }</code> </pre> <br><p>  Or for the function that returns an error: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">B</span></span>, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> (*<span class="hljs-type"><span class="hljs-type">A</span></span>, error)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> (*<span class="hljs-type"><span class="hljs-type">B</span></span>, error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> (*<span class="hljs-type"><span class="hljs-type">B</span></span>, error) { a, err := g() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } b := f(*a) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;b, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><p>  All these containers with the corresponding implementations of <code>fmap</code> are functors. </p><br><h2 id="komponovka-funkciy-function-composition">  Function Composition </h2><br><p>  Now we know that the functor is the abstract name of the container and that we can apply the function to the elements inside the container.  We now turn to the essence of the article - to the abstract concept of the monad. </p><br><p>  A monad is simply a "decorated" type.  Hmm, I suppose it did not become clearer, too abstract.  This is the typical problem of all explanations of the essence of monads.  It is like an attempt to explain what a side effect is: the description will be too general.  So let's better deal with the cause of the abstractness of the monad.  The reason is to compose the functions that return these decorated types. </p><br><p>  Let's start with the usual layout of functions, without decorated types.  In this example, we build the functions <code>f</code> and <code>g</code> and return a function that takes the input data that is expected by <code>f</code> and returns the output data from <code>g</code> : </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">B</span></span>, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(B)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">C</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">C</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">C</span></span> { b := f(a) <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> := g(b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> } }</code> </pre> <br><p>  Obviously, this will only work if the resulting type <code>f</code> matches the input type <code>g</code> . </p><br><p>  Another version: the layout of functions that return errors. </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(*A)</span></span></span></span></span></span> (*<span class="hljs-type"><span class="hljs-type">B</span></span>, error), g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*B)</span></span></span></span> (*<span class="hljs-type"><span class="hljs-type">C</span></span>, error), ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*A)</span></span></span></span> (*<span class="hljs-type"><span class="hljs-type">C</span></span>, error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a *A)</span></span></span></span> (*<span class="hljs-type"><span class="hljs-type">C</span></span>, error) { b, err := f(a) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, err := g(b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, err } }</code> </pre> <br><p>  Now we will try to abstract this error in the form of an embellishment (M) and see what remains: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(B)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt; { mb := f(a) <span class="hljs-comment"><span class="hljs-comment">// ... return mc } }</span></span></code> </pre> <br><p>  We need to return a function that takes <code>A</code> as an input parameter, so let's start with the declaration of the return function.  Since we have <code>A</code> , we can call <code>f</code> and get the value of <code>mb</code> type <code>M&lt;b&gt;</code> , but what next? </p><br><p>  We did not reach the goal, because it turned out too abstract.  I want to say that we have <code>mb</code> , just what to do with it? </p><br><p>  When we knew that this was a mistake, we could test it, but now we cannot, because it is too abstract. </p><br><p>  But ... if we know that our decoration <code>M</code> is also a functor, then we can apply <code>fmap</code> to it: </p><br><pre> <code class="hljs swift">type fmap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">B</span></span>, <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">A</span></span>&gt;) <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;</code> </pre> <br><p>  The function <code>g</code> , to which we want to apply <code>fmap</code> , does not return a simple type like <code>C</code> , it returns <code>M&lt;C&gt;</code> .  Fortunately, for <code>fmap</code> this is not a problem, but the type signature changes: </p><br><pre> <code class="hljs swift">type fmap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(B)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;, <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;) <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;&gt;</code> </pre> <br><p>  Now we have a <code>mmc</code> value of type <code>M&lt;M&lt;C&gt;&gt;</code> : </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(B)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt; { mb := f(a) mmc := fmap(g, mb) <span class="hljs-comment"><span class="hljs-comment">// ... return mc } }</span></span></code> </pre> <br><p>  We want to go from <code>M&lt;M&lt;C&gt;&gt;</code> to <code>M&lt;C&gt;</code> . </p><br><p>  For this, we need our decoration <code>M</code> not just to be a functor, but to have another property.  This property is the <code>join</code> function, which is defined for each monad, as <code>fmap</code> was defined for each functor. </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> join = func(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span><span class="hljs-class">&gt;&gt;) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><p>  Now we can write: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(B)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt; { mb := f(a) mmc := fmap(g, mb) mc := <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(mmc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mc } }</code> </pre> <br><p>  This means that if <code>fmap</code> and <code>join</code> defined during decoration, then we can build two functions that return decorated types.  In other words, it is necessary to define these two functions so that the type is a monad. </p><br><h2 id="join">  Join </h2><br><p>  Monads are functors, so we don‚Äôt need to define <code>fmap</code> for them again.  It is necessary to define only <code>join</code> . </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> join = func(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span><span class="hljs-class">&gt;&gt;) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><p>  Now we define <code>join</code> : </p><br><ul><li>  for lists, which will allow you to create list expressions (list comprehensions); </li><li>  for errors that will allow to process monadic errors (monadic error); </li><li>  and for channels, which will create a consistent pipeline (concurrency pipeline). </li></ul><br><h2 id="spiskovye-vyrazheniya">  List expressions </h2><br><p>  The easiest way to get started is to apply <code>join</code> to slices.  This function simply concatenates all slices. </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ss [][]T)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span></span> { s := []T{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ss { s = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(s, ss[i]...) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s }</code> </pre> <br><p>  Let's see why we needed <code>join</code> again, but this time we will focus on slices.  Here is the <code>compose</code> function for them: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> []<span class="hljs-type"><span class="hljs-type">B</span></span>, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(B)</span></span></span></span> []<span class="hljs-type"><span class="hljs-type">C</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> []<span class="hljs-type"><span class="hljs-type">C</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a A)</span></span></span></span> []<span class="hljs-type"><span class="hljs-type">C</span></span> { bs := f(a) css := fmap(g, bs) cs := <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(css) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs } }</code> </pre> <br><p>  If we pass <code>a</code> to <code>f</code> , we get <code>bs</code> type <code>[]B</code> </p><br><p>  Now we can apply <code>fmap</code> to <code>[]B</code> with <code>g</code> , which will give us a value of type <code>[][]C</code> , not <code>[]C</code> : </p><br><pre> <code class="hljs markdown">func fmap(g func(B) [<span class="hljs-string"></span><span class="hljs-string"></span>]C, bs [<span class="hljs-string"></span><span class="hljs-string"></span>]B) [<span class="hljs-string"></span><span class="hljs-string"></span>][<span class="hljs-symbol"></span><span class="hljs-symbol"></span>]C { css := make([][]C, len(bs)) for i, b := range bs { css[i] = g(b) } return css }</code> </pre> <br><p>  That's what we need to <code>join</code> .  We move from <code>css</code> to <code>cs</code> , or from <code>[][]C</code> to <code>[]C</code> </p><br><p>  Let's look at a more specific example. </p><br><p>  If we replace types: </p><br><ul><li>  <code>A</code> to <code>int</code> , </li><li>  <code>B</code> on <code>int64</code> , </li><li>  <code>C</code> on <code>string</code> . </li></ul><br><p>  Then our function becomes: </p><br><pre> <code class="hljs markdown">func compose(f func(int) [<span class="hljs-string"></span><span class="hljs-string"></span>]int64, g func(int64) [<span class="hljs-string"></span><span class="hljs-string"></span>]string) func(int) [<span class="hljs-string"></span><span class="hljs-string"></span>]string func fmap(g func(int64) [<span class="hljs-string"></span><span class="hljs-string"></span>]string, bs [<span class="hljs-string"></span><span class="hljs-string"></span>]int64) [<span class="hljs-string"></span><span class="hljs-string"></span>][<span class="hljs-symbol"></span><span class="hljs-symbol"></span>]string func join(css [][]string) []string</code> </pre> <br><p>  Now we can use them in our example: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { nums := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>, n) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> nums { nums[i] = <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(i+<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nums } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{strconv.FormatInt(x, <span class="hljs-number"><span class="hljs-number">10</span></span>), strconv.FormatInt(<span class="hljs-number"><span class="hljs-number">-1</span></span>*x, <span class="hljs-number"><span class="hljs-number">10</span></span>)} } c := compose(upto, pair) c(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">// "1","-1","2","-2","3","-3"</span></span></code> </pre> <br><p>  It turns out a slice of our first monad. </p><br><p>  Curiously, this is exactly what Haskell list expressions work with: </p><br><pre> <code class="hljs json">[ y | x &lt;- [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>], y &lt;- [show x, show (<span class="hljs-number"><span class="hljs-number">-1</span></span> * x)] ]</code> </pre> <br><p>  But you could recognize them by the example of Python: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [str(x), str(-<span class="hljs-number"><span class="hljs-number">1</span></span>*x)] [y <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pair(x) ]</code> </pre> <br><h2 id="obrabotka-monadnyh-oshibok-monadic-error">  Monadic Error Processing (Monadic Error) </h2><br><p>  We can also define <code>join</code> for functions that return a value and an error.  To do this, you first need to go back to the <code>fmap</code> function due to some idiosyncrasy in Go: </p><br><pre> <code class="hljs lisp">type fmap = func(<span class="hljs-name"><span class="hljs-name">f</span></span> func(<span class="hljs-name"><span class="hljs-name">B</span></span>) C, g func(<span class="hljs-name"><span class="hljs-name">A</span></span>) (<span class="hljs-name"><span class="hljs-name">B</span></span>, error)) func(<span class="hljs-name"><span class="hljs-name">A</span></span>) (<span class="hljs-name"><span class="hljs-name">C</span></span>, error)</code> </pre> <br><p>  We know that our layout function is going to call <code>fmap</code> with function <code>f</code> , which also returns an error.  As a result, the <code>fmap</code> signature looks like this: </p><br><pre> <code class="hljs lisp">type fmap = func( <span class="hljs-name"><span class="hljs-name">f</span></span> func(<span class="hljs-name"><span class="hljs-name">B</span></span>) (<span class="hljs-name"><span class="hljs-name">C</span></span>, error), g func(<span class="hljs-name"><span class="hljs-name">A</span></span>) (<span class="hljs-name"><span class="hljs-name">B</span></span>, error), ) func(<span class="hljs-name"><span class="hljs-name">A</span></span>) ((<span class="hljs-name"><span class="hljs-name">C</span></span>, error), error)</code> </pre> <br><p>  Unfortunately, the tuples in Go do not belong to the first level objects, so we cannot simply write: </p><br><pre> <code class="hljs lisp">((<span class="hljs-name"><span class="hljs-name">C</span></span>, error), error)</code> </pre> <br><p>  There are several ways around this.  I prefer the function because the functions that return tuples are first-level objects: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">func</span></span>() (<span class="hljs-name"><span class="hljs-name">C</span></span>, error), error)</code> </pre> <br><p>  Now, using our tricks, we can define <code>fmap</code> for functions that return a value and an error: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(B)</span></span></span></span></span></span> (<span class="hljs-type"><span class="hljs-type">C</span></span>, error), g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> (<span class="hljs-type"><span class="hljs-type">B</span></span>, error), ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> (<span class="hljs-type"><span class="hljs-type">C</span></span>, error), error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a A)</span></span></span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> (<span class="hljs-type"><span class="hljs-type">C</span></span>, error), error) { b, err := g(a) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, err := f(b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> (<span class="hljs-type"><span class="hljs-type">C</span></span>, error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, err }, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><p>  This brings us back to the main point: the <code>join</code> function with reference to <code>(func() (C, error), error)</code> .  The solution is simple and performs one of the error checks for us. </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C, error)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">err</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f() }</code> </pre> <br><p>  Now we can use the <code>compose</code> function, since we have already defined <code>join</code> and <code>fmap</code> : </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unmarshal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span> { err = json.Unmarshal(data, &amp;s) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } getnum := compose( unmarshal, strconv.Atoi, ) getnum(<span class="hljs-string"><span class="hljs-string">`"1"`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 1, nil</span></span></code> </pre> <br><p>  As a result, we need to perform fewer error checks, because the monad does it for us in the background using the <code>join</code> function. </p><br><p>  Here is another <a href="https://speakerdeck.com/rebeccaskinner/monadic-error-handling-in-go%3Fslide%3D77">example</a> where I feel like Bart Simpson: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upgradeUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(endpoint, username </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { getEndpoint := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%s/oldusers/%s"</span></span>, endpoint, username) postEndpoint := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%s/newusers/%s"</span></span>, endpoint, username) req, err := http.Get(genEndpoint) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } data, err := ioutil.ReadAll(req.Body) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } olduser, err := user.NewFromJson(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } newuser, err := user.NewUserFromUser(olduser), <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } buf, err := json.Marshal(newuser) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } _, err = http.Post( postEndpoint, <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>, bytes.NewBuffer(buf), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  Technically, <code>compose</code> can take as parameters more than two functions.  Therefore, we collect all the above functions in one call and rewrite our example: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upgradeUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(endpoint, username </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { getEndpoint := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%s/oldusers/%s"</span></span>, endpoint, username) postEndpoint := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%s/newusers/%s"</span></span>, endpoint, username) _, err := compose( http.Get, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req *http.Response)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ioutil.ReadAll(req.Body) }, newUserFromJson, newUserFromUser, json.Marshal, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*http.Response, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.Post( postEndpoint, <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>, bytes.NewBuffer(buf), ) }, )(getEndpoint) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  There are many other monads.  Imagine two functions that return the same type of decoration that you want to put together.  Let's sort one more example. </p><br><h2 id="soglasovannye-konveyery-concurrent-pipelines">  Concurrent Pipelines </h2><br><p>  You can define <code>join</code> for channels. </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(in &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> &lt;-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span></span> { out := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> T) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { wait := sync.WaitGroup{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> in { wait.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inner &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> inner { out &lt;- t } wait.Done() }(c) } wait.Wait() <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(out) }() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out }</code> </pre> <br><p>  Here we have the channel <code>in</code> , which supplies us with channels of type <code>T</code>  First, we will create an <code>out</code> channel, run Gorutina to service the channel, and then return it.  Inside the gorutiny we will launch new gorutins for each of the channels reading from <code>in</code> .  These gorutins send <code>out</code> their inbound events, combining the input data into one stream.  Finally, with the help of a wait group, make sure to close the <code>out</code> channel with all the input data. </p><br><p>  In other words, we read all the <code>T</code> channels from <code>in</code> and transfer them to the <code>out</code> channel. </p><br><p>  For programmers not on Go: I need to pass <code>c</code> as a parameter to internal gorutina, because <code>c</code> is the only variable that takes the value of each element in the channel.  This means that if instead of creating a copy of a value by passing it as a parameter, we simply use it inside the circuit, then we can probably read only from the freshest channel.  <a href="https://golang.org/doc/faq">This is a common error among Go programmers</a> . </p><br><p>  We can define the <code>compose</code> function for a function that returns channels. </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> &lt;-chan <span class="hljs-type"><span class="hljs-type">B</span></span>, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(B)</span></span></span></span> &lt;-chan <span class="hljs-type"><span class="hljs-type">C</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> &lt;-chan <span class="hljs-type"><span class="hljs-type">C</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a A)</span></span></span></span> &lt;-chan <span class="hljs-type"><span class="hljs-type">C</span></span> { chanOfB := f(a) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(fmap(g, chanOfB)) } }</code> </pre> <br><p>  And because of the way we implement <code>join</code> we get consistency almost for nothing. </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toChan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lines []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> &lt;-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { c := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, line := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> lines { c &lt;- line } <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(c) }() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wordsize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(line </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> &lt;-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { removePunc := strings.NewReplacer( <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"'"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"!"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">":"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, ) c := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { words := strings.Split(line, <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, word := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> words { c &lt;- <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(removePunc.Replace(word)) } <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(c) }() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c } sizes := compose( toChan([]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"Bart: Eat my monads!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Monads: I don't think that's a very good idea."</span></span>, <span class="hljs-string"><span class="hljs-string">"Lisa: If anyone wants monads, I'll be in my room."</span></span>, <span class="hljs-string"><span class="hljs-string">"Homer: Mmm monads"</span></span>, <span class="hljs-string"><span class="hljs-string">"Maggie: (Pacifier Suck)"</span></span>, }), wordsize, ) total := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, size := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> sizes { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size == <span class="hljs-number"><span class="hljs-number">6</span></span> { total += <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-comment"><span class="hljs-comment">// total == 6</span></span></code> </pre> <br><h2 id="menshe-zhestikulyacii">  Less gestures </h2><br><p>  This explanation of the monads was made practically on the fingers, and, to make it easier to understand, I deliberately dropped many things.  But there is something else that I want to talk about. </p><br><p>  Technically, our layout function defined in the previous chapter is called <code>Kleisli Arrow</code> . </p><br><pre> <code class="hljs swift">type kleisliArrow = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(B)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;</code> </pre> <br><p>  When people talk about monads, they rarely mention <code>Kleisli Arrow</code> , but for me this was the key to understanding the essence of monads.  If you're lucky, they will explain you the essence with <code>fmap</code> and <code>join</code> , but if you're unlucky, like me, they will explain it to you with the <code>bind</code> function. </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> bind = func(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span><span class="hljs-class">&gt;) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><p>  Why? </p><br><p>  Because <code>bind</code> is such a function in Haskell that you need to implement for your type, if you want it to be considered a monad. </p><br><p>  Repeat our implementation of the <code>compose</code> function: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(B)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt; { mb := f(a) mmc := fmap(g, mb) mc := <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>(mmc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mc } }</code> </pre> <br><p>  If the <code>bind</code> function were implemented, we could just call it instead of <code>fmap</code> and <code>join</code> . </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(B)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt; { mb := f(a) mc := bind(mb, g) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mc } }</code> </pre> <br><p>  This means that <code>bind(mb, g) = join(fmap(g, mb))</code> . </p><br><p>  The role of the <code>bind</code> function for lists will be performed depending on the language <code>concatMap</code> or <code>flatMap</code> . </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concatMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> []<span class="hljs-type"><span class="hljs-type">B</span></span>) []<span class="hljs-type"><span class="hljs-type">B</span></span></code> </pre> <br><h2 id="vnimatelnyy-vzglyad">  Attentive look </h2><br><p>  I found that in Go, the distinction between <code>bind</code> and <code>Kleisli Arrow</code> began to blur for me.  Go returns an error in the tuple, but the tuple is not a first-level object.  For example, this code will not be compiled because you cannot inline the results of <code>f</code> to <code>g</code> by inlining: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + j } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { i := g(f(), <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(i) }</code> </pre> <br><p>  We'll have to write this: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { i, err := f() j := g(i, err, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(j) }</code> </pre> <br><p>  Or make <code>g</code> take a function as input, because functions are first-level objects. </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ff </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">j</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { i, err := ff() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + j } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { i := g(f, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">println</span></span>(i) }</code> </pre> <br><p>  But that means our <code>bind</code> function: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> bind = func(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span><span class="hljs-class">&gt;) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br><p>  defined for errors: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> bind = func(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">err</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">g</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">)) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  it will be unpleasant to use until we convert this tuple into a function: </p><br><pre> <code class="hljs lisp">type bind = func(<span class="hljs-name"><span class="hljs-name">f</span></span> func() (<span class="hljs-name"><span class="hljs-name">B</span></span>, error), g func(<span class="hljs-name"><span class="hljs-name">B</span></span>) (<span class="hljs-name"><span class="hljs-name">C</span></span>, error)) (<span class="hljs-name"><span class="hljs-name">C</span></span>, error)</code> </pre> <br><p>  If you look closely, you can see that our returned tuple is also a function: </p><br><pre> <code class="hljs lisp">type bind = func(<span class="hljs-name"><span class="hljs-name">f</span></span> func() (<span class="hljs-name"><span class="hljs-name">B</span></span>, error), g func(<span class="hljs-name"><span class="hljs-name">B</span></span>) (<span class="hljs-name"><span class="hljs-name">C</span></span>, error)) func() (<span class="hljs-name"><span class="hljs-name">C</span></span>, error)</code> </pre> <br><p>  And if you look again, it turns out that this is our <code>compose</code> function, in which <code>f</code> simply receives zero parameters: </p><br><pre> <code class="hljs lisp">type compose = func(<span class="hljs-name"><span class="hljs-name">f</span></span> func(<span class="hljs-name"><span class="hljs-name">A</span></span>) (<span class="hljs-name"><span class="hljs-name">B</span></span>, error), g func(<span class="hljs-name"><span class="hljs-name">B</span></span>) (<span class="hljs-name"><span class="hljs-name">C</span></span>, error)) func(<span class="hljs-name"><span class="hljs-name">A</span></span>) (<span class="hljs-name"><span class="hljs-name">C</span></span>, error)</code> </pre> <br><p>  Tadam!  We got our <code>Kleisli Arrow</code> , just a few times carefully looking. </p><br><pre> <code class="hljs swift">type compose = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">B</span></span>&gt;, g <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(B)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>&lt;<span class="hljs-type"><span class="hljs-type">C</span></span>&gt;</code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  With the help of decorated types, monads hide the routine logic of the arrangement of functions from us, so that we can feel not punished by Bart Simpson, but by skating and throwing a ball aptly. </p><br><p><img src="https://habrastorage.org/webt/59/d6/38/59d6389370985705661347.jpeg"></p><br><p>  If you want to try monads and other functional programming concepts in Go, you can do it with my <a href="https://github.com/awalterschulze/goderive">GoDerive</a> code <a href="https://github.com/awalterschulze/goderive">generator</a> . </p><br><p>  A warning.  One of the key concepts of functional programming is immutability.  This not only simplifies the work of programs, but also allows you to optimize the compilation.  In Go, to emulate immutability you have to copy a lot of structures, which will decrease performance.  Functional languages ‚Äã‚Äãget away with it, because they can rely on immutability and always refer to the old values, rather than copying them again. </p><br><p>  If you really want to do functional programming, then pay attention to <a href="http://elm-lang.org/">Elm</a> .  This is a statically typed functional programming language for front-end development.  For a functional language, it is easy to learn, as Go is simple for imperative.  I wrote a <a href="https://guide.elm-lang.org/">guide</a> during the day and was able to start working productively that evening.  The creator of the language tried to make learning it easy, even eliminating the need to deal with monads.  Personally, I like to write frontend on Elm in combination with the backend on Go.  And if both languages ‚Äã‚Äãhave already bored you, do not worry, there is still a lot of interesting things ahead, Haskell is waiting for you. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/339426/">https://habr.com/ru/post/339426/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339416/index.html">Android and sound: how to do it right</a></li>
<li><a href="../339418/index.html">DevOops 2017: report review</a></li>
<li><a href="../339420/index.html">Django ORM - slow? Optimize (hardcore)</a></li>
<li><a href="../339422/index.html">The 3 main processes that the CRM system must automate. Automate the conversion process. Part 2</a></li>
<li><a href="../339424/index.html">Aytreking: available solutions and their features</a></li>
<li><a href="../339432/index.html">Hash steganography in dataset. This time fast</a></li>
<li><a href="../339434/index.html">How uneducated youth becomes educated. University response</a></li>
<li><a href="../339436/index.html">Semantic markup: LaTeX, DocBook or ???</a></li>
<li><a href="../339438/index.html">Uneducated youth. How to get out the student</a></li>
<li><a href="../339440/index.html">Misconceptions about JavaScript Engine Switcher 2.X</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>