<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we communicate with React components using TypeScript decorators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When developing applications for React, it is rather inconvenient to create components that are independent of each other, since The standard way to e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we communicate with React components using TypeScript decorators</h1><div class="post__text post__text-html js-mediator-article">  When developing applications for React, it is rather inconvenient to create components that are independent of each other, since  The standard way to exchange data between them is " <a href="https://reactjs.org/docs/lifting-state-up.html">Lifting State Up</a> ".  This approach gradually pollutes the intermediate components with unnecessary properties, making them inconvenient for reuse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/pk/km/4cpkkmweilm92yaln7jlgimkb0g.png" alt="image"></div><br>  The most popular means of solving this problem (and some others) are such libraries as Redux and Mobx, which allow you to store data in a separate place and transfer it to components directly.  In this article I want to demonstrate our approach to solving this issue. <br><a name="habracut"></a><br>  A separate page in the Docsvision EDMS is collected in a special WYSIWYG editor from a variety of React components placed at the required positions: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e37/7ff/ac0/e377ffac0b59367057fb4e617fb374c1.png" alt="image"></div><br>  Partners can write their own JavaScript scripts that interact with components through their API (read / write properties, call methods), and can render the same components through the usual JSX syntax (for example, inside some modal windows or their own components). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, our components should offer three ways to interact: <br><br><ol><li>  Getting the parameters from the server configured in the WYSIWYG editor. </li><li>  Interaction using JavaScript scripts. </li><li>  Interaction through JSX. </li></ol><br>  To support all these modes of interaction, we developed a parameter system that somewhat improves the standard property mechanism.  It looks like this: <br><br><pre><code class="hljs haskell">//         . <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> textBox = layout.controls.textBox; //       . textBox.params.value = <span class="hljs-string"><span class="hljs-string">" "</span></span>; //       . textBox.params.dataChanged = (sender, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">)=&gt; sender.params.value = </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.newValue.toUpperCase();</span></span></code> </pre> <br>  And this is how the class itself works with the parameters of the TextBox component: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextBoxParams</span></span> { <span class="hljs-comment"><span class="hljs-comment">/** . */</span></span> @rw <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>?: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-comment"><span class="hljs-comment">/**    . */</span></span> @r canEdit?: boolean; <span class="hljs-comment"><span class="hljs-comment">/** ,    . */</span></span> @apiEvent dataChanged?: BasicApiEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;; }</code> </pre><br>  As we can see, besides the usual listing of properties, as in the standard property mechanism, there are also decorators @r, @rw and @apiEvent.  With their help, we create more flexible behavior for our properties. <br><br>  And since the same class is also used as an interface for React-properties, we can interact with the component in the same way both with external scripts and through JSX. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_h/oa/hz/_hoahzeykf2nqhnri8caou_fdnu.png"></div><br>  The most commonly used decorators for properties are: <br><br><table><tbody><tr><th>  The name of the decorator </th><th>  Description </th></tr><tr><td><pre>  @r </pre></td><td>  The property is read-only, not allowing to change it. </td></tr><tr><td><pre>  @rw </pre></td><td>  The property is available for both reading and writing. </td></tr><tr><td><pre>  @apiEvent </pre></td><td>  Indicates that we must treat the property value as an event handler for component events with the same name.  Also, when working with such properties, we implement event-specific logic (for example, automatic unsubscribe of the previous handler when setting a new property value). </td></tr><tr><td><pre>  @handler (paramName) </pre></td><td>  Unlike those listed above, this decorator is hung not on a property, but on any getter or setter inside a component.  This allows you to add your own logic when writing or reading the value of a property.  For example, trimming spaces from the beginning and end of a value: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextBoxParams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** . */</span></span> <span class="hljs-meta"><span class="hljs-meta">@rw</span></span> value?: string = ''; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextBox</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseControl&lt;TextBoxProps</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextBoxState&gt;</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-meta"><span class="hljs-meta">@handler</span></span>(<span class="hljs-symbol"><span class="hljs-symbol">'valu</span></span>e') <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> get value(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.value.trim(); } ... }</code> </pre><br></td></tr></tbody></table><br>  At the same time, the decorators themselves usually do not contain any business logic, but merely retain the information that the decorator was used for.  This is done with the help of the <a href="https://github.com/rbuckton/reflect-metadata">reflect-metadata</a> library and is convenient in that it becomes possible to store logic in another place, flexibly combining several associated metadata.  Consider using this library in a simplified example with the @r decorator: <br><br><pre> <code class="hljs cmake">//        @r. const READONLY_DECORATOR_METADATA_KEY = <span class="hljs-string"><span class="hljs-string">"CONTOL_PUBLIC_API_READONLY"</span></span>; //   @r,       . <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> r(<span class="hljs-keyword"><span class="hljs-keyword">target</span></span>: Object, propertyKey: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> | symbol) { Reflect.defineMetadata(READONLY_DECORATOR_METADATA_KEY, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">target</span></span>, propertyKey); } //        @r  . <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> isReadonly(<span class="hljs-keyword"><span class="hljs-keyword">target</span></span>: Object, propertyKey: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Reflect.getMetadata(READONLY_DECORATOR_METADATA_KEY, <span class="hljs-keyword"><span class="hljs-keyword">target</span></span>, propertyKey); }</code> </pre><br>  After applying this decorator on any property of the object, metadata with the name ‚ÄúCONTOL_PUBLIC_API_READONLY‚Äù and the value true will automatically become attached to this property. <br><br>  Using such metadata, we can dynamically set the desired behavior to our parameters (access modifiers, work with events from the table above, etc.).  An example of the simplest implementation is given below the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Sample code with implementation</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextAreaParams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@r</span></span> value: string = <span class="hljs-string"><span class="hljs-string">''</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** .  1 . */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ITextAreaState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextAreaParams</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextArea</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TextAreaParams, ITextAreaState</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** .  2 . */</span></span> params: TextAreaParams = {} <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextAreaParams; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props: ITextAreaProps) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-comment"><span class="hljs-comment">/** .  3 . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = new TextAreaParams() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ITextAreaState; <span class="hljs-comment"><span class="hljs-comment">/** .  4 . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let propName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state) { let descriptor = { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getParamValue(propName), <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>: (value: any) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>. (propName, value), configurable: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, enumerable: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PropertyDescriptor; Object.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.params, propName, descriptor); } <span class="hljs-comment"><span class="hljs-comment">/** .  5 . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let propName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setParamValue(propName, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props[propName], <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">/** .  6 . */</span></span> componentWillReceiveProps(nextProps: ITextAreaProps) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let propName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props[propName] != nextProps[propName]) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setParamValue(propName, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props[propName]); } } } <span class="hljs-comment"><span class="hljs-comment">/** .  7 . */</span></span> getParamValue(paramName: string) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state[paramName]; } <span class="hljs-comment"><span class="hljs-comment">/** .  8 . */</span></span> setParamValue(paramName: string, value: any, initial: boolean) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readOnly = isReadonly(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state, paramName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!readOnly || initial) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state[paramName] = <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forceUpdate(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props[paramName] != value) { console.warn(<span class="hljs-string"><span class="hljs-string">" "</span></span> + paramName + <span class="hljs-string"><span class="hljs-string">"    ."</span></span>); } } } }</code> </pre><br><ol><li>  The interface for the state component is inherited from the Params class, ensuring consistency of data within them.  In addition, the same class is used as an interface for properties. </li><li>  Create an empty object for future work with params.  Properties in it will be filled later. </li><li>  Create a state component, which is an instance of our class for params. </li><li>  Fill in the params properties.  As you can see, the params object itself does not store any data, but uses the getParamValue and setParamValue methods as a getter and setter. </li><li>  Synchronize the original props values ‚Äã‚Äãwith params. </li><li>  When new props values ‚Äã‚Äãare received, we also synchronize them with params.  Based on this and the previous paragraph, it is clear that React-properties transfer their values ‚Äã‚Äãthrough parameters to the state component, which allows using decorators for them as well. </li><li>  The value for the parameters is simply obtained from the property with the same name from the state, since  He is for us "the single source of truth." </li><li>  When a new parameter value is set, it is checked whether our @r decorator is applied to a property using the isReadonly helper created above.  If the property is read-only, a warning about this is displayed in the browser console and the value does not change, otherwise new data is simply written to the state. </li></ol><br></div></div><br>  Thus, we obtained a universal API for accessing a component through the React properties when used inside another component, and when we receive a reference to the component and further work with it as an object.  And with the help of decorators work with them is simple and clear. <br><br>  I hope the demonstration of our approach will allow someone to simplify their API for working with components, and for a more detailed acquaintance with the decorators in TypeScript I recommend the article of my colleague The <a href="https://habrahabr.ru/company/docsvision/blog/310870/">dark side of TypeScript is @ decorators using examples</a> . </div><p>Source: <a href="https://habr.com/ru/post/350646/">https://habr.com/ru/post/350646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350632/index.html">Security Week 7: Dating through a coder and spam updates</a></li>
<li><a href="../350636/index.html">Cooking Juniper Network with Ansible</a></li>
<li><a href="../350638/index.html">Hardcore Java / JVM puzzles</a></li>
<li><a href="../350640/index.html">Bathroom mosaic and Diophantine equations</a></li>
<li><a href="../350642/index.html">How I earned $ 200,000 at 16</a></li>
<li><a href="../350648/index.html">Creating and hosting a telegram bot. From A to Z</a></li>
<li><a href="../350654/index.html">Interview on Data Science: what is expected of you</a></li>
<li><a href="../350656/index.html">ASC scenario as the basis of timeliness and harmony in business</a></li>
<li><a href="../350658/index.html">CSS weirdness to know about</a></li>
<li><a href="../350660/index.html">GitLab 10.5 released: integration with Let's Encrypt, Gemnasium dependency checks and external CI / CD files</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>