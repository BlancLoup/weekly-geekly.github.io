<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cryptographic puzzle: import of a key of WebMoney in Crypto Service Provider</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Private keys in the Windows system are usually stored in a special keystore. Work with these keys occurs by calling the functions of the cryptographic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cryptographic puzzle: import of a key of WebMoney in Crypto Service Provider</h1><div class="post__text post__text-html js-mediator-article"> Private keys in the Windows system are usually stored in a special keystore.  Work with these keys occurs by calling the functions of the cryptographic provider (hereinafter referred to as CSP).  When using the standard CSP (Microsoft Base Cryptographic Provider), the user's keys are stored in the C: \ Users \ [Vasia] \ AppData \ Roaming \ Microsoft \ Crypto folder.  When using special devices, the keys are stored in the memory of the device itself. <br><br>  To increase security, it was decided to import the key WebMoney (the same .kwm, which sign requests to the interfaces) in the CSP.  <i>Usually, those who use the key to sign requests to WM interfaces store it either as a .kwm file in the file system, or as an xml view ‚Äî both are not very secure.</i> <br><br>  It turned out not so easy. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In detail about the problems that you will encounter, while increasing the security of your payment service, read under the cut. <br><br><a name="habracut"></a><br><br>  So.  Let's start with the kwm file format.  The file has a non-intricate format (little things are missing): <br><br>  1. Hash to verify integrity. <br>  2. Encrypted private RSA exhibitor (D). <br>  H. Encrypted RSA-module (Modulus). <br><br>  <b>Problem number 1:</b> after decrypting the key file, we get only 2 of the 8 parameters we need. <br><br>  We have: D and Modulus, we need: Exponent, Modulus, P, Q, DP, DQ, InverseQ, D (for details on the structure to which you need to bring the key to import into CSP, see MSDN <a href="http://msdn.microsoft.com/en-us/library/Aa387401">msdn.microsoft.com/en- us / library / Aa387401</a> ). <br><br>  If you knew E (open exponent), it would not be difficult to find all these parameters.  Usually E take one of the numbers Farm: 17, 257, 65537 or 4294967297. The check is very simple: <br><br>  1. Encrypt an arbitrary message by our parameters D and Modulus: <br><br> <code>encrypted = message^D % Modulus <br></code> <br><br>  2. We are trying to decrypt using Exponent (assumed) and Modulus: <br><br> <code>message = encrypted^Exponent % Modulus <br></code> <br><br>  If the message received after decryption coincided with the original, then Exponent was selected correctly. <br><br>  <i>Note: hereinafter, the operator "^" is exponentiation, and the operator "%" is the remainder of the division</i> . <br><br>  <b>Problem number 2: the</b> open exhibitor is not known to us, and it is quite large. <br><br>  Unfortunately, none of these numbers Farm did not fit as an open exponent.  This is a bit upsetting.  Further, hoping that this number is still not too large - all numbers less than 4 bytes were tried (by brute force).  None of them fit.  It seems to be a dead end and it would be possible to forget about this idea ... <br><br>  This could all end.  It was not possible to get an open exhibitor: to brute force it for several dozen (or even hundreds) years. <br><br>  However, the story continues.  There lived a man like <b>Michael J. Wiener</b> who came up with a way to break into the RSA system, in the case of a small value of d.  We have a little the opposite: the small value of the open exponent, which we do not know. <br><br>  Indeed, by applying Wiener's attack on RSA, you can almost instantly find the open exponent of any key (if it is not very long). <br><br>  Here's what happened: <br><br>  Original values ‚Äã‚Äãof D and Modulus (obtained from the kwm file): <br><br> <code>D: 19715AB67A97257C5C80C8CD8F97448199F6F3FF8A3724DEA911C32CB5E64395D3175D6112A51DC14911FBA4E8FD107C1C65BE062A3491B1131168DF423408E2593 <br> <br> Modulus: 789BE5F2D0C90430EAEFC640B752FE707D75EB12C9C76F776C981014C1825C48989F15F5F53AFBF9B9C11D5C9AF184CC4F3938A48045414F814636C1275321F3AB9 <br></code> <br><br>  An open exhibitor that was instantly restored using Wiener's attack on RSA: <br><br> <code>Exponent: 21EA463DEB0B <br></code> <br><br>  It seemed to be the case: to bring the received parameters to the Private Key BLOBs structure and import into any crypto provider.  But it's not so easy ... <br><br>  <b>Problem number 3: a</b> public exponent is longer than 4 bytes, and the Private Key BLOBs format only allows exhibitors up to 4 bytes in length (4 bytes inclusive). <br><br>  That is the trouble!  It would seem that the task has no solution and you can forget about it (for the second time). <br><br>  Although ... After all, we have cryptosystem parameters (in particular, prime numbers p and q).  Therefore, you can do this: <br><br>  1. Take the original parameters P and Q. <br><br>  2. Choose the appropriate Exponent2 public exponent (no more than 4 bytes).  Take the number Farm 65537. <br><br>  3. Calculate the closed exponent D2 (multiplicatively inverse to the number e modulo (P-1) * <br>  (Q-1)).  D2 will be different from the original D from the kwm file. <br><br>  4. Calculate the parameters: DP2, DQ2, InverseQ2.  They are needed to quickly obtain a signature, using the <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B8%25D1%2582%25D0%25B0%25D0%25B9%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D0%25B1_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25BA%25D0%25B0%25D1%2585">Chinese theorem on residuals</a> . <br><br>  5. The most important thing!  We calculate the difference between the original D (which is in the original key kwm) and D2 of our modified cryptosystem (ie, D2 - D). <br><br>  Now the modified key can be saved in the CSP storage (for example, eToken PRO) as a private RSA key, and the deviation can be saved as a PKCS # 11 object.  When using Microsoft CSP, deviation can be saved to the user's store. <br><br>  In principle, the deviation value is not secret, now our modified key (which is stored in the CSP) is secret. <br><br>  Here is an example in C # that is responsible for importing the modified key into the CSP: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">void</font> ImportPrivateKey( <font color="#0000ff">byte</font> [] modulusBytes, <font color="#0000ff">byte</font> [] privateExponentBytes) <br> { <br> <font color="#008000">//   </font> <br> <br> <font color="#0000ff">var</font> modulus = <font color="#0000ff">new</font> BigInteger(modulusBytes); <br> <font color="#0000ff">var</font> d = <font color="#0000ff">new</font> BigInteger(privateExponentBytes); <br> <br> <font color="#0000ff">var</font> p = Wiener.Calculate(d, modulus); <font color="#008000">//     RSA   P (    )</font> <br> <font color="#0000ff">var</font> q = modulus/p; <br> <font color="#0000ff">var</font> f = (p - 1)*(q - 1); <font color="#008000">//  </font> <br> <font color="#0000ff">var</font> e = <font color="#0000ff">new</font> BigInteger( <font color="#0000ff">new</font> <font color="#0000ff">byte</font> [] {1, 0, 1}); <font color="#008000">// 65537</font> <br> <br> <font color="#0000ff">var</font> d2 = e.modInverse(f); <font color="#008000">// d2 --   </font> <br> <br> <font color="#0000ff">var</font> dp2 = d2%(p - 1); <br> <font color="#0000ff">var</font> dq2 = d2%(q - 1); <br> <font color="#0000ff">var</font> iq = q.modInverse(p); <br> <br> <font color="#0000ff">var</font> rsaParameters = <font color="#0000ff">new</font> RSAParameters <br> { <br> D = toByteArray(d2), <br> DP = toByteArray(dp2), <br> DQ = toByteArray(dq2), <br> Exponent = toByteArray(e), <br> InverseQ = toByteArray(iq), <br> Modulus = toByteArray(modulus), <br> P = toByteArray(p), <br> Q = toByteArray(q) <br> }; <br> <br> BigInteger deviation; <br> <font color="#0000ff">byte</font> flag; <font color="#008000">//  d &gt; d2,   </font> <br> <br> <font color="#0000ff">if</font> (d &gt; d2) <br> { <br> deviation = d - d2; <br> flag = 0; <br> } <br> <font color="#0000ff">else</font> <br> { <br> deviation = d2 - d; <br> flag = 1; <br> } <br> <br> <font color="#008000">//     CSP (   eToken,    CSP "eToken Base Cryptographic Provider")</font> <br> <font color="#0000ff">var</font> cspParameters = <font color="#0000ff">new</font> CspParameters <br> { <br> Flags = <br> CspProviderFlags.UseNonExportableKey | CspProviderFlags.UseUserProtectedKey, <br> KeyNumber = ( <font color="#0000ff">int</font> )KeyNumber.Exchange, <br> KeyContainerName = _containerName <br> }; <br> <br> <font color="#008000">//   </font> <br> RSACryptoServiceProvider.UseMachineKeyStore = <font color="#0000ff">false</font> ; <br> <br> <font color="#0000ff">using</font> ( <font color="#0000ff">var</font> cryptoServiceProvider = <font color="#0000ff">new</font> RSACryptoServiceProvider(cspParameters)) <br> { <br> <font color="#008000">//   </font> <br> cryptoServiceProvider.ImportParameters(rsaParameters); <br> } <br> <br> <font color="#008000">//  deviation    (  )</font> <br> Storage.SaveDataInStorage(_containerName, toByteArray(deviation)); <br> Storage.SaveDataInStorage(_containerName + <font color="#A31515">"_flag"</font> , <font color="#0000ff">new</font> [] {flag}); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  How now to receive the message signature message? <br><br>  The original signature is obtained as follows: <br><br> <code>signature = hash ^ D % Modulus <br></code> <br><br>  We now have no D, but there is D2 and deviation, and D2 + deviation = D. There is no direct access to D2, since  it is run by CSP: you can only get the signature of this D2, by calling standard functions.  Remember algebra: <br><br> <code>a^(b+c) = a^b * a^c <br></code> <br><br>  This law also applies to modular algebra.  So, our original signature (without knowledge D) is this: <br><br> <code>part1 = hash ^ D2 % Modulus <br> <br> part2 = hash ^ deviation % Modulus <br> <br> signature = part1 * part2 % Modulus <br></code> <br><br>  Profit!  Now our key is run by CSP (in the case of a hardware device, this is pretty reliable).  A little trouble - the whole ‚Äúdid not fit together‚Äù, there was still a ‚Äúpiece‚Äù in the form of deviation.  But this deviation is not a secret; without the knowledge of D2, it practically does not introduce any clue about the original D. <br><br>  But do not rush to relax. <br><br>  <b>Problem number 4: the</b> structure of the signed data is different from the generally accepted. <br><br>  If you decrypt the signature obtained by means of Win CAPI (you can decrypt the public exponent and module), you will see something like this structure: <br><br> <code>1FFFFFFFFFFFFFFFFFFFFFFFF003031300D0609608648016503040201050004209F64A747E1B97F131FABB6B447296C9B6F0201E79FB3C5356E6C77E89B6A806 <br></code> <br><br>  at the beginning of the standard header, and at the end of 32 bytes of the hash of the message being signed (cited for SHA-256). <br><br>  The WebMoney Signer signature is different: the first bytes are filled with random numbers, then 16 bytes of the MD4 hash, then a header of 2 bytes. <br><br>  The problem is that the CSP does not support the direct function of modular exponentiation with a private key (if it were possible, everything would work out).  Allowed only: <br><br>  1. Sign the message.  In an explicit form does not suit us, because  WebMoney will not recognize our signature - because the structure is different. <br><br>  2. Encrypt the message.  Again - a kind of encryption (the original message is modified, supplemented by random numbers) - it does not agree with our format. <br><br>  Again a deadlock.  Although ... And what if you slip our CSP is not a real hash, but a pseudo-hash, in which we fit the data in the format we need?  The hash function is not reversible, so there is not a single way to check if the hash is real. <br><br>  To do this, we need to choose an algorithm that has a long enough hash: so that our 16 byte MD4 contains, and a 2-byte header, and it would be nice for security to supplement the data with random numbers. <br><br>  SHA-512 was too big, but SHA-256 just right. <br><br>  This is the function for generating a signature: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">public</font> <font color="#0000ff">string</font> Sign( <font color="#0000ff">string</font> <font color="#0000ff">value</font> ) <br> { <br> <font color="#0000ff">if</font> ( <font color="#0000ff">string</font> .IsNullOrEmpty( <font color="#0000ff">value</font> )) <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> ArgumentNullException( <font color="#A31515">"value"</font> ); <br> <br> <font color="#0000ff">var</font> toSign = <font color="#0000ff">new</font> <font color="#0000ff">byte</font> [32]; <font color="#008000">// - SHA256</font> <br> <br> <font color="#0000ff">var</font> random = <font color="#0000ff">new</font> <font color="#0000ff">byte</font> [14]; <font color="#008000">//  </font> <br> <font color="#0000ff">var</font> hash = getHash( <font color="#0000ff">value</font> ); <font color="#008000">//    MD4</font> <br> <font color="#0000ff">var</font> prefix = <font color="#0000ff">new</font> <font color="#0000ff">byte</font> [] {0, 56}; <font color="#008000">//  WebMoney</font> <br> <br> <font color="#0000ff">var</font> rngCryptoServiceProvider = <font color="#0000ff">new</font> RNGCryptoServiceProvider(); <br> rngCryptoServiceProvider.GetBytes(random); <br> <br> Buffer.BlockCopy(random, 0, toSign, 0, random.Length); <br> Buffer.BlockCopy(hash, 0, toSign, random.Length, hash.Length); <br> Buffer.BlockCopy(prefix, 0, toSign, random.Length + hash.Length, prefix.Length); <br> <br> <font color="#0000ff">var</font> cspParameters = <font color="#0000ff">new</font> CspParameters <br> { <br> Flags = <br> CspProviderFlags.UseNonExportableKey | CspProviderFlags.UseUserProtectedKey, <br> KeyNumber = ( <font color="#0000ff">int</font> ) KeyNumber.Exchange, <br> KeyContainerName = _containerName <br> }; <br> <br> <font color="#0000ff">byte</font> [] signature1; <br> BigInteger modulus; <br> <br> <font color="#0000ff">using</font> ( <font color="#0000ff">var</font> rsaCryptoServiceProvider = <font color="#0000ff">new</font> RSACryptoServiceProvider(528, cspParameters)) <br> { <br> signature1 = rsaCryptoServiceProvider.SignHash(toSign, CryptoConfig.MapNameToOID( <font color="#A31515">"SHA256"</font> )); <br> modulus = <font color="#0000ff">new</font> BigInteger(rsaCryptoServiceProvider.ExportParameters( <font color="#0000ff">false</font> ).Modulus); <br> } <br> <br> <font color="#0000ff">var</font> deviation = <font color="#0000ff">new</font> BigInteger(Storage.LoadDataFromStorage(_containerName)); <br> <br> <font color="#008000">//   SHA-256</font> <br> <font color="#0000ff">var</font> header = <font color="#0000ff">new</font> <font color="#0000ff">byte</font> [] <br> { <br> 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, <br> 0x30, <br> 0x31, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, <br> 0x05, <br> 0x00, 0x04, 0x20 <br> }; <br> <br> <font color="#0000ff">var</font> toEncrypt = <font color="#0000ff">new</font> <font color="#0000ff">byte</font> [65]; <br> <br> Buffer.BlockCopy(header, 0, toEncrypt, 0, header.Length); <br> Buffer.BlockCopy(random, 0, toEncrypt, header.Length, random.Length); <br> Buffer.BlockCopy(hash, 0, toEncrypt, header.Length + random.Length, hash.Length); <br> Buffer.BlockCopy(prefix, 0, toEncrypt, header.Length + random.Length + hash.Length, prefix.Length); <br> <br> <font color="#0000ff">byte</font> flag = Storage.LoadDataFromStorage(_containerName + <font color="#A31515">"_flag"</font> )[0]; <br> <br> <font color="#0000ff">var</font> part1 = <font color="#0000ff">new</font> BigInteger(signature1); <br> BigInteger part2; <br> <br> <font color="#0000ff">if</font> (1 == flag) <br> { <br> <font color="#008000">//  --      --  </font> <br> part2 = <font color="#0000ff">new</font> BigInteger(toEncrypt).modInverse(modulus).modPow(deviation, modulus); <br> } <br> <font color="#0000ff">else</font> <br> part2 = <font color="#0000ff">new</font> BigInteger(toEncrypt).modPow(deviation, modulus); <br> <br> <font color="#0000ff">var</font> signature = toByteArray((part1*part2)%modulus); <br> <br> <font color="#008000">//   little-endian</font> <br> Array.Reverse(signature); <br> <br> <font color="#008000">//    </font> <br> <font color="#0000ff">var</font> uResult = <font color="#0000ff">new</font> <font color="#0000ff">ushort</font> [KeyBytesLength/2]; <br> <br> Buffer.BlockCopy(signature, 0, uResult, 0, signature.Length); <br> <br> <font color="#0000ff">var</font> stringBuilder = <font color="#0000ff">new</font> <font color="#2B91AF">StringBuilder</font> (); <br> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> pos = 0; pos &lt; uResult.Length; pos++) <br> stringBuilder.Append( <font color="#0000ff">string</font> .Format(CultureInfo.InvariantCulture, <font color="#A31515">"{0:x4}"</font> , uResult[pos])); <br> <br> <font color="#0000ff">return</font> stringBuilder.ToString(); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Now everything works like a clock: the key is compatible with any cryptographic device running on a Windows system (aka eToken, ruToken - whatever), the signature is valid. <br><br>  PS <br>  From the author. <br><br>  It may be difficult for someone to understand why I did not choose the ‚Äúeasy way‚Äù.  I explain: I love cryptographic puzzles.  Some people solve scanwords, but I like puzzles more like this. </div><p>Source: <a href="https://habr.com/ru/post/111928/">https://habr.com/ru/post/111928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111917/index.html">With a decade, Wikipedia!</a></li>
<li><a href="../111918/index.html">Making requests with difficult conditions</a></li>
<li><a href="../111919/index.html">Fast autocomplete using libscgi</a></li>
<li><a href="../111925/index.html">10 billion downloads on the AppStore</a></li>
<li><a href="../111927/index.html">Cold fusion earned?</a></li>
<li><a href="../111929/index.html">Running Return to Castle Wolfenstein on Linux</a></li>
<li><a href="../111930/index.html">The latest release of Firefox 4 Beta 9 is ready for download.</a></li>
<li><a href="../111931/index.html">Laptop increased vitality</a></li>
<li><a href="../111932/index.html">Statistics: Half of US Adult Internet Users Work with Wikipedia</a></li>
<li><a href="../111934/index.html">Long-lived computer skills, or What to teach children and students</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>