<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Operations as objects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, I had to access the ZooKeeper repository from C ++ code. There was no decent C ++ wrapper for the libzookeeper sishna library, so I h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Operations as objects</h1><div class="post__text post__text-html js-mediator-article"> Not so long ago, I had to access the ZooKeeper repository from C ++ code.  There was no decent C ++ wrapper for the libzookeeper sishna library, so I had to write it myself.  In the process of implementation, I have significantly modified the approach of the authors of the java-library to build an API, and now I want to share with you the reasons and the results of the decisions made.  Despite the keywords C ++ and ZooKeeper, the approach described in the article is suitable for organizing access to any repositories, and is fully implementable in languages ‚Äã‚Äãother than C ++. <br><a name="habracut"></a><br><br><h4>  Introduction </h4><br><br>  <a href="http://zookeeper.apache.org/">ZooKeeper</a> is a fault-tolerant distributed database that presents data as a hierarchical set of nodes.  Nodes can be created, modified, deleted, checked for their existence, and managed for their access rights.  Some operations take additional options, for example, you can specify the version of the node to which the command applies.  The multithreaded client ZooKeeper, which is discussed in this article, creates two additional streams - in one it performs all I / O operations, in the other it performs custom callbacks and monitors.  Monitors are functions that are called by the client when a node changes state.  For example, you can find out if a node exists and pass a function that will be called when the node is gone or appears.  The rest of the details necessary for understanding the article, I will give as needed. <br>  We needed ZooKeeper to coordinate the execution of tasks by a multitude of machines in several data centers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Having started working on a C ++ library, I decided to make the API as close as possible to <a href="http://zookeeper.apache.org/doc/r3.4.6/api/org/apache/zookeeper/ZooKeeper.html">the Java client API</a> , which has one large <code>ZooKeeper</code> class, providing one method for each operation on the nodes.  However, the shortcomings of this approach were quickly discovered. <br><br>  I wanted to have several options for each command: <br><br><ul><li>  Standard asynchronous: we pass the request parameters and the callback function (callback) to the client.  When the operation is completed, the client will call the provided function in a separate thread created by the ZooKeeper client. </li><li>  Asynchronous, returning object <a href="http://en.cppreference.com/w/cpp/thread/future"><code>std::future</code></a> .  We pass the request parameters to the client, the client returns an object representing the asynchronous calculation.  When we call the <code>std::future::get</code> method, we will be given control after the operation completes.  If the operation fails, the call to <code>std::future::get</code> should throw an exception. </li><li>  Synchronous.  The call is blocked until the operation is completed.  Errors are translated into exceptions. </li></ul><br><br>  If the operation has N possible options (with monitor / without monitor, with version / without version, etc.) and M variants of execution, we are waiting for writing and support for N * M methods.  For example, in the java-client there are 4 <code>exists</code> methods: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Stat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> watch)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> watch, AsyncCallback.StatCallback cb, Object ctx)</span></span></span><span class="hljs-function"> Stat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, Watcher watcher)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, Watcher watcher, AsyncCallback.StatCallback cb, Object ctx)</span></span></span></span></code> </pre><br><br>  If you want to have an option that returns <code>future</code> , you have to add 2 more methods.  A total of 6 methods, and this is only for one operation!  I considered this unacceptable. <br><br><h4>  Types rush to the rescue </h4><br><br>  After realizing the futility of the obvious way, I got the idea of ‚Äã‚Äãrestructuring the API - I need to separate as much as possible the way the command is executed from the command itself.  Each command needs to be arranged in the form of a separate type - a container of parameters. <br><br>  In the client in this case, you need to implement only one method for asynchronous command execution: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Command cmd, Callback callback)</span></span></span></span>;</code> </pre> <br><br>  It is enough to implement only the basic asynchronous version of the implementation; all other options can be implemented outside the client, using the asynchronous interface as the basis <a href="http://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197">without harming the encapsulation at all</a> . <br><br>  So, for each operation we will get a separate class: <br><ul><li> <code>CreateCmd</code> </li> <li> <code>DeleteCmd</code> </li> <li> <code>ExistsCmd</code> </li> <li>  ... </li></ul><br><br>  Each class will store all the parameters that are needed to execute the command.  For example, the <code>delete</code> operation takes a required path and can optionally take a version of the data to which it applies.  The <code>exists</code> operation also requires a path and can optionally take a function called when a node is deleted / created. <br><br>  Here you can select some templates - for example, all commands must contain the path to the node, some can be applied to a specific version ( <code>delete</code> , <code>setACL</code> , <code>setData</code> ), some accept an additional callback monitor, or they can publish events to the session callback monitor.  You can implement these "templates" in the form of <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BC%25D0%25B5%25D1%2581%25D1%258C_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">impurities (mixins)</a> , from which we, as from bricks, will assemble our teams.  In total, I managed to see 3 impurities: <br><ul><li>  <code>Pathable</code> - takes a path in the constructor and provides a method for getting the path. </li><li>  <code>Versionable</code> - stores the version and provides methods for specifying the version and getting the specified version. </li><li>  <code>Watchable</code> - stores and allows you to define a callback that is called when a node changes state. </li></ul><br>  For example, here‚Äôs the impurity code <code>Versionable</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> SelfType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Versionable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Versionable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Version version = AnyVersion)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">version_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(version)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-function">SelfType &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setVersion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Version version)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;version_ = version; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;SelfType &amp;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-function">Version </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">version</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;version_; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Version version_; };</code> </pre><br><br>  To <code>setVersion</code> return the <code>setVersion</code> base class <code>Versionable</code> , the <a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">curiously recurring template pattern</a> technique is used here.  Adding impurities to teams is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeleteCmd</span></span></span><span class="hljs-class"> :</span></span> Pathable, Versionable&lt;DeleteCmd&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteCmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// other methods };</span></span></code> </pre><br><br>  The next step is to determine which type of callback should correspond to each of the commands, because when different commands are completed, the values ‚Äã‚Äãof different types are transferred to the callbacks.  In total, there are 7 types of callbacks: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> VoidCallback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> StatCallback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, Stat <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ExistsCallback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, Stat <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> StringCallback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ChildrenCallback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, Children, Stat <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DataCallback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, Stat <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AclCallback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, AclVector, Stat <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;)&gt;;</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">What is Stat?</b> <div class="spoiler_text">  The <code>Stat</code> structure contains meta-information about a tree node, similar to the <code>stat</code> structure on UNIX systems.  For example, this structure contains the virtual time of the last modification, the size of the data stored in the node, the number of descendants, etc. <br></div></div><br><br>  The easiest way to bind commands to callbacks is to require each team to determine the appropriate nested type <code>CallbackType</code> .  This is not quite beautiful, as the team begins to guess that it will be performed asynchronously with a callback, and this is exactly what we tried to avoid.  However, I chose this particular implementation because of its simplicity and the fact that the asynchronous implementation is basic, and the remaining options will be a superstructure above it. <br><br>  Next, you need to write code that will execute our commands asynchronously.  The easiest option is to place the responsibility for parameter packing and non-blocking command launch on the command classes themselves.  This is also a bit contrary to the accepted philosophy, but it allows you to keep all the logic of asynchronous processing of commands in one place.  If the next version of ZooKeeper contains a new command, it will be enough to add just one class to our library, the changes will be very local and backward compatible. <br><br>  For the unity of the command interface, I decided to enter the abstract type <code>Handle</code> - a low-level descriptor that hides all implementation details from the library client (for example, the fact that the command <code>libzookeeper</code> used to execute commands).  In C / C ++, this can be achieved by declaring a type, but not defining it in the library‚Äôs public header files: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handle</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  How exactly the <code>Handle</code> class is implemented is not so important.  For simplicity, we can assume that this is in fact <code>zhandle_t</code> from the <code>libzookeeper</code> library, and the implementation of our commands in secret from the user converts the pointer to our incomplete type into a pointer to <code>zhandle_t</code> . <br><br>  Thus, in each class representing the command, an overloaded call operator appears. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeCmd</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CallbackType = SomeCallbackType; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handle *, CallbackType)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre><br><br>  I will not give the packing code of command parameters, since  it is rather cumbersome and contains a lot of intermediate code and details not related to the essence of the article. <br><br>  The method of running commands in the client class becomes quite simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Session</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// other methods template &lt;typename CmdType&gt; void run(CmdType const&amp; cmd, typename CmdType::CallbackType callback) { cmd(this-&gt;getHandle(), std::move(callback)); } private: Handle * getHandle(); };</span></span></code> </pre><br><br>  Here we essentially delegate the launch of the team to the team itself, passing it a low-level descriptor. <br><br>  It is important that the overloaded call operator is constant - the commands should not change their state when called.  First, it will allow the use of temporary command objects in the following code: <br><br><pre> <code class="cpp hljs">session.run(DeleteCmd(<span class="hljs-string"><span class="hljs-string">"path"</span></span>).setVersion(knownVersion), myCallback);</code> </pre> <br><br>  The same effect could be achieved by transferring commands by value and relying on <a href="http://habrahabr.ru/post/174019/">move-semantics</a> , but this would have made it necessary in some cases to create redundant copies. <br><br>  Secondly, in this way we inform the person reading the code (and, partly, the compiler) that repeated execution of the same command should not lead to side effects that are not related to changes in the structure of the repository. <br><br>  Now we can asynchronously perform all operations with all possible options, and for this we need only one method in the client - <code>run</code> . <br><br><h4>  Add asynchronous command execution with <code>std::future</code> </h4><br><br>  So, now it is the turn to realize that, for the sake of which everything was started - alternative variants of implementation. <br><br>  To be able to asynchronously execute commands with the <code>std::future</code> object, I want to have a function that has the following signature: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CmdType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:future&lt;ResultOf&lt;CmdType&gt;&gt; runAsync(Session &amp;, CmdType <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;);</code> </pre><br><br>  This function accepts a session and a command as input, returning a <code>std::future</code> object representing the result of the asynchronous command execution. <br><br>  First you need to understand how to fit the command callback parameters into one value.  This is what the <code>ResultOf</code> metafunction is <code>ResultOf</code> .  There are several ways to indicate the correspondence of function parameters to returned values, I chose the simplest one - just write out every possible case as a separate specialization of the template class <code>DeduceResult</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CallbackType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeduceResult</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeduceResult</span></span></span><span class="hljs-class">&lt;std::function&lt;void(std::error_code const&amp;)&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeduceResult</span></span></span><span class="hljs-class">&lt;std::function&lt;void(std::error_code const&amp;, T)&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;T&gt;::type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeduceResult</span></span></span><span class="hljs-class">&lt;std::function&lt;void(std::error_code const&amp;, T, Stat const&amp;)&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;T&gt;::type, Stat&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CmdType&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ResultOf = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> DeduceResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CmdType::CallbackType&gt;::type;</code> </pre><br><br>  The logic of <code>DeduceResult</code> is simple: <br><ul><li>  If only the error code is transferred to the callback, then the result of the operation is <code>void</code> . </li><li>  If an additional parameter is passed to the callback, in addition to the error code, the result of the operation will be this parameter. </li><li>  If the link to the <code>Stat</code> object is also transferred to the callback, the result and the <code>Stat</code> object will be packed into <code>std::pair</code> . </li></ul><br>  <code>ResultOf</code> is a template synonym ( <a href="http://en.cppreference.com/w/cpp/language/type_alias">alias template</a> , one of the nice features of C ++ 11) that passes to the <code>DeduceResult</code> type of callback defined in the command. <br><br>  The use of the <a href="http://en.cppreference.com/w/cpp/types/decay"><code>std::decay</code></a> <a href="http://en.wikibooks.org/wiki/More_C%252B%252B_Idioms/Metafunction">metafunction</a> is noteworthy - some parameters are passed to the callback by reference, but we want to return them to customers by value, because  objects can live on the stack and, if they are passed to another thread, references to them will already be destroyed by the time the client reads them. <br><br>  Now you can do the implementation of the function <code>runAsync</code> .  The implementation is almost obvious: you need to create the <a href="http://en.cppreference.com/w/cpp/thread/promise"><code>std::promise</code></a> object of the required type, get the <code>std::future</code> object from it (by calling the <code>std::promise::get_future()</code> method), create a special callback that will receive the <code>std::promise</code> object and put in it the result or error of the callback.  Then you just need to execute the command through the standard session interface with our callback.  Since a <code>promise</code> should have a callback, it is logical to make a callback a function object containing a <code>promise</code> as a field.  The resulting <code>runAsync</code> function <code>runAsync</code> looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CmdType&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::future&lt;ResultOf&lt;CmdType&gt;&gt; runAsync(Session &amp; session, CmdType <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; cmd) { FutureCallback&lt;ResultOf&lt;CmdType&gt;&gt; cb; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = cb.getPromise().get_future(); session.run(cmd, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cb)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f; }</code> </pre><br><br>  The implementation of the <code>FutureCallback</code> function <code>FutureCallback</code> in many ways mirrors the logic we nested in the <code>ResultOf</code> metafunction.  Based on the expected type of operation, we generate functions that pack our input arguments into an object and pass this object to a common (with a <code>future</code> object) state via <code>promise::set_value</code> or <code>promise::set_exception</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::promise&gt;T&gt; &amp; p, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::error_code </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; ec)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    codeToExceptionPtr  . //     ,    //     exception_ptr,   //  . p.set_exception(codeToExceptionPtr(ec)); } template &lt;typename T&gt; struct CallbackBase { //       promise   ,  //   std::function -    . // . n337 (20.8.11.2.1) using PromisePtr = std::shared_ptr&lt;std::promise&lt;T&gt;&gt;; PromisePtr promisePtr; CallbackBase() : promisePtr(std::make_shared&lt;std::promise&lt;T&gt;&gt;()) {} std::promise&lt;T&gt; &amp; getPromise() { return *promisePtr.get(); } }; template &lt;typename T&gt; struct FutureCallback : CallbackBase&lt;T&gt; { void operator()(std::error_code const&amp; ec, T value) { if (ec) { setError(this-&gt;getPromise(), ec); } else { this-&gt;getPromise().set_value(std::move(value)); } } }; template &lt;&gt; struct FutureCallback&lt;void&gt; : CallbackBase&lt;void&gt; { void operator()(std::error_code const&amp; ec) { if (ec) { setError(this-&gt;getPromise(), ec); } else { this-&gt;getPromise().set_value(); } } }; template &gt;typename T&gt; struct FutureCallback&lt;std::pair&lt;T, Stat&gt;&gt; : CallbackBase&lt;std::pair&lt;T, Stat&gt;&gt; { void operator()(std::error_code const&amp; ec, T data, Stat const&amp; stat) { if (ec) { setError(this-&gt;getPromise(), ec); } else { this-&gt;getPromise().set_value( std::make_pair(std::move(data), stat)); } } };</span></span></code> </pre><br><br>  Now we can use our function as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::future&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt; nodeNameFutures; <span class="hljs-comment"><span class="hljs-comment">//     for (const auto &amp; name : {"/node1", "/node2", "/node3"}) { nodeNameFutures.emplace_back(runAsync(session, CreateCmd(name))); } //     for (auto &amp; f : nodeNameFutures) { f.wait(); }</span></span></code> </pre><br><br>  Writing such a code using callback functions is not a very pleasant thing.  Using the <code>std::future</code> mechanism greatly simplifies such tasks.  For example, I used this mechanism to implement the function of recursive deletion of a subtree. <br><br><h4>  Other embodiments </h4><br><br>  Synchronous command execution we get almost for free: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CmdType&gt; ResultOf&lt;CmdType&gt; runSync(Session &amp; session, CmdType <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; cmd) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> runAsync(session, cmd).get(); }</code> </pre><br><br>  You can come up with many more different embodiments.  For example, you can quite easily write a function that will rerun a command when a connection error occurs, or it records the parameters, the beginning and end of command execution (for example, using the <a href="http://habrahabr.ru/post/256907/">chromium trace_event API</a> ) to debug and analyze performance. <br><br>  In fact, we have a primitive and strongly limited version of the <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">aspect-oriented paradigm</a> .  We can perform additional actions before the launch and after the completion of commands, localizing the logic within one function - the "aspect". <br><br><h4>  Conclusion </h4><br><br>  Transforming operations from storage into methods reduced the coherence of the code and significantly reduced its number, saving a lot of effort in implementation and debugging. <br><br>  The described approach, of course, is not something fundamentally new.  At a minimum, a similar practice is used in the <a href="http://hbase.apache.org/0.94/apidocs/">HBase Java client</a> . <br><br>  There are drawbacks to this method - it generates quite a few classes, and it becomes a bit more difficult for clients to explore the library interface ‚Äî operations are not grouped together in a class interface, but are separated into different types.  For the same reason, it will be difficult for customers to explore the API. By the link, videos and presentations are available through auto-completion in the IDE (however, it may be for the better - although the documentation is read).  Therefore, with such an interface, it is desirable to have detailed documentation and more examples of using the library. <br><br>  <b>UPD: the</b> material presented in the article served as the basis for the report <a href="https://events.yandex.ru/lib/talks/2963/">‚ÄúPractical API for Data Warehouse‚Äù</a> , which the author spoke on July 4 at the C ++ User Group in Nizhny Novgorod.  The link is available video and presentation in pdf. </div><p>Source: <a href="https://habr.com/ru/post/259307/">https://habr.com/ru/post/259307/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259297/index.html">Interface settings and much more in the assembly Vivaldi 1.0.190.2</a></li>
<li><a href="../259299/index.html">Rusty evidence</a></li>
<li><a href="../259301/index.html">Cackle comment system: how we did the analytics</a></li>
<li><a href="../259303/index.html">Creating plug-ins for AutoCAD using the .NET API (Part 5 - Introduction to Blocks)</a></li>
<li><a href="../259305/index.html">PHP Digest number 63 - interesting news, materials and tools (May 11 - 31, 2015)</a></li>
<li><a href="../259309/index.html">Web Application Security Audit Methodology</a></li>
<li><a href="../259311/index.html">AngularJS vs. Backbone.js vs. Ember.js</a></li>
<li><a href="../259315/index.html">HL7: one day in the operating room</a></li>
<li><a href="../259317/index.html">My top 100 books on Programming, Computers and Science: part 1</a></li>
<li><a href="../259321/index.html">Your questions about Data Science</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>