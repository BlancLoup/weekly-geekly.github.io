<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Again about STL: containers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article we talked about arrays as a prototype and the progenitor of containers. Now it is the turn of the actual container classes and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Again about STL: containers</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="https://habrahabr.ru/company/ua-hosting/blog/278039/">previous article</a> we talked about arrays as a prototype and the progenitor of containers.  Now it is the turn of the actual container classes and their supporting libraries. <br><br>  The term library of standard templates (STL, <b>S</b> tandard <b>T</b> emplate <b>L</b> ibrary) refers to a set of interfaces and components originally developed by Alexander Stepanov, Meng Lee and other employees of AT &amp; T Bell Laboratories and Hewlett-Packard Research Laboratories in the early 90s (although later still quite a few had a hand in what has become today the standard component of C ++).  Further, the STL library became the property of SGI, and was also included as a component in the Boost library set.  Finally, the STL library was included in the C ++ standards of 1998 and 2003 (ISO / IEC 14882: 1998 and ISO / IEC 14882: 2003) and has since been considered one of the components of the standard C ++ libraries. <br><br>  The standard does not name this part of the STL library, but this chronology would be well taken into account when dealing with which version of the compiler, language and literature you are dealing with - in the process of reducing HP STL to sizes suitable for standardization, some of the algorithms and functors dropped out of the library, and something is added over time (for example, expanding the set of redefined prototypes of some container methods).  The text will use the traditional name STL only to make it clear what part of the standard C ++ library we mean. <br><a name="habracut"></a><br>  The original purpose of STL (this is clearly seen from the chronology of comments in the header files) was to create a more flexible model of regular containers compared to arrays and generalize to them some widely used algorithms (such as search, sort, and some others).  But the idea turned out to be more fruitful than the original intentions, and was significantly expanded.  STL introduces a number of concepts and data structures that in almost all cases make it possible to greatly simplify the program code.  The following categories of concepts are introduced: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Container - a way to store a set of objects in memory. </li><li>  Iterator - a means of accessing the contents of individual objects in a container. </li><li>  Algorithm - determination of the most standard computing procedures on containers. </li><li>  Adapter - adaptation of the main categories to provide the most commonly used interfaces (such as stack or queue). </li><li>  Functor (functional object) - hiding a function in an object for use by other categories. </li></ol><br>  The STL library is a very large area.  Her description is devoted to entire individual books.  Here, by virtue of a sufficiently initial level of acquaintance, limited volume and following the previously announced goals, the technique of using STL will be considered using intuitively clear examples.  The STL syntax is based on the use of such syntax constructs of the C ++ language as templates (templates) of classes and function templates.  But for the successful <b>application</b> of the STL technique it is not necessary to have a deep understanding of the templates technique (this may come later). <br><br>  The central concept of STL, around which everything else is spinning, is a container (they also use the term collection).  A container is a collection of a certain number of necessarily identical elements packed in a container in a certain way.  The simplest prototype of a container in the classic C ++ language is an array.  The way in which elements are packaged in a container and determines the type of container and the peculiarities of working with elements in such a container.  STL introduces a variety of different types of containers, the main ones are: <br><br><ul><li>  consecutive containers - vector (vector), doubly-connected list (list), deck (deque); </li><li>  associative containers - sets (set and multiset), hash tables (map and multimap); </li><li>  pseudo containers - bitmasks (bitset), strings (string and wstring), arrays (valarray); </li></ul><br>  We will look at examples of using consistently basic ones, moving from simpler to more complex ones.  The simplest type of container is a <b>vector</b> .  The closest prototype of the vector is the C ++ array, but <b>the</b> vector <b>size</b> can be dynamically <b>changed</b> at any time by adding (push_back () method) or removing (for example, the pop_back () method) element.  As well as for an array, we can refer to an arbitrary element of the vector by the indexing operation [n].  What has already been said is already the first, surface layer of knowledge about the vector, but which is sufficient to allow us to start working with it on the analogies of how we work with traditional arrays: <br><br><pre><code class="hljs mel">#include &lt;iostream&gt; #include &lt;<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&gt; #include &lt;climits&gt; using <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> std; void put( const <span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;&amp; v ) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"capacity="</span></span> &lt;&lt; v.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">", size="</span></span> &lt;&lt; v.<span class="hljs-keyword"><span class="hljs-keyword">size</span></span>() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( unsigned i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; v.<span class="hljs-keyword"><span class="hljs-keyword">size</span></span>(); i++ ) cout &lt;&lt; v[ i ] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; cout &lt;&lt; endl; } <span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;&amp; operator +=( <span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;&amp; v, unsigned n ) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> last = v[ v.<span class="hljs-keyword"><span class="hljs-keyword">size</span></span>() - <span class="hljs-number"><span class="hljs-number">1</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( unsigned i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++ ) v.push_back( last + i + <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main( void ) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data[] = { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">6.</span></span>, <span class="hljs-number"><span class="hljs-number">7.</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = sizeof( data ) / sizeof( data[ <span class="hljs-number"><span class="hljs-number">0</span></span> ] ); <span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; array( data, data + n ); cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"max_size="</span></span> &lt;&lt; array.max_size() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ((INT_MAX+1)/2)="</span></span> &lt;&lt; ( (unsigned)INT_MAX + <span class="hljs-number"><span class="hljs-number">1</span></span> ) / <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;&lt; endl; put( array ); put( array += <span class="hljs-number"><span class="hljs-number">2</span></span> ); put( array += <span class="hljs-number"><span class="hljs-number">6</span></span> ); }</code> </pre> <br><pre>  Description vector &lt;float&gt; (this is the previously mentioned template in the class description) declares an object &lt;/ b&gt; in the code: vector </pre>  elements of <b>type</b> float.  Next we see such methods of the vector class as max_size () - the maximum possible length of the vectors in general (implementation constant), size () - the current <b>size</b> (number of elements) of the vector, capacity () - the current <b>capacity of the</b> vector, the maximum number of elements that can be placed in the vector in its current <b>placement</b> .  Execution of this fragment will give something like the following (details may vary depending on the implementation): <br><br><pre> <code class="dos hljs">$ ./vect1 max_size=<span class="hljs-number"><span class="hljs-number">1073741823</span></span> ((INT_MAX+<span class="hljs-number"><span class="hljs-number">1</span></span>)/<span class="hljs-number"><span class="hljs-number">2</span></span>)=<span class="hljs-number"><span class="hljs-number">1073741824</span></span> capacity=<span class="hljs-number"><span class="hljs-number">7</span></span>, size=<span class="hljs-number"><span class="hljs-number">7</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> capacity=<span class="hljs-number"><span class="hljs-number">14</span></span>, size=<span class="hljs-number"><span class="hljs-number">9</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> capacity=<span class="hljs-number"><span class="hljs-number">28</span></span>, size=<span class="hljs-number"><span class="hljs-number">15</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre><br>  Here you can see quite an interesting behavior of the vector (this is its meaning): as soon as adding the next element of the vector, its <b>capacity</b> becomes insufficient for one more element, a <b>new</b> placement of the vector is made, reserving the double capacity for it (with a margin, so that the next addition of a new element did not immediately require new relocation). <br><br>  <b>Note:</b> Doubling the capacity of a vector with relocation shown above is a typical behavior for the implementation of the GCC compiler libraries.  But the standard leaves the implementation of the exact algorithm for reserving capacity for future elements, so you cannot count on it, and it is described here only for a qualitative understanding of the picture (Visual Studio implementations behave differently, reserving only a small excess ... you will learn this yourself). <br><br>  We note further, with no comments so far, the important fact that the operation of placing elements into a container performs <b>copying of the element</b> , which entails a). Requiring a copy constructor for the type of elements and b). For structural elements, this can lead to noticeable performance costs. . <br><br>  Thus, we obtained the equivalent of a C ++ array, the <b>size of</b> which (size ()) dynamically changes in arbitrary limits from a few units to millions of elements.  Note (this is very important) that an increase in the size of a vector is not achieved by indexation beyond its current size, but by pushing (the push_back () method) <b>to the end of the</b> vector (symmetrically, the pop_back () method pushes the last element from the array and reduces its size ()).  Another way to change the size of a vector is to immediately call the resize () methods to the desired size.  It is precisely because the size of the vector, unlike the array, can dynamically change, for the vector there are <b>2 different</b> ways of indexing: as an <b>operation</b> [i] and as a <b>method function</b> at (i).  They <b>differ</b> : the at () method checks the current size of the size () vector, and when indexing beyond its boundary, throws an <b>exception</b> .  In contrast, the indexing operation does not check the boundary, which is not safe, but it is faster.  The at () method allows us to control the output of the vector and either qualify it as a logical error, or adjust the current container size to fit the need, as in such a fragment (here, access attempts are twice as large as the actual operations performed): <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; nums; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { nums.at( i ) = i; <span class="hljs-comment"><span class="hljs-comment">// vector::at throws an out-of-range i++; } catch( const out_of_range&amp; ) { cout &lt;&lt; i &lt;&lt; " "; nums.resize( i + 1 ); } } cout &lt;&lt; endl &lt;&lt; nums.size() &lt;&lt; endl; }</span></span></code> </pre><br><pre> <code class="dos hljs">$ ./vect7 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  The C ++ 11 standard introduces additional expressive means, such as, for example, initialization lists and type deducibility, which greatly simplify the work with containers (and even make old customary recording techniques unnecessary).  This is how a matrix can be described when its a) are simultaneously described.  configuration (square, although it may be rectangular and even triangular), b).  dimension (3x3) and c).  initializing values: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &gt;&amp; m )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;row : m ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x : row ) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &gt;&amp; m )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m.size(); i++ ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> j = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; m[ i ].size(); j++ ) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tmp = m[ i ][ j ]; m[ i ][ j ] = m[ j ][ i ]; m[ j ][ i ] = tmp; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; &gt; matrix = { { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }, { <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> }, { <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span> } }; print( matrix ); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"---------"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; trans( matrix ); print( matrix ); }</code> </pre><br>  And at the same time, work with vectors is shown here (transposition of a square matrix and output to the output stream) as with pseudo-arrays (using only indexing), which are essentially the vectors (in particular, it is shown how the type of the element is determined based on output type according to C ++ 11 standard): <br><br><pre> <code class="dos hljs">$ ./vect6 <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> --------- <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br>  <b>Note:</b> Within the framework of what we already know about vectors, the question sometimes arises: how strictly should the <b>type of the</b> returned size () result be determined (to avoid platform dependence) and, accordingly, any variable cycles operating with the vector size?  From time to time, the followers of the syntax purity follow the answer that it must be size_t, and this answer is incorrect (especially since for many platforms size_t is defined as unsigned int).  If you want to write an absolutely strict definition of the size () type of a vector, then the line in the example above should be written like this: <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( vector&lt;float&gt;::size_type <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; m[ <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> ].<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++ ) { ...</code> </pre><br>  Or, relying on the derivability of C ++ 11 types, like this: <br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( auto <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; m[ <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> ].<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++ ) { ...</code> </pre><br>  Having noted this subtle nuance here (having taken note of it), we <b>will not</b> use it further, in order to avoid unnecessarily cumbersome examples, but we will use unsigned for dimensions. <br><br>  <b>PS</b> Who may be interested in this, the archive of <b>all</b> code examples for testing and further experiments (both the previous and this parts, and all subsequent ones) can be taken <a href="https://yadi.sk/d/xZRwdOJQprq7F">here</a> or <a href="https://drive.google.com/file/d/0B__cqmYoRw_6Wnk1ajA4NmR0Zmc/view%3Fusp%3Dsharing">here</a> , so as not to bash all this manually. </div><p>Source: <a href="https://habr.com/ru/post/278369/">https://habr.com/ru/post/278369/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278359/index.html">MSLibrary. Capturing and verifying phone numbers using regular expressions, for iOS and not only ... Part 2</a></li>
<li><a href="../278361/index.html">Preparing for the CISA exam. Benefits of Business Continuity</a></li>
<li><a href="../278363/index.html">Alljoyn: embedded view of the developer. Part 3: Porting on MK SAMD21</a></li>
<li><a href="../278365/index.html">Study Jam courses for Android developers started in Kazan</a></li>
<li><a href="../278367/index.html">Red Hat, Revolution R, Elasticsearch, MariaDB, Blockchain-as-a-service and much more is available in the Azure Marketplace</a></li>
<li><a href="../278373/index.html">Review of physics in Sonic games. Parts 3 and 4: Jumping and Spinning</a></li>
<li><a href="../278377/index.html">Managing ES6 class private data</a></li>
<li><a href="../278383/index.html">Video analytics 2.0 or what have left the objects. Part 1</a></li>
<li><a href="../278387/index.html">ExtJS 6 gallery with touch events</a></li>
<li><a href="../278389/index.html">Lua Micro Apache Framework</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>