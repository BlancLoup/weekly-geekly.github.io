<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>I think I began to understand what you meant!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To be sealed is a simple matter; be sealed in the search query and double. Read all the great web search engines today are able to correct errors in k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>I think I began to understand what you meant!</h1><div class="post__text post__text-html js-mediator-article">  To be sealed is a simple matter;  be sealed in the search query and double.  Read all the great web search engines today are able to correct errors in keywords in 1x and suggest queries in 2x;  after them the same I want to search for a smaller one.  Both pieces can be deftly implemented using an open search engine named <a href="http://sphinxsearch.com/">Sphinx</a> ;  In this post I will tell you exactly how. <br><br>  Well, for did you mean ("what did you mean") and other query completion ("do not you look for Vasya"). <br><a name="habracut"></a><br><br><h1>  Listen to your favorite song "Valenki"! </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start with the simple ones.  query completion.  The user begins to enter a search line, as you type, you want him to immediately show prompts (so that he doesn‚Äôt look for anything, but listened to ‚ÄúValenki‚Äù, like everyone else).  Perhaps even with the number of results.  How to do where to get the data? <br><br>  There are about two options: you can directly suggest user queries, and you can individual keywords. <br><br>  Keywords hint especially easy.  The indexing program with the unexpected name indexer has two equally unexpected keys: - <b>buildstops</b> , which forces the indexer instead of usually indexing to build a list of N most frequently occurring words (it is a dictionary), and to it - <b>buildfreqs</b> , which also causes the frequencies at the same time count (he is a frequency dictionary).  We take indexer, we build 10 thousand (it is possible 100) the most frequent words in our collection of documents: <br><br><pre> $ indexer myindex --buildstops dict.txt 10000 --buildfreqs
</pre><br><br>  We get something like this file: <br><br><pre> i 9533843
 and 5427048
 to 5418872
 the 5371581
 a 4282225
 you 2877338
 ...
</pre><br><br>  Next thing technology.  We create a SQL nameplate, write an import script for a dozen lines, use the usual LIKE for the prompt, sort the results by the frequency of the word.  LIKE on an index will turn out quite reasonably fast, tk.  looking for the beginning of the key.  For 1-letter queries, it would be nice to immediately calculate and cache the results so as not to shovel thousands of lines for each sneeze.  MySQL query cache, however, in theory will save, if enabled. <br><br><pre> CREATE TABLE keywords
 (
    keyword VARCHAR (255) NOT NULL,
    freq INTEGER NOT NULL,
    INDEX (keyword, freq)
 );

 SELECT * FROM keywords WHERE keyword LIKE 'valen%' ORDER BY freq DESC LIMIT 10
</pre><br><br>  Queries are almost the same.  Neither the sign nor LIKE go anywhere;  only instead of individual words now I want full lines.  You can and should take them in your request log, and from there, count the frequencies.  The log will have to be slightly processed with a file: the line ‚Äúvasya pupkin‚Äù from the point of view of the search coincides with ‚ÄúVasya!  Pupkin! ‚Äù, Why consider them different requests is not very comme il faut.  This is blocked by the Sphinx API <a href="http://sphinxsearch.com/docs/current.html">BuildKeywords ()</a> method: take an arbitrary query line, build keywords on it (with case reduction and all such), restore the normalized query string.  It is better to do all this by setting a persistent connection using the Open () method, otherwise it will work many times slower.  Well, and then on the thumb;  log, file, sort, uniq -c, import script, SQL table, LIKE, profit.  The file should look something like this: <br><br><pre> $ cl = new SphinxClient ();
 $ cl-&gt; Open ();
 foreach ($ log as $ entry)
 {
    $ keywords = $ cl-&gt; BuildKeywords ($ entry, "myindex", false);
    foreach ($ keywords as $ keyword)
       print $ keyword ["tokenized"].  "";
    print "\ n";
 }
</pre><br><br>  The import script from a text file about two fields in the SQL database is left as homework for readers. <br><br><h1>  I understood this hint. </h1><br><br>  Spread the tips, proceed to the correction of errors.  As you know, a Britney typo can be entered in <a href="http://labs.google.com/britney.html">slightly less than 600 different ways</a> .  But she also has a surname.  But they can search and not at all her!  Edak request with errors just will not find anything;  the page will be empty;  Adsense / Ydirect / Unameit will show bad ads;  no one will click;  your startup will burn out;  There will be no one to buy commercial services about Sphinx and the project will also die.  This is unacceptable, urgently need to correct keywords! <br><br>  Clearly, there is always an option to screw in ispell, aspell, hunspell, or any-trendy-today-spell.  Clearly, it always rests on either the quality of the xxxspell dictionary, or stupidly in its absence for the desired language.  It is clear that it does not help with neologisms (helper), spetsterminami (acidium acetylosalicylium), geographic names, etc.  Through this, I still want more.  And the blog is not about ispell, you need to match. <br><br>  Again, you need a frequency dictionary.  True, a larger size than 10K keywords - ‚Äúcorrect‚Äù a rare correct word into a close frequent word is not worth it.  A dictionary of 1 million words should usually suffice, for 10 million absolutely should, those.  the team turns into an indexer - buildstops dict.txt 10,000,000 - build freqs MYINDEXNAME (works at a speed of over 20 MB / sec on the C2D E8500, by the way).  Unlike prompts, searching SQL in such a dictionary does not help;  and more data, and the type of requests is not the same.  But help Sphinx. <br><br>  The main idea is as follows.  We generate for each word from the dictionary a <b>set of trigrams, those.</b>  <b>3 consecutive characters</b> .  We index trigrams with Sphinx.  To search for replacement options, we build trigrams for the error-word-error too, we look for them in the index.  There are several candidates.  The more trigrams coincided, the shorter the word length differs, and the more often the found variant is found, the better.  And now we will sort all this in more detail, on a live example. <br><br>  The created indexer --buildstops dictionary still looks like this (I chose another piece so that the words were longer, and the example is clearer): <br><br><pre> ...
 deal 32431
 created 32429
 light 32275
 needed 32252
 mood 32185
 death 32140
 behind 32136
 usually 32113
 action 32053
 line 32052
 pissed 32043
 ...
</pre><br><br>  For each word we need to create a unique ID, save the word itself and its frequency, build trigrams, and save all this to the base.  If there are typos in the indexed database, it makes sense to drop too few words, maybe.  with a good chance this is a typo. <br><br><pre> CREATE TABLE suggest (
    id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
    keyword VARCHAR (255) NOT NULL,
    trigrams VARCHAR (255) NOT NULL,
    freq INTEGER NOT NULL
 );

 INSERT INTO suggest VALUES
 ...
 (735, 'deal', '__d _de dea eal al_ l__', 32431),
 (736, 'created', '__c _cr cre rea eat ate ted ed_ d__', 32429),
 (737, 'light', '__l _li lig igh ght ht_ t__', 32275),
 (738, 'needed', '__n _ne nee eed ede ded ed_ d__', 32252),
 (739, 'mood', '__m _mo moo ood od_ d__', 32185),
 (740, 'death', '__d _de dea eat ath th_ h__', 32140),
 (741, 'behind', '__b _be beh ehi hin ind nd_ d__', 32136),
 (742, 'usually', '__u _us usu sua ual all lly ly_ y__', 32113),
 (743, 'action', '__a _ac act cti tio ion on_ n__', 32053),
 (744, 'line', '__l _li lin ine ne_ e__', 32052),
 (745, 'pissed', '__p _pi pis iss sse sed ed_ d__', 32043),
 (746, 'bye', '__b _by bye ye_ e__', 32012),
 ...
</pre><br><br>  You only need to index the field with trigrams, but to rank the candidates (those. Choosing the best correction) you still need the word length and the frequency of its occurrences in the collection. <br><br><pre> sql_query = SELECT id, trigrams, freq, LENGTH (keyword) AS len FROM suggest sql_attr_uint = freq sql_attr_uint = len </pre><br><br>  We identify suspicious words from the search query results: if the search results are too small (or not at all), analyze the $ result [‚Äúwords‚Äù] response section, look at the number of documents for each word.  If there are few documents, try to correct such a word.  For example, for the query ‚Äúgreen liight‚Äù in my test index, the number of occurrences for ‚Äúgreen‚Äù is 34421, for ‚Äúliight‚Äù only 2. Which of them to be transferred to correctional work is immediately clear.  Specific thresholds for ‚Äúlittle‚Äù are very individual for different collections of documents and requests.  Look in your dictionary and query log, pick up magic constants. <br><br>  Build trigrams, run a query on a trigram spec.  Since the word is typed with errors, <i>all</i> trigrams are unlikely to match.  On the other hand, if only one trigram coincides, such a candidate is also of little interest: this can happen only if the three letters in the middle of the word (and nothing more) match, or one letter at the beginning (and nothing more).  Well, we use <a href="http://sphinxsearch.com/docs/current.html">the quorum operator</a> , and that‚Äôs exactly what it is looking for: it gives out all documents where at least 2 trigrams coincided.  We also introduce a restriction on the length: we assume that the length of the correct variant differs by no more than 2 characters. <br><br><pre> $ len = strlen ("liight");
 $ cl-&gt; SetFilterRange ("len", $ len-2, $ len + 2);
 $ cl-&gt; Query ('"__l _li iig igh ght ht_ ht __" / 2', 'suggest');
</pre><br><br>  A bunch of found candidates must be sorted, and the best one out of it.  We recall what factors we have: <br><ol><li>  the more trigrams matched, the better; </li><li>  the smaller the word length, the better; </li><li>  the more common the found variant, the better. </li></ol><br><br>  All these factors fresh version of Sphinx is able to calculate and sort completely on the server side.  The number of matched trigrams can be calculated by the SPH_RANK_WORDCOUNT ranker (each trigram is a separate key word during our special search).  The difference in word length is equal to abs (len- $ len), and the frequency is stored in the freq attribute.  We calculate factors, put some together, and choose the best: <br><br><pre> $ cl-&gt; SetMatchMode (SPH_MATCH_EXTENDED2);
 $ cl-&gt; SetRankingMode (SPH_RANK_WORDCOUNT);
 $ cl-&gt; SetSelect ("*, @ weight + 2-abs (len- $ len) AS myrank");
 $ cl-&gt; SetSortMode (SPH_SORT_EXTENDED, "myrank DESC, freq DESC");
</pre><br><br>  Hurray, it works!  For the word liight, the fix light is successfully located.  (More precisely, Sphinx finds the ID, which then gets the string ‚Äúlight‚Äù from the base). <br><br>  This is how the demo attached to Sphinx 0.9.9-rc2 (see the misc / suggest directory inside the archive) is arranged, which can be immediately tested on your data without writing any additional code :-) <br><br>  The demo is immediately understandable, imperfect and subject to <a href="http://sphinxsearch.com/consulting.html">fine-tuning with a file</a> .  (Sorry, I could not resist.) There is a danger that, out of the box, PHP will not work with Russian because UTF-8 is expected, substr is used, and correspondingly without mbstring.overload = 7 nowhere.  Almost certainly have to rotate the FREQ_THRESHOLD, those.  the minimum number of occurrences, below which the word is considered a typo and does not fall into the special index;  for small data collections lower, for large ones increase.  For the same reasons (in order not to rank rare garbage above frequent non-garbage), it may be necessary to twist the formula for calculating myrank.  For example, add an extra oddinick to the number of matched trigrams for frequencies differing 1000 times: <br><br><pre> $ cl-&gt; SetSelect ("*, @ weight + 2-abs (len- $ len) + ln (freq) / ln (1000) AS myrank");
</pre><br><br>  In addition, the trigram focus is effective, but very simple, and does not take into account much.  The order of trigrams is not taken into account, although this is not a problem for words of reasonable length.  What is more interesting is not taken into account <i>how</i> people make mistakes: rearrangement of 2 adjacent letters by the number of trigrams is indistinguishable from replacing these letters with <i>any</i> (!) Others (for example, light / lihgt / limit);  does not take into account the proximity of letters on the keyboard;  does not take into account the phonetic proximity (actually / akshully).  A fairly obvious idea for improving the quality of corrections with a little blood: instead of 1 best option, we take out 10-20 pieces, count the <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D1%2586%25D0%25B8%25D1%258F_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0">Levenshtein distance</a> on the client, adjust the calculation results.  With big blood, you can just ‚Äúcount‚Äù a dozen or two candidates by any other samopisnym algorithm. <br><br>  In general, the demo will work out of the box.  But this is a demo, and nobody canceled a lot of space for further creative work.  Create, invent, write blogs, send patches! </div><p>Source: <a href="https://habr.com/ru/post/61807/">https://habr.com/ru/post/61807/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../61802/index.html">How do you feel about replacing standard form controls with "designer"?</a></li>
<li><a href="../61803/index.html">More than 1.2 billion views per day</a></li>
<li><a href="../61804/index.html">Virtual device with Yii for VMware</a></li>
<li><a href="../61805/index.html">Search for chemical reactions in Nigma made easy</a></li>
<li><a href="../61806/index.html">Google technology shopping</a></li>
<li><a href="../61808/index.html">404: Conference not found</a></li>
<li><a href="../61810/index.html">Second hacker festival in Paris</a></li>
<li><a href="../61815/index.html">UPD: Wi2Geo plugin for popular QIP, Miranda and Skype instant messengers + sources</a></li>
<li><a href="../61819/index.html">Work with sound in * nix. Part 2</a></li>
<li><a href="../61821/index.html">No more analog television in the US</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>