<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Eme? CDM? DRM? CENC? IDK! What you need to make your own video player in the browser</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What do all these abbreviations mean? What you need to develop an open source player to view videos from Amazon, Sky and other platforms and watch vid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Eme? CDM? DRM? CENC? IDK! What you need to make your own video player in the browser</h1><div class="post__text post__text-html js-mediator-article">  What do all these abbreviations mean?  What you need to develop an open source player to view videos from Amazon, Sky and other platforms and watch videos from any provider?  About how the process of streaming video, Sebastian Golash (Sebastian Golasch), spoke at the conference HolyJS 2018 Piter.  Under the cut - video and translation of his report. <br><br><img src="https://habrastorage.org/webt/et/to/7c/etto7cv1khykp68gwreip_8rfy4.jpeg"><br><br>  <i>At the moment, Sebastian (Sebastian Golasch) is a developer at Deutsche Telekom.</i>  <i>He worked with Java and PHP for a long time, and then switched to JS, Python and Rust.</i>  <i>For the past seven years, he has been working on the Qivicon smart home platform.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3Y3R_snaDDc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  A bit about the history of streaming video </h2><br>  First, let's look at the history of the web, how we came from QuickTime to Netflix in 25 years.  It all started in the 90s when Apple invented QuickTime.  Its use on the Internet began in 1993-1994.  At that time, the player could play video with a resolution of 156 √ó 116 pixels and a frequency of 10 FPS, without hardware acceleration (using only processor resources).  This format was focused on dial-up connection 9600 baud - it is 9600 bps, including service information. <br><br>  It was the time of the Netscape browser.  Video in the browser did not look too good, because it was not native to the web.  External software (same QuickTime) with its interface, which was visualized in the browser using the embed tag, was used for playback. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/664/455/137/664455137979de92508841f0d3ceaafa.png"><br><br>  The situation got a little better when Macromedia released the Shockwave Player (after absorbing Macromedia by Adobe, it became the Adobe Flash Player).  The first version of Shockwave Player was released in 1997, but video playback in it appeared only in 2002. <br><br>  They used the Sorenson Spark aka H.263 codec.  It has been optimized for small resolutions and small file sizes.  What does it mean?  For example, a video of 43 seconds, which was used to test the Shockwave Player, weighed only 560 Kbytes.  Of course, the film in such quality would not be very pleasant to watch, but the technology itself was interesting for that time.  However, as in the case of QuickTime, Shockwave Player in the browser required the installation of additional software.  This player had a lot of security problems, but the most important thing is that the video was still an add-on to the browser. <br><br>  In 2007, Microsoft released Silverlight, a bit like Flash.  We will not dig deep, but all these solutions had something in common - a ‚Äúblack box‚Äù.  All players worked like a browser add-on, and you had no idea what was going on inside. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/84b/418/52e/84b41852efd2fb39dbea144b2e898dfe.png"><br><br>
<h2>  Element &lt; <code>Video/</code> &gt; </h2><br>  In 2007, the company Opera offered to use the &lt; <code>Video/</code> &gt; tag, that is, to make a native video in the browser.  We use it today.  It is easy and convenient, and any video can be not only viewed, but also downloaded.  And even if we do not want to allow downloading videos, we cannot prohibit its loading into the browser.  The maximum is to make it so difficult to download video. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cac/3be/693/cac3be693c7a3328062521d828c12c38.png"><br><br>  The <code>&lt;Video/&gt;</code> is the exact opposite of the ‚Äúblack box‚Äù and viewing the source code is very simple. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca1/f23/708/ca1f237081ed5a6a9e648b65e05ea7a1.png"><br><br><h2>  DRM </h2><br>  However, you can‚Äôt just right-click on the video on Netflix and select ‚ÄúSave As‚Äù.  The reason for this is DRM (Digital Restrictions Management, Digital Restrictions Management).  This is not one technology and not a single application that performs any task.  This is a general term for such concepts as: <br><br><ul><li>  Authentication and User Encryption </li><li>  Content-dependent encryption </li><li>  Definition of rights and application of restrictions </li><li>  Review and update </li><li>  Output control and link protection </li><li>  Examination and tracking of violators </li><li>  Key and license management </li></ul><br>  To understand what DRM is, we need to examine its ecosystem, that is, to figure out which companies are involved.  It: <br><br><ul><li>  <b>Content owners</b> are at the top of the ecosystem.  For example, Disney, MGM or FIFA.  These companies produce content, and they have rights to it. </li><li>  <b>DRM Cores</b> are companies that provide DRM technology (for example, Google, Apple, Microsoft, etc.). Currently there are about 7‚Äì8 DRM technologies from different companies. </li><li>  <b>Service providers</b> - develop server software that encrypts video. </li><li>  <b>Browsers</b> that are actually players. </li><li>  <b>Content providers</b> are companies like Netflix, Amazon, Sky, etc. As a rule, they do not own the rights to the content, they license and distribute it. </li><li>  <b>Chip / device vendors</b> are also involved in the ecosystem, because DRM is not only software technology.  Some companies (mostly Chinese) develop chips that encode and decode video. </li></ul><br>  Have you ever wondered why when viewing videos on Netflix in a browser it doesn‚Äôt have a very high resolution (SD), but if you watch the same video on an Apple TV or on an Android TV Box, the same content is played in Full HD or 4K?  DRM is also responsible for this.  The fact is that manufacturers are always afraid of pirates who steal content.  Therefore, the less protected is the environment in which video decoding is performed, the poorer the quality is shown to the user.  For example, if decoding is performed programmatically (for example, in Chrome or Firefox), the video is shown in the worst quality.  In an environment where hardware capabilities are used for decoding (for example, if Android uses a GPU), the possibilities for illegal copying of content are less, and here the playback quality is higher.  Finally, the most secure environment is considered fully hardware (Apple TV or Android TV Box), where both decoding and playback are performed without engaging the software part. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f9/4fb/1bb/9f94fb1bb7c1fa9d31a02d2bf62950f0.png"><br><br>  But if we talk about browsers, then they are almost always decoding performed by software.  Different browsers use different systems for DRM.  Chrome and Firefox use Widevine.  This company is owned by Google and licenses their DRM applications.  Thus, to decode Firefox downloads DRM-library from Google.  In the browser you can see exactly where the download is coming from. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca9/49d/015/ca949d015734b50c36e8594b8f5a4370.png"><br><br>  Apple uses its own FairPlay system, which was created when the company introduced the first iPhones and iPads.  Microsoft also uses its development called PlayReady, which is built right into Windows.  In other cases, Widevine is most often used.  This system exists both as an application and as a hardware solution - chips that decode video. <br><br><h2>  CDM </h2><br>  The abbreviation CDM stands for Content Decryption Module.  This is some piece of software or hardware that can work in several ways: <br><br><ul><li>  Decrypt the video, after which it is visualized in the browser using the &lt;Video /&gt; tag. </li><li>  Decrypt and decode video, then transfer the raw video frames for playback to the browser. </li><li>  Decrypt and decode video, then transfer the raw video frames for playback using the GPU. </li></ul><br>  Despite GPU support, the second option is most often used (at least when it comes to Chrome and Firefox). <br><br><h2>  Layers of decoding and decryption in the browser </h2><br>  So how does all this work together?  To understand this, look at the decoding and decryption layers in the browser.  They are divided into: <br><br><ul><li>  JavaScript application - it tells the computer what kind of video I'm going to watch. </li><li>  A browser is a player that plays video content. </li><li>  Content decryption module. </li><li>  Digital rights management is all about video decoding (I couldn‚Äôt think of a better name, so I called it that way). </li><li>  Trusted runtime environment. </li><li>  In this case, the first two components are the DRM player, the content decryption module is the DRM client, and the last two components are the DRM core. </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/7da/87b/b2b7da87bf7b3b92ef4004f4d4b97800.png"><br><br>  What happens when you play video in a browser is shown in the image below.  She, of course, a little confused: there are a lot of arrows and flowers.  I'll walk through it in steps, using real cases to make it clearer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1e/982/bb7/b1e982bb7fe74fa39f08b00264987409.png"><br><br>  We will use Netflix as an example.  I wrote a debugging application. <br><br>  I started with what I think each of you would have started: I looked through the requests that Netflix makes when I launch the video, and saw a huge number of records. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b04/913/8d7/b049138d7a4da37f5b9b6c5e4da88bf3.png"><br><br>  However, if you leave only those that are really needed to play the video, it turns out that there are only three of them: manifest, license and the first fragment of the video. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/381/e12/a9f/381e12a9f194014ae19501e4e9ada763.png"><br><br>  The Netflix player is written in JavaScript and contains more than 76,000 lines of code, and, of course, I can‚Äôt completely disassemble it.  But I would like to show the main parts that are needed to play the protected video. <br><br>  We will start with the template: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ba/205/e6f/9ba205e6f022e4a99ffa373372c99047.png"><br><br><h2>  EME </h2><br>  But before we dive into the functions, we need to get acquainted with another technology - EME (Encrypted Media Extensions, encrypted media extensions).  This technology does not perform decryption and decoding; it is just a browser API.  EME serves as an interface for CDM, for KeySystem, for a server with a license, and for the server on which the content is stored. <br><br>  So let's start with getKeySystemConfig. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e68/179/765/e68179765d8d942b41efd0a05fb51cd4.png"><br><br>  It should be borne in mind that it depends on the provider, so the config that I give here works for Netflix, but does not work, say, for Amazon. <br><br>  In this config, we have to tell the backend system what level of trusted execution environment we can offer.  This may be secure hardware decoding or secure software decoding.  That is, we tell the system what hardware and software will be used for playback.  And this will determine the quality of the content. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0f/071/1dd/c0f0711ddf9da278d6ab4c23ff31f75c.png"><br><br>  After configuring the config, let's take a look at creating the initial MediaKeySystem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99a/62b/ccb/99a62bccbf59fc6c893db5b34b3e3c91.png"><br><br>  Here begins the interaction with the content decryption module.  You need to tell the API which DRM system and KeySystem we are using.  In our case, this is Widevine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e31/ff8/416/e31ff841688a7f78547c02723c31c11c.png"><br><br>  The next step is optional for all systems, but mandatory for Netflix.  Again, its need depends on the provider.  We need to apply a server certificate to our mediaKeys.  Server certificates are plain text in Netflix's Cadmium.js file that can be easily copied.  And when we apply it to mediaKeys, then all communication between the server with the license and our browser becomes secure thanks to the use of this certificate. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3c/601/dd1/d3c601dd109f2a67e84efe69ca76ba6a.png"><br><br>  When this is done, we need to refer to the original video element and say, ‚ÄúOk, this is the key system we want to use, and this is the hello video tag.  Let's unite you. ‚Äù <br><br><img src="https://habrastorage.org/getpro/habr/post_images/797/6cf/3ce/7976cf3ce8dacf000547d40084d16d22.png"><br><br>  And here is the last function that is needed to configure the video system. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/107/ce0/fa0/107ce0fa0c047fd77218983652e0aa89.png"><br><br>  This is a DRM session, or MediaKeySession.  It is just data that goes from the provider to the decryption module that signs requests.  This data is also plain text, which is hidden behind several functions in the Netflix player file, from where I copied it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed7/3a4/0a3/ed73a40a370d7744f55590fc9e23efa5.png"><br><br>  When we call create.Session in the mediaKeys object, we need to tell which video we support.  In this case, this is mp4.  This brings us back to the context of messaging with our CDM system.  We also need Netflix to apply the server certificate on base64 in each form, but all this config in the create session is again provided dependent on the DRM system. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b24/8ff/e27/b248ffe2709055f4eadc33eab77df455.png"><br><br>  The last function here below - keySession.generateRequest builds the license request in the background.  Or CDM builds a license query in the background.  In other words, these are raw binary data that we have to send to the licensed server in order to get a valid license in return. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43c/798/16e/43c79816e9006b0668d58555887017b7.png"><br><br>  Here interest is cenc.  This is an ISO encryption standard that defines the protection scheme for mp4 video.  In WebM, this is called differently, but the function does the same. <br><br>  The handleMessage is the EventListener interface that we configured.  When this event is triggered by a message event in keySession, we know that we are ready to receive a license from the server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ef/93b/e85/4ef93be85d1d8535408a1abed9ca9ec6.png"><br><br>  And in this callback, we only receive a request to the server with a license, which gives some binary data (they may also differ depending on the provider).  We use this data to update the current session by adding a license.  That is, as soon as we received a valid license from the server, our CDM knows that we can decode and decrypt the video. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/779/ef3/ea9/779ef3ea918671d1c4a2d2df8d9c404d.png"><br><br>  If we apply it to the diagram below, we get this: we want to play the video, and the JavaScript application says: ‚ÄúHello, browser!  I want to play the video! ‚Äù- then uses the Encrypted Media Extensions and makes a request to the License Functions in the Widevine CDM for a license.  This request is then returned to the browser, and we can exchange it for a valid license on the license server, and then we need to transfer this license back to CDM.  This process was shown in the code above. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a98/e80/622/a98e806221a4f2533f0155c8425a36b4.png"><br><br>  But note that we have not lost a single second of video, and all this we need to do in order to be able to play some videos in the future. <br><br><h2>  MSE </h2><br>  And another technology that we need to explore is MSE (Media Source Extensions, extensions for multimedia sources).  She could be called EME's half-sister (Encrypted Media Extensions).  This is also a browser API, and it has nothing to do with DRM.  I see it as a software interface to &lt; <code>Video/</code> &gt; Src.  With its help, you can create binary streams in JavaScript and apply video fragments to the &lt; <code>Video/</code> &gt; element.  Thus, thanks to it, the source of the &lt; <code>Video/</code> &gt; tag becomes dynamic. <br><br>  So, we can use extensions for multimedia sources, instantiate and make access to the video, then load the video fragments in parts and apply them to the &lt; <code>Video/</code> &gt; tag. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a1/8f5/99f/0a18f599f2422bc047ad16d71f32f9af.png"><br><br>  The point is that when you watch a two-hour video, you do not want to wait until it is fully loaded.  Instead, you cut it into small fragments ranging in size from about 30 seconds to 2 minutes and alternately apply them to the &lt; <code>Video/</code> &gt; element. <br><br>  Once our MediaSource buffer is ready and linked to the &lt; <code>Video/</code> &gt; element, we can add a SourceBuffer.  We again have to tell him which video format and which codecs we use, and then it will be created. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/49a/d01/b0f/49ad01b0fcb2745fd0243c9bd4cf0972.png"><br><br>  Finally, we can now begin to fetch individual fragments and send them to our SourceBuffer using the append method on the &lt;Video /&gt; element, receiving a dynamically created video.  This can also be used for other use cases, when people can independently combine different video elements, creating their own videos, but I would not like to dig into it too deeply. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d5/687/bc3/9d5687bc390e405b84977c99420abb4b.png"><br><br>  So this is almost the last step we have to take.  You have a distribution network, you have fragments, and then the browser sends encrypted and compressed fragments to CDM, where decryption and possibly decoding is performed.  Then the decrypted and uncompressed fragments are sent back to the browser, where they are visualized and displayed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/498/2d0/8a6/4982d08a6ee484ab5de56fb3cdb6d247.png"><br><br><h2>  Manifest </h2><br>  But there is one more thing.  How do we know which fragments we need to load, where do we download them, and when?  And this is the last part, the missing request from the manifest.  When we make a request to Netflix for a manifest, it needs a lot of data.  If we just want to play a video, then it matters for us which DRM system we use, which video we want to view (Netflix ID, which can be copied from the URL) and profiles.  Profiles determine the resolution at which we receive video, as well as in what language we receive audio tracks, in what format (stereo, Dolby Digital, etc.), whether we use subtitles, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/daf/b78/506/dafb7850664c7b2baba6894add61a79a.png"><br><br><h2>  MPEG-DASH </h2><br>  The most commonly used manifest format is MPEG-DASH.  True, Apple uses a different format - HSL, which looks like a list of files in the old Winamp player.  But Widevine and Microsoft use MPEG-DASH.  It is based on XML, and it defines everything: duration, buffer size, content types, when which fragments are loaded, fragments for different resolutions, and adaptive bitrate switching.  The latter means that if a user, for example, watches a video and the download speed drops, the playback does not stop, but the quality of the video simply deteriorates.  This is due to the fact that the manifest defines the same parts for different permissions, they have the same duration and the same indices.  Therefore, as the download speed decreases, the browser can simply switch to a stream with a lower resolution, without suspending the download or buffering the data. <br><br>  Here is the manifesto for the film ‚ÄúGuardians of the Galaxy‚Äù.  In it, we can see that at different download speeds people will get videos with different quality, as well as the fact that there are audio tracks for people with hearing impairments.  It also spells the presence of subtitles. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/785/a96/a6f/785a96a6fa6b13ed57bd6f5518f36fa1.png"><br><br>  We have a duration and an indication of the time from which to start playing.  This function is used, for example, when you interrupt viewing and then return to the video, starting from where you left off. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcc/349/b4c/dcc349b4c9b4a4eabfa26da95511185d.png"><br><br>  There is again robustness, which says: this fragment can be lost only if your system meets the requirements.  In this case, it is hardware decoding using Hardware Secure Codecs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a76/7c2/248/a767c224876945a69441fe4314114319.png"><br><br>  For the same part of the video, you can define as many fragments as you like with different resolutions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fa/202/d19/9fa202d1922b5e6d9aabb5a22f359d49.png"><br><br>  And then you get the URL to download the fragment, and the range parameter shows the range of values ‚Äã‚Äãin milliseconds. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35e/325/93c/35e32593c77c1c7b242ce0141e8b6fd3.png"><br><br>  This is the last part.  You also sometimes get a manifest from a CDN.  Some providers have a separate server for the delivery of fragments, but more often they come from the same machine as the manifest functionality.  When we downloaded the manifest, we know which fragments we need to download, we can send a request for fragments, and then decrypt and decode from CDM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/826/2e5/47d/8262e547d950d80ec737263c795ddab9.png"><br><br>  In general, that's all.  All that was said above is enough to develop an open source player for watching videos from Amazon, Sky and other platforms and watching videos of almost any provider. <br><br><h2>  MSL </h2><br>  Netflix considered that it was worth adding additional encryption of messages between the browser and the server.  They called it the "message security layer" - Message Security Layer, or MSL.  It doesn‚Äôt do anything directly with the video; it‚Äôs just an extra layer of encryption.  One of the reasons for introducing MSL is that HTTPS is not secure enough.  On the other hand, <a href="https://github.com/Netflix/Msl">MSL</a> is open source, so you can always see how it works.  Here I am not going to delve into this topic, and if you are interested, you can always find information about why Netflix does MSL in their blog.  GitHub has detailed implementation documentation and working implementations in Java. <br><br>  There is also a <a href="https://github.com/Asciidisco/Plugin.Video.Netflix">Python implementation</a> that we wrote with friends.  As far as I know, this is the only working open source client for Netflix.  He works with Kodi Media Center.  For visualization, you can use VLC Player or any other suitable software. <br><br><h2>  And again the "black box" </h2><br>  So, you saw what it took for us to implement all this, and how often I mentioned CDM - the ‚Äúblack box‚Äù that is downloaded from Google.  Thus, we again returned the video to the ‚Äúblack box‚Äù.  The beautiful &lt;Video /&gt; element is again hidden from us.  We have added third-party software that helps us, but which is still closed and which we cannot manage.  It can do a lot of inconspicuous things: tracking, analytics, sending data ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ef/e10/72c/7efe1072c1d1d1390451a08ba3897f33.png"><br><br>  This is what Tim Berners Lee said about this: <i>‚ÄúThus, in general, it is important to support EME as a relatively secure online environment in which you can watch movies, as well as the most convenient and one that makes it part of the interconnected discourse of humanity.‚Äù</i> <br><br>  But there are other opinions regarding this.  In particular, from the Electronic Frontiers Foundation, which until the advent of DRM was a member of the W3C.  That's what they say: <i>‚ÄúIn 2013, the EFF was disappointed to learn that the W3C had taken on the EME standardization project - encrypted media extensions.</i>  <i>In essence, we are talking about an API whose sole function was to provide DRM for a leading role in the browser ecosystem.</i>  <i>We will continue to fight to ensure that the Internet is free and open.</i>  <i>We will continue to sue the US government to repeal laws that make DRM so toxic, and we will continue to fight at the level of global law. "</i> <br><br>  It's hard for me to say how to treat this.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the one hand, I am always for open and free Internet, in which browsers there is no proprietary code that can send requests to unknown places. </font><font style="vertical-align: inherit;">On the other hand, we need services like Netflix that charge for video. </font><font style="vertical-align: inherit;">Perhaps they could create their own applications for playback, and then the Internet would refuse such kind of content.</font></font><br><br><blockquote>   , 24-25 ,    <b>HolyJS 2018 Moscow</b> ,      <a href="https://holyjs-moscow.ru/talks/6zmpksvqkamasoacmaikcw/">¬´The Universal Serial Web¬ª</a> :     WebUSB,    USB-  .     -,    . <br><br> PS  1-      <a href="https://holyjs-moscow.ru/registration/"></a> . ,     ‚Äî  50%   . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/426727/">https://habr.com/ru/post/426727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426717/index.html">Illusion of deception: visual-optical illusion based on retro-prediction</a></li>
<li><a href="../426719/index.html">Hackathon on Data Science in SIBUR: how it was</a></li>
<li><a href="../426721/index.html">Avoiding Fails in Product Development: 10 Tips from Rookee</a></li>
<li><a href="../426723/index.html">Microsoft partners are hoping to create a time capsule on the moon</a></li>
<li><a href="../426725/index.html">How to do things when they do not want to do</a></li>
<li><a href="../426729/index.html">TypeScript magic school: generics and type extensions</a></li>
<li><a href="../426731/index.html">CSS: interesting border-radius features</a></li>
<li><a href="../426733/index.html">Iron will not fail. How I prepare dozens of servers a day for a fight</a></li>
<li><a href="../426735/index.html">Welcome to the JETHACK hackathon</a></li>
<li><a href="../426737/index.html">Briefly about the architecture of neuromorphic processors: a view from the inside</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>