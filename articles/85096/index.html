<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET and working with unmanaged code. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=".NET and working with unmanaged code. Part 2 

 Those who have not read the first part - read 

 After completing the first part of the work, creating...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET and working with unmanaged code. Part 2</h1><div class="post__text post__text-html js-mediator-article">  .NET and working with unmanaged code.  Part 2 <br><br>  Those who have not read the first part - <a href="http://habrahabr.ru/blogs/net/84076/">read</a> <br><br>  After completing the first part of the work, creating structures, the task was complicated for me.  The library with which I needed to work - allocated an array, the size of which was not known until the launch.  He was dynamic, i.e.  the more data, the more array.  Here the task became more interesting, because  the old way, when it was enough to use a structure in which this size was specified, was no longer appropriate. <br><a name="habracut"></a><br>  Then I began to study marshaling further and found some more methods in the Marshal class that helped me solve the problem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And so, the task itself: <br>  - the input library takes a pointer to an array of pointers (void *) o_O <br>  - the contents of the array - this pointers to other arrays, for example, to an array of characters, where the file address is specified, pointers to int arrays, which contain some data <br><br>  Because  I would often have to call some code, I created a special static class UnMemory, its code is below <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///      </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> UnMemory <br> { <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">private</font> <font color="#0000ff">static</font> Queue&lt; <font color="#2B91AF">IntPtr</font> &gt; queue = <font color="#0000ff">new</font> Queue&lt; <font color="#2B91AF">IntPtr</font> &gt;(); <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> Enqueue( <font color="#2B91AF">IntPtr</font> ptr) <br> { <br> queue.Enqueue(ptr); <br> } <br> <br> <font color="#0000ff">private</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> FreeIntPtr( <font color="#2B91AF">IntPtr</font> ptr) <br> { <br> <font color="#0000ff">if</font> (ptr != <font color="#2B91AF">IntPtr</font> .Zero) <br> Marshal.FreeCoTaskMem(ptr); <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///      </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> FreeMemory() <br> { <br> <font color="#0000ff">while</font> (queue.Count &gt; 0) <br> { <br> <font color="#2B91AF">IntPtr</font> temp = queue.Dequeue(); <br> <font color="#008000">//  ,    </font> <br> Marshal.FreeCoTaskMem(temp); <br> } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  In this class, I defined a queue in which I would add all the pointers to the generated unmanaged memory, so that at the end I would call its static FreeMomory () method to completely clear the allocated memory.  To add a pointer to the queue, you must call UnMemory.Enqueue (ptr); <br>  It seemed to me more convenient than to refer to the signs to clear each of them.  After all, you can skip something and get a memory leak. <br><br>  Also, I needed another class, which I call UnMemory, which will allocate space in the unmanaged memory and fill it with data, and of course read from it. <br>  Its code is below <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;typeparam name="T"&gt;  &lt;/typeparam&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> UnMemory&lt;T&gt; <br> <font color="#0000ff">where</font> T : <font color="#0000ff">struct</font> <br> { <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///        </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;param name="memory_object"&gt;  &lt;/param&gt;</font> <br> <font color="#008000">/// &lt;param name="ptr"&gt;&lt;/param&gt;</font> <br> <font color="#008000">/// &lt;typeparam name="T"&gt;  &lt;/typeparam&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> SaveInMem(T memory_object, <font color="#0000ff">ref</font> <font color="#2B91AF">IntPtr</font> ptr) <br> { <br> <font color="#0000ff">if</font> ( <font color="#0000ff">default</font> (T).Equals(memory_object)) <br> { <br> <font color="#008000">//     </font> <br> ptr = Marshal.AllocCoTaskMem(Marshal.SizeOf( <font color="#0000ff">typeof</font> (T))); <br> UnMemory.Enqueue(ptr); <br> <font color="#0000ff">return</font> ; <br> } <br> <br> <font color="#0000ff">if</font> (ptr == <font color="#2B91AF">IntPtr</font> .Zero) <br> { <br> <font color="#008000">//     </font> <br> ptr = Marshal.AllocCoTaskMem(Marshal.SizeOf( <font color="#0000ff">typeof</font> (T))); <br> <br> <font color="#008000">//     </font> <br> Marshal.StructureToPtr(memory_object, ptr, <font color="#0000ff">false</font> ); <br> } <br> <font color="#0000ff">else</font> <br> { <br> <font color="#008000">//     </font> <br> Marshal.StructureToPtr(memory_object, ptr, <font color="#0000ff">true</font> ); <br> } <br> <br> UnMemory.Enqueue(ptr); <br> } <br> <br> <font color="#008000">/// &lt;typeparam name="T"&gt;IntPtr, int, float&lt;/typeparam&gt;</font> <br> <font color="#008000">/// &lt;exception cref="System.ArgumentException"&gt; #1    IntPtr, int, float&lt;/exception&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> SaveInMem2(T[] managedArray, <font color="#0000ff">ref</font> <font color="#2B91AF">IntPtr</font> pnt) <br> { <br> Debug.Assert(managedArray != <font color="#0000ff">null</font> , <font color="#A31515">"    Null"</font> ); <br> Debug.Assert(managedArray.Length != 0, <font color="#A31515">"      0"</font> ); <br> <br> <font color="#0000ff">if</font> (pnt == <font color="#2B91AF">IntPtr</font> .Zero) <br> { <br> <font color="#008000">//     .  =    * </font> <br> <font color="#008000">//int size = Marshal.SizeOf(typeof(T)) * managedArray.Length;</font> <br> <font color="#0000ff">int</font> size = Marshal.SizeOf(managedArray[0]) * managedArray.Length; <br> pnt = Marshal.AllocCoTaskMem(size); <br> } <br> <br> <font color="#008000">//     ,      Marshal.Copy</font> <br> <font color="#0000ff">if</font> ( <font color="#0000ff">typeof</font> (T) == <font color="#0000ff">typeof</font> ( <font color="#0000ff">int</font> )) <br> { <br> <font color="#0000ff">int</font> [] i = managedArray <font color="#0000ff">as</font> <font color="#0000ff">int</font> []; <br> Marshal.Copy(i, 0, pnt, i.Length); <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> ( <font color="#0000ff">typeof</font> (T) == <font color="#0000ff">typeof</font> ( <font color="#0000ff">byte</font> )) <br> { <br> <font color="#0000ff">byte</font> [] b = managedArray <font color="#0000ff">as</font> <font color="#0000ff">byte</font> []; <br> Marshal.Copy(b, 0, pnt, b.Length); <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> ( <font color="#0000ff">typeof</font> (T) == <font color="#0000ff">typeof</font> ( <font color="#0000ff">float</font> )) <br> { <br> <font color="#0000ff">float</font> [] f = managedArray <font color="#0000ff">as</font> <font color="#0000ff">float</font> []; <br> Marshal.Copy(f, 0, pnt, f.Length); <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> ( <font color="#0000ff">typeof</font> (T) == <font color="#0000ff">typeof</font> ( <font color="#0000ff">char</font> )) <br> { <br> <font color="#008000">//        </font> <br> <font color="#0000ff">byte</font> [] b = <font color="#2B91AF">Encoding</font> .Default.GetBytes(managedArray <font color="#0000ff">as</font> <font color="#0000ff">char</font> []); <br> Marshal.Copy(b, 0, pnt, b.Length); <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> ( <font color="#0000ff">typeof</font> (T) == <font color="#0000ff">typeof</font> ( <font color="#2B91AF">IntPtr</font> )) <br> { <br> <font color="#2B91AF">IntPtr</font> [] p = managedArray <font color="#0000ff">as</font> <font color="#2B91AF">IntPtr</font> []; <br> Marshal.Copy(p, 0, pnt, p.Length); <br> } <br> <font color="#0000ff">else</font> <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> ArgumentException( <font color="#A31515">" #1    IntPtr, int, float  char"</font> ); <br> <br> <font color="#008000">//  ,    </font> <br> UnMemory.Enqueue(pnt); <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;param name="ptr"&gt;&lt;/param&gt;</font> <br> <font color="#008000">/// &lt;param name="type"&gt;   &lt;/param&gt;</font> <br> <font color="#008000">/// &lt;returns&gt;  &lt;/returns&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> T ReadInMem( <font color="#2B91AF">IntPtr</font> ptr) <br> { <br> <font color="#0000ff">return</font> (T)Marshal.PtrToStructure(ptr, <font color="#0000ff">typeof</font> (T)); <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> T[] ReadInMem2( <font color="#2B91AF">IntPtr</font> ptr, <font color="#0000ff">int</font> size) <br> { <br> <font color="#0000ff">if</font> ( <font color="#0000ff">typeof</font> (T) == <font color="#0000ff">typeof</font> ( <font color="#0000ff">int</font> )) <br> { <br> <font color="#0000ff">int</font> [] memInt = <font color="#0000ff">new</font> <font color="#0000ff">int</font> [size]; <br> Marshal.Copy(ptr, memInt, 0, size); <br> <font color="#0000ff">return</font> memInt <font color="#0000ff">as</font> T[]; <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> ( <font color="#0000ff">typeof</font> (T) == <font color="#0000ff">typeof</font> ( <font color="#0000ff">byte</font> )) <br> { <br> <font color="#0000ff">byte</font> [] memByte = <font color="#0000ff">new</font> <font color="#0000ff">byte</font> [size]; <br> Marshal.Copy(ptr, memByte, 0, size); <br> <font color="#0000ff">return</font> memByte <font color="#0000ff">as</font> T[]; <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> ( <font color="#0000ff">typeof</font> (T) == <font color="#0000ff">typeof</font> ( <font color="#0000ff">float</font> )) <br> { <br> <font color="#0000ff">float</font> [] memFloat = <font color="#0000ff">new</font> <font color="#0000ff">float</font> [size]; <br> Marshal.Copy(ptr, memFloat, 0, size); <br> <font color="#0000ff">return</font> memFloat <font color="#0000ff">as</font> T[]; <br> } <br> <font color="#0000ff">else</font> <font color="#0000ff">if</font> ( <font color="#0000ff">typeof</font> (T) == <font color="#0000ff">typeof</font> ( <font color="#2B91AF">IntPtr</font> )) <br> { <br> <font color="#2B91AF">IntPtr</font> [] memIntPtr = <font color="#0000ff">new</font> <font color="#2B91AF">IntPtr</font> [size]; <br> Marshal.Copy(ptr, memIntPtr, 0, size); <br> <font color="#0000ff">return</font> memIntPtr <font color="#0000ff">as</font> T[]; <br> } <br> <font color="#0000ff">else</font> <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> ArgumentException( <font color="#A31515">" #1    int, float  char"</font> ); <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///   </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">class</font> UnArray <br> { <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;typeparam name="T"&gt;  &lt;/typeparam&gt;</font> <br> <font color="#008000">/// &lt;param name="array"&gt; &lt;/param&gt;</font> <br> <font color="#008000">/// &lt;returns&gt; &lt;/returns&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> T[,] Rank1_Rank2(T[] array, <font color="#0000ff">int</font> x, <font color="#0000ff">int</font> y) <br> { <br> T[,] res = <font color="#0000ff">new</font> T[x, y]; <br> <font color="#0000ff">int</font> size = Buffer.ByteLength(array); <br> Buffer.BlockCopy(array, 0, res, 0, size); <br> <font color="#0000ff">return</font> res; <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;typeparam name="T"&gt;  &lt;/typeparam&gt;</font> <br> <font color="#008000">/// &lt;param name="array"&gt; &lt;/param&gt;</font> <br> <font color="#008000">/// &lt;returns&gt; &lt;/returns&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> T[] ToRank1(T[,] array, <font color="#0000ff">int</font> x, <font color="#0000ff">int</font> y) <br> { <br> T[] res = <font color="#0000ff">new</font> T[x * y]; <br> <font color="#0000ff">int</font> size = Buffer.ByteLength(array); <br> Buffer.BlockCopy(array, 0, res, 0, size); <br> <font color="#0000ff">return</font> res; <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;typeparam name="T"&gt;  &lt;/typeparam&gt;</font> <br> <font color="#008000">/// &lt;param name="array"&gt; &lt;/param&gt;</font> <br> <font color="#008000">/// &lt;returns&gt; &lt;/returns&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> T[, ,] Rank1_Rank3(T[] array, <font color="#0000ff">int</font> x, <font color="#0000ff">int</font> y, <font color="#0000ff">int</font> z) <br> { <br> T[, ,] res = <font color="#0000ff">new</font> T[x, y, z]; <br> <font color="#0000ff">int</font> size = Buffer.ByteLength(array); <br> Buffer.BlockCopy(array, 0, res, 0, size); <br> <font color="#0000ff">return</font> res; <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;typeparam name="T"&gt;  &lt;/typeparam&gt;</font> <br> <font color="#008000">/// &lt;param name="array"&gt; &lt;/param&gt;</font> <br> <font color="#008000">/// &lt;returns&gt; &lt;/returns&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> T[] ToRank1(T[, ,] array, <font color="#0000ff">int</font> x, <font color="#0000ff">int</font> y, <font color="#0000ff">int</font> z) <br> { <br> T[] res = <font color="#0000ff">new</font> T[x * y * z]; <br> <font color="#0000ff">int</font> size = Buffer.ByteLength(array); <br> Buffer.BlockCopy(array, 0, res, 0, size); <br> <font color="#0000ff">return</font> res; <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;typeparam name="T"&gt;  &lt;/typeparam&gt;</font> <br> <font color="#008000">/// &lt;param name="array"&gt; &lt;/param&gt;</font> <br> <font color="#008000">/// &lt;returns&gt; &lt;/returns&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> T[, , ,] Rank1_Rank4(T[] array, <font color="#0000ff">int</font> x, <font color="#0000ff">int</font> y, <font color="#0000ff">int</font> z, <font color="#0000ff">int</font> w) <br> { <br> T[, , ,] res = <font color="#0000ff">new</font> T[x, y, z, w]; <br> <font color="#0000ff">int</font> size = Buffer.ByteLength(array); <br> Buffer.BlockCopy(array, 0, res, 0, size); <br> <font color="#0000ff">return</font> res; <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;typeparam name="T"&gt;  &lt;/typeparam&gt;</font> <br> <font color="#008000">/// &lt;param name="array"&gt; &lt;/param&gt;</font> <br> <font color="#008000">/// &lt;returns&gt; &lt;/returns&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> T[] ToRank1(T[, , ,] array, <font color="#0000ff">int</font> x, <font color="#0000ff">int</font> y, <font color="#0000ff">int</font> z, <font color="#0000ff">int</font> w) <br> { <br> T[] res = <font color="#0000ff">new</font> T[x * y * z * w]; <br> <font color="#0000ff">int</font> size = Buffer.ByteLength(array); <br> Buffer.BlockCopy(array, 0, res, 0, size); <br> <font color="#0000ff">return</font> res; <br> } <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  This class is generalized, which made it possible not to create a set of methods for each type separately.  The meaning of this class is that it converts arrays from managed memory to unmanaged and vice versa.  The SaveInMem method saves the structure we pass to it, the SaveInMem2 method saves an array, such as intPtr, Int, float ... The limitation is represented by the Marshal.Copy method itself, which implements copying separately for int, separately for byte and some others.  For each type, the poet needed to make his own call, such as if (typeof (T) == typeof (int)) <br><br>  The ReadInMem and ReadInMem2 methods for reading structures and arrays, similar to SaveMem and SaveMem2. <br><br>  As I said in the <a href="http://habrahabr.ru/blogs/net/84076/">first</a> part of the article, I had to work with multidimensional arrays, but the marshaling does not allow this, it can read and write only one-dimensional arrays.  Therefore, I create a subclass of UnArray, which is also generalized, has several methods that create arrays from one-dimensional to two-dimensional, three-dimensional, four-dimensional and vice versa.  True, I needed all these methods more in the first part, in the second, when working with arrays, they were hardly useful, although several methods could be added, then they would be useful. <br><br>  And so, now go directly to the challenge itself. <br>  From C, the call looks like this: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">extern</font> <font color="#A31515">"C"</font> <font color="#0000ff">int</font> __import TkzIvc( <font color="#0000ff">void</font> *mpGS[]);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  For C #, this call will look like this: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">[DllImport( <font color="#A31515">@"DllTkzIvc.dll"</font> )] <br> <font color="#0000ff">private</font> <font color="#0000ff">static</font> <font color="#0000ff">extern</font> <font color="#0000ff">int</font> _TkzIvc([In] <font color="#2B91AF">IntPtr</font> mpGS);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  It remains the most simple.  Make a wrapper for use <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">[StructLayout(LayoutKind.Sequential)] <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> mpSh_Struct : IDisposable <br> { <br> <font color="#0000ff">private</font> <font color="#2B91AF">IntPtr</font> [] mpSh = <font color="#0000ff">new</font> <font color="#2B91AF">IntPtr</font> [5]; <br> <font color="#0000ff">private</font> <font color="#0000ff">int</font> size_vetv; <font color="#008000">//  </font> <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///    </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;value&gt;   255 &lt;/value&gt;</font> <br> <font color="#008000">/// &lt;exception cref="System.ArgumentOutOfRangeException"&gt;,   ,  255 &lt;/exception&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> PathSh <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#0000ff">return</font> Marshal.PtrToStringAnsi( <font color="#0000ff">this</font> .mpSh[0]); <br> } <br> <font color="#0000ff">set</font> <br> { <br> <font color="#0000ff">if</font> ( <font color="#2B91AF">String</font> .IsNullOrEmpty( <font color="#0000ff">value</font> ) || <font color="#0000ff">value</font> .Length &gt; 255) <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> ArgumentOutOfRangeException( <font color="#A31515">"         255 "</font> ); <br> <font color="#0000ff">this</font> .mpSh[0] = Marshal.StringToHGlobalAnsi( <font color="#0000ff">value</font> ); <br> } <br> } <br> <br> <font color="#008000">///&lt;summary&gt;</font> <br> <font color="#008000">///   int[]</font> <br> <font color="#008000">///&lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">int</font> [] TypeV <br> { <br> <font color="#0000ff">get</font> { <font color="#0000ff">return</font> UnMemory&lt; <font color="#0000ff">int</font> &gt;.ReadInMem2( <font color="#0000ff">this</font> .mpSh[1], <font color="#0000ff">this</font> .size_vetv); } <br> <font color="#0000ff">set</font> { UnMemory&lt; <font color="#0000ff">int</font> &gt;.SaveInMem2( <font color="#0000ff">value</font> , <font color="#0000ff">ref</font> <font color="#0000ff">this</font> .mpSh[1]); } <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///   char u1[][6]</font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#008000">/// &lt;value&gt;     5 &lt;/value&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> [] u1 <br> { <br> <font color="#0000ff">get</font> <br> { <br> <font color="#008000">//     </font> <br> <font color="#0000ff">byte</font> [] mem = UnMemory&lt; <font color="#0000ff">byte</font> &gt;.ReadInMem2( <font color="#0000ff">this</font> .mpSh[2], <font color="#0000ff">this</font> .size_vetv * 6); <br> <font color="#008000">// ,       string[]</font> <br> <font color="#0000ff">int</font> length = <font color="#0000ff">this</font> .size_vetv; <br> <font color="#008000">//   </font> <br> <font color="#0000ff">string</font> [] res = <font color="#0000ff">new</font> <font color="#0000ff">string</font> [length]; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt; length; i++) <br> { <br> <font color="#008000">//     ,    String    </font> <br> res[i] = <font color="#2B91AF">Encoding</font> .Default.GetString(mem, i * 6, 6).TrimEnd( <font color="#A31515">'\0'</font> ); <br> } <br> <font color="#0000ff">return</font> res; <br> } <br> <font color="#0000ff">set</font> <br> { <br> <font color="#008000">//   char[]</font> <br> <font color="#0000ff">char</font> [] res = <font color="#0000ff">new</font> <font color="#0000ff">char</font> [ <font color="#0000ff">value</font> .Length * 6]; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt; <font color="#0000ff">value</font> .Length; i++) <br> { <br> <font color="#0000ff">if</font> ( <font color="#0000ff">value</font> [i] != <font color="#0000ff">null</font> ) <br> <font color="#0000ff">value</font> [i].CopyTo(0, res, i * 6, <font color="#0000ff">value</font> [i].Length); <br> } <br> <font color="#008000">// </font> <br> UnMemory&lt; <font color="#0000ff">char</font> &gt;.SaveInMem2(res, <font color="#0000ff">ref</font> <font color="#0000ff">this</font> .mpSh[2]); <br> } <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///   float[]</font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">float</font> [] EK1B1 <br> { <br> <font color="#0000ff">get</font> { <font color="#0000ff">return</font> UnMemory&lt; <font color="#0000ff">float</font> &gt;.ReadInMem2( <font color="#0000ff">this</font> .mpSh[4], <font color="#0000ff">this</font> .size_vetv); } <br> <font color="#0000ff">set</font> { UnMemory&lt; <font color="#0000ff">float</font> &gt;.SaveInMem2( <font color="#0000ff">value</font> , <font color="#0000ff">ref</font> <font color="#0000ff">this</font> .mpSh[4]); } <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">int</font> [] ParamSh <br> { <br> <font color="#0000ff">get</font> { <font color="#0000ff">return</font> UnMemory&lt; <font color="#0000ff">int</font> &gt;.ReadInMem2( <font color="#0000ff">this</font> .mpSh[3], 6); } <br> <font color="#0000ff">set</font> <br> { <br> <font color="#0000ff">this</font> .size_vetv = <font color="#0000ff">value</font> [0]; <font color="#008000">//   (ParamSh[0])</font> <br> UnMemory&lt; <font color="#0000ff">int</font> &gt;.SaveInMem2( <font color="#0000ff">value</font> , <font color="#0000ff">ref</font> <font color="#0000ff">this</font> .mpSh[3]); <br> } <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000ff">public</font> <font color="#0000ff">bool</font> Read( <font color="#0000ff">out</font> <font color="#0000ff">string</font> errorText) <br> { <br> <font color="#0000ff">try</font> <br> { <br> <font color="#2B91AF">IntPtr</font> t = <font color="#0000ff">new</font> <font color="#2B91AF">IntPtr</font> (); <br> UnMemory&lt; <font color="#2B91AF">IntPtr</font> &gt;.SaveInMem2( <font color="#0000ff">this</font> .mpSh, <font color="#0000ff">ref</font> t); <br> <br> _TkzIvc(t); <br> <br> mpSh = UnMemory&lt; <font color="#2B91AF">IntPtr</font> &gt;.ReadInMem2(t, <font color="#0000ff">this</font> .mpSh.Length); <br> <br> <font color="#0000ff">int</font> [] paramSh = <font color="#0000ff">this</font> .ParamSh; <font color="#008000">//  </font> <br> <font color="#0000ff">this</font> .size_vetv = paramSh[0]; <font color="#008000">//  </font> <br> errorText = <font color="#2B91AF">String</font> .Empty; <br> <font color="#0000ff">return</font> <font color="#0000ff">true</font> ; <br> } <br> <font color="#0000ff">catch</font> (DllNotFoundException) <br> { <br> errorText = <font color="#A31515">"  .         "</font> ; <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> <font color="#0000ff">catch</font> (Exception exp) <br> { <br> errorText = exp.Message; <br> <font color="#0000ff">return</font> <font color="#0000ff">false</font> ; <br> } <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Dispose() <br> { <br> <font color="#008000">//     </font> <br> UnMemory.FreeMemory(); <br> <br> <font color="#008000">//  ,   </font> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 1; i &lt; 5; i++) <br> { <br> <font color="#2B91AF">IntPtr</font> ptr = mpSh[i]; <br> <font color="#008000">// </font> <br> UnMemory.FreeIntPtr(ptr); <br> } <br> } <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  NOTE that for plain text strings, I used Marshal.StringToHGlobalAnsi (text).  Because  This is a special Marshal class method for reading and writing a plain text string that ends with a '\ 0' character. <br><br>  An array of pointers is stored in mpSh, and for all fields, get and set methods are implemented that write and read unmanaged memory almost transparently from the class itself.  The Read method transfers an array of pointers to unmanaged memory in order to later read the data from it (when the library is called, this data is filled in).  After calling Read, we can read the variable we need by simply referring to the desired field. <br><br>  However, there is one restriction ... it is better to get a link to the array (int [] paramSh = this.ParamSh), and only then work with it, rather than constantly referring to the field (this.size_vetv = this.ParamSh [0]).  Because when accessing, the data will be re-read from unmanaged memory.  Despite the fact that it goes fast, if there are many calls, it can take a long time. <br><br>  PS: this article has not been reviewed by CustomMarshaling.  Its essence is that you can fully customize how a certain structure should be maintained, with its help you can support different versions of your libraries.  For example, save DateTime as a String in a certain format, etc. Such cases are less common, so a separate article can be highlighted for this. <br><br>  Unfortunately I can not attach the source to the article, because  This will not approve the manual :) But I tried to bring the maximum code so that without source codes it was clear how to work with the marshaling.  If you find something incomprehensible, please write and I will answer your questions. <br></div><p>Source: <a href="https://habr.com/ru/post/85096/">https://habr.com/ru/post/85096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../85090/index.html">Innovations on Timelance.ru</a></li>
<li><a href="../85091/index.html">Hosting Performance Check</a></li>
<li><a href="../85092/index.html">Building and running HipHop-PHP</a></li>
<li><a href="../85094/index.html">Rare Microsystems MS-21C-E laptop</a></li>
<li><a href="../85095/index.html">Design Pattern "Adapter" / "Adapter"</a></li>
<li><a href="../85099/index.html">Ping.fm Why are you like this?</a></li>
<li><a href="../85100/index.html">Spell Checker in Visual Studio</a></li>
<li><a href="../85104/index.html">ASA. Configuring Intercept Authentication via AD and LDAP</a></li>
<li><a href="../85105/index.html">Installing RoR 3 beta + Ruby EE + Passenger on Ubuntu 9.10</a></li>
<li><a href="../85111/index.html">Obtics - functional reactive programming on .Net</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>