<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple data scrambling algorithms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sometimes you need to encrypt something, but to attract serious encryption algorithms like and out of place will be like a cannon on sparrows. For exa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple data scrambling algorithms</h1><div class="post__text post__text-html js-mediator-article">  Sometimes you need to encrypt something, but to attract serious encryption algorithms like and out of place will be like a cannon on sparrows.  For example, you need a simple protection of traffic from users / Trojans with <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BD%25D0%25B8%25D1%2584%25D1%2584%25D0%25B5%25D1%2580">sniffers</a> , but the data itself is not worth it to spend a lot of time on their encryption-decryption, and of the implementation itself, too.  Or you need to somehow secure the secrecy of some stored data from ordinary users.  It is clear that such algorithms will not stand up against targeted hacking attempts by professionals, but we will try to complicate the work with them, although such a task is usually not set.  This is usually called <i>scrambling</i> . <br><br>  Under the cut, I set out ideas for such algorithms and promise that they will be more complicated than an ordinary XOR with a fixed key.  Just in case, I draw attention to the fact that these algorithms do not pretend to be crypto-resistant, but I am sure that you will be able to find an application for them. <br><a name="habracut"></a><br><h5>  Prerequisites </h5><br>  It is assumed that a potential hacker either does not have access to the code that performs encryption, or does not have sufficient qualifications for reverse engineering, or the data are not so valuable as to waste time on heavier hacking methods. <br><br>  Probably everyone knows that in such cases, most often use a simple cyclic overlay key of a fixed length using the XOR operation.  And they still know very well that such protection does not withstand even a novice ‚Äúhacker‚Äù or advanced user.  I would like something more complicated, but simple to implement. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  And if you generate a key? </h5><br>  The first thing that comes to mind is to generate a long enough key to at least make it difficult to find the key length.  For example, use a certain pseudo-random number generator with input data known to both the sender and the receiver.  One of such frequently used generators is a <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B3%25D1%2580%25D1%2583%25D1%258D%25D0%25BD%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4">linear congruent</a> PRNG (GNSS is <i>a pseudo-random number generator</i> ).  Of course, we guess that this is bad, but what exactly is bad about this approach?  The problem is that it is quite difficult to generate parameters for the generator itself.  It is rather difficult to choose programmatically good parameters for a linear congruent PRNG so that the sequence is long and nondegenerate.  On this occasion, you can read in 3.2.1 in the book D. Knut "The Art of Programming".  Therefore, often these parameters are inserted into the code as constants and, as a result, the potential hacker receives many encrypted messages with one key, which greatly simplifies his work. <br><br><h5>  And what if the data itself is used to generate this pseudo-random sequence? </h5><br>  This idea struck me about 20 years ago, when I ‚Äúhelped‚Äù to write a diploma to a friend of my acquaintance.  At first glance it seems that this is impossible, because we need a generator that would produce the same sequence when encrypting and decrypting.  Oddly enough, it is this ‚Äúdeadly‚Äù thesis that gives us the path to the creation of such a generator.  Yes, we need an algorithm that changes the values ‚Äã‚Äãof its internal variables in the same way, if we give it the original byte (or whatever we have is the atomic coding unit) and the encrypted byte.  How to achieve this?  All ingenious is simple - to calculate the next key value, you can use <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BC%25D1%2583%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">commutative operations</a> for pairs of source-encrypted bytes.  Since the result of the operation does not depend on the order of the operands in the pair, it is obvious that such an algorithm will change its variables when decrypting in the same way as when encrypting, but the sequence of keys for other input data will be different. <br><br><h5>  An example of a key generator dependent on input data </h5><br>  To make it clearer, consider a simple example of such an algorithm. <br>  Let x <sub>n</sub> is the next code in the source data, k <sub>n</sub> is the current key, k <sub>n + 1</sub> is the next key value, y <sub>n</sub> is the encrypted code x <sub>n</sub> . <br>  Q (a, b) is a certain commutative function, i.e.  such that q (a, b) == q (b, a). <br>  F (a, b, c) is a certain integer function. <br>  Then, the (de) coding iteration can be described as: <br>  y <sub>n</sub> : = x <sub>n</sub> <b>xor</b> k <sub>n</sub> ; <br>  k <sub>n + 1</sub> : = F (k <sub>n</sub> , Q (x <sub>n</sub> , y <sub>n</sub> ), n); <br>  If for the F () function it is clear that its implementation is in general limited only by our imagination and common sense, then about Q (), you probably want to see the details, namely, what conditions it must meet to be commutative.  The easiest way to achieve this is to use arguments only in pairs in commutative operations, for example, xor, addition, multiplication.  Examples: <br>  <s>Q (a, b) = a <b>xor</b> b</s> .  ( <i>Corrected:</i> I guess I got excited, because when you impose a source and encrypted code, you get a key, which is undesirable. I personally use a bit more complex functions). <br>  Q (a, b) = ((a <b>xor</b> b) <b>or</b> 1) * ((a + b) <b>xor</b> 1). <br>  As you can see, it is not difficult to invent your super-duper Q () function.  Another thing is whether to make it difficult?  I think that there is no special meaning in its over-complication. <br><br><h5>  Well, now what's bad? </h5><br>  Yes, without knowing the code of the encoding function, it will be very difficult to read something.  But what clues still remain?  If the input parameters for the scrambler are the same, then <br><ol><li>  If two messages start with the same data, then the beginning of the encrypted data will be exactly the same; </li><li>  The key for the first code is the same; </li><li>  The length of the encrypted message exactly matches the length of the original message. </li></ol><br>  How to deal with it, but do not put your young life?  Of course, there can be many ways to fight, but I want to be cheap and angry, are there any?  I have a few ideas on this. <br>  To overcome the first two points, there is a very simple but effective technique.  When encrypting, insert random data before each message.  Even one byte (code) is enough.  Since the next key depends on the data, even for identical messages we will get different key sequences.  The recipient simply needs to drop this prefix after decrypting the message. <br>  To combat the third item, you can add random data before and / or after the message. <br><br><h5>  Any more ideas? </h5><br>  And then!  I always have ideas! <br>  Suppose you transfer data in a compressed form.  Or the data is already partially encrypted.  Or each message / block is rather long and consists of binary data with an approximately uniform distribution of codes.  In this case, any interference with the order of the codes in the message can significantly complicate the life of a potential hacker.  I am sure that you yourself can come up with some primitive byte mixer in the data block, but I did promise interesting and beautiful ideas. <br><br><h5>  Data shuffler </h5> <br>  Usually, to solve this problem, some HRMS are used to obtain pairs of code indices in a data block that swap places.  The trouble with this method is that it is difficult to guarantee that some of the data will not remain in the same place.  It is also not entirely clear how many permutations need to be made in order to achieve an acceptable result, although, for reliability, you can simply go through all the message codes and exchange each with a random one.  But there is one more trouble - if the generator has a poor distribution over the square (and the linear congruent is such a disease and it hurts, and moreover it is hopeless), then at certain block sizes one can run into a looping of the output values.  For a long time I went to the idea of ‚Äã‚Äãa fast pseudo-random data shuffler (shuffler) and I think that it deserves your attention not only as an algorithm for scrambling. <br><br>  A bit of theory.  In clause 3.2.1.2 of D. Knuth's ‚ÄúThe Art of Programming‚Äù book, you can find criteria for choosing a multiplier for a linear congruent generator so that the length of the generated sequence is equal to the module.  What does this mean?  This means that for a generator with module <i>m</i> each value from 0 to <i>m</i> -1 will be given exactly one time.  Why do we need it?  Recall that it would be advisable for our shuffler to ensure that all the bytes (codes) of the message changed their place.  That is, if the length of this data block is equal to this very <i>m</i> , then it will be sufficient for us to simply write the next input byte (code) of the message to the output buffer at an index equal to the next value from the generator.  The simplicity of this algorithm is so seductive that I could not pass by. <br><br>  But, as always happens with something seductive, it was not without problems.  Firstly, not all <i>m</i> equally <s>useful</s> are good.  From the same chapter of the same book, we see that if <i>m</i> is the product of primes in the first degree, then we cannot achieve a complete enumeration of the elements in principle (apart from iteration in a row, which is, of course, not interesting to us).  It turns out that we cannot get the generator we need with a given sequence length, and therefore, if we have messages of arbitrary length, then we cannot always find such a generator.  Dead end?  Do we really need arbitrary length generators?  Recall that for a potential burglar, knowing the length of a message is very useful.  Then we already know the method of struggle that we successfully used for the generator, depending on the input data.  That's right, you need to throw in random trash, and best of all before the useful data.  True, there is a problem in that in each block you need to somehow indicate the amount of useful information in it.  If in your case the length of all messages / data blocks is fixed, then you can fix and <i>m</i> choose the first value convenient for you that is longer than the length of the input block and satisfies the criterion from Theorem A from 3.2.1.3 from the book. <br><br>  Now about the criteria for the generator parameters <i>x <sub>n + 1</sub> = (a * x <sub>n</sub> + c) mod m</i> : <br><ol><li>  c and m are mutually simple; </li><li>  a - 1 is a multiple of p for all prime divisors p of the number m; </li><li>  a - 1 must be a multiple of 4 if m is a multiple of 4. </li></ol><br>  How would this achieve a little blood?  I suggest this option: <br>  <i>m</i> = 2 <sup>n</sup> , where n&gt; 3; <br>  <i>c</i> = p, p is a prime number &amp; p&gt; 2; <br>  <i>a</i> = 4 * k + 1. <br>  As it is easy to notice, all three conditions are fulfilled and such values ‚Äã‚Äãare quite easy to select. <br><br><h5>  Any more ideas? </h5><br>  The idea of ‚Äã‚Äãcombining a shuffler and a data-dependent generator is pretty obvious.  To do this, we first feed the generator the necessary amount of garbage to adjust the length of the message to the size of the shuffler block, and then run the data of the message itself.  All output codes are written by indices that we get from the shuffler. <br><br>  I think that's enough for today. <br><br>  <i>Corrections: Corrected the noticed time and crossed out a bad example.</i> <br></div><p>Source: <a href="https://habr.com/ru/post/116835/">https://habr.com/ru/post/116835/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../116824/index.html">Object tracking on video</a></li>
<li><a href="../116825/index.html">About documentation standards</a></li>
<li><a href="../116827/index.html">Operator comma</a></li>
<li><a href="../116830/index.html">Parsing XML with Simple Framework</a></li>
<li><a href="../116834/index.html">Sectional Symfony2 Application</a></li>
<li><a href="../116837/index.html">Signal quality criteria for WiMax networks</a></li>
<li><a href="../116838/index.html">We optimize the work process in the console</a></li>
<li><a href="../116840/index.html">New Year's Eve update on Habr√©</a></li>
<li><a href="../116842/index.html">Govnokod: the enemy must know in person</a></li>
<li><a href="../116843/index.html">Larry Page became CEO of Google</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>