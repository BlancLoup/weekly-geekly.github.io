<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write Telegram-bot on Rust, which will run the code on ... Rust?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Goodnight! Today I would like to briefly describe how to write a Telegram bot on Rust, which will run the code on Rust. The article does not have a go...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write Telegram-bot on Rust, which will run the code on ... Rust?</h1><div class="post__text post__text-html js-mediator-article"><p>  Goodnight!  Today I would like to briefly describe how to write a Telegram bot on Rust, which will run the code on Rust.  The article does not have a goal to make a full immersion in the API telegram_bot, Serde, Telegram or in the nuances of development on Rust.  Rather, it is exploratory in nature.  Peano numbers using the type system will not add. <br><img src="https://habrastorage.org/files/e1d/a90/000/e1da900003684042a932bb58d714ea01.png" alt="Preview of the article"></p><br><a name="habracut"></a><br><h1 id="sozdanie-bota-v-telegram">  Creating a bot in Telegram </h1><br><p>  <a href="https://web.telegram.org/">A temporary link to the bot, so that you can see the result</a> </p><br><p>  First, create a bot and get an HTTP API token. </p><br><p>  We go to <a href="https://web.telegram.org/">this guy</a> and write the following: </p><br><p> We initiate the creation of a new bot: <code>/newbot</code> . <br>  The answer of the godfather: </p><br><blockquote>  Alright, a new bot.  How are we going to call it?  Please choose a name for your bot. </blockquote><p>  In the answer we write the name of the bot we want to create: <code>rust</code> . <br>  The answer of the godfather: </p><br><blockquote>  Good  Now let's choose a username for your bot.  It must end in <code>bot</code> .  Like this, for example: TetrisBot or tetris_bot. </blockquote><p>  Following the directions, enter another name: <code>rustlanguage_bot</code> . <br>  The answer of the godfather: </p><br><blockquote>  Done!  Congratulations on your new bot.  You will find it at t.me/rustlanguage_bot.  You can now add a list of commands.  By the way, you‚Äôll be better than the username for it.  Just make sure the bot is fully functional before you do this.  Use this token to access the HTTP.  API:% TOKEN% For a description of the Bot API, see this page: <a href="https://core.telegram.org/bots/api">https://core.telegram.org/bots/api</a> </blockquote><p>  Fine.  Bot created.  <code>%TOKEN%</code> - this is actually the token. </p><br><h1 id="rust-playground">  Rust playground </h1><br><p>  Now a little about how and where to run the code that the user will send to the bot as a message. </p><br><p>  There is a <code>Rust Playground</code> service that allows you to run the simplest Rust code online.  We will use it.  It is located at this address: <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a> </p><br><p>  Following the link, we introduce a simple hello-world program: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>); }</code> </pre><br><p>  Open the <code>Network</code> tab from <code>DevTools</code> to see what and in what format it sends to get the results of the compilation: </p><br><p><img src="https://habrastorage.org/files/059/598/a6b/059598a6b37c4781b53ea79f13a04dfc.png" alt="Rust Playground Request"></p><br><p>  It seems to be all transparent and clear.  Let's try to reproduce from the console: </p><br><pre> <code class="hljs cmake">[loomaclin@localhost ~]$ curl -X POST -d '{<span class="hljs-string"><span class="hljs-string">"code"</span></span>:<span class="hljs-string"><span class="hljs-string">"fn main() {\n println!(\"Hello world!\");\n}"</span></span>,<span class="hljs-string"><span class="hljs-string">"version"</span></span>:<span class="hljs-string"><span class="hljs-string">"stable"</span></span>,<span class="hljs-string"><span class="hljs-string">"optimize"</span></span>:<span class="hljs-string"><span class="hljs-string">"0"</span></span>,<span class="hljs-string"><span class="hljs-string">"test"</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>,<span class="hljs-string"><span class="hljs-string">"separate_output"</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,<span class="hljs-string"><span class="hljs-string">"color"</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,<span class="hljs-string"><span class="hljs-string">"backtrace"</span></span>:<span class="hljs-string"><span class="hljs-string">"0"</span></span>}' https://play.rust-lang.org/evaluate.json {<span class="hljs-string"><span class="hljs-string">"program"</span></span>:<span class="hljs-string"><span class="hljs-string">"Hello world!\n"</span></span>,<span class="hljs-string"><span class="hljs-string">"rustc"</span></span>:<span class="hljs-string"><span class="hljs-string">"rustc 1.16.0 (30cf806ef 2017-03-10)\n"</span></span>}</code> </pre><br><p>  Great, let's go further. </p><br><h1 id="pishem-bota">  Write bot </h1><br><p>  Create a project: </p><br><pre> <code class="hljs pgsql">cargo <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> rust_telegram_bot <span class="hljs-comment"><span class="hljs-comment">--bin</span></span></code> </pre> <br><h4 id="dobavim-sleduyuschie-zavisimosti-v-cargotoml">  Add the following dependencies to <code>Cargo.toml</code> : </h4><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">dependencies</span></span>] telegram-bot = { git = <span class="hljs-string"><span class="hljs-string">"https://github.com/White-Oak/telegram-bot.git"</span></span> } hyper = <span class="hljs-string"><span class="hljs-string">"0.10.8"</span></span> hyper-rustls = <span class="hljs-string"><span class="hljs-string">"0.3.2"</span></span> serde_json = <span class="hljs-string"><span class="hljs-string">"0.9.10"</span></span> serde = <span class="hljs-string"><span class="hljs-string">"0.9.14"</span></span> serde_derive = <span class="hljs-string"><span class="hljs-string">"0.9.14"</span></span></code> </pre> <br><p>  I will briefly describe why they are needed: </p><br><ul><li><p>  <code>Serde</code> designed to serialize / deserialize data in various formats.  In this case, we need to work with JSON (serde_json) and pinch code generation (serde_derive); </p><br></li><li><p>  <code>Hyper</code> to work with the network will use the HTTP client, which it provides to interact with the Rust Playground.  Since the interaction is carried out via the HTTPS protocol, a battery in the form of <code>hyper-rustls</code> still needed; </p><br></li><li>  well and most importantly, for interaction with the Telegram API, we will use the ready-made <code>telegram-bot</code> library, but not specifically it, but fork of comrade @white_oak, which fitted it to work with the current version of <code>Hyper</code> . </li></ul><br><h4 id="v-srcmainrs-podklyuchim-vse-neobhodimye-biblioteki-i-moduli">  In <code>src/main.rs</code> include all the necessary libraries and modules: </h4><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> telegram_bot; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> hyper; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> hyper_rustls; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_json::Value; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> telegram_bot::{Api, MessageType, ListeningMethod, ListeningAction}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> hyper::client::Client; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> hyper::net::HttpsConnector; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> hyper_rustls::TlsClient;</code> </pre> <br><p>  Note: <code>#[macro_use]</code> used to include in the scope of the current program macros from the library to which this attribute was applied. </p><br><p>  In this line, we import modules from the library root to determine the type of message, the "wiretapping" method, and the structure representing the Telegram API: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> telegram_bot::{Api, MessageType, ListeningMethod, ListeningAction};</code> </pre> <br><p>  Using <code>enum</code> , we describe the possible types of responses from the server, and there are 2 of them in this case, when the program was compiled successfully, and when a compilation error occurred: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize, Debug)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[serde(untagged)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResponseType</span></span></span></span> { ProgramCompiled { program: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, rustc: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> }, ProgramCompileError { rustc: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> } }</code> </pre> <br><p>  Noticed the attribute <code>#[serde(untagged)]</code> , which was applied to the enumeration?  He says that when (de) serializing, for the enumeration options, no tag will be searched for that clearly indicates which one it is.  So how does <code>Serde</code> determine which response option from the server we received?  In fact, it will try to deserialize into each of the options until it reaches the first successful result.  More details about this can be found in the official documentation: <a href="https://serde.rs/enum-representations.html">https://serde.rs/enum-representations.html</a> . </p><br><p>  Define the structure for our query in the Rust Playground: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlaygroundRequest</span></span></span></span> { code: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, version: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, optimize: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, test: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, separate_output: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, backtrace: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> }</code> </pre> <br><p>  From the user input in this structure only the <code>code</code> field will go.  The rest is hard-coded, because we always do this :) (no) </p><br><p>  In the main function of the <code>main</code> program, we will create the Telegram API instance and make it print everything that came to the bot in the message: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> api = Api::from_env(<span class="hljs-string"><span class="hljs-string">"TOKEN"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"getMe: {:?}"</span></span>, api.get_me()); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> listener = api.listener(ListeningMethod::LongPoll(<span class="hljs-literal"><span class="hljs-literal">None</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = listener.listen(|u| <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(m) = u.message { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = m.from.first_name; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> m.msg { MessageType::Text(t) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"&lt;{}&gt; {}"</span></span>, name, t); } _ =&gt; {} } }); }</code> </pre> <br><p>  To check the performance of this code, run the program, not forgetting to pass the real token received earlier as the environment variable: </p><br><pre> <code class="hljs matlab">TOKEN=<span class="hljs-comment"><span class="hljs-comment">%TOKEN% cargo run</span></span></code> </pre> <br><p>  Let us analyze a bit what we wrote above. </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> api = Api::from_env(<span class="hljs-string"><span class="hljs-string">"TOKEN"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"getMe: {:?}"</span></span>, api.get_me());</code> </pre> <br><p>  Here we create an instance of the <code>Api</code> structure imported from <code>telegram_bot</code> , then create a bot listener in long-polling mode: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> listener = api.listener(ListeningMethod::LongPoll(<span class="hljs-literal"><span class="hljs-literal">None</span></span>));</code> </pre> <br><p>  Finally, we create a message processing loop using the <code>listen</code> function and matching by the message type pattern: </p><br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = listener.listen(|u| <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(m) = u.message { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = m.from.first_name; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> m.msg { MessageType::Text(t) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"&lt;{}&gt; {}"</span></span>, name, t); } _ =&gt; {} } });</code> </pre> <br><p>  We agree that we will transmit the code only in text form.  Files, etc. exclude.  For this, as you can see, all the other enumeration options for <code>MessageType</code> simply ignored. </p><br><p>  We process the <code>/rust</code> command by sending a request to the Rust Playground, and read the answer: </p><br><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t.starts_with(<span class="hljs-string"><span class="hljs-string">"/rust "</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> program = t.split(<span class="hljs-string"><span class="hljs-string">"/rust "</span></span>).collect(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tls = hyper_rustls::TlsClient::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> connector = HttpsConnector::new(tls); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = Client::with_connector(connector); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> playground_request = serde_json::to_string(&amp;PlaygroundRequest { code: program, version: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"stable"</span></span>), optimize: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"0"</span></span>), test: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, separate_output: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, color: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, backtrace: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"0"</span></span>), }) .unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> response = client .post(<span class="hljs-string"><span class="hljs-string">"https://play.rust-lang.org/evaluate.json"</span></span>) .body(&amp;playground_request) .send() .unwrap(); response.read_to_string(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result : {:?}"</span></span>, result); }</code> </pre> <br><p>  We process the request only if the message starts with a certain command ( <code>/rust</code> ): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t.starts_with(<span class="hljs-string"><span class="hljs-string">"/rust "</span></span>) {</code> </pre> <br><p>  And also pull out the program code that needs to be compiled: </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> program = t.split(<span class="hljs-string"><span class="hljs-string">"/rust "</span></span>).collect();</code> </pre> <br><p>  The <code>serde_json::to_string(&amp;PlaygroundReques { ... })</code> function serializes our query structure to a string.  The rest of the code refers to the initialization of the HTTPS client, sending and reading the request, more about this can be found here: <a href="https://hyper.rs/hyper/v0.10.7/hyper/index.html">https://hyper.rs/hyper/v0.10.7/hyper/index.html</a> . </p><br><p>  We process the come answer: </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result : ResponseType = serde_json::from_str(&amp;result) .unwrap_or(ResponseType::ProgramCompileError { rustc: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"     "</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { ResponseType::ProgramCompiled { program, .. } =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, program) } ResponseType::ProgramCompileError { rustc, .. } =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, rustc) } };</code> </pre> <br><p>  The <code>serde::from_str</code> deserializes the reply to one of our <code>enum</code> variants.  In case the answer could not be deserialized, for simplicity we wrap it in a compilation error variant with the appropriate text.  Next, we form our resulting message, which will be sent to the user, based on which of the <code>enum</code> options was presented.  Perhaps, for the first time, you see the pattern type <code>{ program, .. }</code> in the pattern matching, I will explain - this ignores the structure, which we do not need during the processing of this variant, when the structure is restructured. </p><br><p>  Sending compilation results to chat: </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result.len() &gt; <span class="hljs-number"><span class="hljs-number">500</span></span> { result.truncate(<span class="hljs-number"><span class="hljs-number">500</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(api.send_message(m.chat.id(), result, <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(m.message_id), <span class="hljs-literal"><span class="hljs-literal">None</span></span>));</code> </pre> <br><p>  At the end, we check the length of the message to exclude the results of the compilation with a large amount of output, and cut the case.  After we send the message, specifying the identifier of the chat from which the request for compilation came, and transmit the final result of the compilation.  We also send the id of the message you need to reply to.  The rest of the transmitted parameters are optional and are responsible for displaying the preview, the type of response, and the like. </p><br><h1 id="proveryaem-rabotosposobnost">  We check the performance </h1><br><p><img src="https://habrastorage.org/files/09d/87e/463/09d87e463f4348589fe7199cc334496b.png" alt="Chat with a rust telegram bot"></p><br><p>  Output to console: </p><br><pre> <code class="hljs tex"> Finished dev [unoptimized + debuginfo] target(s) in 2.38 secs Running `target/debug/rust_telegram_bot` getMe: Ok(User { id: 334562900, first_name: "rust", last_name: None, username: Some("rustlanguage_bot") }) &lt;Arsen&gt; /rust abc Result : "{<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>rustc<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>rustc 1.16.0 (30cf806ef 2017-03-10)<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>nerror: expected one of `!` or `::`, found `&lt;eof&gt;`<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>n --&gt; &lt;anon&gt;:1:1<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>n |<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>n1 | abc<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>n | ^^^<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>n<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>nerror: aborting due to previous error<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>n<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>n<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>}" &lt;Arsen&gt; /rust fn main() { println!("Hello habrahabr!"); } Result : "{<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>program<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>Hello habrahabr!<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>n<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>,<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>rustc<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>:<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span>rustc 1.16.0 (30cf806ef 2017-03-10)<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>n<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">"</span></span></span></span> }"</code> </pre><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  I think that's all.  Thanks to <a href="https://github.com/White-Oak">WhiteOak</a> for the <code>telegram_bot</code> fork. <br>  By the way, he has a project for binding to QML from Rust: <a href="https://github.com/White-Oak/qml-rust">https://github.com/White-Oak/qml-rust</a> .  Perhaps someone will be interesting. </p><br><p>  Any constructive criticism is welcome. <br>  The repository with the full code of this bot is located <a href="https://github.com/LooMaclin/rust_telegram_bot">here</a> . </p><br><p>  I almost forgot to leave a link to the chat of the Russian-speaking community Rust, where you will always be helped to cope with the language: <a href="https://gitter.im/ruRust/general">https://gitter.im/ruRust/general</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/326830/">https://habr.com/ru/post/326830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326818/index.html">Week before the International Mobile Conference MBLT17</a></li>
<li><a href="../326822/index.html">The main thing is the tail. Software development pipeline technology</a></li>
<li><a href="../326824/index.html">Scaling TLS</a></li>
<li><a href="../326826/index.html">Bash Scripts, Part 5: Signals, Background Tasks, Script Management</a></li>
<li><a href="../326828/index.html">Permafrost, coal mine and piqlFilm: a new approach to data storage and protection</a></li>
<li><a href="../326832/index.html">How to approach the analysis of the site in terms of a hacker and identify vulnerabilities?</a></li>
<li><a href="../326834/index.html">Amateur CNC?</a></li>
<li><a href="../326840/index.html">Mustached shooter with a polygonal belly. Part two</a></li>
<li><a href="../326846/index.html">A simple error in coding does not mean a non-fearful error.</a></li>
<li><a href="../326848/index.html">Android application performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>