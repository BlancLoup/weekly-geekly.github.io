<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating an emulator arcade machine. Part 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parts first , second , third . 

 The rest of the machine 
 The code we wrote to emulate an 8080 processor is quite general and can be easily adapted ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating an emulator arcade machine. Part 4</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="image"></div><br>  Parts <a href="https://habr.com/post/418635/">first</a> , <a href="https://habr.com/post/418683/">second</a> , <a href="https://habr.com/post/418699/">third</a> . <br><br><h2>  The rest of the machine </h2><br>  The code we wrote to emulate an 8080 processor is quite general and can be easily adapted to run on any machine with the C compiler. But in order to play the game itself, we need to do more.  We'll have to emulate the equipment of the entire arcade machine and write the code sticking the specific features of our computing environment to the emulator. <br><br>  (It may be interesting for you to look at the <a href="http://www.brentradio.com/SpaceInvaders.htm">schematic diagram of the</a> machine.) <br><a name="habracut"></a><br><h2>  Timings </h2><br>  The game runs on a 2-MHz 8080. Your computer is much faster.  To take this into account, we will have to come up with some mechanism. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Interruptions </h2><br>  Interrupts are designed to allow the processor to process tasks with precise execution times, such as I / O.  The processor can execute the program, and when the interrupt pin is triggered, it stops executing the current program and does something else. <br><br>  We need to simulate the way an arcade machine generates interrupts. <br><br><h2>  Graphics </h2><br>  Space Invaders draws graphics to its memory in the 0x2400 address range.  A real hardware video controller would read RAM and control the CRT display.  Our program will have to emulate this behavior by drawing a picture of the game in the window. <br><br><h2>  Buttons </h2><br>  The game has physical buttons that the program reads using the IN command of the 8080 processor. Our emulator will have to bind the IN input to these commands from the keyboard. <br><br><h2>  ROM and RAM </h2><br>  It is necessary to admit: we "cut off the corner" by creating a 16-kilobyte memory buffer, which includes the lower 16 KB of memory allocation of the processor.  In fact, the first 2 KB of memory allocation are real ROM (ROM, read-only memory).  We will need to put write operations in memory into a function so that it is impossible to write to ROM. <br><br><h2>  Sound </h2><br>  While we did not say anything about the sound.  Space Invaders has a cute analog sound scheme that reproduces one of 8 sounds, controlled by the OUT command, which is transmitted to one of the ports.  We will have to convert these OUT commands to play audio samples on our platform. <br><br>  It may seem like a lot of work, but it's not so bad, and we can move gradually.  The first thing we want to do is to see the screen, for which we will need interrupts, graphics, and part of the processing of IN and OUT commands. <br><br><h2>  Displays and updates </h2><br><h3>  The basics </h3><br>  You probably know the components of a video display system.  Somewhere in the system there is some kind of RAM that contains an image to display on the screen.  In the case of analog devices, there is equipment that reads this RAM and converts bytes into analog voltage transmitted to a monitor. <br><br>  A deeper understanding of the system will help us when it comes to analyzing the purpose of allocating memory and code functionality. <br><br>  Analog displays have refresh rate and timing requirements.  At any given time on the display is updated specific pixel.  The image transmitted on the screen is filled point by point, starting from the top left corner and up to the top right, then the first point of the second line, the last point of the second line, etc.  After the last line is drawn on the screen, the video controller can generate a Vertical Blank Interrupt (also known as VBI or VBL) interrupt. <br><br>  To ensure smooth animation, the image in RAM processed by the video controller cannot be changed.  If the update of RAM occurred in the middle of the frame, the viewer will see parts of the two images.  This leads to the effect of "breaking", when a frame that is different from the frame at the bottom is shown at the top of the screen.  If you've ever seen a line break, you know what it looks like. <br><br>  To avoid breaks, the software must do something to avoid transferring the location of the screen update.  And there is only one way to do this. <br><br>  VBL is generated after the last line is completed, and usually there is a certain amount of time before the first line is drawn again.  (This is the time of Vertical Blank, and it can be about 1 millisecond.) <br><br>  When you receive a VBL program begins to draw the screen on top. <br><br>  Each line is drawn before the process of reverse frame sweep. <br><br>  The CPU is always in front of a reverse hotkey and therefore avoids breaking lines. <br><br><div style="text-align:center;"><img src="http://www.emulator101.com/images/verticalretrace.jpg" alt="image"></div><br><h2>  Space Invaders Video System </h2><br>  A very informative <a href="http://computerarcheology.com/Arcade/SpaceInvaders/Hardware.html">page</a> tells us that Space Invaders has two video interruptions.  One is for the end of the frame, but it also generates an interrupt in the middle of the screen.  The page describes the screen update system ‚Äî the game draws graphics in the upper half of the screen when it receives an interrupt from the middle of the screen, and draws graphics at the bottom of the screen when it receives an interruption from the end of the frame.  This is a pretty smart way to eliminate line breaks, and a good example of what can be achieved when you develop hardware and software at the same time. <br><br>  We have to force the emulation of our automaton to generate such interrupts.  If we generate them with a frequency of 60 Hz, like the Space Invaders machine, then the game will be drawn with the correct frequency. <br><br>  In the next section, we will talk about interrupt mechanics and think about how to emulate them. <br><br><h2>  Buttons and Ports </h2><br>  8080 implements I / O using IN and OUT instructions.  It has 8 separate ports IN and OUT - the port is determined by the command data byte.  For example, <code>IN 3</code> will put port 3 in register A, and <code>OUT 2</code> will send A to port 2. <br><br>  I took the information about the purpose of each port from the <a href="http://computerarcheology.com/Arcade/SpaceInvaders/Hardware.html">Computer Archeology</a> website.  If this information were not available, we would have to get it by studying the concept, as well as by reading and step-by-step code execution. <br><br> <code>: <br>  1 <br>  0  (0,  ) <br> 1  Start   <br> 2  Start   <br> 3 ? <br> 4     <br> 5     <br> 6     <br> 7 ? <br> <br>  2 <br>  0,1 DIP-   (0:3,1:4,2:5,3:6) <br> 2 ""  <br> 3 DIP-  , 1:1000,0:1500 <br> 4     <br> 5     <br> 6     <br> 7    DIP-, 1:,0: <br> <br>  3    <br> <br>  2     ( 0,1,2) <br>  3    <br>  4    <br>  5    <br>  6  "" ? ,     , <br>       (0=a,1=b,2=c  ..) <br> <br> (  3,5,6      1=$01  2=$00 <br>    ,       (attract mode))</code> <br> <br>  There are three ways to implement I / O in our software stack (which consists of an 8080 emulator, machine code and platform code). <br><br><ol><li>  Embed knowledge about the machine in our 8080 emulator </li><li>  Embed the knowledge of the 8080 emulator in the code of the machine </li><li>  Invent a formal interface between the three parts of the code to enable the exchange of information through the API </li></ol><br>  I excluded the first option - it is fairly obvious that the emulator is at the very bottom of this call chain and should remain separate.  (Imagine that you need to re-use the emulator for another game, and you will understand what I mean.) In general, transferring high-level data structures to lower levels is a poor architectural solution. <br><br>  I chose option 2. Let me first show the code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode = state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*opcode == <span class="hljs-number"><span class="hljs-number">0xdb</span></span>) <span class="hljs-comment"><span class="hljs-comment">//machine specific handling for IN { uint8_t port = opcode[1]; state-&gt;a = MachineIN(state, port); state-&gt;pc++; } else if (*opcode == 0xd3) //OUT { uint8_t port = opcode[1]; MachineOUT(state, port); state-&gt;pc++; } else Emulate8080Op(state); }</span></span></code> </pre> <br>  This code re-implements the processing of opcodes for IN and OUT in the same layer that causes the emulator for the remaining commands.  In my opinion, this allows you to make the code cleaner.  This is similar to a redefinition or subclass for these two commands, which belongs to the automaton layer. <br><br>  The disadvantage is that we transfer the opcode emulation in two places.  I will not blame you for choosing the third option.  In the second variant, less code is required, but option 3 is more ‚Äúclean‚Äù, however the price is an increase in complexity.  This is a matter of style choice. <br><br><h2>  Shift register </h2><br>  The slot machine Space Invaders has an interesting hardware solution that implements the bit shift command.  The 8080 has commands to shift by 1 bit, but to implement a multi-bit / multi-byte shift, you will need dozens of 8080 commands. Special hardware allows the game to perform these operations in just a few instructions.  It draws every frame on the game field, that is, it is used many times per frame. <br><br>  I don‚Äôt think I can explain it better than Computer Archeology‚Äôs excellent <a href="http://computerarcheology.com/Arcade/SpaceInvaders/Hardware.html">analysis</a> : <br><br> <code>; 16- : <br> ; f 0  <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    4  x  y,     x, : <br> ; $0000, <br> ; write $aa -&gt; $aa00, <br> ; write $ff -&gt; $ffaa, <br> ; write $12 -&gt; $12ff, .. <br> ; <br> ;    2 ( 0,1,2)    8- , : <br> ; offset 0: <br> ; rrrrrrrr result=xxxxxxxx <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 2: <br> ; rrrrrrrr result=xxxxxxyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 7: <br> ; rrrrrrrr result=xyyyyyyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    3   .</code> <br> <br>  For the OUT command, the entry in port 2 sets the offset value, and the entry in port 4 sets the data in the shift registers.  Reading with IN 3 returns data shifted by the amount of shift.  In my machine, it is implemented like this: <br><br><pre> <code class="cpp hljs"> -(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) MachineIN(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> v = (shift1&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | shift0; a = ((v &gt;&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>-shift_offset)) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) MachineOUT(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: shift_offset = value &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: shift0 = shift1; shift1 = value; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><h2>  Keyboard </h2><br>  To get the automaton's response, we need to bind keyboard input to it.  Most platforms have a way to get keystroke and release events.  The platform code for the buttons will look like the following: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(PeekMessage(&amp;msg,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,PM_REMOVE)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYDOWN ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyDown(LEFT); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYUP ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyUp(LEFT); } }</code> </pre> <br>  The automat code sticking the platform code to the emulator code will look something like this: <br><br><pre> <code class="cpp hljs"> MachineKeyDown(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> key) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LEFT: port[<span class="hljs-number"><span class="hljs-number">1</span></span>] |= <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Set bit 5 of port 1 break; case RIGHT: port[1] |= 0x40; //Set bit 6 of port 1 break; /*....*/ } } PlatformKeyUp(char key) { switch(key) { case LEFT: port[1] &amp;= 0xDF //Clear bit 5 of port 1 break; case RIGHT: port[1] &amp;= 0xBF //Clear bit 6 of port 1 break; /*....*/ } }</span></span></code> </pre> <br>  If you wish, you can arbitrarily combine the code of the machine and the platform - this is the choice of implementation.  I will not do this, because I'm going to port the machine to several different platforms. <br><br><h2>  Interruptions </h2><br>  Having studied the directory, I realized that 8080 handles interrupts as follows: <br><br><ol><li>  The interrupt source (external to the CPU) sets the pin of the interrupt to the CPU. </li><li>  When the CPU confirms the interrupt reception, the interrupt source can send any opcode to the bus and the CPU will see it.  (Most often they use the RST command.) </li><li>  The CPU executes this command.  If it is RST, then it is analogous to the CALL command for a fixed address at the bottom of the memory.  She writes the current PC to the stack. </li><li>  The code in the lower memory address handles what the interrupt wants to tell the program.  After processing is completed, RST ends with a call to RET. </li></ol><br>  The video equipment of the game generates two interrupts that we must emulate programmatically: the end of the frame and the middle of the frame.  Both are performed at 60 Hz (60 times per second).  1/60 of a second is 16.6667 milliseconds. <br><br>  To simplify working with interrupts, I will add a function to the 8080 emulator: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interrupt_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//perform "PUSH PC" Push(state, (state-&gt;pc &amp; 0xFF00) &gt;&gt; 8, (state-&gt;pc &amp; 0xff)); //Set the PC to the low memory vector. //This is identical to an "RST interrupt_num" instruction. state-&gt;pc = 8 * interrupt_num; }</span></span></code> </pre> <br>  The platform code must implement a timer that we can call (for now, I'll just call it time ()).  The machine code will use it to transmit an interrupt to the 8080 emulator.  In the automaton code, when the timer expires, I will call GenerateInterrupt: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { Emulate8080Op(state); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( time() - lastInterrupt &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1/60 second has elapsed { //only do an interrupt if they are enabled if (state-&gt;int_enable) { GenerateInterrupt(state, 2); //interrupt 2 //Save the time we did this lastInterrupt = time(); } } }</span></span></code> </pre> <br>  There are some details of how the 8080 actually handles interrupts, which we will not emulate.  I believe that such processing will be enough for our purposes. </div><p>Source: <a href="https://habr.com/ru/post/419143/">https://habr.com/ru/post/419143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419131/index.html">The preliminary launch date of the SpaceIL lunar module has been announced.</a></li>
<li><a href="../419133/index.html">Friday webinars: learning to program for free</a></li>
<li><a href="../419135/index.html">Friday JS: a game of 0 lines JS and CSS</a></li>
<li><a href="../419137/index.html">Logging of activity using Web Beacon API</a></li>
<li><a href="../419141/index.html">In the United States is gaining momentum sex phishing</a></li>
<li><a href="../419145/index.html">Fintech Digest: Apple's capitalization exceeded $ 1 trillion, AI helped eBay raise billions in revenue</a></li>
<li><a href="../419147/index.html">1000-dimensional cube: is it possible to create a computational model of human memory today?</a></li>
<li><a href="../419149/index.html">Mikrotik RoMON Guide</a></li>
<li><a href="../419151/index.html">Smart home: a new dimension of comfort and commitment to excellence. Part two</a></li>
<li><a href="../419155/index.html">Porting JS to Elbrus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>