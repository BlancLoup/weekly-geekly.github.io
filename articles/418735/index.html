<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Focusing on ownership</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note translator: the record is dated May 13, 2014, so some details, including the source code, may not correspond to the current state of affairs. The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Focusing on ownership</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Note</em>  <em>translator: the record is dated May 13, 2014, so some details, including the source code, may not correspond to the current state of affairs.</em>  <em>The answer to the question of why a translation of such an old post is needed will be the value of its content for developing an understanding of such one of the fundamental concepts of the Rust language as possession.</em> </p><br><p>  Over time, I became convinced that it would be better to abandon the distinction between mutable and immutable local variables in Rust.  At least, many people are <a href="http://www.reddit.com/r/rust/comments/2581s5/informal_survey_which_is_clearer_mutability_or/">skeptical</a> about this issue.  I wanted to state my position in public.  I will cite various motives: philosophical, technical and practical, and also turn to the main defense of the current system.  (Note: I viewed this as a Rust RFC, but decided that the tone was better for a blog post, and I don‚Äôt have time to rewrite it now.) </p><a name="habracut"></a><br><h2 id="poyasnenie">  Explanation </h2><br><p>  I wrote this article quite strongly and I believe that the line I advocate will be correct.  However, if we do not end up maintaining the current system, it will not be a disaster or something like that.  It has its advantages, and in general I find it quite enjoyable.  I just think we can improve it. </p><br><h2 id="odnim-slovom">  In a word </h2><br><p> I would like to remove the distinction between immutable and mutable local variables and rename the <code>&amp;mut</code> pointers to <code>&amp;my</code> , <code>&amp;only</code> or <code>&amp;uniq</code> (it <code>&amp;uniq</code> no difference to me).  If only there was no keyword <code>mut</code> . </p><br><h2 id="filosofskiy-motiv">  Philosophical motive </h2><br><p>  The main reason I want to do this is that I think it will make the language more consistent and easy to understand.  Essentially, this reorients us from talk about <em>changeability</em> to talk about the <em>use of pseudonyms</em> ("aliasing") (which I will call <strong>"sharing"</strong> (see "sharing"), see below). </p><br><p>  Variability becomes a consequence of the uniqueness that follows: "You can always change everything you have unique access to. Shareable data is usually immutable, but if you need, you can change it using a certain type of <code>Cell</code> type." </p><br><p>  In other words, over time it became clear to me that problems with data races and memory security arise when you have <em>both</em> pseudonyms and volatility <em>at the same time</em> .  A functional approach to solving this problem is to eliminate variability.  Rust's approach would be to remove the use of pseudonyms.  This gives us a story that can be told, and which will help us to understand. </p><br><p>  Terminology note: I think that we should refer to the <em>use of pseudonyms</em> as <em>division</em> ( <em>note: translator: hereinafter, instead of "aliasing" we use "sharing" in the meaning of "sharing" or "shared ownership", since neither "use of pseudonyms", Neither "pseudonymy" gives an understanding of what is at stake</em> ).  In the past, we avoided this because of its multi-threaded references.  However, if / when we implement <a href="http://smallcultfollowing.com/babysteps/blog/2014/02/25/rust-rfc-stronger-guarantees-for-mutable-borrows/">plans for</a> <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/11/data-parallelism-in-rust/">paralleling the data</a> that I proposed, then this connotation is not entirely inappropriate.  In fact, <a href="http://smallcultfollowing.com/babysteps/blog/2013/06/11/on-the-connection-between-memory-management-and-data-race-freedom/">given the close relationship</a> between memory security and data races, I really want to promote this connotation. </p><br><h2 id="obrazovatelnyy-motiv">  Educational motive </h2><br><p>  I think that the current rules are more difficult to understand than they should be.  It is not obvious, for example, that <code>&amp;mut T</code> implies any shared ownership.  In addition, the notation <code>&amp;mut T</code> assumes that <code>&amp;T</code> does not imply any changeability, which is not entirely accurate, due to types such as <code>Cell</code> .  And it is impossible to agree on how to call them (‚Äúchangeable / immutable links‚Äù is the most common, but this is not entirely correct). </p><br><p>  In contrast, a type like <code>&amp;my T</code> or <code>&amp;only T</code> seems to simplify explanations.  This is a <em>unique link</em> - naturally, you cannot force two of them to point to the same place.  And <em>variability</em> is an orthogonal thing: it comes from uniqueness, but it also holds for cells.  And the type <code>&amp;T</code> is just its opposite, a <em>shared link</em> .  <a href="https://github.com/rust-lang/rfcs/pull/58">RFC PR # 58</a> gives a number of similar arguments.  I will not repeat them here. </p><br><h2 id="prakticheskiy-motiv">  Practical motive </h2><br><p>  Currently, there is a gap between borrowed pointers, which can be either shared or changeable + unique, and local variables, which are always unique, but can be changeable or immutable.  The end result of this is that users must place <code>mut</code> ads on things that are not directly editable. </p><br><h3 id="lokalnye-peremennye-ne-mogut-byt-smodelirovany-s-ispolzovaniem-ssylok">  Local variables cannot be modeled using links. </h3><br><p>  This phenomenon arises from the fact that links are not as expressive as local variables.  In general, this prevents the abstraction.  Let me give a few examples to explain what I mean.  Imagine that I have an environment structure that stores a pointer to an error counter: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Env</span></span></span></span> { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Now I can create instances of this structure (and use them): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  OK, now imagine that I want to isolate the code that changes <code>env.errors</code> into a separate function.  I would think that since the <code>env</code> variable is not declared as mutable, I can use an immutable <code>&amp;</code> reference: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;env); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span></span>(env: &amp;Env) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_condition { *env.errors += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  } }</span></span></code> </pre> <br><p>  But it is not.  The problem is that <code>&amp;Env</code> is a type with shared ownership ( <em>note of the translator: as you know, there can be more than one immutable object reference at a time</em> ), and therefore <code>env.errors</code> appears in a space that allows for separate ownership of the <code>env</code> object.  For this code to work, I must declare <code>env</code> as mutable and use the <code>&amp;mut</code> reference ( <em>note of the translator: <code>&amp;mut</code> to indicate to the compiler that the <code>env</code> is uniquely owned, since only one variable reference to the object can exist at a time, and the data race is excluded, and <code>mut</code> because you cannot create a mutable reference to an immutable object</em> ): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env = Env { errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors }; helper(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> env);</code> </pre> <br><p>  This problem arises due to the fact that we know that local variables are unique, but we cannot put this knowledge into a borrowed link without making it mutable. </p><br><p>  This problem occurs in a number of other places.  So far we have written about this in different ways, but the feeling continues to haunt us that we are talking about a break, which simply should not be. </p><br><h3 id="proverka-tipov-primenitelno-k-zamykaniyam">  Type checking for closures </h3><br><p>  We had to bypass this restriction in the case of closures.  The closures are <em>mainly</em> absorbed into structures such as <code>Env</code> , but not quite.  This is due to the fact that I do not want to require local variables to be declared <code>mut</code> , if they are used via <code>&amp;mut</code> in the closure.  In other words, take some code, for example: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(errors: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { do_something(|| *errors += <span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br><p>  An expression describing a closure will actually create an instance of the <code>Env</code> structure: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClosureEnv</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt; { errors: &amp;uniq &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }</code> </pre> <br><p>  Pay attention to the link <code>&amp;uniq</code> .  This is not what the end user can enter.  It means "unique, but not necessarily changeable" pointer.  This is required to pass type checking.  If the user tried to write this structure manually, he would have to write <code>&amp;mut &amp;mut usize</code> , which in turn would require the <code>errors</code> parameter to be declared as <code>mut errors: &amp;mut usize</code> . </p><br><h3 id="nezapakovannye-zamykaniya-i-procedury">  Unpacked closures and procedures </h3><br><p>  I foresee that this restriction is a problem for unpacked closures.  Let me elaborate on the design that I was considering.  In principle, the idea was that the expression <code>||</code>  is equivalent to some new structural type that implements one of the types of <code>Fn</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fn</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnMut</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FnOnce</span></span></span></span>&lt;A, R&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ...); }</code> </pre> <br><p>  The exact type will be selected according to the expected type, as of today.  In this case, closure consumers can write one of two things: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: T) { ... }</code> </pre> <br><p>  We ... probably want to fix the syntax, perhaps add sugar, such as <code>FnMut(usize) -&gt; usize</code> , or save | usize |  -&gt; usize, etc.  It is not so important, it is important that we will pass the closure <em>by value</em> .  Please note that in accordance with the current DST (Dynamically-Sized Types) rules, it is permissible to pass type into a type by value as an argument, therefore the <code>FnMut&lt;usize, usize&gt;</code> argument <code>FnMut&lt;usize, usize&gt;</code> is a valid DST and is not a problem. </p><br><p>  <em>Aside</em> : this project is not complete, and I will describe all the details in a separate message. </p><br><p>  The problem is that the call to the closure will require the reference <code>&amp;mut</code> .  Since the closure is passed by value, users will again have to write <code>mut</code> where it looks out of place: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> closure: <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  This is the same problem as in the <code>Env</code> example above: what <em>actually</em> happens here is that the <code>FnMut</code> type just wants a <em>unique</em> link, but since this is not part of the type system, it requests a <em>mutable</em> link. </p><br><p>  Now we can perhaps get around this in different ways.  One option we could do is to <code>||</code>  the syntax would not be revealed to "a certain structural type," but rather to "a structural type or a pointer to a structural type, as dictated by the type inference."  In this case, the caller could write: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, closure: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">FnMut</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = closure.call(<span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><p>  I do not want to say that this is the end of the world.  But this is another step forward in the growing distortions that we need to go through in order to maintain this gap between local variables and references. </p><br><h3 id="drugie-chasti-api">  Other parts of the API </h3><br><p>  I have not done an exhaustive study, but, naturally, this distinction is creeping out somewhere else.  For example, to read from a <code>Socket</code> , I need a unique pointer, so I have to declare it mutable.  Therefore, sometimes this does not work: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> socket = Socket::new(); socket.read() <span class="hljs-comment"><span class="hljs-comment">// :   </span></span></code> </pre> <br><p>  Naturally, according to my proposal, such code would work fine.  You would still get an error message if you tried to read from <code>&amp;Socket</code> , but then it would read something like "it is impossible to create a unique link to a shared link", which I personally consider more understandable. </p><br><h2 id="no-razve-nam-ne-nuzhen-mut-dlya-bezopasnosti">  But don't we need <code>mut</code> for security? </h2><br><p>  No, not at all.  Rust programs would be equally good if you simply declared all bindings as <code>mut</code> .  The compiler is perfectly capable of tracking which local variables change at any time ‚Äî precisely because they are <em>local</em> to the current function.  What the type system really cares about is uniqueness. </p><br><p>  The value that I see in the current rules of application of <code>mut</code> , and I will not deny that it has value, is primarily that they help declare the intention.  That is, when I read the code, I know which variables can be reassigned.  On the other hand, I also spend a lot of time reading C ++ code and, frankly, never noticed that this was a major stumbling block.  (The same goes for the time I spent reading code in Java, JavaScript, Python, or Ruby.) </p><br><p>  It's also true that I sometimes find bugs because I declared the variable as <code>mut</code> and forgot to change it.  I think that we could get similar advantages with the help of other, more aggressive checks (for example, none of the variables used in the cycle condition change in the body of the cycle).  I personally can not remember to face the opposite situation: that is, if the compiler says that something must be changeable, it basically always means that I forgot the keyword <code>mut</code> somewhere.  (Consider: when was the last time you responded to a compiler error about an unacceptable change, doing something other than restructuring the code to make the change valid?) </p><br><h2 id="alternativy">  Alternatives </h2><br><p>  I see three alternatives to the current system: </p><br><ol><li>  The one that I introduced, where you just throw away "volatility" and track only the uniqueness. </li><li>  The one where you have three reference types: <code>&amp;</code> , <code>&amp;uniq</code> and <code>&amp;mut</code> .  (As I wrote, this is actually the type system we have today, at least in terms of the borrow checker.) </li><li><p>  A more rigorous version, in which "non-mut" variables are always considered to be separate.  This would mean that you have to write: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> p = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> errors; <span class="hljs-comment"><span class="hljs-comment">// ,  `p`   ,  `mut`. *p += 1;</span></span></code> </pre> <br><p>  You need to declare <code>p</code> as <code>mut</code> , because otherwise the variable will be considered to be separate, although it is a local variable and, therefore, a change of <code>*p</code> not allowed.  What is strange in this scheme is that the local variable does NOT allow separate possession, and we know for sure, because when you try to create its alias, it will move, it will launch a destructor, etc.  That is, we still have the concept of "owned", which is different from "does not allow separate ownership." </p><br><p>  On the other hand, if we described this system, saying that volatility is inherited through <code>&amp;mut</code> pointers, without even talking about shared ownership, it might make sense. </p><br></li></ol><br><p>  Of these three, I definitely prefer # 1.  It is the simplest, and now I am most interested in how we can simplify Rust, keeping its character.  Otherwise, I prefer the one we have right now. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In principle, I find that the current rules on variability have some value, but they are expensive.  They are a sort of flowing abstraction: that is, they tell a simple story that turns out to be incomplete.  This leads to confusion when people move from the initial understanding, in which <code>&amp;mut</code> displays how variability works, to a full understanding: sometimes <code>mut</code> needed only to ensure uniqueness, and sometimes it is achieved without the keyword <code>mut</code> . </p><br><p>  Moreover, we must act with caution in order to maintain a fiction, which <code>mut</code> stands for variability, not uniqueness.  We have added special cases for the borrower to check for closures.  We need to make the rules regarding <code>&amp;mut</code> volatility more complex in general.  We must either add <code>mut</code> to the closures so that they can be called, or we can make the clocks syntax re-arranged in a less obvious way.  And so on. </p><br><p>  In the end, everything turns into a more complex language as a whole.  Instead of just thinking about shared ownership and uniqueness, the user should think about shared ownership and volatility, and both of them are somehow messed up. </p><br><p>  I do not think it's worth it. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/418735/">https://habr.com/ru/post/418735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418721/index.html">Legends of virus construction: the beginning of the war</a></li>
<li><a href="../418723/index.html">AndroidX patch</a></li>
<li><a href="../418725/index.html">Magic constant</a></li>
<li><a href="../418727/index.html">Where and how to get into embeddingings of graphs</a></li>
<li><a href="../418729/index.html">All that you have asked for a long time, in one release - CLion 2018.2</a></li>
<li><a href="../418737/index.html">Laser ablation, tellurite glass and Er2O3 dopant</a></li>
<li><a href="../418739/index.html">Center for Additive Technology: Industrial 3D Printers 3D Systems, Stratasys, SLM, EOS</a></li>
<li><a href="../418743/index.html">The history of first place on the ML Boot Camp VI</a></li>
<li><a href="../418747/index.html">Problem Solving: how to effectively solve problems in a team?</a></li>
<li><a href="../418751/index.html">Dexp brazen chinese spy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>