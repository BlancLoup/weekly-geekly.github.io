<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reverse engineering of a radio-controlled tank using GNU Radio and HackRF</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A year ago, our CTF-team at a major international competition RuCTF in Yekaterinburg received a radio-controlled tank as one of the prizes. 


 Why do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reverse engineering of a radio-controlled tank using GNU Radio and HackRF</h1><div class="post__text post__text-html js-mediator-article"><p>  A year ago, our CTF-team at a major international competition RuCTF in Yekaterinburg received a radio-controlled tank as one of the prizes. </p><br><p>  Why does the hacker team have a toy radio-controlled tank?  To reverse it, of course. </p><br><p>  In the article, I will tell you how using GNU Radio and HackRF One you can figure out from scratch in a wireless tank control protocol, how to decode its packets and generate them programmatically to control a tank from a computer. </p><br><p><img src="https://habrastorage.org/files/942/40e/0cc/94240e0cc5494caf8e3ed3c33e1ea51e.jpg" alt="image"></p><a name="habracut"></a><br><h2 id="osmotr-podopytnogo">  Examination of the test subject </h2><br><p>  Given: </p><br><ul><li>  Radio-controlled tank </li><li>  Remote Control </li><li>  Computer with GNU Radio installed </li><li>  Hackrf one </li></ul><br><p>  Let's look first at the console itself. </p><br><p><img src="https://habrastorage.org/files/d12/f4b/b39/d12f4bb397a249ef9715ff35729ec02c.jpg" alt="image"></p><br><p>  The right joystick of the console is responsible for the movement of the tank: forward, backward, turn in place.  The joystick has no intermediate positions, that is, it will not work slowly.  You can only go or not go. </p><br><p>  The left joystick is responsible for turning the tower and shooting.  "Left" - "right" turns the tower itself in the appropriate direction.  "Down" allows you to aim vertically: while the joystick is in this position, the barrel cycles vertically up and down.  And to shoot, you need to hold the joystick in the "up" position for a few seconds. </p><br><p>  At the bottom of the console there is a channel switch with three positions ("A", "B" and "C"), on the bottom of the tank there is the same. </p><br><p>  On the remote there are several other buttons.  The OK button and 123456 tank does not respond.  Pressing the button (/) switches the remote control to some strange mode in which the tank stops responding.  A second click returns everything as it was.  Most likely, this console can be used for other than tank toys, and there these buttons are already somehow meaningfully involved. </p><br><p>  Well, behind the remote there is a very useful for us sticker "27.145 MHz". </p><br><h2 id="sdr">  SDR </h2><br><p>  First, we look at the radio broadcast using the gqrx program, which displays it in the form of a beautiful "waterfall" and also allows you to listen to the broadcast. </p><br><p><img src="https://habrastorage.org/files/514/6b0/54e/5146b054e3634997bbd777ff6d8c4112.png" alt="image"></p><br><p>  Immediately after switching on, the remote ‚Äúclicks‚Äù a little, and then just leaves a noticeable thin line of a constant signal.  When you press the buttons and reject the joysticks, the remote also ‚Äúclicks‚Äù.  Well, we found the remote.  But for decoding this, of course, is not enough.  Moving on to the GNU Radio Companion, where we will assemble various schemes for decoding the signal. </p><br><p>  Let's put together a simple scheme in GNU Radio, which allows you to tune in to the frequency and visualize the signal. </p><br><p><img src="https://habrastorage.org/files/f6a/902/566/f6a902566e66473eb855a228313637dd.png" alt="image"></p><br><p>  I will try, being myself not an expert in SDR, and acting mainly on a whim, to explain what is happening. </p><br><p>  First, as the source, we will use the RTL-SDR Source element, which works with both very cheap RTL-SDR and more advanced devices like HackRF One. </p><br><p>  It is important that you do not need to tune exactly at the desired frequency, but a little to the side.  This is due to the fact that most SDR for purely hardware reasons have the so-called DC bias.  After tuning to a certain frequency exactly ‚Äúin the middle‚Äù, at zero frequency, there will be a constant component, which looks like a fairly powerful constant signal.  To bypass this feature, it is enough to tune in a bit to the side, and then, if it is required, to shift the signal by software.  Then the peak of DC bias and the signal under study will be sufficiently spaced so as not to influence each other. </p><br><p>  The screenshot shows that I used a file as an alternative source.  Indeed, why go after the console every time, if you can record it once and then just play it back? </p><br><p> The next element, <em>Frequency Xlating FIR Filter</em> , is a combination unit for signal transfer in frequency, filtering and decimation.  After the transfer, the signal of interest to us is at zero frequency, filtering rejects uninteresting frequencies, where there are DC bias and other noises, and decimation lowers the sampling frequency.  It is easier and more efficient to work with a low sampling rate signal (it simply requires less CPU resources).  Now, unfortunately, I can‚Äôt remember from which random blogs and which considerations I picked up such values ‚Äã‚Äãfor the <a href="http://gnuradio.org/doc/doxygen/classgr_1_1filter_1_1firdes.html">low_pass</a> filter, but they work quite well: <code>firdes.low_pass(1.0, samp_rate, samp_rate / decimation * 0.4, 2e3)</code> . </p><br><p>  Hint: in GNU Radio, you can use <em>QT GUI Range</em> widgets as block parameter variables (just by specifying their ID instead of a constant), and then these parameters can be adjusted by the interactive widget right while the circuit is running. </p><br><p>  Well, at the end of the scheme there is a universal <em>QT GUI Sink</em> for visualizing the signal in various ways. </p><br><p>  After launching the scheme we will see the following picture on the <em>Waterfall Display</em> tab: </p><br><p><img src="https://habrastorage.org/files/0f8/3c5/38e/0f83c538e3d64074a98fdaf7014dda97.png" alt="image"></p><br><p>  Adjust the <code>freq_offset</code> so that the signal is as close to zero as possible.  The signal will still float a little in frequency, and this, apparently, can not escape.  But this will not prevent us in the future. </p><br><p>  And now open the tab <em>Time Domain Display</em> .  Having played a little with the <em>FFT Size</em> below, you can get a picture like this: </p><br><p><img src="https://habrastorage.org/files/c04/318/fda/c04318fdaba94bf698e7c0460dbb3bd3.png" alt="image"></p><br><p>  Oops!  Yes, it looks like bits! </p><br><p>  So, all we did was tune in to the frequency.  That is, we have the most ordinary amplitude modulation. </p><br><p>  The complex component is confusing, and the schedule intuitively shows that it is not needed here.  We need a number module.  Select it using the <em>Complex to Mag</em> block and see the schedule again: </p><br><p><img src="https://habrastorage.org/files/4b5/150/c52/4b5150c5215040bfb0502e5e294cb8fe.png" alt="image"></p><br><p>  Already much better.  Here you can immediately see two logical levels - "0" at around 0.4, and "1" at around 1.3.  Well, all this is diluted with a little noise, of course.  I want to note that this "0" is not "absolute", but is also transmitted by the remote control.  If the console is turned off at all, the signal will go from 0.4 to 0. </p><br><p>  Let's deal with this "frame".  The relatively long "1" and the next "0" are apparently special start bits for synchronization. </p><br><p>  The value of a bit is encoded in length "0" from one "1" to the following: short "0" is a logical zero, long "0" is a logical one.  In one frame, apparently, 16 bits. </p><br><p><img src="https://habrastorage.org/files/560/ac5/3b3/560ac53b3c4f4a76a7eb762d7e9288a5.png" alt="image"></p><br><h2 id="dekodirovanie-komand">  Command decoding </h2><br><p>  Now you can write a special block for GNU Radio in Python, which will decode the frames and write them to the console.  Sources of <em>Python Block</em> type blocks can be edited without leaving the GNU Radio Companion!  Very comfortably. </p><br><p>  I will not focus on the code, anyone can watch it under the spoiler.  And the final signal decoding scheme was as follows: </p><br><p><img src="https://habrastorage.org/files/800/093/459/8000934596804156a5478ba36213edcc.png" alt="image"></p><br><div class="spoiler">  <b class="spoiler_title">GNU Radio block for decoding packets</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gnuradio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gr <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(gr.sync_block)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, samp_rate=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""arguments to this function show up as parameters in GRC"""</span></span> gr.sync_block.__init__( self, name=<span class="hljs-string"><span class="hljs-string">'Shitty Tank Decoder'</span></span>, <span class="hljs-comment"><span class="hljs-comment"># will show up in GRC in_sig=[np.int8], out_sig=[] ) self._samp_rate = samp_rate self._sync_threshold = samp_rate / 1000 # for tracking state across buffers self._last_idx = 0 self._last_level = 0 # for state machine self._state_machine = None self._last_event = None self._last_cmd = None def start(self): self._log = sys.stderr return True def _on_edge(self, ts, is_raising): if self._state_machine is None: self._state_machine = self._state_machine_gen() self._state_machine.send(None) elif ts - self._last_event &gt; self._sync_threshold * 10: if not is_raising: # stuck on high level? weird return # reset state machine self._state_machine = self._state_machine_gen() self._state_machine.send(None) self._state_machine.send(ts) self._last_event = ts def _state_machine_gen(self): while True: raising = yield falling = yield sync_length = falling - raising if sync_length &lt; self._sync_threshold: continue #print &gt;&gt;sys.stderr, "Sync length", sync_length, "samples" if self._last_cmd is not None: pass #print &gt;&gt;sys.stderr, "Intercommand delay", raising - self._last_cmd res = [] raising = yield sync_length_low = raising - falling #print &gt;&gt;sys.stderr, "Sync low length", sync_length_low, "samples" while len(res) &lt; 16: falling = yield #print &gt;&gt;sys.stderr, "peak length", falling - raising raising = yield if raising - falling &lt; sync_length_low // 6: continue #print &gt;&gt;sys.stderr, "low length", raising - falling res.append([0, 1][int(raising - falling &gt; sync_length_low // 3)]) falling = yield cmd = "".join(str(x) for x in res) print &gt;&gt;self._log, cmd self._last_cmd = falling def work(self, input_items, output_items): data = input_items[0] if self._last_level is not None: data = np.insert(data, 0, self._last_level) else: self._last_idx = 0 edges = np.diff(data) edge_indices = np.where(edges != 0)[0] for i in edge_indices: self._on_edge(self._last_idx + i, edges[i] &gt; 0) self._last_idx += len(data) self._last_level = data[-1] return len(input_items[0])</span></span></code> </pre> </div></div><br><p>  In general, the scheme was very imperfect.  The separation of "0" and "1" at a constant threshold of 0.5 results in the circuit not working at all when the console is too far or too close.  This did not prevent further experiments, and in general I noticed this feature only six months later, when I began to write this article.  But I will be grateful if someone tells you how to do it right. </p><br><p>  Let's understand what the bits in this protocol mean.  We assume that the data is transmitted in the order of MSB, that is, from the older bits to the younger ones (this is only a matter of agreement, nothing more). </p><br><p>  First, the three low-order bits are responsible for the channel.  000 - A, 010 - B, 100 - C. It was easy to verify experimentally. </p><br><p>  A single deviation of the left joystick to the left generates the following sequence of commands (hereinafter the channel will be A): </p><br><pre> <code class="hljs cs"><span class="hljs-number"><span class="hljs-number">0000010000000000</span></span> <span class="hljs-number"><span class="hljs-number">0000010000000000</span></span> <span class="hljs-number"><span class="hljs-number">0000000011110000</span></span> <span class="hljs-meta"><span class="hljs-meta"># &lt;-   20 </span></span></code> </pre> <br><p>  Rejecting and holding the joystick, we get this: </p><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0000010000000000</span></span> <span class="hljs-number"><span class="hljs-number">0000010000000000</span></span> <span class="hljs-number"><span class="hljs-number">0001010000000000</span></span> <span class="hljs-meta"><span class="hljs-meta"># &lt;-  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">    0000000011110000 # &lt;-   20 </span></span></code> </pre> <br><p>  For all other directions, the pattern is similar: the upper three bits remain unchanged and zero, the fourth bit works like a ‚Äúrepeat flag‚Äù, the next four bits are responsible for the direction (right, left, up, down, respectively).  And at the very end, a rather strange-looking team repeats itself, in semantics, apparently meaning "stop."  The same command "stop" remote control broadcasts several times immediately after switching on. </p><br><p>  With the right joystick responsible for moving the tank, everything is somewhat more interesting.  Let me remind you that "up" - "down" is responsible for moving the tank back and forth, and "left" - "right" - for turning on the spot.  These bits go right after the predecessors, just in that position where we saw 1111 when stopped.  They change in a rather strange way.  Can you guess why? </p><br><ul><li>  0101 - forward </li><li>  1010 - back </li><li>  0110 - to the left </li><li>  1001 - right </li></ul><br><p>  As in the case of the left joystick, with the repetition, the same fourth most significant bit is set, and after releasing it there is a package with four units. </p><br><p>  The OK button sends a command with the first high bit lit (that is, 1000000000000000000), a long press generates the same commands with the repeat flag.  Tank command ignores. </p><br><p>  The (/) button switches the console to a strange mode, where all the joystick commands (except for "stop") add the high bits 2 and 3. The tank does not respond to such commands, as was said at the beginning.  Pressing the button again brings the remote back to the original mode. </p><br><p>  Button 123456 sends the command "stop" (which is from 1111 in the position of the joystick movement).  If you hold the button down, the repeat flag is set.  Why is it needed is also unclear. </p><br><p>  The assignment of the fourth least significant bit was not possible; it is always equal to zero. </p><br><p>  Two joysticks can be rejected at the same time, and packets with non-zero bits in both fields are obtained.  It is not combined with the OK button, it takes precedence over joysticks. </p><br><p>  Summarizing, the general format of packages is as follows: </p><br><pre> <code class="hljs objectivec">K<span class="hljs-meta"><span class="hljs-meta">##RTTTTMMMMxCCC R -  T -  (turret) M -  (movement) C -  (channel) K -  OK # -  ,     (/) x - </span></span></code> </pre> <br><h2 id="upravlenie-tankom-s-kompyutera">  Tank control from computer </h2><br><p>  HackRF One can not only receive a signal, but also transmit it.  So let's try to control the tank from the computer! </p><br><p>  We saw that the modulation of the signal there is very simple.  Generating such a signal using GNU Radio will be easy.  To do this, it is enough to generate the sequence "0" and "1" with the necessary delays and send them to <em>osmocom Sink</em> , which sends them straight to the air. </p><br><p><img src="https://habrastorage.org/files/6ec/e7a/7bf/6ece7a7bf98e454fad7dd23a21487e9b.png" alt="image"></p><br><p>  The block given below under the spoiler is able to transmit only movement commands, but it is easy to expand it to support the rest. </p><br><div class="spoiler">  <b class="spoiler_title">Block for coding commands</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gnuradio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gr LOW_AMPLITUDE = <span class="hljs-number"><span class="hljs-number">0.5</span></span> HIGH_AMPLITUDE = <span class="hljs-number"><span class="hljs-number">1.0</span></span> HIGH_PULSE_LENGTH = <span class="hljs-number"><span class="hljs-number">1014e-6</span></span> LOW_PULSE_LENGTH = <span class="hljs-number"><span class="hljs-number">600e-6</span></span> PEAK_LENGTH = <span class="hljs-number"><span class="hljs-number">140e-6</span></span> LOW_LENGTH_ZERO = <span class="hljs-number"><span class="hljs-number">150e-6</span></span> LOW_LENGTH_ONE = <span class="hljs-number"><span class="hljs-number">270e-6</span></span> INTERPACKET_PAUSE = <span class="hljs-number"><span class="hljs-number">52000e-6</span></span> REPEAT_BIT = <span class="hljs-number"><span class="hljs-number">0b0001000000000000</span></span> CHANNEL_BITS = { <span class="hljs-string"><span class="hljs-string">"A"</span></span>: <span class="hljs-number"><span class="hljs-number">0b000</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span>: <span class="hljs-number"><span class="hljs-number">0b010</span></span>, <span class="hljs-string"><span class="hljs-string">"C"</span></span>: <span class="hljs-number"><span class="hljs-number">0b100</span></span>, } <span class="hljs-comment"><span class="hljs-comment"># WTF: 0b0010000001010000 def xround(val): return int(val + 0.5) def encode_action(channel, forward, backward, left=False, right=False): value = 0 value |= CHANNEL_BITS[channel] print(forward, backward, left, right, file=sys.stderr) if 0: value |= 0b0000000011110000 elif forward: value |= 0b1010000001010000 elif backward: value |= 0b1010000010100000 elif right: value |= 0b0000000010010000 elif left: value |= 0b0000000001100000 else: value |= 0b0000000011110000 return value def encode_samples(value, sample_rate): for _ in xrange(xround(HIGH_PULSE_LENGTH * sample_rate)): yield 1 for _ in xrange(xround(LOW_PULSE_LENGTH * sample_rate)): yield 0 for i in range(16): for _ in xrange(xround(PEAK_LENGTH * sample_rate)): yield 1 bit = (1&lt;&lt;15) &amp; (value &lt;&lt; i) if bit: for _ in xrange(xround(LOW_LENGTH_ONE * sample_rate)): yield 0 else: for _ in xrange(xround(LOW_LENGTH_ZERO * sample_rate)): yield 0 for _ in xrange(xround(PEAK_LENGTH * sample_rate)): yield 1 class blk(gr.sync_block): def __init__(self, sample_rate=1.0, forward=False, backward=False, left=False, right=False, channel="A"): gr.sync_block.__init__( self, name='Tank Control', # will show up in GRC in_sig=[], out_sig=[np.float32] ) if not channel in ("A", "B", "C"): raise ValueError(channel) self.sample_rate = sample_rate self.forward = forward self.backward = backward self.left = left self.right = right self.channel = channel def start(self): self._generator = self._generate_samples() return True def _should_tx(self): return self.forward or self.backward or self.left or self.right def _generate_samples(self): while True: if self._should_tx(): value = encode_action(self.channel, self.forward, self.backward, self.left, self.right) # output twice without repeat bit # weird, but that's what remote does for _ in xrange(2): for bit in encode_samples(value, self.sample_rate): yield bit for _ in xrange(xround(self.sample_rate * INTERPACKET_PAUSE)): yield 0 value |= REPEAT_BIT while self._should_tx(): for bit in encode_samples(value, self.sample_rate): yield bit for _ in xrange(xround(self.sample_rate * INTERPACKET_PAUSE)): yield 0 # stop thing value = encode_action(self.channel, False, False) for _ in xrange(2): for bit in encode_samples(value, self.sample_rate): yield bit for _ in xrange(xround(self.sample_rate * INTERPACKET_PAUSE)): yield 0 yield 0 def work(self, input_items, output_items): output_items[0].fill(LOW_AMPLITUDE) output_bits = min(len(output_items[0]), int(self.sample_rate / 100)) for i in xrange(output_bits): output_items[0][i] = HIGH_AMPLITUDE if next(self._generator) else LOW_AMPLITUDE return output_bits</span></span></code> </pre> </div></div><br><p>  And this scheme really successfully controls the tank! </p><br><p>  The only problem I encountered and could not win until the end is a very significant lag.  I was able to reduce this problem by reducing the size of buffers ( <code>hackrf,buffers=2</code> in the <em>Device Arguments</em> of <em>osmocom Sink</em> ), as well as using a large sample rate.  But the unpleasant tangible lag, which is not observed when controlling from the standard console, still remains. </p><br><p>  Nevertheless, the "proof of concept" was successfully demonstrated. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  This radio-controlled tank works on a very simple protocol that is easily reversed using GNU Radio. </p><br><p>  The protocol uses amplitude manipulation with a fairly simple physical encoding, where the packet has a pronounced start mark, and the bits are encoded with a length of "0" (low level). </p><br><p>  Each packet has 16 bits of information, and the purpose of almost all of these 16 bits is easy to understand just by experimenting with the console. </p><br><p>  It was also very easy to assemble a scheme in the GNU Radio Companion that would send commands to the tank.  The only problem that could not be overcome to the end is lag. </p><br><h2 id="prilozhenie">  application </h2><br><ul><li>  <a href="">GNU Radio Companion circuit - decoder</a> </li><li>  <a href="">GNU Radio Companion Circuit - Transmitter</a> </li><li>  <a href="">Record a signal from a working console</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/325894/">https://habr.com/ru/post/325894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325882/index.html">Vulnerability of the Xen hypervisor allows access to host memory from a virtual machine</a></li>
<li><a href="../325884/index.html">7 bad tips to the REST API designer</a></li>
<li><a href="../325888/index.html">ThinkPHP # 14 Mitap in Kharkov. 5 years together</a></li>
<li><a href="../325890/index.html">Review of the section "Design" at the conference DUMP-2017</a></li>
<li><a href="../325892/index.html">Management of risks. Part 2</a></li>
<li><a href="../325896/index.html">Surf Studio: machine learning in production</a></li>
<li><a href="../325898/index.html">Excursion to the Glasgow Science Center - and about the development of the game on "Fixico"</a></li>
<li><a href="../325900/index.html">Unity3d / Android: check user on Node.JS own server</a></li>
<li><a href="../325902/index.html">Fintech: adapt or die</a></li>
<li><a href="../325904/index.html">rssh, or How to allow SCP, but disable SSH</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>