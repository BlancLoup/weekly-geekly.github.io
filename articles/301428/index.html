<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We clean the bow (but not crying): optimization techniques</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a formal response to posting on the IDZ forum . The problem that the author of the original publication described was that the perform...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We clean the bow (but not crying): optimization techniques</h1><div class="post__text post__text-html js-mediator-article">  This article is a formal response to <a href="https://software.intel.com/en-us/forums/intel-moderncode-for-parallel-architectures/topic/590710">posting on the IDZ forum</a> .  The problem that the author of the original publication described was that the performance of the code did not increase sufficiently when using OpenMP on an 8-core E5-2650 V2 processor with 16 hardware threads.  It took some time on the forum to help the publication author and provide him with the necessary hints, however, there was not enough time to optimize the code.  This article describes further optimization techniques in addition to those described on the IDZ forum. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/da7/494/ea6/da7494ea6570459a921fcb521cf6a73b.jpg"></div><a name="habracut"></a><br>  I must say that I do not know the skill level of the author of the original publication.  I will proceed from the fact that the author recently graduated from an educational institution where they could teach parallel programming with an emphasis on scaling.  In practice, more often it happens that systems have a limited amount of computing resources (threads), so you should remember not only about scaling, but also about efficiency.  The source code example published on the forum contains basic information that helps to understand how to solve the problems of efficiency (to a greater extent) and scaling (to a lesser extent). <br><br>  When preparing the code for this article, I took the liberty to rework the sample code, retaining its overall design and layout.  I saved the basic algorithm unchanged, because the sample code was taken from the application, which could have other functions in addition to the algorithm described.  In the sample code provided, a LOGICAL array (mask) was used to control the flow.  A sample of the code could have been written without logical arrays, but this code could be a fragment of a larger application, in which these arrays of masks could be necessary for some reason not so obvious in the sample code.  Therefore, I left the mask in place. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Having studied the code and the first attempt of parallelization, I determined that the most optimal place was not chosen for creating a parallel region (parallel DO).  The source code looks like this. <br><br><pre><code class="hljs vbscript">bid = <span class="hljs-number"><span class="hljs-number">1</span></span> ! { <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> stated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> original posting, but would appeared <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> bid=<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">65</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> k=<span class="hljs-number"><span class="hljs-number">1</span></span>,km<span class="hljs-number"><span class="hljs-number">-1</span></span> ! km = <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> kk=<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span> !$OMP PARALLEL <span class="hljs-keyword"><span class="hljs-keyword">PRIVATE</span></span>(I) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span>(SHARED) !$omp <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j=<span class="hljs-number"><span class="hljs-number">1</span></span>,ny_block ! ny_block = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>,nx_block ! nx_block = <span class="hljs-number"><span class="hljs-number">81</span></span> ... {code} enddo enddo !$omp <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> !$OMP <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> PARALLEL enddo enddo</code> </pre> <br>  At the first attempt of parallelization, the user applied it to the <b>do j =</b> loop.  This is the most intense level of the cycle, but to solve this problem on this platform you need to work at another level. <br><br>  In this case, 16 threads were used.  Two inner cycles together perform 8100 iterations, which gives approximately 506 iterations per stream (if we have 16 threads).  Nevertheless, the entry into the parallel region is carried out 120 times (60 * 2).  The work done in the innermost cycle did not matter much, but it required resources.  Because of this, the parallel region has covered a large part of the application.  With 16 threads and 60 iterations of the outer loop counter (120 when using loops), it is more efficient to create a parallel region in the <b>do k</b> loop. <br><br>  The code has been modified to perform a <b>do k</b> loop many times and calculate the average execution time of the entire <b>do k</b> loop.  When applying optimization techniques, you can use the difference between the average operation time of the source code and the revised code to measure the improvements achieved.  I do not have an 8-core E5-2650 v2 processor for testing, but I found a 6-core E5-2620 v2 processor.  The slightly revised code produced the following results: <br><br><pre> <code class="hljs pgsql">OriginalSerialCode Average <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-number"><span class="hljs-number">0.8267E-02</span></span> Version1_ParallelAtInnerTwoLoops Average <span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-number"><span class="hljs-number">0.1746E-02</span></span>, x <span class="hljs-type"><span class="hljs-type">Serial</span></span> <span class="hljs-number"><span class="hljs-number">4.74</span></span></code> </pre> <br>  On a 6-core E5-2620 v2 processor, the performance increase should be somewhere between six times and twelve times (if we take into account an additional 15% for hyper-threading, then the speed should increase 7 times).  Increased productivity by 4.74 times.  Significantly less than expected: we expected a sevenfold acceleration. <br>  In further sections of this article we will look at other optimization techniques. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">OriginalSerialCode</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Average</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.8395E-02</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ParallelAtInnerTwoLoops</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Average</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.1699E-02</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Serial</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.94</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ParallelAtkmLoop</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Average</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.6905E-03</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Serial</span></span> 12<span class="hljs-selector-class"><span class="hljs-selector-class">.16</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Prior</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.46</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ParallelAtkmLoopDynamic</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Average</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5509E-03</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Serial</span></span> 15<span class="hljs-selector-class"><span class="hljs-selector-class">.24</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Prior</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.25</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ParallelNestedRank1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Average</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.3630E-03</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Serial</span></span> 23<span class="hljs-selector-class"><span class="hljs-selector-class">.13</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Prior</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.52</span></span></code> </pre> <br>  Note that the <i>ParallelAtInnerTwoLoops</i> report indicates that in the second run, the multiplier was different from the multiplier of the first run.  The reason for this behavior is in the successful placement of the code (or in the wrong one).  The code itself did not change, it is completely identical in both launches.  The only difference is in adding additional code and in inserting call statements into these routines.  It is important to remember that placing tight cycles can greatly affect the performance of these cycles.  In some cases, code performance may change significantly even if a single operator is added. <br><br>  To make it easier to read code changes, the text of the three inner loops was enclosed in a subroutine.  Due to this, it becomes easier to study the code and carry out diagnostics using the VTune profiler.  An example from the <i>ParallelAtkmLoop</i> subroutine: <br><br><pre> <code class="hljs ruby">bid = <span class="hljs-number"><span class="hljs-number">1</span></span> !$OMP PARALLEL DEFAULT(SHARED) !$omp <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> k=<span class="hljs-number"><span class="hljs-number">1</span></span>,km-<span class="hljs-number"><span class="hljs-number">1</span></span> ! km = <span class="hljs-number"><span class="hljs-number">60</span></span> call ParallelAtkmLoop_sub(bid, k) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> !$omp <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> !$OMP <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> PARALLEL endtime = omp_get_wtime() ... subroutine ParallelAtkmLoop_sub(bid, k) ... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> kk=<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j=<span class="hljs-number"><span class="hljs-number">1</span></span>,ny_block ! ny_block = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>,nx_block ! nx_block = <span class="hljs-number"><span class="hljs-number">81</span></span> ... enddo enddo enddo <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine ParallelAtkmLoop_sub</code> </pre> <br>  The first stage of optimization includes two changes. <br><br><ol><li>  Moving the parallelization two cycles higher, to the level of the do k loop.  Due to this, the number of occurrences in the parallel region decreased by 120 times. </li><li>  The application used the LOGICAL array as a mask to select a code.  I redid the code used to form the values ‚Äã‚Äãto get rid of unnecessary manipulations with the mask array. </li></ol><br>  As a result of these two changes, the performance increased by 2.46 times compared with the initial attempt to parallelize.  This is a good result, but is it worth staying there? <br>  In the innermost loop, we see the following: <br><br><pre> <code class="hljs matlab"> ... {construct masks} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( LMASK1(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>) ) then ... {code} endif <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( LMASK2(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>) ) then ... {code} endif <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LMASK3(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>) ) then ... {code} endif</code> </pre> <br>  It turns out that each iteration has a different amount of work.  In this case, it is better to use dynamic planning.  The next stage of optimization is applied to <i>ParallelAtkmLoopDynamic</i> .  This is the same code as <i>ParallelAtkmLoop</i> , but with the addition of <i>schedule (dynamic)</i> to <i>! $ Omp do</i> . <br><br>  This simple change alone resulted in a speed increase of 1.25 times.  Note that dynamic scheduling is not the only possible planning method.  There are other types worth exploring.  Also remember that for this type of planning a modifier (fragment size) is often added. <br><br>  The next level of optimization, which provides an acceleration of 1.52 times, can be called aggressive optimization.  To achieve this incremental speed increase of 52%, tangible programming efforts are required (however, nothing prohibitively complex).  The possibility of this optimization is determined by analyzing the assembler code in VTune. <br><br>  It should be emphasized that there is no need to understand assembly code for its analysis.  As a rule, one can proceed from the following: <br>  the more assembler code, the lower the performance. <br><br>  You can draw a direct parallel: the harder (more complex) the assembler code, the more likely that the compiler will miss the optimization possibilities.  If you see missing opportunities, you can use a simple technique to help the compiler optimize the code. <br>  In the code of the main algorithm we see. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">subroutine ParallelAtkmLoopDynamic_sub(bid, k) use omp_lib use mod_globals implicit none !----------------------------------------------------------------------- ! ! dummy variables ! !----------------------------------------------------------------------- integer :: bid,k !----------------------------------------------------------------------- ! ! local variables ! !----------------------------------------------------------------------- real , dimension(nx_block,ny_block,<span class="hljs-number"><span class="hljs-number">2</span></span>) :: &amp; WORK1, WORK2, WORK3, WORK4 ! work arrays real , dimension(nx_block,ny_block) :: &amp; WORK2_NEXT, WORK4_NEXT ! WORK2 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> WORK4 at <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> level logical , dimension(nx_block,ny_block) :: &amp; LMASK1, LMASK2, LMASK3 ! flags integer :: kk, j, i ! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> indices !----------------------------------------------------------------------- ! ! code ! !----------------------------------------------------------------------- <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> kk=<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j=<span class="hljs-number"><span class="hljs-number">1</span></span>,ny_block <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>,nx_block <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TLT%K_LEVEL(i,j,bid) == k) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TLT%K_LEVEL(i,j,bid) &lt; KMT(i,j,bid)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> LMASK1(i,j) = TLT%ZTW(i,j,bid) == <span class="hljs-number"><span class="hljs-number">1</span></span> LMASK2(i,j) = TLT%ZTW(i,j,bid) == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(LMASK2(i,j)) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> LMASK3(i,j) = TLT%K_LEVEL(i,j,bid) + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; KMT(i,j,bid) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> LMASK3(i,j) = .<span class="hljs-literal"><span class="hljs-literal">false</span></span>. endif <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> LMASK1(i,j) = .<span class="hljs-literal"><span class="hljs-literal">false</span></span>. LMASK2(i,j) = .<span class="hljs-literal"><span class="hljs-literal">false</span></span>. LMASK3(i,j) = .<span class="hljs-literal"><span class="hljs-literal">false</span></span>. endif <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> LMASK1(i,j) = .<span class="hljs-literal"><span class="hljs-literal">false</span></span>. LMASK2(i,j) = .<span class="hljs-literal"><span class="hljs-literal">false</span></span>. LMASK3(i,j) = .<span class="hljs-literal"><span class="hljs-literal">false</span></span>. endif <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( LMASK1(i,j) ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> WORK1(i,j,kk) = KAPPA_THIC(i,j,kbt,k,bid) &amp; * SLX(i,j,kk,kbt,k,bid) * dz(k) WORK2(i,j,kk) = c2 * dzwr(k) * ( WORK1(i,j,kk) &amp; - KAPPA_THIC(i,j,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) * SLX(i,j,kk,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) &amp; * dz(k+<span class="hljs-number"><span class="hljs-number">1</span></span>) ) WORK2_NEXT(i,j) = c2 * ( &amp; KAPPA_THIC(i,j,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) * SLX(i,j,kk,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) - &amp; KAPPA_THIC(i,j,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) * SLX(i,j,kk,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) ) WORK3(i,j,kk) = KAPPA_THIC(i,j,kbt,k,bid) &amp; * SLY(i,j,kk,kbt,k,bid) * dz(k) WORK4(i,j,kk) = c2 * dzwr(k) * ( WORK3(i,j,kk) &amp; - KAPPA_THIC(i,j,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) * SLY(i,j,kk,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) &amp; * dz(k+<span class="hljs-number"><span class="hljs-number">1</span></span>) ) WORK4_NEXT(i,j) = c2 * ( &amp; KAPPA_THIC(i,j,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) * SLY(i,j,kk,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) - &amp; KAPPA_THIC(i,j,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) * SLY(i,j,kk,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( WORK2_NEXT(i,j) ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( WORK2(i,j,kk) ) ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> WORK2(i,j,kk) = WORK2_NEXT(i,j) endif <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( WORK4_NEXT(i,j) ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( WORK4(i,j,kk ) ) ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> WORK4(i,j,kk) = WORK4_NEXT(i,j) endif endif <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( LMASK2(i,j) ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> WORK1(i,j,kk) = KAPPA_THIC(i,j,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) &amp; * SLX(i,j,kk,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) WORK2(i,j,kk) = c2 * ( WORK1(i,j,kk) &amp; - ( KAPPA_THIC(i,j,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) &amp; * SLX(i,j,kk,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) ) ) WORK1(i,j,kk) = WORK1(i,j,kk) * dz(k+<span class="hljs-number"><span class="hljs-number">1</span></span>) WORK3(i,j,kk) = KAPPA_THIC(i,j,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) &amp; * SLY(i,j,kk,ktp,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) WORK4(i,j,kk) = c2 * ( WORK3(i,j,kk) &amp; - ( KAPPA_THIC(i,j,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) &amp; * SLY(i,j,kk,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) ) ) WORK3(i,j,kk) = WORK3(i,j,kk) * dz(k+<span class="hljs-number"><span class="hljs-number">1</span></span>) endif <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LMASK3(i,j) ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k.lt.km<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ! added <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> avoid out of bounds access WORK2_NEXT(i,j) = c2 * dzwr(k+<span class="hljs-number"><span class="hljs-number">1</span></span>) * ( &amp; KAPPA_THIC(i,j,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) * SLX(i,j,kk,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) * dz(k+<span class="hljs-number"><span class="hljs-number">1</span></span>) - &amp; KAPPA_THIC(i,j,ktp,k+<span class="hljs-number"><span class="hljs-number">2</span></span>,bid) * SLX(i,j,kk,ktp,k+<span class="hljs-number"><span class="hljs-number">2</span></span>,bid) * dz(k+<span class="hljs-number"><span class="hljs-number">2</span></span>)) WORK4_NEXT(i,j) = c2 * dzwr(k+<span class="hljs-number"><span class="hljs-number">1</span></span>) * ( &amp; KAPPA_THIC(i,j,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) * SLY(i,j,kk,kbt,k+<span class="hljs-number"><span class="hljs-number">1</span></span>,bid) * dz(k+<span class="hljs-number"><span class="hljs-number">1</span></span>) - &amp; KAPPA_THIC(i,j,ktp,k+<span class="hljs-number"><span class="hljs-number">2</span></span>,bid) * SLY(i,j,kk,ktp,k+<span class="hljs-number"><span class="hljs-number">2</span></span>,bid) * dz(k+<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( WORK2_NEXT(i,j) ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( WORK2(i,j,kk) ) ) &amp; WORK2(i,j,kk) = WORK2_NEXT(i,j) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(WORK4_NEXT(i,j)) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(WORK4(i,j,kk)) ) &amp; WORK4(i,j,kk) = WORK4_NEXT(i,j) endif enddo enddo enddo <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine Version2_ParallelAtkmLoop_sub</code> </pre> </div></div><br>  Let's start Intel Amplifier (VTune) and as an example we will consider line 540. <br><br><img src="https://habrastorage.org/files/fee/d8d/886/feed8d886c714db592797c40c40dfaf5.jpg"><br><br>  This is part of the instruction that multiplies two numbers.  For this partial information you can expect: <br><br><ul><li>  load value for any SLX index; </li><li>  multiplication by the value of any index dz. </li></ul><br>  If you click the Assembly button in the Amplifier. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3b4/0a8/d49/3b40a8d4967f4476a4073640b2c7fa17.jpg"></div><br>  Then we sort by line number of the code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1fe/754/905/1fe754905d8142dc82a130b7ecc99d23.jpg"></div><br>  In line of code 540 we see the following. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e5b/cf7/fa5/e5bcf7fa54d44994a3c580ea7d4902a7.jpg"></div><br>  A total of 46 assembly instructions are used to multiply two numbers. <br><br>  We now turn to mutual influence. <br><br>  These two numbers are cells of two arrays.  The SLX array has six subscriptions, the other array has one.  The last two assembler instructions: <i>vmovss</i> from memory and <i>vmulss</i> from memory.  We hoped to get a fully optimized code that met our expectations.  In the above code, 44 out of 46 assembler functions are associated with the calculation of array indices for these two variables.  Naturally, several instructions may be required to obtain indices in arrays, but 44 is clearly too many.  Is it possible to reduce the complexity in any way? <br><br>  When viewing the source code (the latest version shown above), you can see that the last two subordinate SLX scripts and one subordinate <i>dz</i> script are invariant for the two most internal loops.  In the case of SLX, the left of two indices (two variables controlling the most internal loops) is a continuous array fragment.  The compiler did not recognize the constant (right) array indices as candidates for an invariant loop code that can be inferred from the loop.  In addition, the compiler could not recognize the two indices, located to the left of all, to collapse into one index. <br><br>  This is a good example of possible optimization that can be implemented by the compiler.  In this case, the following optimization procedure, in which invariant subordinate scenarios are derived from the cycle, provides an increase in productivity by 1.52 times. <br>  We now know that much of the do code includes contiguous array fragments with several subordinate scripts.  Is it possible to reduce the number of subordinate scenarios without rewriting the entire application? <br><br>  Answer: yes, it is possible if you encapsulate smaller sections of arrays represented by a smaller number of subordinate scripts.  How to do this in our code example? <br><br>  I decided to apply this approach to two levels of nesting. <br><br><ol><li>  At the outermost level of <i>bid</i> (module data indicates that 65 <i>bid</i> values ‚Äã‚Äãare used in the actual code). </li><li>  At the next level - at the level of the <b>do k</b> cycle.  In addition, we combine the first two indices into one. </li></ol><br>  The outermost layer transmits fragments of the <i>bid</i> level array. <br><br><pre> <code class="hljs sql">bid = 1 ! in real application bid may iterate ! peel off the bid <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> ParallelNestedRank1_bid( &amp; TLT%K_LEVEL(:,:,bid), &amp; KMT(:,:,bid), &amp; TLT%ZTW(:,:,bid), &amp; KAPPA_THIC(:,:,:,:,bid), &amp; SLX(:,:,:,:,:,bid), &amp; SLY(:,:,:,:,:,bid)) ‚Ä¶ subroutine ParallelNestedRank1_bid(K_LEVEL_bid, KMT_bid, ZTW_bid, KAPPA_THIC_bid, SLX_bid, SLY_bid) <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> omp_lib <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> mod_globals implicit <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">dimension</span></span>(nx_block , ny_block) :: K_LEVEL_bid, KMT_bid, ZTW_bid <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">dimension</span></span>(nx_block,ny_block,<span class="hljs-number"><span class="hljs-number">2</span></span>,km) :: KAPPA_THIC_bid <span class="hljs-built_in"><span class="hljs-built_in">real</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">dimension</span></span>(nx_block,ny_block,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,km) :: SLX_bid, SLY_bid ‚Ä¶</code> </pre> <br>  Note that for arrays without pointers (distributed or with fixed sizes) arrays are continuous.  This makes it possible to ‚Äúcut off‚Äù the rightmost indices for transmitting a fragment of a continuous array, for which you simply need to calculate the offset in a subset of a larger array.  At the same time, in order to try to ‚Äúcut off‚Äù any other indices, except the rightmost ones, you need to create a temporary array, which should be avoided.  However, in some cases, even this may be appropriate. <br><br>  At the second nested level, we have expanded the additional index of the array of the <b>do k</b> loop, and also compressed the first two indices into one. <br><br><pre> <code class="hljs ruby">!$OMP PARALLEL DEFAULT(SHARED) !$omp <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> k=<span class="hljs-number"><span class="hljs-number">1</span></span>,km-<span class="hljs-number"><span class="hljs-number">1</span></span> call ParallelNestedRank1_bid_k( &amp; K_LEVEL_bid, KMT_bid, ZTW_bid, &amp; KAPPA_THIC_bid(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,k), &amp; KAPPA_THIC_bid(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,k+<span class="hljs-number"><span class="hljs-number">1</span></span>), KAPPA_THIC_bid(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,k+<span class="hljs-number"><span class="hljs-number">2</span></span>),&amp; SLX_bid(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,k), SLY_bid(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,k), &amp; SLX_bid(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,k+<span class="hljs-number"><span class="hljs-number">1</span></span>), SLY_bid(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,k+<span class="hljs-number"><span class="hljs-number">1</span></span>), &amp; SLX_bid(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,k+<span class="hljs-number"><span class="hljs-number">2</span></span>), SLY_bid(<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>,k+<span class="hljs-number"><span class="hljs-number">2</span></span>), &amp; dz(k),dz(k+<span class="hljs-number"><span class="hljs-number">1</span></span>),dz(k+<span class="hljs-number"><span class="hljs-number">2</span></span>),dzwr(k),dzwr(k+<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> !$omp <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> !$OMP <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> PARALLEL <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> subroutine ParallelNestedRank1_bid subroutine ParallelNestedRank11_bid_k( &amp; k, K_LEVEL_bid, KMT_bid, ZTW_bid, &amp; KAPPA_THIC_bid_k, KAPPA_THIC_bid_kp1, KAPPA_THIC_bid_kp2, &amp; SLX_bid_k, SLY_bid_k, &amp; SLX_bid_kp1, SLY_bid_kp1, &amp; SLX_bid_kp2, SLY_bid_kp2, &amp; dz_k,dz_kp1,dz_kp2,dzwr_k,dzwr_kp1) use mod_globals implicit none !----------------------------------------------------------------------- ! ! dummy variables ! !----------------------------------------------------------------------- integer <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: k integer, dimension(nx_block*ny_block) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: K_LEVEL_bid, KMT_bid, ZTW_bid real, dimension(nx_block*ny_block,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: KAPPA_THIC_bid_k, KAPPA_THIC_bid_kp1 real, dimension(nx_block*ny_block,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: KAPPA_THIC_bid_kp2 real, dimension(nx_block*ny_block,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: SLX_bid_k, SLY_bid_k real, dimension(nx_block*ny_block,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: SLX_bid_kp1, SLY_bid_kp1 real, dimension(nx_block*ny_block,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: SLX_bid_kp2, SLY_bid_kp2 real <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: dz_k,dz_kp1,dz_kp2,dzwr_k,dzwr_kp1 ... ! <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> note index (i,j) compression to (ij) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> kk=<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ij=<span class="hljs-number"><span class="hljs-number">1</span></span>,ny_block*nx_block <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( LMASK1(ij) ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span></code> </pre> <br>  Notice that a fragment of a continuous array is transmitted at the call point (link).  Empty arguments to the procedure being called indicate a continuous chunk of memory of the same size with a different set of indices.  If you are careful when working in FORTRAN, it is quite feasible. <br><br>  All actions to create code are reduced to copy and paste operations, and then to search and replace.  Except for this, the code flow does not change.  This could be done by an attentive novice programmer who has the necessary instructions. <br><br>  In future versions of the compiler, built-in optimization tools may make all these actions unnecessary, but now ‚Äúunnecessary‚Äù programming can in some cases lead to a significant increase in performance (in this case by 52%). <br><br>  Equivalent instruction is now such. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5d7/b72/c14/5d7b72c1401249b0a62cb056df723ff2.jpg"></div><br>  The assembler code now looks like this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4fc/f25/2cb/4fcf252cb70946ca9c2c0085966cf840.jpg"></div><br>  Instead of 46 instructions, 6 is left, that is, 7.66 times less.  Thus, reducing the number of subordinate scripts in the array allows you to reduce the number of instructions. <br><br>  The introduction of a two-level investment with "cutting" led to an increase in productivity by 1.52 times.  Is 52% more productivity worth the extra effort?  Decide for yourself, everything is subjective here.  It can be assumed that optimization algorithms incorporated in future versions of compilers will themselves extract subordinate scripts of invariant arrays, which was done manually above.  But for now you can use the described method of "cutting" and compressing indexes. <br>  I hope my recommendations will be helpful. <br><br>  ¬ª <a href="">Sample source code</a> </div><p>Source: <a href="https://habr.com/ru/post/301428/">https://habr.com/ru/post/301428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301418/index.html">Creating a VoIP Provider Template in 3CX Phone System</a></li>
<li><a href="../301420/index.html">Office 365 updates</a></li>
<li><a href="../301422/index.html">IPSec VPN for OS X and iOS. Without pain</a></li>
<li><a href="../301424/index.html">SpamFireWall - prohibit access to the site for spam bots</a></li>
<li><a href="../301426/index.html">Web scraping with Node.js</a></li>
<li><a href="../301432/index.html">Warren Buffett and Dan Gilbert fight for Yahoo assets</a></li>
<li><a href="../301434/index.html">June 4, 2016 is a cloudy day 2.0. Artificial intelligence in the cloud</a></li>
<li><a href="../301436/index.html">How we parse income declarations using open data</a></li>
<li><a href="../301440/index.html">C ++ User Group, meeting in Kazan May 28, 2016</a></li>
<li><a href="../301442/index.html">Running NodeJS-application on Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>