<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The basics of indexing and EXPLAIN in MySQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The topic of the report by Vasily Lukyanchikov is indexing in MySQL and the advanced features of EXPLAIN, i.e. our task will be to answer the question...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The basics of indexing and EXPLAIN in MySQL</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/18e/c80/ee018ec80cc3f9037c94549096d8500f.jpg"><br><br><p>  The topic of the report by Vasily Lukyanchikov is indexing in MySQL and the advanced features of EXPLAIN, i.e.  our task will be to answer the questions: what can we figure out with the help of EXPLAIN, what should we pay attention to? </p><br><p>  Many of the constraints of EXPLAIN are associated with the optimizer, so we first look at the architecture to understand where the constraints follow from and what, in principle, can be done with the help of EXPLAIN. </p><br><p>  We will go through the indexes very briefly, solely in terms of what the nuances are in MySQL, in contrast to the general theory. </p><br><p>  The report, therefore, consists of 3 parts: </p><br><ul><li>  Architecture; </li><li>  Basics of indexing; </li><li>  EXPLAIN (examples). </li></ul><br><a name="habracut"></a><br><h3>  Vasily Lukyanchikov (Stanigost) </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/51c/b75/054/51cb75054a4643766e403294e7125796.jpg"><br><br><h3>  MySQL architecture </h3><br><p>  Schematically, the server can be represented as follows: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ee0/18e/c80/ee018ec80cc3f9037c94549096d8500f.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  The first block is the clients that access the server through the functions of the corresponding connector or C API via TCP / IP or UNIX Socket, as a rule.  They get to the control unit connections, where, in fact, there is an authorization of the client at this moment, and the launch of the process of authorization and execution.  Each client works in its own independent stream.  Extra threads can be cached by the server and then used. </p><br><p>  About the query cache, it should be noted that it is represented by one common thread for all clients and in some cases may be a bottleneck if we have a multi-core architecture and very simple database requests.  The base quickly executes them, the time to access the cache can become a bottleneck, since this is the only thread, and everyone is queuing up to it. </p><br><p>  With connection management, the request goes to the main pipeline, which consists of three parts - the parser, the optimizer and the performer.  Actually, this part turns the resulting SQL query into a data sample.  This part communicates with the repository interface, each according to its tasks: </p><br><ul><li>  the parser checks the syntax of the query, requests the storages for the presence of table and field data, access rights directly to these fields and checks for the response in the query cache, and then passes the parsed query to the optimizer; </li><li>  the optimizer queries the repository interface with index statistics, on the basis of which it builds a query plan that passes to the executor; </li><li>  the executor calls the received plan directly for the data in the repository, sends the response to the client via the interface and, if necessary, changes the update cache (either the result itself or resets it if there was a request for updates). </li></ul><br><p>  Here it is necessary to note the key feature related to MySQL, is the interface of the connected storages, i.e.  You can develop your own storage (standard interface) in your company and connect it.  Thus, you can make the data stored in the most convenient way for you, taking into account the various nuances. </p><br><p>  The reverse feature is that the optimizer is very weakly connected to the repositories, it does not know and does not take into account the individual nuances of the execution of the part of the request by this or that repository.  And, strangely, this also happens badly for the main repositories that MySQL developers are developing directly, and this situation has only improved in recent versions.  This point must be considered. </p><br><p>  Another point worth noting is that the indexes in MySQL are implemented exactly at the storage level, they are not standardized.  Therefore, you need to keep track of what type of index - full-text, B-Tree, spatial, etc. - is used by one or another repository.  And most importantly: the same index in different repositories - it can be a completely different structure.  For example, the B-Tree index in MyISAM stores a pointer to the data itself, and in InnoDB it stores a pointer to the primary key;  in MyISAM, compression of prefix indexes occurs, but in InnoDB this does not happen, but there is caching of both data and indexes. </p><br><p>  There are many nuances that need to be taken into account when working, i.e.  some requests will be faster executed in one storage, some in another, since  they store statistics differently.  For example, a count (*) query in the case of MyISAM can be executed very quickly without referring to the data itself, since  there is stored exactly the statistics in the metadata, it is, however, for special cases, but, nevertheless, there are such nuances. </p><br><p>  Immediately let's say about the query plan.  It is done by the optimizer, and this is not some executable code, but a set of instructions that it passes to the performer.  This is some assumption about how the request will be executed.  After the executor makes a request, some differences may appear and, unlike PostgreSQL, MySQL does not show what has been done, that is, when we look at EXPLAIN in MySQL, we do not have ANALYZE.  More precisely, it appeared quite recently in Maria version 10.1, which is still beta, and, naturally, is not yet used.  Therefore, we must bear in mind that when we look at EXPLAIN in MySQL, these are some assumptions. </p><br><p>  Often there is a situation that we have the same plan, but different performance.  Here it should be noted that the optimizer itself in terms of EXPLAIN gives very few things.  For example, we have select (*) requests from a table and select pairs of fields from a table will have the same plan, but in one case we will have several Kb selected for each record, and in the other - there may be several MB if we have huge records .  Naturally, the performance of these requests will vary by orders of magnitude, but the plan will not show it.  Or, we may have the same plan, one request, but it will be different on different machines, because in one case the index is read from memory, in the other, if the buffer is small, the index is taken from the disk.  Again, with the same plan, performance will vary.  Therefore, in addition to EXPLAIN, you need to look at different things, first of all, at the server parameters (show status). </p><br><p>  Here it is appropriate to refer to the last RIT ++ conference, where Grigory Rubtsov‚Äôs report was on the MySQL botanical determinant - for those who cannot hypnotize the server and immediately identify the bottleneck, there is a whole consistent scheme: look at this and that parameter - go there.  As in the classical botanical determinant, when we were searching for a definition of plants, we looked at the number of leaves, the shape, etc.  and so came to the answer.  There is such a structure - where to look consistently what to do to find bottlenecks. </p><br><br><h3>  Go to the indexes in MySQL </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d93/ac1/ffc/d93ac1ffcad237c54243efb65bbfd074.jpg"><br><br><p>  We will not consider and list all types of indexes - they are more or less standard for each database.  Speaking of MySQL, we need to note the following: MySQL does not manage duplicate indexes, i.e.  if we create a table as presented, it does not mean that we will have a primary index created unique to column 1. This means that we will have three identical indexes created for one column.  All three of them will occupy space, will be updated, will be taken into account by the optimizer, and MySQL will not issue any warning itself, i.e.  You need to watch it yourself. </p><br><p>  Speaking about indexes (basically we will talk about b-tree, as the most used), in order not to go into details and not to draw a tree, the index is very convenient to represent in the form of an alphabetical index.  For example, an address book is a table, an alphabetical index to it is the index.  Applying this analogy, we can imagine how the work with the index occurs, whereby data is selected there more quickly, etc. But there is some difference in MySQL itself, since MySQL always follows the index, it uses the index only from left to right sequentially, without tricks This may cause questions. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/f82/18c/00ff8218c62bd70fb2b21eff8cdd9068.jpg"><br><br><p>  For example, if we need to find some names in the alphabetical index.  "Hands" we will look for as follows: look at the first name, find the right names, scroll through to the next name.  This is not a limitation of the b-tree tree, it is a limitation of the implementation of the b-tree tree directly in MySQL.  Other databases are able to do this ‚Äî using not the first column, for example, in the case of WHERE B = 3, the index in MySQL will not be used at all.  Only in the special case if we ask for the minimum and maximum from this column, but this is rather the exception. </p><br><p>  The slide above presents various options, and it is worth noting that the index breaks off at the first inequality, i.e.  it is used sequentially from left to right until the first inequality.  After the inequality, the further part of the index is no longer used.  Those.  in condition A - constant, B - range, the first two parts will be used.  In the second case, the entire index will be used.  In the third case, the index will also be used entirely, since  the order of the constants in the condition does not matter, and the server can rearrange them.  In the case of B = 3 index, in general, will not be used.  In the case of a constant and inequality, the index will be used only for the first two parts, for the third part the index can no longer be used.  In case A, the constant and the sorting by the last, the index will be used only for the first part, because the second part is skipped, the penultimate index will be used entirely.  And in the last version, again, the index will be used only on the first part, because the index can be used for sorting only when it is going in one direction. </p><br><p>  This is due to the fact that the composite index in MySQL is, in fact, the usual b-tree index over the concatenation of incoming columns, respectively, it can move either upward or downward in the entire tuple.  Therefore, we will not be able to say: ‚Äúwe are moving in the ascending order of B and decreasing in C‚Äù according to the index.  This limitation is specific to MySQL. </p><br><p>  There is such a nuance.  For example, A in (0,1) and A between 0 and 1 are equivalent forms, this is a range both there and there, but in the case when it is A in (0,1) is a list, he understands that this is not range, and replaces with the plural equality condition.  In this case, it will use the index.  This is another aspect of MySQL, i.e.  You need to look at how to write - either as a list, or to put &lt;&gt;.  He distinguishes it. </p><br><p> A few words about redundant syntax.  If we have index (A) and index (A, B), then index (A) would be superfluous, because in the case of index (A, B), part A can be used in it.  Therefore, we need to ensure that there are no redundant indexes and delete them ourselves.  Clearly, this also applies to the case when both indices are b-tree, but if, for example, index (A) is full-text, then, naturally, it may be necessary. </p><br><p>  Let's return to the nuance on the list.  We can make a wider index unique here.  For example, if we make index (A, B), then we simply will not use condition B, but we can make it so that it automatically substitutes the missing condition in the application if there is a small possible variant of the list.  But with this recommendation you need to be very careful, because, despite the presence of a list, the further use of the index is not discarded, it cannot be used for sorting, i.e.  only on equality.  Therefore, if we have sorting requests, then we will have to rebuild the request through union all so that there are no lists in order to use sorting.  Naturally, this is not always possible and is not always convenient.  If an extension of the index allows us, for example, to make an index covering (meaning that all the fields that are selected and used in the query are present in the index), then the server understands that it‚Äôs not necessary to go to the table for the data and it completely appeals to the index to form the result.  Since  The index is more ordered, compact, and most often stored in cached memory, which is more convenient.  Therefore, when compiling an index, we always look to see if we can somehow find a covering index for our query. </p><br><p>  Next, consider the cases when the indexes are not used. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/9c7/789/a25/9c7789a2595a5417876bcd7789bafc8b.jpg"><br><br><p>  There are common nuances with other databases, for example, when the index is part of an expression, as in PostgreSQL, it cannot convert it, so if we have id + 1 = 3 in the query, the id index will not be used.  We must bear it ourselves.  If the index is part of an expression, we must see if we can transform it so that the index can be moved to the left side explicitly. </p><br><p>  Similarly, due to the fact that it does not produce conversions (these are not only mathematical, there may be a mismatch of encodings, a type conversion), the index will not be used either.  The index is not used when the first part is skipped when searching by the suffix.  Well, of course, the index will not be used when comparing with the fields of a similar table, because in this case, it will first need to read the record from the table to compare. </p><br><p>  Before that, I mentioned covering indexes, and why they are good.  Let's return to the slide with architecture: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/a6d/43b/b6d/a6d43bb6d8badfe37c2266823e74c5f4.jpg"><br><br><p>  It happens like this: the executor requests data (WHERE condition) from the storage, respectively, if we have a WHERE condition for several positions, then they can all be processed inside the storage itself.  This is the best option.  There may be an option when part of the conditions will be processed at the storage level by the index, the lines transferred to the level up, the server will apply, and further conditions will be discarded.  Clearly, it will be slower, because  There will be a transfer of the records themselves from the repository to the performer.  Therefore, the covering indices, if they are used here only for those fields that are more profitable in the request, because  we already have fewer rows. </p><br><p>  Here, for example, is a similar optimization called index condition pushdown: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e53/178/7f3/e531787f3859f572500dacd17a93e21c.jpg"><br><br><p>  This refers to the following.  We have an index for three fields - A, B, C. In such conditions, we can use only part of the first.  It would seem that we can check the indexes in the repository itself, but earlier (up to MySQL 5.6, MariaDB 5.3), the server did not do this, so you need to carefully look at specific releases - what the server can do.  In new versions, the server searches the first part of the index, only column A, selects the data and, before transferring the records to the performer, it checks the condition for the second and third parts and looks at whether it is necessary to select the whole records or not.  This naturally reduces the number of records that need to be read from the disk. </p><br><p>  The key feature in InnoDB is that the secondary keys refer to the primary key, so in fact the secondary key in InnoDB is the secondary key + pointer to the primary key. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e92/4d5/268/e924d526846f614e944e3aab4264fd44.jpg"><br><br><p>  Such a long index has an invisible "tail."  Invisible in the sense that earlier the optimizer did not take it into account in its actions. </p><br><p>  Here, we have a primary (A, B) composite, respectively, secondary key - this will be a composite key on (C, A, B) and we can already search for it. </p><br><p>  Thus, when you work with InnoDB tables and make indexes, you should always take into account that a long primary key can be either good or bad, depending on what queries you have, because it will be added to all indexes. </p><br><p>  Here is the next nuance - this optimization will be considered only for filtering rows.  In our case, only the values ‚Äã‚Äãof the secondary key are stored in a sorted form, and the pointers to the primary key are not sorted; therefore, the server can use such a long invisible tail only for equality conditions of string filtering.  It is available in MariaDB 5.5, MySQL 5.6. </p><br><p>  The key constraints of the optimizer are that it historically uses very few statistics.  It requests data from repositories.  Here is more detailed what the server takes into account: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e92/4d5/268/e924d526846f614e944e3aab4264fd44.jpg"><br><br><p>  It can take into account the results of input commands, fields, the number of lines, i.e.  pretty little data.  The peculiarity is that initially the statistics are calculated as follows: we start the server or do some kind of command like ALTER, we have the statistics updated, then the table lives for a while, some process suddenly changes, then the statistics are updated again.  Those.  it happens that the statistics itself does not correspond to the distribution of data. </p><br><p>  Again, each repository selects statistics in its own way ‚Äî somewhere more, somewhere less.  The latest versions implement the idea of ‚Äã‚Äãindependent statistics, i.e.  server-level statistics ‚Äî service tables are allocated, in which in a uniform way, statistics for all tables are collected independently of storage mechanisms, moreover, if in Percona 5.6.  this is done only for indexes in InnoDB, then Maria 10 went further and collected it even for non-indexed columns, due to which the optimizer can choose more optimal execution plans, since he understands data distribution better. </p><br><p>  The optimizer does not take into account the storage specifics - when we send a request to the storage, it is clear that the search for the secondary key in InnoDB will take longer because we go through the secondary key, get the primary key pointers, take these pointers, follow the data, those.  we will have a double pass, and in MyISAM, for example, there will be immediately pointers directly to the lines themselves.  The optimizer does not take into account the similar nuances of the relative speed of certain parts (our request can simultaneously refer to different repositories).  It also does not take into account a lot of issues related to equipment, i.e.  what data we have cached, what kind of buffers ... </p><br><p>  Metrics.  It is clear that the optimizer chooses the cheapest plan, but the cheapest plan from the point of view of the optimizer is the plan with the lowest cost, and the question of cost is a certain convention that may not coincide with our ideas about it.  Again, the difficulty of choosing is when there are a lot of tables and you need to move and look at them in different ways. </p><br><p>  He also uses the rules, i.e.  if he, for example, understands that you need to use a full text index, then he uses it, even though we may have a condition on the primary key, which will uniquely produce one column. </p><br><p>  There is still such a nuance - from our point of view, these two entries are equivalent: </p><br><p>  where a between 1 and 4 </p><br><p>  where a&gt; 0 and a &lt;5 </p><br><p>  but from the point of view of the MySQL server, no.  In the case when a&gt; 0 and a &lt;0, he will use the search by range, and in the case when we write the same through ‚Äúbetween‚Äù, he can convert it into a list and use the condition on multiple equalities. </p><br><p>  Such nuances do not allow writing queries based on common sense, but on the other hand it is convenient in that it increases the demand for specially trained people to optimize MySQL.  :) </p><br><br><h3>  Briefly about how the optimizer works </h3><br><p>  It checks the request for triviality, i.e.  can he, in general, make a query, relying only on the statistics of the indices.  Maybe we are asking for negative values ‚Äã‚Äãfor the ID column, which is positively defined.  Then he immediately understands that we are requesting out of range.  This is a very effective option in terms of speed - choose the cheapest plan. </p><br><p>  It would seem that the optimizer can do very few things, but in fact it applies various techniques to the mathematical transformation of the query, for example, the subqueries can either degrade, as in the old versions, by making it independent dependent, or it can be improved, as in the new ones.  The list of techniques is very long. </p><br><p>  This is the beginning of the table from the MariaDB documentation: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/131/7f2/0a6/1317f20a6e468031400a0736418a171f.jpg"><br><br><p>  You need to know what lies behind all these words, so I recommend watching the documentation on MariaDB, because  it is equipped with clear pictures, illustrations, and from them one can understand what is related to what. </p><br><p>  How we can influence the optimizer: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d30/839/7b7/d308397b722ad9ee1bd6615ddcf641f6.jpg"><br><br><ul><li>  To rewrite a query is to either use an equivalent form of record, that is, for example, replace the subquery with a join, or rewrite the query dramatically, breaking up into parts, writing some data into temporary intermediate tables, or, in general, denormalize the table and get rid of join'ov. </li><li>  Indices - we can either add the necessary indices, or look, maybe it‚Äôs enough for us to update the statistics. </li><li>  Hints to the optimizer - use / force / ignore index - we can explicitly indicate to it which indexes should be used for which operations - for sorting, grouping, etc. </li><li>  straight_join - we can set the hard order of table joins so that it does not go through various options.  We know the features of the distribution of data and know the order in which we need to work, so we clearly indicate this. </li><li>  @@ optimizer_switch - enable / disable all specific additional optimization techniques through this variable. </li><li>  The variables optimizer_prune_level and optimizer_search_depth determine how the server selects the optimal plan ‚Äî iterates over all possible options or discards.  It is clear that when we have a lot of joinl tables, and the server will analyze several million permutations, it can take a quarter of an hour to think, and then execute in a split second.  Such situations occur, so all these variables by default limit the execution time, which leads to the fact that the plan can be chosen non-optimal.  When we perform optimization, in testing mode we can change these variables so that the server selects all the options and see if a more optimal plan can be chosen. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/af1/c6b/e21/af1c6be21cac1dea28adc2e405823ae0.jpg"><br><br><p>  SQL_CALC_FOUND_ROWS is a scary word that completely kills optimization.  In practice, the idea is that if we have a LIMIT request, we can include a keyword in the request, and the server will give us in the response, including the total number that would be chosen without a limit.  This is convenient, for example, when we paginate pages, and this is the fault of all automatic systems.  This is bad, because COUNT MySQL can optimize queries very well, but in difficult cases, when we have joines, groupings, etc., count the number of rows separately, we can rewrite the query so that part of the join, joines we do not need, part of the groupings, too, to get an answer on the total number of pages </p><br><p>  The server uses only one method per request.  When we add FOUND_ROWS, it solves two problems with one method, i.e.  he actually selects all rows, as if there was no LIMIT, pulls data out of storage ‚Äî all long records, he thinks, discards unnecessary ... This is very bad.  Here you need to understand that the same COUNT (*) does not read the lines themselves, it simply looks at them for the presence, without transferring data to the reader. </p><br><p>  At this level, you need to know the details to understand, otherwise just looking at EXPLAIN will not be very meaningful. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/274/b3d/f6e/274b3df6ee89335312d16a9ace25458b.jpg"><br><br><p>  The disadvantages of EXPLAIN follow from the disadvantages of the optimizer.  There are cases when he, in general, writes not what he does, gives very little information, when we say that EXPLAIN does not fulfill the request, but simply makes a plan.  In older versions, it ran from subqueries, since  from subqueries he materialized into a temporary subtable and if they are heavy, then the execution of these subqueries took a lot of time.  And there was even a conflict with the fact that from the subquery may contain a user-defined function that will change the data, then EXPLAIN itself would also change the data.  It is not clear why this is necessary, but in practice people sometimes invent very strange things. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e34/b10/4a7/e34b104a70d859e284e3f6692deaf72d.jpg"><br><br><h3>  EXPLAIN Types </h3><br><p>  If you use the PARTITIONS keyword, then it will show which sections our query uses. </p><br><p>  The EXTENDED keyword is convenient in that it forms a SQL query that recovers from the execution plan.  This is not the original SQL query, the original SQL query is converted into a plan, and then a new SQL query is synthesized from the plan already by the optimizer, which contains a number of hints on which we can understand what is happening.  Creating a temporary table with keys, caching some pieces of the query - all these nuances are well described in the documentation and they help to understand what the server is doing, how our query transforms. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/e65/08c/614/e6508c61477a244beee927e4cc39b4ca.jpg"><br><br><p>  This is, in fact, EXPLAIN the simplest query. </p><br><p>  Here you need to look at the following: </p><br><ul><li>  type of access that is used.  In the first case, this is ALL ‚Äî the entire table is being scanned.  In the second case, eq_ref is a search directly by key, forming one record. </li><li>  the number of lines, which is expected, given that this is a kind of convention. </li><li>  possible_keys are the keys that the optimizer plans to use, and key is the key that it chooses.  An option is possible if you have, for example, possible_key: NULL, and there is some key in the key value.  This happens in cases where, for example, there are no WHERE conditions on the SELECT FROM table.  The optimizer sees that, like, no keys should be used, and then it looks that the columns are part of the key and, in principle, you can select them precisely by the index and then make the covering index.  So it may happen that possible_key: NULL, and the key is the covering index, which means that it will use the index. </li><li>  key_len is the length of the index that it uses, that is, if we have a composite index, then by looking at key_len, we can understand which part of the index it uses. </li></ul><br><br><p>  Further we will not consider in detail all possible options - this is well described in the documentation. </p><br><p>  It is clear that he forms one row for each table that occurs in the query, and executes the query in the sequence in which the table is displayed, i.e.  looking at EXPLAIN, we can immediately understand that the following order of access to the tables was chosen - first selects the city table, then selects the country table.  Everything is simple here. </p><br><p>  But, when we have such a sophisticated EXPLAIN, which includes various UNION, FROM subqueries, etc., and a long ‚Äúsheet‚Äù is output: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/115/d8a/07c/115d8a07c026a509b9da1e9f1c520a0d.jpg"><br><br><p>  The question arises - how to read it? </p><br><p>  The idea is very simple: we enumerate all the SELECTs that appear in the query, and the SELECT number will correspond to the identifier number that is in EXPLAIN. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/714/80b/0e0/71480b0e078fd59f293c8d765772e552.jpg"><br><br><p>  I highlighted in different colors for clarity. </p><br><p>  The second caveat - we can look at the numbers.  For example, number 6 - DERIVED is a FROM subquery.  The next one comes with a larger id.  This means that it belongs to the same FROM subquery, i.e.  will go to the same temporary table.  Thus, looking only at identifiers, many conclusions can already be drawn. </p><br><p>  There is an inconvenience: I say that rows are executed sequentially, but in reality, when there are such things as derived tables, this is not quite the case.  Those.  it is convenient to read requests with UNIONS in this way - one UNION is 4, and this means that the lines from 1st to 4th refer to one part of UNION, and from 4th to the last - to the second part.  Those.  we can look at the last line and go up, and so break requests.  Actually, there is nothing difficult in this, only skill is needed. </p><br><p>  There are utilities that immediately build EXPLAIN's graphical representations, but we will not consider them, especially since in the case of complex queries, they are also not so easy to understand.  This is an amateur. </p><br><p>  Example when EXPLAIN is lying. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/eab/8c8/ad7eab8c87767a69c2c102c97be8d066.jpg"><br><br><p>  We have a query with a subquery in the in part.  The subquery is independent, however, MySQL before MariaDB 5.3 and MySQL 5.6 often performed these queries as dependent ones.  We see the type of the query - dependent, but on the other hand we see type: index_subquery - this means that in fact the subquery is not executed, but is replaced with the function of viewing the index.  Those.  these lines are in conflict with each other, they talk about opposite things. </p><br><p>  The question arises - what is actually happening there, because  Does EXPLAIN give out conflicting information? </p><br><p>  We can do the query profiling and see: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/f17/f31/b13/f17f31b13d4da30978a1e11f54cbdfda.jpg"><br><br><p>  In the case when the request is executed dependent, as on the right, we have part of the execution of the request - data transfer - will be multiple, duplicated.  In the case when the query is executed independently, these values ‚Äã‚Äãwill not be duplicated. </p><br><p>  In addition, profiling is convenient for determining such nuances as transferring big data, calculating statistics, etc. </p><br><br><h3>  Sorting </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/27c/4f1/47d/27c4f147d201c3b52a96393d5fee8f88.jpg"><br><br><p>  When ORDER BY id LIMIT 10000, 10 is bad, because     10 .  +  10,  1001-    10 .    -  .  ID  10 000, LIMIT 10.    offset   ‚Äî    ,   ,  . </p><br><p>   ORDER BY rand(), ..       ,    ,     ,     rand        . ,      , ORDER BY rand()       ,       . </p><br><p>      , ,     ,        ‚Äî ORDER BY null. </p><br><p>     . </p><br><p>  : </p><br><img src="https://habrastorage.org/getpro/habr/post_images/3f4/74e/07f/3f474e07fab824dc53c2b9e56f17be64.jpg"><br><br><p>        - .     10   , ..     ,     . ,   ‚Äú ‚Äù   join'      .  :         .         .     ,     . </p><br><p>    ,  10    ‚Äî  10    +   ,  10    +   .   , ..          ,     .   ,  ,  .      ,        ,   ,  ,   ,     ,      ,       Using filesort,  .    Using filesort' ‚Äî   . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d19/fa9/b6d/d19fa9b6d09b8b943396d962164a0f16.jpg"><br><br><p>  ,    : ,   -    ,    .   ,    -   ,      . </p><br><p>       ,     UNION'    from     .    ,        , .. ,   UNION', +    ,      .  ,        ,    . </p><br><p>    ORDER BY + LIMIT ,   WordPress. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/2a2/627/ff7/2a2627ff7d23404f59b073ca143e1261.jpg"><br><br><p>     ‚Äî    ,      , ..   ,          3 .  , ,   Using filesort    .  Since     ,  , ..     ,          ,       ,    , ..    2 . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/236/96b/392/23696b39253639fdad79f5a4b77e40ad.jpg"><br><br><p>    ,    .    ,  ,        ,       category_ID=1, ,    ,     . .         ,     ,  ,  3 ,    . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/fbe/ee0/cb3/fbeee0cb320f6df8444a1d48cc94c513.jpg"><br><br><p>     Using filesort,    ,     ‚Äî     .   show status   , ,       95      . ,   .     key bufer size,  ,   .  ,    ,      ,      ,       . </p><br><p>  ,      . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/a3c/89b/283/a3c89b2830cae17501ea41f9920d69b4.jpg"><br><br><p>    , .., ,         ,          ,    ,          2  (, ).          - . </p><br><p>  ,  ‚Äî    EXPLAN',     . </p><br><p>     ANALYZE statement ‚Äî  ,   PostgreSQL    ,     MariaDB 10.1,   beta. </p><br><p>     SHOW EXPLAIN,      MariaDB   EXPLAIN    .     . </p><br><blockquote> <font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any questions you can ask me on the forum </font></font><a href="http://sqlinfo.ru/forum/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLinfo.ru/forum/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></font> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/309328/">https://habr.com/ru/post/309328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309316/index.html">Clear boy Zone.js</a></li>
<li><a href="../309318/index.html">4 types of memory leaks in javascript and how to deal with them</a></li>
<li><a href="../309320/index.html">Mail of Russia: in e-commerce-future with cautious optimism</a></li>
<li><a href="../309324/index.html">Anatomy of a web service</a></li>
<li><a href="../309326/index.html">How does MySQL replication work?</a></li>
<li><a href="../309330/index.html">Database scaling through sharding and partitioning</a></li>
<li><a href="../309332/index.html">Principles and techniques for processing queues</a></li>
<li><a href="../309338/index.html">Future is now: what will happen on JavaDay Kharkiv 2016, September 17</a></li>
<li><a href="../309340/index.html">.Net Core, 1C, dynamic compilation, Scripting API</a></li>
<li><a href="../309342/index.html">We invite you on October 19, Moscow to the IX conference "Embedded Technologies 2016. Industrial Internet of Things"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>