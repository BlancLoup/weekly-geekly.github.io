<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing and building syntax trees with PLY. The basics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is PLY? 
 PLY is an abbreviation of the first letters of an expression: P ython L ex- Y acc. 
 In fact, this is the port of the lex and yacc util...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing and building syntax trees with PLY. The basics</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/178/82c/79e/17882c79e4443998a0e1020819cc3d3b.png"><br><h2>  What is PLY? </h2><br>  <a href="http://www.dabeaz.com/ply/ply.html">PLY</a> is an abbreviation of the first letters of an expression: <strong>P</strong> ython <strong>L</strong> ex- <strong>Y</strong> acc. <br>  In fact, this is the port of the lex and yacc utilities on python in a nice wrapper. <br>  Working with ply is very simple and the threshold for starting to use is almost zero. <br>  It is written on pure python and is a <a href="http://ru.wikipedia.org/wiki/LALR%25281%2529">LALR (1) parser</a> , but who cares? <br>  I am by nature a practitioner (like most of you) therefore went into battle! <br><br><h2>  What do we do? </h2><br>  <a href="http://www.dabeaz.com/ply/example.html">The site has an example of</a> writing the next calculator, so we will not repeat.  And let's do something like a parser of a very very narrow PHP subset :) <br>  Our task at the end of the article is to build a syntax tree for such an example: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $val = <span class="hljs-number"><span class="hljs-number">5</span></span>; $result = substr( <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*(<span class="hljs-number"><span class="hljs-number">7</span></span>-$val) ); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"  : $result"</span></span>;</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The example is very small and taken from the ceiling.  But to build a tree of code you need a lot and the campaign we will use such a mechanism PLY as state. <br><br><a name="habracut"></a><br><br><h4>  Lex </h4><br>  <a href="http://ru.wikipedia.org/wiki/Lex">Lex</a> is the thing that breaks the text down into basic language elements.  Well, or groups the text into basic elements.  Something like this. <br><br>  What do we see here, except for the useless code?  We see tokens (basic elements): <br>  PHP_START - '&lt;? Php' <br>  PHP_VAR - '$ result' <br>  PHP_EQUAL - '=' <br>  PHP_NAME - 'substr' <br>  PHP_OPEN - '(' <br>  PHP_STRING - "foobar", 'this is our result: $ result' <br>  PHP_NUM - '2', '7' <br>  PHP_CLOSE - ')' <br>  PHP_ECHO - "echo" <br>  PHP_COLON - ';' <br>  PHP_COMA - ',' <br>  PHP_PLUSMINUS - '-' <br>  PHP_DIVMUL - '*' <br><br>  To parse the text on tokens in PLY there is <i>ply.lex</i> .  And it works with regular expressions. <br>  And he is very picky about what we write in the code.  It requires the presence of an array called tokens. <br>  For each element of this array, we are obliged to have a regular code or function in the code named t_ILEMENT. <br>  Why is he so picky?  Because it does not work directly during the execution of the program, but is executed only once at the first launch of the program and creates the lextab.py file, which describes transition tables and regular tables.  The next time you start the program, it checks the presence of this file and, if it is present, it no longer tries to build the tables again, but uses the generated ones. <br>  Back to the code. <br>  If the PHP syntax were limited to the thirteen tokens listed above, we would write the following: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># coding=utf8 import ply.lex as lex #      ,                tokens = ( 'PHPSTART', 'PHPVAR', 'PHPEQUAL', 'PHPFUNC', 'PHPSTRING', 'PHPECHO', 'PHPCOLON', 'PHPCOMA', 'PHPOPEN', 'PHPCLOSE', 'PHPNUM', 'PLUSMINUS', 'DIVMUL' ) #      ident = r'[az]\w*' #            t_ =  t_PHPSTART = r'\&lt;\?php' t_PHPVAR = r'\$'+ident #  , ? t_PHPEQUAL = r'\=' t_PHPFUNC = ident t_PHPSTRING = r'"(\\.|[^"])*"' t_PHPECHO = r'echo' t_PHPCOLON = r';' t_PHPCOMA = r',' t_PHPOPEN = r'\(' t_PHPCLOSE = r'\)' t_PHPNUM = r'\d+' t_PLUSMINUS = r'\+|\-' t_DIVMUL = r'/|\*' #     .    ,  $var=$value  $var   =  $value t_ignore = ' \r\n\t\f' #     .      def t_error(t): print "Illegal character '%s'" % t.value[0] t.lexer.skip(1) lexer = lex.lex(reflags=re.UNICODE | re.DOTALL) data = ''' &lt;?php $result = substr("foobar", "bar"); echo $result; ''' lexer.input(data) while True: tok = lexer.token() #    if not tok: break #   print tok</span></span></code> </pre><br><br>  In the comments to the code, I roughly described what we have going on there.  I will only note that instead of regulars defining a token, <a href="http://www.dabeaz.com/ply/ply.html">you can write functions</a> in which there will be the same regulars, but in addition you can write something else of your own there.  For example: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t_PHPVAR</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">r'\$[a-zA-Z]\w*'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">',    '</span></span> + t.value <span class="hljs-comment"><span class="hljs-comment"># value -      return t</span></span></code> </pre><br><br>  By the way, the output of the example that is written above will be: <br><br><pre>  LexToken (PHPSTART, '&lt;? Php', 1,1)
 LexToken (PHPVAR, '$ val', 1.7)
 LexToken (PHPEQUAL, '=', 1.12)
 LexToken (PHPNUM, '5', 1.14)
 LexToken (PHPCOLON, ';', 1.15)
 LexToken (PHPVAR, '$ result', 1.17)
 LexToken (PHPEQUAL, '=', 1.25)
 LexToken (PHPFUNC, 'substr', 1.27)
 LexToken (PHPOPEN, '(', 1.33)
 LexToken (PHPSTRING, '"foobar"', 1.35)
 LexToken (PHPCOMA, ',', 1.43)
 LexToken (PHPNUM, '2', 1.45)
 LexToken (DIVMUL, '*', 1.46)
 LexToken (PHPOPEN, '(', 1.47)
 LexToken (PHPNUM, '7', 1.48)
 LexToken (PLUSMINUS, '-', 1.49)
 LexToken (PHPVAR, '$ val', 1.50)
 LexToken (PHPCLOSE, ')', 1.54)
 LexToken (PHPCLOSE, ')', 1.56)
 LexToken (PHPCOLON, ';', 1.57)
 LexToken (PHPFUNC, 'echo', 1.59)
 LexToken (PHPSTRING, '"\ xd1 \ x8d \ xd1 \ x82 \ xd0 \ xbe \ xd0 \ xbd \ xd0 \ xb0 \ xd1 \ x88 \ xd1 \ x80 \ xd0 \ xb5 \ xd0 \ xb7 \ xd1 \ x83 \ xd0 \ xbb \ xd1 \ x8c \ xd1 \ x82 \ xd0 \ xb0 \ xd1 \ x82: $ result "', 1.64)
 LexToken (PHPCOLON, ';', 1,107)
</pre><br><br>  The numbers at the end are the line number and the character number.  As you can see, the line number does not change.  You need to change it yourself.  How?  When you pass the token with the transition to a new line.  To do this, remove the newline character from the ignored tokens and add a new t_newline function: <br><br><pre> <code class="python hljs">t_ignore = <span class="hljs-string"><span class="hljs-string">' \r\t\f'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t_newline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">r'\n+'</span></span> t.lexer.lineno += len(t.value)</code> </pre><br><br>  Now everything works with us: <br><br><pre> LexToken (PHPSTART, '&lt;? Php', 2.1)
 LexToken (PHPVAR, '$ val', 3.7)
 LexToken (PHPEQUAL, '=', 3.12)
 LexToken (PHPNUM, '5', 3.14)
 LexToken (PHPCOLON, ';', 3.15)
 LexToken (PHPVAR, '$ result', 4.17)
 LexToken (PHPEQUAL, '=', 4.25)
 LexToken (PHPFUNC, 'substr', 4.27)
 LexToken (PHPOPEN, '(', 4.33)
 LexToken (PHPSTRING, '"foobar"', 4.35)
 LexToken (PHPCOMA, ',', 4.43)
 LexToken (PHPNUM, '2', 4.45)
 LexToken (DIVMUL, '*', 4.46)
 LexToken (PHPOPEN, '(', 4.47)
 LexToken (PHPNUM, '7', 4.48)
 LexToken (PLUSMINUS, '-', 4.49)
 LexToken (PHPVAR, '$ val', 4.50)
 LexToken (PHPCLOSE, ')', 4.54)
 LexToken (PHPCLOSE, ')', 4.56)
 LexToken (PHPCOLON, ';', 4.57)
 LexToken (PHPFUNC, 'echo', 5.59)
 LexToken (PHPSTRING, '"\ xd1 \ x8d \ xd1 \ x82 \ xd0 \ xbe \ xd0 \ xbd \ xd0 \ xb0 \ xd1 \ x88 \ xd1 \ x80 \ xd0 \ xb5 \ xd0 \ xb7 \ xd1 \ x83 \ xd0 \ xbb \ xd1 \ x8c \ xd1 \ x82 \ xd0 \ xb0 \ xd1 \ x82: $ result "', 5.64)
 LexToken (PHPCOLON, ';', 5,107)
</pre><br><br>  Works, but not completely.  Our string ‚Äúis our result: $ result‚Äù is returned by the lexer as is  And how will we parse it?  Create a separate lexer?  Nope  In PLY (and in lex) there is support for such a thing as state.  <a href="http://www.dabeaz.com/ply/ply.html">State</a> is a switch to a different type of token.  This is what we will use. <br><br><h6>  State </h6><br>  So, in order to create a new state, we first need to declare it: <br><br><pre> <code class="python hljs">states = ( (<span class="hljs-string"><span class="hljs-string">'string'</span></span>,<span class="hljs-string"><span class="hljs-string">'exclusive'</span></span>), )</code> </pre><br><br>  'string' is the name of the new state, and exclusive is the type.  In general, there can be two types of states: exclusive and inclusive.  Exclusive - general tokens are not visible (common, these are the ones we wrote before, they are in the INITIAL state by default).  Inclusive - you can see common tokens and in the current state we just add additional ones to them. <br>  In the case of our string, we do not need other tokens, since inside we have it all different.  But we will borrow a couple.  We need the PHPVAR token, because our variable looks the same both inside and outside the line, and we need another token, which you will see later on. <br>  To make the token shared, we must assign it the ANY_ prefix, but to make the token visible only for a particular state, &lt;state&gt; _.  Below are the modified tokens. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#            t_ =  t_PHPSTART = r'\&lt;\?php' t_ANY_PHPVAR = r'\$'+ident #  , ? t_PHPEQUAL = r'\=' t_PHPFUNC = ident t_PHPECHO = r'echo' t_PHPCOLON = r';' t_PHPCOMA = r',' t_PHPOPEN = r'\(' t_PHPCLOSE = r'\)' t_PHPNUM = r'\d+' t_PLUSMINUS = r'\+|\-' t_DIVMUL = r'/|\*' #   PHPSTRING     ,      def t_ANY_PHPSTRING(t): #    ,         . r'"' if t.lexer.current_state() == 'string': t.lexer.begin('INITIAL') #     else: t.lexer.begin('string') #   return t t_string_STR = r'(\\.|[^$"])+' #         ,    #       t_string_ignore = '' #    ,      state #         def t_string_error(t): print "Illegal character '%s'" % t.value[0] t.lexer.skip(1)</span></span></code> </pre><br><br>  By the way, have you noticed this: <i>LexToken (PHPFUNC, 'echo', 5.59)</i> ? <br>  PLY sorts regular expressions in ascending order before building the table and wins the longest during the parsing process.  That's why echo doesn't parse like PHPECHO.  How to get around this?  Easy.  Just change the return type of the token in the function. <br>  Like this: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@TOKEN(ident) def t_PHPFUNC(t): if t.value.lower() == 'echo': t.type = 'PHPECHO' return t</span></span></code> </pre><br><br>  Now echo returns as needed.  By the way, about the <a href="http://www.dabeaz.com/ply/ply.html">TOKEN</a> decorator: instead of writing a regular at the beginning of the function body, you can simply put it into a variable and apply it to the function as a decorator.  What we did. <br><br>  Here it is.  Now everything seems to be.  Yes, not all. <br>  It would be nice to ignore comments. <br>  Well, let's add another small function to the lexer: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t_comment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">r'(/\*(.|\n)*?\*/)|(//.*)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Full source code lexer (lexer.py)</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># coding=utf8 import ply.lex as lex from ply.lex import TOKEN import re states = ( ('string','exclusive'), ) #      ,                tokens = ( 'PHPSTART', 'PHPVAR', 'PHPEQUAL', 'PHPFUNC', 'PHPSTRING', 'PHPECHO', 'PHPCOLON', 'PHPCOMA', 'PHPOPEN', 'PHPCLOSE', 'PHPNUM', 'PLUSMINUS', 'DIVMUL', 'STR' ) #      ident = r'[az]\w*' #            t_ =  t_PHPSTART = r'\&lt;\?php' t_ANY_PHPVAR = r'\$'+ident #  , ? t_PHPEQUAL = r'\=' t_PHPCOLON = r';' t_PHPCOMA = r',' t_PHPOPEN = r'\(' t_PHPCLOSE = r'\)' t_PHPNUM = r'\d+' t_PLUSMINUS = r'\+|\-' t_DIVMUL = r'/|\*' @TOKEN(ident) def t_PHPFUNC(t): if t.value.lower() == 'echo': t.type = 'PHPECHO' return t #   def t_comment(t): r'(/\*(.|\n)*?\*/)|(//.*)' pass #   PHPSTRING     ,      def t_ANY_PHPSTRING(t): #    ,         . r'"' if t.lexer.current_state() == 'string': t.lexer.begin('INITIAL') #     else: t.lexer.begin('string') #   return t t_string_STR = r'(\\.|[^$"])+' #         ,    #       t_string_ignore = '' #    ,      state #         def t_string_error(t): print "Illegal character '%s'" % t.value[0] t.lexer.skip(1) #     .    ,  $var=$value  $var   =  $value t_ignore = ' \r\t\f' def t_newline(t): r'\n+' t.lexer.lineno += len(t.value) #     .      def t_error(t): print "Illegal character '%s'" % t.value[0] t.lexer.skip(1) lexer = lex.lex(reflags=re.UNICODE | re.DOTALL | re.IGNORECASE) if __name__=="__main__": data = ''' &lt;?php $val = 5; $result = substr( "foobar", 2*(7-$val) ); echo "  : $result"; ''' lexer.input(data) while True: tok = lexer.token() #    if not tok: break #   print tok</span></span></code> </pre><br></div></div><br><br>  Now go to the parser (parser.py). <br><br><h4>  Yacc </h4><br>  Yacc is a piece (parser) into which we transfer tokens and describe the rules for their connection (grammar).  Hike the work of this program, we can create an abstract tree, or immediately run the program (as is done in the example with a calculator on the site). <br>  In PLY, there is a class <i>ply.yacc</i> to describe grammar. <br>  Describing grammar in ply is very simple and it gives even some pleasure.  To describe, we again have special functions p_name function, where in the doc-lines we describe this very grammar. <br>  Let's try to write a very simple grammar for our abstract php example: <br><br><pre> php -&gt; [PHPSTART phpbody]?
 phpbody -&gt; [phpline phpcolons] *
 phpcolons -&gt; [PHPCOLON] +
 phpline -&gt; assign |  func |  [PHPECHO args]
 assign -&gt; PHPVAR PHPEQUAL expr
 expr -&gt; [fact |  expr PLUSMINUS fact]
 fact -&gt; [term |  fact DIVMUL term]
 term -&gt; [arg |  PHPOPEN expr PHPCLOSE]
 func -&gt; PHPFUNC PHPOPEN args PHPCLOSE
 args -&gt; [expr [PHPCOMA expr] *]?
 arg -&gt; string |  phpvar |  PHPNUM |  func
 string -&gt; PHPSTRING str PHPSTRING
 str -&gt; [STR |  str phpvar]?
 phpvar -&gt; PHPVAR
</pre><br><br>  There is already a lot of text written, and you can still talk for a very long time.  But to understand the basics of ply.yacc, it suffices to look at one example.  And then I'll post the source of the parser. <br><br>  So, the torn piece from the parser: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p_str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'''str : | STR | str phpvar'''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(p) == <span class="hljs-number"><span class="hljs-number">1</span></span>: p[<span class="hljs-number"><span class="hljs-number">0</span></span>] = Node(<span class="hljs-string"><span class="hljs-string">'str'</span></span>, [<span class="hljs-string"><span class="hljs-string">''</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> len(p) == <span class="hljs-number"><span class="hljs-number">2</span></span>: p[<span class="hljs-number"><span class="hljs-number">0</span></span>] = Node(<span class="hljs-string"><span class="hljs-string">'str'</span></span>, [p[<span class="hljs-number"><span class="hljs-number">1</span></span>]]) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: p[<span class="hljs-number"><span class="hljs-number">0</span></span>] = p[<span class="hljs-number"><span class="hljs-number">1</span></span>].add_parts([p[<span class="hljs-number"><span class="hljs-number">2</span></span>]])</code> </pre><br><br>  In order.  Parsing starts from the first top function with the pattern p_ &lt;function&gt;.  Those.  For example, my first source is p_php, so the parser will start working from there (from top to bottom).  The parser works with the rules in the doc-lines, and after their matching returns control to the function with the rules and passes the variable p.  The variable p stores the result of the parsing.  And after processing, we have to shove our results in p [0].  Elements starting from p [1] are the right part of our rules - token tokens and rules. <br><br><pre> <code class="python hljs"> <span class="hljs-string"><span class="hljs-string">'''str : | STR | str phpvar'''</span></span></code> </pre><br><br>  In fact, the rule above is a combined (merged) rule.  '|'  as easy to guess - this is OR, well, or various token options. <br>  A space is required between the colon and the left / right side.  So likes ply.  If the right side can be empty, then we do not write anything after the colon.  Tokens should be written in capital letters, and the rules should be small, without the p_ prefix.  Those.  in the example above, the p_str and p_phpvar rules were used. <br><br>  For example, if we have "" (empty string), then in p we will have only one value - p [0], and it is not defined and we must fill it. <br>  If we have the string "hello $ vasya pupkin", then this function will be executed three times.  The first time is for the STR value, and we will return this value back to p [0], the second time for $ vasya, and add it to the previous value (p [1] will contain the node that we returned to p [0] at the last iteration ), and the third time we add to the exit "pupkin".  I guess I described it messily, but you just need to touch it.  Open the execution environment and play :) <br><br>  By the way, sometimes the option with divided versions is more convenient (taftology, sorry): <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p_str_empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'''str :'''</span></span> p[<span class="hljs-number"><span class="hljs-number">0</span></span>] = Node(<span class="hljs-string"><span class="hljs-string">'str'</span></span>, [<span class="hljs-string"><span class="hljs-string">''</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p_str_raw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'''str : STR'''</span></span> p[<span class="hljs-number"><span class="hljs-number">0</span></span>] = Node(<span class="hljs-string"><span class="hljs-string">'str'</span></span>, [p[<span class="hljs-number"><span class="hljs-number">1</span></span>]]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p_str_var</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'''str : str phpvar'''</span></span> p[<span class="hljs-number"><span class="hljs-number">0</span></span>] = p[<span class="hljs-number"><span class="hljs-number">1</span></span>].add_parts([p[<span class="hljs-number"><span class="hljs-number">2</span></span>]])</code> </pre><br><br>  It is absolutely identical to the previous version of the code.  Just other markers.  Functions have different names (because they must be separated in python), but the prefixes are identical (str), which causes ply to group them together as variants of the same rule. <br><br>  For the convenience of building a tree, I used such a simple and effective class: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parts_str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> st = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> part <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parts: st.append( str( part ) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"\n"</span></span>.join(st) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.type + <span class="hljs-string"><span class="hljs-string">":\n\t"</span></span> + self.parts_str().replace(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>, <span class="hljs-string"><span class="hljs-string">"\n\t"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_parts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parts)</span></span></span><span class="hljs-function">:</span></span> self.parts += parts <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, type, parts)</span></span></span><span class="hljs-function">:</span></span> self.type = type self.parts = parts</code> </pre><br><br>  It simultaneously stores all that is necessary, and structures the conclusion that it is convenient when debugging. <br><br><div class="spoiler">  <b class="spoiler_title">Full parser code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># coding=utf8 from lexer import tokens import ply.yacc as yacc class Node: def parts_str(self): st = [] for part in self.parts: st.append( str( part ) ) return "\n".join(st) def __repr__(self): return self.type + ":\n\t" + self.parts_str().replace("\n", "\n\t") def add_parts(self, parts): self.parts += parts return self def __init__(self, type, parts): self.type = type self.parts = parts def p_php(p): '''php : | PHPSTART phpbody''' if len(p) == 1: p[0] = None else: p[0] = p[2] def p_phpbody(p): '''phpbody : | phpbody phpline phpcolons''' if len(p) &gt; 1: if p[1] is None: p[1] = Node('body', []) p[0] = p[1].add_parts([p[2]]) else: p[0] = Node('body', []) def p_phpcolons(p): '''phpcolons : PHPCOLON | phpcolons PHPCOLON''' def p_phpline(p): '''phpline : assign | func | PHPECHO args''' if len(p) == 2: p[0] = p[1] else: p[0] = Node('echo', [p[2]]) def p_assign(p): '''assign : PHPVAR PHPEQUAL expr''' p[0] = Node('assign', [p[1], p[3]]) def p_expr(p): '''expr : fact | expr PLUSMINUS fact''' if len(p) == 2: p[0] = p[1] else: p[0] = Node(p[2], [p[1], p[3]]) def p_fact(p): '''fact : term | fact DIVMUL term''' if len(p) == 2: p[0] = p[1] else: p[0] = Node(p[2], [p[1], p[3]]) def p_term(p): '''term : arg | PHPOPEN expr PHPCLOSE''' if len(p) == 2: p[0] = p[1] else: p[0] = p[2] def p_func(p): '''func : PHPFUNC PHPOPEN args PHPCLOSE''' p[0] = Node('func', [p[1], p[3]]) def p_args(p): '''args : | expr | args PHPCOMA expr''' if len(p) == 1: p[0] = Node('args', []) elif len(p) == 2: p[0] = Node('args', [p[1]]) else: p[0] = p[1].add_parts([p[3]]) def p_arg(p): '''arg : string | phpvar | PHPNUM | func''' p[0] = Node('arg', [p[1]]) def p_phpvar(p): '''phpvar : PHPVAR''' p[0] = Node('var', [p[1]]) def p_string(p): '''string : PHPSTRING str PHPSTRING''' p[0] = p[2] def p_str(p): '''str : | STR | str phpvar''' if len(p) == 1: p[0] = Node('str', ['']) elif len(p) == 2: p[0] = Node('str', [p[1]]) else: p[0] = p[1].add_parts([p[2]]) def p_error(p): print 'Unexpected token:', p parser = yacc.yacc() def build_tree(code): return parser.parse(code)</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">The main file, from where we call all</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># coding=utf8 from parser import build_tree data = ''' &lt;?php $val = 5; $result = substr( "foobar", 2*(7-$val) ); /* comment */ echo "  : ", $result; ''' result = build_tree(data) print result</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Syntax tree output</b> <div class="spoiler_text"><pre> line:
	 assign:
		 $ val
		 arg:
			 five
	 assign:
		 $ result
		 arg:
			 func:
				 substr
				 args:
					 arg:
						 str:
							 foobar
					 *:
						 arg:
							 2
						 -:
							 arg:
								 7
							 arg:
								 var:
									 $ val
	 echo:
		 args:
			 arg:
				 str:
					 this is our result: 
			 arg:
				 var:
					 $ result
</pre><br></div></div><br><br><h2>  Conclusion </h2><br><br>  If there are any comments or suggestions, I will gladly add / change the post. <br><br>  <a href="https://github.com/dyatlov/habr-ply-microphp">Article code here</a> <br><br>  Well, if I'm wondering why I suddenly decided to write about ply - <a href="https://github.com/dyatlov/Pyfox">pyfox</a> .  I do little by little css processing on python.  Rather, the css parser is written, but the walk through the dom is not fully implemented yet (not all pseudo-selectors work).  Now specifically the problem with nth-child.  Not at the level of css but at the level of effective matching - in dom there is no such property as a number among neighbors, but I don‚Äôt want to consider previous neighbors.  Apparently you have to customize HTMLParser.  Can anyone decide to join me?  All welcome :) </div><p>Source: <a href="https://habr.com/ru/post/191252/">https://habr.com/ru/post/191252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191240/index.html">Elliptical cryptography: practice</a></li>
<li><a href="../191242/index.html">Programmer's brain</a></li>
<li><a href="../191246/index.html">Conflict Resolution in Transitive Dependencies - Good, Bad, Angry</a></li>
<li><a href="../191248/index.html">ASP.NET MVC client-side routing</a></li>
<li><a href="../191250/index.html">Internal device llst, part 2 or Little Smalltalk + LLVM =</a></li>
<li><a href="../191254/index.html">The German government warns the country's authorities against using Windows 8</a></li>
<li><a href="../191256/index.html">Features parsing block HTML-code screen access programs</a></li>
<li><a href="../191262/index.html">RosVybory Danger</a></li>
<li><a href="../191266/index.html">Meet-in-the-middle: brute force optimization and more</a></li>
<li><a href="../191268/index.html">Record Records</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>