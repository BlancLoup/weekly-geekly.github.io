<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Micropython on GSM + GPS A9G module</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This time I thought about hiding a GPS tracker as a precaution in my bike. There are a lot of autonomous devices on the market for tracking cars, carg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Micropython on GSM + GPS A9G module</h1><div class="post__text post__text-html js-mediator-article"><p>  This time I thought about hiding a GPS tracker as a precaution in my bike.  There are a lot of autonomous devices on the market for tracking cars, cargo, bicycles, luggage, children and animals.  The vast majority of them interact with the user via SMS.  More expensive options provide Find my phone functionality, but are tied to a specific online service. <br>  Ideally, I would like to have full control over the tracker: use it in a convenient mode without SMS and registration.  Superficial googling led me to a couple of modules from the sky, one of which, the A9G pudding board, I ordered (~ $ 15). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7f/b34/fe0/f7fb34fe016bb3a6c532712b9b2e75e1.png" alt="Module"></p><br><p>  This article is about how I got python to work on this module. </p><a name="habracut"></a><br><p>  If A9G is an analogue of ESP (the manufacturer, by the way, is the same), then the pudding board itself is analogous to the NodeMCU board, except that the pudding board does not have an integrated USB-UART converter.  But there are many other interesting things.  <a href="">Manufacturer</a> Specifications: </p><br><ul><li>  32 bit core (RISC), up to 312MHz </li><li>  29x GPIO (all soldered, this number includes all interfaces) </li><li>  watch and watchdog </li><li>  1x USB 1.1 interface (I didn‚Äôt find it there, but copy from offsite) and microUSB for power </li><li>  2x UART (+1 service) </li><li>  2x SPI (did not try) </li><li>  3x I2C (did not try) </li><li>  1x SDMMC (with physical slot) </li><li>  2x analog inputs (10 bits, perhaps one of them is used by lithium battery controllers) </li><li>  4Mb flash </li><li>  4Mb PSRAM </li><li>  ADC (microphone, physically exists on the board) and DAC (speaker, absent) </li><li>  battery charge controller (no battery itself) </li><li>  GSM (800, 900, 1800, 1900 MHz) with SMS, voice and GPRS </li><li>  GPS connected via UART2 (there is an "A9" module without it) </li><li>  SIM slot (nanoSIM) </li><li>  two buttons (one reset, the other - on and programmable function) </li><li>  two LEDs </li></ul><br><p>  The operating voltage is 3.3V, the input voltage is 5-3.8V (depending on the connection).  In general, the module has all the necessary hardware in order to assemble a simple push-button mobile device from it.  But from the examples one gets the impression that the Chinese buy it for sale from slot machines or slot machines with gambling or something like that.  Alternatives to the module are quite popular SIM800 modules, which, unfortunately, do not have an SDK in free access (that is, modules are sold as AT modems). </p><br><h1>  Sdk </h1><br><p> The <a href="https://github.com/Ai-Thinker-Open/GPRS_C_SDK">SDK is</a> attached to the module in satisfactory English.  It is installed under Ubuntu, but Windows and containers are preferred.  Everything works through poking in the GUI: ESPtool for this module is only to be overridden.  The firmware itself is going to makefile.  Debagger is there: before hanging, the module dumps the stack trace into the service port.  But personally, I could not translate addresses into lines of code (gdb reports that addresses do not correspond to anything).  It is possible that this is due to poor support for Linux itself.  Accordingly, if you want to tinker with the module - try to do it under Windows (and unsubscribe at github).  Otherwise, here are the <a href="https://ai-thinker-open.github.io/GPRS_C_SDK_DOC/en/c-sdk/installation_linux.html">instructions</a> for Linux.  After installation, you need to check the correctness of the paths in .bashrc and delete (rename) all <code>CSDTK/lib/libQt*</code> : otherwise, the flasher (also known as debugger) will simply not start due to a conflict with probably installed libQt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a7/955/5bc/7a79555bca02e1ad6363b8da9559c91e.png" alt="Flasher"></p><br><p>  To the flasher goes <a href="https://ai-thinker-open.github.io/GPRS_C_SDK_DOC/en/c-sdk/burn-debug.html">instruction</a> . </p><br><h1>  Connection </h1><br><p>  Everything is more complicated than on NodeMCU.  The modules look similar, but on the pudding board there is no USB-TTY chip and microUSB is used only for power.  Accordingly, you will need USB-TTY at 3.3V.  And two are better: one for debugging the port and one for UART1: the first is used to fill the firmware and the second you can use as a normal terminal.  In order not to drag all these snot to the computer, I additionally purchased a 4-port USB splitter with a two-meter wire and an external power supply (mandatory).  The total cost of this set with the module itself will be $ 25-30 (without power supply: use from the phone). </p><br><h1>  Firmware </h1><br><p>  The module comes with AT firmware: you can connect to the 3.3V arduine and use it as a modem via UART1.  Your firmware is written in C. <code>make</code> creates two firmware files: one is sewn for about a minute, the other is quite fast.  You can sew only one of these files: the first time is large, the subsequent times are small.  In total, in my development process, the Chinese SDK ( <code>coolwatcher</code> ) is open on the desktop for managing the module, miniterm as a stdio and code editor. </p><br><h1>  API </h1><br><p>  The <a href="https://ai-thinker-open.github.io/GPRS_C_SDK_DOC/en/">API</a> content reflects the list at the top and resembles ESP8266 in its early days: it took me 3 hours to launch HelloWorld.  Unfortunately, the set of functions available to the user is very limited: for example, there is no access to the phone book on the SIM card, low-level information about connecting to a cellular network, and so on.  API documentation is even less complete, so you have to rely on examples (two dozen) and include files.  However, the module can do a lot down to SSL connections: obviously, the manufacturer has focused on the highest priority functions. </p><br><p>  However, the programming of Chinese microcontrollers through the Chinese API must be loved.  For all the others, the manufacturer <a href="https://github.com/Neutree/micropython/">began to port</a> <a href="https://micropython.org/">micropython</a> to this module.  I decided to try myself in an open-source project and continue this good deed (link at the end of the article). </p><br><h1>  micropython </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9a1/b46/e00/9a1b46e00d290db2f478ebb54f7d9e74.jpg" alt="logo"></p><br><p>  Micropython is an open-source project that port cPython to microcontrollers.  Development is conducted in two directions.  The first is the support and development of core libraries common to all microcontrollers that describe working with basic data types in python: objects, functions, classes, strings, atomic types, and so on.  The second is, in fact, the ports: for each microcontroller, it is necessary to ‚Äúteach‚Äù the library to work with the UART for I / O, select the stack for the virtual machine, specify a set of optimizations.  Optionally, work with iron is described: GPIO, power, wireless communication, file system. <br>  All this is written in pure C with macros: micropython has a set of recommended recipes starting from the declaration of strings in ROM to the writing of modules.  In addition to this, samopisny modules on python are fully supported (the main thing is not to forget about the amount of memory).  The project curators aim <a href="https://github.com/micropython/micropython/wiki/ContributorGuidelines">to launch jang</a> (picture with a loaf of bread).  As an advertisement: the project sells its own board for <a href="https://store.micropython.org/">pyboard</a> students, but ports for the ESP8266 and ESP32 modules are also popular. </p><br><p>  When the firmware is ready and flooded - you simply connect to the microcontroller through the UART and get into the Python REPL. </p><br><pre> <code class="bash hljs">$ miniterm.py /dev/ttyUSB1 115200 --raw MicroPython cd2f742 on 2017-11-29; unicorn with Cortex-M3 Type <span class="hljs-string"><span class="hljs-string">"help()"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) hello</code> </pre> <br><p>  After that, you can start writing <a href="https://github.com/micropython/micropython/wiki/Differences">in almost ordinary python3</a> , not forgetting the memory limitations. </p><br><p>  The A9G module is not officially supported (a list of officially supported modules is available in <code>micropython/ports</code> , there are about a dozen of them).  Nevertheless, the iron manufacturer forked a micropython and created an environment for the A9G port: <a href="https://github.com/Neutree/micropython/tree/master/ports/gprs_a9"><code>micropython/ports/gprs_a9</code></a> , for which he thanks a lot.  At the moment when I became interested in this issue, the port was successfully compiled and the microcontroller welcomed me to the REPL.  But, unfortunately, only the work with the file system and the GPIO was present from the third-party modules: nothing connected with the wireless network and GPS was available.  I decided to correct this flaw and set myself the goal of porting all the functions necessary for the GPS tracker.  <a href="https://micropython-dev-docs.readthedocs.io/en/latest/adding-module.html">The official documentation</a> for this case is unnecessarily laconic: therefore, I had to poke around in the code. </p><br><h2>  Where to begin </h2><br><p>  First, go to <code>micropython/ports</code> and copy <code>micropython/ports/minimal</code> to the new folder where the port will be located.  Then, edit <code>main.c</code> for your platform.  Keep in mind that all the yummy is in the <code>main</code> function, where you need to call the initializer <code>mp_init()</code> , having previously prepared for it the settings of the microcontroller and the stack.  Then, for event-driven API, you need to call <code>pyexec_event_repl_init()</code> and feed the characters entered via UART into the <code>pyexec_event_repl_process_char(char)</code> function.  This will ensure interaction through the REPL.  The second file, <code>micropython/ports/minimal/uart_core.c</code> describes blocking input and output in the UART.  I give the original code for the STM32 for those who are too lazy to look. </p><br><p> <code>main.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_dummy; stack_top = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)&amp;stack_dummy; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_GC gc_init(heap, heap + sizeof(heap)); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> mp_init(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_COMPILER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_REPL_EVENT_DRIVEN pyexec_event_repl_init(); for (;;) { int c = mp_hal_stdin_rx_chr(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (pyexec_event_repl_process_char(c)) { break; } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pyexec_friendly_repl(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//do_str("print('hello world!', list(x+1 for x in range(10)), end='eol\\n')", MP_PARSE_SINGLE_INPUT); //do_str("for i in range(10):\r\n print(i)", MP_PARSE_FILE_INPUT); #else pyexec_frozen_module("frozentest.py"); #endif mp_deinit(); return 0; }</span></span></span></span></code> </pre> <br><p> <code>uart_core.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Receive single character int mp_hal_stdin_rx_chr(void) { unsigned char c = 0; #if MICROPY_MIN_USE_STDOUT int r = read(0, &amp;c, 1); (void)r; #elif MICROPY_MIN_USE_STM32_MCU // wait for RXNE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 5)) == 0) { } c = USART1-&gt;DR; #endif return c; } // Send string of given length void mp_hal_stdout_tx_strn(const char *str, mp_uint_t len) { #if MICROPY_MIN_USE_STDOUT int r = write(1, str, len); (void)r; #elif MICROPY_MIN_USE_STM32_MCU while (len--) { // wait for TXE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 7)) == 0) { } USART1-&gt;DR = *str++; } #endif }</span></span></code> </pre> <br><p>  After that, you need to rewrite the Makefile using the recommendations / compiler from the manufacturer: everything is individual.  Everything, ideally, should be enough: we assemble, fill in the firmware and see the REPL in the UART. <br>  After reviving the <code>micropython</code> you need to take care of its well-being: set up the garbage collector, the correct reaction to Ctrl-D (soft reset) and some other things that I will not dwell on: see the <code>mpconfigport.h</code> file. </p><br><h2>  Create a module </h2><br><p>  The most interesting thing is to write your own modules.  So, a module (optional, but desirable) starts with its own <code>mod[].c</code> file <code>mod[].c</code> , which is added to the <code>Makefile</code> (variable <code>SRC_C</code> if you follow the convention).  An empty module looks like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// nlr - non-local return:  C  ,      goto-  . //  nlr_raise             . #include "py/nlr.h" //   .  ,  mp_map_elem_t,  ,   . #include "py/obj.h" //   . mp_raise_ValueError(char* msg)  mp_raise_OSError(int errorcode)   . //  ,   mp_call_function_*     Callable (  callback-). #include "py/runtime.h" #include "py/binary.h" //  header   :       #include "portmodules.h" //    --  .     MP_QSTR_[ ]. MP_OBJ_NEW_QSTR   . //             RAM. //      -      __name__ STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, }; //      STATIC MP_DEFINE_CONST_DICT (mp_module_mymodule_globals, mymodule_globals_table); //   :             const mp_obj_module_t mp_module_mymodule = { .base = { &amp;mp_type_module }, .globals = (mp_obj_dict_t*)&amp;mp_module_mymodule_globals, };</span></span></code> </pre> <br><p>  Of course, the port itself does not recognize the constant <code>mp_module_mymodule</code> : it must be added to the variable <code>MICROPY_PORT_BUILTIN_MODULES</code> in the settings of the port <code>mpconfigport.h</code> .  By the way <del>  non dull wallpapers </del>  Chip name and port name are also changed there.  After all these changes, you can try to compile the module and import it from the REPL.  The module will have only one <code>__name__</code> attribute with the name of the module (a different case for checking the auto-completion in the REPL via Tab). </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.__name__ <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span></code> </pre> <br><h2>  Constants </h2><br><p>  The next stage in complexity is the addition of constants.  Constants are often needed for settings ( <code>INPUT</code> , <code>OUTPUT</code> , <code>HIGH</code> , <code>LOW</code> , etc.) Everything is quite simple.  Here, for example, the <code>magic_number = 10</code> constant: </p><br><pre> <code class="cpp hljs">STATIC <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mp_map_elem_t</span></span> mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(<span class="hljs-number"><span class="hljs-number">10</span></span>) }, };</code> </pre> <br><p>  Testing: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.magic_number <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><h2>  Functions </h2><br><p>  Adding a function to a module follows the general principle: declare, wrap, add (I give a slightly more complicated example than in the documentation). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  STATIC mp_obj_t conditional_add_one(mp_obj_t value) { //   int.         -  :   . int value_int = mp_obj_get_int(value); value_int ++; if (value_int == 10) { //  None return mp_const_none; } //   int return mp_obj_new_int(value); } //    .     // runtime.h   . STATIC MP_DEFINE_CONST_FUN_OBJ_1(conditional_add_one_obj, conditional_add_one); //  STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, };</span></span></code> </pre> <br><p>  Testim: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">9</span></span>) &gt;&gt;&gt;</code> </pre> <br><h2>  Classes (types) </h2><br><p>  With classes (types), everything is also relatively simple.  Here is an example from the documentation (well, almost): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = {}; //   STATIC MP_DEFINE_CONST_DICT(mymodule_hello_locals_dict, mymodule_hello_locals_dict_table); // ,  ,   const mp_obj_type_t mymodule_helloObj_type = { //    { &amp;mp_type_type }, // : helloObj .name = MP_QSTR_helloObj, //  .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, }; //    STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;mymodule_helloObj_type }, };</span></span></code> </pre> <br><p>  Testim: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>mymodule.helloObj &lt;type <span class="hljs-string"><span class="hljs-string">'helloObj'</span></span>&gt;</code> </pre> <br><p>  The resulting type can be inherited, compared, but it has neither a constructor nor any associated data.  The data is added "side by side" with the designer: it is proposed to create a separate structure in which the Python type will be stored separately and a random data set separately. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  -. ,    typedef struct _mymodule_hello_obj_t { //   mp_obj_base_t base; // -  uint8_t hello_number; } mymodule_hello_obj_t;</span></span></code> </pre> <br><p>  How to interact with this data?  One of the most difficult ways is through the constructor. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// -,   (,  ,   mymodule_helloObj_type //   ,     - ),   (args  kwargs)  //        : args, kwargs STATIC mp_obj_t mymodule_hello_make_new( const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args ) { //    mp_arg_check_num(n_args, n_kw, 1, 1, true); //   mymodule_hello_obj_t *self = m_new_obj(mymodule_hello_obj_t); //     self-&gt;base.type = &amp;mymodule_hello_type; //   self-&gt;hello_number = mp_obj_get_int(args[0]) //   return MP_OBJ_FROM_PTR(self); //    __init__, ,  } //      make_new const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, //  .make_new = mymodule_hello_make_new, };</span></span></code> </pre> <br><p>  Of the other fields, there is another <code>.print</code> , and I suppose the rest of the magic of <code>Python3</code> . </p><br><p>  But <code>make_new</code> is not at all necessary to get an object instance: initialization can be done in an arbitrary function.  Here is a good example from <code>micropython/ports/esp32/modsocket.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   :       STATIC mp_obj_t get_socket(size_t n_args, const mp_obj_t *args) { socket_obj_t *sock = m_new_obj_with_finaliser(socket_obj_t); sock-&gt;base.type = &amp;socket_type; sock-&gt;domain = AF_INET; sock-&gt;type = SOCK_STREAM; sock-&gt;proto = 0; sock-&gt;peer_closed = false; if (n_args &gt; 0) { sock-&gt;domain = mp_obj_get_int(args[0]); if (n_args &gt; 1) { sock-&gt;type = mp_obj_get_int(args[1]); if (n_args &gt; 2) { sock-&gt;proto = mp_obj_get_int(args[2]); } } } sock-&gt;fd = lwip_socket(sock-&gt;domain, sock-&gt;type, sock-&gt;proto); if (sock-&gt;fd &lt; 0) { exception_from_errno(errno); } _socket_settimeout(sock, UINT64_MAX); return MP_OBJ_FROM_PTR(sock); } //     0-3  STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(get_socket_obj, 0, 3, get_socket);</span></span></code> </pre> <br><h2>  Bound methods </h2><br><p>  The next step is to add attached methods.  However, this is not much different from all other methods.  We return to the example from the documentation: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    :     1 (self) STATIC mp_obj_t mymodule_hello_increment(mp_obj_t self_in) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); self-&gt;hello_number += 1; return mp_const_none; } //     MP_DEFINE_CONST_FUN_OBJ_1(mymodule_hello_increment_obj, mymodule_hello_increment); //      'inc' STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR_inc), (mp_obj_t)&amp;mymodule_hello_increment_obj }, }</span></span></code> </pre> <br><p>  Everything! </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.inc()</code> </pre> <br><h2>  All other attributes: <strong>getattr</strong> , <strong>setattr</strong> </h2><br><p>  How about adding non-functions, using <code>@property</code> and generally own <code>__getattr__</code> ?  Please: this is done manually bypassing <code>mymodule_hello_locals_dict_table</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ... STATIC void mymodule_hello_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); if (dest[0] != MP_OBJ_NULL) { // __setattr__ if (attr == MP_QSTR_val) { self-&gt;val = dest[1]; dest[0] = MP_OBJ_NULL; } } else { // __getattr__ if (attr == MP_QSTR_val) { dest[0] = self-&gt;val; } } } // ...     attr const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, //     //.locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, .make_new = mymodule_hello_make_new, //   - attr .attr = mymodule_hello_attr, };</span></span></code> </pre><br><p>  Something hurt laconic attr turned out, you say.  Where are all these <code>mp_raise_AttributeError</code> ( <em>note</em> : there is no such function)?  In fact, <code>AttributeError</code> will be called automatically.  The secret is that <code>dest</code> is an array of two elements.  The first element has the meaning of "output", write-only: it takes the value <code>MP_OBJ_SENTINEL</code> if the value needs to be written and <code>MP_OBJ_NULL</code> if it needs to be read.  Accordingly, at the output of the function <code>MP_OBJ_NULL</code> is expected in the first case and something <code>mp_obj_t</code> in the second.  The second element is ‚Äúinput‚Äù, read-only: accepts the value of the object to be written if the value is to be written and <code>MP_OBJ_NULL</code> if it is to be read.  You do not need to change it. </p><br><p>  That's it, you can check: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.val = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; x.val <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  The most interesting thing is that Tab completion in the REPL still works and suggests <code>.val</code> !  I honestly am not an expert in C, so I can only guess how this happens (by redefining the operator '=='). </p><br><h2>  Port </h2><br><p>  Returning to the A9G module, I <a href="https://github.com/pulkin/micropython/tree/master/ports/gprs_a9">described the</a> support for all the basic functions, namely, SMS, GPRS (usockets), GPS, power management.  Now you can pour something like this on the module and it will work: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cellular <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usocket <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gps <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> machine <span class="hljs-comment"><span class="hljs-comment">#   print("Waiting network registration ...") while not c.is_network_registered(): time.sleep(1) time.sleep(2) #  GPRS print("Activating ...") c.gprs_activate("internet", "", "") print("Local IP:", sock.get_local_ip()) #  GPS gps.on() #    thingspeak host = "api.thingspeak.com" api_key = "some-api-key" fields = ('latitude', 'longitude', 'battery', 'sat_visible', 'sat_tracked') #  ,      ! fields = dict(zip(fields, map(lambda x: "field{}".format(x+1), range(len(fields))) )) x, y = gps.get_location() level = machine.get_input_voltage()[1] sats_vis, sats_tracked = gps.get_satellites() s = sock.socket() print("Connecting ...") s.connect((host, 80)) print("Sending ...") #      ,     HTTP.           HTTP, SSL   print("Sent:", s.send("GET /update?api_key={}&amp;{latitude}={:f}&amp;{longitude}={:f}&amp;{battery}={:f}&amp;{sat_visible}={:d}&amp;{sat_tracked}={:d} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n".format( api_key, x, y, level, sats_vis, sats_tracked, host, **fields ))) print("Receiving ...") print("Received:", s.recv(128)) s.close()</span></span></code> </pre> <br><p>  The project welcomes all possible assistance.  If you like the project and / or this article - do not forget to leave a <a href="https://github.com/pulkin/micropython/tree/master/ports/gprs_a9">Like on githabe</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/446090/">https://habr.com/ru/post/446090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446076/index.html">QlikView. Conditional Formatting "Like Excel"</a></li>
<li><a href="../446078/index.html">"Sound": discussing a podcast about audio equipment</a></li>
<li><a href="../446080/index.html">In the US, the court recommended banning the import of certain iPhone models due to Apple‚Äôs violation of Qualcomm patents.</a></li>
<li><a href="../446082/index.html">Tale of semirings</a></li>
<li><a href="../446088/index.html">Things I don't know in 2018</a></li>
<li><a href="../446092/index.html">Only without hands! Robots that do not repeat user actions</a></li>
<li><a href="../446094/index.html">With the periodic table in life</a></li>
<li><a href="../446098/index.html">Soviet Mission Control Center of Vostok and Voskhod times</a></li>
<li><a href="../446100/index.html">Automatic creation of Android and iOS localization files from Excel spreadsheet</a></li>
<li><a href="../446104/index.html">The Python Paradox (The Python Paradox)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>